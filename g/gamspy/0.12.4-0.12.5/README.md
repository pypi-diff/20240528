# Comparing `tmp/gamspy-0.12.4-py3-none-any.whl.zip` & `tmp/gamspy-0.12.5-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,53 +1,54 @@
-Zip file size: 88748 bytes, number of entries: 51
+Zip file size: 89580 bytes, number of entries: 52
 -rw-rw-r--  2.0 unx     1221 b- defN 24-May-13 10:04 gamspy/__init__.py
 -rw-rw-r--  2.0 unx      112 b- defN 24-May-13 10:04 gamspy/__main__.py
--rw-rw-r--  2.0 unx    30754 b- defN 24-May-13 10:04 gamspy/_container.py
+-rw-rw-r--  2.0 unx    31894 b- defN 24-May-28 07:47 gamspy/_container.py
+-rw-rw-r--  2.0 unx     2761 b- defN 24-May-28 07:47 gamspy/_extrinsic.py
 -rw-rw-r--  2.0 unx    11000 b- defN 24-Apr-28 14:46 gamspy/_miro.py
--rw-rw-r--  2.0 unx    23550 b- defN 24-May-13 10:04 gamspy/_model.py
--rw-rw-r--  2.0 unx    10118 b- defN 24-May-13 10:04 gamspy/_model_instance.py
--rw-rw-r--  2.0 unx     9952 b- defN 24-May-13 10:04 gamspy/_options.py
--rw-rw-r--  2.0 unx     9750 b- defN 24-May-13 10:04 gamspy/_validation.py
--rw-rw-r--  2.0 unx     5580 b- defN 24-May-13 10:04 gamspy/exceptions.py
--rw-rw-r--  2.0 unx     9428 b- defN 24-May-13 10:04 gamspy/utils.py
+-rw-rw-r--  2.0 unx    21751 b- defN 24-May-28 07:47 gamspy/_model.py
+-rw-rw-r--  2.0 unx    10118 b- defN 24-May-28 06:41 gamspy/_model_instance.py
+-rw-rw-r--  2.0 unx     9308 b- defN 24-May-28 07:47 gamspy/_options.py
+-rw-rw-r--  2.0 unx    10024 b- defN 24-May-28 07:47 gamspy/_validation.py
+-rw-rw-r--  2.0 unx     5747 b- defN 24-May-28 07:47 gamspy/exceptions.py
+-rw-rw-r--  2.0 unx     9428 b- defN 24-May-28 06:41 gamspy/utils.py
 -rw-rw-r--  2.0 unx      109 b- defN 24-Mar-24 21:59 gamspy/version.py
 -rw-rw-r--  2.0 unx      394 b- defN 24-May-13 10:04 gamspy/_algebra/__init__.py
--rw-rw-r--  2.0 unx     2067 b- defN 24-May-13 10:04 gamspy/_algebra/condition.py
+-rw-rw-r--  2.0 unx     2189 b- defN 24-May-28 07:47 gamspy/_algebra/condition.py
 -rw-rw-r--  2.0 unx     2091 b- defN 24-May-13 10:04 gamspy/_algebra/domain.py
--rw-rw-r--  2.0 unx     8536 b- defN 24-May-13 10:04 gamspy/_algebra/expression.py
+-rw-rw-r--  2.0 unx     8139 b- defN 24-May-28 07:47 gamspy/_algebra/expression.py
 -rw-rw-r--  2.0 unx      867 b- defN 24-May-13 10:04 gamspy/_algebra/number.py
 -rw-rw-r--  2.0 unx     3640 b- defN 24-May-13 10:04 gamspy/_algebra/operable.py
 -rw-rw-r--  2.0 unx     8292 b- defN 24-May-13 10:04 gamspy/_algebra/operation.py
 -rw-rw-r--  2.0 unx        0 b- defN 24-Mar-24 21:59 gamspy/_backend/__init__.py
--rw-rw-r--  2.0 unx     4295 b- defN 24-May-13 10:04 gamspy/_backend/backend.py
--rw-rw-r--  2.0 unx    25633 b- defN 24-May-13 10:04 gamspy/_backend/engine.py
--rw-rw-r--  2.0 unx     2993 b- defN 24-May-13 10:04 gamspy/_backend/local.py
--rw-rw-r--  2.0 unx    14787 b- defN 24-May-13 10:04 gamspy/_backend/neos.py
+-rw-rw-r--  2.0 unx     4298 b- defN 24-May-28 07:47 gamspy/_backend/backend.py
+-rw-rw-r--  2.0 unx    25878 b- defN 24-May-28 07:47 gamspy/_backend/engine.py
+-rw-rw-r--  2.0 unx     3292 b- defN 24-May-28 07:47 gamspy/_backend/local.py
+-rw-rw-r--  2.0 unx    15076 b- defN 24-May-28 07:47 gamspy/_backend/neos.py
 -rw-rw-r--  2.0 unx       35 b- defN 24-May-13 10:04 gamspy/_cli/__init__.py
--rw-rw-r--  2.0 unx    14378 b- defN 24-May-13 10:04 gamspy/_cli/cmdline.py
+-rw-rw-r--  2.0 unx    14434 b- defN 24-May-28 07:47 gamspy/_cli/cmdline.py
 -rw-rw-r--  2.0 unx     3473 b- defN 24-May-13 10:04 gamspy/_cli/util.py
 -rw-rw-r--  2.0 unx      450 b- defN 24-May-13 10:04 gamspy/_symbols/__init__.py
--rw-rw-r--  2.0 unx     4970 b- defN 24-May-13 10:04 gamspy/_symbols/alias.py
--rw-rw-r--  2.0 unx    19863 b- defN 24-May-13 10:04 gamspy/_symbols/equation.py
--rw-rw-r--  2.0 unx    12839 b- defN 24-May-13 10:04 gamspy/_symbols/parameter.py
--rw-rw-r--  2.0 unx    19664 b- defN 24-May-13 10:04 gamspy/_symbols/set.py
--rw-rw-r--  2.0 unx     1527 b- defN 24-May-13 10:04 gamspy/_symbols/symbol.py
+-rw-rw-r--  2.0 unx     4633 b- defN 24-May-28 07:47 gamspy/_symbols/alias.py
+-rw-rw-r--  2.0 unx    19487 b- defN 24-May-28 07:47 gamspy/_symbols/equation.py
+-rw-rw-r--  2.0 unx    12477 b- defN 24-May-28 07:47 gamspy/_symbols/parameter.py
+-rw-rw-r--  2.0 unx    19309 b- defN 24-May-28 07:47 gamspy/_symbols/set.py
+-rw-rw-r--  2.0 unx     1527 b- defN 24-May-28 06:41 gamspy/_symbols/symbol.py
 -rw-rw-r--  2.0 unx     2785 b- defN 24-Apr-28 14:46 gamspy/_symbols/universe_alias.py
--rw-rw-r--  2.0 unx    16010 b- defN 24-May-13 10:04 gamspy/_symbols/variable.py
+-rw-rw-r--  2.0 unx    15641 b- defN 24-May-28 07:47 gamspy/_symbols/variable.py
 -rw-rw-r--  2.0 unx      391 b- defN 24-May-13 10:04 gamspy/_symbols/implicits/__init__.py
 -rw-rw-r--  2.0 unx     3263 b- defN 24-May-13 10:04 gamspy/_symbols/implicits/implicit_equation.py
--rw-rw-r--  2.0 unx     2796 b- defN 24-May-13 10:04 gamspy/_symbols/implicits/implicit_parameter.py
+-rw-rw-r--  2.0 unx     2796 b- defN 24-May-27 19:10 gamspy/_symbols/implicits/implicit_parameter.py
 -rw-rw-r--  2.0 unx     1320 b- defN 24-May-13 10:04 gamspy/_symbols/implicits/implicit_set.py
 -rw-rw-r--  2.0 unx      479 b- defN 24-Apr-26 14:21 gamspy/_symbols/implicits/implicit_symbol.py
 -rw-rw-r--  2.0 unx     2666 b- defN 24-May-13 10:04 gamspy/_symbols/implicits/implicit_variable.py
 -rw-rw-r--  2.0 unx     2392 b- defN 24-May-13 10:04 gamspy/math/__init__.py
--rw-rw-r--  2.0 unx     4525 b- defN 24-May-13 10:04 gamspy/math/log_power.py
+-rw-rw-r--  2.0 unx     4498 b- defN 24-May-28 07:47 gamspy/math/log_power.py
 -rw-rw-r--  2.0 unx    15805 b- defN 24-May-13 10:04 gamspy/math/misc.py
 -rw-rw-r--  2.0 unx     2666 b- defN 24-May-13 10:04 gamspy/math/probability.py
 -rw-rw-r--  2.0 unx     2249 b- defN 24-May-13 10:04 gamspy/math/trigonometric.py
--rw-r--r--  2.0 unx     1189 b- defN 24-May-13 10:05 gamspy-0.12.4.dist-info/LICENSE
--rw-rw-r--  2.0 unx     5717 b- defN 24-May-13 10:05 gamspy-0.12.4.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 24-May-13 10:05 gamspy-0.12.4.dist-info/WHEEL
--rw-r--r--  2.0 unx       52 b- defN 24-May-13 10:05 gamspy-0.12.4.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        7 b- defN 24-May-13 10:05 gamspy-0.12.4.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     4220 b- defN 24-May-13 10:05 gamspy-0.12.4.dist-info/RECORD
-51 files, 330992 bytes uncompressed, 82102 bytes compressed:  75.2%
+-rw-r--r--  2.0 unx     1189 b- defN 24-May-28 08:48 gamspy-0.12.5.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     6293 b- defN 24-May-28 08:48 gamspy-0.12.5.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 24-May-28 08:48 gamspy-0.12.5.dist-info/WHEEL
+-rw-r--r--  2.0 unx       52 b- defN 24-May-28 08:48 gamspy-0.12.5.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        7 b- defN 24-May-28 08:48 gamspy-0.12.5.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     4298 b- defN 24-May-28 08:48 gamspy-0.12.5.dist-info/RECORD
+52 files, 332336 bytes uncompressed, 82818 bytes compressed:  75.1%
```

## zipnote {}

```diff
@@ -3,14 +3,17 @@
 
 Filename: gamspy/__main__.py
 Comment: 
 
 Filename: gamspy/_container.py
 Comment: 
 
+Filename: gamspy/_extrinsic.py
+Comment: 
+
 Filename: gamspy/_miro.py
 Comment: 
 
 Filename: gamspy/_model.py
 Comment: 
 
 Filename: gamspy/_model_instance.py
@@ -129,26 +132,26 @@
 
 Filename: gamspy/math/probability.py
 Comment: 
 
 Filename: gamspy/math/trigonometric.py
 Comment: 
 
-Filename: gamspy-0.12.4.dist-info/LICENSE
+Filename: gamspy-0.12.5.dist-info/LICENSE
 Comment: 
 
-Filename: gamspy-0.12.4.dist-info/METADATA
+Filename: gamspy-0.12.5.dist-info/METADATA
 Comment: 
 
-Filename: gamspy-0.12.4.dist-info/WHEEL
+Filename: gamspy-0.12.5.dist-info/WHEEL
 Comment: 
 
-Filename: gamspy-0.12.4.dist-info/entry_points.txt
+Filename: gamspy-0.12.5.dist-info/entry_points.txt
 Comment: 
 
-Filename: gamspy-0.12.4.dist-info/top_level.txt
+Filename: gamspy-0.12.5.dist-info/top_level.txt
 Comment: 
 
-Filename: gamspy-0.12.4.dist-info/RECORD
+Filename: gamspy-0.12.5.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## gamspy/_container.py

```diff
@@ -6,22 +6,22 @@
 import sys
 import uuid
 from typing import TYPE_CHECKING, Any, Literal
 
 import gams.transfer as gt
 from gams import DebugLevel, GamsCheckpoint, GamsJob, GamsWorkspace
 from gams.core import gdx
-from gams.core.opt import optResetStr
 
 import gamspy as gp
 import gamspy._miro as miro
 import gamspy.utils as utils
 from gamspy._backend.backend import backend_factory
+from gamspy._extrinsic import ExtrinsicLibrary
 from gamspy._miro import MiroJSONEncoder
-from gamspy._options import Options, _map_options
+from gamspy._options import Options
 from gamspy._symbols.symbol import Symbol
 from gamspy.exceptions import ValidationError
 
 if TYPE_CHECKING:
     import pandas as pd
 
     from gamspy import (
@@ -93,15 +93,14 @@
         system_directory = (
             system_directory
             if system_directory
             else utils._get_gamspy_base_directory()
         )
 
         self._unsaved_statements: list = []
-        self._is_first_run = True
         self.miro_protect = miro_protect
 
         # import symbols from arbitrary gams code
         self._import_symbols: list[str] = []
 
         super().__init__(system_directory=system_directory)
 
@@ -119,29 +118,23 @@
             self._save_to,
             self._restart_from,
             self._gdx_in,
             self._gdx_out,
         ) = self._setup_paths()
 
         self._job: GamsJob | None = None
-        self._is_first_run = True
         self._temp_container = gt.Container(
             system_directory=self.system_directory
         )
 
         if options is not None and not isinstance(options, Options):
             raise TypeError(
                 f"`options` must be of type Option but found {type(options)}"
             )
-        self._options = options
-        self._gams_options = _map_options(
-            self.workspace,
-            global_options=options,
-            is_seedable=True,
-        )
+        self._options = Options() if options is None else options
 
         # needed for miro
         self._miro_input_symbols: list[str] = []
         self._miro_output_symbols: list[str] = []
         if load_from is not None:
             self.read(load_from)
             self._run()
@@ -191,24 +184,35 @@
             self[name]._is_dirty = False
 
         super().write(
             os.path.join(data_path, "default.gdx"),
             symbols,
         )
 
-    def _addGamsCode(
+    def addGamsCode(
         self, gams_code: str, import_symbols: list[str] = []
     ) -> None:
         """
         Adds an arbitrary GAMS code to the generate .gms file
 
         Parameters
         ----------
         gams_code : str
-        import_symbols : List[str], optional
+            Gams code that you want to insert.
+        import_symbols : list[str], optional
+            Symbols to be imported to the container from GAMS.
+
+        Examples
+        --------
+        >>> from gamspy import Container
+        >>> m = Container()
+        >>> m.addGamsCode("scalar piHalf / [pi/2] /;", import_symbols=["piHalf"])
+        >>> m["piHalf"].toValue()
+        1.5707963267948966
+
         """
         if import_symbols is not None and (
             not isinstance(import_symbols, list)
             or any(not isinstance(symbol, str) for symbol in import_symbols)
         ):
             raise ValidationError("import_symbols must be a list of strings")
 
@@ -357,23 +361,20 @@
                     modified_names.append(symbol.alias_with.name)
 
                 modified_names.append(name)
 
         return dirty_names, modified_names
 
     def _run(self, keep_flags: bool = False) -> pd.DataFrame | None:
-        runner = backend_factory(self, self._gams_options)
-
+        runner = backend_factory(self, self._options)
         summary = runner.solve(is_implicit=True, keep_flags=keep_flags)
 
-        if not self._is_first_run:
-            # Required for correct seeding
-            optResetStr(self._gams_options._opt, "seed")
-
-        self._is_first_run = False
+        if self._options and self._options.seed is not None:
+            # Required for correct seeding. Seed can only be set in the first run.
+            self._options.seed = None
 
         if IS_MIRO_INIT:
             self._write_default_gdx_miro()  # pragma: no cover
 
         return summary
 
     def _swap_checkpoints(self):
@@ -402,15 +403,15 @@
         string = f"$onMultiR\n$onUNDF\n$gdxIn {gdx_in}\n"
         for statement in self._unsaved_statements:
             if isinstance(statement, str):
                 string += statement + "\n"
             elif isinstance(statement, gp.UniverseAlias):
                 continue
             else:
-                string += statement.getStatement() + "\n"
+                string += statement.getDeclaration() + "\n"
 
         for symbol_name in modified_names:
             symbol = self[symbol_name]
             if isinstance(symbol, Symbol) and not symbol_name.startswith(
                 gp.Model._generate_prefix
             ):
                 if (
@@ -429,43 +430,138 @@
         if self._miro_output_symbols and not IS_MIRO_INIT and MIRO_GDX_OUT:
             string += miro.get_unload_output_str(self)
 
         self._gams_string += string
 
         return string
 
-    def gamsJobName(self) -> str | None:
+    def read(
+        self,
+        load_from: str,
+        symbol_names: list[str] | None = None,
+        load_records: bool = True,
+        mode: str | None = None,
+        encoding: str | None = None,
+    ):
         """
-        Returns the name of the latest GAMS job that was executed
+        Reads specified symbols from the gdx file. If symbol_names are
+        not provided, it reads all symbols from the gdx file.
+
+        Parameters
+        ----------
+        load_from : str
+        symbol_names : List[str], optional
+        load_records : bool
+        mode : str, optional
+        encoding : str, optional
+
+        Examples
+        --------
+        >>> import gamspy as gp
+        >>> m = gp.Container()
+        >>> i = gp.Set(m, "i", records=['i1', 'i2'])
+        >>> m.write("test.gdx")
+        >>> new_container = gp.Container()
+        >>> new_container.read("test.gdx")
+        >>> new_container.data.keys() == m.data.keys()
+        True
 
-        Returns
-        -------
-        str | None
         """
-        return self._job.name if self._job is not None else None
+        super().read(load_from, symbol_names, load_records, mode, encoding)
+        self._cast_symbols(symbol_names)
 
-    def gdxInputPath(self) -> str:
+    def write(
+        self,
+        write_to: str,
+        symbol_names: list[str] | None = None,
+        compress: bool = False,
+        mode: str | None = None,
+        eps_to_zero: bool = True,
+    ):
         """
-        Path to the input gdx file
+        Writes specified symbols to the gdx file. If symbol_names are
+        not provided, it writes all symbols to the gdx file.
+
+        Parameters
+        ----------
+        write_to : str
+        symbol_names : List[str], optional
+        compress : bool
+        mode : str, optional
+        eps_to_zero : bool
+
+        Examples
+        --------
+        >>> import gamspy as gp
+        >>> m = gp.Container()
+        >>> i = gp.Set(m, "i", records=['i1', 'i2'])
+        >>> m.write("test.gdx")
 
-        Returns
-        -------
-        str
         """
-        return self._gdx_in
+        dirty_names, _ = self._get_touched_symbol_names()
 
-    def gdxOutputPath(self) -> str:
+        if len(dirty_names) > 0:
+            self._run(keep_flags=True)
+
+        super().write(
+            write_to,
+            symbol_names,
+            compress,
+            mode=mode,
+            eps_to_zero=eps_to_zero,
+        )
+
+    def generateGamsString(self, show_raw: bool = False) -> str:
         """
-        Path to the output gdx file
+        Generates the GAMS code
+
+        Parameters
+        ----------
+        show_raw : bool, optional
+            Shows the raw model without data and other necessary
+            GAMS statements, by default False.
 
         Returns
         -------
         str
         """
-        return self._gdx_out
+        if not show_raw:
+            return self._gams_string
+
+        return utils._filter_gams_string(self._gams_string)
+
+    def loadRecordsFromGdx(
+        self,
+        load_from: str,
+        symbol_names: list[str] | None = None,
+    ):
+        """
+        Loads data of the given symbols from a gdx file. If no
+        symbol names are given, data of all symbols are loaded.
+
+        Parameters
+        ----------
+        load_from : str
+            Path to the gdx file
+        symbols : List[str], optional
+            Symbols whose data will be load from gdx, by default None
+
+        Examples
+        --------
+        >>> from gamspy import Container, Set
+        >>> m = Container()
+        >>> i = Set(m, "i", records=["i1", "i2"])
+        >>> m.write("test.gdx")
+        >>> m2 = Container()
+        >>> m2.loadRecordsFromGdx("test.gdx")
+        >>> print(i.records.equals(m2["i"].records))
+        True
+
+        """
+        self._load_records_from_gdx(load_from, symbol_names, user_invoked=True)
 
     def addAlias(self, name: str, alias_with: Set | Alias) -> Alias:
         """
         Creates a new Alias and adds it to the container
 
         Parameters
         ----------
@@ -883,38 +979,19 @@
         try:
             shutil.copy(self._gdx_out, m._gdx_out)
         except FileNotFoundError:
             pass
 
         # if already defined equations exist, add them to .gms file
         for equation in self.getEquations():
-            if equation._assignment is not None:
-                m._add_statement(equation._assignment)
+            if equation._definition is not None:
+                m._add_statement(equation._definition)
 
         return m
 
-    def generateGamsString(self, show_raw: bool = False) -> str:
-        """
-        Generates the GAMS code
-
-        Parameters
-        ----------
-        show_raw : bool, optional
-            Shows the raw model without data and other necessary
-            GAMS statements, by default False.
-
-        Returns
-        -------
-        str
-        """
-        if not show_raw:
-            return self._gams_string
-
-        return utils._filter_gams_string(self._gams_string)
-
     def getEquations(self) -> list[Equation]:
         """
         Returns all equation symbols in the Container.
 
         Returns
         -------
         list[Equation]
@@ -951,112 +1028,67 @@
                 self[name].modified = True
 
         self._temp_container.data = {}
 
         if user_invoked:
             self._run()
 
-    def loadRecordsFromGdx(
-        self,
-        load_from: str,
-        symbol_names: list[str] | None = None,
-    ) -> None:
+    def importExtrinsicLibrary(
+        self, lib_path: str, functions: dict[str, str]
+    ) -> ExtrinsicLibrary:
         """
-        Loads data of the given symbols from a gdx file. If no
-        symbol names are given, data of all symbols are loaded.
+        Imports an extrinsic library to the GAMS environment.
 
         Parameters
         ----------
-        load_from : str
-            Path to the gdx file
-        symbols : List[str], optional
-            Symbols whose data will be load from gdx, by default None
-
-        Examples
-        --------
-        >>> from gamspy import Container, Set
-        >>> m = Container()
-        >>> i = Set(m, "i", records=["i1", "i2"])
-        >>> m.write("test.gdx")
-        >>> m2 = Container()
-        >>> m2.loadRecordsFromGdx("test.gdx")
-        >>> print(i.records.equals(m2["i"].records))
-        True
+        lib_path : str
+            Path to the .so, .dylib or .dll file that contains the extrinsic library
+        functions : dict[str, str]
+            Names of the functions as a dictionary. Key is the desired function name in GAMSPy
+            and value is the function name in the extrinsic library.
 
-        """
-        self._load_records_from_gdx(load_from, symbol_names, user_invoked=True)
+        Returns
+        -------
+        ExtrinsicLibrary
 
-    def read(
-        self,
-        load_from: str,
-        symbol_names: list[str] | None = None,
-        load_records: bool = True,
-        mode: str | None = None,
-        encoding: str | None = None,
-    ) -> None:
+        Raises
+        ------
+        FileNotFoundError
+            In case the extrinsic library does not exist in the given path.
         """
-        Reads specified symbols from the gdx file. If symbol_names are
-        not provided, it reads all symbols from the gdx file.
+        if not os.path.exists(lib_path):
+            raise FileNotFoundError(f"`{lib_path}` is not a valid path.")
 
-        Parameters
-        ----------
-        load_from : str
-        symbol_names : List[str], optional
-        load_records : bool
-        mode : str, optional
-        encoding : str, optional
+        external_lib = ExtrinsicLibrary(lib_path, functions)
+        self._add_statement(external_lib)
 
-        Examples
-        --------
-        >>> import gamspy as gp
-        >>> m = gp.Container()
-        >>> i = gp.Set(m, "i", records=['i1', 'i2'])
-        >>> m.write("test.gdx")
-        >>> new_container = gp.Container()
-        >>> new_container.read("test.gdx")
-        >>> new_container.data.keys() == m.data.keys()
-        True
+        return external_lib
 
+    def gamsJobName(self) -> str | None:
         """
-        super().read(load_from, symbol_names, load_records, mode, encoding)
-        self._cast_symbols(symbol_names)
+        Returns the name of the latest GAMS job that was executed
 
-    def write(
-        self,
-        write_to: str,
-        symbol_names: list[str] | None = None,
-        compress: bool = False,
-        mode: str | None = None,
-        eps_to_zero: bool = True,
-    ) -> None:
+        Returns
+        -------
+        str | None
         """
-        Writes specified symbols to the gdx file. If symbol_names are
-        not provided, it writes all symbols to the gdx file.
-
-        Parameters
-        ----------
-        write_to : str
-        symbol_names : List[str], optional
-        compress : bool
-        mode : str, optional
-        eps_to_zero : bool
+        return self._job.name if self._job is not None else None
 
-        Examples
-        --------
-        >>> import gamspy as gp
-        >>> m = gp.Container()
-        >>> i = gp.Set(m, "i", records=['i1', 'i2'])
-        >>> m.write("test.gdx")
+    def gdxInputPath(self) -> str:
+        """
+        Path to the input gdx file
 
+        Returns
+        -------
+        str
         """
-        dirty_names, _ = self._get_touched_symbol_names()
+        return self._gdx_in
 
-        if len(dirty_names) > 0:
-            self._run(keep_flags=True)
+    def gdxOutputPath(self) -> str:
+        """
+        Path to the output gdx file
 
-        super().write(
-            write_to,
-            symbol_names,
-            compress,
-            mode=mode,
-            eps_to_zero=eps_to_zero,
-        )
+        Returns
+        -------
+        str
+        """
+        return self._gdx_out
```

## gamspy/_model.py

```diff
@@ -1,27 +1,25 @@
 from __future__ import annotations
 
 import io
 import logging
 import os
 import uuid
-import warnings
 from enum import Enum
 from typing import TYPE_CHECKING, Iterable, Literal
 
-from gams import GamsExceptionExecution, GamsOptions
+from gams import GamsExceptionExecution
 
 import gamspy as gp
 import gamspy._algebra.expression as expression
 import gamspy._algebra.operation as operation
 import gamspy._validation as validation
 import gamspy.utils as utils
 from gamspy._backend.backend import backend_factory
 from gamspy._model_instance import ModelInstance
-from gamspy._options import _map_options
 from gamspy.exceptions import ValidationError
 
 if TYPE_CHECKING:
     import pandas as pd
 
     from gamspy import Container, Equation, Parameter, Variable
     from gamspy._algebra.expression import Expression
@@ -365,56 +363,14 @@
             variable.modified = False
             self.equations.append(equation)
 
             return variable
 
         return assignment
 
-    def _prepare_gams_options(
-        self,
-        solver: str | None = None,
-        backend: str = "local",
-        options: Options | None = None,
-        solver_options: dict | None = None,
-        output: io.TextIOWrapper | None = None,
-        create_log_file: bool = False,
-    ) -> GamsOptions:
-        gams_options = _map_options(
-            self.container.workspace,
-            backend=backend,
-            options=options,
-            global_options=self.container._options,
-            is_seedable=False,
-            output=output,
-            create_log_file=create_log_file,
-        )
-
-        if solver:
-            gams_options.all_model_types = solver
-
-        if solver_options:
-            if solver is None:
-                raise ValidationError(
-                    "You need to provide a 'solver' to apply solver options."
-                )
-
-            solver_file_name = (
-                self.container.workspace.working_directory
-                + os.sep
-                + f"{solver.lower()}.123"
-            )
-
-            with open(solver_file_name, "w", encoding="utf-8") as solver_file:
-                for key, value in solver_options.items():
-                    solver_file.write(f"{key} {value}\n")
-
-            gams_options.optfile = 123
-
-        return gams_options
-
     def _validate_model(self, equations, problem, sense=None) -> tuple:
         if isinstance(problem, str):
             if problem.upper() not in gp.Problem.values():
                 raise ValueError(
                     f"Allowed problem types: {gp.Problem.values()} but found"
                     f" {problem}."
                 )
@@ -512,16 +468,16 @@
         ):
             self._objective_variable._is_dirty = True
 
         for equation in self.equations:
             if not equation.name.startswith(Model._generate_prefix):
                 equation._is_dirty = True
 
-            if equation._assignment is not None:
-                variables = equation._assignment._find_variables()
+            if equation._definition is not None:
+                variables = equation._definition._find_variables()
                 for name in variables:
                     if not name.startswith(Model._generate_prefix):
                         self.container[name]._is_dirty = True
 
         if self._matches:
             for equation, variable in self._matches.items():
                 equation._is_dirty = True
@@ -612,18 +568,17 @@
         solver: str | None = None,
         options: Options | None = None,
         solver_options: dict | None = None,
         model_instance_options: ModelInstanceOptions | dict | None = None,
         output: io.TextIOWrapper | None = None,
         backend: Literal["local", "engine", "neos"] = "local",
         client: EngineClient | NeosClient | None = None,
-        create_log_file: bool = False,
     ) -> pd.DataFrame | None:
         """
-        Generates the gams string, writes it to a file and runs it
+        Solves the model with given options.
 
         Parameters
         ----------
         solver : str, optional
             Solver name
         options : Options, optional
             GAMS options
@@ -633,53 +588,53 @@
             Model instance options
         output : TextIOWrapper, optional
             Output redirection target
         backend : str, optional
             Backend to run on
         client : EngineClient, NeosClient, optional
             EngineClient to communicate with GAMS Engine or NEOS Client to communicate with NEOS Server
-        create_log_file : bool
-            Allows creating a log file
 
         Returns
         -------
         DataFrame, optional
+            Summary of the solve
 
         Raises
         ------
         ValidationError
             In case engine_config is not provided for `engine` backend or
             neos_client is not provided for `neos` backend.
         ValueError
             In case problem is not in possible problem types
         ValueError
             In case sense is different than "MIN" or "MAX"
         """
         validation.validate_solver_args(solver, options, output)
+        validation.validate_model(self)
+
+        if options is None:
+            options = self.container._options
+
+        options._set_extra_options(
+            self.container.working_directory,
+            solver=solver,
+            solver_options=solver_options,
+        )
 
         if self._is_frozen:
             self.instance.solve(model_instance_options, output)
             return None
 
-        gams_options = self._prepare_gams_options(
-            solver,
-            backend,
-            options,
-            solver_options,
-            output=output,
-            create_log_file=create_log_file,
-        )
-
         self._append_solve_string()
         self._create_model_attributes()
         self._make_variable_and_equations_dirty()
 
         runner = backend_factory(
             self.container,
-            gams_options,
+            options,
             output,
             backend,
             client,
             self,
         )
 
         summary = runner.solve()
@@ -740,22 +695,7 @@
 
         model_str = f"Model {self.name}"
         if equations_str != "":
             model_str += f" / {equations_str} /"
         model_str += ";"
 
         return model_str
-
-    def getStatement(self) -> str:
-        """
-        Statement of the Model declaration
-
-        Returns
-        -------
-        str
-        """
-        warnings.warn(
-            "getStatement is going to be renamed in 0.12.5. Please use getDeclaration instead.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        return self.getDeclaration()
```

## gamspy/_options.py

```diff
@@ -1,33 +1,30 @@
 from __future__ import annotations
 
 import logging
 import os
 from pathlib import Path
-from typing import Literal
-from typing import Optional
-from typing import TYPE_CHECKING
-from typing import Union
-
-from gams import GamsOptions
-from gams import GamsWorkspace
-from gams import SymbolUpdateType
+from typing import TYPE_CHECKING, Any, Literal, Optional
+
+from gams import GamsOptions, GamsWorkspace, SymbolUpdateType
 from pydantic import BaseModel
 
+from gamspy.exceptions import ValidationError
+
 logger = logging.getLogger("Options")
 logger.setLevel(logging.INFO)
 
 formatter = logging.Formatter("[%(name)s - %(levelname)s] %(message)s")
 handler = logging.StreamHandler()
 handler.setFormatter(formatter)
 handler.setLevel(logging.INFO)
 logger.addHandler(handler)
 
 if TYPE_CHECKING:
-    import io
+    from gamspy._model import Problem
 
 multi_solve_map = {"replace": 0, "merge": 1, "clear": 2}
 
 # GAMSPy to GAMS Control mapping
 option_map = {
     "cns": "cns",
     "dnlp": "dnlp",
@@ -51,15 +48,14 @@
     "domain_violation_limit": "domlim",
     "job_time_limit": "etlim",
     "job_heap_limit": "heaplimit",
     "hold_fixed_variables": "holdfixed",
     "integer_variable_upper_bound": "intvarup",
     "iteration_limit": "iterlim",
     "keep_temporary_files": "keep",
-    "license": "license",
     "listing_file": "output",
     "log_file": "_logfile",
     "variable_listing_limit": "limcol",
     "equation_listing_limit": "limrow",
     "node_limit": "nodlim",
     "absolute_optimality_gap": "optca",
     "relative_optimality_gap": "optcr",
@@ -72,16 +68,14 @@
     "show_os_memory": "showosmemory",
     "solver_link_type": "solvelink",
     "merge_strategy": "solveopt",
     "step_summary": "stepsum",
     "suppress_compiler_listing": "suppress",
     "report_solver_status": "sysout",
     "threads": "threads",
-    "trace_file": "trace",
-    "trace_file_format": "traceopt",
     "write_listing_file": "_writeoutput",
     "zero_rounding_threshold": "zerores",
     "report_underflow": "zeroresrep",
 }
 
 
 class Options(BaseModel):
@@ -107,193 +101,160 @@
     domain_violation_limit: Optional[int] = None
     job_time_limit: Optional[float] = None
     job_heap_limit: Optional[float] = None
     hold_fixed_variables: Optional[bool] = None
     integer_variable_upper_bound: Optional[int] = None
     iteration_limit: Optional[int] = None
     keep_temporary_files: bool = False
-    license: Optional[str] = None
     listing_file: Optional[str] = None
     log_file: Optional[str] = None
     variable_listing_limit: Optional[int] = None
     equation_listing_limit: Optional[int] = None
     node_limit: Optional[int] = None
     absolute_optimality_gap: Optional[float] = None
     relative_optimality_gap: Optional[float] = None
     profile: Optional[int] = None
     profile_tolerance: Optional[float] = None
+    redirect_log_to_stdout: Optional[bool] = False
     time_limit: Optional[float] = None
     savepoint: Optional[Literal[0, 1, 2, 3, 4]] = None
     seed: Optional[int] = None
     report_solution: Literal[0, 1, 2] = 2
     show_os_memory: Literal[0, 1, 2] = 0
     solver_link_type: Optional[Literal[0, 1, 2, 3, 4, 5, 6, 7]] = None
     merge_strategy: Optional[Literal["replace", "merge", "clear"]] = None
     step_summary: Optional[bool] = None
     suppress_compiler_listing: bool = False
     report_solver_status: Optional[bool] = None
     threads: Optional[int] = None
-    trace_file: Optional[str] = None
-    trace_file_format: Optional[Literal[0, 1, 2, 3, 4, 5]] = None
     write_listing_file: bool = True
     zero_rounding_threshold: Optional[float] = None
     report_underflow: Optional[bool] = None
 
-    def _get_gams_compatible_options(self):
-        options_dict = self.model_dump()
-        if options_dict["allow_suffix_in_equation"] is not None:
-            allows_suffix = options_dict["allow_suffix_in_equation"]
-            options_dict["allow_suffix_in_equation"] = (
+    def _get_gams_compatible_options(self) -> dict:
+        gamspy_options = self.model_dump(exclude_none=True)
+        if "allow_suffix_in_equation" in gamspy_options:
+            allows_suffix = gamspy_options["allow_suffix_in_equation"]
+            gamspy_options["allow_suffix_in_equation"] = (
                 "on" if allows_suffix else "off"
             )
 
-        if options_dict["allow_suffix_in_limited_variables"] is not None:
-            allows_suffix = options_dict["allow_suffix_in_limited_variables"]
-            options_dict["allow_suffix_in_limited_variables"] = (
+        if "allow_suffix_in_limited_variables" in gamspy_options:
+            allows_suffix = gamspy_options["allow_suffix_in_limited_variables"]
+            gamspy_options["allow_suffix_in_limited_variables"] = (
                 "on" if allows_suffix else "off"
             )
 
-        if options_dict["merge_strategy"] is not None:
-            strategy = options_dict["merge_strategy"]
-            options_dict["merge_strategy"] = multi_solve_map[strategy]
-
-        if options_dict["listing_file"] is not None:
-            os.makedirs(Path(options_dict["listing_file"]).parent.absolute(), exist_ok=True)
-            if not os.path.isabs(options_dict["listing_file"]):
-                options_dict["listing_file"] = os.path.abspath(options_dict["listing_file"])
-
-        if options_dict["log_file"] is not None:
-            os.makedirs(Path(options_dict["log_file"]).parent.absolute(), exist_ok=True)
-            if not os.path.isabs(options_dict["log_file"]):
-                options_dict["log_file"] = os.path.abspath(options_dict["log_file"])
-
-        options_dict = {
-            option_map[key]: value for key, value in options_dict.items()  # type: ignore
-        }
-
-        return options_dict
-
-
-def _fix_log_option(
-    output: Union[io.TextIOWrapper, None],
-    create_log_file: bool,
-    options: GamsOptions,
-) -> GamsOptions:
-    if output is None:
-        options._logoption = 2 if create_log_file else 0
-    else:
-        options._logoption = 4 if create_log_file else 3
-
-    return options
-
-
-def _set_options(
-    gams_options: GamsOptions,
-    options: Options,
-    is_seedable: bool = True,
-):
-    options_dict = options._get_gams_compatible_options()
-    for option, value in options_dict.items():
-        if value is not None:
-            if option == "seed" and not is_seedable:
-                continue
-            setattr(gams_options, option.lower(), value)
-
-    return gams_options
-
-
-def _set_trace_options(
-    gams_options: GamsOptions,
-    options: Optional[Options],
-    backend: str,
-    workspace: GamsWorkspace,
-):
-    if options is not None:
-        if options.trace_file_format is not None:
-            if options.trace_file_format != 3:
-                logger.log(
-                    logging.INFO,
-                    "Trace file format is different than 3. GAMSPy will not"
-                    " return any summary!",
+        if "merge_strategy" in gamspy_options:
+            strategy = gamspy_options["merge_strategy"]
+            gamspy_options["merge_strategy"] = multi_solve_map[strategy]
+
+        if "listing_file" in gamspy_options:
+            os.makedirs(
+                Path(gamspy_options["listing_file"]).parent.absolute(),
+                exist_ok=True,
+            )
+            if not os.path.isabs(gamspy_options["listing_file"]):
+                gamspy_options["listing_file"] = os.path.abspath(
+                    gamspy_options["listing_file"]
                 )
-            trace_option = options.trace_file_format
-        else:
-            trace_option = 3
 
-        if options.trace_file is None:
-            trace_path = (
-                "trace.txt"
-                if backend in ["engine", "neos"]
-                else os.path.join(workspace.working_directory, "trace.txt")
-            )
-        else:
-            trace_path = (
-                options.trace_file
-                if backend in ["engine", "neos"]
-                else os.path.abspath(options.trace_file)
+        if "log_file" in gamspy_options:
+            os.makedirs(
+                Path(gamspy_options["log_file"]).parent.absolute(),
+                exist_ok=True,
             )
-    else:
-        trace_option = 3
-        trace_path = (
-            "trace.txt"
-            if backend in ["engine", "neos"]
-            else os.path.join(workspace.working_directory, "trace.txt")
-        )
+            if not os.path.isabs(gamspy_options["log_file"]):
+                gamspy_options["log_file"] = os.path.abspath(
+                    gamspy_options["log_file"]
+                )
 
-    gams_options.trace = trace_path
-    gams_options.traceopt = trace_option
+        gams_options = {
+            option_map[key]: value
+            for key, value in gamspy_options.items()
+            if key in option_map
+        }
 
-    return gams_options
+        gams_options["previouswork"] = (
+            1  # # In case GAMS version differs on backend
+        )
+        gams_options["traceopt"] = 3
 
+        if self.log_file:
+            if self.redirect_log_to_stdout:
+                gams_options["_logoption"] = 4
+            else:
+                gams_options["_logoption"] = 2
+        else:
+            if self.redirect_log_to_stdout:
+                gams_options["_logoption"] = 3
+            else:
+                gams_options["_logoption"] = 0
+
+        return gams_options
+
+    def _set_extra_options(
+        self,
+        working_directory: str,
+        solver: str | None,
+        solver_options: dict | None,
+    ):
+        extra_options: dict[str, Any] = {}
+
+        if solver is not None:
+            extra_options["solver"] = solver
+
+        if solver_options:
+            if solver is None:
+                raise ValidationError(
+                    "You need to provide a 'solver' to apply solver options."
+                )
 
-def _map_options(
-    workspace: GamsWorkspace,
-    backend: str = "local",
-    options: Union[Options, None] = None,
-    global_options: Union[Options, None] = None,
-    is_seedable: bool = True,
-    output: Optional[io.TextIOWrapper] = None,
-    create_log_file: bool = False,
-) -> GamsOptions:
-    """
-    Maps given GAMSPy options to GamsOptions
-
-    Parameters
-    ----------
-    options : Options | None
-        GAMSPy options
-    global_options : Options | None
-        Global options
-    is_seedable : bool, optional
-        only seedable at first run or in model.solve function, by default True
-
-    Returns
-    -------
-    GamsOptions
-
-    """
-    gams_options = GamsOptions(workspace)
-
-    if global_options is not None:
-        gams_options = _set_options(
-            gams_options,
-            global_options,
-            is_seedable,
-        )
+            solver_file_name = os.path.join(
+                working_directory, f"{solver.lower()}.123"
+            )
 
-    if options is not None:
-        gams_options = _set_options(gams_options, options, is_seedable)
+            with open(solver_file_name, "w", encoding="utf-8") as solver_file:
+                for key, value in solver_options.items():
+                    solver_file.write(f"{key} {value}\n")
+
+            extra_options["optfile"] = 123
+
+        self._extra_options = extra_options
+
+    def _get_gams_options(
+        self, workspace: GamsWorkspace, problem: Problem | None = None
+    ) -> GamsOptions:
+        gams_options = GamsOptions(workspace)
+
+        if hasattr(self, "_extra_options") and "solver" in self._extra_options:
+            solver = self._extra_options["solver"]
+            gams_options.all_model_types = solver
+            if (
+                solver.lower()
+                != getattr(gams_options, str(problem).lower()).lower()
+            ):
+                raise ValidationError(
+                    f"Given solver `{solver}` is not capable of solving given"
+                    f" problem type `{problem}`. See capability matrix "
+                    "(https://www.gams.com/latest/docs/S_MAIN.html#SOLVERS_MODEL_TYPES)"
+                    " to choose a suitable solver"
+                )
 
-    gams_options = _set_trace_options(
-        gams_options, options, backend, workspace
-    )
-    gams_options = _fix_log_option(output, create_log_file, gams_options)
-    gams_options.previouswork = 1  # In case GAMS version differs on backend
+        if (
+            hasattr(self, "_extra_options")
+            and "optfile" in self._extra_options
+        ):
+            gams_options.optfile = self._extra_options["optfile"]
+
+        gams_options_dict = self._get_gams_compatible_options()
+        for key, value in gams_options_dict.items():
+            setattr(gams_options, key, value)
 
-    return gams_options
+        return gams_options
 
 
 update_type_map = {
     "0": SymbolUpdateType.Zero,
     "base_case": SymbolUpdateType.BaseCase,
     "accumulate": SymbolUpdateType.Accumulate,
     "inherit": SymbolUpdateType._Inherit,
```

## gamspy/_validation.py

```diff
@@ -364,7 +364,15 @@
 
     # Check validity of output
     if output is not None and not isinstance(output, io.TextIOBase):
         raise TypeError(
             "`output` must be of type io.TextIOWrapper but found"
             f" {type(output)}"
         )
+
+
+def validate_model(model: gp.Model):
+    for equation in model.equations:
+        if equation._definition is None:
+            raise ValidationError(
+                f"`{equation.name}` has been declared as an equation but no equation definition was found."
+            )
```

## gamspy/exceptions.py

```diff
@@ -117,16 +117,16 @@
     exception: GamsExceptionExecution,
 ) -> str:
     error_message = ""
     if not options._writeoutput:
         exception.value = error_message
         return exception
 
-    header = "=" * 80
-    footer = "=" * 80
+    header = "=" * 14
+    footer = "=" * 14
     message_format = "\n\n{header}\nError Summary\n{footer}\n{message}\n"
 
     lst_filename = options.output if options.output else job._job_name + ".lst"
 
     lst_path = workspace._working_directory + os.path.sep + lst_filename
 
     with open(lst_path, encoding="utf-8") as lst_file:
@@ -138,19 +138,24 @@
             line = all_lines[index]
 
             if line.startswith("****"):
                 error_lines = [all_lines[index - 1]]
                 temp_index = index
 
                 while (
-                    all_lines[temp_index].startswith("****")
-                    and temp_index < len(all_lines) - 1
+                    any(
+                        "****" in err_line
+                        for err_line in all_lines[temp_index : temp_index + 5]
+                    )
+                    and temp_index < len(all_lines) - 10
                 ):
-                    error_lines.append(all_lines[temp_index])
-                    temp_index += 1
+                    for offset in range(5):
+                        error_lines.append(all_lines[temp_index + offset])
+
+                    temp_index += 5
 
                 error_message = message_format.format(
                     message="".join(error_lines),
                     header=header,
                     footer=footer,
                     return_code=exception.rc,
                     meaning=error_codes[exception.rc],
```

## gamspy/_algebra/condition.py

```diff
@@ -57,8 +57,11 @@
 
         self._symbol.container._add_statement(statement)
 
         if isinstance(self._symbol, ImplicitSymbol):
             self._symbol.container[self._symbol.parent.name]._is_dirty = True
             self._symbol.parent._assignment = statement
 
+        if isinstance(self._symbol, implicits.ImplicitEquation):
+            self._symbol.parent._definition = statement
+
         self._symbol.container._run()
```

## gamspy/_algebra/expression.py

```diff
@@ -1,10 +1,9 @@
 from __future__ import annotations
 
-import warnings
 from typing import TYPE_CHECKING, Optional, Union
 
 import gamspy as gp
 import gamspy._algebra.condition as condition
 import gamspy._algebra.domain as domain
 import gamspy._algebra.operable as operable
 import gamspy._algebra.operation as operation
@@ -200,29 +199,14 @@
         >>> expression = a * b
         >>> expression.getDeclaration()
         '(a * b)'
 
         """
         return self.gamsRepr()
 
-    def getStatement(self) -> str:
-        """
-        Statement of this Expression in .gms file.
-
-        Returns
-        -------
-        str
-        """
-        warnings.warn(
-            "getStatement is going to be renamed in 0.12.5. Please use getDeclaration instead.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        return self.getDeclaration()
-
     def _find_variables(self) -> list[Variable]:
         stack = []
         variables: list[Variable] = []
 
         node: OperandType = self
         while True:
             if node is not None:
```

## gamspy/_backend/backend.py

```diff
@@ -7,17 +7,15 @@
 import pandas as pd
 
 from gamspy.exceptions import ValidationError
 
 if TYPE_CHECKING:
     import io
 
-    from gams import GamsOptions
-
-    from gamspy import Container, Model
+    from gamspy import Container, Model, Options
     from gamspy._backend.engine import EngineClient, GAMSEngine
     from gamspy._backend.local import Local
     from gamspy._backend.neos import NeosClient, NEOSServer
 
 SOLVE_STATUS = [
     "",
     "Normal",
@@ -44,28 +42,28 @@
     "Solver",
     "Solver Time",
 ]
 
 
 def backend_factory(
     container: Container,
-    options: GamsOptions | None = None,
+    options: Options | None = None,
     output: io.TextIOWrapper | None = None,
     backend: Literal["local", "engine", "neos"] = "local",
     client: EngineClient | NeosClient | None = None,
     model: Model | None = None,
 ) -> Local | GAMSEngine | NEOSServer:
     if backend == "neos":
         from gamspy._backend.neos import NEOSServer
 
-        return NEOSServer(container, options, client, model)
+        return NEOSServer(container, options, client, model)  # type: ignore
     elif backend == "engine":
         from gamspy._backend.engine import GAMSEngine
 
-        return GAMSEngine(container, client, options, output, model)
+        return GAMSEngine(container, client, options, output, model)  # type: ignore
     elif backend == "local":
         from gamspy._backend.local import Local
 
         return Local(container, options, output, model)
 
     raise ValidationError(
         f"`{backend}` is not a valid backend. Possible backends:"
```

## gamspy/_backend/engine.py

```diff
@@ -10,30 +10,30 @@
 import urllib.parse
 import uuid
 import zipfile
 from typing import TYPE_CHECKING
 
 import certifi
 import urllib3
-from gams import GamsEngineConfiguration, GamsOptions
+from gams import GamsEngineConfiguration
 from gams.control.workspace import GamsException
 from gams.core.cfg import cfgModelTypeName
 from gams.core.gmo import gmoProc_nrofmodeltypes
 from gams.core.opt import optSetStrStr
 
 import gamspy._backend.backend as backend
 from gamspy.exceptions import (
     EngineClientException,
     EngineException,
     GamspyException,
     ValidationError,
 )
 
 if TYPE_CHECKING:
-    from gamspy import Container, Model
+    from gamspy import Container, Model, Options
 
 
 logger = logging.getLogger("ENGINE")
 logger.setLevel(logging.INFO)
 stream_handler = logging.StreamHandler()
 stream_handler.setLevel(logging.INFO)
 formatter = logging.Formatter("[%(name)s - %(levelname)s] %(message)s")
@@ -673,15 +673,15 @@
 
 
 class GAMSEngine(backend.Backend):
     def __init__(
         self,
         container: Container,
         client: EngineClient | None,
-        options: GamsOptions,
+        options: Options,
         output: io.TextIOWrapper | None = None,
         model: Model | None = None,
     ) -> None:
         if client is None:
             raise ValidationError(
                 "`engine_client` must be provided to solve on GAMS Engine"
             )
@@ -689,15 +689,21 @@
         super().__init__(
             container,
             os.path.basename(container._gdx_in),
             os.path.basename(container._gdx_out),
         )
 
         self.client = client
-        self.options = options
+        if model is None:
+            self.options = options._get_gams_options(self.container.workspace)
+        else:
+            self.options = options._get_gams_options(
+                self.container.workspace, model.problem
+            )
+        self.options.trace = "trace.txt"
         self.output = output
         self.model = model
         self.job_name = f"_job_{uuid.uuid4()}"
         self.gms_file = self.job_name + ".gms"
         self.pf_file = self.job_name + ".pf"
 
     def is_async(self):
```

## gamspy/_backend/local.py

```diff
@@ -1,37 +1,45 @@
 from __future__ import annotations
 
 import os
 import uuid
 from typing import TYPE_CHECKING
 
-from gams import GamsJob, GamsOptions
+from gams import GamsJob
 from gams.control.workspace import GamsExceptionExecution
 
 import gamspy._backend.backend as backend
 import gamspy._miro as miro
 from gamspy.exceptions import GamspyException, customize_exception
 
 if TYPE_CHECKING:
     import io
 
-    from gamspy import Container, Model
+    from gamspy import Container, Model, Options
 
 
 class Local(backend.Backend):
     def __init__(
         self,
         container: Container,
-        options: GamsOptions,
+        options: Options,
         output: io.TextIOWrapper | None = None,
         model: Model | None = None,
     ) -> None:
         super().__init__(container, container._gdx_in, container._gdx_out)
-        self.options = options
-        self.options.license = container._license_path
+        if model is None:
+            self.options = options._get_gams_options(self.container.workspace)
+        else:
+            self.options = options._get_gams_options(
+                self.container.workspace, model.problem
+            )
+        self.options.license = self.container._license_path
+        self.options.trace = os.path.join(
+            self.container.workspace.working_directory, "trace.txt"
+        )
         self.output = output
         self.model = model
 
     def is_async(self):
         return False
 
     def solve(self, is_implicit: bool = False, keep_flags: bool = False):
@@ -84,13 +92,13 @@
                 self.container._gdx_out, symbols
             )
 
         miro.load_miro_symbol_records(self.container)
 
         self.container._swap_checkpoints()
 
-        if self.options.traceopt == 3 and not is_implicit:
+        if not is_implicit:
             return self.prepare_summary(
                 self.container.working_directory, self.options.trace
             )
 
         return None
```

## gamspy/_backend/neos.py

```diff
@@ -23,15 +23,15 @@
 formatter = logging.Formatter("[%(name)s - %(levelname)s] %(message)s")
 stream_handler.setFormatter(formatter)
 logger.addHandler(stream_handler)
 
 if TYPE_CHECKING:
     from gams import GamsOptions
 
-    from gamspy import Container, Model
+    from gamspy import Container, Model, Options
 
 
 class NeosClient:
     def __init__(
         self,
         email: str,
         server: str = "https://neos-server.org:3333",
@@ -386,26 +386,33 @@
         return job_number, job_password
 
 
 class NEOSServer(backend.Backend):
     def __init__(
         self,
         container: Container,
-        options: GamsOptions,
+        options: Options,
         client: NeosClient | None,
         model: Model | None = None,
     ) -> None:
         if client is None:
             raise ValidationError(
                 "`neos_client` must be provided to solve on NEOS Server"
             )
 
         super().__init__(container, "in.gdx", "output.gdx")
 
         self.options = options
+        if model is None:
+            self.options = options._get_gams_options(self.container.workspace)
+        else:
+            self.options = options._get_gams_options(
+                self.container.workspace, model.problem
+            )
+        self.options.trace = "trace.txt"
         self.client = client
         self.model = model
 
     def is_async(self):
         return not self.client.is_blocking
 
     def solve(self, is_implicit: bool = False, keep_flags: bool = False):
```

## gamspy/_cli/cmdline.py

```diff
@@ -198,18 +198,19 @@
                 [
                     "pip",
                     "install",
                     f"gamspy-{solver_name}=={gamspy_base.__version__}",
                     "--force-reinstall",
                 ],
                 check=True,
+                stderr=subprocess.PIPE,
             )
         except subprocess.CalledProcessError as e:
             raise GamspyException(
-                f"Could not install gamspy-{solver_name}: {e.output}"
+                f"Could not install gamspy-{solver_name}: {e.stderr.decode('utf-8')}"
             ) from e
     else:
         try:
             solver_lib = importlib.import_module(f"gamspy_{solver_name}")
         except ModuleNotFoundError as e:
             e.msg = f"You must install gamspy-{solver_name} first!"
             raise e
```

## gamspy/_symbols/alias.py

```diff
@@ -1,11 +1,10 @@
 from __future__ import annotations
 
 import uuid
-import warnings
 from typing import TYPE_CHECKING
 
 import gams.transfer as gt
 from gams.core.gdx import GMS_DT_ALIAS
 
 import gamspy as gp
 import gamspy._algebra.condition as condition
@@ -104,15 +103,18 @@
                     f"Cannot overwrite symbol `{name}` in container"
                     " because it is not an Alias object)"
                 )
             except KeyError:
                 return object.__new__(Alias)
 
     def __init__(
-        self, container: Container, name: str | None, alias_with: Set
+        self,
+        container: Container,
+        name: str | None = None,
+        alias_with: Set | None = None,
     ):
         # does symbol exist
         has_symbol = False
         if isinstance(getattr(self, "container", None), gp.Container):
             has_symbol = True
 
         if has_symbol:
@@ -123,15 +125,15 @@
             self.alias_with = alias_with
         else:
             self._is_dirty = False
 
             if name is not None:
                 name = validation.validate_name(name)
             else:
-                name = str(uuid.uuid4()).replace("-", "_")
+                name = "a" + str(uuid.uuid4()).replace("-", "_")
 
             super().__init__(container, name, alias_with)
 
             validation.validate_container(self, self.domain)
             self.where = condition.Condition(self)
             self.container._add_statement(self)
 
@@ -163,22 +165,7 @@
         Declaration of the Alias in GAMS
 
         Returns
         -------
         str
         """
         return f"Alias({self.alias_with.name},{self.name});"
-
-    def getStatement(self) -> str:
-        """
-        Statement of the Alias declaration
-
-        Returns
-        -------
-        str
-        """
-        warnings.warn(
-            "getStatement is going to be renamed in 0.12.5. Please use getDeclaration instead.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        return self.getDeclaration()
```

## gamspy/_symbols/equation.py

```diff
@@ -1,13 +1,12 @@
 from __future__ import annotations
 
 import builtins
 import itertools
 import uuid
-import warnings
 from enum import Enum
 from typing import TYPE_CHECKING, Any
 
 import gams.transfer as gt
 import pandas as pd
 from gams.core.gdx import GMS_DT_EQU
 from gams.transfer._internals import (
@@ -270,15 +269,15 @@
             self._is_dirty = False
             self._is_frozen = False
 
             if name is not None:
                 name = validation.validate_name(name)
 
                 if is_miro_output:
-                    name = name.lower()
+                    name = name.lower()  # type: ignore
             else:
                 name = "e" + str(uuid.uuid4()).replace("-", "_")
 
             previous_state = container.miro_protect
             container.miro_protect = False
             super().__init__(
                 container,
@@ -368,15 +367,15 @@
         )
 
     def _init_definition(
         self,
         assignment: Variable | Operation | Expression | None = None,
     ):
         if assignment is None:
-            self._assignment = None  # type: ignore
+            self._definition = None  # type: ignore
             return None
 
         domain = (
             self._definition_domain if self._definition_domain else self.domain
         )
         self._set_definition(domain, assignment)
 
@@ -400,15 +399,15 @@
                 domain=domain,
             ),
             "..",
             rhs,
         )
 
         self.container._add_statement(statement)
-        self._assignment = statement
+        self._definition = statement
 
     @property
     def l(self):  # noqa: E741, E743
         """
         Level
 
         Returns
@@ -678,33 +677,18 @@
         >>> v = gp.Variable(m, "v", domain=[i])
         >>> e = gp.Equation(m, "e", domain=[i])
         >>> e[i] = a[i] <= v[i]
         >>> e.getDefinition()
         'e(i) .. a(i) =l= v(i);'
 
         """
-        if self._assignment is None:
+        if self._definition is None:
             raise ValidationError("Equation is not defined!")
 
-        return self._assignment.getDeclaration()
-
-    def getStatement(self) -> str:
-        """
-        Statement of the Equation declaration
-
-        Returns
-        -------
-        str
-        """
-        warnings.warn(
-            "getStatement is going to be renamed in 0.12.5. Please use getDeclaration instead.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        return self.getDeclaration()
+        return self._definition.getDeclaration()
 
 
 def cast_type(type: str | EquationType) -> str:
     if isinstance(type, str):
         if type.lower() not in [
             "eq",
             "geq",
```

## gamspy/_symbols/parameter.py

```diff
@@ -1,12 +1,11 @@
 from __future__ import annotations
 
 import itertools
 import uuid
-import warnings
 from typing import TYPE_CHECKING, Any
 
 import gams.transfer as gt
 import pandas as pd
 from gams.core.gdx import GMS_DT_PAR
 
 import gamspy as gp
@@ -208,15 +207,15 @@
             self._is_dirty = False
             self._is_frozen = False
 
             if name is not None:
                 name = validation.validate_name(name)
 
                 if is_miro_input or is_miro_output:
-                    name = name.lower()
+                    name = name.lower()  # type: ignore
             else:
                 name = "p" + str(uuid.uuid4()).replace("-", "_")
 
             previous_state = container.miro_protect
             container.miro_protect = False
             super().__init__(
                 container,
@@ -378,45 +377,30 @@
         if self.description:
             output += ' "' + self.description + '"'
 
         output += ";"
 
         return output
 
-    def getDefinition(self) -> str:
+    def getAssignment(self) -> str:
         """
-        Definition of the Parameter in GAMS
+        Latest assignment to the Parameter in GAMS
 
         Returns
         -------
         str
 
         Examples
         --------
         >>> import gamspy as gp
         >>> m = gp.Container()
         >>> i = gp.Set(m, "i", records=['i1','i2'])
         >>> a = gp.Parameter(m, "a", [i], records=[['i1',1],['i2',2]])
         >>> a[i] = a[i] * 5
-        >>> a.getDefinition()
+        >>> a.getAssignment()
         'a(i) = (a(i) * 5);'
 
         """
-        if self._assignment is None:
+        if not hasattr(self, "_assignment"):
             raise ValidationError("Parameter is not defined!")
 
         return self._assignment.getDeclaration()
-
-    def getStatement(self) -> str:
-        """
-        Statement of the Parameter declaration
-
-        Returns
-        -------
-        str
-        """
-        warnings.warn(
-            "getStatement is going to be renamed in 0.12.5. Please use getDeclaration instead.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        return self.getDeclaration()
```

## gamspy/_symbols/set.py

```diff
@@ -1,12 +1,11 @@
 from __future__ import annotations
 
 import itertools
 import uuid
-import warnings
 from typing import TYPE_CHECKING, Any, Literal
 
 import gams.transfer as gt
 import pandas as pd
 from gams.core.gdx import GMS_DT_SET
 
 import gamspy as gp
@@ -466,15 +465,15 @@
         else:
             self._is_dirty = False
             self.where = condition.Condition(self)
 
             if name is not None:
                 name = validation.validate_name(name)
                 if is_miro_input or is_miro_output:
-                    name = name.lower()
+                    name = name.lower()  # type: ignore
             else:
                 name = "s" + str(uuid.uuid4()).replace("-", "_")
 
             singleton_check(is_singleton, records)
 
             previous_state = container.miro_protect
             container.miro_protect = False
@@ -621,51 +620,36 @@
         if self.description:
             output += f' "{self.description}"'
 
         output += ";"
 
         return output
 
-    def getDefinition(self) -> str:
+    def getAssignment(self) -> str:
         """
-        Definition of the Set in GAMS
+        Latest assignment to the Set in GAMS
 
         Returns
         -------
         str
 
         Examples
         --------
         >>> import gamspy as gp
         >>> m = gp.Container()
         >>> i = gp.Set(m, "i", records=['i1','i2'])
         >>> i['i1'] = False
-        >>> i.getDefinition()
+        >>> i.getAssignment()
         'i("i1") = no;'
 
         """
-        if self._assignment is None:
-            raise ValidationError("Set is not defined!")
+        if not hasattr(self, "_assignment"):
+            raise ValidationError("Set is not assigned!")
 
         return self._assignment.getDeclaration()
 
-    def getStatement(self) -> str:
-        """
-        Statement of the Set declaration
-
-        Returns
-        -------
-        str
-        """
-        warnings.warn(
-            "getStatement is going to be renamed in 0.12.5. Please use getDeclaration instead.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        return self.getDeclaration()
-
 
 def singleton_check(is_singleton: bool, records: Any | None):
     if is_singleton and records is not None and len(records) > 1:
         raise ValidationError(
             "Singleton set records size cannot be more than one."
         )
```

## gamspy/_symbols/variable.py

```diff
@@ -1,13 +1,12 @@
 from __future__ import annotations
 
 import builtins
 import itertools
 import uuid
-import warnings
 from enum import Enum
 from typing import TYPE_CHECKING, Any
 
 import gams.transfer as gt
 import pandas as pd
 from gams.core.gdx import GMS_DT_VAR
 from gams.transfer._internals import (
@@ -245,15 +244,15 @@
             self._is_dirty = False
             self._is_frozen = False
 
             if name is not None:
                 name = validation.validate_name(name)
 
                 if is_miro_output:
-                    name = name.lower()
+                    name = name.lower()  # type: ignore
             else:
                 name = "v" + str(uuid.uuid4()).replace("-", "_")
 
             previous_state = container.miro_protect
             container.miro_protect = False
             super().__init__(
                 container,
@@ -544,53 +543,38 @@
         if self.description:
             output += ' "' + self.description + '"'
 
         output += ";"
 
         return output
 
-    def getDefinition(self) -> str:
+    def getAssignment(self) -> str:
         """
-        Definition of the Variable in GAMS
+        Latest assignment to the Variable in GAMS
 
         Returns
         -------
         str
 
         Examples
         --------
         >>> import gamspy as gp
         >>> m = gp.Container()
         >>> i = gp.Set(m, "i", records=['i1','i2'])
         >>> v = gp.Variable(m, "v", domain=[i])
         >>> v.l[i] = 0;
-        >>> v.getDefinition()
+        >>> v.getAssignment()
         'v.l(i) = 0;'
 
         """
         if not hasattr(self, "_assignment"):
             raise ValidationError("Variable is not defined!")
 
         return self._assignment.getDeclaration()
 
-    def getStatement(self) -> str:
-        """
-        Statement of the Variable declaration
-
-        Returns
-        -------
-        str
-        """
-        warnings.warn(
-            "getStatement is going to be renamed in 0.12.5. Please use getDeclaration instead.",
-            DeprecationWarning,
-            stacklevel=2,
-        )
-        return self.getDeclaration()
-
 
 def cast_type(type: str | VariableType) -> str:
     if isinstance(type, str) and type.lower() not in VariableType.values():
         raise ValueError(
             f"Allowed variable types: {VariableType.values()} but"
             f" found {type}."
         )
```

## gamspy/math/log_power.py

```diff
@@ -39,23 +39,23 @@
     Returns
     -------
     Expression
     """
     return expression.Expression(None, MathOp("logBeta", (x, y)), None)
 
 
-def log_gamma(x: int | float | Symbol, y: int | float | Symbol) -> Expression:
+def log_gamma(x: int | float | Symbol) -> Expression:
     """
     Log gamma function
 
     Returns
     -------
     Expression
     """
-    return expression.Expression(None, MathOp("logGamma", (x, y)), None)
+    return expression.Expression(None, MathOp("logGamma", (x,)), None)
 
 
 def logit(x: int | float | Symbol) -> Expression:
     """
     Natural logarithm of x (i.e. logarithm base e of x)
 
     Returns
```

## Comparing `gamspy-0.12.4.dist-info/LICENSE` & `gamspy-0.12.5.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `gamspy-0.12.4.dist-info/METADATA` & `gamspy-0.12.5.dist-info/METADATA`

 * *Files 6% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: gamspy
-Version: 0.12.4
+Version: 0.12.5
 Summary: Python-based algebraic modeling interface to GAMS
 Author-email: GAMS Development Corporation <support@gams.com>
 License: GAMSpy - General Algebraic Modeling in Python
         
         Copyright (c) 2024 GAMS Development Corp. <support@gams.com>
         Copyright (c) 2024 GAMS Software GmbH <support@gams.com>
         
@@ -68,23 +68,31 @@
 Requires-Dist: numpydoc >=1.5.0 ; extra == 'doc'
 Requires-Dist: nbsphinx >=0.9.3 ; extra == 'doc'
 Requires-Dist: sphinx-copybutton >=0.5.2 ; extra == 'doc'
 Requires-Dist: ipykernel ; extra == 'doc'
 Requires-Dist: matplotlib >=3.7.3 ; extra == 'doc'
 Requires-Dist: sphinx-design >=0.5.0 ; extra == 'doc'
 Requires-Dist: pydata-sphinx-theme >=0.14.1 ; extra == 'doc'
+Requires-Dist: plotly >=5.22.0 ; extra == 'doc'
+Requires-Dist: kaleido >=0.2.1 ; extra == 'doc'
+Requires-Dist: pytest >=8.2.1 ; extra == 'doc'
+Requires-Dist: nbmake >=1.5.3 ; extra == 'doc'
+Requires-Dist: openpyxl >=3.1.2 ; extra == 'doc'
 Provides-Extra: test
 Requires-Dist: coverage[toml] >=7.2.7 ; extra == 'test'
 Requires-Dist: openpyxl >=3.1.2 ; extra == 'test'
 Requires-Dist: cerberus >=1.3.5 ; extra == 'test'
 Requires-Dist: python-dotenv >=1.0.0 ; extra == 'test'
 
 ![plot](https://github.com/GAMS-dev/gamspy/blob/develop/docs/_static/gamspy_logo.png?raw=true)
 
 -----------------
+[![PyPI version](https://img.shields.io/pypi/v/gamspy.svg?maxAge=3600)](https://gamspy.readthedocs.io/en/latest/)
+[![Downloads](https://static.pepy.tech/badge/gamspy)](https://pepy.tech/project/gamspy)
+[![Documentation Status](https://readthedocs.org/projects/gamspy/badge/?version=latest)](https://gamspy.readthedocs.io/en/latest/)
 
 # GAMSPy: Algebraic Modeling Interface to GAMS
 
 ## Installation
 
 ```sh
 pip install gamspy
@@ -92,14 +100,16 @@
 
 ## What is it?
 
 **gamspy** is a mathematical optimization package that combines the power of the high performance GAMS execution system
 and flexibility of the Python language. It includes all GAMS symbols (Set, Alias, Parameter, Variable, and
 Equation) to compose mathematical models, a math package, and various utility functions.
 
+## Documentation
+The official documentation is hosted on [GAMSPy Readthedocs](https://gamspy.readthedocs.io/en/latest/index.html).
 
 ## Design Philosophy
 GAMSPy makes extensive use of set based operations -- the absence of any explicit looping, indexing, etc., in native Python.
 These things are taking place, of course, just “behind the scenes” in optimized, pre-compiled C code.
 
 Set based approach has many advantages:
 
@@ -112,17 +122,14 @@
 ## Main Features
 Here are just a few of the things that **gamspy** does well:
 
   - Specify model algebra in Python natively
   - Combines the flexibility of Python programming flow controls and the power of model specification in GAMS
   - Test a variety of solvers on a model by changing only one line
 
-## Documentation
-The official documentation is hosted on [GAMSPy Readthedocs](https://gamspy.readthedocs.io/en/latest/index.html).
-
 ## Getting Help
 
-For usage questions, the best place to go to is [GAMS](https://www.gams.com/latest/docs/API_PY_GETTING_STARTED.html).
+For usage questions, the best place to go to is [GAMSPy Documentation](https://gamspy.readthedocs.io/en/latest/index.html).
 General questions and discussions can also take place on the [GAMS World Forum](https://forum.gamsworld.org).
 
 ## Discussion and Development
-If you have a design request or concern, please write to support@gams.com.
+If you have a design request or concern, please write to gamspy@gams.com.
```

## Comparing `gamspy-0.12.4.dist-info/RECORD` & `gamspy-0.12.5.dist-info/RECORD`

 * *Files 21% similar despite different names*

```diff
@@ -1,51 +1,52 @@
 gamspy/__init__.py,sha256=mzApIyw17_JeLwPEZjjl2zqx_XKC1wBKKe_TEChAW88,1221
 gamspy/__main__.py,sha256=vjHS8h-b1bDhHOR78rLNUZPQGmRKGPCnieZiSfrkf3E,112
-gamspy/_container.py,sha256=ZFVaZz972LMvegkpCBl0gA8DTRVn1EDLdOqAA6qo8tg,30754
+gamspy/_container.py,sha256=0eOk7CQwzYy-aaIO_UHoAxz2Im8dXgmBLmK3J6AEFas,31894
+gamspy/_extrinsic.py,sha256=ncxf44iSOxnG5o92OPBMM0rUYtyVkRw-SfuR3x_ymK0,2761
 gamspy/_miro.py,sha256=E3h5q7Me_M0_ruL9D8MVLuufToU2Q1fOkCwNOQrY2WQ,11000
-gamspy/_model.py,sha256=6kcQRj16kCPZA0MG0cMLxefs9tEwoiMFlblIZBQoMq4,23550
+gamspy/_model.py,sha256=XiSv47l5UMBD425cTGYZdhsHTtX6iIf4lkZVz4GUuNU,21751
 gamspy/_model_instance.py,sha256=zYotTYyxnndgkr2-aG6sjStoufHwZT1sWHOMugqK7ho,10118
-gamspy/_options.py,sha256=PB3ZQxJTyAmQ_AAk8R6on6ZDEvaNEWFY9Ww6keKZbfc,9952
-gamspy/_validation.py,sha256=sGKtWX5F5G75ULkR4tQgp8sVn226rDyi2H_Q3zKp1NQ,9750
-gamspy/exceptions.py,sha256=jhNON4U0StYCLj3vN51ulnbCAC0Z2k5QDv-jlHnw6A8,5580
+gamspy/_options.py,sha256=WezStqD7Lxb0a4_Vx9XWgLDP_IDZ6s4KTpSl3ocO31c,9308
+gamspy/_validation.py,sha256=Qo0STxMF-7InuCPoXY6pC8fncGBd-6j9atDOSkZsHwA,10024
+gamspy/exceptions.py,sha256=bE_ALIZF7YBogLWOFJBoVbgYoFU3sadW4TRTqJCnQtg,5747
 gamspy/utils.py,sha256=tgWcpOqIBWkmT6eovkhFDjkhBXRhgiZ8L7WzZUUVu5c,9428
 gamspy/version.py,sha256=GsqTw9rQ4Zz80ZSlIo44vYqgcVBJSbGOqJFJW3j_z88,109
 gamspy/_algebra/__init__.py,sha256=sCnhq67Fq_btEo3Z9-s4UM1EGogf7c3MnYpUFsuiusg,394
-gamspy/_algebra/condition.py,sha256=p6REQJQNPRWOy5Ur0wwOwEdLJ2yR-2dOKFDsvhyMyik,2067
+gamspy/_algebra/condition.py,sha256=gY2nOFs0HhB4y-EHwfsWej0tuZjq_yVb9XrPdubY0gs,2189
 gamspy/_algebra/domain.py,sha256=nzMK5Ez94Ycftq4XVskSm-eYguuDBM40GeXbzIdF20I,2091
-gamspy/_algebra/expression.py,sha256=meWI7lhgOlobYkdGTcflaoFjEFGoDA15NQsB_1GgkXU,8536
+gamspy/_algebra/expression.py,sha256=-bP8Sf1j434giPWTaaRbbjc53F6dQ0u_grlfhiY6hdI,8139
 gamspy/_algebra/number.py,sha256=28BiUJNaZaJdeYtpVKcAGmrMfh75ooFefXhkh4ea2JA,867
 gamspy/_algebra/operable.py,sha256=jWsV3UxBydhbqUBeHJmI3PphM-S2D2SFiB5NlqGVugg,3640
 gamspy/_algebra/operation.py,sha256=oKG9ntqCh5pCy9TLquoPvX_eTc_zZce_jdTzLXI0TNA,8292
 gamspy/_backend/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-gamspy/_backend/backend.py,sha256=YqJhlLdJ7l3C0gedso1WF9vzSivo0IaHMBUSfCo9mVY,4295
-gamspy/_backend/engine.py,sha256=b2IEIAkw2SkAny4JpHukn-LkGJd1GMaUfCyzCGllKxE,25633
-gamspy/_backend/local.py,sha256=MN4S4VK7myaNy6JBnDbGViSsWdtpjQd_2F_SiyXp4KU,2993
-gamspy/_backend/neos.py,sha256=afcAtPR_Yuyue5mXOHHD0oOkkrRsowAEkT9NNle-45s,14787
+gamspy/_backend/backend.py,sha256=v9hWRYHVDoEFJfn59DKKajabqdGMwgVwptjvzhmtNRE,4298
+gamspy/_backend/engine.py,sha256=cOUxSMTnUQ0TK-epJd-tVKLR39HUmPF2Iit3Vi6SYN8,25878
+gamspy/_backend/local.py,sha256=Gaw1hcvtc_XZPgjIr8O-Eccks3VeqcYVU_PpNxC7tYk,3292
+gamspy/_backend/neos.py,sha256=yr43Kse592NB6xWh5luVhZtejOpmufvIv2Q4dxFJcLY,15076
 gamspy/_cli/__init__.py,sha256=U4S_2y3zgLZVfMenHRaJFBW8yqh2mUBuI291LGQVOJ8,35
-gamspy/_cli/cmdline.py,sha256=1u4xpAo3_1Xu3dAmTMkxh--kI76PfM6wgzIY6kRCuyc,14378
+gamspy/_cli/cmdline.py,sha256=XwmLWB5enVPDtKhSAbMby0H6N-BCvG6l_AyKFBQK4hY,14434
 gamspy/_cli/util.py,sha256=N9hrp9zM_c95E7vzMQH_R58ESzh8lrtR-MSaYQnht1I,3473
 gamspy/_symbols/__init__.py,sha256=p0Zd7XytuOe8kRclN1lFrRFaN_btFSSGdIBSXrlp03E,450
-gamspy/_symbols/alias.py,sha256=Ia2-frp2EPlo44dwQDMSrsRrEDYqDQ4GB95XtKGvfzM,4970
-gamspy/_symbols/equation.py,sha256=llr2q4C9cVX5fNa-AUVIY8GaxJ7FciIKFUrIi7IP5XI,19863
-gamspy/_symbols/parameter.py,sha256=_fRICq55DJrWCj7LwJ8wDhnYYjQ5f0dwCLawG4tgFWE,12839
-gamspy/_symbols/set.py,sha256=X-z6FjPxCe24EUEveNvgGsT9C8ldXesEy59qiRd2uxU,19664
+gamspy/_symbols/alias.py,sha256=TC7s9M5L5EdWhXIleOf0urYI2zT525V4cFtipFDH0lM,4633
+gamspy/_symbols/equation.py,sha256=nhGDBcLTa6K1hDmdTPLCNWr3h47aubB-7U3JmqxCXyw,19487
+gamspy/_symbols/parameter.py,sha256=QjLlfXIr9i3IFMfnZCICGgn4yfzhCDNxktyP8TM6W1k,12477
+gamspy/_symbols/set.py,sha256=A7MP3Ktn7sEDqw4g8VpxXz_PfKslZeszzbNI0CnWHvU,19309
 gamspy/_symbols/symbol.py,sha256=5CdrRrPQ6xchTYCvAQ8CwAlOd9zZ-5rSQO_IYDliCvM,1527
 gamspy/_symbols/universe_alias.py,sha256=QYWbP4tFDh0RAaIWZRfba_ScGmZaB70HfyGlai6KhMU,2785
-gamspy/_symbols/variable.py,sha256=FMVJvd-pQoOqkB2tUWt9e2n1iVobLGhyCwEhIMDTSuY,16010
+gamspy/_symbols/variable.py,sha256=dkdutt7mZSNc9rrSzoaNxTDczlcv_KlqYL6OioRM9Oc,15641
 gamspy/_symbols/implicits/__init__.py,sha256=bvYl_lYtnTztfNUTMxqteIztotwh1T2CUQpidQITSMQ,391
 gamspy/_symbols/implicits/implicit_equation.py,sha256=NEj96Z7sqaQa_9c4badl7GHqRCk261SVmdcWOhH2IgA,3263
 gamspy/_symbols/implicits/implicit_parameter.py,sha256=qLplXH9CGo-oLn_NUjzRChqL9RzXP4onw92DJcAAMqA,2796
 gamspy/_symbols/implicits/implicit_set.py,sha256=41Ql9_KeTx38WqdPD-GKRjCNbwYKhQqrGPZPI-DFs98,1320
 gamspy/_symbols/implicits/implicit_symbol.py,sha256=T2IdQsbZT3ahIG4OI0ooRIEdsPPtNwct7d6A-i1p1Ro,479
 gamspy/_symbols/implicits/implicit_variable.py,sha256=rLyXTpQxYN9V3062b56a1G5ro9eSeefIHwzM88iG3n4,2666
 gamspy/math/__init__.py,sha256=38oCpY6WTz1vCGT_24WRnrTKhiSXvwj-asF5ZeqTa54,2392
-gamspy/math/log_power.py,sha256=7HFDC7YbjekA005nbrnrRUmgqRnvfr8p_Mvd-VLvZ0Q,4525
+gamspy/math/log_power.py,sha256=f_KAwktPzuMguDTXqNv1JL0qSndlVj8C1TnpE2CppOE,4498
 gamspy/math/misc.py,sha256=UwSB-DJfBRoq26mTUbI0xZaie-mUDD6G5sUS-Itup2A,15805
 gamspy/math/probability.py,sha256=XwRDxK1VsXtiZzmxGXLBFkNa1iUbEoFbNEOjkXA4pcI,2666
 gamspy/math/trigonometric.py,sha256=tqG8Pq0v011Cs6yr14tnMM3NkehGe78jU10D-QF6Q6Y,2249
-gamspy-0.12.4.dist-info/LICENSE,sha256=D4HfHbHRs3LVWo3uXq44WQc1FkBP5srUCEa-vO0W9tE,1189
-gamspy-0.12.4.dist-info/METADATA,sha256=bIdbYW4PzaLuO1th9gYxzQSvTpgLJ_RlFwUk8TfcfhE,5717
-gamspy-0.12.4.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-gamspy-0.12.4.dist-info/entry_points.txt,sha256=oQx1MCqP7LGWaNWawnikcMN4qaPHAV-SB_30BeWXgzw,52
-gamspy-0.12.4.dist-info/top_level.txt,sha256=fsq4q5lfdb2GEZC9O3PUih38s7TfIgolIaO5NgR3Hf8,7
-gamspy-0.12.4.dist-info/RECORD,,
+gamspy-0.12.5.dist-info/LICENSE,sha256=D4HfHbHRs3LVWo3uXq44WQc1FkBP5srUCEa-vO0W9tE,1189
+gamspy-0.12.5.dist-info/METADATA,sha256=6l7ZQiKZKvC5I5tOJM9TCBxqzEW9v505xNGSdIZWRXo,6293
+gamspy-0.12.5.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+gamspy-0.12.5.dist-info/entry_points.txt,sha256=oQx1MCqP7LGWaNWawnikcMN4qaPHAV-SB_30BeWXgzw,52
+gamspy-0.12.5.dist-info/top_level.txt,sha256=fsq4q5lfdb2GEZC9O3PUih38s7TfIgolIaO5NgR3Hf8,7
+gamspy-0.12.5.dist-info/RECORD,,
```


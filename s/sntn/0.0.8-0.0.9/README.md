# Comparing `tmp/sntn-0.0.8-py2.py3-none-any.whl.zip` & `tmp/sntn-0.0.9-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,30 +1,30 @@
-Zip file size: 72439 bytes, number of entries: 28
--rw-r--r--  2.0 unx       69 b- defN 24-May-12 01:16 sntn/__init__.py
--rw-r--r--  2.0 unx     1139 b- defN 24-May-16 19:09 sntn/__main__.py
--rw-r--r--  2.0 unx     6325 b- defN 24-May-09 00:20 sntn/_bvn.py
--rw-r--r--  2.0 unx     7456 b- defN 24-May-17 02:19 sntn/_fast_integrals.py
--rw-r--r--  2.0 unx    15431 b- defN 24-May-09 00:20 sntn/_lasso.py
--rw-r--r--  2.0 unx    24865 b- defN 24-May-17 02:19 sntn/_nts.py
--rw-r--r--  2.0 unx    11864 b- defN 24-May-09 00:20 sntn/_screening.py
--rw-r--r--  2.0 unx    25008 b- defN 24-May-09 00:20 sntn/_solvers.py
--rw-r--r--  2.0 unx     3333 b- defN 24-May-09 00:20 sntn/_split.py
--rw-r--r--  2.0 unx    11988 b- defN 24-May-09 00:20 sntn/_tnorm.py
--rw-r--r--  2.0 unx     1161 b- defN 24-May-09 00:20 sntn/dists.py
--rw-r--r--  2.0 unx      632 b- defN 24-May-08 17:40 sntn/posi.py
--rw-r--r--  2.0 unx     1869 b- defN 24-May-08 17:40 sntn/trialML.py
--rw-r--r--  2.0 unx        0 b- defN 24-May-08 17:40 sntn/_cdf_bvn/__init__.py
--rw-r--r--  2.0 unx     8466 b- defN 24-May-09 00:20 sntn/_cdf_bvn/_approx.py
--rw-r--r--  2.0 unx     7472 b- defN 24-May-09 00:20 sntn/_cdf_bvn/_brute.py
--rw-r--r--  2.0 unx     2074 b- defN 24-May-08 17:40 sntn/_cdf_bvn/_utils.py
--rw-r--r--  2.0 unx       94 b- defN 24-May-08 17:40 sntn/benchmark/readme.md
--rw-r--r--  2.0 unx      192 b- defN 24-May-08 17:40 sntn/benchmark/runtime.py
--rw-r--r--  2.0 unx        0 b- defN 24-May-08 17:40 sntn/utilities/__init__.py
--rw-r--r--  2.0 unx     3170 b- defN 24-May-08 17:40 sntn/utilities/grad.py
--rw-r--r--  2.0 unx     5962 b- defN 24-May-08 17:40 sntn/utilities/linear.py
--rw-r--r--  2.0 unx    23074 b- defN 24-May-16 16:02 sntn/utilities/utils.py
--rw-r--r--  2.0 unx    35150 b- defN 24-May-17 02:19 sntn-0.0.8.dist-info/LICENSE.txt
--rw-r--r--  2.0 unx    11061 b- defN 24-May-17 02:19 sntn-0.0.8.dist-info/METADATA
--rw-r--r--  2.0 unx      110 b- defN 24-May-17 02:19 sntn-0.0.8.dist-info/WHEEL
--rw-r--r--  2.0 unx        5 b- defN 24-May-17 02:19 sntn-0.0.8.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2116 b- defN 24-May-17 02:19 sntn-0.0.8.dist-info/RECORD
-28 files, 210086 bytes uncompressed, 69125 bytes compressed:  67.1%
+Zip file size: 73098 bytes, number of entries: 28
+-rw-r--r--  2.0 unx       69 b- defN 24-May-22 17:45 sntn/__init__.py
+-rw-r--r--  2.0 unx     1139 b- defN 24-May-22 17:45 sntn/__main__.py
+-rw-r--r--  2.0 unx     6325 b- defN 24-May-22 17:45 sntn/_bvn.py
+-rw-r--r--  2.0 unx     7456 b- defN 24-May-22 17:45 sntn/_fast_integrals.py
+-rw-r--r--  2.0 unx    15431 b- defN 24-May-22 17:45 sntn/_lasso.py
+-rw-r--r--  2.0 unx    26670 b- defN 24-May-27 22:29 sntn/_nts.py
+-rw-r--r--  2.0 unx    11864 b- defN 24-May-22 17:45 sntn/_screening.py
+-rw-r--r--  2.0 unx    25008 b- defN 24-May-22 17:45 sntn/_solvers.py
+-rw-r--r--  2.0 unx     3333 b- defN 24-May-22 17:45 sntn/_split.py
+-rw-r--r--  2.0 unx    11988 b- defN 24-May-22 17:45 sntn/_tnorm.py
+-rw-r--r--  2.0 unx     1161 b- defN 24-May-22 17:45 sntn/dists.py
+-rw-r--r--  2.0 unx      632 b- defN 24-May-22 17:45 sntn/posi.py
+-rw-r--r--  2.0 unx     1869 b- defN 24-May-22 17:45 sntn/trialML.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-22 17:45 sntn/_cdf_bvn/__init__.py
+-rw-r--r--  2.0 unx     8466 b- defN 24-May-22 17:45 sntn/_cdf_bvn/_approx.py
+-rw-r--r--  2.0 unx     7472 b- defN 24-May-22 17:45 sntn/_cdf_bvn/_brute.py
+-rw-r--r--  2.0 unx     2074 b- defN 24-May-22 17:45 sntn/_cdf_bvn/_utils.py
+-rw-r--r--  2.0 unx       94 b- defN 24-May-22 17:45 sntn/benchmark/readme.md
+-rw-r--r--  2.0 unx      192 b- defN 24-May-22 17:45 sntn/benchmark/runtime.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-22 17:45 sntn/utilities/__init__.py
+-rw-r--r--  2.0 unx     3170 b- defN 24-May-22 17:45 sntn/utilities/grad.py
+-rw-r--r--  2.0 unx     5962 b- defN 24-May-22 17:45 sntn/utilities/linear.py
+-rw-r--r--  2.0 unx    23074 b- defN 24-May-22 17:45 sntn/utilities/utils.py
+-rw-r--r--  2.0 unx    35150 b- defN 24-May-27 23:34 sntn-0.0.9.dist-info/LICENSE.txt
+-rw-r--r--  2.0 unx    11297 b- defN 24-May-27 23:34 sntn-0.0.9.dist-info/METADATA
+-rw-r--r--  2.0 unx      110 b- defN 24-May-27 23:34 sntn-0.0.9.dist-info/WHEEL
+-rw-r--r--  2.0 unx        5 b- defN 24-May-27 23:34 sntn-0.0.9.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2116 b- defN 24-May-27 23:34 sntn-0.0.9.dist-info/RECORD
+28 files, 212127 bytes uncompressed, 69784 bytes compressed:  67.1%
```

## zipnote {}

```diff
@@ -63,23 +63,23 @@
 
 Filename: sntn/utilities/linear.py
 Comment: 
 
 Filename: sntn/utilities/utils.py
 Comment: 
 
-Filename: sntn-0.0.8.dist-info/LICENSE.txt
+Filename: sntn-0.0.9.dist-info/LICENSE.txt
 Comment: 
 
-Filename: sntn-0.0.8.dist-info/METADATA
+Filename: sntn-0.0.9.dist-info/METADATA
 Comment: 
 
-Filename: sntn-0.0.8.dist-info/WHEEL
+Filename: sntn-0.0.9.dist-info/WHEEL
 Comment: 
 
-Filename: sntn-0.0.8.dist-info/top_level.txt
+Filename: sntn-0.0.9.dist-info/top_level.txt
 Comment: 
 
-Filename: sntn-0.0.8.dist-info/RECORD
+Filename: sntn-0.0.9.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## sntn/_nts.py

```diff
@@ -97,16 +97,14 @@
         if fix_mu:
             mu1, mu2 = _mus_are_equal(mu1, mu2)
         self.fix_mu = fix_mu
         mu1, mu2, tau21, tau22, a, b, c1, c2 = broastcast_max_shape(mu1, mu2, tau21, tau22, a, b, c1, c2)
         assert np.all(tau21 > 0), 'tau21 needs to be strictly greater than zero'
         assert np.all(tau22 > 0), 'tau22 needs to be strictly greater than zero'
         assert np.all(b > a), 'b needs to be greated than a'
-        assert np.all(c1 > 0), 'c1 needs to be strictly greater than zero'
-        assert np.all(c2 > 0), 'c2 needs to be strictly greater than zero'
         # Capture the original shape for later transformations
         self.param_shape = mu1.shape
         # Flatten parameters
         mu1, mu2, tau21, tau22, a, b, c1, c2 = [x.flatten() for x in [mu1, mu2, tau21, tau22, a, b, c1, c2]]
         # Store the original attributes
         self.mu1, self.c1, self.tau21 = mu1, c1, tau21
         self.mu2, self.c2, self.tau22 = mu2, c2, tau22
@@ -193,15 +191,15 @@
         # Return to proper shape
         pval = reverse_broadcast_from_k(pval, self.param_shape)
         # Bound b/w [0,1]
         pval = np.clip(pval, 0, 1)
         return pval
             
 
-    def pdf(self, x:np.ndarray, **kwargs) -> np.ndarray:
+    def pdf(self, x:np.ndarray) -> np.ndarray:
         """Calculates the marginal density of the NTS distribution at some point x"""
         x = try2array(x)
         x = broadcast_to_k(x, self.param_shape)
         # Calculate pdf
         term1 = self.sigma1 * self.Z
         m1 = (x - self.theta1) / self.sigma1
         term2 = (self.beta-self.rho*m1) / np.sqrt(1-self.rho**2)
@@ -250,14 +248,17 @@
             method: str = 'fast', 
             tol_cdf: float = 1e-3, 
             verbose: bool = False, 
             verbose_iter: int = 50,
             root_iter: int | None = None,
             use_approx_init: bool = True,
             clip: float = 30,
+            calc_rvs_init: bool = True,
+            seed: int = 1234,
+            n_samp: int = 1000,
             **kwargs
         ) -> np.ndarray:
         """
         Returns the quantile of the NTS distribution(s)
         
         Arguments
         ---------
@@ -269,35 +270,51 @@
             After w(p) is found, check maximum error b/w |F(w) - p| < tol_cdf
         verbose: bool
             During the loop, should the iteration be printed? (default==False)
         verbose_iter: int
             During the loop, at which iteration should the print occur (default==50)
         root_iter: int | None
             For method=='root', how much roots should we solve at the same time? This is useful for an array of quantiles. Note that the final count will be between: (k*(iter//k) ,self.k). Defaults to self.k if is None
+        calc_rvs_init: bool = True
+            Should RVS be used to calculate an initial guestimate?
+        seed: int = 1234
+            If RVS is used, what seed should be used?
+        n_samp: int = 1000
+            How many samples are needed? Will be max(n_samp, len(p))
         use_approx_init: bool
             For the 'fast' method, should the 'approx' weights be initialized, or use the default from _fast_integrals? (default==True)
         clip: float
             For the 'fast' method, how to limit +- infinity to some large nubmer (default = 30)
         **kwargs           
             Will be passed onto _rootfinder_newton (consider 'use_gradclip', 'clip_low', or 'clip_high' for convergence failures)
         
         Methods
         -------
         fast:               Solves all roots simultaneously using Newton's method (unstable for small Z)
         root:               Solve all roots simultaneously (fast but unstable)
         loop:               Loop over all i,j configurations (slower but more stable)
-        approx:             Use the quantiles from each dist
+        approx:             Use the quantiles from each dist (i.e. c1*norm.ppf(alpha) + c2*tnorm(alpha)
+        rvs:                Use simulated data
         """
-        valid_ppf_methods = ['fast', 'root', 'approx', 'loop']
+        valid_ppf_methods = ['fast', 'root', 'approx', 'loop', 'rvs']
         assert method in valid_ppf_methods, f'method must be one of {valid_ppf_methods}'
         # Make sure aligns with the parameters
-        p = np.atleast_1d(p)
-        num_p = len(p)
-        p = broadcast_to_k(p, self.param_shape)
-        w0 = self.c1*self.dist_Z1.ppf(p) + self.c2*self.dist_Z2.ppf(p)
+        orig_p = np.atleast_1d(p)
+        assert (len(orig_p.shape) == 1) | (orig_p.shape == self.param_shape), f'currently the ppf method only supports broadcasting an array of percentiles, or matching the original parameter shape: {self.param_shape}. Your shape = {orig_p.shape}'
+        num_p = len(orig_p)
+        p = broadcast_to_k(orig_p, self.param_shape)
+        if use_approx_init and method == 'fast':  # Override the RVS
+            calc_rvs_init = False
+        if calc_rvs_init:
+            n_samp = max(n_samp, num_p)
+            W_sample = self.rvs(n_samp, seed)
+            w0 = np.quantile(W_sample, q=orig_p, axis=0)
+            w0 = broadcast_to_k(w0, self.param_shape)
+        else:
+            w0 = self.c1*self.dist_Z1.ppf(p) + self.c2*self.dist_Z2.ppf(p)
         assert p.shape == w0.shape, 'Expected ppf of dist_Z{12} to align with p shape'
         if method == 'fast':
             # Solve in the m(w) space
             kwargs_newton = get_valid_kwargs_func(_rootfinder_newton, **kwargs)
             # Broadcast the parameters
             target_p = np.squeeze(self.Z * p)  # If it can be flat, let it be
             target_p, beta, alpha, rho, sigma1, theta1, Zphi = np.broadcast_arrays(target_p, self.beta, self.alpha, self.rho, self.sigma1, self.theta1, self.Z)
@@ -309,31 +326,37 @@
                 w_init = np.broadcast_to(np.squeeze(w0), shape=theta1.shape)
                 m_init = (w_init - theta1) / sigma1
                 kwargs_newton['x0_vec'] = m_init
             m_roots = _rootfinder_newton(ub=beta, lb=alpha, rho=rho, target_p=target_p, **kwargs_newton)
             # Solve for w
             w = m_roots * sigma1 + theta1
             cdf_roots = bvn_cdf_diff(x1=m_roots, x2a=beta, x2b=alpha, rho=rho) / Zphi
+            cdf_roots = np.clip(cdf_roots, 0, 1)
             err_cdf = np.abs(cdf_roots - np.squeeze(p))
             # Identify any failures
             if err_cdf.max() > tol_cdf:
-                idx_err = (err_cdf > tol_cdf).flatten()
-                warn(f'Heads ups, a total of {idx_err.sum()} roots of {len(idx_err)} need to be resolved with a slower method')
-                tmp_sntn = _nts(mu1=self.mu1[idx_err], mu2=self.mu2[idx_err], 
-                                tau21=self.tau21[idx_err], tau22=self.tau22[idx_err], 
-                                a=self.a[idx_err], b=self.b[idx_err], 
-                                c1=self.c1[idx_err], x2=self.c2[idx_err], fix_mu=self.fix_mu)
-                tmp_z = tmp_sntn.ppf(p[idx_err]).flatten()
-                w[idx_err] = tmp_z
-                tmp_err_cdf = np.abs(tmp_sntn.cdf(tmp_z) - p)
-                idx_fail = tmp_err_cdf > tol_cdf
-                if idx_fail.any():
-                    warn(f'Even with the resolve, a total of {idx_fail.sum()} of the {len(idx_fail)} problem quantiles have still failed')
+                idx_err = err_cdf > tol_cdf
+                warn(f'Heads ups, a total of {idx_err.sum()} roots of {np.prod(idx_err.shape)} could not be solved, using random draws to approximate, adjust the n_samp argument as needed')
+                # There parameters have at least one erro
+                idx_err_params = np.any(idx_err, axis=0)
+                full_mask = np.zeros_like(w, dtype=bool)  # Initialize a mask of the same shape as w
+                full_mask[:, idx_err_params] = idx_err[:, idx_err_params]  # Apply error flags based on your conditions
+                tmp_sntn = _nts(mu1=self.mu1[idx_err_params], mu2=self.mu2[idx_err_params], 
+                                    tau21=self.tau21[idx_err_params], tau22=self.tau22[idx_err_params], 
+                                    a=self.a[idx_err_params], b=self.b[idx_err_params], 
+                                    c1=self.c1[idx_err_params], x2=self.c2[idx_err_params], fix_mu=self.fix_mu)
+                # Calculate the quantiles (some may be superfluous if there's no error)
+                w_err = np.quantile(tmp_sntn.rvs(n_samp, seed), orig_p, axis=0)
+                # Overwrite the relevant indices
+                w[full_mask] = w_err[full_mask[:, idx_err_params]]
             # Reshape for reverse_broadcast_from_k
             w = w.reshape(w0.shape)
+        if method == 'rvs':
+            w = np.quantile(self.rvs(n_samp, seed), orig_p, axis=0)
+            w = w.reshape(w0.shape)
         if method == 'approx':
             # Use the simple quantiles
             w = w0.copy()
         if method == 'root':
             # err_cdf_p needs to be flattened
             w0_flat, p_flat = w0.flatten(), p.flatten()
             # How many calculations can we get per iteration (max of root_iter)
@@ -341,15 +364,14 @@
                 root_iter = self.k
             iter_act = self.k * (root_iter // self.k)
             n_loop = int(np.ceil(self.k * num_p / iter_act))
             vprint(f'Calculating {iter_act} roots per iteration over {n_loop} loops', verbose)
             # Loop over all solutions
             kwargs_root = get_valid_kwargs_func(root, **kwargs)
             solution = np.zeros(w0_flat.shape)
-            # breakpoint()
             for loop in range(n_loop):
                 # Break up into batches of at most 
                 idx_low, idx_high = iter_act*loop, iter_act*(loop+1)
                 w0_loop, p_loop = w0_flat[idx_low:idx_high], p_flat[idx_low: idx_high]
                 solroot = root(self._err_cdf_p, w0_loop, args=(p_loop, ), **kwargs_root)
                 if (loop+1) == n_loop:
                     solution[idx_low:] = solroot.x  # Last iteration may have a different shape
@@ -370,18 +392,23 @@
             for j in range(self.k):
                 dist_j = _nts(self.mu1[j], self.tau21[j], self.mu2[j], self.tau22[j], self.a[j], self.b[j], self.c1[j], self.c2[j], cdf_approach=self.bvn.cdf_approach)
                 fun_j = lambda xx, pp: dist_j.cdf(xx) - pp            
                 # Inner loop are the n quantile point
                 for i in range(n):
                     w0_ij = w0[i,j]
                     p_ij = p[i,j]
-                    solution_ij = root(fun_j, w0_ij, args=(p_ij))
+                    solution_ij = root(fun=fun_j, x0=w0_ij, args=(p_ij))
                     merr_ij = np.max(np.abs(solution_ij.fun))
                     if merr_ij > tol_cdf:
-                        warn(f'Error {merr_ij:.5f} > {tol_cdf:.5f} at iteration i={i}, j={j}')
+                        warn(f'Error {merr_ij:.5f} > {tol_cdf:.5f} at iteration i={i}, j={j}, trying alternative solution')
+                        if j >= 1:
+                            # Try the previous solutions (works best when p_seq has a small space)
+                            solution_ij = root(fun=fun_j, x0=w[i,j-1], args=(p_ij))
+                            if np.max(np.abs(solution_ij.fun)) < tol_cdf:
+                                continue
                     w[i,j] = solution_ij.x[0]
                     if verbose:
                         ncomp = i*self.k + (j+1)
                         if ncomp % verbose_iter == 0:
                             dtime = time() - stime
                             nleft = ntot - ncomp
                             rate = ncomp / dtime
```

## Comparing `sntn-0.0.8.dist-info/LICENSE.txt` & `sntn-0.0.9.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `sntn-0.0.8.dist-info/METADATA` & `sntn-0.0.9.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: sntn
-Version: 0.0.8
+Version: 0.0.9
 Summary: Sum of a normal and a truncated Normal (SNTN)
 Home-page: https://github.com/ErikinBC/SNTN
 Author: Erik Drysdale
 Author-email: erikinwest@gmail.com
 License: GPLv3
 Classifier: Development Status :: 3 - Alpha
 Classifier: Intended Audience :: Science/Research
@@ -43,27 +43,23 @@
 \end{align*}
 $$
 
 <br>
 
 # Installation
 
-See [pypi](https://pypi.org/project/sntn/). 
+See [pypi](https://pypi.org/project/sntn/). To check that the package compiled properly, please run `python3 -m sntn`.
 
 **Please make sure you have atleast python>=3.11!**
 
-1. numpy<=1.24.2
-2. pandas<=2.0.0
-3. scipy<=1.9.3
-4. glmnet<=2.2.1
-
-I recommend using `conda install -c conda-forge glmnet`. To check that the package compiled properly, please run `python3 -m sntn`.
+For custom development to the source code, you can try either: `conda env create -f env.yml`, or if anaconda give you environment solving errors, you can install tye main packages with `conda install -c conda-forge plotnine=0.10.1 glmnet=2.2.1 numpy=1.24.2 pandas=2.0.0 scikit-learn=1.2.2 setuptools=65.6.3 pip=23.0.1` followed by `twine==5.1.0 pytest==8.2.1`.
 
 <br>
 
+
 # main classes
 
 There are six classes from this package that are likely to be used by practioneers. Functions or classes that start with an underscore "_" are designed for internal use, but some of the their optional arguments may be of interest.
 
 1. `dists.nts(mu1, tau21, mu2, tau22, a, b, c1=1, c2=1)`: main class for the doing inference on a SNTN distribution, with the usual scipy-like methods: `cdf`, `pdf`, `ppf`, and `rvs` as well as a `conf_int` method for generating exact confidence intervals (default is to assume that the X's are equally weighted c1=c2=1). Optional keyword arguments include `fix_mu:bool` which forces mu1=mu2, which is useful for generating confidence intervals or quantiles when the nulll hypothesis is that both $X_1$ and $X_2$ have the same underlying mean, as well as any other named parameter which can go into `dists._bvn` (discussed below). 
 2. `dists.tnorm(mu, sigma2, a, b)`: Wrapper for key methods of a truncated normal from the `scipy.stats.truncnorm` class along with a `conf_int` method to generate exact confidence intervals for a truncated normal distribution (which can be used by a 100%-screening approach for PoSI) and matches the intervals that will get produced by the [selectiveInference package](https://cran.r-project.org/web/packages/selectiveInference/). Note that this class accepts the lower/upper bounds as is, and does not require them to be transformed in advance (as scipy does). Both `nts` and `tnorm` use `_solvers.conf_inf_solver._conf_int` to find confidence intervals and kwargs can be passed into it.
 3. `dists.bvn(mu1, sigma21, mu2, sigma22, rho)`:  Custom bivariate normal (BVN) distribution with `cdf` and `rvs` methods. Uses can pass `cdf_approach={scipy, cox1, cox2, owen, drezner1, drezner2}` as a kwarg, with the default set to owen (which uses the Owens-T, and is very fast, but can be numerically instable if $|\rho| \approx 1$). Each cdf_approach has its own kwargs which can be passed in during construction (e.g. `_cdf_bvn._approx._bvn_cox`).
```

## Comparing `sntn-0.0.8.dist-info/RECORD` & `sntn-0.0.9.dist-info/RECORD`

 * *Files 15% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 sntn/__init__.py,sha256=NeZAcWUHcfs1-EcyjuIsAhJao2BL9Q4p3u_x7QxDy7w,69
 sntn/__main__.py,sha256=Yq8-L_i5x5WpyRbx2uZOXYz_mj5LDfeJAOE3z6M_sxM,1139
 sntn/_bvn.py,sha256=w9uBXl-zR7lEsobviP-KdtIBOGa797mMMm42C-vBIxw,6325
 sntn/_fast_integrals.py,sha256=f8v8USXbM5qt2vOpllj756aju_ue-H46fraiU9nZoaQ,7456
 sntn/_lasso.py,sha256=Lhxgo9oWpw0OAfzbIHGyfCKYpJSTjfBOnsu3JIm-OHo,15431
-sntn/_nts.py,sha256=rfsy6q6IGYdXPQl9E-S7h7DZLp07qrSbWZd-b0WdCtU,24865
+sntn/_nts.py,sha256=QDcSorvrbm_edlqhRp1HmRoJTIm1y5vW5gXmGgniMSk,26670
 sntn/_screening.py,sha256=7F9yHG6QuAy9EwKF3qgyPeU4Z-23L-vBrVlFOGFLNto,11864
 sntn/_solvers.py,sha256=l6i5F1dun73w0fW_WOr8HKqu1pXr5Bx9_ccRwNLcwQg,25008
 sntn/_split.py,sha256=8_RLPj98Wagczt9mgugpg3yS95H92xiBf_EaXA6XS0o,3333
 sntn/_tnorm.py,sha256=Q9XPLq4c1Sq-r22EoNDupr0i70VnxMK6d_-rjvG1xVg,11988
 sntn/dists.py,sha256=Ug64eew7pMls9uuxVWlX8ie1m4_Een7A1nzN1vTlAuQ,1161
 sntn/posi.py,sha256=tjYgQ3AEbfBrFrOMLrTBScAet6eEMjFXwZzsABQ6cFY,632
 sntn/trialML.py,sha256=QmoC3z7bQWN2q4rIsQ-H_HYHSnN69QDRoh9unW5JucQ,1869
@@ -17,12 +17,12 @@
 sntn/_cdf_bvn/_utils.py,sha256=V8giGaPmTBgZN-0MHrMiDRE0veUQJYY16wrCOgAAdUY,2074
 sntn/benchmark/readme.md,sha256=sgppexoNzjL8yAYkQHZdcJh54dV0AhGIh6DHlxV6YrA,94
 sntn/benchmark/runtime.py,sha256=sBNYHiAwjREAHOub2cHyJsXp4v9KVgtDw5nXPB8LnLo,192
 sntn/utilities/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 sntn/utilities/grad.py,sha256=9Lql7n58Hh3N1_JYOhMbCr-m_Y_EP82d6bKRE1s7LS8,3170
 sntn/utilities/linear.py,sha256=VgjZYA8yP8WOjWY3x4dFeb4V3haVMcbcN6sb1DkMzCc,5962
 sntn/utilities/utils.py,sha256=SydKPrYgSY6Fz-IEipN3FrtoiggcGzkg0q0rQYsYycA,23074
-sntn-0.0.8.dist-info/LICENSE.txt,sha256=5X8cMguM-HmKfS_4Om-eBqM6A1hfbgZf6pfx2G24QFI,35150
-sntn-0.0.8.dist-info/METADATA,sha256=vQJnuGNXNGIOoQdcZsqc-zWgcrKnODcDRruGZcqprmE,11061
-sntn-0.0.8.dist-info/WHEEL,sha256=DZajD4pwLWue70CAfc7YaxT1wLUciNBvN_TTcvXpltE,110
-sntn-0.0.8.dist-info/top_level.txt,sha256=edQ28OSe7s2OMbEmB2gVzrm-AGUXP2Ai44GLFkTwh7I,5
-sntn-0.0.8.dist-info/RECORD,,
+sntn-0.0.9.dist-info/LICENSE.txt,sha256=5X8cMguM-HmKfS_4Om-eBqM6A1hfbgZf6pfx2G24QFI,35150
+sntn-0.0.9.dist-info/METADATA,sha256=c7LLxnVCUwarRyBd8zvbrl_hlGIMtLqPB2wVkw6u5Zo,11297
+sntn-0.0.9.dist-info/WHEEL,sha256=DZajD4pwLWue70CAfc7YaxT1wLUciNBvN_TTcvXpltE,110
+sntn-0.0.9.dist-info/top_level.txt,sha256=edQ28OSe7s2OMbEmB2gVzrm-AGUXP2Ai44GLFkTwh7I,5
+sntn-0.0.9.dist-info/RECORD,,
```


# Comparing `tmp/KratosShapeOptimizationApplication-9.5-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip` & `tmp/KratosShapeOptimizationApplication-9.5.1-cp39-cp39-win_amd64.whl.zip`

## zipinfo -v {}

 * *Differences in extra fields detected; using output from zipinfo -v*

```diff
@@ -1,2918 +1,1960 @@
 There is no zipfile comment.
 
 End-of-central-directory record:
 -------------------------------
 
-  Zip archive file size:                   2398279 (0000000000249847h)
-  Actual end-cent-dir record offset:       2398257 (0000000000249831h)
-  Expected end-cent-dir record offset:     2398257 (0000000000249831h)
+  Zip archive file size:                    808846 (00000000000C578Eh)
+  Actual end-cent-dir record offset:        808824 (00000000000C5778h)
+  Expected end-cent-dir record offset:      808824 (00000000000C5778h)
   (based on the length of the central directory and its expected offset)
 
   This zipfile constitutes the sole disk of a single-part archive; its
-  central directory contains 79 entries.
-  The central directory is 11507 (0000000000002CF3h) bytes long,
+  central directory contains 67 entries.
+  The central directory is 8411 (00000000000020DBh) bytes long,
   and its (expected) offset in bytes from the beginning of the zipfile
-  is 2386750 (0000000000246B3Eh).
+  is 800413 (00000000000C369Dh).
 
 
 Central directory entry #1:
 ---------------------------
 
-  KratosMultiphysics/
+  KratosMultiphysics/.libs/KratosShapeOptimizationApplication.pyd
 
   offset of local header from start of archive:   0
                                                   (0000000000000000h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             19 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:42
+  32-bit CRC value (hex):                         a4de43c3
+  compressed size:                                215494 bytes
+  uncompressed size:                              654848 bytes
+  length of filename:                             63 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #2:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/
+  KratosMultiphysics/.libs/KratosShapeOptimizationCore.dll
 
-  offset of local header from start of archive:   77
-                                                  (000000000000004Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   215587
+                                                  (0000000000034A23h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             48 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:42
+  32-bit CRC value (hex):                         6ac38c7a
+  compressed size:                                457752 bytes
+  uncompressed size:                              1359360 bytes
+  length of filename:                             56 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #3:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/optimizer_factory.py
+  KratosMultiphysics/.libs/KratosShapeOptimizationCore.lib
 
-  offset of local header from start of archive:   183
-                                                  (00000000000000B7h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   673425
+                                                  (00000000000A4691h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         20993b18
-  compressed size:                                2280 bytes
-  uncompressed size:                              13333 bytes
-  length of filename:                             68 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:42
+  32-bit CRC value (hex):                         fe4e9439
+  compressed size:                                29853 bytes
+  uncompressed size:                              281238 bytes
+  length of filename:                             56 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #4:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/loggers/
+  KratosMultiphysics/ShapeOptimizationApplication/TemplateMainKratosShapeOptimization.py
 
-  offset of local header from start of archive:   2589
-                                                  (0000000000000A1Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   703364
+                                                  (00000000000ABB84h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             56 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         4cdab683
+  compressed size:                                529 bytes
+  uncompressed size:                              1373 bytes
+  length of filename:                             86 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #5:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_penalized_projection.py
+  KratosMultiphysics/ShapeOptimizationApplication/__init__.py
 
-  offset of local header from start of archive:   2703
-                                                  (0000000000000A8Fh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   704009
+                                                  (00000000000ABE09h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         e264471a
-  compressed size:                                964 bytes
-  uncompressed size:                              4353 bytes
-  length of filename:                             92 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         ab3419a4
+  compressed size:                                219 bytes
+  uncompressed size:                              829 bytes
+  length of filename:                             59 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #6:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_relaxed_gradient_projection.py
+  KratosMultiphysics/ShapeOptimizationApplication/communicator_factory.py
 
-  offset of local header from start of archive:   3817
-                                                  (0000000000000EE9h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   704317
+                                                  (00000000000ABF3Dh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         f82d1bea
-  compressed size:                                1071 bytes
-  uncompressed size:                              6523 bytes
-  length of filename:                             99 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         4279d89a
+  compressed size:                                1872 bytes
+  uncompressed size:                              13757 bytes
+  length of filename:                             71 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #7:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_vtk.py
+  KratosMultiphysics/ShapeOptimizationApplication/mapper_factory.py
 
-  offset of local header from start of archive:   5045
-                                                  (00000000000013B5h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   706290
+                                                  (00000000000AC6F2h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         12105350
-  compressed size:                                1140 bytes
-  uncompressed size:                              4488 bytes
-  length of filename:                             76 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         51a51ee5
+  compressed size:                                1207 bytes
+  uncompressed size:                              5575 bytes
+  length of filename:                             65 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #8:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_gid.py
+  KratosMultiphysics/ShapeOptimizationApplication/model_part_controller_factory.py
 
-  offset of local header from start of archive:   6319
-                                                  (00000000000018AFh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   707592
+                                                  (00000000000ACC08h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         27885df0
-  compressed size:                                1259 bytes
-  uncompressed size:                              5466 bytes
-  length of filename:                             76 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         bf97567b
+  compressed size:                                1772 bytes
+  uncompressed size:                              9924 bytes
+  length of filename:                             80 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #9:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_gradient_projection.py
+  KratosMultiphysics/ShapeOptimizationApplication/optimizer_factory.py
 
-  offset of local header from start of archive:   7712
-                                                  (0000000000001E20h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   709474
+                                                  (00000000000AD362h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         f9804d6d
-  compressed size:                                946 bytes
-  uncompressed size:                              4418 bytes
-  length of filename:                             91 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         6087214f
+  compressed size:                                2297 bytes
+  uncompressed size:                              13568 bytes
+  length of filename:                             68 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #10:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_unv.py
+  KratosMultiphysics/ShapeOptimizationApplication/algorithms/__init__.py
 
-  offset of local header from start of archive:   8807
-                                                  (0000000000002267h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   711869
+                                                  (00000000000ADCBDh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         ef78b1bd
-  compressed size:                                895 bytes
-  uncompressed size:                              3603 bytes
-  length of filename:                             76 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                2 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             70 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #11:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_steepest_descent.py
+  KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_base.py
 
-  offset of local header from start of archive:   9836
-                                                  (000000000000266Ch) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   711971
+                                                  (00000000000ADD23h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         14ed5c43
-  compressed size:                                811 bytes
-  uncompressed size:                              3445 bytes
-  length of filename:                             88 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         dbf313b5
+  compressed size:                                329 bytes
+  uncompressed size:                              1725 bytes
+  length of filename:                             76 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #12:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_bead_optimization.py
+  KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_bead_optimization.py
 
-  offset of local header from start of archive:   10793
-                                                  (0000000000002A29h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   712406
+                                                  (00000000000ADED6h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         2239db97
-  compressed size:                                959 bytes
-  uncompressed size:                              4791 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         759b31d7
+  compressed size:                                4211 bytes
+  uncompressed size:                              22391 bytes
   length of filename:                             89 characters
-  length of extra field:                          24 bytes
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #13:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_shape_fraction_optimization.py
+  KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_factory.py
 
-  offset of local header from start of archive:   11899
-                                                  (0000000000002E7Bh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   716736
+                                                  (00000000000AEFC0h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         e9e947a3
-  compressed size:                                1012 bytes
-  uncompressed size:                              5161 bytes
-  length of filename:                             99 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         f687111e
+  compressed size:                                581 bytes
+  uncompressed size:                              3535 bytes
+  length of filename:                             79 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #14:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_base.py
+  KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_gradient_projection.py
 
-  offset of local header from start of archive:   13068
-                                                  (000000000000330Ch) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   717426
+                                                  (00000000000AF272h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         121ed1f7
-  compressed size:                                331 bytes
-  uncompressed size:                              1423 bytes
-  length of filename:                             77 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         ce2823ba
+  compressed size:                                3310 bytes
+  uncompressed size:                              16642 bytes
+  length of filename:                             91 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #15:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/loggers/sensitivity_heatmap_logger.py
+  KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_penalized_projection.py
 
-  offset of local header from start of archive:   13534
-                                                  (00000000000034DEh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   720857
+                                                  (00000000000AFFD9h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         7e363a27
-  compressed size:                                924 bytes
-  uncompressed size:                              4893 bytes
-  length of filename:                             85 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         2ce2cd9d
+  compressed size:                                2413 bytes
+  uncompressed size:                              12034 bytes
+  length of filename:                             92 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #16:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/loggers/data_logger_factory.py
+  KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_relaxed_gradient_projection.py
 
-  offset of local header from start of archive:   14601
-                                                  (0000000000003909h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   723392
+                                                  (00000000000B09C0h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         3a08dc02
-  compressed size:                                1907 bytes
-  uncompressed size:                              11563 bytes
-  length of filename:                             78 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         572aef6d
+  compressed size:                                5052 bytes
+  uncompressed size:                              30725 bytes
+  length of filename:                             99 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #17:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_trust_region.py
+  KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_shape_fraction_optimization.py
 
-  offset of local header from start of archive:   16644
-                                                  (0000000000004104h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   728573
+                                                  (00000000000B1DFDh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         99772522
-  compressed size:                                1150 bytes
-  uncompressed size:                              5835 bytes
-  length of filename:                             84 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         50e8fcf7
+  compressed size:                                5351 bytes
+  uncompressed size:                              30335 bytes
+  length of filename:                             99 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #18:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/loggers/__init__.py
+  KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_steepest_descent.py
 
-  offset of local header from start of archive:   17936
-                                                  (0000000000004610h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  offset of local header from start of archive:   734053
+                                                  (00000000000B3365h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             67 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         808d7649
+  compressed size:                                2945 bytes
+  uncompressed size:                              13418 bytes
+  length of filename:                             88 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #19:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_base.py
+  KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_trust_region.py
 
-  offset of local header from start of archive:   18061
-                                                  (000000000000468Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   737116
+                                                  (00000000000B3F5Ch) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         c165a755
-  compressed size:                                1259 bytes
-  uncompressed size:                              6205 bytes
-  length of filename:                             76 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         7526ad20
+  compressed size:                                6130 bytes
+  uncompressed size:                              32060 bytes
+  length of filename:                             84 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #20:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/response_functions/
+  KratosMultiphysics/ShapeOptimizationApplication/analyzers/__init__.py
 
-  offset of local header from start of archive:   19454
-                                                  (0000000000004BFEh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   743360
+                                                  (00000000000B57C0h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
   32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
+  compressed size:                                2 bytes
   uncompressed size:                              0 bytes
-  length of filename:                             67 characters
-  length of extra field:                          24 bytes
+  length of filename:                             69 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #21:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/response_functions/mesh_based_packaging.py
+  KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_base.py
 
-  offset of local header from start of archive:   19579
-                                                  (0000000000004C7Bh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   743461
+                                                  (00000000000B5825h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         be530d16
-  compressed size:                                1061 bytes
-  uncompressed size:                              3464 bytes
-  length of filename:                             90 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         0b0c6615
+  compressed size:                                350 bytes
+  uncompressed size:                              1346 bytes
+  length of filename:                             74 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #22:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/response_functions/airfoil_2d_responses.py
+  KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_empty.py
 
-  offset of local header from start of archive:   20788
-                                                  (0000000000005134h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   743915
+                                                  (00000000000B59EBh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         af2c0914
-  compressed size:                                1352 bytes
-  uncompressed size:                              8085 bytes
-  length of filename:                             90 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         76b20448
+  compressed size:                                267 bytes
+  uncompressed size:                              877 bytes
+  length of filename:                             75 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #23:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/response_functions/packaging_response_base.py
+  KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_factory.py
 
-  offset of local header from start of archive:   22288
-                                                  (0000000000005710h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   744287
+                                                  (00000000000B5B5Fh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         2834d77c
-  compressed size:                                1767 bytes
-  uncompressed size:                              6244 bytes
-  length of filename:                             93 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         becf7ce3
+  compressed size:                                2564 bytes
+  uncompressed size:                              15569 bytes
+  length of filename:                             77 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #24:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/response_functions/total_volume.py
+  KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_internal.py
 
-  offset of local header from start of archive:   24206
-                                                  (0000000000005E8Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   746958
+                                                  (00000000000B65CEh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         96f85c4b
-  compressed size:                                732 bytes
-  uncompressed size:                              2030 bytes
-  length of filename:                             82 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         e8bfe39e
+  compressed size:                                1953 bytes
+  uncompressed size:                              8438 bytes
+  length of filename:                             78 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #25:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/response_functions/surface_normal_shape_change.py
+  KratosMultiphysics/ShapeOptimizationApplication/custom_ios/__init__.py
 
-  offset of local header from start of archive:   25078
-                                                  (00000000000061F6h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   749019
+                                                  (00000000000B6DDBh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         6165a92d
-  compressed size:                                1582 bytes
-  uncompressed size:                              5308 bytes
-  length of filename:                             97 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                2 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             70 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #26:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/response_functions/response_function_factory.py
+  KratosMultiphysics/ShapeOptimizationApplication/custom_ios/wrl_io.py
 
-  offset of local header from start of archive:   26815
-                                                  (00000000000068BFh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   749121
+                                                  (00000000000B6E41h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         f7b64a62
-  compressed size:                                558 bytes
-  uncompressed size:                              2202 bytes
-  length of filename:                             95 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         707bd9cc
+  compressed size:                                993 bytes
+  uncompressed size:                              3006 bytes
+  length of filename:                             68 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #27:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/response_functions/face_angle.py
+  KratosMultiphysics/ShapeOptimizationApplication/custom_ios/wrl_reader.py
 
-  offset of local header from start of archive:   27526
-                                                  (0000000000006B86h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   750212
+                                                  (00000000000B7284h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         3c397e2e
-  compressed size:                                1801 bytes
-  uncompressed size:                              6177 bytes
-  length of filename:                             80 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         33966d9b
+  compressed size:                                1004 bytes
+  uncompressed size:                              3715 bytes
+  length of filename:                             72 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #28:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/response_functions/plane_based_packaging.py
+  KratosMultiphysics/ShapeOptimizationApplication/loggers/__init__.py
 
-  offset of local header from start of archive:   29465
-                                                  (0000000000007319h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   751318
+                                                  (00000000000B76D6h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         aa916dea
-  compressed size:                                791 bytes
-  uncompressed size:                              2364 bytes
-  length of filename:                             91 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                2 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             67 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #29:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/response_functions/__init__.py
+  KratosMultiphysics/ShapeOptimizationApplication/loggers/data_logger_factory.py
 
-  offset of local header from start of archive:   30405
-                                                  (00000000000076C5h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  offset of local header from start of archive:   751417
+                                                  (00000000000B7739h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         c8921a08
+  compressed size:                                1920 bytes
+  uncompressed size:                              11762 bytes
   length of filename:                             78 characters
-  length of extra field:                          24 bytes
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #30:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/model_part_controller_factory.py
+  KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_base.py
 
-  offset of local header from start of archive:   30541
-                                                  (000000000000774Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   753445
+                                                  (00000000000B7F25h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         4f8ced3c
-  compressed size:                                1759 bytes
-  uncompressed size:                              9727 bytes
-  length of filename:                             80 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         2af3842e
+  compressed size:                                333 bytes
+  uncompressed size:                              1451 bytes
+  length of filename:                             77 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #31:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/custom_ios/
+  KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_gid.py
 
-  offset of local header from start of archive:   32438
-                                                  (0000000000007EB6h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   753885
+                                                  (00000000000B80DDh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             59 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         1d6b3c00
+  compressed size:                                1272 bytes
+  uncompressed size:                              5577 bytes
+  length of filename:                             76 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #32:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/custom_ios/wrl_reader.py
+  KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_unv.py
 
-  offset of local header from start of archive:   32555
-                                                  (0000000000007F2Bh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   755263
+                                                  (00000000000B863Fh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         a36e6517
-  compressed size:                                993 bytes
-  uncompressed size:                              3596 bytes
-  length of filename:                             72 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         a47498f6
+  compressed size:                                903 bytes
+  uncompressed size:                              3676 bytes
+  length of filename:                             76 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #33:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/custom_ios/wrl_io.py
+  KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_vtk.py
 
-  offset of local header from start of archive:   33678
-                                                  (000000000000838Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   756272
+                                                  (00000000000B8A30h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         2e0080bf
-  compressed size:                                984 bytes
-  uncompressed size:                              2924 bytes
-  length of filename:                             68 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         b73b3aeb
+  compressed size:                                1148 bytes
+  uncompressed size:                              4584 bytes
+  length of filename:                             76 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #34:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/custom_ios/__init__.py
+  KratosMultiphysics/ShapeOptimizationApplication/loggers/sensitivity_heatmap_logger.py
 
-  offset of local header from start of archive:   34788
-                                                  (00000000000087E4h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  offset of local header from start of archive:   757526
+                                                  (00000000000B8F16h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             70 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         1631cca1
+  compressed size:                                931 bytes
+  uncompressed size:                              4984 bytes
+  length of filename:                             85 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #35:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/
+  KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_base.py
 
-  offset of local header from start of archive:   34916
-                                                  (0000000000008864h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   758572
+                                                  (00000000000B932Ch) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             65 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:56
+  32-bit CRC value (hex):                         c4e0feaa
+  compressed size:                                1269 bytes
+  uncompressed size:                              6333 bytes
+  length of filename:                             76 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #36:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_basic_updating.py
+  KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_bead_optimization.py
 
-  offset of local header from start of archive:   35039
-                                                  (00000000000088DFh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   759947
+                                                  (00000000000B988Bh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         932c9dbc
-  compressed size:                                463 bytes
-  uncompressed size:                              1609 bytes
-  length of filename:                             98 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         e861c400
+  compressed size:                                970 bytes
+  uncompressed size:                              4870 bytes
+  length of filename:                             89 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #37:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_with_solver.py
+  KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_gradient_projection.py
 
-  offset of local header from start of archive:   35658
-                                                  (0000000000008B4Ah) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   761036
+                                                  (00000000000B9CCCh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         488d4119
-  compressed size:                                2733 bytes
-  uncompressed size:                              12262 bytes
-  length of filename:                             95 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         253aef67
+  compressed size:                                952 bytes
+  uncompressed size:                              4498 bytes
+  length of filename:                             91 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #38:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_base.py
+  KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_penalized_projection.py
 
-  offset of local header from start of archive:   38544
-                                                  (0000000000009690h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   762109
+                                                  (00000000000BA0FDh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         df92ed49
-  compressed size:                                297 bytes
-  uncompressed size:                              994 bytes
-  length of filename:                             88 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         161785e5
+  compressed size:                                974 bytes
+  uncompressed size:                              4432 bytes
+  length of filename:                             92 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #39:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/__init__.py
+  KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_relaxed_gradient_projection.py
 
-  offset of local header from start of archive:   38987
-                                                  (000000000000984Bh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  offset of local header from start of archive:   763205
+                                                  (00000000000BA545h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             76 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         43e88885
+  compressed size:                                1080 bytes
+  uncompressed size:                              6630 bytes
+  length of filename:                             99 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #40:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/TemplateMainKratosShapeOptimization.py
+  KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_shape_fraction_optimization.py
 
-  offset of local header from start of archive:   39121
-                                                  (00000000000098D1h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   764414
+                                                  (00000000000BA9FEh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         9bdce1d2
-  compressed size:                                524 bytes
-  uncompressed size:                              1343 bytes
-  length of filename:                             86 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         020428d6
+  compressed size:                                1022 bytes
+  uncompressed size:                              5253 bytes
+  length of filename:                             99 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #41:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/mapper_factory.py
+  KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_steepest_descent.py
 
-  offset of local header from start of archive:   39789
-                                                  (0000000000009B6Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   765565
+                                                  (00000000000BAE7Dh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         e55f5369
-  compressed size:                                1195 bytes
-  uncompressed size:                              5476 bytes
-  length of filename:                             65 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         20a587ab
+  compressed size:                                821 bytes
+  uncompressed size:                              3509 bytes
+  length of filename:                             88 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #42:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/utilities/
-
-  offset of local header from start of archive:   41107
-                                                  (000000000000A093h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             58 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #43:
----------------------------
-
-  KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_math.py
+  KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_trust_region.py
 
-  offset of local header from start of archive:   41223
-                                                  (000000000000A107h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   766504
+                                                  (00000000000BB228h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         ee1e4f34
-  compressed size:                                3455 bytes
-  uncompressed size:                              14277 bytes
-  length of filename:                             72 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         780cd9db
+  compressed size:                                1160 bytes
+  uncompressed size:                              5935 bytes
+  length of filename:                             84 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #44:
+Central directory entry #43:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_variable_utilities.py
+  KratosMultiphysics/ShapeOptimizationApplication/mapping/__init__.py
 
-  offset of local header from start of archive:   44808
-                                                  (000000000000AF08h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   767778
+                                                  (00000000000BB722h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         e16fc270
-  compressed size:                                603 bytes
-  uncompressed size:                              2247 bytes
-  length of filename:                             86 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #45:
----------------------------
-
-  KratosMultiphysics/ShapeOptimizationApplication/utilities/__init__.py
-
-  offset of local header from start of archive:   45555
-                                                  (000000000000B1F3h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
   32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
+  compressed size:                                2 bytes
   uncompressed size:                              0 bytes
-  length of filename:                             69 characters
-  length of extra field:                          24 bytes
+  length of filename:                             67 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #46:
+Central directory entry #44:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_sensitivity_heatmap.py
+  KratosMultiphysics/ShapeOptimizationApplication/mapping/in_plane_vertex_morphing_mapper.py
 
-  offset of local header from start of archive:   45682
-                                                  (000000000000B272h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   767877
+                                                  (00000000000BB785h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         434e7c1d
-  compressed size:                                2129 bytes
-  uncompressed size:                              11819 bytes
-  length of filename:                             87 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         b9c4b0dd
+  compressed size:                                1776 bytes
+  uncompressed size:                              7041 bytes
+  length of filename:                             90 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #47:
+Central directory entry #45:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_timer.py
+  KratosMultiphysics/ShapeOptimizationApplication/mapping/sliding_vertex_morphing_mapper.py
 
-  offset of local header from start of archive:   47956
-                                                  (000000000000BB54h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   769773
+                                                  (00000000000BBEEDh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         e19905f2
-  compressed size:                                373 bytes
-  uncompressed size:                              1807 bytes
-  length of filename:                             73 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         59547a87
+  compressed size:                                3969 bytes
+  uncompressed size:                              19078 bytes
+  length of filename:                             89 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #48:
+Central directory entry #46:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/communicator_factory.py
+  KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/__init__.py
 
-  offset of local header from start of archive:   48460
-                                                  (000000000000BD4Ch) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   773861
+                                                  (00000000000BCEE5h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         b2c60a56
-  compressed size:                                1858 bytes
-  uncompressed size:                              13498 bytes
-  length of filename:                             71 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #49:
----------------------------
-
-  KratosMultiphysics/ShapeOptimizationApplication/analyzers/
-
-  offset of local header from start of archive:   50447
-                                                  (000000000000C50Fh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
   32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
+  compressed size:                                2 bytes
   uncompressed size:                              0 bytes
-  length of filename:                             58 characters
-  length of extra field:                          24 bytes
+  length of filename:                             76 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
-Central directory entry #50:
+Central directory entry #47:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_base.py
+  KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_base.py
 
-  offset of local header from start of archive:   50563
-                                                  (000000000000C583h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   773969
+                                                  (00000000000BCF51h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         452b3b2c
-  compressed size:                                345 bytes
-  uncompressed size:                              1316 bytes
-  length of filename:                             74 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         babf885b
+  compressed size:                                303 bytes
+  uncompressed size:                              1016 bytes
+  length of filename:                             88 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #51:
+Central directory entry #48:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_factory.py
+  KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_basic_updating.py
 
-  offset of local header from start of archive:   51040
-                                                  (000000000000C760h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   774390
+                                                  (00000000000BD0F6h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         0d022a43
-  compressed size:                                2547 bytes
-  uncompressed size:                              15259 bytes
-  length of filename:                             77 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         a39d623c
+  compressed size:                                471 bytes
+  uncompressed size:                              1643 bytes
+  length of filename:                             98 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #52:
+Central directory entry #49:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_empty.py
+  KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_with_solver.py
 
-  offset of local header from start of archive:   53722
-                                                  (000000000000D1DAh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   774989
+                                                  (00000000000BD34Dh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         890210dd
-  compressed size:                                262 bytes
-  uncompressed size:                              856 bytes
-  length of filename:                             75 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         0226b781
+  compressed size:                                2748 bytes
+  uncompressed size:                              12499 bytes
+  length of filename:                             95 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #53:
+Central directory entry #50:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_internal.py
+  KratosMultiphysics/ShapeOptimizationApplication/response_functions/__init__.py
 
-  offset of local header from start of archive:   54117
-                                                  (000000000000D365h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   777862
+                                                  (00000000000BDE86h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         cb752419
-  compressed size:                                1939 bytes
-  uncompressed size:                              8283 bytes
-  length of filename:                             78 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #54:
----------------------------
-
-  KratosMultiphysics/ShapeOptimizationApplication/analyzers/__init__.py
-
-  offset of local header from start of archive:   56192
-                                                  (000000000000DB80h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
   32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
+  compressed size:                                2 bytes
   uncompressed size:                              0 bytes
-  length of filename:                             69 characters
-  length of extra field:                          24 bytes
+  length of filename:                             78 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #55:
+Central directory entry #51:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/algorithms/
+  KratosMultiphysics/ShapeOptimizationApplication/response_functions/airfoil_2d_responses.py
 
-  offset of local header from start of archive:   56319
-                                                  (000000000000DBFFh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   777972
+                                                  (00000000000BDEF4h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             59 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         ffd74b0b
+  compressed size:                                1364 bytes
+  uncompressed size:                              8273 bytes
+  length of filename:                             90 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
-Central directory entry #56:
+Central directory entry #52:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_steepest_descent.py
+  KratosMultiphysics/ShapeOptimizationApplication/response_functions/face_angle.py
 
-  offset of local header from start of archive:   56436
-                                                  (000000000000DC74h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   779456
+                                                  (00000000000BE4C0h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         0c3a4188
-  compressed size:                                2925 bytes
-  uncompressed size:                              13163 bytes
-  length of filename:                             88 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         94fc0795
+  compressed size:                                1816 bytes
+  uncompressed size:                              6317 bytes
+  length of filename:                             80 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #57:
+Central directory entry #53:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_gradient_projection.py
+  KratosMultiphysics/ShapeOptimizationApplication/response_functions/mesh_based_packaging.py
 
-  offset of local header from start of archive:   59507
-                                                  (000000000000E873h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   781382
+                                                  (00000000000BEC46h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         aab73052
-  compressed size:                                3293 bytes
-  uncompressed size:                              16325 bytes
-  length of filename:                             91 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         b4ccc9aa
+  compressed size:                                1070 bytes
+  uncompressed size:                              3534 bytes
+  length of filename:                             90 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #58:
+Central directory entry #54:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_trust_region.py
+  KratosMultiphysics/ShapeOptimizationApplication/response_functions/packaging_response_base.py
 
-  offset of local header from start of archive:   62949
-                                                  (000000000000F5E5h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   782572
+                                                  (00000000000BF0ECh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         25c9aea8
-  compressed size:                                6093 bytes
-  uncompressed size:                              31404 bytes
-  length of filename:                             84 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         27ac7552
+  compressed size:                                1781 bytes
+  uncompressed size:                              6400 bytes
+  length of filename:                             93 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #59:
+Central directory entry #55:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_bead_optimization.py
+  KratosMultiphysics/ShapeOptimizationApplication/response_functions/plane_based_packaging.py
 
-  offset of local header from start of archive:   69184
-                                                  (0000000000010E40h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   784476
+                                                  (00000000000BF85Ch) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         2733b2f2
-  compressed size:                                4189 bytes
-  uncompressed size:                              21979 bytes
-  length of filename:                             89 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         b90a1fa9
+  compressed size:                                799 bytes
+  uncompressed size:                              2425 bytes
+  length of filename:                             91 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #60:
+Central directory entry #56:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_relaxed_gradient_projection.py
+  KratosMultiphysics/ShapeOptimizationApplication/response_functions/response_function_factory.py
 
-  offset of local header from start of archive:   73520
-                                                  (0000000000011F30h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   785396
+                                                  (00000000000BFBF4h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         77d5b334
-  compressed size:                                5031 bytes
-  uncompressed size:                              30146 bytes
-  length of filename:                             99 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         3692ca54
+  compressed size:                                565 bytes
+  uncompressed size:                              2242 bytes
+  length of filename:                             95 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #61:
+Central directory entry #57:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_base.py
+  KratosMultiphysics/ShapeOptimizationApplication/response_functions/surface_normal_shape_change.py
 
-  offset of local header from start of archive:   78708
-                                                  (0000000000013374h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   786086
+                                                  (00000000000BFEA6h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         5b2d68d6
-  compressed size:                                322 bytes
-  uncompressed size:                              1694 bytes
-  length of filename:                             76 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         a54605ba
+  compressed size:                                1597 bytes
+  uncompressed size:                              5433 bytes
+  length of filename:                             97 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #62:
+Central directory entry #58:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_penalized_projection.py
+  KratosMultiphysics/ShapeOptimizationApplication/response_functions/total_volume.py
 
-  offset of local header from start of archive:   79164
-                                                  (000000000001353Ch) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   787810
+                                                  (00000000000C0562h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         d020198f
-  compressed size:                                2398 bytes
-  uncompressed size:                              11809 bytes
-  length of filename:                             92 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         a61125ba
+  compressed size:                                745 bytes
+  uncompressed size:                              2086 bytes
+  length of filename:                             82 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #63:
+Central directory entry #59:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_factory.py
+  KratosMultiphysics/ShapeOptimizationApplication/utilities/__init__.py
 
-  offset of local header from start of archive:   81712
-                                                  (0000000000013F30h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   788667
+                                                  (00000000000C08BBh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         bf30cd99
-  compressed size:                                577 bytes
-  uncompressed size:                              3473 bytes
-  length of filename:                             79 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #64:
----------------------------
-
-  KratosMultiphysics/ShapeOptimizationApplication/algorithms/__init__.py
-
-  offset of local header from start of archive:   82426
-                                                  (00000000000141FAh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
   32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
+  compressed size:                                2 bytes
   uncompressed size:                              0 bytes
-  length of filename:                             70 characters
-  length of extra field:                          24 bytes
+  length of filename:                             69 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #65:
+Central directory entry #60:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_shape_fraction_optimization.py
+  KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_math.py
 
-  offset of local header from start of archive:   82554
-                                                  (000000000001427Ah) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   788768
+                                                  (00000000000C0920h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         bcc4aad3
-  compressed size:                                5325 bytes
-  uncompressed size:                              29713 bytes
-  length of filename:                             99 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         a16c64ac
+  compressed size:                                3479 bytes
+  uncompressed size:                              14720 bytes
+  length of filename:                             72 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #66:
+Central directory entry #61:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/__init__.py
+  KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_sensitivity_heatmap.py
 
-  offset of local header from start of archive:   88036
-                                                  (00000000000157E4h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   792349
+                                                  (00000000000C171Dh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         56280326
-  compressed size:                                215 bytes
-  uncompressed size:                              811 bytes
-  length of filename:                             59 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #67:
----------------------------
-
-  KratosMultiphysics/ShapeOptimizationApplication/mapping/
-
-  offset of local header from start of archive:   88368
-                                                  (0000000000015930h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             56 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         6b2da233
+  compressed size:                                2150 bytes
+  uncompressed size:                              12054 bytes
+  length of filename:                             87 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
-Central directory entry #68:
+Central directory entry #62:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/mapping/in_plane_vertex_morphing_mapper.py
+  KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_timer.py
 
-  offset of local header from start of archive:   88482
-                                                  (00000000000159A2h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   794616
+                                                  (00000000000C1FF8h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         3aedb27c
-  compressed size:                                1762 bytes
-  uncompressed size:                              6901 bytes
-  length of filename:                             90 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         b9c572fe
+  compressed size:                                379 bytes
+  uncompressed size:                              1854 bytes
+  length of filename:                             73 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #69:
+Central directory entry #63:
 ---------------------------
 
-  KratosMultiphysics/ShapeOptimizationApplication/mapping/sliding_vertex_morphing_mapper.py
+  KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_variable_utilities.py
 
-  offset of local header from start of archive:   90392
-                                                  (0000000000016118h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   795098
+                                                  (00000000000C21DAh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         3a638b83
-  compressed size:                                3949 bytes
-  uncompressed size:                              18699 bytes
-  length of filename:                             89 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #70:
----------------------------
-
-  KratosMultiphysics/ShapeOptimizationApplication/mapping/__init__.py
-
-  offset of local header from start of archive:   94488
-                                                  (0000000000017118h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             67 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         841c7385
+  compressed size:                                609 bytes
+  uncompressed size:                              2301 bytes
+  length of filename:                             86 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #71:
----------------------------
-
-  KratosMultiphysics/.libs/
-
-  offset of local header from start of archive:   94613
-                                                  (0000000000017195h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:00
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:00 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:00 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             25 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #72:
+Central directory entry #64:
 ---------------------------
 
-  KratosMultiphysics/.libs/KratosShapeOptimizationApplication.cpython-39-x86_64-linux-gnu.so
+  KratosShapeOptimizationApplication-9.5.1.dist-info/METADATA
 
-  offset of local header from start of archive:   94696
-                                                  (00000000000171E8h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   795823
+                                                  (00000000000C24AFh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         2737c9ae
-  compressed size:                                687272 bytes
-  uncompressed size:                              2079457 bytes
-  length of filename:                             90 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:44
+  32-bit CRC value (hex):                         7460d97c
+  compressed size:                                1055 bytes
+  uncompressed size:                              2440 bytes
+  length of filename:                             59 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100755 octal):            -rwxr-xr-x
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #73:
----------------------------
-
-  KratosShapeOptimizationApplication-9.5.dist-info/
-
-  offset of local header from start of archive:   782116
-                                                  (00000000000BEF24h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:00
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:00 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:00 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             49 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #74:
+Central directory entry #65:
 ---------------------------
 
-  KratosShapeOptimizationApplication-9.5.dist-info/METADATA
+  KratosShapeOptimizationApplication-9.5.1.dist-info/WHEEL
 
-  offset of local header from start of archive:   782223
-                                                  (00000000000BEF8Fh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   796967
+                                                  (00000000000C2927h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         8114a891
-  compressed size:                                1037 bytes
-  uncompressed size:                              2338 bytes
-  length of filename:                             57 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:44
+  32-bit CRC value (hex):                         86fb6b41
+  compressed size:                                96 bytes
+  uncompressed size:                              100 bytes
+  length of filename:                             56 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #75:
+Central directory entry #66:
 ---------------------------
 
-  KratosShapeOptimizationApplication-9.5.dist-info/WHEEL
+  KratosShapeOptimizationApplication-9.5.1.dist-info/top_level.txt
 
-  offset of local header from start of archive:   783375
-                                                  (00000000000BF40Fh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   797149
+                                                  (00000000000C29DDh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         90d34e0d
-  compressed size:                                116 bytes
-  uncompressed size:                              148 bytes
-  length of filename:                             54 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #76:
----------------------------
-
-  KratosShapeOptimizationApplication-9.5.dist-info/top_level.txt
-
-  offset of local header from start of archive:   783603
-                                                  (00000000000BF4F3h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
+  file last modified on (DOS date/time):          2024 May 27 13:36:44
   32-bit CRC value (hex):                         f32d789f
-  compressed size:                                19 bytes
+  compressed size:                                21 bytes
   uncompressed size:                              19 bytes
-  length of filename:                             62 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #77:
----------------------------
-
-  KratosShapeOptimizationApplication-9.5.dist-info/RECORD
-
-  offset of local header from start of archive:   783742
-                                                  (00000000000BF57Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:00
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:00 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:00 UTC
-  32-bit CRC value (hex):                         0d09293d
-  compressed size:                                3098 bytes
-  uncompressed size:                              9202 bytes
-  length of filename:                             55 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100664 octal):            -rw-rw-r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #78:
----------------------------
-
-  KratosShapeOptimizationApplication.libs/
-
-  offset of local header from start of archive:   786953
-                                                  (00000000000C0209h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:00
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:00 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:00 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             40 characters
-  length of extra field:                          24 bytes
+  length of filename:                             64 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
-Central directory entry #79:
+Central directory entry #67:
 ---------------------------
 
-  KratosShapeOptimizationApplication.libs/libKratosShapeOptimizationCore-2091758f.so
+  KratosShapeOptimizationApplication-9.5.1.dist-info/RECORD
 
-  offset of local header from start of archive:   787051
-                                                  (00000000000C026Bh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   797264
+                                                  (00000000000C2A50h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:01:54
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:01:54 UTC
-  32-bit CRC value (hex):                         3e3b4047
-  compressed size:                                1599559 bytes
-  uncompressed size:                              5876785 bytes
-  length of filename:                             82 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:44
+  32-bit CRC value (hex):                         4fbcde1f
+  compressed size:                                3062 bytes
+  uncompressed size:                              9087 bytes
+  length of filename:                             57 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100755 octal):            -rwxr-xr-x
+  non-MSDOS external file attributes:             81B400 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
```

## zipnote {}

```diff
@@ -1,238 +1,202 @@
-Filename: KratosMultiphysics/
+Filename: KratosMultiphysics/.libs/KratosShapeOptimizationApplication.pyd
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/
+Filename: KratosMultiphysics/.libs/KratosShapeOptimizationCore.dll
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/optimizer_factory.py
-Comment: 
-
-Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/
-Comment: 
-
-Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_penalized_projection.py
-Comment: 
-
-Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_relaxed_gradient_projection.py
-Comment: 
-
-Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_vtk.py
-Comment: 
-
-Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_gid.py
-Comment: 
-
-Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_gradient_projection.py
+Filename: KratosMultiphysics/.libs/KratosShapeOptimizationCore.lib
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_unv.py
-Comment: 
-
-Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_steepest_descent.py
-Comment: 
-
-Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_bead_optimization.py
-Comment: 
-
-Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_shape_fraction_optimization.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/TemplateMainKratosShapeOptimization.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_base.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/sensitivity_heatmap_logger.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/communicator_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/data_logger_factory.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/mapper_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_trust_region.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/model_part_controller_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/__init__.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/optimizer_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_base.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/
+Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_base.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/mesh_based_packaging.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_bead_optimization.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/airfoil_2d_responses.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/packaging_response_base.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_gradient_projection.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/total_volume.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_penalized_projection.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/surface_normal_shape_change.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_relaxed_gradient_projection.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/response_function_factory.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_shape_fraction_optimization.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/face_angle.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_steepest_descent.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/plane_based_packaging.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_trust_region.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/__init__.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/analyzers/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/model_part_controller_factory.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_base.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/custom_ios/
+Filename: KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_empty.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/custom_ios/wrl_reader.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/custom_ios/wrl_io.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_internal.py
 Comment: 
 
 Filename: KratosMultiphysics/ShapeOptimizationApplication/custom_ios/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/
-Comment: 
-
-Filename: KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_basic_updating.py
-Comment: 
-
-Filename: KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_with_solver.py
-Comment: 
-
-Filename: KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_base.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/custom_ios/wrl_io.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/__init__.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/custom_ios/wrl_reader.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/TemplateMainKratosShapeOptimization.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/mapper_factory.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/data_logger_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/utilities/
+Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_base.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_math.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_gid.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_variable_utilities.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_unv.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/utilities/__init__.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_vtk.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_sensitivity_heatmap.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/sensitivity_heatmap_logger.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_timer.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_base.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/communicator_factory.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_bead_optimization.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/analyzers/
+Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_gradient_projection.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_base.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_penalized_projection.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_factory.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_relaxed_gradient_projection.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_empty.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_shape_fraction_optimization.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_internal.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_steepest_descent.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/analyzers/__init__.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_trust_region.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/
+Filename: KratosMultiphysics/ShapeOptimizationApplication/mapping/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_steepest_descent.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/mapping/in_plane_vertex_morphing_mapper.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_gradient_projection.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/mapping/sliding_vertex_morphing_mapper.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_trust_region.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_bead_optimization.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_base.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_relaxed_gradient_projection.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_basic_updating.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_base.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_with_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_penalized_projection.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_factory.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/airfoil_2d_responses.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/__init__.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/face_angle.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_shape_fraction_optimization.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/mesh_based_packaging.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/__init__.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/packaging_response_base.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/mapping/
+Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/plane_based_packaging.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/mapping/in_plane_vertex_morphing_mapper.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/response_function_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/mapping/sliding_vertex_morphing_mapper.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/surface_normal_shape_change.py
 Comment: 
 
-Filename: KratosMultiphysics/ShapeOptimizationApplication/mapping/__init__.py
+Filename: KratosMultiphysics/ShapeOptimizationApplication/response_functions/total_volume.py
 Comment: 
 
-Filename: KratosMultiphysics/.libs/
+Filename: KratosMultiphysics/ShapeOptimizationApplication/utilities/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/.libs/KratosShapeOptimizationApplication.cpython-39-x86_64-linux-gnu.so
+Filename: KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_math.py
 Comment: 
 
-Filename: KratosShapeOptimizationApplication-9.5.dist-info/
+Filename: KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_sensitivity_heatmap.py
 Comment: 
 
-Filename: KratosShapeOptimizationApplication-9.5.dist-info/METADATA
+Filename: KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_timer.py
 Comment: 
 
-Filename: KratosShapeOptimizationApplication-9.5.dist-info/WHEEL
+Filename: KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_variable_utilities.py
 Comment: 
 
-Filename: KratosShapeOptimizationApplication-9.5.dist-info/top_level.txt
+Filename: KratosShapeOptimizationApplication-9.5.1.dist-info/METADATA
 Comment: 
 
-Filename: KratosShapeOptimizationApplication-9.5.dist-info/RECORD
+Filename: KratosShapeOptimizationApplication-9.5.1.dist-info/WHEEL
 Comment: 
 
-Filename: KratosShapeOptimizationApplication.libs/
+Filename: KratosShapeOptimizationApplication-9.5.1.dist-info/top_level.txt
 Comment: 
 
-Filename: KratosShapeOptimizationApplication.libs/libKratosShapeOptimizationCore-2091758f.so
+Filename: KratosShapeOptimizationApplication-9.5.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v1.0 to extract, compression method=store
+Zip archive data, at least v2.0 to extract, compression method=deflate
```

## KratosMultiphysics/ShapeOptimizationApplication/optimizer_factory.py

 * *Ordering differences only*

```diff
@@ -1,235 +1,235 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#
-# ==============================================================================
-
-
-# Kratos Core and Apps
-import KratosMultiphysics as KM
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-
-# additional imports
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
-from KratosMultiphysics.ShapeOptimizationApplication.analyzers.analyzer_empty import EmptyAnalyzer
-from KratosMultiphysics.ShapeOptimizationApplication import model_part_controller_factory
-from KratosMultiphysics.ShapeOptimizationApplication.analyzers import analyzer_factory
-from KratosMultiphysics.ShapeOptimizationApplication import communicator_factory
-from KratosMultiphysics.ShapeOptimizationApplication.algorithms import algorithm_factory
-
-## Purely for backward compatibility, should be removed soon.
-def CreateOptimizer(optimization_settings,model,external_analyzer=EmptyAnalyzer()):
-    return Optimizer(model, optimization_settings, external_analyzer)
-
-def Create( model, optimization_settings, external_analyzer=EmptyAnalyzer()):
-    return Optimizer(model, optimization_settings, external_analyzer)
-
-# ==============================================================================
-class Optimizer:
-    # --------------------------------------------------------------------------
-    def __init__(self, model, optimization_settings, external_analyzer=EmptyAnalyzer()):
-        self._ValidateSettings(optimization_settings)
-        self.optimization_settings = optimization_settings
-
-        self.model_part_controller = model_part_controller_factory.CreateController(optimization_settings["model_settings"], model)
-        self.analyzer = analyzer_factory.CreateAnalyzer(optimization_settings, self.model_part_controller, external_analyzer)
-        self.communicator = communicator_factory.CreateCommunicator(optimization_settings)
-
-        if not optimization_settings["design_variables"]["type"].GetString() == "vertex_morphing":
-            raise NameError("The following type of design variables is not supported by the optimizer: " + variable_type)
-
-        self.__AddVariablesToBeUsedByAllAlgorithms()
-        self.__AddVariablesToBeUsedByDesignVariables()
-
-    # --------------------------------------------------------------------------
-    def __AddVariablesToBeUsedByAllAlgorithms(self):
-        model_part = self.model_part_controller.GetOptimizationModelPart()
-        number_of_objectives = self.optimization_settings["objectives"].size()
-        number_of_constraints = self.optimization_settings["constraints"].size()
-
-        nodal_variable = KM.KratosGlobals.GetVariable("DF1DX")
-        model_part.AddNodalSolutionStepVariable(nodal_variable)
-        nodal_variable = KM.KratosGlobals.GetVariable("DF1DX_MAPPED")
-        model_part.AddNodalSolutionStepVariable(nodal_variable)
-
-        for itr in range(1,number_of_constraints+1):
-            nodal_variable = KM.KratosGlobals.GetVariable(f"DC{(itr)}DX")
-            model_part.AddNodalSolutionStepVariable(nodal_variable)
-            nodal_variable = KM.KratosGlobals.GetVariable(f"DC{(itr)}DX_MAPPED")
-            model_part.AddNodalSolutionStepVariable(nodal_variable)
-
-        model_part.AddNodalSolutionStepVariable(KSO.CONTROL_POINT_UPDATE)
-        model_part.AddNodalSolutionStepVariable(KSO.CONTROL_POINT_CHANGE)
-        model_part.AddNodalSolutionStepVariable(KSO.SHAPE_UPDATE)
-        model_part.AddNodalSolutionStepVariable(KSO.SHAPE_CHANGE)
-        model_part.AddNodalSolutionStepVariable(KSO.MESH_CHANGE)
-        model_part.AddNodalSolutionStepVariable(KM.NORMAL)
-        model_part.AddNodalSolutionStepVariable(KSO.NORMALIZED_SURFACE_NORMAL)
-
-        # variables required for remeshing
-        model_part.AddNodalSolutionStepVariable(KM.DISTANCE)
-        model_part.AddNodalSolutionStepVariable(KM.DISTANCE_GRADIENT)
-
-        # sensitivity heatmap
-        if self.optimization_settings["output"].Has("sensitivity_heatmap") and \
-            self.optimization_settings["output"]["sensitivity_heatmap"].GetBool():
-            self.__AddVariablesToBeUsedBySensitivityHeatmap()
-
-    def __AddVariablesToBeUsedByDesignVariables(self):
-        if self.optimization_settings["design_variables"]["filter"].Has("in_plane_morphing") and \
-            self.optimization_settings["design_variables"]["filter"]["in_plane_morphing"].GetBool():
-                model_part = self.model_part_controller.GetOptimizationModelPart()
-                model_part.AddNodalSolutionStepVariable(KSO.BACKGROUND_COORDINATE)
-                model_part.AddNodalSolutionStepVariable(KSO.BACKGROUND_NORMAL)
-                model_part.AddNodalSolutionStepVariable(KSO.OUT_OF_PLANE_DELTA)
-        if self.optimization_settings["design_variables"]["filter"].Has("sliding_morphing") and \
-            self.optimization_settings["design_variables"]["filter"]["sliding_morphing"].GetBool():
-                model_part = self.model_part_controller.GetOptimizationModelPart()
-                model_part.AddNodalSolutionStepVariable(KSO.BACKGROUND_COORDINATE)
-                model_part.AddNodalSolutionStepVariable(KSO.BACKGROUND_NORMAL)
-                model_part.AddNodalSolutionStepVariable(KSO.OUT_OF_PLANE_DELTA)
-
-        if self.optimization_settings["design_variables"]["filter"]["filter_radius"].IsString() and \
-            self.optimization_settings["design_variables"]["filter"]["filter_radius"].GetString() == "adaptive":
-            # variables required for adaptive
-            model_part = self.model_part_controller.GetOptimizationModelPart()
-            model_part.AddNodalSolutionStepVariable(KSO.VERTEX_MORPHING_RADIUS)
-            model_part.AddNodalSolutionStepVariable(KSO.VERTEX_MORPHING_RADIUS_RAW)
-            model_part.AddNodalSolutionStepVariable(KSO.GAUSSIAN_CURVATURE)
-            model_part.AddNodalSolutionStepVariable(KSO.MAX_NEIGHBOUR_DISTANCE)
-
-    def __AddVariablesToBeUsedBySensitivityHeatmap(self):
-        model_part = self.model_part_controller.GetOptimizationModelPart()
-
-        model_part.AddNodalSolutionStepVariable(KM.NODAL_AREA)
-
-        sensitivity_heatmap_settings = None
-        if self.optimization_settings["output"].Has("sensitivity_heatmap_settings"):
-            sensitivity_heatmap_settings = self.optimization_settings["output"]["sensitivity_heatmap_settings"]
-
-        weigthing = True
-        mapping = True
-        if sensitivity_heatmap_settings:
-            if sensitivity_heatmap_settings.Has("sensitivity_weighting") and \
-                not sensitivity_heatmap_settings["sensitivity_weighting"].GetBool():
-                weigthing = False
-            if sensitivity_heatmap_settings.Has("mapping") and \
-                not sensitivity_heatmap_settings["mapping"].GetBool():
-                mapping = False
-
-        if self.optimization_settings["optimization_algorithm"]["name"].GetString() == "bead_optimization":
-            model_part.AddNodalSolutionStepVariable(KSO.HEATMAP_DF1DALPHA)
-            if weigthing:
-                model_part.AddNodalSolutionStepVariable(KSO.DF1DALPHA_WEIGHTED)
-                if mapping:
-                    model_part.AddNodalSolutionStepVariable(KSO.DF1DALPHA_WEIGHTED_MAPPED)
-        else:
-            model_part.AddNodalSolutionStepVariable(KSO.HEATMAP_DF1DX)
-            if weigthing:
-                model_part.AddNodalSolutionStepVariable(KSO.DF1DX_WEIGHTED)
-                if mapping:
-                    model_part.AddNodalSolutionStepVariable(KSO.DF1DX_WEIGHTED_MAPPED)
-
-            number_of_constraints = self.optimization_settings["constraints"].size()
-            if number_of_constraints != 0:
-                model_part.AddNodalSolutionStepVariable(KSO.HEATMAP_MAX)
-                model_part.AddNodalSolutionStepVariable(KSO.HEATMAP_L2)
-            for itr in range(1,number_of_constraints+1):
-                nodal_variable = KM.KratosGlobals.GetVariable(f"HEATMAP_DC{(itr)}DX")
-                model_part.AddNodalSolutionStepVariable(nodal_variable)
-                if weigthing:
-                    nodal_variable = KM.KratosGlobals.GetVariable(f"DC{(itr)}DX_WEIGHTED")
-                    model_part.AddNodalSolutionStepVariable(nodal_variable)
-                    if mapping:
-                        nodal_variable = KM.KratosGlobals.GetVariable(f"DC{(itr)}DX_WEIGHTED_MAPPED")
-                        model_part.AddNodalSolutionStepVariable(nodal_variable)
-
-    # --------------------------------------------------------------------------
-    def Optimize(self):
-        algorithm_name = self.optimization_settings["optimization_algorithm"]["name"].GetString()
-
-        KM.Logger.Print("")
-        KM.Logger.Print("===============================================================================")
-        KM.Logger.PrintInfo("ShapeOpt", Timer().GetTimeStamp(), ": Starting optimization using the following algorithm: ", algorithm_name)
-        KM.Logger.Print("===============================================================================\n")
-
-        algorithm = algorithm_factory.CreateOptimizationAlgorithm(self.optimization_settings,
-                                                                  self.analyzer,
-                                                                  self.communicator,
-                                                                  self.model_part_controller)
-        algorithm.CheckApplicability()
-        algorithm.InitializeOptimizationLoop()
-        algorithm.RunOptimizationLoop()
-        algorithm.FinalizeOptimizationLoop()
-
-        KM.Logger.Print("")
-        KM.Logger.Print("===============================================================================")
-        KM.Logger.PrintInfo("ShapeOpt", "Finished optimization")
-        KM.Logger.Print("===============================================================================\n")
-
-    # ==============================================================================
-    # ------------------------------------------------------------------------------
-    # ==============================================================================
-    def _ValidateSettings(self, optimization_settings):
-        self._ValidateTopLevelSettings(optimization_settings)
-        self._ValidateObjectiveSettingsRecursively(optimization_settings["objectives"])
-        self._ValidateConstraintSettings(optimization_settings["constraints"])
-
-    # ------------------------------------------------------------------------------
-    def _ValidateTopLevelSettings(self, optimization_settings):
-        default_settings = KM.Parameters("""
-        {
-            "model_settings" : { },
-            "objectives" : [ ],
-            "constraints" : [ ],
-            "design_variables" : { },
-            "optimization_algorithm" : { },
-            "output" : { }
-        }""")
-
-        for key in default_settings.keys():
-            if not optimization_settings.Has(key):
-                raise RuntimeError("Optimizer: Required setting '{}' missing in 'optimization_settings'!".format(key))
-
-        optimization_settings.ValidateAndAssignDefaults(default_settings)
-
-    # ------------------------------------------------------------------------------
-    def _ValidateObjectiveSettingsRecursively(self, objective_settings):
-        default_settings = KM.Parameters("""
-        {
-            "identifier"                          : "NO_IDENTIFIER_SPECIFIED",
-            "type"                                : "minimization",
-            "scaling_factor"                      : 1.0,
-            "analyzer"                            : "external",
-            "response_settings"                   : {},
-            "is_combined"                         : false,
-            "combination_type"                    : "sum",
-            "combined_responses"                  : [],
-            "weight"                              : 1.0,
-            "project_gradient_on_surface_normals" : false
-        }""")
-        for itr in range(objective_settings.size()):
-            objective_settings[itr].ValidateAndAssignDefaults(default_settings)
-
-            if objective_settings[itr]["is_combined"].GetBool():
-                self._ValidateObjectiveSettingsRecursively(objective_settings[itr]["combined_responses"])
-
-    # ------------------------------------------------------------------------------
-    def _ValidateConstraintSettings(self, constraint_settings):
-        default_settings = KM.Parameters("""
-        {
-            "identifier"                          : "NO_IDENTIFIER_SPECIFIED",
-            "type"                                : "<",
-            "scaling_factor"                      : 1.0,
-            "reference"                           : "initial_value",
-            "reference_value"                     : 1.0,
-            "analyzer"                            : "external",
-            "response_settings"                   : {},
-            "project_gradient_on_surface_normals" : false
-        }""")
-        for itr in range(constraint_settings.size()):
-            constraint_settings[itr].ValidateAndAssignDefaults(default_settings)
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#
+# ==============================================================================
+
+
+# Kratos Core and Apps
+import KratosMultiphysics as KM
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+
+# additional imports
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
+from KratosMultiphysics.ShapeOptimizationApplication.analyzers.analyzer_empty import EmptyAnalyzer
+from KratosMultiphysics.ShapeOptimizationApplication import model_part_controller_factory
+from KratosMultiphysics.ShapeOptimizationApplication.analyzers import analyzer_factory
+from KratosMultiphysics.ShapeOptimizationApplication import communicator_factory
+from KratosMultiphysics.ShapeOptimizationApplication.algorithms import algorithm_factory
+
+## Purely for backward compatibility, should be removed soon.
+def CreateOptimizer(optimization_settings,model,external_analyzer=EmptyAnalyzer()):
+    return Optimizer(model, optimization_settings, external_analyzer)
+
+def Create( model, optimization_settings, external_analyzer=EmptyAnalyzer()):
+    return Optimizer(model, optimization_settings, external_analyzer)
+
+# ==============================================================================
+class Optimizer:
+    # --------------------------------------------------------------------------
+    def __init__(self, model, optimization_settings, external_analyzer=EmptyAnalyzer()):
+        self._ValidateSettings(optimization_settings)
+        self.optimization_settings = optimization_settings
+
+        self.model_part_controller = model_part_controller_factory.CreateController(optimization_settings["model_settings"], model)
+        self.analyzer = analyzer_factory.CreateAnalyzer(optimization_settings, self.model_part_controller, external_analyzer)
+        self.communicator = communicator_factory.CreateCommunicator(optimization_settings)
+
+        if not optimization_settings["design_variables"]["type"].GetString() == "vertex_morphing":
+            raise NameError("The following type of design variables is not supported by the optimizer: " + variable_type)
+
+        self.__AddVariablesToBeUsedByAllAlgorithms()
+        self.__AddVariablesToBeUsedByDesignVariables()
+
+    # --------------------------------------------------------------------------
+    def __AddVariablesToBeUsedByAllAlgorithms(self):
+        model_part = self.model_part_controller.GetOptimizationModelPart()
+        number_of_objectives = self.optimization_settings["objectives"].size()
+        number_of_constraints = self.optimization_settings["constraints"].size()
+
+        nodal_variable = KM.KratosGlobals.GetVariable("DF1DX")
+        model_part.AddNodalSolutionStepVariable(nodal_variable)
+        nodal_variable = KM.KratosGlobals.GetVariable("DF1DX_MAPPED")
+        model_part.AddNodalSolutionStepVariable(nodal_variable)
+
+        for itr in range(1,number_of_constraints+1):
+            nodal_variable = KM.KratosGlobals.GetVariable(f"DC{(itr)}DX")
+            model_part.AddNodalSolutionStepVariable(nodal_variable)
+            nodal_variable = KM.KratosGlobals.GetVariable(f"DC{(itr)}DX_MAPPED")
+            model_part.AddNodalSolutionStepVariable(nodal_variable)
+
+        model_part.AddNodalSolutionStepVariable(KSO.CONTROL_POINT_UPDATE)
+        model_part.AddNodalSolutionStepVariable(KSO.CONTROL_POINT_CHANGE)
+        model_part.AddNodalSolutionStepVariable(KSO.SHAPE_UPDATE)
+        model_part.AddNodalSolutionStepVariable(KSO.SHAPE_CHANGE)
+        model_part.AddNodalSolutionStepVariable(KSO.MESH_CHANGE)
+        model_part.AddNodalSolutionStepVariable(KM.NORMAL)
+        model_part.AddNodalSolutionStepVariable(KSO.NORMALIZED_SURFACE_NORMAL)
+
+        # variables required for remeshing
+        model_part.AddNodalSolutionStepVariable(KM.DISTANCE)
+        model_part.AddNodalSolutionStepVariable(KM.DISTANCE_GRADIENT)
+
+        # sensitivity heatmap
+        if self.optimization_settings["output"].Has("sensitivity_heatmap") and \
+            self.optimization_settings["output"]["sensitivity_heatmap"].GetBool():
+            self.__AddVariablesToBeUsedBySensitivityHeatmap()
+
+    def __AddVariablesToBeUsedByDesignVariables(self):
+        if self.optimization_settings["design_variables"]["filter"].Has("in_plane_morphing") and \
+            self.optimization_settings["design_variables"]["filter"]["in_plane_morphing"].GetBool():
+                model_part = self.model_part_controller.GetOptimizationModelPart()
+                model_part.AddNodalSolutionStepVariable(KSO.BACKGROUND_COORDINATE)
+                model_part.AddNodalSolutionStepVariable(KSO.BACKGROUND_NORMAL)
+                model_part.AddNodalSolutionStepVariable(KSO.OUT_OF_PLANE_DELTA)
+        if self.optimization_settings["design_variables"]["filter"].Has("sliding_morphing") and \
+            self.optimization_settings["design_variables"]["filter"]["sliding_morphing"].GetBool():
+                model_part = self.model_part_controller.GetOptimizationModelPart()
+                model_part.AddNodalSolutionStepVariable(KSO.BACKGROUND_COORDINATE)
+                model_part.AddNodalSolutionStepVariable(KSO.BACKGROUND_NORMAL)
+                model_part.AddNodalSolutionStepVariable(KSO.OUT_OF_PLANE_DELTA)
+
+        if self.optimization_settings["design_variables"]["filter"]["filter_radius"].IsString() and \
+            self.optimization_settings["design_variables"]["filter"]["filter_radius"].GetString() == "adaptive":
+            # variables required for adaptive
+            model_part = self.model_part_controller.GetOptimizationModelPart()
+            model_part.AddNodalSolutionStepVariable(KSO.VERTEX_MORPHING_RADIUS)
+            model_part.AddNodalSolutionStepVariable(KSO.VERTEX_MORPHING_RADIUS_RAW)
+            model_part.AddNodalSolutionStepVariable(KSO.GAUSSIAN_CURVATURE)
+            model_part.AddNodalSolutionStepVariable(KSO.MAX_NEIGHBOUR_DISTANCE)
+
+    def __AddVariablesToBeUsedBySensitivityHeatmap(self):
+        model_part = self.model_part_controller.GetOptimizationModelPart()
+
+        model_part.AddNodalSolutionStepVariable(KM.NODAL_AREA)
+
+        sensitivity_heatmap_settings = None
+        if self.optimization_settings["output"].Has("sensitivity_heatmap_settings"):
+            sensitivity_heatmap_settings = self.optimization_settings["output"]["sensitivity_heatmap_settings"]
+
+        weigthing = True
+        mapping = True
+        if sensitivity_heatmap_settings:
+            if sensitivity_heatmap_settings.Has("sensitivity_weighting") and \
+                not sensitivity_heatmap_settings["sensitivity_weighting"].GetBool():
+                weigthing = False
+            if sensitivity_heatmap_settings.Has("mapping") and \
+                not sensitivity_heatmap_settings["mapping"].GetBool():
+                mapping = False
+
+        if self.optimization_settings["optimization_algorithm"]["name"].GetString() == "bead_optimization":
+            model_part.AddNodalSolutionStepVariable(KSO.HEATMAP_DF1DALPHA)
+            if weigthing:
+                model_part.AddNodalSolutionStepVariable(KSO.DF1DALPHA_WEIGHTED)
+                if mapping:
+                    model_part.AddNodalSolutionStepVariable(KSO.DF1DALPHA_WEIGHTED_MAPPED)
+        else:
+            model_part.AddNodalSolutionStepVariable(KSO.HEATMAP_DF1DX)
+            if weigthing:
+                model_part.AddNodalSolutionStepVariable(KSO.DF1DX_WEIGHTED)
+                if mapping:
+                    model_part.AddNodalSolutionStepVariable(KSO.DF1DX_WEIGHTED_MAPPED)
+
+            number_of_constraints = self.optimization_settings["constraints"].size()
+            if number_of_constraints != 0:
+                model_part.AddNodalSolutionStepVariable(KSO.HEATMAP_MAX)
+                model_part.AddNodalSolutionStepVariable(KSO.HEATMAP_L2)
+            for itr in range(1,number_of_constraints+1):
+                nodal_variable = KM.KratosGlobals.GetVariable(f"HEATMAP_DC{(itr)}DX")
+                model_part.AddNodalSolutionStepVariable(nodal_variable)
+                if weigthing:
+                    nodal_variable = KM.KratosGlobals.GetVariable(f"DC{(itr)}DX_WEIGHTED")
+                    model_part.AddNodalSolutionStepVariable(nodal_variable)
+                    if mapping:
+                        nodal_variable = KM.KratosGlobals.GetVariable(f"DC{(itr)}DX_WEIGHTED_MAPPED")
+                        model_part.AddNodalSolutionStepVariable(nodal_variable)
+
+    # --------------------------------------------------------------------------
+    def Optimize(self):
+        algorithm_name = self.optimization_settings["optimization_algorithm"]["name"].GetString()
+
+        KM.Logger.Print("")
+        KM.Logger.Print("===============================================================================")
+        KM.Logger.PrintInfo("ShapeOpt", Timer().GetTimeStamp(), ": Starting optimization using the following algorithm: ", algorithm_name)
+        KM.Logger.Print("===============================================================================\n")
+
+        algorithm = algorithm_factory.CreateOptimizationAlgorithm(self.optimization_settings,
+                                                                  self.analyzer,
+                                                                  self.communicator,
+                                                                  self.model_part_controller)
+        algorithm.CheckApplicability()
+        algorithm.InitializeOptimizationLoop()
+        algorithm.RunOptimizationLoop()
+        algorithm.FinalizeOptimizationLoop()
+
+        KM.Logger.Print("")
+        KM.Logger.Print("===============================================================================")
+        KM.Logger.PrintInfo("ShapeOpt", "Finished optimization")
+        KM.Logger.Print("===============================================================================\n")
+
+    # ==============================================================================
+    # ------------------------------------------------------------------------------
+    # ==============================================================================
+    def _ValidateSettings(self, optimization_settings):
+        self._ValidateTopLevelSettings(optimization_settings)
+        self._ValidateObjectiveSettingsRecursively(optimization_settings["objectives"])
+        self._ValidateConstraintSettings(optimization_settings["constraints"])
+
+    # ------------------------------------------------------------------------------
+    def _ValidateTopLevelSettings(self, optimization_settings):
+        default_settings = KM.Parameters("""
+        {
+            "model_settings" : { },
+            "objectives" : [ ],
+            "constraints" : [ ],
+            "design_variables" : { },
+            "optimization_algorithm" : { },
+            "output" : { }
+        }""")
+
+        for key in default_settings.keys():
+            if not optimization_settings.Has(key):
+                raise RuntimeError("Optimizer: Required setting '{}' missing in 'optimization_settings'!".format(key))
+
+        optimization_settings.ValidateAndAssignDefaults(default_settings)
+
+    # ------------------------------------------------------------------------------
+    def _ValidateObjectiveSettingsRecursively(self, objective_settings):
+        default_settings = KM.Parameters("""
+        {
+            "identifier"                          : "NO_IDENTIFIER_SPECIFIED",
+            "type"                                : "minimization",
+            "scaling_factor"                      : 1.0,
+            "analyzer"                            : "external",
+            "response_settings"                   : {},
+            "is_combined"                         : false,
+            "combination_type"                    : "sum",
+            "combined_responses"                  : [],
+            "weight"                              : 1.0,
+            "project_gradient_on_surface_normals" : false
+        }""")
+        for itr in range(objective_settings.size()):
+            objective_settings[itr].ValidateAndAssignDefaults(default_settings)
+
+            if objective_settings[itr]["is_combined"].GetBool():
+                self._ValidateObjectiveSettingsRecursively(objective_settings[itr]["combined_responses"])
+
+    # ------------------------------------------------------------------------------
+    def _ValidateConstraintSettings(self, constraint_settings):
+        default_settings = KM.Parameters("""
+        {
+            "identifier"                          : "NO_IDENTIFIER_SPECIFIED",
+            "type"                                : "<",
+            "scaling_factor"                      : 1.0,
+            "reference"                           : "initial_value",
+            "reference_value"                     : 1.0,
+            "analyzer"                            : "external",
+            "response_settings"                   : {},
+            "project_gradient_on_surface_normals" : false
+        }""")
+        for itr in range(constraint_settings.size()):
+            constraint_settings[itr].ValidateAndAssignDefaults(default_settings)
```

## KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_penalized_projection.py

 * *Ordering differences only*

```diff
@@ -1,79 +1,79 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#                   Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-# importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Import logger base classes
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_base import ValueLogger
-
-# Import additional libraries
-import csv
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
-
-# ==============================================================================
-class ValueLoggerPenalizedProjection( ValueLogger ):
-    # --------------------------------------------------------------------------
-    def InitializeLogging( self ):
-        with open(self.complete_log_file_name, 'w') as csvfile:
-            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
-            row = []
-            row.append("{:>4s}".format("itr"))
-            row.append("{:>13s}".format("f"))
-            row.append("{:>13s}".format("df_abs[%]"))
-            row.append("{:>13s}".format("df_rel[%]"))
-
-            for itr in range(self.constraints.size()):
-                con_type = self.constraints[itr]["type"].GetString()
-                row.append("{:>13s}".format("c"+str(itr+1)+": "+con_type))
-                row.append("{:>13s}".format("c"+str(itr+1)+"_ref"))
-
-            row.append("{:>13s}".format("c_scaling"))
-            row.append("{:>13s}".format("step_size"))
-            row.append("{:>25s}".format("time_stamp"))
-            historyWriter.writerow(row)
-
-    # --------------------------------------------------------------------------
-    def _WriteCurrentValuesToConsole( self ):
-        objective_id = self.objectives[0]["identifier"].GetString()
-        KM.Logger.Print("")
-        KM.Logger.PrintInfo("ShapeOpt", "Current value of objective = ", "{:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
-
-        KM.Logger.PrintInfo("ShapeOpt", "Absolut change of objective = ","{:> .5E}".format(self.history["abs_change_objective"][self.current_index])," [%]")
-        KM.Logger.PrintInfo("ShapeOpt", "Relative change of objective = ","{:> .5E}".format(self.history["rel_change_objective"][self.current_index])," [%]\n")
-
-        for itr in range(self.constraints.size()):
-            constraint_id = self.constraints[itr]["identifier"].GetString()
-            KM.Logger.PrintInfo("ShapeOpt", "Value of C"+str(itr+1)+" = ", "{:> .5E}".format(self.history["response_value"][constraint_id][self.current_index]))
-
-    # --------------------------------------------------------------------------
-    def _WriteCurrentValuesToFile( self ):
-        with open(self.complete_log_file_name, 'a') as csvfile:
-            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
-            row = []
-            row.append("{:>4d}".format(self.current_index))
-
-            objective_id = self.objectives[0]["identifier"].GetString()
-            row.append(" {:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["abs_change_objective"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["rel_change_objective"][self.current_index]))
-
-            for itr in range(self.constraints.size()):
-                constraint_id = self.constraints[itr]["identifier"].GetString()
-                row.append(" {:> .5E}".format(self.history["response_value"][constraint_id][self.current_index]))
-                row.append(" {:> .5E}".format(self.communicator.getReferenceValue(constraint_id)))
-
-            row.append(" {:> .5E}".format(self.history["correction_scaling"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["step_size"][self.current_index]))
-            row.append("{:>25}".format(Timer().GetTimeStamp()))
-            historyWriter.writerow(row)
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#                   Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+# importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Import logger base classes
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_base import ValueLogger
+
+# Import additional libraries
+import csv
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
+
+# ==============================================================================
+class ValueLoggerPenalizedProjection( ValueLogger ):
+    # --------------------------------------------------------------------------
+    def InitializeLogging( self ):
+        with open(self.complete_log_file_name, 'w') as csvfile:
+            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
+            row = []
+            row.append("{:>4s}".format("itr"))
+            row.append("{:>13s}".format("f"))
+            row.append("{:>13s}".format("df_abs[%]"))
+            row.append("{:>13s}".format("df_rel[%]"))
+
+            for itr in range(self.constraints.size()):
+                con_type = self.constraints[itr]["type"].GetString()
+                row.append("{:>13s}".format("c"+str(itr+1)+": "+con_type))
+                row.append("{:>13s}".format("c"+str(itr+1)+"_ref"))
+
+            row.append("{:>13s}".format("c_scaling"))
+            row.append("{:>13s}".format("step_size"))
+            row.append("{:>25s}".format("time_stamp"))
+            historyWriter.writerow(row)
+
+    # --------------------------------------------------------------------------
+    def _WriteCurrentValuesToConsole( self ):
+        objective_id = self.objectives[0]["identifier"].GetString()
+        KM.Logger.Print("")
+        KM.Logger.PrintInfo("ShapeOpt", "Current value of objective = ", "{:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
+
+        KM.Logger.PrintInfo("ShapeOpt", "Absolut change of objective = ","{:> .5E}".format(self.history["abs_change_objective"][self.current_index])," [%]")
+        KM.Logger.PrintInfo("ShapeOpt", "Relative change of objective = ","{:> .5E}".format(self.history["rel_change_objective"][self.current_index])," [%]\n")
+
+        for itr in range(self.constraints.size()):
+            constraint_id = self.constraints[itr]["identifier"].GetString()
+            KM.Logger.PrintInfo("ShapeOpt", "Value of C"+str(itr+1)+" = ", "{:> .5E}".format(self.history["response_value"][constraint_id][self.current_index]))
+
+    # --------------------------------------------------------------------------
+    def _WriteCurrentValuesToFile( self ):
+        with open(self.complete_log_file_name, 'a') as csvfile:
+            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
+            row = []
+            row.append("{:>4d}".format(self.current_index))
+
+            objective_id = self.objectives[0]["identifier"].GetString()
+            row.append(" {:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["abs_change_objective"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["rel_change_objective"][self.current_index]))
+
+            for itr in range(self.constraints.size()):
+                constraint_id = self.constraints[itr]["identifier"].GetString()
+                row.append(" {:> .5E}".format(self.history["response_value"][constraint_id][self.current_index]))
+                row.append(" {:> .5E}".format(self.communicator.getReferenceValue(constraint_id)))
+
+            row.append(" {:> .5E}".format(self.history["correction_scaling"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["step_size"][self.current_index]))
+            row.append("{:>25}".format(Timer().GetTimeStamp()))
+            historyWriter.writerow(row)
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_relaxed_gradient_projection.py

 * *Ordering differences only*

```diff
@@ -1,108 +1,108 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Ihar Antonau
-#
-# ==============================================================================
-
-# importing the Kratos Library
-import KratosMultiphysics as Kratos
-
-# Import logger base classes
-from .value_logger_base import ValueLogger
-
-# Import additional libraries
-import csv
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
-
-# ==============================================================================
-class ValueLoggerRelaxedGradientProjection( ValueLogger ):
-    # --------------------------------------------------------------------------
-    def InitializeLogging( self ):
-        with open(self.complete_log_file_name, 'w') as csvfile:
-            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
-            row = []
-            row.append("{:>4s}".format("itr"))
-            row.append("{:>13s}".format("f"))
-            row.append("{:>13s}".format("df_abs[%]"))
-            row.append("{:>13s}".format("df_rel[%]"))
-
-            for itr in range(self.constraints.size()):
-                con_type = self.constraints[itr]["type"].GetString()
-                row.append("{:>13s}".format("c"+str(itr+1)+": "+con_type))
-                row.append("{:>13s}".format("c"+str(itr+1)+"_ref"))
-
-            row.append("{:>13s}".format("step_size"))
-            row.append("{:>13s}".format("inf_norm_p"))
-            row.append("{:>13s}".format("inf_norm_c"))
-            row.append("{:>13s}".format("projection_norm"))
-
-            for itr in range(self.constraints.size()):
-                row.append("{:>13s}".format("c"+str(itr+1)+"_buffer_value"))
-                row.append("{:>13s}".format("c"+str(itr+1)+"_buffer_size"))
-                row.append("{:>13s}".format("c"+str(itr+1)+"_buffer_size_factor"))
-                row.append("{:>13s}".format("c"+str(itr+1)+"_central_buffer_value"))
-                row.append("{:>13s}".format("c"+str(itr+1)+"_lower_buffer_value"))
-                row.append("{:>13s}".format("c"+str(itr+1)+"_upper_buffer_value"))
-
-            row.append("{:>25s}".format("time_stamp"))
-            historyWriter.writerow(row)
-
-    # --------------------------------------------------------------------------
-    def _WriteCurrentValuesToConsole( self ):
-        objective_id = self.objectives[0]["identifier"].GetString()
-        Kratos.Logger.Print("")
-        Kratos.Logger.PrintInfo("ShapeOpt", "Current value of objective = ", "{:> .5E}".format(self.history["response_value"]
-                                                                                               [objective_id][self.current_index]))
-
-        Kratos.Logger.PrintInfo("ShapeOpt", "Absolute change of objective = ","{:> .5E}".format(self.history["abs_change_objective"][self.current_index]),
-                                                                                                " [%]")
-        Kratos.Logger.PrintInfo("ShapeOpt", "Relative change of objective = ","{:> .5E}".format(self.history["rel_change_objective"][self.current_index]),
-                                                                                                " [%]\n")
-
-        for itr in range(self.constraints.size()):
-            constraint_id = self.constraints[itr]["identifier"].GetString()
-            Kratos.Logger.PrintInfo("ShapeOpt", f"Value of C{str(itr+1)} = ","{:> .5E}".format(
-                                    self.history["response_value"][constraint_id][self.current_index]))
-
-    # --------------------------------------------------------------------------
-    def _WriteCurrentValuesToFile( self ):
-        with open(self.complete_log_file_name, 'a') as csvfile:
-            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
-            row = []
-            row.append("{:>4d}".format(self.current_index))
-
-            objective_id = self.objectives[0]["identifier"].GetString()
-            row.append(" {:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["abs_change_objective"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["rel_change_objective"][self.current_index]))
-
-            for itr in range(self.constraints.size()):
-                constraint_id = self.constraints[itr]["identifier"].GetString()
-                row.append(" {:> .5E}".format(self.history["response_value"][constraint_id][self.current_index]))
-                row.append(" {:> .5E}".format(self.communicator.getReferenceValue(constraint_id)))
-
-            row.append(" {:> .5E}".format(self.history["step_size"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["inf_norm_p"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["inf_norm_c"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["projection_norm"][self.current_index]))
-
-            for itr in range(self.constraints.size()):
-                constraint_id = self.constraints[itr]["identifier"].GetString()
-                row.append(" {:> .5E}".format(self.history["c"+str(itr+1)+"_buffer_value"][self.current_index]))
-                row.append(" {:> .5E}".format(self.history["c"+str(itr+1)+"_buffer_size"][self.current_index]))
-                row.append(" {:> .5E}".format(self.history["c"+str(itr+1)+"_buffer_size_factor"][self.current_index]))
-                row.append(" {:> .5E}".format(self.history["c"+str(itr+1)+"_central_buffer_value"][self.current_index] +
-                                              self.communicator.getReferenceValue(constraint_id)))
-                row.append(" {:> .5E}".format(self.history["c"+str(itr+1)+"_lower_buffer_value"][self.current_index]
-                                              + self.communicator.getReferenceValue(constraint_id)))
-                row.append(" {:> .5E}".format(self.history["c"+str(itr+1)+"_upper_buffer_value"][self.current_index]
-                                              + self.communicator.getReferenceValue(constraint_id)))
-
-            row.append("{:>25}".format(Timer().GetTimeStamp()))
-            historyWriter.writerow(row)
-
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Ihar Antonau
+#
+# ==============================================================================
+
+# importing the Kratos Library
+import KratosMultiphysics as Kratos
+
+# Import logger base classes
+from .value_logger_base import ValueLogger
+
+# Import additional libraries
+import csv
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
+
+# ==============================================================================
+class ValueLoggerRelaxedGradientProjection( ValueLogger ):
+    # --------------------------------------------------------------------------
+    def InitializeLogging( self ):
+        with open(self.complete_log_file_name, 'w') as csvfile:
+            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
+            row = []
+            row.append("{:>4s}".format("itr"))
+            row.append("{:>13s}".format("f"))
+            row.append("{:>13s}".format("df_abs[%]"))
+            row.append("{:>13s}".format("df_rel[%]"))
+
+            for itr in range(self.constraints.size()):
+                con_type = self.constraints[itr]["type"].GetString()
+                row.append("{:>13s}".format("c"+str(itr+1)+": "+con_type))
+                row.append("{:>13s}".format("c"+str(itr+1)+"_ref"))
+
+            row.append("{:>13s}".format("step_size"))
+            row.append("{:>13s}".format("inf_norm_p"))
+            row.append("{:>13s}".format("inf_norm_c"))
+            row.append("{:>13s}".format("projection_norm"))
+
+            for itr in range(self.constraints.size()):
+                row.append("{:>13s}".format("c"+str(itr+1)+"_buffer_value"))
+                row.append("{:>13s}".format("c"+str(itr+1)+"_buffer_size"))
+                row.append("{:>13s}".format("c"+str(itr+1)+"_buffer_size_factor"))
+                row.append("{:>13s}".format("c"+str(itr+1)+"_central_buffer_value"))
+                row.append("{:>13s}".format("c"+str(itr+1)+"_lower_buffer_value"))
+                row.append("{:>13s}".format("c"+str(itr+1)+"_upper_buffer_value"))
+
+            row.append("{:>25s}".format("time_stamp"))
+            historyWriter.writerow(row)
+
+    # --------------------------------------------------------------------------
+    def _WriteCurrentValuesToConsole( self ):
+        objective_id = self.objectives[0]["identifier"].GetString()
+        Kratos.Logger.Print("")
+        Kratos.Logger.PrintInfo("ShapeOpt", "Current value of objective = ", "{:> .5E}".format(self.history["response_value"]
+                                                                                               [objective_id][self.current_index]))
+
+        Kratos.Logger.PrintInfo("ShapeOpt", "Absolute change of objective = ","{:> .5E}".format(self.history["abs_change_objective"][self.current_index]),
+                                                                                                " [%]")
+        Kratos.Logger.PrintInfo("ShapeOpt", "Relative change of objective = ","{:> .5E}".format(self.history["rel_change_objective"][self.current_index]),
+                                                                                                " [%]\n")
+
+        for itr in range(self.constraints.size()):
+            constraint_id = self.constraints[itr]["identifier"].GetString()
+            Kratos.Logger.PrintInfo("ShapeOpt", f"Value of C{str(itr+1)} = ","{:> .5E}".format(
+                                    self.history["response_value"][constraint_id][self.current_index]))
+
+    # --------------------------------------------------------------------------
+    def _WriteCurrentValuesToFile( self ):
+        with open(self.complete_log_file_name, 'a') as csvfile:
+            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
+            row = []
+            row.append("{:>4d}".format(self.current_index))
+
+            objective_id = self.objectives[0]["identifier"].GetString()
+            row.append(" {:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["abs_change_objective"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["rel_change_objective"][self.current_index]))
+
+            for itr in range(self.constraints.size()):
+                constraint_id = self.constraints[itr]["identifier"].GetString()
+                row.append(" {:> .5E}".format(self.history["response_value"][constraint_id][self.current_index]))
+                row.append(" {:> .5E}".format(self.communicator.getReferenceValue(constraint_id)))
+
+            row.append(" {:> .5E}".format(self.history["step_size"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["inf_norm_p"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["inf_norm_c"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["projection_norm"][self.current_index]))
+
+            for itr in range(self.constraints.size()):
+                constraint_id = self.constraints[itr]["identifier"].GetString()
+                row.append(" {:> .5E}".format(self.history["c"+str(itr+1)+"_buffer_value"][self.current_index]))
+                row.append(" {:> .5E}".format(self.history["c"+str(itr+1)+"_buffer_size"][self.current_index]))
+                row.append(" {:> .5E}".format(self.history["c"+str(itr+1)+"_buffer_size_factor"][self.current_index]))
+                row.append(" {:> .5E}".format(self.history["c"+str(itr+1)+"_central_buffer_value"][self.current_index] +
+                                              self.communicator.getReferenceValue(constraint_id)))
+                row.append(" {:> .5E}".format(self.history["c"+str(itr+1)+"_lower_buffer_value"][self.current_index]
+                                              + self.communicator.getReferenceValue(constraint_id)))
+                row.append(" {:> .5E}".format(self.history["c"+str(itr+1)+"_upper_buffer_value"][self.current_index]
+                                              + self.communicator.getReferenceValue(constraint_id)))
+
+            row.append("{:>25}".format(Timer().GetTimeStamp()))
+            historyWriter.writerow(row)
+
 # ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_vtk.py

 * *Ordering differences only*

```diff
@@ -1,96 +1,96 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#                   Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-
-# Kratos Core and Apps
-import KratosMultiphysics as KM
-
-# Additional imports
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.design_logger_base import DesignLogger
-from KratosMultiphysics.vtk_output_process import VtkOutputProcess
-
-# ==============================================================================
-class DesignLoggerVTK( DesignLogger ):
-
-    # --------------------------------------------------------------------------
-    def __init__( self, model_part_controller, optimization_settings ):
-        self.output_settings = optimization_settings["output"]
-        minimal_vtk_settings = KM.Parameters("""
-        {
-            "name"       : "vtk",
-            "vtk_parameters" : {
-                "model_part_name"        : "PLEASE_SPECIFY_MODEL_PART_NAME",
-                "write_ids"              : false,
-                "file_format"            : "binary",
-                "output_sub_model_parts" : false,
-                "output_path"            : "Optimization_Results"
-            }
-        }""")
-
-        output_format = self.output_settings["output_format"]
-        if not output_format.Has("vtk_parameters"):
-            output_format.AddValue("vtk_parameters", minimal_vtk_settings["vtk_parameters"])
-        else:
-            if output_format["vtk_parameters"].Has("model_part_name"):
-                KM.Logger.PrintWarning("ShapeOpt::DesignLoggerVTK", "vtk output parameter `model_part_name` will be overwritten!")
-            if output_format["vtk_parameters"].Has("output_path"):
-                KM.Logger.PrintWarning("ShapeOpt::DesignLoggerVTK", "vtk output parameter `output_path` will be overwritten!")
-
-        output_format["vtk_parameters"].ValidateAndAssignDefaults(minimal_vtk_settings["vtk_parameters"])
-
-        self.model = model_part_controller.GetModel()
-        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
-        self.design_surface = model_part_controller.GetDesignSurface()
-
-        self.vtk_io = self.__CreateVTKIO()
-
-    # --------------------------------------------------------------------------
-    def __CreateVTKIO( self ):
-
-        vtk_parameters = self.output_settings["output_format"]["vtk_parameters"]
-        output_mode = self.output_settings["design_output_mode"].GetString()
-
-        nodal_results = self.output_settings["nodal_results"]
-        vtk_parameters.AddValue("nodal_solution_step_data_variables", nodal_results)
-
-        if output_mode == "write_design_surface":
-            vtk_parameters["model_part_name"].SetString(self.design_surface.FullName())
-        elif output_mode == "write_optimization_model_part":
-            vtk_parameters["model_part_name"].SetString(self.optimization_model_part.FullName())
-        else:
-            raise NameError("The following design output mode is not defined within a VTK output (name may be misspelled): " + output_mode)
-
-        vtk_parameters["output_path"].SetString(self.output_settings["output_directory"].GetString())
-
-        return VtkOutputProcess(self.model, vtk_parameters)
-
-    # --------------------------------------------------------------------------
-    def InitializeLogging( self ):
-        self.vtk_io.ExecuteInitialize()
-        self.vtk_io.ExecuteBeforeSolutionLoop()
-
-    # --------------------------------------------------------------------------
-    def LogCurrentDesign( self, optimizationIteration ):
-        OriginalTime = self.optimization_model_part.ProcessInfo[KM.TIME]
-        self.optimization_model_part.ProcessInfo[KM.TIME] = optimizationIteration
-
-        self.vtk_io.ExecuteInitializeSolutionStep()
-        if(self.vtk_io.IsOutputStep()):
-            self.vtk_io.PrintOutput()
-        self.vtk_io.ExecuteFinalizeSolutionStep()
-
-        self.optimization_model_part.ProcessInfo[KM.TIME] = OriginalTime
-
-    # --------------------------------------------------------------------------
-    def FinalizeLogging( self ):
-        self.vtk_io.ExecuteFinalize()
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#                   Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+
+# Kratos Core and Apps
+import KratosMultiphysics as KM
+
+# Additional imports
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.design_logger_base import DesignLogger
+from KratosMultiphysics.vtk_output_process import VtkOutputProcess
+
+# ==============================================================================
+class DesignLoggerVTK( DesignLogger ):
+
+    # --------------------------------------------------------------------------
+    def __init__( self, model_part_controller, optimization_settings ):
+        self.output_settings = optimization_settings["output"]
+        minimal_vtk_settings = KM.Parameters("""
+        {
+            "name"       : "vtk",
+            "vtk_parameters" : {
+                "model_part_name"        : "PLEASE_SPECIFY_MODEL_PART_NAME",
+                "write_ids"              : false,
+                "file_format"            : "binary",
+                "output_sub_model_parts" : false,
+                "output_path"            : "Optimization_Results"
+            }
+        }""")
+
+        output_format = self.output_settings["output_format"]
+        if not output_format.Has("vtk_parameters"):
+            output_format.AddValue("vtk_parameters", minimal_vtk_settings["vtk_parameters"])
+        else:
+            if output_format["vtk_parameters"].Has("model_part_name"):
+                KM.Logger.PrintWarning("ShapeOpt::DesignLoggerVTK", "vtk output parameter `model_part_name` will be overwritten!")
+            if output_format["vtk_parameters"].Has("output_path"):
+                KM.Logger.PrintWarning("ShapeOpt::DesignLoggerVTK", "vtk output parameter `output_path` will be overwritten!")
+
+        output_format["vtk_parameters"].ValidateAndAssignDefaults(minimal_vtk_settings["vtk_parameters"])
+
+        self.model = model_part_controller.GetModel()
+        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
+        self.design_surface = model_part_controller.GetDesignSurface()
+
+        self.vtk_io = self.__CreateVTKIO()
+
+    # --------------------------------------------------------------------------
+    def __CreateVTKIO( self ):
+
+        vtk_parameters = self.output_settings["output_format"]["vtk_parameters"]
+        output_mode = self.output_settings["design_output_mode"].GetString()
+
+        nodal_results = self.output_settings["nodal_results"]
+        vtk_parameters.AddValue("nodal_solution_step_data_variables", nodal_results)
+
+        if output_mode == "write_design_surface":
+            vtk_parameters["model_part_name"].SetString(self.design_surface.FullName())
+        elif output_mode == "write_optimization_model_part":
+            vtk_parameters["model_part_name"].SetString(self.optimization_model_part.FullName())
+        else:
+            raise NameError("The following design output mode is not defined within a VTK output (name may be misspelled): " + output_mode)
+
+        vtk_parameters["output_path"].SetString(self.output_settings["output_directory"].GetString())
+
+        return VtkOutputProcess(self.model, vtk_parameters)
+
+    # --------------------------------------------------------------------------
+    def InitializeLogging( self ):
+        self.vtk_io.ExecuteInitialize()
+        self.vtk_io.ExecuteBeforeSolutionLoop()
+
+    # --------------------------------------------------------------------------
+    def LogCurrentDesign( self, optimizationIteration ):
+        OriginalTime = self.optimization_model_part.ProcessInfo[KM.TIME]
+        self.optimization_model_part.ProcessInfo[KM.TIME] = optimizationIteration
+
+        self.vtk_io.ExecuteInitializeSolutionStep()
+        if(self.vtk_io.IsOutputStep()):
+            self.vtk_io.PrintOutput()
+        self.vtk_io.ExecuteFinalizeSolutionStep()
+
+        self.optimization_model_part.ProcessInfo[KM.TIME] = OriginalTime
+
+    # --------------------------------------------------------------------------
+    def FinalizeLogging( self ):
+        self.vtk_io.ExecuteFinalize()
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_gid.py

 * *Ordering differences only*

```diff
@@ -1,112 +1,112 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#                   Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-
-# Kratos Core and Apps
-import KratosMultiphysics as KM
-
-# For GID output
-from KratosMultiphysics.gid_output_process import GiDOutputProcess
-
-# Import logger base classes
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.design_logger_base import DesignLogger
-
-# ==============================================================================
-class DesignLoggerGID( DesignLogger ):
-
-    # --------------------------------------------------------------------------
-    def __init__( self, model_part_controller, optimization_settings ):
-        self.output_settings = optimization_settings["output"]
-        minimal_gid_parameters = KM.Parameters("""
-        {
-            "name"           : "gid",
-            "gid_parameters" : { }
-        }""")
-
-        self.output_settings["output_format"].ValidateAndAssignDefaults(minimal_gid_parameters)
-        self.output_settings["output_format"]["gid_parameters"].RecursivelyValidateAndAssignDefaults(GiDOutputProcess.defaults)
-
-        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
-        self.design_surface = model_part_controller.GetDesignSurface()
-
-        self.write_design_surface = False
-        self.write_optimization_model_part = False
-        self.design_history_filename = None
-
-        self.__DetermineOutputMode()
-        self.__ModifySettingsToMatchDefaultGiDOutputProcess()
-        self.__CreateGiDIO()
-
-    # --------------------------------------------------------------------------
-    def __DetermineOutputMode( self ):
-        output_mode = self.output_settings["design_output_mode"].GetString()
-
-        if output_mode == "write_design_surface":
-            self.write_design_surface = True
-            self.design_history_filename = self.design_surface.Name
-        elif output_mode == "write_optimization_model_part":
-            if self.optimization_model_part.NumberOfElements() == 0:
-                raise NameError("Output of optimization model part in Gid-format requires definition of elements. No elements are given in current mdpa! You may change the design output mode.")
-            self.write_optimization_model_part = True
-            self.design_history_filename = self.optimization_model_part.Name
-        else:
-            raise NameError("The following design output mode is not defined within a GiD output (name may be misspelled): " + output_mode)
-
-    # --------------------------------------------------------------------------
-    def __ModifySettingsToMatchDefaultGiDOutputProcess( self ):
-        gid_parameters = self.output_settings["output_format"]["gid_parameters"]
-
-        # Add nodal results
-        self.output_settings["output_format"]["gid_parameters"]["result_file_configuration"]["nodal_results"] = self.output_settings["nodal_results"]
-
-        # Set condition flag
-        if not gid_parameters["result_file_configuration"]["gidpost_flags"].Has("WriteConditionsFlag"):
-            gid_parameters["result_file_configuration"]["gidpost_flags"].AddEmptyValue("WriteConditionsFlag")
-
-        if self.write_design_surface:
-            gid_parameters["result_file_configuration"]["gidpost_flags"]["WriteConditionsFlag"].SetString("WriteConditions")
-        elif self.write_optimization_model_part:
-            gid_parameters["result_file_configuration"]["gidpost_flags"]["WriteConditionsFlag"].SetString("WriteElementsOnly")
-
-    # --------------------------------------------------------------------------
-    def __CreateGiDIO( self ):
-
-        gid_config = self.output_settings["output_format"]["gid_parameters"]
-        results_directory = self.output_settings["output_directory"].GetString()
-        design_history_file_path =  results_directory+"/"+self.design_history_filename
-
-        if self.write_design_surface:
-            self.gid_io = GiDOutputProcess(self.design_surface, design_history_file_path, gid_config)
-        elif self.write_optimization_model_part:
-            self.gid_io = GiDOutputProcess(self.optimization_model_part, design_history_file_path, gid_config)
-
-    # --------------------------------------------------------------------------
-    def InitializeLogging( self ):
-        self.gid_io.ExecuteInitialize()
-        self.gid_io.ExecuteBeforeSolutionLoop()
-
-    # --------------------------------------------------------------------------
-    def LogCurrentDesign( self, optimizationIteration ):
-        OriginalTime = self.optimization_model_part.ProcessInfo[KM.TIME]
-        self.optimization_model_part.ProcessInfo[KM.TIME] = optimizationIteration
-
-        self.gid_io.ExecuteInitializeSolutionStep()
-        if(self.gid_io.IsOutputStep()):
-            self.gid_io.PrintOutput()
-        self.gid_io.ExecuteFinalizeSolutionStep()
-
-        self.optimization_model_part.ProcessInfo[KM.TIME] = OriginalTime
-
-    # --------------------------------------------------------------------------
-    def FinalizeLogging( self ):
-        self.gid_io.ExecuteFinalize()
-
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#                   Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+
+# Kratos Core and Apps
+import KratosMultiphysics as KM
+
+# For GID output
+from KratosMultiphysics.gid_output_process import GiDOutputProcess
+
+# Import logger base classes
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.design_logger_base import DesignLogger
+
+# ==============================================================================
+class DesignLoggerGID( DesignLogger ):
+
+    # --------------------------------------------------------------------------
+    def __init__( self, model_part_controller, optimization_settings ):
+        self.output_settings = optimization_settings["output"]
+        minimal_gid_parameters = KM.Parameters("""
+        {
+            "name"           : "gid",
+            "gid_parameters" : { }
+        }""")
+
+        self.output_settings["output_format"].ValidateAndAssignDefaults(minimal_gid_parameters)
+        self.output_settings["output_format"]["gid_parameters"].RecursivelyValidateAndAssignDefaults(GiDOutputProcess.defaults)
+
+        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
+        self.design_surface = model_part_controller.GetDesignSurface()
+
+        self.write_design_surface = False
+        self.write_optimization_model_part = False
+        self.design_history_filename = None
+
+        self.__DetermineOutputMode()
+        self.__ModifySettingsToMatchDefaultGiDOutputProcess()
+        self.__CreateGiDIO()
+
+    # --------------------------------------------------------------------------
+    def __DetermineOutputMode( self ):
+        output_mode = self.output_settings["design_output_mode"].GetString()
+
+        if output_mode == "write_design_surface":
+            self.write_design_surface = True
+            self.design_history_filename = self.design_surface.Name
+        elif output_mode == "write_optimization_model_part":
+            if self.optimization_model_part.NumberOfElements() == 0:
+                raise NameError("Output of optimization model part in Gid-format requires definition of elements. No elements are given in current mdpa! You may change the design output mode.")
+            self.write_optimization_model_part = True
+            self.design_history_filename = self.optimization_model_part.Name
+        else:
+            raise NameError("The following design output mode is not defined within a GiD output (name may be misspelled): " + output_mode)
+
+    # --------------------------------------------------------------------------
+    def __ModifySettingsToMatchDefaultGiDOutputProcess( self ):
+        gid_parameters = self.output_settings["output_format"]["gid_parameters"]
+
+        # Add nodal results
+        self.output_settings["output_format"]["gid_parameters"]["result_file_configuration"]["nodal_results"] = self.output_settings["nodal_results"]
+
+        # Set condition flag
+        if not gid_parameters["result_file_configuration"]["gidpost_flags"].Has("WriteConditionsFlag"):
+            gid_parameters["result_file_configuration"]["gidpost_flags"].AddEmptyValue("WriteConditionsFlag")
+
+        if self.write_design_surface:
+            gid_parameters["result_file_configuration"]["gidpost_flags"]["WriteConditionsFlag"].SetString("WriteConditions")
+        elif self.write_optimization_model_part:
+            gid_parameters["result_file_configuration"]["gidpost_flags"]["WriteConditionsFlag"].SetString("WriteElementsOnly")
+
+    # --------------------------------------------------------------------------
+    def __CreateGiDIO( self ):
+
+        gid_config = self.output_settings["output_format"]["gid_parameters"]
+        results_directory = self.output_settings["output_directory"].GetString()
+        design_history_file_path =  results_directory+"/"+self.design_history_filename
+
+        if self.write_design_surface:
+            self.gid_io = GiDOutputProcess(self.design_surface, design_history_file_path, gid_config)
+        elif self.write_optimization_model_part:
+            self.gid_io = GiDOutputProcess(self.optimization_model_part, design_history_file_path, gid_config)
+
+    # --------------------------------------------------------------------------
+    def InitializeLogging( self ):
+        self.gid_io.ExecuteInitialize()
+        self.gid_io.ExecuteBeforeSolutionLoop()
+
+    # --------------------------------------------------------------------------
+    def LogCurrentDesign( self, optimizationIteration ):
+        OriginalTime = self.optimization_model_part.ProcessInfo[KM.TIME]
+        self.optimization_model_part.ProcessInfo[KM.TIME] = optimizationIteration
+
+        self.gid_io.ExecuteInitializeSolutionStep()
+        if(self.gid_io.IsOutputStep()):
+            self.gid_io.PrintOutput()
+        self.gid_io.ExecuteFinalizeSolutionStep()
+
+        self.optimization_model_part.ProcessInfo[KM.TIME] = OriginalTime
+
+    # --------------------------------------------------------------------------
+    def FinalizeLogging( self ):
+        self.gid_io.ExecuteFinalize()
+
 # ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_gradient_projection.py

 * *Ordering differences only*

```diff
@@ -1,80 +1,80 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-# importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Import logger base classes
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_base import ValueLogger
-
-# Import additional libraries
-import csv
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
-
-# ==============================================================================
-class ValueLoggerGradientProjection( ValueLogger ):
-    # --------------------------------------------------------------------------
-    def InitializeLogging( self ):
-        with open(self.complete_log_file_name, 'w') as csvfile:
-            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
-            row = []
-            row.append("{:>4s}".format("itr"))
-            row.append("{:>13s}".format("f"))
-            row.append("{:>13s}".format("df_abs[%]"))
-            row.append("{:>13s}".format("df_rel[%]"))
-
-            for itr in range(self.constraints.size()):
-                con_type = self.constraints[itr]["type"].GetString()
-                row.append("{:>13s}".format("c"+str(itr+1)+": "+con_type))
-                row.append("{:>13s}".format("c"+str(itr+1)+"_ref"))
-
-            row.append("{:>13s}".format("step_size"))
-            row.append("{:>13s}".format("inf_norm_s"))
-            row.append("{:>13s}".format("inf_norm_c"))
-            row.append("{:>25s}".format("time_stamp"))
-            historyWriter.writerow(row)
-
-    # --------------------------------------------------------------------------
-    def _WriteCurrentValuesToConsole( self ):
-        objective_id = self.objectives[0]["identifier"].GetString()
-        KM.Logger.Print("")
-        KM.Logger.PrintInfo("ShapeOpt", "Current value of objective = ", "{:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
-
-        KM.Logger.PrintInfo("ShapeOpt", "Absolute change of objective = ","{:> .5E}".format(self.history["abs_change_objective"][self.current_index])," [%]")
-        KM.Logger.PrintInfo("ShapeOpt", "Relative change of objective = ","{:> .5E}".format(self.history["rel_change_objective"][self.current_index])," [%]\n")
-
-        for itr in range(self.constraints.size()):
-            constraint_id = self.constraints[itr]["identifier"].GetString()
-            KM.Logger.PrintInfo("ShapeOpt", "Value of C"+str(itr+1)+" = ", "{:> .5E}".format(self.history["response_value"][constraint_id][self.current_index]))
-
-    # --------------------------------------------------------------------------
-    def _WriteCurrentValuesToFile( self ):
-        with open(self.complete_log_file_name, 'a') as csvfile:
-            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
-            row = []
-            row.append("{:>4d}".format(self.current_index))
-
-            objective_id = self.objectives[0]["identifier"].GetString()
-            row.append(" {:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["abs_change_objective"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["rel_change_objective"][self.current_index]))
-
-            for itr in range(self.constraints.size()):
-                constraint_id = self.constraints[itr]["identifier"].GetString()
-                row.append(" {:> .5E}".format(self.history["response_value"][constraint_id][self.current_index]))
-                row.append(" {:> .5E}".format(self.communicator.getReferenceValue(constraint_id)))
-
-            row.append(" {:> .5E}".format(self.history["step_size"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["inf_norm_s"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["inf_norm_c"][self.current_index]))
-            row.append("{:>25}".format(Timer().GetTimeStamp()))
-            historyWriter.writerow(row)
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+# importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Import logger base classes
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_base import ValueLogger
+
+# Import additional libraries
+import csv
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
+
+# ==============================================================================
+class ValueLoggerGradientProjection( ValueLogger ):
+    # --------------------------------------------------------------------------
+    def InitializeLogging( self ):
+        with open(self.complete_log_file_name, 'w') as csvfile:
+            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
+            row = []
+            row.append("{:>4s}".format("itr"))
+            row.append("{:>13s}".format("f"))
+            row.append("{:>13s}".format("df_abs[%]"))
+            row.append("{:>13s}".format("df_rel[%]"))
+
+            for itr in range(self.constraints.size()):
+                con_type = self.constraints[itr]["type"].GetString()
+                row.append("{:>13s}".format("c"+str(itr+1)+": "+con_type))
+                row.append("{:>13s}".format("c"+str(itr+1)+"_ref"))
+
+            row.append("{:>13s}".format("step_size"))
+            row.append("{:>13s}".format("inf_norm_s"))
+            row.append("{:>13s}".format("inf_norm_c"))
+            row.append("{:>25s}".format("time_stamp"))
+            historyWriter.writerow(row)
+
+    # --------------------------------------------------------------------------
+    def _WriteCurrentValuesToConsole( self ):
+        objective_id = self.objectives[0]["identifier"].GetString()
+        KM.Logger.Print("")
+        KM.Logger.PrintInfo("ShapeOpt", "Current value of objective = ", "{:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
+
+        KM.Logger.PrintInfo("ShapeOpt", "Absolute change of objective = ","{:> .5E}".format(self.history["abs_change_objective"][self.current_index])," [%]")
+        KM.Logger.PrintInfo("ShapeOpt", "Relative change of objective = ","{:> .5E}".format(self.history["rel_change_objective"][self.current_index])," [%]\n")
+
+        for itr in range(self.constraints.size()):
+            constraint_id = self.constraints[itr]["identifier"].GetString()
+            KM.Logger.PrintInfo("ShapeOpt", "Value of C"+str(itr+1)+" = ", "{:> .5E}".format(self.history["response_value"][constraint_id][self.current_index]))
+
+    # --------------------------------------------------------------------------
+    def _WriteCurrentValuesToFile( self ):
+        with open(self.complete_log_file_name, 'a') as csvfile:
+            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
+            row = []
+            row.append("{:>4d}".format(self.current_index))
+
+            objective_id = self.objectives[0]["identifier"].GetString()
+            row.append(" {:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["abs_change_objective"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["rel_change_objective"][self.current_index]))
+
+            for itr in range(self.constraints.size()):
+                constraint_id = self.constraints[itr]["identifier"].GetString()
+                row.append(" {:> .5E}".format(self.history["response_value"][constraint_id][self.current_index]))
+                row.append(" {:> .5E}".format(self.communicator.getReferenceValue(constraint_id)))
+
+            row.append(" {:> .5E}".format(self.history["step_size"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["inf_norm_s"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["inf_norm_c"][self.current_index]))
+            row.append("{:>25}".format(Timer().GetTimeStamp()))
+            historyWriter.writerow(row)
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_unv.py

 * *Ordering differences only*

```diff
@@ -1,73 +1,73 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#                   Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-
-# Kratos Core and Apps
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-
-# Import logger base classes
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.design_logger_base import DesignLogger
-
-# ==============================================================================
-class DesignLoggerUNV( DesignLogger ):
-
-    # --------------------------------------------------------------------------
-    def __init__( self, model_part_controller, optimization_settings ):
-        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
-        self.design_surface = model_part_controller.GetDesignSurface()
-        self.output_settings = optimization_settings["output"]
-
-        self.write_design_surface = False
-        self.write_optimization_model_part = False
-        self.design_history_filename = None
-
-        self.__DetermineOutputMode()
-        self.__CreateUNVIO()
-
-    # --------------------------------------------------------------------------
-    def __DetermineOutputMode( self ):
-        output_mode = self.output_settings["design_output_mode"].GetString()
-
-        if output_mode == "write_design_surface":
-            self.write_design_surface = True
-            self.design_history_filename = self.design_surface.Name
-        elif output_mode == "write_optimization_model_part":
-            if self.optimization_model_part.NumberOfElements() == 0:
-                raise NameError("Output of optimization model part in UNV-format requires definition of elements. No elements are given in current mdpa! You may change the design output mode.")
-            self.write_optimization_model_part = True
-            self.design_history_filename = self.optimization_model_part.Name
-        else:
-            raise NameError("The following design output mode is not defined within a UNV output (name may be misspelled): " + OutputMode)
-
-    # --------------------------------------------------------------------------
-    def __CreateUNVIO( self ):
-        results_directory = self.output_settings["output_directory"].GetString()
-        design_history_file_path =  results_directory+"/"+self.design_history_filename
-        nodal_results = self.output_settings["nodal_results"]
-
-        if self.write_design_surface:
-            self.UNVIO = KSO.UniversalFileIO( self.design_surface, design_history_file_path, "WriteConditionsOnly", nodal_results )
-        elif self.write_optimization_model_part:
-            self.UNVIO = KSO.UniversalFileIO( self.optimization_model_part, design_history_file_path, "WriteElementsOnly", nodal_results )
-
-    # --------------------------------------------------------------------------
-    def InitializeLogging( self ):
-        self.UNVIO.InitializeLogging()
-
-    # --------------------------------------------------------------------------
-    def LogCurrentDesign( self, OptimizationIteration ):
-        self.UNVIO.LogNodalResults( OptimizationIteration )
-
-    # --------------------------------------------------------------------------
-    def FinalizeLogging( self ):
-        pass
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#                   Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+
+# Kratos Core and Apps
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+
+# Import logger base classes
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.design_logger_base import DesignLogger
+
+# ==============================================================================
+class DesignLoggerUNV( DesignLogger ):
+
+    # --------------------------------------------------------------------------
+    def __init__( self, model_part_controller, optimization_settings ):
+        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
+        self.design_surface = model_part_controller.GetDesignSurface()
+        self.output_settings = optimization_settings["output"]
+
+        self.write_design_surface = False
+        self.write_optimization_model_part = False
+        self.design_history_filename = None
+
+        self.__DetermineOutputMode()
+        self.__CreateUNVIO()
+
+    # --------------------------------------------------------------------------
+    def __DetermineOutputMode( self ):
+        output_mode = self.output_settings["design_output_mode"].GetString()
+
+        if output_mode == "write_design_surface":
+            self.write_design_surface = True
+            self.design_history_filename = self.design_surface.Name
+        elif output_mode == "write_optimization_model_part":
+            if self.optimization_model_part.NumberOfElements() == 0:
+                raise NameError("Output of optimization model part in UNV-format requires definition of elements. No elements are given in current mdpa! You may change the design output mode.")
+            self.write_optimization_model_part = True
+            self.design_history_filename = self.optimization_model_part.Name
+        else:
+            raise NameError("The following design output mode is not defined within a UNV output (name may be misspelled): " + OutputMode)
+
+    # --------------------------------------------------------------------------
+    def __CreateUNVIO( self ):
+        results_directory = self.output_settings["output_directory"].GetString()
+        design_history_file_path =  results_directory+"/"+self.design_history_filename
+        nodal_results = self.output_settings["nodal_results"]
+
+        if self.write_design_surface:
+            self.UNVIO = KSO.UniversalFileIO( self.design_surface, design_history_file_path, "WriteConditionsOnly", nodal_results )
+        elif self.write_optimization_model_part:
+            self.UNVIO = KSO.UniversalFileIO( self.optimization_model_part, design_history_file_path, "WriteElementsOnly", nodal_results )
+
+    # --------------------------------------------------------------------------
+    def InitializeLogging( self ):
+        self.UNVIO.InitializeLogging()
+
+    # --------------------------------------------------------------------------
+    def LogCurrentDesign( self, OptimizationIteration ):
+        self.UNVIO.LogNodalResults( OptimizationIteration )
+
+    # --------------------------------------------------------------------------
+    def FinalizeLogging( self ):
+        pass
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_steepest_descent.py

 * *Ordering differences only*

```diff
@@ -1,64 +1,64 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#                   Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-# importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Import logger base classes
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_base import ValueLogger
-
-# Import additional libraries
-import csv
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
-
-# ==============================================================================
-class ValueLoggerSteepestDescent( ValueLogger ):
-    # --------------------------------------------------------------------------
-    def InitializeLogging( self ):
-        with open(self.complete_log_file_name, 'w') as csvfile:
-            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
-            row = []
-            row.append("{:>4s}".format("itr"))
-            row.append("{:>13s}".format("f"))
-            row.append("{:>13s}".format("df_abs[%]"))
-            row.append("{:>13s}".format("df_rel[%]"))
-            row.append("{:>13s}".format("norm_df"))
-            row.append("{:>13s}".format("step_size"))
-            row.append("{:>25s}".format("time_stamp"))
-            historyWriter.writerow(row)
-
-    # --------------------------------------------------------------------------
-    def _WriteCurrentValuesToConsole( self ):
-        objective_id = self.objectives[0]["identifier"].GetString()
-        KM.Logger.Print("")
-        KM.Logger.PrintInfo("ShapeOpt", "Current value of objective = ", "{:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
-
-        KM.Logger.PrintInfo("ShapeOpt", "Absolut change of objective = ","{:> .5E}".format(self.history["abs_change_objective"][self.current_index])," [%]")
-        KM.Logger.PrintInfo("ShapeOpt", "Relative change of objective = ","{:> .5E}".format(self.history["rel_change_objective"][self.current_index])," [%]\n")
-
-    # --------------------------------------------------------------------------
-    def _WriteCurrentValuesToFile( self ):
-        with open(self.complete_log_file_name, 'a') as csvfile:
-            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
-            row = []
-            row.append("{:>4d}".format(self.current_index))
-
-            objective_id = self.objectives[0]["identifier"].GetString()
-            row.append(" {:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["abs_change_objective"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["rel_change_objective"][self.current_index]))
-
-            row.append(" {:> .5E}".format(self.history["norm_objective_gradient"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["step_size"][self.current_index]))
-            row.append("{:>25}".format(Timer().GetTimeStamp()))
-            historyWriter.writerow(row)
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#                   Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+# importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Import logger base classes
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_base import ValueLogger
+
+# Import additional libraries
+import csv
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
+
+# ==============================================================================
+class ValueLoggerSteepestDescent( ValueLogger ):
+    # --------------------------------------------------------------------------
+    def InitializeLogging( self ):
+        with open(self.complete_log_file_name, 'w') as csvfile:
+            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
+            row = []
+            row.append("{:>4s}".format("itr"))
+            row.append("{:>13s}".format("f"))
+            row.append("{:>13s}".format("df_abs[%]"))
+            row.append("{:>13s}".format("df_rel[%]"))
+            row.append("{:>13s}".format("norm_df"))
+            row.append("{:>13s}".format("step_size"))
+            row.append("{:>25s}".format("time_stamp"))
+            historyWriter.writerow(row)
+
+    # --------------------------------------------------------------------------
+    def _WriteCurrentValuesToConsole( self ):
+        objective_id = self.objectives[0]["identifier"].GetString()
+        KM.Logger.Print("")
+        KM.Logger.PrintInfo("ShapeOpt", "Current value of objective = ", "{:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
+
+        KM.Logger.PrintInfo("ShapeOpt", "Absolut change of objective = ","{:> .5E}".format(self.history["abs_change_objective"][self.current_index])," [%]")
+        KM.Logger.PrintInfo("ShapeOpt", "Relative change of objective = ","{:> .5E}".format(self.history["rel_change_objective"][self.current_index])," [%]\n")
+
+    # --------------------------------------------------------------------------
+    def _WriteCurrentValuesToFile( self ):
+        with open(self.complete_log_file_name, 'a') as csvfile:
+            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
+            row = []
+            row.append("{:>4d}".format(self.current_index))
+
+            objective_id = self.objectives[0]["identifier"].GetString()
+            row.append(" {:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["abs_change_objective"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["rel_change_objective"][self.current_index]))
+
+            row.append(" {:> .5E}".format(self.history["norm_objective_gradient"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["step_size"][self.current_index]))
+            row.append("{:>25}".format(Timer().GetTimeStamp()))
+            historyWriter.writerow(row)
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_bead_optimization.py

 * *Ordering differences only*

```diff
@@ -1,79 +1,79 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#                   Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-# importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Import logger base classes
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_base import ValueLogger
-
-# Import additional libraries
-import csv
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
-
-# ==============================================================================
-class ValueLoggerBeadOptimization( ValueLogger ):
-    # --------------------------------------------------------------------------
-    def InitializeLogging( self ):
-        with open(self.complete_log_file_name, 'w') as csvfile:
-            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
-            row = []
-            row.append("{:>12s}".format("overall_itr"))
-            row.append("{:>10s}".format("outer_itr"))
-            row.append("{:>10s}".format("inner_itr"))
-            row.append("{:>13s}".format("l"))
-            row.append("{:>13s}".format("dl_rel[%]"))
-            row.append("{:>13s}".format("f"))
-            row.append("{:>13s}".format("df_abs[%]"))
-            row.append("{:>13s}".format("df_rel[%]"))
-            row.append("{:>14s}".format("max_norm_dfda"))
-            row.append("{:>13s}".format("lambda_p"))
-            row.append("{:>13s}".format("p"))
-            row.append("{:>13s}".format("p_scaling"))
-            row.append("{:>13s}".format("p_fac"))
-            row.append("{:>13s}".format("step_size"))
-            row.append("{:>25s}".format("time_stamp"))
-            historyWriter.writerow(row)
-
-    # --------------------------------------------------------------------------
-    def _WriteCurrentValuesToConsole( self ):
-        objective_id = self.objectives[0]["identifier"].GetString()
-        KM.Logger.Print("")
-        KM.Logger.PrintInfo("ShapeOpt", "Current value of objective = ","{:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
-
-        KM.Logger.PrintInfo("ShapeOpt", "Absolut change of objective = ","{:> .5E}".format(self.history["abs_change_objective"][self.current_index])," [%]")
-        KM.Logger.PrintInfo("ShapeOpt", "Relative change of objective = ","{:> .5E}".format(self.history["rel_change_objective"][self.current_index])," [%]\n")
-        KM.Logger.PrintInfo("ShapeOpt", "Value of penalty term = ","{:> .5E}".format(self.history["penalty_value"][self.current_index]),"\n")
-
-    # --------------------------------------------------------------------------
-    def _WriteCurrentValuesToFile( self ):
-        with open(self.complete_log_file_name, 'a') as csvfile:
-            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
-            row = []
-            row.append("{:>12d}".format(self.current_index))
-            row.append("{:>10d}".format(self.history["outer_iteration"][self.current_index]))
-            row.append("{:>10d}".format(self.history["inner_iteration"][self.current_index]))
-            objective_id = self.objectives[0]["identifier"].GetString()
-            row.append(" {:> .5E}".format(self.history["lagrange_value"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["lagrange_value_relative_change"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["abs_change_objective"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["rel_change_objective"][self.current_index]))
-            row.append("  {:> .5E}".format(self.history["max_norm_objective_gradient"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["penalty_lambda"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["penalty_value"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["penalty_scaling"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["penalty_factor"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["step_size"][self.current_index]))
-            row.append("{:>25}".format(Timer().GetTimeStamp()))
-            historyWriter.writerow(row)
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#                   Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+# importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Import logger base classes
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_base import ValueLogger
+
+# Import additional libraries
+import csv
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
+
+# ==============================================================================
+class ValueLoggerBeadOptimization( ValueLogger ):
+    # --------------------------------------------------------------------------
+    def InitializeLogging( self ):
+        with open(self.complete_log_file_name, 'w') as csvfile:
+            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
+            row = []
+            row.append("{:>12s}".format("overall_itr"))
+            row.append("{:>10s}".format("outer_itr"))
+            row.append("{:>10s}".format("inner_itr"))
+            row.append("{:>13s}".format("l"))
+            row.append("{:>13s}".format("dl_rel[%]"))
+            row.append("{:>13s}".format("f"))
+            row.append("{:>13s}".format("df_abs[%]"))
+            row.append("{:>13s}".format("df_rel[%]"))
+            row.append("{:>14s}".format("max_norm_dfda"))
+            row.append("{:>13s}".format("lambda_p"))
+            row.append("{:>13s}".format("p"))
+            row.append("{:>13s}".format("p_scaling"))
+            row.append("{:>13s}".format("p_fac"))
+            row.append("{:>13s}".format("step_size"))
+            row.append("{:>25s}".format("time_stamp"))
+            historyWriter.writerow(row)
+
+    # --------------------------------------------------------------------------
+    def _WriteCurrentValuesToConsole( self ):
+        objective_id = self.objectives[0]["identifier"].GetString()
+        KM.Logger.Print("")
+        KM.Logger.PrintInfo("ShapeOpt", "Current value of objective = ","{:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
+
+        KM.Logger.PrintInfo("ShapeOpt", "Absolut change of objective = ","{:> .5E}".format(self.history["abs_change_objective"][self.current_index])," [%]")
+        KM.Logger.PrintInfo("ShapeOpt", "Relative change of objective = ","{:> .5E}".format(self.history["rel_change_objective"][self.current_index])," [%]\n")
+        KM.Logger.PrintInfo("ShapeOpt", "Value of penalty term = ","{:> .5E}".format(self.history["penalty_value"][self.current_index]),"\n")
+
+    # --------------------------------------------------------------------------
+    def _WriteCurrentValuesToFile( self ):
+        with open(self.complete_log_file_name, 'a') as csvfile:
+            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
+            row = []
+            row.append("{:>12d}".format(self.current_index))
+            row.append("{:>10d}".format(self.history["outer_iteration"][self.current_index]))
+            row.append("{:>10d}".format(self.history["inner_iteration"][self.current_index]))
+            objective_id = self.objectives[0]["identifier"].GetString()
+            row.append(" {:> .5E}".format(self.history["lagrange_value"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["lagrange_value_relative_change"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["abs_change_objective"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["rel_change_objective"][self.current_index]))
+            row.append("  {:> .5E}".format(self.history["max_norm_objective_gradient"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["penalty_lambda"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["penalty_value"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["penalty_scaling"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["penalty_factor"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["step_size"][self.current_index]))
+            row.append("{:>25}".format(Timer().GetTimeStamp()))
+            historyWriter.writerow(row)
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_shape_fraction_optimization.py

 * *Ordering differences only*

```diff
@@ -1,92 +1,92 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Schmölz David, https://github.com/dschmoelz
-#
-# ==============================================================================
-
-# importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Import logger base classes
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_base import ValueLogger
-
-# Import additional libraries
-import csv
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
-
-# ==============================================================================
-class ValueLoggerShapeFractionOptimization( ValueLogger ):
-    # --------------------------------------------------------------------------
-    def InitializeLogging( self ):
-        with open(self.complete_log_file_name, 'w') as csvfile:
-            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
-            row = []
-            row.append("{:>4s}".format("itr"))
-            row.append("{:>13s}".format("f"))
-            row.append("{:>13s}".format("df_abs[%]"))
-            row.append("{:>13s}".format("df_rel[%]"))
-            row.append("{:>13s}".format("penalty_value"))
-            row.append("{:>13s}".format("penalty_factor"))
-            row.append("{:>13s}".format("f_p"))
-            row.append("{:>13s}".format("df_rel_p"))
-            row.append("{:>13s}".format("shape_fraction"))
-
-            for itr in range(self.constraints.size()):
-                con_type = self.constraints[itr]["type"].GetString()
-                row.append("{:>13s}".format("c"+str(itr+1)+": "+con_type))
-                row.append("{:>13s}".format("c"+str(itr+1)+"_ref"))
-
-            row.append("{:>13s}".format("step_size"))
-            row.append("{:>13s}".format("inf_norm_s"))
-            row.append("{:>13s}".format("inf_norm_c"))
-            row.append("{:>25s}".format("time_stamp"))
-            historyWriter.writerow(row)
-
-    # --------------------------------------------------------------------------
-    def _WriteCurrentValuesToConsole( self ):
-        objective_id = self.objectives[0]["identifier"].GetString()
-        KM.Logger.Print("")
-        KM.Logger.PrintInfo("ShapeOpt", "Current value of objective = ", "{:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
-
-        KM.Logger.PrintInfo("ShapeOpt", "Absolute change of objective = ","{:> .5E}".format(self.history["abs_change_objective"][self.current_index])," [%]")
-        KM.Logger.PrintInfo("ShapeOpt", "Relative change of objective = ","{:> .5E}".format(self.history["rel_change_objective"][self.current_index])," [%]\n")
-
-        for itr in range(self.constraints.size()):
-            constraint_id = self.constraints[itr]["identifier"].GetString()
-            KM.Logger.PrintInfo("ShapeOpt", "Value of C"+str(itr+1)+" = ", "{:> .5E}".format(self.history["response_value"][constraint_id][self.current_index]))
-
-    # --------------------------------------------------------------------------
-    def _WriteCurrentValuesToFile( self ):
-        with open(self.complete_log_file_name, 'a') as csvfile:
-            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
-            row = []
-            row.append("{:>4d}".format(self.current_index))
-
-            objective_id = self.objectives[0]["identifier"].GetString()
-            row.append(" {:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["abs_change_objective"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["rel_change_objective"][self.current_index]))
-
-            row.append(" {:> .5E}".format(self.history["penalty_value"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["penalty_factor"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["f_p"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["df_rel_p"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["shape_fraction"][self.current_index]))
-
-
-            for itr in range(self.constraints.size()):
-                constraint_id = self.constraints[itr]["identifier"].GetString()
-                row.append(" {:> .5E}".format(self.history["response_value"][constraint_id][self.current_index]))
-                row.append(" {:> .5E}".format(self.communicator.getReferenceValue(constraint_id)))
-
-            row.append(" {:> .5E}".format(self.history["step_size"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["inf_norm_s"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["inf_norm_c"][self.current_index]))
-            row.append("{:>25}".format(Timer().GetTimeStamp()))
-            historyWriter.writerow(row)
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Schmölz David, https://github.com/dschmoelz
+#
+# ==============================================================================
+
+# importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Import logger base classes
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_base import ValueLogger
+
+# Import additional libraries
+import csv
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
+
+# ==============================================================================
+class ValueLoggerShapeFractionOptimization( ValueLogger ):
+    # --------------------------------------------------------------------------
+    def InitializeLogging( self ):
+        with open(self.complete_log_file_name, 'w') as csvfile:
+            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
+            row = []
+            row.append("{:>4s}".format("itr"))
+            row.append("{:>13s}".format("f"))
+            row.append("{:>13s}".format("df_abs[%]"))
+            row.append("{:>13s}".format("df_rel[%]"))
+            row.append("{:>13s}".format("penalty_value"))
+            row.append("{:>13s}".format("penalty_factor"))
+            row.append("{:>13s}".format("f_p"))
+            row.append("{:>13s}".format("df_rel_p"))
+            row.append("{:>13s}".format("shape_fraction"))
+
+            for itr in range(self.constraints.size()):
+                con_type = self.constraints[itr]["type"].GetString()
+                row.append("{:>13s}".format("c"+str(itr+1)+": "+con_type))
+                row.append("{:>13s}".format("c"+str(itr+1)+"_ref"))
+
+            row.append("{:>13s}".format("step_size"))
+            row.append("{:>13s}".format("inf_norm_s"))
+            row.append("{:>13s}".format("inf_norm_c"))
+            row.append("{:>25s}".format("time_stamp"))
+            historyWriter.writerow(row)
+
+    # --------------------------------------------------------------------------
+    def _WriteCurrentValuesToConsole( self ):
+        objective_id = self.objectives[0]["identifier"].GetString()
+        KM.Logger.Print("")
+        KM.Logger.PrintInfo("ShapeOpt", "Current value of objective = ", "{:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
+
+        KM.Logger.PrintInfo("ShapeOpt", "Absolute change of objective = ","{:> .5E}".format(self.history["abs_change_objective"][self.current_index])," [%]")
+        KM.Logger.PrintInfo("ShapeOpt", "Relative change of objective = ","{:> .5E}".format(self.history["rel_change_objective"][self.current_index])," [%]\n")
+
+        for itr in range(self.constraints.size()):
+            constraint_id = self.constraints[itr]["identifier"].GetString()
+            KM.Logger.PrintInfo("ShapeOpt", "Value of C"+str(itr+1)+" = ", "{:> .5E}".format(self.history["response_value"][constraint_id][self.current_index]))
+
+    # --------------------------------------------------------------------------
+    def _WriteCurrentValuesToFile( self ):
+        with open(self.complete_log_file_name, 'a') as csvfile:
+            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
+            row = []
+            row.append("{:>4d}".format(self.current_index))
+
+            objective_id = self.objectives[0]["identifier"].GetString()
+            row.append(" {:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["abs_change_objective"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["rel_change_objective"][self.current_index]))
+
+            row.append(" {:> .5E}".format(self.history["penalty_value"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["penalty_factor"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["f_p"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["df_rel_p"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["shape_fraction"][self.current_index]))
+
+
+            for itr in range(self.constraints.size()):
+                constraint_id = self.constraints[itr]["identifier"].GetString()
+                row.append(" {:> .5E}".format(self.history["response_value"][constraint_id][self.current_index]))
+                row.append(" {:> .5E}".format(self.communicator.getReferenceValue(constraint_id)))
+
+            row.append(" {:> .5E}".format(self.history["step_size"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["inf_norm_s"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["inf_norm_c"][self.current_index]))
+            row.append("{:>25}".format(Timer().GetTimeStamp()))
+            historyWriter.writerow(row)
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_base.py

 * *Ordering differences only*

```diff
@@ -1,28 +1,28 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#                   Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-
-# ==============================================================================
-class DesignLogger:
-
-    # --------------------------------------------------------------------------
-    def InitializeLogging( self ):
-        raise RuntimeError("Design logger base class is called. Please check your implementation of the function >> InitializeLogging << .")
-
-    # --------------------------------------------------------------------------
-    def LogCurrentDesign( self, optimizationIteration ):
-        raise RuntimeError("Design logger base class is called. Please check your implementation of the function >> LogCurrentDesign << .")
-
-    #---------------------------------------------------------------------------
-    def FinalizeLogging( self ):
-        raise RuntimeError("Design logger base class is called. Please check your implementation of the function >> FinalizeLogging << .")
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#                   Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+
+# ==============================================================================
+class DesignLogger:
+
+    # --------------------------------------------------------------------------
+    def InitializeLogging( self ):
+        raise RuntimeError("Design logger base class is called. Please check your implementation of the function >> InitializeLogging << .")
+
+    # --------------------------------------------------------------------------
+    def LogCurrentDesign( self, optimizationIteration ):
+        raise RuntimeError("Design logger base class is called. Please check your implementation of the function >> LogCurrentDesign << .")
+
+    #---------------------------------------------------------------------------
+    def FinalizeLogging( self ):
+        raise RuntimeError("Design logger base class is called. Please check your implementation of the function >> FinalizeLogging << .")
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/loggers/sensitivity_heatmap_logger.py

 * *Ordering differences only*

```diff
@@ -1,91 +1,91 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Schmölz David, https://github.com/dschmoelz
-#
-# ==============================================================================
-
-# importing the Kratos Library
-import KratosMultiphysics as Kratos
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_sensitivity_heatmap import SensitivityHeatmapCalculator
-
-# ==============================================================================
-class SensitivityHeatmapLoggerBase:
-
-    # --------------------------------------------------------------------------
-    def __init__( self, model_part_controller, optimization_settings ):
-
-        default_heatmap_settings = Kratos.Parameters("""
-        {
-            "norm_type": "l2",
-            "sensitivity_weighting": true,
-            "mapping" : true,
-            "relaxation_method": "reciprocal",
-            "relaxation_coefficient": 0.5
-        }""")
-
-        self.heatmap_settings = optimization_settings["output"]["sensitivity_heatmap_settings"]
-        if self.heatmap_settings.Has("relaxation_method") and self.heatmap_settings["relaxation_method"].GetString() == "constant":
-            if not self.heatmap_settings.Has("relaxation_coefficient"):
-                raise RuntimeError("'relaxation_coefficient' is missing for relaxation method 'constant'!")
-        self.heatmap_settings.ValidateAndAssignDefaults(default_heatmap_settings)
-
-        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
-        self.design_surface = model_part_controller.GetDesignSurface()
-
-        self.objectives = optimization_settings["objectives"]
-        self.constraints = optimization_settings["constraints"]
-
-        self.sensitivity_heatmap_calculator = None
-
-    # --------------------------------------------------------------------------
-    def InitializeLogging ( self ):
-        raise RuntimeError("Sensitivity Heatmap logger base class is called. Please check your implementation of the function >> InitializeLogging << .")
-
-    # --------------------------------------------------------------------------
-    def LogSensitivityHeatmap(self, optimization_iteration, mapper):
-        self.sensitivity_heatmap_calculator.ComputeHeatmaps(optimization_iteration, mapper)
-
-# ==============================================================================
-class SensitivityHeatmapLoggerSteepestDescent(SensitivityHeatmapLoggerBase):
-
-    def InitializeLogging(self):
-        self.heatmap_settings.AddString("design_variable_name", "X")
-        self.heatmap_settings.AddInt("design_variable_dimension", 3)
-        self.sensitivity_heatmap_calculator = SensitivityHeatmapCalculator(self.design_surface, self.objectives, self.constraints, self.heatmap_settings)
-
-
-# ==============================================================================
-class SensitivityHeatmapLoggerPenalizedProjection(SensitivityHeatmapLoggerBase):
-
-    def InitializeLogging(self):
-        self.heatmap_settings.AddString("design_variable_name", "X")
-        self.heatmap_settings.AddInt("design_variable_dimension", 3)
-        self.sensitivity_heatmap_calculator = SensitivityHeatmapCalculator(self.design_surface, self.objectives, self.constraints, self.heatmap_settings)
-
-# ==============================================================================
-class SensitivityHeatmapLoggerGradientProjection(SensitivityHeatmapLoggerBase):
-
-    def InitializeLogging(self):
-        self.heatmap_settings.AddString("design_variable_name", "X")
-        self.heatmap_settings.AddInt("design_variable_dimension", 3)
-        self.sensitivity_heatmap_calculator = SensitivityHeatmapCalculator(self.design_surface, self.objectives, self.constraints, self.heatmap_settings)
-
-# ==============================================================================
-class SensitivityHeatmapLoggerTrustRegion(SensitivityHeatmapLoggerBase):
-
-    def InitializeLogging(self):
-        self.heatmap_settings.AddString("design_variable_name", "X")
-        self.heatmap_settings.AddInt("design_variable_dimension", 3)
-        self.sensitivity_heatmap_calculator = SensitivityHeatmapCalculator(self.design_surface, self.objectives, self.constraints, self.heatmap_settings)
-
-# ==============================================================================
-class SensitivityHeatmapLoggerBeadOptimization(SensitivityHeatmapLoggerBase):
-
-    def InitializeLogging(self):
-        self.heatmap_settings.AddString("design_variable_name", "ALPHA")
-        self.heatmap_settings.AddInt("design_variable_dimension", 1)
-        self.sensitivity_heatmap_calculator = SensitivityHeatmapCalculator(self.design_surface, self.objectives, self.constraints, self.heatmap_settings)
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Schmölz David, https://github.com/dschmoelz
+#
+# ==============================================================================
+
+# importing the Kratos Library
+import KratosMultiphysics as Kratos
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_sensitivity_heatmap import SensitivityHeatmapCalculator
+
+# ==============================================================================
+class SensitivityHeatmapLoggerBase:
+
+    # --------------------------------------------------------------------------
+    def __init__( self, model_part_controller, optimization_settings ):
+
+        default_heatmap_settings = Kratos.Parameters("""
+        {
+            "norm_type": "l2",
+            "sensitivity_weighting": true,
+            "mapping" : true,
+            "relaxation_method": "reciprocal",
+            "relaxation_coefficient": 0.5
+        }""")
+
+        self.heatmap_settings = optimization_settings["output"]["sensitivity_heatmap_settings"]
+        if self.heatmap_settings.Has("relaxation_method") and self.heatmap_settings["relaxation_method"].GetString() == "constant":
+            if not self.heatmap_settings.Has("relaxation_coefficient"):
+                raise RuntimeError("'relaxation_coefficient' is missing for relaxation method 'constant'!")
+        self.heatmap_settings.ValidateAndAssignDefaults(default_heatmap_settings)
+
+        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
+        self.design_surface = model_part_controller.GetDesignSurface()
+
+        self.objectives = optimization_settings["objectives"]
+        self.constraints = optimization_settings["constraints"]
+
+        self.sensitivity_heatmap_calculator = None
+
+    # --------------------------------------------------------------------------
+    def InitializeLogging ( self ):
+        raise RuntimeError("Sensitivity Heatmap logger base class is called. Please check your implementation of the function >> InitializeLogging << .")
+
+    # --------------------------------------------------------------------------
+    def LogSensitivityHeatmap(self, optimization_iteration, mapper):
+        self.sensitivity_heatmap_calculator.ComputeHeatmaps(optimization_iteration, mapper)
+
+# ==============================================================================
+class SensitivityHeatmapLoggerSteepestDescent(SensitivityHeatmapLoggerBase):
+
+    def InitializeLogging(self):
+        self.heatmap_settings.AddString("design_variable_name", "X")
+        self.heatmap_settings.AddInt("design_variable_dimension", 3)
+        self.sensitivity_heatmap_calculator = SensitivityHeatmapCalculator(self.design_surface, self.objectives, self.constraints, self.heatmap_settings)
+
+
+# ==============================================================================
+class SensitivityHeatmapLoggerPenalizedProjection(SensitivityHeatmapLoggerBase):
+
+    def InitializeLogging(self):
+        self.heatmap_settings.AddString("design_variable_name", "X")
+        self.heatmap_settings.AddInt("design_variable_dimension", 3)
+        self.sensitivity_heatmap_calculator = SensitivityHeatmapCalculator(self.design_surface, self.objectives, self.constraints, self.heatmap_settings)
+
+# ==============================================================================
+class SensitivityHeatmapLoggerGradientProjection(SensitivityHeatmapLoggerBase):
+
+    def InitializeLogging(self):
+        self.heatmap_settings.AddString("design_variable_name", "X")
+        self.heatmap_settings.AddInt("design_variable_dimension", 3)
+        self.sensitivity_heatmap_calculator = SensitivityHeatmapCalculator(self.design_surface, self.objectives, self.constraints, self.heatmap_settings)
+
+# ==============================================================================
+class SensitivityHeatmapLoggerTrustRegion(SensitivityHeatmapLoggerBase):
+
+    def InitializeLogging(self):
+        self.heatmap_settings.AddString("design_variable_name", "X")
+        self.heatmap_settings.AddInt("design_variable_dimension", 3)
+        self.sensitivity_heatmap_calculator = SensitivityHeatmapCalculator(self.design_surface, self.objectives, self.constraints, self.heatmap_settings)
+
+# ==============================================================================
+class SensitivityHeatmapLoggerBeadOptimization(SensitivityHeatmapLoggerBase):
+
+    def InitializeLogging(self):
+        self.heatmap_settings.AddString("design_variable_name", "ALPHA")
+        self.heatmap_settings.AddInt("design_variable_dimension", 1)
+        self.sensitivity_heatmap_calculator = SensitivityHeatmapCalculator(self.design_surface, self.objectives, self.constraints, self.heatmap_settings)
```

## KratosMultiphysics/ShapeOptimizationApplication/loggers/data_logger_factory.py

 * *Ordering differences only*

```diff
@@ -1,199 +1,199 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#                   Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-
-# Kratos Core and Apps
-import KratosMultiphysics as Kratos
-
-# Additional imports
-import shutil
-import os
-
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.design_logger_gid import DesignLoggerGID
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.design_logger_unv import DesignLoggerUNV
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.design_logger_vtk import DesignLoggerVTK
-
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_steepest_descent import ValueLoggerSteepestDescent
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_penalized_projection import ValueLoggerPenalizedProjection
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_trust_region import ValueLoggerTrustRegion
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_bead_optimization import ValueLoggerBeadOptimization
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_gradient_projection import ValueLoggerGradientProjection
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_relaxed_gradient_projection import ValueLoggerRelaxedGradientProjection
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_shape_fraction_optimization import ValueLoggerShapeFractionOptimization
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.sensitivity_heatmap_logger import (
-    SensitivityHeatmapLoggerSteepestDescent,
-    SensitivityHeatmapLoggerPenalizedProjection,
-    SensitivityHeatmapLoggerGradientProjection,
-    SensitivityHeatmapLoggerTrustRegion,
-    SensitivityHeatmapLoggerBeadOptimization)
-
-# ==============================================================================
-def CreateDataLogger( ModelPartController, Communicator, OptimizationSettings ):
-    return DataLogger( ModelPartController, Communicator, OptimizationSettings )
-
-# ==============================================================================
-class DataLogger():
-    # --------------------------------------------------------------------------
-    def __init__( self, ModelPartController, Communicator, OptimizationSettings ):
-        self.ModelPartController = ModelPartController
-        self.Communicator = Communicator
-        self.OptimizationSettings = OptimizationSettings
-
-        default_logger_settings = Kratos.Parameters("""
-        {
-            "output_directory"          : "Optimization_Results",
-            "optimization_log_filename" : "optimization_log",
-            "design_output_mode"        : "write_optimization_model_part",
-            "sensitivity_heatmap"       : false,
-            "sensitivity_heatmap_settings": {},
-            "nodal_results"             : [ "SHAPE_CHANGE" ],
-            "output_format"             : { "name": "vtk" }
-        }""")
-
-        self.OptimizationSettings["output"].ValidateAndAssignDefaults(default_logger_settings)
-
-        self.ValueLogger = self.__CreateValueLogger()
-        self.DesignLogger = self.__CreateDesignLogger()
-        self.SensitivityHeatmapLogger = self.__CreateSensitivityHeatmapLogger()
-
-        self.__CreateFolderToStoreOptimizationResults()
-        self.__OutputInformationAboutResponseFunctions()
-
-    # -----------------------------------------------------------------------------
-    def __CreateValueLogger( self ):
-        AlgorithmName = self.OptimizationSettings["optimization_algorithm"]["name"].GetString()
-        if AlgorithmName == "steepest_descent":
-            return ValueLoggerSteepestDescent( self.Communicator, self.OptimizationSettings )
-        elif AlgorithmName == "penalized_projection":
-            return ValueLoggerPenalizedProjection( self.Communicator, self.OptimizationSettings )
-        elif AlgorithmName == "gradient_projection":
-            return ValueLoggerGradientProjection( self.Communicator, self.OptimizationSettings )
-        elif AlgorithmName == "trust_region":
-            return ValueLoggerTrustRegion( self.Communicator, self.OptimizationSettings )
-        elif AlgorithmName == "bead_optimization":
-            return ValueLoggerBeadOptimization( self.Communicator, self.OptimizationSettings )
-        elif AlgorithmName == "relaxed_gradient_projection":
-            return ValueLoggerRelaxedGradientProjection(self.Communicator, self.OptimizationSettings)
-        elif AlgorithmName == "shape_fraction_optimization":
-            return ValueLoggerShapeFractionOptimization( self.Communicator, self.OptimizationSettings )
-        else:
-            raise NameError("The following optimization algorithm not supported by the response logger (name may be misspelled): " + AlgorithmName)
-
-    # -----------------------------------------------------------------------------
-    def __CreateDesignLogger( self ):
-        valid_output_modes = ["write_design_surface", "write_optimization_model_part", "none"]
-        output_mode = self.OptimizationSettings["output"]["design_output_mode"].GetString()
-
-        # backward compatibility
-        if output_mode == "WriteDesignSurface":
-            Kratos.Logger.PrintWarning("ShapeOpt", "'design_output_mode': 'WriteDesignSurface' is deprecated and replaced with 'write_design_surface'.")
-            self.OptimizationSettings["output"]["design_output_mode"].SetString("write_design_surface")
-            output_mode = self.OptimizationSettings["output"]["design_output_mode"].GetString()
-
-        if output_mode == "WriteOptimizationModelPart":
-            Kratos.Logger.PrintWarning("ShapeOpt", "'design_output_mode': 'WriteOptimizationModelPart' is deprecated and replaced with 'write_optimization_model_part'.")
-            self.OptimizationSettings["output"]["design_output_mode"].SetString("write_optimization_model_part")
-            output_mode = self.OptimizationSettings["output"]["design_output_mode"].GetString()
-
-        if output_mode not in valid_output_modes:
-            raise RuntimeError("Invalid 'design_output_mode', available options are: {}".format(valid_output_modes))
-
-        if output_mode == "none":
-            Kratos.Logger.Print("")
-            Kratos.Logger.PrintInfo("ShapeOpt", "No design output will be created because 'design_output_mode' = 'None'.")
-            return None
-
-        outputFormatName = self.OptimizationSettings["output"]["output_format"]["name"].GetString()
-        if outputFormatName == "gid":
-            return DesignLoggerGID( self.ModelPartController, self.OptimizationSettings )
-        if outputFormatName == "unv":
-            return DesignLoggerUNV( self.ModelPartController, self.OptimizationSettings )
-        if outputFormatName == "vtk":
-            return DesignLoggerVTK( self.ModelPartController, self.OptimizationSettings )
-        else:
-            raise NameError("The following output format is not supported by the design logger (name may be misspelled): " + outputFormatName)
-
-    # -----------------------------------------------------------------------------
-    def __CreateSensitivityHeatmapLogger( self ):
-        if not self.OptimizationSettings["output"]["sensitivity_heatmap"].GetBool():
-            return None
-
-        AlgorithmName = self.OptimizationSettings["optimization_algorithm"]["name"].GetString()
-        if AlgorithmName == "steepest_descent":
-            return SensitivityHeatmapLoggerSteepestDescent( self.ModelPartController, self.OptimizationSettings )
-        elif AlgorithmName == "penalized_projection":
-            return SensitivityHeatmapLoggerPenalizedProjection( self.ModelPartController, self.OptimizationSettings )
-        elif AlgorithmName == "gradient_projection":
-            return SensitivityHeatmapLoggerGradientProjection( self.ModelPartController, self.OptimizationSettings )
-        elif AlgorithmName == "trust_region":
-            return SensitivityHeatmapLoggerTrustRegion( self.ModelPartController, self.OptimizationSettings )
-        elif AlgorithmName == "bead_optimization":
-            return SensitivityHeatmapLoggerBeadOptimization( self.ModelPartController, self.OptimizationSettings )
-        else:
-            raise NameError("The following optimization algorithm is not supported by the sensitivity heatmap logger (name may be misspelled): " + AlgorithmName)
-
-    # --------------------------------------------------------------------------
-    def __CreateFolderToStoreOptimizationResults ( self ):
-        resultsDirectory = self.OptimizationSettings["output"]["output_directory"].GetString()
-        if os.path.exists(resultsDirectory):
-            shutil.rmtree(resultsDirectory)
-        os.makedirs(resultsDirectory)
-
-    # --------------------------------------------------------------------------
-    def __OutputInformationAboutResponseFunctions( self ):
-        numberOfObjectives = self.OptimizationSettings["objectives"].size()
-        numberOfConstraints = self.OptimizationSettings["constraints"].size()
-
-        Kratos.Logger.Print("")
-        Kratos.Logger.PrintInfo("ShapeOpt", "The following objectives are defined:\n")
-        for objectiveNumber in range(numberOfObjectives):
-            Kratos.Logger.Print(self.OptimizationSettings["objectives"][objectiveNumber])
-
-        if numberOfConstraints != 0:
-            Kratos.Logger.PrintInfo("ShapeOpt", "The following constraints are defined:\n")
-            for constraintNumber in range(numberOfConstraints):
-                Kratos.Logger.Print(self.OptimizationSettings["constraints"][constraintNumber],"\n")
-        else:
-            Kratos.Logger.PrintInfo("ShapeOpt", "No constraints defined.\n")
-
-    # --------------------------------------------------------------------------
-    def InitializeDataLogging( self ):
-        if self.DesignLogger:
-            self.DesignLogger.InitializeLogging()
-        self.ValueLogger.InitializeLogging()
-        if self.SensitivityHeatmapLogger:
-            self.SensitivityHeatmapLogger.InitializeLogging()
-
-    # --------------------------------------------------------------------------
-    def LogCurrentDesign( self, current_iteration ):
-        if self.DesignLogger:
-            self.DesignLogger.LogCurrentDesign( current_iteration )
-
-    # --------------------------------------------------------------------------
-    def LogCurrentValues( self, current_iteration, additional_values ):
-        self.ValueLogger.LogCurrentValues( current_iteration, additional_values )
-
-    # --------------------------------------------------------------------------
-    def LogSensitivityHeatmap( self, current_iteration, mapper ):
-        if self.SensitivityHeatmapLogger:
-            self.SensitivityHeatmapLogger.LogSensitivityHeatmap( current_iteration, mapper )
-
-    # --------------------------------------------------------------------------
-    def FinalizeDataLogging( self ):
-        if self.DesignLogger:
-            self.DesignLogger.FinalizeLogging()
-        self.ValueLogger.FinalizeLogging()
-
-    # --------------------------------------------------------------------------
-    def GetValues( self, key ):
-        return self.ValueLogger.GetValues(key)
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#                   Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+
+# Kratos Core and Apps
+import KratosMultiphysics as Kratos
+
+# Additional imports
+import shutil
+import os
+
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.design_logger_gid import DesignLoggerGID
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.design_logger_unv import DesignLoggerUNV
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.design_logger_vtk import DesignLoggerVTK
+
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_steepest_descent import ValueLoggerSteepestDescent
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_penalized_projection import ValueLoggerPenalizedProjection
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_trust_region import ValueLoggerTrustRegion
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_bead_optimization import ValueLoggerBeadOptimization
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_gradient_projection import ValueLoggerGradientProjection
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_relaxed_gradient_projection import ValueLoggerRelaxedGradientProjection
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_shape_fraction_optimization import ValueLoggerShapeFractionOptimization
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.sensitivity_heatmap_logger import (
+    SensitivityHeatmapLoggerSteepestDescent,
+    SensitivityHeatmapLoggerPenalizedProjection,
+    SensitivityHeatmapLoggerGradientProjection,
+    SensitivityHeatmapLoggerTrustRegion,
+    SensitivityHeatmapLoggerBeadOptimization)
+
+# ==============================================================================
+def CreateDataLogger( ModelPartController, Communicator, OptimizationSettings ):
+    return DataLogger( ModelPartController, Communicator, OptimizationSettings )
+
+# ==============================================================================
+class DataLogger():
+    # --------------------------------------------------------------------------
+    def __init__( self, ModelPartController, Communicator, OptimizationSettings ):
+        self.ModelPartController = ModelPartController
+        self.Communicator = Communicator
+        self.OptimizationSettings = OptimizationSettings
+
+        default_logger_settings = Kratos.Parameters("""
+        {
+            "output_directory"          : "Optimization_Results",
+            "optimization_log_filename" : "optimization_log",
+            "design_output_mode"        : "write_optimization_model_part",
+            "sensitivity_heatmap"       : false,
+            "sensitivity_heatmap_settings": {},
+            "nodal_results"             : [ "SHAPE_CHANGE" ],
+            "output_format"             : { "name": "vtk" }
+        }""")
+
+        self.OptimizationSettings["output"].ValidateAndAssignDefaults(default_logger_settings)
+
+        self.ValueLogger = self.__CreateValueLogger()
+        self.DesignLogger = self.__CreateDesignLogger()
+        self.SensitivityHeatmapLogger = self.__CreateSensitivityHeatmapLogger()
+
+        self.__CreateFolderToStoreOptimizationResults()
+        self.__OutputInformationAboutResponseFunctions()
+
+    # -----------------------------------------------------------------------------
+    def __CreateValueLogger( self ):
+        AlgorithmName = self.OptimizationSettings["optimization_algorithm"]["name"].GetString()
+        if AlgorithmName == "steepest_descent":
+            return ValueLoggerSteepestDescent( self.Communicator, self.OptimizationSettings )
+        elif AlgorithmName == "penalized_projection":
+            return ValueLoggerPenalizedProjection( self.Communicator, self.OptimizationSettings )
+        elif AlgorithmName == "gradient_projection":
+            return ValueLoggerGradientProjection( self.Communicator, self.OptimizationSettings )
+        elif AlgorithmName == "trust_region":
+            return ValueLoggerTrustRegion( self.Communicator, self.OptimizationSettings )
+        elif AlgorithmName == "bead_optimization":
+            return ValueLoggerBeadOptimization( self.Communicator, self.OptimizationSettings )
+        elif AlgorithmName == "relaxed_gradient_projection":
+            return ValueLoggerRelaxedGradientProjection(self.Communicator, self.OptimizationSettings)
+        elif AlgorithmName == "shape_fraction_optimization":
+            return ValueLoggerShapeFractionOptimization( self.Communicator, self.OptimizationSettings )
+        else:
+            raise NameError("The following optimization algorithm not supported by the response logger (name may be misspelled): " + AlgorithmName)
+
+    # -----------------------------------------------------------------------------
+    def __CreateDesignLogger( self ):
+        valid_output_modes = ["write_design_surface", "write_optimization_model_part", "none"]
+        output_mode = self.OptimizationSettings["output"]["design_output_mode"].GetString()
+
+        # backward compatibility
+        if output_mode == "WriteDesignSurface":
+            Kratos.Logger.PrintWarning("ShapeOpt", "'design_output_mode': 'WriteDesignSurface' is deprecated and replaced with 'write_design_surface'.")
+            self.OptimizationSettings["output"]["design_output_mode"].SetString("write_design_surface")
+            output_mode = self.OptimizationSettings["output"]["design_output_mode"].GetString()
+
+        if output_mode == "WriteOptimizationModelPart":
+            Kratos.Logger.PrintWarning("ShapeOpt", "'design_output_mode': 'WriteOptimizationModelPart' is deprecated and replaced with 'write_optimization_model_part'.")
+            self.OptimizationSettings["output"]["design_output_mode"].SetString("write_optimization_model_part")
+            output_mode = self.OptimizationSettings["output"]["design_output_mode"].GetString()
+
+        if output_mode not in valid_output_modes:
+            raise RuntimeError("Invalid 'design_output_mode', available options are: {}".format(valid_output_modes))
+
+        if output_mode == "none":
+            Kratos.Logger.Print("")
+            Kratos.Logger.PrintInfo("ShapeOpt", "No design output will be created because 'design_output_mode' = 'None'.")
+            return None
+
+        outputFormatName = self.OptimizationSettings["output"]["output_format"]["name"].GetString()
+        if outputFormatName == "gid":
+            return DesignLoggerGID( self.ModelPartController, self.OptimizationSettings )
+        if outputFormatName == "unv":
+            return DesignLoggerUNV( self.ModelPartController, self.OptimizationSettings )
+        if outputFormatName == "vtk":
+            return DesignLoggerVTK( self.ModelPartController, self.OptimizationSettings )
+        else:
+            raise NameError("The following output format is not supported by the design logger (name may be misspelled): " + outputFormatName)
+
+    # -----------------------------------------------------------------------------
+    def __CreateSensitivityHeatmapLogger( self ):
+        if not self.OptimizationSettings["output"]["sensitivity_heatmap"].GetBool():
+            return None
+
+        AlgorithmName = self.OptimizationSettings["optimization_algorithm"]["name"].GetString()
+        if AlgorithmName == "steepest_descent":
+            return SensitivityHeatmapLoggerSteepestDescent( self.ModelPartController, self.OptimizationSettings )
+        elif AlgorithmName == "penalized_projection":
+            return SensitivityHeatmapLoggerPenalizedProjection( self.ModelPartController, self.OptimizationSettings )
+        elif AlgorithmName == "gradient_projection":
+            return SensitivityHeatmapLoggerGradientProjection( self.ModelPartController, self.OptimizationSettings )
+        elif AlgorithmName == "trust_region":
+            return SensitivityHeatmapLoggerTrustRegion( self.ModelPartController, self.OptimizationSettings )
+        elif AlgorithmName == "bead_optimization":
+            return SensitivityHeatmapLoggerBeadOptimization( self.ModelPartController, self.OptimizationSettings )
+        else:
+            raise NameError("The following optimization algorithm is not supported by the sensitivity heatmap logger (name may be misspelled): " + AlgorithmName)
+
+    # --------------------------------------------------------------------------
+    def __CreateFolderToStoreOptimizationResults ( self ):
+        resultsDirectory = self.OptimizationSettings["output"]["output_directory"].GetString()
+        if os.path.exists(resultsDirectory):
+            shutil.rmtree(resultsDirectory)
+        os.makedirs(resultsDirectory)
+
+    # --------------------------------------------------------------------------
+    def __OutputInformationAboutResponseFunctions( self ):
+        numberOfObjectives = self.OptimizationSettings["objectives"].size()
+        numberOfConstraints = self.OptimizationSettings["constraints"].size()
+
+        Kratos.Logger.Print("")
+        Kratos.Logger.PrintInfo("ShapeOpt", "The following objectives are defined:\n")
+        for objectiveNumber in range(numberOfObjectives):
+            Kratos.Logger.Print(self.OptimizationSettings["objectives"][objectiveNumber])
+
+        if numberOfConstraints != 0:
+            Kratos.Logger.PrintInfo("ShapeOpt", "The following constraints are defined:\n")
+            for constraintNumber in range(numberOfConstraints):
+                Kratos.Logger.Print(self.OptimizationSettings["constraints"][constraintNumber],"\n")
+        else:
+            Kratos.Logger.PrintInfo("ShapeOpt", "No constraints defined.\n")
+
+    # --------------------------------------------------------------------------
+    def InitializeDataLogging( self ):
+        if self.DesignLogger:
+            self.DesignLogger.InitializeLogging()
+        self.ValueLogger.InitializeLogging()
+        if self.SensitivityHeatmapLogger:
+            self.SensitivityHeatmapLogger.InitializeLogging()
+
+    # --------------------------------------------------------------------------
+    def LogCurrentDesign( self, current_iteration ):
+        if self.DesignLogger:
+            self.DesignLogger.LogCurrentDesign( current_iteration )
+
+    # --------------------------------------------------------------------------
+    def LogCurrentValues( self, current_iteration, additional_values ):
+        self.ValueLogger.LogCurrentValues( current_iteration, additional_values )
+
+    # --------------------------------------------------------------------------
+    def LogSensitivityHeatmap( self, current_iteration, mapper ):
+        if self.SensitivityHeatmapLogger:
+            self.SensitivityHeatmapLogger.LogSensitivityHeatmap( current_iteration, mapper )
+
+    # --------------------------------------------------------------------------
+    def FinalizeDataLogging( self ):
+        if self.DesignLogger:
+            self.DesignLogger.FinalizeLogging()
+        self.ValueLogger.FinalizeLogging()
+
+    # --------------------------------------------------------------------------
+    def GetValues( self, key ):
+        return self.ValueLogger.GetValues(key)
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_trust_region.py

 * *Ordering differences only*

```diff
@@ -1,100 +1,100 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#
-# ==============================================================================
-
-# importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Import logger base classes
-from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_base import ValueLogger
-
-# Import additional libraries
-import csv
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
-
-# ==============================================================================
-class ValueLoggerTrustRegion( ValueLogger ):
-    # --------------------------------------------------------------------------
-    def InitializeLogging( self ):
-        with open(self.complete_log_file_name, 'w') as csvfile:
-            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
-            row = []
-            row.append("{:>4s}".format("itr"))
-            row.append("{:>13}".format("f"))
-            row.append("{:>12s}".format("df_abs[%]"))
-            row.append("{:>12s}".format("df_rel[%]"))
-
-            for itr in range(self.constraints.size()):
-                con_type = self.constraints[itr]["type"].GetString()
-                row.append("{:>13}".format("c"+str(itr+1)+": "+con_type))
-                row.append("{:>13}".format("c"+str(itr+1)+"_ref"))
-                row.append("{:>12s}".format("len_C"+str(itr+1)))
-                row.append("{:>12s}".format("adj_len_C"+str(itr+1)))
-
-            row.append("{:>12s}".format("bi_itrs"))
-            row.append("{:>12s}".format("bi_err"))
-            row.append("{:>17}".format("test_norm_dX_bar"))
-            row.append("{:>12s}".format("norm_dX"))
-            row.append("{:>12s}".format("step_length"))
-            row.append("{:>25s}".format("time_stamp"))
-            historyWriter.writerow(row)
-
-    # --------------------------------------------------------------------------
-    def _WriteCurrentValuesToConsole( self ):
-        KM.Logger.Print("")
-        KM.Logger.Print("-------------------------------------------------------\n")
-
-        objective_id = self.objectives[0]["identifier"].GetString()
-        KM.Logger.PrintInfo("ShapeOpt", "Current value of objective = ", round(self.history["response_value"][objective_id][self.current_index],12))
-
-        KM.Logger.PrintInfo("ShapeOpt", "Absolut change of objective = ",round(self.history["abs_change_objective"][self.current_index],4)," [%]")
-        KM.Logger.PrintInfo("ShapeOpt", "Relative change of objective = ",round(self.history["rel_change_objective"][self.current_index],4)," [%]\n")
-
-        for itr in range(self.constraints.size()):
-            constraint_id = self.constraints[itr]["identifier"].GetString()
-            KM.Logger.PrintInfo("ShapeOpt", "Value of C"+str(itr+1)+" = ", round(self.history["response_value"][constraint_id][self.current_index],12), "\n")
-
-        KM.Logger.PrintInfo("ShapeOpt", "NormInf3D of dX = ", round(self.history["norm_dX"][self.current_index],6), "\n")
-
-        KM.Logger.PrintInfo("ShapeOpt", "len_bar_obj = ", round(self.history["len_bar_obj"][self.current_index],6))
-        KM.Logger.PrintInfo("ShapeOpt", "adj_len_bar_obj = ", round(self.history["adj_len_bar_obj"][self.current_index],6), "\n")
-
-        KM.Logger.PrintInfo("ShapeOpt", "len_bar_cons = ", [round(entry, 6) for entry in self.history["len_bar_cons"][self.current_index]])
-        KM.Logger.PrintInfo("ShapeOpt", "adj_len_bar_cons = ", [round(entry, 6) for entry in self.history["adj_len_bar_cons"][self.current_index]], "\n")
-
-        KM.Logger.Print("-------------------------------------------------------")
-
-    # --------------------------------------------------------------------------
-    def _WriteCurrentValuesToFile( self ):
-        with open(self.complete_log_file_name, 'a') as csvfile:
-            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
-            row = []
-            row.append("{:>4d}".format(self.current_index))
-
-            objective_id = self.objectives[0]["identifier"].GetString()
-            row.append(" {:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["abs_change_objective"][self.current_index]))
-            row.append(" {:> .5E}".format(self.history["rel_change_objective"][self.current_index]))
-
-            for itr in range(self.constraints.size()):
-                constraint_id = self.constraints[itr]["identifier"].GetString()
-                row.append(" {:> .5E}".format(self.history["response_value"][constraint_id][self.current_index]))
-                row.append(" {:> .5E}".format(self.communicator.getReferenceValue(constraint_id)))
-                row.append("{:>12f}".format(self.history["len_bar_cons"][self.current_index][itr]))
-                row.append("{:>12f}".format(self.history["adj_len_bar_cons"][self.current_index][itr]))
-
-            row.append("{:>12d}".format(self.history["bi_itrs"][self.current_index]))
-            row.append("{:>12f}".format(self.history["bi_err"][self.current_index]))
-            row.append("{:>17f}".format(self.history["test_norm_dX_bar"][self.current_index]))
-            row.append("{:>12f}".format(self.history["norm_dX"][self.current_index]))
-            row.append(" {:>.5E}".format(self.history["step_length"][self.current_index]))
-            row.append("{:>25}".format(Timer().GetTimeStamp()))
-            historyWriter.writerow(row)
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#
+# ==============================================================================
+
+# importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Import logger base classes
+from KratosMultiphysics.ShapeOptimizationApplication.loggers.value_logger_base import ValueLogger
+
+# Import additional libraries
+import csv
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
+
+# ==============================================================================
+class ValueLoggerTrustRegion( ValueLogger ):
+    # --------------------------------------------------------------------------
+    def InitializeLogging( self ):
+        with open(self.complete_log_file_name, 'w') as csvfile:
+            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
+            row = []
+            row.append("{:>4s}".format("itr"))
+            row.append("{:>13}".format("f"))
+            row.append("{:>12s}".format("df_abs[%]"))
+            row.append("{:>12s}".format("df_rel[%]"))
+
+            for itr in range(self.constraints.size()):
+                con_type = self.constraints[itr]["type"].GetString()
+                row.append("{:>13}".format("c"+str(itr+1)+": "+con_type))
+                row.append("{:>13}".format("c"+str(itr+1)+"_ref"))
+                row.append("{:>12s}".format("len_C"+str(itr+1)))
+                row.append("{:>12s}".format("adj_len_C"+str(itr+1)))
+
+            row.append("{:>12s}".format("bi_itrs"))
+            row.append("{:>12s}".format("bi_err"))
+            row.append("{:>17}".format("test_norm_dX_bar"))
+            row.append("{:>12s}".format("norm_dX"))
+            row.append("{:>12s}".format("step_length"))
+            row.append("{:>25s}".format("time_stamp"))
+            historyWriter.writerow(row)
+
+    # --------------------------------------------------------------------------
+    def _WriteCurrentValuesToConsole( self ):
+        KM.Logger.Print("")
+        KM.Logger.Print("-------------------------------------------------------\n")
+
+        objective_id = self.objectives[0]["identifier"].GetString()
+        KM.Logger.PrintInfo("ShapeOpt", "Current value of objective = ", round(self.history["response_value"][objective_id][self.current_index],12))
+
+        KM.Logger.PrintInfo("ShapeOpt", "Absolut change of objective = ",round(self.history["abs_change_objective"][self.current_index],4)," [%]")
+        KM.Logger.PrintInfo("ShapeOpt", "Relative change of objective = ",round(self.history["rel_change_objective"][self.current_index],4)," [%]\n")
+
+        for itr in range(self.constraints.size()):
+            constraint_id = self.constraints[itr]["identifier"].GetString()
+            KM.Logger.PrintInfo("ShapeOpt", "Value of C"+str(itr+1)+" = ", round(self.history["response_value"][constraint_id][self.current_index],12), "\n")
+
+        KM.Logger.PrintInfo("ShapeOpt", "NormInf3D of dX = ", round(self.history["norm_dX"][self.current_index],6), "\n")
+
+        KM.Logger.PrintInfo("ShapeOpt", "len_bar_obj = ", round(self.history["len_bar_obj"][self.current_index],6))
+        KM.Logger.PrintInfo("ShapeOpt", "adj_len_bar_obj = ", round(self.history["adj_len_bar_obj"][self.current_index],6), "\n")
+
+        KM.Logger.PrintInfo("ShapeOpt", "len_bar_cons = ", [round(entry, 6) for entry in self.history["len_bar_cons"][self.current_index]])
+        KM.Logger.PrintInfo("ShapeOpt", "adj_len_bar_cons = ", [round(entry, 6) for entry in self.history["adj_len_bar_cons"][self.current_index]], "\n")
+
+        KM.Logger.Print("-------------------------------------------------------")
+
+    # --------------------------------------------------------------------------
+    def _WriteCurrentValuesToFile( self ):
+        with open(self.complete_log_file_name, 'a') as csvfile:
+            historyWriter = csv.writer(csvfile, delimiter=',',quotechar='|',quoting=csv.QUOTE_MINIMAL)
+            row = []
+            row.append("{:>4d}".format(self.current_index))
+
+            objective_id = self.objectives[0]["identifier"].GetString()
+            row.append(" {:> .5E}".format(self.history["response_value"][objective_id][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["abs_change_objective"][self.current_index]))
+            row.append(" {:> .5E}".format(self.history["rel_change_objective"][self.current_index]))
+
+            for itr in range(self.constraints.size()):
+                constraint_id = self.constraints[itr]["identifier"].GetString()
+                row.append(" {:> .5E}".format(self.history["response_value"][constraint_id][self.current_index]))
+                row.append(" {:> .5E}".format(self.communicator.getReferenceValue(constraint_id)))
+                row.append("{:>12f}".format(self.history["len_bar_cons"][self.current_index][itr]))
+                row.append("{:>12f}".format(self.history["adj_len_bar_cons"][self.current_index][itr]))
+
+            row.append("{:>12d}".format(self.history["bi_itrs"][self.current_index]))
+            row.append("{:>12f}".format(self.history["bi_err"][self.current_index]))
+            row.append("{:>17f}".format(self.history["test_norm_dX_bar"][self.current_index]))
+            row.append("{:>12f}".format(self.history["norm_dX"][self.current_index]))
+            row.append(" {:>.5E}".format(self.history["step_length"][self.current_index]))
+            row.append("{:>25}".format(Timer().GetTimeStamp()))
+            historyWriter.writerow(row)
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_base.py

 * *Ordering differences only*

```diff
@@ -1,128 +1,128 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#                   Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-# importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Import additional libraries
-import os
-
-# ==============================================================================
-class ValueLogger():
-
-    # --------------------------------------------------------------------------
-    def __init__( self, communicator, optimization_settings ):
-        self.communicator = communicator
-        self.optimization_settings = optimization_settings
-
-        self.objectives = optimization_settings["objectives"]
-        self.constraints = optimization_settings["constraints"]
-
-        self.complete_log_file_name = self.__CreateCompleteLogFileName( optimization_settings )
-
-        self.obj_reference_value = 0
-        self.current_index = 0
-        self.previos_index = 0
-
-        self.history = { "response_value"              : {},
-                         "standardized_response_value" : {},
-                         "abs_change_objective"        : {},
-                         "rel_change_objective"        : {} }
-
-        for itr in range(self.objectives.size()):
-            objective_id = self.objectives[itr]["identifier"].GetString()
-            self.history["response_value"][objective_id] = {}
-            self.history["standardized_response_value"][objective_id] = {}
-
-        for itr in range(self.constraints.size()):
-            constraint_id = self.constraints[itr]["identifier"].GetString()
-            self.history["response_value"][constraint_id] = {}
-            self.history["standardized_response_value"][constraint_id] = {}
-
-        self.predefined_keys = list(self.history.keys())
-
-    # --------------------------------------------------------------------------
-    def InitializeLogging( self ):
-        pass
-
-    # --------------------------------------------------------------------------
-    def LogCurrentValues( self, index, additional_values_dictionary ):
-        self.current_index = index
-
-        self.__LogObjectiveValuesToHistory()
-        self.__LogConstraintValuesToHistory()
-        self.__LogAdditionalValuesToHistory( additional_values_dictionary )
-
-        self._WriteCurrentValuesToConsole()
-        self._WriteCurrentValuesToFile()
-
-        self.previos_index = index
-
-    # --------------------------------------------------------------------------
-    def FinalizeLogging( self ):
-        pass
-
-    # --------------------------------------------------------------------------
-    def GetValues( self, key ):
-        return self.history[key]
-
-    # --------------------------------------------------------------------------
-    @staticmethod
-    def __CreateCompleteLogFileName( optimization_settings ):
-        resultsDirectory = optimization_settings["output"]["output_directory"].GetString()
-        optimizationLogFilename = optimization_settings["output"]["optimization_log_filename"].GetString() + ".csv"
-        return os.path.join( resultsDirectory, optimizationLogFilename )
-
-    # --------------------------------------------------------------------------
-    def __LogObjectiveValuesToHistory( self ):
-        objective_id = self.objectives[0]["identifier"].GetString()
-        is_first_log = self.history["response_value"][objective_id] == {}
-
-        self.history["response_value"][objective_id][self.current_index] = self.communicator.getValue( objective_id )
-        self.history["standardized_response_value"][objective_id][self.current_index] = self.communicator.getStandardizedValue( objective_id )
-
-        if is_first_log:
-            self.obj_reference_value = self.communicator.getValue( objective_id )
-
-            if abs(self.obj_reference_value)<1e-12:
-                KM.Logger.PrintWarning("ShapeOpt::ValueLogger", "Objective reference value < 1e-12!! Therefore, standard reference value of 1 is assumed! ")
-                self.obj_reference_value = 1.0
-
-            self.history["abs_change_objective"] = {self.current_index: 0.0}
-            self.history["rel_change_objective"] = {self.current_index: 0.0}
-        else:
-            current_obj_value = self.history["response_value"][objective_id][self.current_index]
-            previos_obj_value = self.history["response_value"][objective_id][self.previos_index]
-            abs_change = 100*(current_obj_value-self.obj_reference_value) / abs(self.obj_reference_value)
-            rel_change = 100*(current_obj_value-previos_obj_value) / abs(self.obj_reference_value)
-
-            self.history["abs_change_objective"][self.current_index] = abs_change
-            self.history["rel_change_objective"][self.current_index] = rel_change
-
-    # --------------------------------------------------------------------------
-    def __LogConstraintValuesToHistory( self ):
-        for itr in range(self.constraints.size()):
-            constraint_id = self.constraints[itr]["identifier"].GetString()
-            self.history["response_value"][constraint_id][self.current_index] = self.communicator.getValue( constraint_id )
-            self.history["standardized_response_value"][constraint_id][self.current_index] = self.communicator.getStandardizedValue( constraint_id )
-
-    # --------------------------------------------------------------------------
-    def __LogAdditionalValuesToHistory( self, additional_values_dictionary ):
-        for key, value in additional_values_dictionary.items():
-            if key in self.predefined_keys:
-                raise NameError("ValueLogger: The key \""+key+"\" is already predefined and may not be overwritten! Predefined keys are: "+str(self.predefined_keys))
-
-            if key not in self.history.keys():
-                self.history[key] = {}
-
-            self.history[key][self.current_index] = value
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#                   Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+# importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Import additional libraries
+import os
+
+# ==============================================================================
+class ValueLogger():
+
+    # --------------------------------------------------------------------------
+    def __init__( self, communicator, optimization_settings ):
+        self.communicator = communicator
+        self.optimization_settings = optimization_settings
+
+        self.objectives = optimization_settings["objectives"]
+        self.constraints = optimization_settings["constraints"]
+
+        self.complete_log_file_name = self.__CreateCompleteLogFileName( optimization_settings )
+
+        self.obj_reference_value = 0
+        self.current_index = 0
+        self.previos_index = 0
+
+        self.history = { "response_value"              : {},
+                         "standardized_response_value" : {},
+                         "abs_change_objective"        : {},
+                         "rel_change_objective"        : {} }
+
+        for itr in range(self.objectives.size()):
+            objective_id = self.objectives[itr]["identifier"].GetString()
+            self.history["response_value"][objective_id] = {}
+            self.history["standardized_response_value"][objective_id] = {}
+
+        for itr in range(self.constraints.size()):
+            constraint_id = self.constraints[itr]["identifier"].GetString()
+            self.history["response_value"][constraint_id] = {}
+            self.history["standardized_response_value"][constraint_id] = {}
+
+        self.predefined_keys = list(self.history.keys())
+
+    # --------------------------------------------------------------------------
+    def InitializeLogging( self ):
+        pass
+
+    # --------------------------------------------------------------------------
+    def LogCurrentValues( self, index, additional_values_dictionary ):
+        self.current_index = index
+
+        self.__LogObjectiveValuesToHistory()
+        self.__LogConstraintValuesToHistory()
+        self.__LogAdditionalValuesToHistory( additional_values_dictionary )
+
+        self._WriteCurrentValuesToConsole()
+        self._WriteCurrentValuesToFile()
+
+        self.previos_index = index
+
+    # --------------------------------------------------------------------------
+    def FinalizeLogging( self ):
+        pass
+
+    # --------------------------------------------------------------------------
+    def GetValues( self, key ):
+        return self.history[key]
+
+    # --------------------------------------------------------------------------
+    @staticmethod
+    def __CreateCompleteLogFileName( optimization_settings ):
+        resultsDirectory = optimization_settings["output"]["output_directory"].GetString()
+        optimizationLogFilename = optimization_settings["output"]["optimization_log_filename"].GetString() + ".csv"
+        return os.path.join( resultsDirectory, optimizationLogFilename )
+
+    # --------------------------------------------------------------------------
+    def __LogObjectiveValuesToHistory( self ):
+        objective_id = self.objectives[0]["identifier"].GetString()
+        is_first_log = self.history["response_value"][objective_id] == {}
+
+        self.history["response_value"][objective_id][self.current_index] = self.communicator.getValue( objective_id )
+        self.history["standardized_response_value"][objective_id][self.current_index] = self.communicator.getStandardizedValue( objective_id )
+
+        if is_first_log:
+            self.obj_reference_value = self.communicator.getValue( objective_id )
+
+            if abs(self.obj_reference_value)<1e-12:
+                KM.Logger.PrintWarning("ShapeOpt::ValueLogger", "Objective reference value < 1e-12!! Therefore, standard reference value of 1 is assumed! ")
+                self.obj_reference_value = 1.0
+
+            self.history["abs_change_objective"] = {self.current_index: 0.0}
+            self.history["rel_change_objective"] = {self.current_index: 0.0}
+        else:
+            current_obj_value = self.history["response_value"][objective_id][self.current_index]
+            previos_obj_value = self.history["response_value"][objective_id][self.previos_index]
+            abs_change = 100*(current_obj_value-self.obj_reference_value) / abs(self.obj_reference_value)
+            rel_change = 100*(current_obj_value-previos_obj_value) / abs(self.obj_reference_value)
+
+            self.history["abs_change_objective"][self.current_index] = abs_change
+            self.history["rel_change_objective"][self.current_index] = rel_change
+
+    # --------------------------------------------------------------------------
+    def __LogConstraintValuesToHistory( self ):
+        for itr in range(self.constraints.size()):
+            constraint_id = self.constraints[itr]["identifier"].GetString()
+            self.history["response_value"][constraint_id][self.current_index] = self.communicator.getValue( constraint_id )
+            self.history["standardized_response_value"][constraint_id][self.current_index] = self.communicator.getStandardizedValue( constraint_id )
+
+    # --------------------------------------------------------------------------
+    def __LogAdditionalValuesToHistory( self, additional_values_dictionary ):
+        for key, value in additional_values_dictionary.items():
+            if key in self.predefined_keys:
+                raise NameError("ValueLogger: The key \""+key+"\" is already predefined and may not be overwritten! Predefined keys are: "+str(self.predefined_keys))
+
+            if key not in self.history.keys():
+                self.history[key] = {}
+
+            self.history[key][self.current_index] = value
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/response_functions/mesh_based_packaging.py

 * *Ordering differences only*

```diff
@@ -1,70 +1,70 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-import KratosMultiphysics as KM
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-from .packaging_response_base import PackagingResponseBase
-from ..custom_ios.wrl_io import WrlIO
-
-class MeshBasedPackaging(PackagingResponseBase):
-    """
-    A class for mesh packaging response function. The mesh should contain surface conditions only.
-    By default the normals of the conditions indicate the feasible side of the mesh (see setting 'feasible_in_normal_direction')
-    """
-
-    def __init__(self, identifier, response_settings, model):
-        super().__init__(identifier, response_settings, model)
-
-        self.packaging_model_part = None
-        self.packaging_model_part_needs_to_be_imported = False
-
-        packaging_model_part_name = response_settings["packaging_model_part_name"].GetString()
-        self.packaging_input_type = response_settings["packaging_model_import_settings"]["input_type"].GetString()
-        if self.packaging_input_type in ["mdpa", "vrml", "wrl"]:
-            self.packaging_model_part = self.model.CreateModelPart(packaging_model_part_name)
-            domain_size = response_settings["packaging_domain_size"].GetInt()
-            if domain_size not in [2, 3]:
-                raise Exception("PlaneBasedPackaging: Invalid 'domain_size': {}".format(domain_size))
-            self.packaging_model_part.ProcessInfo.SetValue(KM.DOMAIN_SIZE, domain_size)
-        elif self.packaging_input_type == "use_input_model_part":
-            self.packaging_model_part = self.model.GetModelPart(packaging_model_part_name)
-        else:
-            raise Exception("Other model part input options are not yet implemented.")
-
-        self.packaging_model_part.AddNodalSolutionStepVariable(KM.NORMAL)
-        self.packaging_model_part.AddNodalSolutionStepVariable(KSO.NORMALIZED_SURFACE_NORMAL)
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "packaging_model_part_name"       : "UNKNOWN_NAME",
-            "packaging_domain_size"           : 3,
-            "packaging_model_import_settings" : {
-                "input_type"     : "mdpa",
-                "input_filename" : "UNKNOWN_NAME"
-            }
-        }""")
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
-
-    def Initialize(self):
-        super().Initialize()
-
-        if self.packaging_input_type == "mdpa":
-            model_part_io = KM.ModelPartIO(self.response_settings["packaging_model_import_settings"]["input_filename"].GetString())
-            model_part_io.ReadModelPart(self.packaging_model_part)
-        elif self.packaging_input_type in ["vrml", "wrl"]:
-            model_part_io = WrlIO(self.response_settings["packaging_model_import_settings"]["input_filename"].GetString())
-            model_part_io.ReadModelPart(self.packaging_model_part)
-
-    def _CalculateDistances(self):
-        geometry_tools = KSO.GeometryUtilities(self.model_part)
-
-        self.signed_distances, self.directions = geometry_tools.ComputeDistancesToBoundingModelPart(self.packaging_model_part)
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+import KratosMultiphysics as KM
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+from .packaging_response_base import PackagingResponseBase
+from ..custom_ios.wrl_io import WrlIO
+
+class MeshBasedPackaging(PackagingResponseBase):
+    """
+    A class for mesh packaging response function. The mesh should contain surface conditions only.
+    By default the normals of the conditions indicate the feasible side of the mesh (see setting 'feasible_in_normal_direction')
+    """
+
+    def __init__(self, identifier, response_settings, model):
+        super().__init__(identifier, response_settings, model)
+
+        self.packaging_model_part = None
+        self.packaging_model_part_needs_to_be_imported = False
+
+        packaging_model_part_name = response_settings["packaging_model_part_name"].GetString()
+        self.packaging_input_type = response_settings["packaging_model_import_settings"]["input_type"].GetString()
+        if self.packaging_input_type in ["mdpa", "vrml", "wrl"]:
+            self.packaging_model_part = self.model.CreateModelPart(packaging_model_part_name)
+            domain_size = response_settings["packaging_domain_size"].GetInt()
+            if domain_size not in [2, 3]:
+                raise Exception("PlaneBasedPackaging: Invalid 'domain_size': {}".format(domain_size))
+            self.packaging_model_part.ProcessInfo.SetValue(KM.DOMAIN_SIZE, domain_size)
+        elif self.packaging_input_type == "use_input_model_part":
+            self.packaging_model_part = self.model.GetModelPart(packaging_model_part_name)
+        else:
+            raise Exception("Other model part input options are not yet implemented.")
+
+        self.packaging_model_part.AddNodalSolutionStepVariable(KM.NORMAL)
+        self.packaging_model_part.AddNodalSolutionStepVariable(KSO.NORMALIZED_SURFACE_NORMAL)
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "packaging_model_part_name"       : "UNKNOWN_NAME",
+            "packaging_domain_size"           : 3,
+            "packaging_model_import_settings" : {
+                "input_type"     : "mdpa",
+                "input_filename" : "UNKNOWN_NAME"
+            }
+        }""")
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
+
+    def Initialize(self):
+        super().Initialize()
+
+        if self.packaging_input_type == "mdpa":
+            model_part_io = KM.ModelPartIO(self.response_settings["packaging_model_import_settings"]["input_filename"].GetString())
+            model_part_io.ReadModelPart(self.packaging_model_part)
+        elif self.packaging_input_type in ["vrml", "wrl"]:
+            model_part_io = WrlIO(self.response_settings["packaging_model_import_settings"]["input_filename"].GetString())
+            model_part_io.ReadModelPart(self.packaging_model_part)
+
+    def _CalculateDistances(self):
+        geometry_tools = KSO.GeometryUtilities(self.model_part)
+
+        self.signed_distances, self.directions = geometry_tools.ComputeDistancesToBoundingModelPart(self.packaging_model_part)
```

## KratosMultiphysics/ShapeOptimizationApplication/response_functions/airfoil_2d_responses.py

 * *Ordering differences only*

```diff
@@ -1,189 +1,189 @@
-import KratosMultiphysics
-from KratosMultiphysics import Parameters, Logger
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-from KratosMultiphysics.response_functions.response_function_interface import ResponseFunctionInterface
-import math
-
-def DotProduct(A,B):
-    result = 0
-    for i,j in zip(A,B):
-        result += i*j
-    return result
-
-class AngleOfAttackResponseFunction(ResponseFunctionInterface):
-    def __init__(self, response_id, response_settings, model):
-        self.model = model
-        if not response_settings.Has("trailing_edge_model_part")  or not response_settings.Has("leading_edge_model_part"):
-            raise(Exception("Please define a model part with the trailing edge node and a model part with the leading edge node"))
-
-        self.trailing_edge_model_part_name = response_settings["trailing_edge_model_part"].GetString()
-        self.leading_edge_sub_model_part_name = response_settings["leading_edge_model_part"].GetString()
-        self.reference_direction= response_settings["reference_direction"].GetVector() if response_settings.Has("reference_direction") else [1.0,0.0,0.0]
-
-    def Initialize(self):
-        self.te_model_part = self.model[self.trailing_edge_model_part_name]
-        self.le_model_part = self.model[self.leading_edge_sub_model_part_name]
-        self.main_model_part = self.te_model_part.GetRootModelPart()
-
-        for node in self.te_model_part.Nodes:
-            self.te_node = node
-            break
-        for node in self.le_model_part.Nodes:
-            self.le_node = node
-            break
-
-    def CalculateValue(self):
-        self.aoa = self._CalculateAOA(self.te_node.X,self.te_node.Y, self.le_node.X, self.le_node.Y)
-
-    def CalculateGradient(self):
-        x_diff = self.le_node.X - self.te_node.X
-        y_diff = self.le_node.Y - self.te_node.Y
-
-        cshape_sensitivity_0 = x_diff
-        cshape_sensitivity_1 = y_diff
-        cshape_sensitivity_2 = cshape_sensitivity_0**2 + cshape_sensitivity_1**2
-        cshape_sensitivity_3 = 1/cshape_sensitivity_2
-        cshape_sensitivity_4 = cshape_sensitivity_0*self.reference_direction[0] + cshape_sensitivity_1*self.reference_direction[1]
-        cshape_sensitivity_5 = cshape_sensitivity_3*cshape_sensitivity_4
-        cshape_sensitivity_6 = self.reference_direction[0]**2 + self.reference_direction[1]**2
-        cshape_sensitivity_7 = 1/(math.sqrt(cshape_sensitivity_2)*math.sqrt(cshape_sensitivity_6)*math.sqrt(-cshape_sensitivity_3*cshape_sensitivity_4**2/cshape_sensitivity_6 + 1))
-
-        self.te_x_gradient = -cshape_sensitivity_7*(-cshape_sensitivity_0*cshape_sensitivity_5 + self.reference_direction[0])
-        self.te_y_gradient = -cshape_sensitivity_7*(-cshape_sensitivity_1*cshape_sensitivity_5 + self.reference_direction[1])
-        self.le_x_gradient = cshape_sensitivity_7*(-cshape_sensitivity_0*cshape_sensitivity_5 + self.reference_direction[0])
-        self.le_y_gradient = cshape_sensitivity_7*(-cshape_sensitivity_1*cshape_sensitivity_5 + self.reference_direction[1])
-
-    def GetValue(self):
-        return self.aoa
-
-    def GetNodalGradient(self, variable):
-        zero_vector = KratosMultiphysics.Vector(3, 0.0)
-        gradient ={node.Id : zero_vector for node in self.main_model_part.Nodes}
-
-        shape_gradient = KratosMultiphysics.Vector(3, 0.0)
-        shape_gradient[0] = self.te_x_gradient
-        shape_gradient[1] = self.te_y_gradient
-        gradient[self.te_node.Id] = shape_gradient
-
-        shape_gradient = KratosMultiphysics.Vector(3, 0.0)
-        shape_gradient[0] = self.le_x_gradient
-        shape_gradient[1] = self.le_y_gradient
-        gradient[self.le_node.Id] = shape_gradient
-
-        return gradient
-
-    def _CalculateAOA(self, te_x, te_y, le_x, le_y):
-        ref_dir_norm = KratosMultiphysics.Vector(self.reference_direction).norm_2()
-        chord_vector = KratosMultiphysics.Vector(3, 0.0)
-        chord_vector[0] = te_x-le_x
-        chord_vector[1] = te_y-le_y
-        chord_norm = chord_vector.norm_2()
-        aoa = math.acos(DotProduct(self.reference_direction, chord_vector)/(ref_dir_norm*chord_norm))
-
-        return aoa
-
-class ChordLengthResponseFunction(ResponseFunctionInterface):
-
-
-    def __init__(self, response_id, response_settings, model):
-        self.model = model
-
-        if not response_settings.Has("trailing_edge_model_part")  or not response_settings.Has("leading_edge_model_part"):
-            raise(Exception("Please define a model part with the trailing edge node and a model part with the leading edge node"))
-
-        self.trailing_edge_model_part_name = response_settings["trailing_edge_model_part"].GetString()
-        self.leading_edge_sub_model_part_name = response_settings["leading_edge_model_part"].GetString()
-
-    def Initialize(self):
-        self.te_model_part = self.model[self.trailing_edge_model_part_name]
-        self.le_model_part = self.model[self.leading_edge_sub_model_part_name]
-        self.main_model_part = self.te_model_part.GetRootModelPart()
-
-        for node in self.te_model_part.Nodes:
-            self.te_node = node
-            break
-        for node in self.le_model_part.Nodes:
-            self.le_node = node
-            break
-
-    def _ComputeChord(self, te_x, te_y, le_x, le_y):
-        chord = math.sqrt((te_x-le_x)**2+(te_y-le_y)**2)
-
-        return chord
-
-    def CalculateValue(self):
-        self.chord = self._ComputeChord(self.te_node.X,self.te_node.Y, self.le_node.X,self.le_node.Y)
-
-    def CalculateGradient(self):
-        x_diff = self.le_node.X - self.te_node.X
-        y_diff = self.le_node.Y - self.te_node.Y
-
-        self.te_x_gradient = -x_diff/math.sqrt(x_diff**2 + y_diff**2)
-        self.te_y_gradient = -y_diff/math.sqrt(x_diff**2 + y_diff**2)
-        self.le_x_gradient = x_diff/math.sqrt(x_diff**2 + y_diff**2)
-        self.le_y_gradient = y_diff/math.sqrt(x_diff**2 + y_diff**2)
-
-    def GetValue(self):
-        return self.chord
-
-    def GetNodalGradient(self, variable):
-        zero_vector = KratosMultiphysics.Vector(3, 0.0)
-        gradient ={node.Id : zero_vector for node in self.main_model_part.Nodes}
-
-        shape_gradient = KratosMultiphysics.Vector(3, 0.0)
-        shape_gradient[0] = self.te_x_gradient
-        shape_gradient[1] = self.te_y_gradient
-        gradient[self.te_node.Id] = shape_gradient
-
-        shape_gradient = KratosMultiphysics.Vector(3, 0.0)
-        shape_gradient[0] = self.le_x_gradient
-        shape_gradient[1] = self.le_y_gradient
-        gradient[self.le_node.Id] = shape_gradient
-
-        return gradient
-
-
-
-class PerimeterResponseFunction(ResponseFunctionInterface):
-
-    def __init__(self, response_id, response_settings, model):
-        self.model = model
-        self.model_part_name = response_settings["model_part_name"].GetString()
-        self.step_size = response_settings["step_size"].GetDouble() if response_settings.Has("step_size") else 1e-6
-
-    def Initialize(self):
-        self.main_model_part = self.model[self.model_part_name]
-
-    def _ComputePerimeter(self,  model_part):
-        return KSO.GeometryUtilities(model_part).CalculateLength(model_part.Conditions)
-
-    def CalculateValue(self):
-        pass
-
-    def CalculateGradient(self):
-        pass
-
-    def GetValue(self):
-
-        return self._ComputePerimeter(self.main_model_part)
-
-    def GetNodalGradient(self, variable):
-        gradient = {}
-        initial_perimeter =  self._ComputePerimeter(self.main_model_part)
-
-        for node in self.main_model_part.Nodes:
-            shape_gradient = KratosMultiphysics.Vector(3, 0.0)
-
-            node.X += self.step_size
-            current_perimeter =  self._ComputePerimeter(self.main_model_part)
-            shape_gradient[0] = (current_perimeter-initial_perimeter)/self.step_size
-            node.X -= self.step_size
-
-            node.Y += self.step_size
-            current_perimeter =  self._ComputePerimeter(self.main_model_part)
-            shape_gradient[1] = (current_perimeter-initial_perimeter)/self.step_size
-            node.Y -= self.step_size
-
-            gradient[node.Id] = shape_gradient
-
+import KratosMultiphysics
+from KratosMultiphysics import Parameters, Logger
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+from KratosMultiphysics.response_functions.response_function_interface import ResponseFunctionInterface
+import math
+
+def DotProduct(A,B):
+    result = 0
+    for i,j in zip(A,B):
+        result += i*j
+    return result
+
+class AngleOfAttackResponseFunction(ResponseFunctionInterface):
+    def __init__(self, response_id, response_settings, model):
+        self.model = model
+        if not response_settings.Has("trailing_edge_model_part")  or not response_settings.Has("leading_edge_model_part"):
+            raise(Exception("Please define a model part with the trailing edge node and a model part with the leading edge node"))
+
+        self.trailing_edge_model_part_name = response_settings["trailing_edge_model_part"].GetString()
+        self.leading_edge_sub_model_part_name = response_settings["leading_edge_model_part"].GetString()
+        self.reference_direction= response_settings["reference_direction"].GetVector() if response_settings.Has("reference_direction") else [1.0,0.0,0.0]
+
+    def Initialize(self):
+        self.te_model_part = self.model[self.trailing_edge_model_part_name]
+        self.le_model_part = self.model[self.leading_edge_sub_model_part_name]
+        self.main_model_part = self.te_model_part.GetRootModelPart()
+
+        for node in self.te_model_part.Nodes:
+            self.te_node = node
+            break
+        for node in self.le_model_part.Nodes:
+            self.le_node = node
+            break
+
+    def CalculateValue(self):
+        self.aoa = self._CalculateAOA(self.te_node.X,self.te_node.Y, self.le_node.X, self.le_node.Y)
+
+    def CalculateGradient(self):
+        x_diff = self.le_node.X - self.te_node.X
+        y_diff = self.le_node.Y - self.te_node.Y
+
+        cshape_sensitivity_0 = x_diff
+        cshape_sensitivity_1 = y_diff
+        cshape_sensitivity_2 = cshape_sensitivity_0**2 + cshape_sensitivity_1**2
+        cshape_sensitivity_3 = 1/cshape_sensitivity_2
+        cshape_sensitivity_4 = cshape_sensitivity_0*self.reference_direction[0] + cshape_sensitivity_1*self.reference_direction[1]
+        cshape_sensitivity_5 = cshape_sensitivity_3*cshape_sensitivity_4
+        cshape_sensitivity_6 = self.reference_direction[0]**2 + self.reference_direction[1]**2
+        cshape_sensitivity_7 = 1/(math.sqrt(cshape_sensitivity_2)*math.sqrt(cshape_sensitivity_6)*math.sqrt(-cshape_sensitivity_3*cshape_sensitivity_4**2/cshape_sensitivity_6 + 1))
+
+        self.te_x_gradient = -cshape_sensitivity_7*(-cshape_sensitivity_0*cshape_sensitivity_5 + self.reference_direction[0])
+        self.te_y_gradient = -cshape_sensitivity_7*(-cshape_sensitivity_1*cshape_sensitivity_5 + self.reference_direction[1])
+        self.le_x_gradient = cshape_sensitivity_7*(-cshape_sensitivity_0*cshape_sensitivity_5 + self.reference_direction[0])
+        self.le_y_gradient = cshape_sensitivity_7*(-cshape_sensitivity_1*cshape_sensitivity_5 + self.reference_direction[1])
+
+    def GetValue(self):
+        return self.aoa
+
+    def GetNodalGradient(self, variable):
+        zero_vector = KratosMultiphysics.Vector(3, 0.0)
+        gradient ={node.Id : zero_vector for node in self.main_model_part.Nodes}
+
+        shape_gradient = KratosMultiphysics.Vector(3, 0.0)
+        shape_gradient[0] = self.te_x_gradient
+        shape_gradient[1] = self.te_y_gradient
+        gradient[self.te_node.Id] = shape_gradient
+
+        shape_gradient = KratosMultiphysics.Vector(3, 0.0)
+        shape_gradient[0] = self.le_x_gradient
+        shape_gradient[1] = self.le_y_gradient
+        gradient[self.le_node.Id] = shape_gradient
+
+        return gradient
+
+    def _CalculateAOA(self, te_x, te_y, le_x, le_y):
+        ref_dir_norm = KratosMultiphysics.Vector(self.reference_direction).norm_2()
+        chord_vector = KratosMultiphysics.Vector(3, 0.0)
+        chord_vector[0] = te_x-le_x
+        chord_vector[1] = te_y-le_y
+        chord_norm = chord_vector.norm_2()
+        aoa = math.acos(DotProduct(self.reference_direction, chord_vector)/(ref_dir_norm*chord_norm))
+
+        return aoa
+
+class ChordLengthResponseFunction(ResponseFunctionInterface):
+
+
+    def __init__(self, response_id, response_settings, model):
+        self.model = model
+
+        if not response_settings.Has("trailing_edge_model_part")  or not response_settings.Has("leading_edge_model_part"):
+            raise(Exception("Please define a model part with the trailing edge node and a model part with the leading edge node"))
+
+        self.trailing_edge_model_part_name = response_settings["trailing_edge_model_part"].GetString()
+        self.leading_edge_sub_model_part_name = response_settings["leading_edge_model_part"].GetString()
+
+    def Initialize(self):
+        self.te_model_part = self.model[self.trailing_edge_model_part_name]
+        self.le_model_part = self.model[self.leading_edge_sub_model_part_name]
+        self.main_model_part = self.te_model_part.GetRootModelPart()
+
+        for node in self.te_model_part.Nodes:
+            self.te_node = node
+            break
+        for node in self.le_model_part.Nodes:
+            self.le_node = node
+            break
+
+    def _ComputeChord(self, te_x, te_y, le_x, le_y):
+        chord = math.sqrt((te_x-le_x)**2+(te_y-le_y)**2)
+
+        return chord
+
+    def CalculateValue(self):
+        self.chord = self._ComputeChord(self.te_node.X,self.te_node.Y, self.le_node.X,self.le_node.Y)
+
+    def CalculateGradient(self):
+        x_diff = self.le_node.X - self.te_node.X
+        y_diff = self.le_node.Y - self.te_node.Y
+
+        self.te_x_gradient = -x_diff/math.sqrt(x_diff**2 + y_diff**2)
+        self.te_y_gradient = -y_diff/math.sqrt(x_diff**2 + y_diff**2)
+        self.le_x_gradient = x_diff/math.sqrt(x_diff**2 + y_diff**2)
+        self.le_y_gradient = y_diff/math.sqrt(x_diff**2 + y_diff**2)
+
+    def GetValue(self):
+        return self.chord
+
+    def GetNodalGradient(self, variable):
+        zero_vector = KratosMultiphysics.Vector(3, 0.0)
+        gradient ={node.Id : zero_vector for node in self.main_model_part.Nodes}
+
+        shape_gradient = KratosMultiphysics.Vector(3, 0.0)
+        shape_gradient[0] = self.te_x_gradient
+        shape_gradient[1] = self.te_y_gradient
+        gradient[self.te_node.Id] = shape_gradient
+
+        shape_gradient = KratosMultiphysics.Vector(3, 0.0)
+        shape_gradient[0] = self.le_x_gradient
+        shape_gradient[1] = self.le_y_gradient
+        gradient[self.le_node.Id] = shape_gradient
+
+        return gradient
+
+
+
+class PerimeterResponseFunction(ResponseFunctionInterface):
+
+    def __init__(self, response_id, response_settings, model):
+        self.model = model
+        self.model_part_name = response_settings["model_part_name"].GetString()
+        self.step_size = response_settings["step_size"].GetDouble() if response_settings.Has("step_size") else 1e-6
+
+    def Initialize(self):
+        self.main_model_part = self.model[self.model_part_name]
+
+    def _ComputePerimeter(self,  model_part):
+        return KSO.GeometryUtilities(model_part).CalculateLength(model_part.Conditions)
+
+    def CalculateValue(self):
+        pass
+
+    def CalculateGradient(self):
+        pass
+
+    def GetValue(self):
+
+        return self._ComputePerimeter(self.main_model_part)
+
+    def GetNodalGradient(self, variable):
+        gradient = {}
+        initial_perimeter =  self._ComputePerimeter(self.main_model_part)
+
+        for node in self.main_model_part.Nodes:
+            shape_gradient = KratosMultiphysics.Vector(3, 0.0)
+
+            node.X += self.step_size
+            current_perimeter =  self._ComputePerimeter(self.main_model_part)
+            shape_gradient[0] = (current_perimeter-initial_perimeter)/self.step_size
+            node.X -= self.step_size
+
+            node.Y += self.step_size
+            current_perimeter =  self._ComputePerimeter(self.main_model_part)
+            shape_gradient[1] = (current_perimeter-initial_perimeter)/self.step_size
+            node.Y -= self.step_size
+
+            gradient[node.Id] = shape_gradient
+
         return gradient
```

## KratosMultiphysics/ShapeOptimizationApplication/response_functions/packaging_response_base.py

 * *Ordering differences only*

```diff
@@ -1,156 +1,156 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-import time as timer
-import KratosMultiphysics as KM
-from KratosMultiphysics import Logger
-from KratosMultiphysics.response_functions.response_function_interface import ResponseFunctionInterface
-
-class PackagingResponseBase(ResponseFunctionInterface):
-    """
-    A base class for packaging response functions that agglomerate the nodal violations
-    into a single response function.
-    The agglomeration happens by summing up the square of each nodal violation.
-    Nodes that are feasible do NOT contribute to the response value/gradient.
-    This is why a prediction of the violation using the gradients is not possible,
-    only correction of violations (e.g. from the last step) will happen.
-
-    Derived classes need to implement the calculation of the nodal violations
-
-    Important settings:
-    feasible_in_normal_direction : boolean flag that indicates if the normal of bounding instance
-        points to the feasible side. True by default
-    """
-
-    def __init__(self, identifier, response_settings, model):
-        self.identifier = identifier
-
-        response_settings.ValidateAndAssignDefaults(self.GetDefaultParameters())
-
-        self.response_settings = response_settings
-        self.model = model
-
-        self._model_part_name = response_settings["model_part_name"].GetString()
-        input_type = response_settings["model_import_settings"]["input_type"].GetString()
-        if input_type == "mdpa":
-            self.model_part = self.model.CreateModelPart(self._model_part_name)
-            domain_size = response_settings["domain_size"].GetInt()
-            if domain_size not in [2, 3]:
-                raise Exception("PackagingResponseBase: Invalid 'domain_size': {}".format(domain_size))
-            self.model_part.ProcessInfo.SetValue(KM.DOMAIN_SIZE, domain_size)
-        elif input_type == "use_input_model_part":
-            self.model_part = None  # will be retrieved in Initialize()
-        else:
-            raise Exception("PackagingResponseBase: '{}' model part input type not implemented.".format(input_type))
-
-        self.signed_distances = None
-        self.directions = None
-
-        self.value = None
-
-        self.gradient = {}
-
-        self.feasible_in_normal_direction = self.response_settings["feasible_in_normal_direction"].GetBool()
-        self.exponent = 2
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "response_type"         : "UNKNOWN_TYPE",
-            "model_part_name"       : "UNKNOWN_NAME",
-            "domain_size"           : 3,
-            "model_import_settings" : {
-                "input_type"        : "use_input_model_part",
-                "input_filename"    : "UNKNOWN_NAME"
-            },
-            "feasible_in_normal_direction" : true
-        }""")
-        return this_defaults
-
-    def Initialize(self):
-        if self.response_settings["model_import_settings"]["input_type"].GetString() == "mdpa":
-            file_name = self.response_settings["model_import_settings"]["input_filename"].GetString()
-            model_part_io = KM.ModelPartIO(file_name)
-            model_part_io.ReadModelPart(self.model_part)
-        else:
-            self.model_part = self.model.GetModelPart(self._model_part_name)
-
-    def InitializeSolutionStep(self):
-        self.value = None
-        self.signed_distances = None
-        self.directions = None
-        self.gradient = {}
-
-    def CalculateValue(self):
-        Logger.PrintInfo("\n> Starting primal analysis for response", self.identifier)
-
-        startTime = timer.time()
-
-        if not self.directions or not self.signed_distances:
-            self._CalculateDistances()
-
-        value = 0.0
-        for i in range(len(self.signed_distances)):
-            value += self._CalculateNodalValue(self.signed_distances[i])
-
-        self.value = value
-
-        Logger.PrintInfo("> Time needed for calculating the response value = ", round(timer.time() - startTime,2), "s")
-
-    def CalculateGradient(self):
-        Logger.PrintInfo("\n> Starting gradient calculation for response", self.identifier)
-
-        startTime = timer.time()
-
-        if not self.directions or not self.signed_distances:
-            self._CalculateDistances()
-
-        for i, node in enumerate(self.model_part.Nodes):
-            gradient = self._CalculateNodalGradient(self.signed_distances[i], self.directions[i*3:i*3+3])
-            self.gradient[node.Id] = gradient
-
-        Logger.PrintInfo("> Time needed for calculating gradients = ", round(timer.time() - startTime,2), "s")
-
-    def GetValue(self):
-        return self.value
-
-    def GetNodalGradient(self, variable):
-        if not self.gradient:
-            raise RuntimeError("Gradient was not calculated")
-        if variable != KM.SHAPE_SENSITIVITY:
-            raise RuntimeError("GetNodalGradient: No gradient for {}!".format(variable.Name))
-        return self.gradient
-
-    def _CalculateDistances(self):
-        raise NotImplementedError("_CalculateDistances needs to be implemented by the derived class!")
-
-    def _CalculateNodalValue(self, signed_distance):
-        if not self._HasContribution(signed_distance):
-            return 0.0
-        return pow(signed_distance, self.exponent)
-
-    def _CalculateNodalGradient(self, signed_distance, direction):
-        if not self._HasContribution(signed_distance):
-            return [0.0, 0.0, 0.0]
-
-        factor = self.exponent * pow(signed_distance, self.exponent-1)
-        gradient = [
-            direction[0] * factor,
-            direction[1] * factor,
-            direction[2] * factor
-        ]
-        return gradient
-
-    def _HasContribution(self, signed_distance):
-        if not self.feasible_in_normal_direction and signed_distance > 0:
-            return True
-        elif self.feasible_in_normal_direction and signed_distance < 0:
-            return True
-        return False
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+import time as timer
+import KratosMultiphysics as KM
+from KratosMultiphysics import Logger
+from KratosMultiphysics.response_functions.response_function_interface import ResponseFunctionInterface
+
+class PackagingResponseBase(ResponseFunctionInterface):
+    """
+    A base class for packaging response functions that agglomerate the nodal violations
+    into a single response function.
+    The agglomeration happens by summing up the square of each nodal violation.
+    Nodes that are feasible do NOT contribute to the response value/gradient.
+    This is why a prediction of the violation using the gradients is not possible,
+    only correction of violations (e.g. from the last step) will happen.
+
+    Derived classes need to implement the calculation of the nodal violations
+
+    Important settings:
+    feasible_in_normal_direction : boolean flag that indicates if the normal of bounding instance
+        points to the feasible side. True by default
+    """
+
+    def __init__(self, identifier, response_settings, model):
+        self.identifier = identifier
+
+        response_settings.ValidateAndAssignDefaults(self.GetDefaultParameters())
+
+        self.response_settings = response_settings
+        self.model = model
+
+        self._model_part_name = response_settings["model_part_name"].GetString()
+        input_type = response_settings["model_import_settings"]["input_type"].GetString()
+        if input_type == "mdpa":
+            self.model_part = self.model.CreateModelPart(self._model_part_name)
+            domain_size = response_settings["domain_size"].GetInt()
+            if domain_size not in [2, 3]:
+                raise Exception("PackagingResponseBase: Invalid 'domain_size': {}".format(domain_size))
+            self.model_part.ProcessInfo.SetValue(KM.DOMAIN_SIZE, domain_size)
+        elif input_type == "use_input_model_part":
+            self.model_part = None  # will be retrieved in Initialize()
+        else:
+            raise Exception("PackagingResponseBase: '{}' model part input type not implemented.".format(input_type))
+
+        self.signed_distances = None
+        self.directions = None
+
+        self.value = None
+
+        self.gradient = {}
+
+        self.feasible_in_normal_direction = self.response_settings["feasible_in_normal_direction"].GetBool()
+        self.exponent = 2
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "response_type"         : "UNKNOWN_TYPE",
+            "model_part_name"       : "UNKNOWN_NAME",
+            "domain_size"           : 3,
+            "model_import_settings" : {
+                "input_type"        : "use_input_model_part",
+                "input_filename"    : "UNKNOWN_NAME"
+            },
+            "feasible_in_normal_direction" : true
+        }""")
+        return this_defaults
+
+    def Initialize(self):
+        if self.response_settings["model_import_settings"]["input_type"].GetString() == "mdpa":
+            file_name = self.response_settings["model_import_settings"]["input_filename"].GetString()
+            model_part_io = KM.ModelPartIO(file_name)
+            model_part_io.ReadModelPart(self.model_part)
+        else:
+            self.model_part = self.model.GetModelPart(self._model_part_name)
+
+    def InitializeSolutionStep(self):
+        self.value = None
+        self.signed_distances = None
+        self.directions = None
+        self.gradient = {}
+
+    def CalculateValue(self):
+        Logger.PrintInfo("\n> Starting primal analysis for response", self.identifier)
+
+        startTime = timer.time()
+
+        if not self.directions or not self.signed_distances:
+            self._CalculateDistances()
+
+        value = 0.0
+        for i in range(len(self.signed_distances)):
+            value += self._CalculateNodalValue(self.signed_distances[i])
+
+        self.value = value
+
+        Logger.PrintInfo("> Time needed for calculating the response value = ", round(timer.time() - startTime,2), "s")
+
+    def CalculateGradient(self):
+        Logger.PrintInfo("\n> Starting gradient calculation for response", self.identifier)
+
+        startTime = timer.time()
+
+        if not self.directions or not self.signed_distances:
+            self._CalculateDistances()
+
+        for i, node in enumerate(self.model_part.Nodes):
+            gradient = self._CalculateNodalGradient(self.signed_distances[i], self.directions[i*3:i*3+3])
+            self.gradient[node.Id] = gradient
+
+        Logger.PrintInfo("> Time needed for calculating gradients = ", round(timer.time() - startTime,2), "s")
+
+    def GetValue(self):
+        return self.value
+
+    def GetNodalGradient(self, variable):
+        if not self.gradient:
+            raise RuntimeError("Gradient was not calculated")
+        if variable != KM.SHAPE_SENSITIVITY:
+            raise RuntimeError("GetNodalGradient: No gradient for {}!".format(variable.Name))
+        return self.gradient
+
+    def _CalculateDistances(self):
+        raise NotImplementedError("_CalculateDistances needs to be implemented by the derived class!")
+
+    def _CalculateNodalValue(self, signed_distance):
+        if not self._HasContribution(signed_distance):
+            return 0.0
+        return pow(signed_distance, self.exponent)
+
+    def _CalculateNodalGradient(self, signed_distance, direction):
+        if not self._HasContribution(signed_distance):
+            return [0.0, 0.0, 0.0]
+
+        factor = self.exponent * pow(signed_distance, self.exponent-1)
+        gradient = [
+            direction[0] * factor,
+            direction[1] * factor,
+            direction[2] * factor
+        ]
+        return gradient
+
+    def _HasContribution(self, signed_distance):
+        if not self.feasible_in_normal_direction and signed_distance > 0:
+            return True
+        elif self.feasible_in_normal_direction and signed_distance < 0:
+            return True
+        return False
```

## KratosMultiphysics/ShapeOptimizationApplication/response_functions/total_volume.py

 * *Ordering differences only*

```diff
@@ -1,56 +1,56 @@
-"""
-This module contains an interface to the total volume response function
-"""
-import time as timer
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-from KratosMultiphysics.response_functions.response_function_interface import ResponseFunctionInterface
-
-class TotalVolume(ResponseFunctionInterface):
-    def __init__(self, identifier, response_settings, model):
-        self.identifier = identifier
-        self.response_settings = response_settings
-
-        default_parameters = Kratos.Parameters("""
-        {
-            "response_type"            : "total_volume",
-            "model_part_name"          : "PLEASE_SPECIFY_MODEL_PART_NAME"
-        }
-        """)
-
-        self.response_settings.ValidateAndAssignDefaults(default_parameters)
-        self.model = model
-
-    def Initialize(self):
-        self.model_part = self.model[self.response_settings["model_part_name"].GetString()]
-
-    def CalculateValue(self):
-        start_time = timer.time()
-
-        self.value = KSO.GeometryUtilities(self.model_part).ComputeVolume()
-
-        Kratos.Logger.PrintInfo(self._GetLabel(), "Time needed for calculating the response value = ",round(timer.time() - start_time,2),"s")
-
-    def CalculateGradient(self):
-        start_time = timer.time()
-
-        KSO.GeometryUtilities(self.model_part).ComputeVolumeShapeDerivatives(Kratos.SHAPE_SENSITIVITY)
-        self.gradient = {}
-        for node in self.model_part.Nodes:
-            self.gradient[node.Id] = node.GetSolutionStepValue(Kratos.SHAPE_SENSITIVITY)
-
-        Kratos.Logger.PrintInfo(self._GetLabel(), "Time needed for calculating the gradient = ",round(timer.time() - start_time,2),"s")
-
-    def GetValue(self):
-        return self.value
-
-    def GetNodalGradient(self, variable):
-        if variable != Kratos.SHAPE_SENSITIVITY:
-            raise RuntimeError("GetNodalGradient: No gradient for {}!".format(variable.Name))
-        return self.gradient
-
-    @staticmethod
-    def _GetLabel():
-        return "TotalVolume"
-
-
+"""
+This module contains an interface to the total volume response function
+"""
+import time as timer
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+from KratosMultiphysics.response_functions.response_function_interface import ResponseFunctionInterface
+
+class TotalVolume(ResponseFunctionInterface):
+    def __init__(self, identifier, response_settings, model):
+        self.identifier = identifier
+        self.response_settings = response_settings
+
+        default_parameters = Kratos.Parameters("""
+        {
+            "response_type"            : "total_volume",
+            "model_part_name"          : "PLEASE_SPECIFY_MODEL_PART_NAME"
+        }
+        """)
+
+        self.response_settings.ValidateAndAssignDefaults(default_parameters)
+        self.model = model
+
+    def Initialize(self):
+        self.model_part = self.model[self.response_settings["model_part_name"].GetString()]
+
+    def CalculateValue(self):
+        start_time = timer.time()
+
+        self.value = KSO.GeometryUtilities(self.model_part).ComputeVolume()
+
+        Kratos.Logger.PrintInfo(self._GetLabel(), "Time needed for calculating the response value = ",round(timer.time() - start_time,2),"s")
+
+    def CalculateGradient(self):
+        start_time = timer.time()
+
+        KSO.GeometryUtilities(self.model_part).ComputeVolumeShapeDerivatives(Kratos.SHAPE_SENSITIVITY)
+        self.gradient = {}
+        for node in self.model_part.Nodes:
+            self.gradient[node.Id] = node.GetSolutionStepValue(Kratos.SHAPE_SENSITIVITY)
+
+        Kratos.Logger.PrintInfo(self._GetLabel(), "Time needed for calculating the gradient = ",round(timer.time() - start_time,2),"s")
+
+    def GetValue(self):
+        return self.value
+
+    def GetNodalGradient(self, variable):
+        if variable != Kratos.SHAPE_SENSITIVITY:
+            raise RuntimeError("GetNodalGradient: No gradient for {}!".format(variable.Name))
+        return self.gradient
+
+    @staticmethod
+    def _GetLabel():
+        return "TotalVolume"
+
+
```

## KratosMultiphysics/ShapeOptimizationApplication/response_functions/surface_normal_shape_change.py

 * *Ordering differences only*

```diff
@@ -1,125 +1,125 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-import time as timer
-import KratosMultiphysics as KM
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-from KratosMultiphysics import Logger
-from KratosMultiphysics.response_functions.response_function_interface import ResponseFunctionInterface
-
-class SurfaceNormalShapeChange(ResponseFunctionInterface):
-    """
-    This simple geometric response function calculates the sum of all shape updates in
-    surface normal direction. Shape update in surface normal direction is considered positive,
-    in the opposite direction negative.
-
-    Note that the direction of the surface normals changes in every step,
-    this is why the response value is not a meaningful measure but only an indication on how much the shape changed.
-
-    Important settings:
-    flip_normal_direction : boolean flag for changing on which side of the surface the update is considered positive.
-    """
-
-    def __init__(self, identifier, response_settings, model):
-        self.identifier = identifier
-
-        response_settings.ValidateAndAssignDefaults(self.GetDefaultParameters())
-
-        self.response_settings = response_settings
-        self.model = model
-
-        self._model_part_name = response_settings["model_part_name"].GetString()
-        input_type = response_settings["model_import_settings"]["input_type"].GetString()
-        if input_type == "mdpa":
-            self.model_part = self.model.CreateModelPart(self._model_part_name)
-            domain_size = response_settings["domain_size"].GetInt()
-            if domain_size not in [2, 3]:
-                raise Exception("SurfaceNormalShapeChange: Invalid 'domain_size': {}".format(domain_size))
-            self.model_part.ProcessInfo.SetValue(KM.DOMAIN_SIZE, domain_size)
-        elif input_type == "use_input_model_part":
-            self.model_part = None  # will be retrieved in Initialize()
-        else:
-            raise Exception("SurfaceNormalShapeChange: '{}' model part input type not implemented.".format(input_type))
-
-        self.signed_distances = None
-        self.directions = None
-
-        self.previous_value = 0.0
-        self.value = 0.0
-
-        self.gradient = {}
-
-        self.flip_normal_direction = self.response_settings["flip_normal_direction"].GetBool()
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "response_type"         : "surface_normal_shape_change",
-            "model_part_name"       : "UNKNOWN_NAME",
-            "domain_size"           : 3,
-            "model_import_settings" : {
-                "input_type"        : "use_input_model_part",
-                "input_filename"    : "UNKNOWN_NAME"
-            },
-            "flip_normal_direction" : false
-        }""")
-        return this_defaults
-
-    def Initialize(self):
-        if self.response_settings["model_import_settings"]["input_type"].GetString() == "mdpa":
-            file_name = self.response_settings["model_import_settings"]["input_filename"].GetString()
-            model_part_io = KM.ModelPartIO(file_name)
-            model_part_io.ReadModelPart(self.model_part)
-        else:
-            self.model_part = self.model.GetModelPart(self._model_part_name)
-
-    def InitializeSolutionStep(self):
-        self.previous_value = self.value
-        self.value = None
-        self.gradient = {}
-        KSO.GeometryUtilities(self.model_part).ComputeUnitSurfaceNormals()
-
-    def CalculateValue(self):
-        Logger.PrintInfo("\n> Starting primal analysis for response", self.identifier)
-
-        startTime = timer.time()
-
-        value = 0.0
-        for node in self.model_part.Nodes:
-            shape_update = node.GetSolutionStepValue(KSO.SHAPE_UPDATE)
-            normalized_normal = node.GetSolutionStepValue(KSO.NORMALIZED_SURFACE_NORMAL)
-            value += shape_update[0] * normalized_normal[0]
-            value += shape_update[1] * normalized_normal[1]
-            value += shape_update[2] * normalized_normal[2]
-
-        self.value = value + self.previous_value
-
-        Logger.PrintInfo("> Time needed for calculating the response value = ", round(timer.time() - startTime,2), "s")
-
-    def CalculateGradient(self):
-        Logger.PrintInfo("\n> Starting gradient calculation for response", self.identifier)
-
-        startTime = timer.time()
-
-        for node in self.model_part.Nodes:
-            normalized_normal = node.GetSolutionStepValue(KSO.NORMALIZED_SURFACE_NORMAL)
-            self.gradient[node.Id] = normalized_normal
-
-        Logger.PrintInfo("> Time needed for calculating gradients = ", round(timer.time() - startTime,2), "s")
-
-    def GetValue(self):
-        return self.value
-
-    def GetNodalGradient(self, variable):
-        if not self.gradient:
-            raise RuntimeError("Gradient was not calculated")
-        if variable != KM.SHAPE_SENSITIVITY:
-            raise RuntimeError("GetNodalGradient: No gradient for {}!".format(variable.Name))
-        return self.gradient
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+import time as timer
+import KratosMultiphysics as KM
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+from KratosMultiphysics import Logger
+from KratosMultiphysics.response_functions.response_function_interface import ResponseFunctionInterface
+
+class SurfaceNormalShapeChange(ResponseFunctionInterface):
+    """
+    This simple geometric response function calculates the sum of all shape updates in
+    surface normal direction. Shape update in surface normal direction is considered positive,
+    in the opposite direction negative.
+
+    Note that the direction of the surface normals changes in every step,
+    this is why the response value is not a meaningful measure but only an indication on how much the shape changed.
+
+    Important settings:
+    flip_normal_direction : boolean flag for changing on which side of the surface the update is considered positive.
+    """
+
+    def __init__(self, identifier, response_settings, model):
+        self.identifier = identifier
+
+        response_settings.ValidateAndAssignDefaults(self.GetDefaultParameters())
+
+        self.response_settings = response_settings
+        self.model = model
+
+        self._model_part_name = response_settings["model_part_name"].GetString()
+        input_type = response_settings["model_import_settings"]["input_type"].GetString()
+        if input_type == "mdpa":
+            self.model_part = self.model.CreateModelPart(self._model_part_name)
+            domain_size = response_settings["domain_size"].GetInt()
+            if domain_size not in [2, 3]:
+                raise Exception("SurfaceNormalShapeChange: Invalid 'domain_size': {}".format(domain_size))
+            self.model_part.ProcessInfo.SetValue(KM.DOMAIN_SIZE, domain_size)
+        elif input_type == "use_input_model_part":
+            self.model_part = None  # will be retrieved in Initialize()
+        else:
+            raise Exception("SurfaceNormalShapeChange: '{}' model part input type not implemented.".format(input_type))
+
+        self.signed_distances = None
+        self.directions = None
+
+        self.previous_value = 0.0
+        self.value = 0.0
+
+        self.gradient = {}
+
+        self.flip_normal_direction = self.response_settings["flip_normal_direction"].GetBool()
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "response_type"         : "surface_normal_shape_change",
+            "model_part_name"       : "UNKNOWN_NAME",
+            "domain_size"           : 3,
+            "model_import_settings" : {
+                "input_type"        : "use_input_model_part",
+                "input_filename"    : "UNKNOWN_NAME"
+            },
+            "flip_normal_direction" : false
+        }""")
+        return this_defaults
+
+    def Initialize(self):
+        if self.response_settings["model_import_settings"]["input_type"].GetString() == "mdpa":
+            file_name = self.response_settings["model_import_settings"]["input_filename"].GetString()
+            model_part_io = KM.ModelPartIO(file_name)
+            model_part_io.ReadModelPart(self.model_part)
+        else:
+            self.model_part = self.model.GetModelPart(self._model_part_name)
+
+    def InitializeSolutionStep(self):
+        self.previous_value = self.value
+        self.value = None
+        self.gradient = {}
+        KSO.GeometryUtilities(self.model_part).ComputeUnitSurfaceNormals()
+
+    def CalculateValue(self):
+        Logger.PrintInfo("\n> Starting primal analysis for response", self.identifier)
+
+        startTime = timer.time()
+
+        value = 0.0
+        for node in self.model_part.Nodes:
+            shape_update = node.GetSolutionStepValue(KSO.SHAPE_UPDATE)
+            normalized_normal = node.GetSolutionStepValue(KSO.NORMALIZED_SURFACE_NORMAL)
+            value += shape_update[0] * normalized_normal[0]
+            value += shape_update[1] * normalized_normal[1]
+            value += shape_update[2] * normalized_normal[2]
+
+        self.value = value + self.previous_value
+
+        Logger.PrintInfo("> Time needed for calculating the response value = ", round(timer.time() - startTime,2), "s")
+
+    def CalculateGradient(self):
+        Logger.PrintInfo("\n> Starting gradient calculation for response", self.identifier)
+
+        startTime = timer.time()
+
+        for node in self.model_part.Nodes:
+            normalized_normal = node.GetSolutionStepValue(KSO.NORMALIZED_SURFACE_NORMAL)
+            self.gradient[node.Id] = normalized_normal
+
+        Logger.PrintInfo("> Time needed for calculating gradients = ", round(timer.time() - startTime,2), "s")
+
+    def GetValue(self):
+        return self.value
+
+    def GetNodalGradient(self, variable):
+        if not self.gradient:
+            raise RuntimeError("Gradient was not calculated")
+        if variable != KM.SHAPE_SENSITIVITY:
+            raise RuntimeError("GetNodalGradient: No gradient for {}!".format(variable.Name))
+        return self.gradient
```

## KratosMultiphysics/ShapeOptimizationApplication/response_functions/response_function_factory.py

 * *Ordering differences only*

```diff
@@ -1,40 +1,40 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-from . import plane_based_packaging
-from . import mesh_based_packaging
-from . import surface_normal_shape_change
-from . import face_angle
-from . import airfoil_2d_responses
-from . import total_volume
-
-def CreateResponseFunction(response_id, response_settings, model):
-    response_type = response_settings["response_type"].GetString()
-
-    if response_type == "plane_based_packaging":
-        return plane_based_packaging.PlaneBasedPackaging(response_id, response_settings, model)
-    elif response_type == "mesh_based_packaging":
-        return mesh_based_packaging.MeshBasedPackaging(response_id, response_settings, model)
-    elif response_type == "surface_normal_shape_change":
-        return surface_normal_shape_change.SurfaceNormalShapeChange(response_id, response_settings, model)
-    elif response_type == "face_angle":
-        return face_angle.FaceAngleResponseFunction(response_id, response_settings, model)
-    elif response_type == "airfoil_angle_of_attack":
-        return airfoil_2d_responses.AngleOfAttackResponseFunction(response_id, response_settings, model)
-    elif response_type == "airfoil_chord_length":
-        return airfoil_2d_responses.ChordLengthResponseFunction(response_id, response_settings, model)
-    elif response_type == "airfoil_perimeter":
-        return airfoil_2d_responses.PerimeterResponseFunction(response_id, response_settings, model)
-    elif response_type == "total_volume":
-        return total_volume.TotalVolume(response_id, response_settings, model)
-    else:
-        raise NameError("The type of the following response function is not specified: "+ response_id +
-                        ".\nAvailable types are: 'plane_based_packaging', 'mesh_based_packaging', 'face_angle', " +
-                        "'airfoil_angle_of_attack', 'airfoil_chord_length', 'airfoil_perimeter.")
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+from . import plane_based_packaging
+from . import mesh_based_packaging
+from . import surface_normal_shape_change
+from . import face_angle
+from . import airfoil_2d_responses
+from . import total_volume
+
+def CreateResponseFunction(response_id, response_settings, model):
+    response_type = response_settings["response_type"].GetString()
+
+    if response_type == "plane_based_packaging":
+        return plane_based_packaging.PlaneBasedPackaging(response_id, response_settings, model)
+    elif response_type == "mesh_based_packaging":
+        return mesh_based_packaging.MeshBasedPackaging(response_id, response_settings, model)
+    elif response_type == "surface_normal_shape_change":
+        return surface_normal_shape_change.SurfaceNormalShapeChange(response_id, response_settings, model)
+    elif response_type == "face_angle":
+        return face_angle.FaceAngleResponseFunction(response_id, response_settings, model)
+    elif response_type == "airfoil_angle_of_attack":
+        return airfoil_2d_responses.AngleOfAttackResponseFunction(response_id, response_settings, model)
+    elif response_type == "airfoil_chord_length":
+        return airfoil_2d_responses.ChordLengthResponseFunction(response_id, response_settings, model)
+    elif response_type == "airfoil_perimeter":
+        return airfoil_2d_responses.PerimeterResponseFunction(response_id, response_settings, model)
+    elif response_type == "total_volume":
+        return total_volume.TotalVolume(response_id, response_settings, model)
+    else:
+        raise NameError("The type of the following response function is not specified: "+ response_id +
+                        ".\nAvailable types are: 'plane_based_packaging', 'mesh_based_packaging', 'face_angle', " +
+                        "'airfoil_angle_of_attack', 'airfoil_chord_length', 'airfoil_perimeter.")
```

## KratosMultiphysics/ShapeOptimizationApplication/response_functions/face_angle.py

 * *Ordering differences only*

```diff
@@ -1,140 +1,140 @@
-# importing the Kratos Library
-import KratosMultiphysics as KM
-from KratosMultiphysics import Parameters, Logger
-from KratosMultiphysics.response_functions.response_function_interface import ResponseFunctionInterface
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-
-import time as timer
-
-
-def _AddConditionsFromParent(parent, child):
-    node_ids = set([node.Id for node in child.Nodes])
-    conditions = []
-    for condition in parent.Conditions:
-        all_nodes_found = True
-        for node in condition.GetNodes():
-            if node.Id not in node_ids:
-                all_nodes_found = False
-                break
-        if all_nodes_found:
-            conditions.append(condition.Id)
-    child.AddConditions(conditions)
-
-# ==============================================================================
-class FaceAngleResponseFunction(ResponseFunctionInterface):
-    """
-    Face angle response function.
-    It aggregates the deviation of the face angles of all surface conditions using sqrt(sum(g_i)),
-    where g_i are the condition wise violations - feasible conditions do not contribute
-
-    It requires surface conditions in the modelpart, since they are used to compute the face orientation.
-    Ideally the design surface model part is used.
-
-    Attributes
-    ----------
-    model_part : Model part object of the response function
-    response_function_utility: Cpp utilities object doing the actual computation of response value and gradient.
-    """
-
-    def __init__(self, identifier, response_settings, model):
-        self.identifier = identifier
-
-        response_settings.ValidateAndAssignDefaults(self.GetDefaultParameters())
-
-        self.response_settings = response_settings
-        self.model = model
-        self.model_part_needs_to_be_imported = False
-
-        self.value = None
-
-        self._model_part_name = response_settings["model_part_name"].GetString()
-        input_type = response_settings["model_import_settings"]["input_type"].GetString()
-        if input_type == "mdpa":
-            self.model_part = self.model.CreateModelPart(self._model_part_name, 2)
-            domain_size = response_settings["domain_size"].GetInt()
-            if domain_size not in [3]:
-                raise Exception("FaceAngleResponseFunction: Invalid 'domain_size': {}".format(domain_size))
-            self.model_part.ProcessInfo.SetValue(KM.DOMAIN_SIZE, domain_size)
-            self.model_part_needs_to_be_imported = True
-        elif input_type == "use_input_model_part":
-            self.model_part = None  # will be retrieved in Initialize()
-        else:
-            raise Exception("Other model part input options are not yet implemented.")
-
-        self.response_function_utility = None  # will be created in Initialize()
-
-        self.model.GetModelPart(self._model_part_name.split(".")[0]).AddNodalSolutionStepVariable(KM.SHAPE_SENSITIVITY)
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "response_type"         : "UNKNOWN_TYPE",
-            "model_part_name"       : "UNKNOWN_NAME",
-            "only"                  : "",
-            "domain_size"           : 3,
-            "model_import_settings" : {
-                "input_type"        : "use_input_model_part",
-                "input_filename"    : "UNKNOWN_NAME"
-            },
-            "main_direction": [0.0, 0.0, 1.0],
-            "min_angle": 0.0,
-            "gradient_mode": "finite_differencing",
-            "step_size": 1e-6,
-            "consider_only_initially_feasible": false
-        }""")
-        return this_defaults
-
-    def Initialize(self):
-        if self.response_settings["model_import_settings"]["input_type"].GetString() == "mdpa":
-            file_name = self.response_settings["model_import_settings"]["input_filename"].GetString()
-            model_part_io = KM.ModelPartIO(file_name)
-            model_part_io.ReadModelPart(self.model_part)
-        else:
-            self.model_part = self.model.GetModelPart(self._model_part_name)
-
-        only = self.response_settings["only"].GetString()
-        if only != "":
-            only_part = self.model.GetModelPart(only)
-            if only_part.NumberOfConditions() == 0:
-                _AddConditionsFromParent(self.model_part, only_part)
-                Logger.PrintWarning("FaceAngleResponse", "Automatically added {} conditions to model_part '{}'.".format(only_part.NumberOfConditions(), only_part.Name))
-        else:
-            only_part = self.model_part
-
-        if only_part.NumberOfConditions() == 0:
-            raise RuntimeError("The model_part '{}' does not have any surface conditions!".format(only_part.Name))
-
-        self.response_function_utility = KSO.FaceAngleResponseFunctionUtility(only_part, self.response_settings)
-
-        self.response_function_utility.Initialize()
-
-    def UpdateDesign(self, updated_model_part, variable):
-        self.value = None
-
-    def CalculateValue(self):
-        Logger.PrintInfo("FaceAngleResponse", "Starting calculation of response value:", self.identifier)
-
-        startTime = timer.time()
-        self.value = self.response_function_utility.CalculateValue()
-        Logger.PrintInfo("FaceAngleResponse", "Time needed for calculating the response value = ",round(timer.time() - startTime,2),"s")
-
-    def CalculateGradient(self):
-        Logger.PrintInfo("FaceAngleResponse", "Starting gradient calculation for response", self.identifier)
-
-        for node in self.model_part.Nodes:
-            node.SetSolutionStepValue(KM.SHAPE_SENSITIVITY, [0.0, 0.0, 0.0])
-
-        startTime = timer.time()
-        self.response_function_utility.CalculateGradient()
-        Logger.PrintInfo("FaceAngleResponse", "Time needed for calculating gradients",round(timer.time() - startTime,2),"s")
-
-    def GetValue(self):
-        return self.value
-
-    def GetNodalGradient(self, variable):
-        if variable != KM.SHAPE_SENSITIVITY:
-            raise RuntimeError("GetNodalGradient: No gradient for {}!".format(variable.Name))
-        gradient = {}
-        for node in self.model_part.Nodes:
-            gradient[node.Id] = node.GetSolutionStepValue(variable)
-        return gradient
+# importing the Kratos Library
+import KratosMultiphysics as KM
+from KratosMultiphysics import Parameters, Logger
+from KratosMultiphysics.response_functions.response_function_interface import ResponseFunctionInterface
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+
+import time as timer
+
+
+def _AddConditionsFromParent(parent, child):
+    node_ids = set([node.Id for node in child.Nodes])
+    conditions = []
+    for condition in parent.Conditions:
+        all_nodes_found = True
+        for node in condition.GetNodes():
+            if node.Id not in node_ids:
+                all_nodes_found = False
+                break
+        if all_nodes_found:
+            conditions.append(condition.Id)
+    child.AddConditions(conditions)
+
+# ==============================================================================
+class FaceAngleResponseFunction(ResponseFunctionInterface):
+    """
+    Face angle response function.
+    It aggregates the deviation of the face angles of all surface conditions using sqrt(sum(g_i)),
+    where g_i are the condition wise violations - feasible conditions do not contribute
+
+    It requires surface conditions in the modelpart, since they are used to compute the face orientation.
+    Ideally the design surface model part is used.
+
+    Attributes
+    ----------
+    model_part : Model part object of the response function
+    response_function_utility: Cpp utilities object doing the actual computation of response value and gradient.
+    """
+
+    def __init__(self, identifier, response_settings, model):
+        self.identifier = identifier
+
+        response_settings.ValidateAndAssignDefaults(self.GetDefaultParameters())
+
+        self.response_settings = response_settings
+        self.model = model
+        self.model_part_needs_to_be_imported = False
+
+        self.value = None
+
+        self._model_part_name = response_settings["model_part_name"].GetString()
+        input_type = response_settings["model_import_settings"]["input_type"].GetString()
+        if input_type == "mdpa":
+            self.model_part = self.model.CreateModelPart(self._model_part_name, 2)
+            domain_size = response_settings["domain_size"].GetInt()
+            if domain_size not in [3]:
+                raise Exception("FaceAngleResponseFunction: Invalid 'domain_size': {}".format(domain_size))
+            self.model_part.ProcessInfo.SetValue(KM.DOMAIN_SIZE, domain_size)
+            self.model_part_needs_to_be_imported = True
+        elif input_type == "use_input_model_part":
+            self.model_part = None  # will be retrieved in Initialize()
+        else:
+            raise Exception("Other model part input options are not yet implemented.")
+
+        self.response_function_utility = None  # will be created in Initialize()
+
+        self.model.GetModelPart(self._model_part_name.split(".")[0]).AddNodalSolutionStepVariable(KM.SHAPE_SENSITIVITY)
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "response_type"         : "UNKNOWN_TYPE",
+            "model_part_name"       : "UNKNOWN_NAME",
+            "only"                  : "",
+            "domain_size"           : 3,
+            "model_import_settings" : {
+                "input_type"        : "use_input_model_part",
+                "input_filename"    : "UNKNOWN_NAME"
+            },
+            "main_direction": [0.0, 0.0, 1.0],
+            "min_angle": 0.0,
+            "gradient_mode": "finite_differencing",
+            "step_size": 1e-6,
+            "consider_only_initially_feasible": false
+        }""")
+        return this_defaults
+
+    def Initialize(self):
+        if self.response_settings["model_import_settings"]["input_type"].GetString() == "mdpa":
+            file_name = self.response_settings["model_import_settings"]["input_filename"].GetString()
+            model_part_io = KM.ModelPartIO(file_name)
+            model_part_io.ReadModelPart(self.model_part)
+        else:
+            self.model_part = self.model.GetModelPart(self._model_part_name)
+
+        only = self.response_settings["only"].GetString()
+        if only != "":
+            only_part = self.model.GetModelPart(only)
+            if only_part.NumberOfConditions() == 0:
+                _AddConditionsFromParent(self.model_part, only_part)
+                Logger.PrintWarning("FaceAngleResponse", "Automatically added {} conditions to model_part '{}'.".format(only_part.NumberOfConditions(), only_part.Name))
+        else:
+            only_part = self.model_part
+
+        if only_part.NumberOfConditions() == 0:
+            raise RuntimeError("The model_part '{}' does not have any surface conditions!".format(only_part.Name))
+
+        self.response_function_utility = KSO.FaceAngleResponseFunctionUtility(only_part, self.response_settings)
+
+        self.response_function_utility.Initialize()
+
+    def UpdateDesign(self, updated_model_part, variable):
+        self.value = None
+
+    def CalculateValue(self):
+        Logger.PrintInfo("FaceAngleResponse", "Starting calculation of response value:", self.identifier)
+
+        startTime = timer.time()
+        self.value = self.response_function_utility.CalculateValue()
+        Logger.PrintInfo("FaceAngleResponse", "Time needed for calculating the response value = ",round(timer.time() - startTime,2),"s")
+
+    def CalculateGradient(self):
+        Logger.PrintInfo("FaceAngleResponse", "Starting gradient calculation for response", self.identifier)
+
+        for node in self.model_part.Nodes:
+            node.SetSolutionStepValue(KM.SHAPE_SENSITIVITY, [0.0, 0.0, 0.0])
+
+        startTime = timer.time()
+        self.response_function_utility.CalculateGradient()
+        Logger.PrintInfo("FaceAngleResponse", "Time needed for calculating gradients",round(timer.time() - startTime,2),"s")
+
+    def GetValue(self):
+        return self.value
+
+    def GetNodalGradient(self, variable):
+        if variable != KM.SHAPE_SENSITIVITY:
+            raise RuntimeError("GetNodalGradient: No gradient for {}!".format(variable.Name))
+        gradient = {}
+        for node in self.model_part.Nodes:
+            gradient[node.Id] = node.GetSolutionStepValue(variable)
+        return gradient
```

## KratosMultiphysics/ShapeOptimizationApplication/response_functions/plane_based_packaging.py

 * *Ordering differences only*

```diff
@@ -1,61 +1,61 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-import KratosMultiphysics as KM
-from .packaging_response_base import PackagingResponseBase
-from KratosMultiphysics.ShapeOptimizationApplication.utilities import custom_math as cm
-
-class PlaneBasedPackaging(PackagingResponseBase):
-    """
-    A class that defines the response function for plane-based packaging. The plane is defined by an origin point and a normal vector.
-    By default the normal of the plane indicates the feasible side of the plane (see setting 'feasible_in_normal_direction')
-    """
-
-    def __init__(self, identifier, response_settings, model):
-
-        super().__init__(identifier, response_settings, model)
-
-        self.plane_origin = []
-        for i in range(0,3):
-            self.plane_origin.append(self.response_settings["plane_origin"][i].GetDouble())
-
-        self.plane_normal = []
-        for i in range(0,3):
-            self.plane_normal.append(self.response_settings["plane_normal"][i].GetDouble())
-
-        self.plane_normal = cm.ScalarVectorProduct(1.0/cm.Norm2(self.plane_normal), self.plane_normal)
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "plane_origin"          : [0.0, 0.0, 0.0],
-            "plane_normal"          : [0.0, 0.0, 1.0]
-        }""")
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
-
-    def _DistanceVectorToPlane(self, node):
-        plane_to_point = [
-            node.X - self.plane_origin[0],
-            node.Y - self.plane_origin[1],
-            node.Z - self.plane_origin[2]
-        ]
-
-        distance = cm.Dot(plane_to_point, self.plane_normal)
-
-        return distance, self.plane_normal
-
-    def _CalculateDistances(self):
-        self.signed_distances = []
-        self.directions = []
-        for node in self.model_part.Nodes:
-            distance, direction = self._DistanceVectorToPlane(node)
-            self.signed_distances.append(distance)
-            self.directions.extend(direction)
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+import KratosMultiphysics as KM
+from .packaging_response_base import PackagingResponseBase
+from KratosMultiphysics.ShapeOptimizationApplication.utilities import custom_math as cm
+
+class PlaneBasedPackaging(PackagingResponseBase):
+    """
+    A class that defines the response function for plane-based packaging. The plane is defined by an origin point and a normal vector.
+    By default the normal of the plane indicates the feasible side of the plane (see setting 'feasible_in_normal_direction')
+    """
+
+    def __init__(self, identifier, response_settings, model):
+
+        super().__init__(identifier, response_settings, model)
+
+        self.plane_origin = []
+        for i in range(0,3):
+            self.plane_origin.append(self.response_settings["plane_origin"][i].GetDouble())
+
+        self.plane_normal = []
+        for i in range(0,3):
+            self.plane_normal.append(self.response_settings["plane_normal"][i].GetDouble())
+
+        self.plane_normal = cm.ScalarVectorProduct(1.0/cm.Norm2(self.plane_normal), self.plane_normal)
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "plane_origin"          : [0.0, 0.0, 0.0],
+            "plane_normal"          : [0.0, 0.0, 1.0]
+        }""")
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
+
+    def _DistanceVectorToPlane(self, node):
+        plane_to_point = [
+            node.X - self.plane_origin[0],
+            node.Y - self.plane_origin[1],
+            node.Z - self.plane_origin[2]
+        ]
+
+        distance = cm.Dot(plane_to_point, self.plane_normal)
+
+        return distance, self.plane_normal
+
+    def _CalculateDistances(self):
+        self.signed_distances = []
+        self.directions = []
+        for node in self.model_part.Nodes:
+            distance, direction = self._DistanceVectorToPlane(node)
+            self.signed_distances.append(distance)
+            self.directions.extend(direction)
```

## KratosMultiphysics/ShapeOptimizationApplication/model_part_controller_factory.py

 * *Ordering differences only*

```diff
@@ -1,197 +1,197 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#
-# ==============================================================================
-
-
-# importing the Kratos Library
-import KratosMultiphysics as KM
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-
-# ==============================================================================
-def CreateController(model_settings, model):
-    return ModelPartController(model_settings, model)
-
-# ==============================================================================
-class ModelPartController:
-    # --------------------------------------------------------------------------
-    def __init__(self, model_settings, model):
-        self.model_settings = model_settings
-
-        default_settings = KM.Parameters("""
-        {
-            "domain_size"           : 3,
-            "model_part_name"       : "OPTIMIZATION_MODEL_PART_NAME",
-            "model_import_settings"              : {
-                "input_type"     : "mdpa",
-                "input_filename" : "OPTIMIZATION_MODEL_PART_FILENAME"
-            },
-            "design_surface_sub_model_part_name" : "DESIGN_SURFACE_NAME",
-            "damping" : {
-                "apply_damping"      : false,
-                "recalculate_damping": false,
-                "max_neighbor_nodes" : 10000,
-                "damping_regions"    : []
-            },
-            "direction_damping" : {
-                "recalculate_damping": true,
-                "max_neighbor_nodes" : 10000,
-                "damping_regions"    : []
-            },
-            "mesh_motion" : {
-                "apply_mesh_solver" : false
-            }
-        }""")
-
-        self.model_settings.ValidateAndAssignDefaults(default_settings)
-        self.model_settings["model_import_settings"].ValidateAndAssignDefaults(default_settings["model_import_settings"])
-        self.model_settings["damping"].ValidateAndAssignDefaults(default_settings["damping"])
-        self.model_settings["direction_damping"].ValidateAndAssignDefaults(default_settings["direction_damping"])
-
-        for direction_damping_settings in self.model_settings["direction_damping"]["damping_regions"].values():
-            if not direction_damping_settings.Has("max_neighbor_nodes"):
-                max_neighbors = self.model_settings["direction_damping"]["max_neighbor_nodes"].GetInt()
-                direction_damping_settings.AddEmptyValue("max_neighbor_nodes").SetInt(max_neighbors)
-
-        self.model = model
-
-        model_part_name = self.model_settings["model_part_name"].GetString()
-        self.optimization_model_part = model.CreateModelPart(model_part_name)
-        self.optimization_model_part.ProcessInfo.SetValue(KM.DOMAIN_SIZE, self.model_settings["domain_size"].GetInt())
-
-        if self.model_settings["mesh_motion"]["apply_mesh_solver"].GetBool():
-            from KratosMultiphysics.ShapeOptimizationApplication.mesh_controllers.mesh_controller_with_solver import MeshControllerWithSolver
-            self.mesh_controller = MeshControllerWithSolver(self.model_settings["mesh_motion"], self.model)
-        else:
-            from KratosMultiphysics.ShapeOptimizationApplication.mesh_controllers.mesh_controller_basic_updating import MeshControllerBasicUpdating
-            self.mesh_controller = MeshControllerBasicUpdating(self.optimization_model_part)
-
-        self.design_surface = None
-        self.damping_utility = None
-        self.direction_dampings = []
-
-    # --------------------------------------------------------------------------
-    def Initialize(self):
-        self.__ImportOptimizationModelPart()
-        self.__IdentifyDesignSurface()
-
-        self.mesh_controller.Initialize()
-
-    def InitializeDamping(self):
-        """Initialize damping utilities, should be called after mapper is initialized"""
-        if self.model_settings["damping"]["apply_damping"].GetBool():
-            self.damping_utility = KSO.DampingUtilities(
-                self.design_surface, self.model_settings["damping"]
-            )
-
-        for direction_damping_settings in self.model_settings["direction_damping"]["damping_regions"].values():
-            self.direction_dampings.append(
-                KSO.DirectionDampingUtilities(
-                    self.design_surface, direction_damping_settings
-                )
-            )
-
-    # --------------------------------------------------------------------------
-    def SetMinimalBufferSize(self, buffer_size):
-        if self.optimization_model_part.GetBufferSize() < buffer_size:
-            self.optimization_model_part.SetBufferSize(buffer_size)
-
-    # --------------------------------------------------------------------------
-    def UpdateTimeStep(self, step):
-        self.optimization_model_part.CloneTimeStep(step)
-        self.optimization_model_part.ProcessInfo.SetValue(KM.STEP, step)
-
-    # --------------------------------------------------------------------------
-    def UpdateMeshAccordingInputVariable(self, InputVariable):
-        self.mesh_controller.UpdateMeshAccordingInputVariable(InputVariable)
-
-        if self.model_settings["damping"]["recalculate_damping"].GetBool():
-            self.damping_utility = KSO.DampingUtilities(
-                self.design_surface, self.model_settings["damping"]
-            )
-
-        if self.model_settings["direction_damping"]["recalculate_damping"].GetBool():
-            self.direction_dampings = []
-            for direction_damping_settings in self.model_settings["direction_damping"]["damping_regions"].values():
-                self.direction_dampings.append(
-                    KSO.DirectionDampingUtilities(
-                        self.design_surface, direction_damping_settings
-                    )
-                )
-
-    # --------------------------------------------------------------------------
-    def SetMeshToReferenceMesh(self):
-        KSO.MeshControllerUtilities(self.optimization_model_part).SetMeshToReferenceMesh()
-
-    # --------------------------------------------------------------------------
-    def SetReferenceMeshToMesh(self):
-        KSO.MeshControllerUtilities(self.optimization_model_part).SetReferenceMeshToMesh()
-
-    # --------------------------------------------------------------------------
-    def SetDeformationVariablesToZero(self):
-        KSO.MeshControllerUtilities(self.optimization_model_part).SetDeformationVariablesToZero()
-
-    # --------------------------------------------------------------------------
-    def GetOptimizationModelPart(self):
-        return self.optimization_model_part
-
-    # --------------------------------------------------------------------------
-    def GetModel(self):
-        return self.model
-
-    # --------------------------------------------------------------------------
-    def GetDesignSurface(self):
-        return self.design_surface
-
-    # --------------------------------------------------------------------------
-    def DampNodalSensitivityVariableIfSpecified(self, variable):
-        if self.model_settings["damping"]["apply_damping"].GetBool():
-            self.damping_utility.DampNodalVariable(variable)
-
-        for direction_damping in reversed(self.direction_dampings):
-            direction_damping.DampNodalVariable(variable)
-
-    # --------------------------------------------------------------------------
-    def DampNodalUpdateVariableIfSpecified(self, variable):
-        for direction_damping in self.direction_dampings:
-            direction_damping.DampNodalVariable(variable)
-
-        if self.model_settings["damping"]["apply_damping"].GetBool():
-            self.damping_utility.DampNodalVariable(variable)
-
-    # --------------------------------------------------------------------------
-    def ComputeUnitSurfaceNormals(self):
-        KSO.GeometryUtilities(self.GetDesignSurface()).ComputeUnitSurfaceNormals()
-
-    # --------------------------------------------------------------------------
-    def ProjectNodalVariableOnUnitSurfaceNormals(self, variable):
-        KSO.GeometryUtilities(self.GetDesignSurface()).ProjectNodalVariableOnUnitSurfaceNormals(variable)
-
-    # --------------------------------------------------------------------------
-    def __ImportOptimizationModelPart(self):
-        input_type = self.model_settings["model_import_settings"]["input_type"].GetString()
-        if input_type != "mdpa":
-            raise RuntimeError("The model part for the optimization has to be read from the mdpa file!")
-        input_filename = self.model_settings["model_import_settings"]["input_filename"].GetString()
-
-        model_part_io = KM.ModelPartIO(input_filename)
-        model_part_io.ReadModelPart(self.optimization_model_part)
-
-        self.SetMinimalBufferSize(1)
-
-    # --------------------------------------------------------------------------
-    def __IdentifyDesignSurface(self):
-        nameOfDesignSurface = self.model_settings["design_surface_sub_model_part_name"].GetString()
-        if self.optimization_model_part.HasSubModelPart(nameOfDesignSurface):
-            self.design_surface = self.optimization_model_part.GetSubModelPart(nameOfDesignSurface)
-            KM.Logger.Print("")
-            KM.Logger.PrintInfo("ShapeOpt", "The following design surface was defined:\n\n",self.design_surface)
-        else:
-            raise ValueError("The following sub-model part (design surface) specified for shape optimization does not exist: ",nameOfDesignSurface)
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#
+# ==============================================================================
+
+
+# importing the Kratos Library
+import KratosMultiphysics as KM
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+
+# ==============================================================================
+def CreateController(model_settings, model):
+    return ModelPartController(model_settings, model)
+
+# ==============================================================================
+class ModelPartController:
+    # --------------------------------------------------------------------------
+    def __init__(self, model_settings, model):
+        self.model_settings = model_settings
+
+        default_settings = KM.Parameters("""
+        {
+            "domain_size"           : 3,
+            "model_part_name"       : "OPTIMIZATION_MODEL_PART_NAME",
+            "model_import_settings"              : {
+                "input_type"     : "mdpa",
+                "input_filename" : "OPTIMIZATION_MODEL_PART_FILENAME"
+            },
+            "design_surface_sub_model_part_name" : "DESIGN_SURFACE_NAME",
+            "damping" : {
+                "apply_damping"      : false,
+                "recalculate_damping": false,
+                "max_neighbor_nodes" : 10000,
+                "damping_regions"    : []
+            },
+            "direction_damping" : {
+                "recalculate_damping": true,
+                "max_neighbor_nodes" : 10000,
+                "damping_regions"    : []
+            },
+            "mesh_motion" : {
+                "apply_mesh_solver" : false
+            }
+        }""")
+
+        self.model_settings.ValidateAndAssignDefaults(default_settings)
+        self.model_settings["model_import_settings"].ValidateAndAssignDefaults(default_settings["model_import_settings"])
+        self.model_settings["damping"].ValidateAndAssignDefaults(default_settings["damping"])
+        self.model_settings["direction_damping"].ValidateAndAssignDefaults(default_settings["direction_damping"])
+
+        for direction_damping_settings in self.model_settings["direction_damping"]["damping_regions"].values():
+            if not direction_damping_settings.Has("max_neighbor_nodes"):
+                max_neighbors = self.model_settings["direction_damping"]["max_neighbor_nodes"].GetInt()
+                direction_damping_settings.AddEmptyValue("max_neighbor_nodes").SetInt(max_neighbors)
+
+        self.model = model
+
+        model_part_name = self.model_settings["model_part_name"].GetString()
+        self.optimization_model_part = model.CreateModelPart(model_part_name)
+        self.optimization_model_part.ProcessInfo.SetValue(KM.DOMAIN_SIZE, self.model_settings["domain_size"].GetInt())
+
+        if self.model_settings["mesh_motion"]["apply_mesh_solver"].GetBool():
+            from KratosMultiphysics.ShapeOptimizationApplication.mesh_controllers.mesh_controller_with_solver import MeshControllerWithSolver
+            self.mesh_controller = MeshControllerWithSolver(self.model_settings["mesh_motion"], self.model)
+        else:
+            from KratosMultiphysics.ShapeOptimizationApplication.mesh_controllers.mesh_controller_basic_updating import MeshControllerBasicUpdating
+            self.mesh_controller = MeshControllerBasicUpdating(self.optimization_model_part)
+
+        self.design_surface = None
+        self.damping_utility = None
+        self.direction_dampings = []
+
+    # --------------------------------------------------------------------------
+    def Initialize(self):
+        self.__ImportOptimizationModelPart()
+        self.__IdentifyDesignSurface()
+
+        self.mesh_controller.Initialize()
+
+    def InitializeDamping(self):
+        """Initialize damping utilities, should be called after mapper is initialized"""
+        if self.model_settings["damping"]["apply_damping"].GetBool():
+            self.damping_utility = KSO.DampingUtilities(
+                self.design_surface, self.model_settings["damping"]
+            )
+
+        for direction_damping_settings in self.model_settings["direction_damping"]["damping_regions"].values():
+            self.direction_dampings.append(
+                KSO.DirectionDampingUtilities(
+                    self.design_surface, direction_damping_settings
+                )
+            )
+
+    # --------------------------------------------------------------------------
+    def SetMinimalBufferSize(self, buffer_size):
+        if self.optimization_model_part.GetBufferSize() < buffer_size:
+            self.optimization_model_part.SetBufferSize(buffer_size)
+
+    # --------------------------------------------------------------------------
+    def UpdateTimeStep(self, step):
+        self.optimization_model_part.CloneTimeStep(step)
+        self.optimization_model_part.ProcessInfo.SetValue(KM.STEP, step)
+
+    # --------------------------------------------------------------------------
+    def UpdateMeshAccordingInputVariable(self, InputVariable):
+        self.mesh_controller.UpdateMeshAccordingInputVariable(InputVariable)
+
+        if self.model_settings["damping"]["recalculate_damping"].GetBool():
+            self.damping_utility = KSO.DampingUtilities(
+                self.design_surface, self.model_settings["damping"]
+            )
+
+        if self.model_settings["direction_damping"]["recalculate_damping"].GetBool():
+            self.direction_dampings = []
+            for direction_damping_settings in self.model_settings["direction_damping"]["damping_regions"].values():
+                self.direction_dampings.append(
+                    KSO.DirectionDampingUtilities(
+                        self.design_surface, direction_damping_settings
+                    )
+                )
+
+    # --------------------------------------------------------------------------
+    def SetMeshToReferenceMesh(self):
+        KSO.MeshControllerUtilities(self.optimization_model_part).SetMeshToReferenceMesh()
+
+    # --------------------------------------------------------------------------
+    def SetReferenceMeshToMesh(self):
+        KSO.MeshControllerUtilities(self.optimization_model_part).SetReferenceMeshToMesh()
+
+    # --------------------------------------------------------------------------
+    def SetDeformationVariablesToZero(self):
+        KSO.MeshControllerUtilities(self.optimization_model_part).SetDeformationVariablesToZero()
+
+    # --------------------------------------------------------------------------
+    def GetOptimizationModelPart(self):
+        return self.optimization_model_part
+
+    # --------------------------------------------------------------------------
+    def GetModel(self):
+        return self.model
+
+    # --------------------------------------------------------------------------
+    def GetDesignSurface(self):
+        return self.design_surface
+
+    # --------------------------------------------------------------------------
+    def DampNodalSensitivityVariableIfSpecified(self, variable):
+        if self.model_settings["damping"]["apply_damping"].GetBool():
+            self.damping_utility.DampNodalVariable(variable)
+
+        for direction_damping in reversed(self.direction_dampings):
+            direction_damping.DampNodalVariable(variable)
+
+    # --------------------------------------------------------------------------
+    def DampNodalUpdateVariableIfSpecified(self, variable):
+        for direction_damping in self.direction_dampings:
+            direction_damping.DampNodalVariable(variable)
+
+        if self.model_settings["damping"]["apply_damping"].GetBool():
+            self.damping_utility.DampNodalVariable(variable)
+
+    # --------------------------------------------------------------------------
+    def ComputeUnitSurfaceNormals(self):
+        KSO.GeometryUtilities(self.GetDesignSurface()).ComputeUnitSurfaceNormals()
+
+    # --------------------------------------------------------------------------
+    def ProjectNodalVariableOnUnitSurfaceNormals(self, variable):
+        KSO.GeometryUtilities(self.GetDesignSurface()).ProjectNodalVariableOnUnitSurfaceNormals(variable)
+
+    # --------------------------------------------------------------------------
+    def __ImportOptimizationModelPart(self):
+        input_type = self.model_settings["model_import_settings"]["input_type"].GetString()
+        if input_type != "mdpa":
+            raise RuntimeError("The model part for the optimization has to be read from the mdpa file!")
+        input_filename = self.model_settings["model_import_settings"]["input_filename"].GetString()
+
+        model_part_io = KM.ModelPartIO(input_filename)
+        model_part_io.ReadModelPart(self.optimization_model_part)
+
+        self.SetMinimalBufferSize(1)
+
+    # --------------------------------------------------------------------------
+    def __IdentifyDesignSurface(self):
+        nameOfDesignSurface = self.model_settings["design_surface_sub_model_part_name"].GetString()
+        if self.optimization_model_part.HasSubModelPart(nameOfDesignSurface):
+            self.design_surface = self.optimization_model_part.GetSubModelPart(nameOfDesignSurface)
+            KM.Logger.Print("")
+            KM.Logger.PrintInfo("ShapeOpt", "The following design surface was defined:\n\n",self.design_surface)
+        else:
+            raise ValueError("The following sub-model part (design surface) specified for shape optimization does not exist: ",nameOfDesignSurface)
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/custom_ios/wrl_reader.py

 * *Ordering differences only*

```diff
@@ -1,119 +1,119 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-import os
-
-class Shape:
-    def __init__(self, name, nodes, faces):
-        self.name = name
-        self.nodes = nodes
-        self.faces = faces
-
-def detect_file(file_name):
-    wrl_name = file_name + ".wrl"
-    vrml_name = file_name + ".vrml"
-
-    if os.path.isfile(wrl_name) and os.path.isfile(vrml_name):
-        raise Exception("Wrl reader: file {} found with '.wrl' and '.vrml' ending! Please remove one of them!".format(file_name))
-    elif os.path.isfile(wrl_name):
-        return wrl_name
-    elif os.path.isfile(vrml_name):
-        return vrml_name
-    else:
-        raise Exception("Wrl reader: file {} not found with '.wrl' or '.vrml' ending!".format(file_name))
-
-def read_nodes(line, file):
-    nodes = []
-    while "[" not in line:
-        line = next(file)
-
-    line = next(file)
-
-    while "]" not in line:
-        if line == "\n":
-            line = next(file)
-
-        try:
-            entries = line.split(",")[0].split()
-            if len(entries) != 3:
-                raise RuntimeError("wrl_reader: Did not find 3 coordinate components!", line)
-            nodes.append([float(x) for x in entries])
-        except IOError:
-            pass
-
-        line = next(file)
-
-    return nodes
-
-def read_faces(line, file):
-    faces = []
-    while "[" not in line:
-        line = next(file)
-
-    line = next(file)
-
-    while "]" not in line:
-        if line == "\n":
-            line = next(file)
-
-        try:
-            entries = line.split(",")
-            entries = [x.strip() for x in entries]
-            if entries.count("-1") != 1:
-                raise RuntimeError("wrl_reader: Can only read one face per line!", line)
-            entries = entries[:entries.index("-1")]
-            if len(entries) < 2:
-                raise RuntimeError("wrl_reader: Can not read faces with less than 3 nodes!", line)
-            elif len(entries) > 4:
-                raise RuntimeError("wrl_reader: Can not read faces with more than 4 nodes!", line)
-            faces.append([int(x) for x in entries])
-        except IOError:
-            pass
-
-        line = next(file)
-
-    return faces
-
-def read_shape(line, file):
-    try:
-        name = line.split("#")[1].strip()
-    except IndexError:
-        name = "geometry"
-    nodes = []
-    faces = []
-
-    while "geometry" not in line:
-        line = next(file)
-    if "IndexedFaceSet" not in line:
-        raise RuntimeError("wrl_reader: Can not read '{}'".format(line))
-
-    while not nodes or not faces:
-        if line.strip().startswith("coord "):
-            nodes = read_nodes(line, file)
-        elif line.strip().startswith("coordIndex"):
-            faces = read_faces(line, file)
-        line = next(file)
-
-    return Shape(name, nodes, faces)
-
-def read_shapes(file_name):
-    shapes = []
-    with open(file_name, "r") as file:
-
-        first_line = file.readline()
-        if not first_line.startswith("#VRML V2.0"):
-            raise RuntimeError("wrl_reader: Can not read '{}' format!"\
-                " Only '#VRML V2.0' is supported.".format(first_line.strip()))
-
-        for line in file:
-            if line.strip().startswith("Shape"):
-                shapes.append(read_shape(line, file))
-                line = next(file)
-    return shapes
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+import os
+
+class Shape:
+    def __init__(self, name, nodes, faces):
+        self.name = name
+        self.nodes = nodes
+        self.faces = faces
+
+def detect_file(file_name):
+    wrl_name = file_name + ".wrl"
+    vrml_name = file_name + ".vrml"
+
+    if os.path.isfile(wrl_name) and os.path.isfile(vrml_name):
+        raise Exception("Wrl reader: file {} found with '.wrl' and '.vrml' ending! Please remove one of them!".format(file_name))
+    elif os.path.isfile(wrl_name):
+        return wrl_name
+    elif os.path.isfile(vrml_name):
+        return vrml_name
+    else:
+        raise Exception("Wrl reader: file {} not found with '.wrl' or '.vrml' ending!".format(file_name))
+
+def read_nodes(line, file):
+    nodes = []
+    while "[" not in line:
+        line = next(file)
+
+    line = next(file)
+
+    while "]" not in line:
+        if line == "\n":
+            line = next(file)
+
+        try:
+            entries = line.split(",")[0].split()
+            if len(entries) != 3:
+                raise RuntimeError("wrl_reader: Did not find 3 coordinate components!", line)
+            nodes.append([float(x) for x in entries])
+        except IOError:
+            pass
+
+        line = next(file)
+
+    return nodes
+
+def read_faces(line, file):
+    faces = []
+    while "[" not in line:
+        line = next(file)
+
+    line = next(file)
+
+    while "]" not in line:
+        if line == "\n":
+            line = next(file)
+
+        try:
+            entries = line.split(",")
+            entries = [x.strip() for x in entries]
+            if entries.count("-1") != 1:
+                raise RuntimeError("wrl_reader: Can only read one face per line!", line)
+            entries = entries[:entries.index("-1")]
+            if len(entries) < 2:
+                raise RuntimeError("wrl_reader: Can not read faces with less than 3 nodes!", line)
+            elif len(entries) > 4:
+                raise RuntimeError("wrl_reader: Can not read faces with more than 4 nodes!", line)
+            faces.append([int(x) for x in entries])
+        except IOError:
+            pass
+
+        line = next(file)
+
+    return faces
+
+def read_shape(line, file):
+    try:
+        name = line.split("#")[1].strip()
+    except IndexError:
+        name = "geometry"
+    nodes = []
+    faces = []
+
+    while "geometry" not in line:
+        line = next(file)
+    if "IndexedFaceSet" not in line:
+        raise RuntimeError("wrl_reader: Can not read '{}'".format(line))
+
+    while not nodes or not faces:
+        if line.strip().startswith("coord "):
+            nodes = read_nodes(line, file)
+        elif line.strip().startswith("coordIndex"):
+            faces = read_faces(line, file)
+        line = next(file)
+
+    return Shape(name, nodes, faces)
+
+def read_shapes(file_name):
+    shapes = []
+    with open(file_name, "r") as file:
+
+        first_line = file.readline()
+        if not first_line.startswith("#VRML V2.0"):
+            raise RuntimeError("wrl_reader: Can not read '{}' format!"\
+                " Only '#VRML V2.0' is supported.".format(first_line.strip()))
+
+        for line in file:
+            if line.strip().startswith("Shape"):
+                shapes.append(read_shape(line, file))
+                line = next(file)
+    return shapes
```

## KratosMultiphysics/ShapeOptimizationApplication/custom_ios/wrl_io.py

 * *Ordering differences only*

```diff
@@ -1,82 +1,82 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-import KratosMultiphysics as KM
-from .wrl_reader import read_shapes, detect_file
-
-def _rename_to_valid_name(model_part, shape):
-    name = shape.name
-
-    ref_name = name
-    i = 2
-    while model_part.HasSubModelPart(name):
-        name = ref_name +"_{}".format(i)
-        i += 1
-
-    if shape.name != name:
-        KM.Logger.PrintWarning("ShapeOpt", "WrlIO: Name of the sub model part has been changed from '{}' to '{}' in order "\
-            "to avoid name clashes!".format(shape.name, name))
-        shape.name = name
-
-class WrlIO:
-
-    def __init__(self, file_name):
-        self.file_name = detect_file(file_name)
-
-    def ReadModelPart(self, model_part):
-        KM.Logger.PrintInfo("ShapeOpt", "Start reading model part from '{}'.".format(self.file_name))
-
-        if model_part.ProcessInfo.GetValue(KM.DOMAIN_SIZE) != 3:
-            raise Exception("WrlIO: Domain size has to be 3!")
-
-        shapes = read_shapes(self.file_name)
-
-        node_multiplicity = {}
-
-        nodes_shift = 0
-        faces_shift = 0
-        for i, shape in enumerate(shapes):
-            _rename_to_valid_name(model_part, shape)
-            sub_model_part = model_part.CreateSubModelPart(shape.name)
-
-            property_id = i+1
-            new_property = model_part.CreateNewProperties(property_id)
-
-            for i, node in enumerate(shape.nodes):
-                node_id = i + nodes_shift
-                new_node = model_part.CreateNewNode(node_id, *node)
-                sub_model_part.AddNode(new_node, 0)
-                node_multiplicity[node_id] = 0
-
-            for i, face in enumerate(shape.faces):
-                face_id = i + faces_shift
-                node_ids = [x + nodes_shift for x in face]
-
-                for node_id in node_ids:
-                    node_multiplicity[node_id] += 1
-
-                condition_type = "SurfaceCondition3D{}N".format(len(node_ids))
-                new_condition = model_part.CreateNewCondition(condition_type, face_id, node_ids, new_property)
-                sub_model_part.AddCondition(new_condition)
-
-            nodes_shift += len(shape.nodes)
-            faces_shift += len(shape.faces)
-
-        # remove flying nodes
-        counter = 0
-        for node_id, count in node_multiplicity.items():
-            if count == 0:
-                model_part.RemoveNode(node_id)
-                counter += 1
-
-        if counter > 0:
-            KM.Logger.PrintWarning("WrlIO", "Deleted {} flying nodes from model part!".format(counter))
-
-        KM.Logger.PrintInfo("ShapeOpt", "Finished reading model part.")
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+import KratosMultiphysics as KM
+from .wrl_reader import read_shapes, detect_file
+
+def _rename_to_valid_name(model_part, shape):
+    name = shape.name
+
+    ref_name = name
+    i = 2
+    while model_part.HasSubModelPart(name):
+        name = ref_name +"_{}".format(i)
+        i += 1
+
+    if shape.name != name:
+        KM.Logger.PrintWarning("ShapeOpt", "WrlIO: Name of the sub model part has been changed from '{}' to '{}' in order "\
+            "to avoid name clashes!".format(shape.name, name))
+        shape.name = name
+
+class WrlIO:
+
+    def __init__(self, file_name):
+        self.file_name = detect_file(file_name)
+
+    def ReadModelPart(self, model_part):
+        KM.Logger.PrintInfo("ShapeOpt", "Start reading model part from '{}'.".format(self.file_name))
+
+        if model_part.ProcessInfo.GetValue(KM.DOMAIN_SIZE) != 3:
+            raise Exception("WrlIO: Domain size has to be 3!")
+
+        shapes = read_shapes(self.file_name)
+
+        node_multiplicity = {}
+
+        nodes_shift = 0
+        faces_shift = 0
+        for i, shape in enumerate(shapes):
+            _rename_to_valid_name(model_part, shape)
+            sub_model_part = model_part.CreateSubModelPart(shape.name)
+
+            property_id = i+1
+            new_property = model_part.CreateNewProperties(property_id)
+
+            for i, node in enumerate(shape.nodes):
+                node_id = i + nodes_shift
+                new_node = model_part.CreateNewNode(node_id, *node)
+                sub_model_part.AddNode(new_node, 0)
+                node_multiplicity[node_id] = 0
+
+            for i, face in enumerate(shape.faces):
+                face_id = i + faces_shift
+                node_ids = [x + nodes_shift for x in face]
+
+                for node_id in node_ids:
+                    node_multiplicity[node_id] += 1
+
+                condition_type = "SurfaceCondition3D{}N".format(len(node_ids))
+                new_condition = model_part.CreateNewCondition(condition_type, face_id, node_ids, new_property)
+                sub_model_part.AddCondition(new_condition)
+
+            nodes_shift += len(shape.nodes)
+            faces_shift += len(shape.faces)
+
+        # remove flying nodes
+        counter = 0
+        for node_id, count in node_multiplicity.items():
+            if count == 0:
+                model_part.RemoveNode(node_id)
+                counter += 1
+
+        if counter > 0:
+            KM.Logger.PrintWarning("WrlIO", "Deleted {} flying nodes from model part!".format(counter))
+
+        KM.Logger.PrintInfo("ShapeOpt", "Finished reading model part.")
```

## KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_basic_updating.py

 * *Ordering differences only*

```diff
@@ -1,35 +1,35 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#
-# ==============================================================================
-
-
-# importing the Kratos Library
-import KratosMultiphysics as KM
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-
-# Additional imports
-import time as timer
-from .mesh_controller_base import MeshController
-
-# ==============================================================================
-class MeshControllerBasicUpdating(MeshController):
-    # --------------------------------------------------------------------------
-    def __init__(self, OptimizationModelPart):
-        self.OptimizationModelPart = OptimizationModelPart
-
-    # --------------------------------------------------------------------------
-    def UpdateMeshAccordingInputVariable(self, variable):
-        KM.Logger.Print("")
-        KM.Logger.PrintInfo("ShapeOpt", "Starting to update the mesh")
-        startTime = timer.time()
-        KSO.MeshControllerUtilities(self.OptimizationModelPart).UpdateMeshAccordingInputVariable(variable)
-        KSO.MeshControllerUtilities(self.OptimizationModelPart).LogMeshChangeAccordingInputVariable(variable)
-        KM.Logger.PrintInfo("ShapeOpt", "Time needed for updating the mesh = ",round(timer.time() - startTime,2),"s")
-
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#
+# ==============================================================================
+
+
+# importing the Kratos Library
+import KratosMultiphysics as KM
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+
+# Additional imports
+import time as timer
+from .mesh_controller_base import MeshController
+
+# ==============================================================================
+class MeshControllerBasicUpdating(MeshController):
+    # --------------------------------------------------------------------------
+    def __init__(self, OptimizationModelPart):
+        self.OptimizationModelPart = OptimizationModelPart
+
+    # --------------------------------------------------------------------------
+    def UpdateMeshAccordingInputVariable(self, variable):
+        KM.Logger.Print("")
+        KM.Logger.PrintInfo("ShapeOpt", "Starting to update the mesh")
+        startTime = timer.time()
+        KSO.MeshControllerUtilities(self.OptimizationModelPart).UpdateMeshAccordingInputVariable(variable)
+        KSO.MeshControllerUtilities(self.OptimizationModelPart).LogMeshChangeAccordingInputVariable(variable)
+        KM.Logger.PrintInfo("ShapeOpt", "Time needed for updating the mesh = ",round(timer.time() - startTime,2),"s")
+
 # ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_with_solver.py

 * *Ordering differences only*

```diff
@@ -1,237 +1,237 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#
-# ==============================================================================
-
-
-# Kratos Core and Apps
-import KratosMultiphysics as KM
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-
-# Additional imports
-import time as timer
-from KratosMultiphysics.ShapeOptimizationApplication.mesh_controllers.mesh_controller_base import MeshController
-from KratosMultiphysics.MeshMovingApplication.mesh_moving_analysis import MeshMovingAnalysis
-
-try:
-    import KratosMultiphysics.MeshingApplication as KMA
-    from KratosMultiphysics.MeshingApplication.mmg_process import MmgProcess as automatic_remeshing_process
-    if not hasattr(KMA, "MmgProcess2D"):
-        automatic_remeshing_process = None
-        automatic_remeshing_error_msg = "MeshingApplication is not compiled with '-DINCLUDE_MMG=ON'"
-except ImportError as err:
-    automatic_remeshing_process = None
-    automatic_remeshing_error_msg = str(err)
-
-# # ==============================================================================
-class MeshControllerWithSolver(MeshController) :
-    # --------------------------------------------------------------------------
-    def __init__(self, MeshSolverSettings, model):
-        default_settings = KM.Parameters("""
-        {
-            "apply_mesh_solver" : true,
-            "solver_settings" : {
-                "domain_size"     : 3,
-                "echo_level"      : 0,
-                "solver_type"     : "structural_similarity",
-                "model_part_name" : "NONE",
-                "model_import_settings"              : {
-                    "input_type"     : "use_input_model_part"
-                },
-                "time_stepping" : {
-                    "time_step"       : 1.0
-                },
-                "linear_solver_settings" : {
-                    "solver_type" : "amgcl",
-                    "smoother_type":"ilu0",
-                    "krylov_type": "gmres",
-                    "coarsening_type": "aggregation",
-                    "max_iteration": 200,
-                    "verbosity" : 0,
-                    "tolerance": 1e-7
-                },
-                "compute_reactions"                : false,
-                "calculate_mesh_velocity"          : false
-            },
-            "processes" : {
-                "boundary_conditions_process_list" : []
-            },
-            "use_automatic_remeshing"     : false,
-            "automatic_remeshing_settings": {
-                "strategy"        : "optimization",
-                "step_frequency"  : 1,
-                "automatic_remesh": true,
-                "automatic_remesh_parameters": {
-                    "automatic_remesh_type": "Ratio",
-                    "min_size_ratio": 1.0,
-                    "max_size_ratio": 5.0,
-                    "refer_type"    : "Mean"
-                },
-                "echo_level": 0,
-                "force_min" : true,
-                "force_max" : true
-            }
-        }""")
-        self.MeshSolverSettings = MeshSolverSettings
-        self.MeshSolverSettings.ValidateAndAssignDefaults(default_settings)
-        self.MeshSolverSettings["solver_settings"].ValidateAndAssignDefaults(default_settings["solver_settings"])
-        self.MeshSolverSettings["processes"].ValidateAndAssignDefaults(default_settings["processes"])
-
-        if not self.MeshSolverSettings["solver_settings"].Has("linear_solver_settings"):
-            MeshSolverSettings.AddValue("linear_solver_settings", default_settings["solver_settings"]["linear_solver_settings"])
-            KM.Logger.PrintInfo("ShapeOpt", "::[MeshControllerWithSolver]:: using default linear solver for mesh motion.")
-
-        if not MeshSolverSettings.Has("problem_data"):
-            self.__AddDefaultProblemData(self.MeshSolverSettings)
-        else:
-            KM.Logger.PrintInfo("ShapeOpt", "::[MeshControllerWithSolver]:: using custom problem data for mesh motion.")
-
-        self.OptimizationModelPart = model[self.MeshSolverSettings["solver_settings"]["model_part_name"].GetString()]
-
-        if self.MeshSolverSettings["processes"]["boundary_conditions_process_list"].size() == 0:
-            self.__FixWholeSurface(self.OptimizationModelPart, self.MeshSolverSettings)
-            self.has_automatic_boundary_process = True
-        else:
-            self.has_automatic_boundary_process = False
-
-        self.is_remeshing_used = self.MeshSolverSettings["use_automatic_remeshing"].GetBool()
-        if (self.is_remeshing_used):
-            automatic_remeshing_process_settings = self.MeshSolverSettings["automatic_remeshing_settings"]
-            if (automatic_remeshing_process is None):
-                raise RuntimeError("Automatic remeshing requires to import MeshingApplication. Importing failed with following error msg.\n\t" + automatic_remeshing_error_msg)
-
-            self.__CheckAndSetAutomaticMeshRefinementSettings(automatic_remeshing_process_settings)
-            self.remeshing_process = automatic_remeshing_process(model, automatic_remeshing_process_settings)
-
-            # remeshing requires to reinitialize the model_part of the mesh solver
-            self.MeshSolverSettings["solver_settings"].AddBool("reinitialize_model_part_each_step", True)
-
-            KM.Logger.PrintInfo("ShapeOpt", "Initialized automatic automatic remeshing process")
-
-        self._mesh_moving_analysis = MeshMovingAnalysis(model, self.MeshSolverSettings)
-
-    # --------------------------------------------------------------------------
-    def Initialize(self):
-        if self.has_automatic_boundary_process:
-            KSO.GeometryUtilities(self.OptimizationModelPart).ExtractBoundaryNodes("auto_surface_nodes")
-
-        self._mesh_moving_analysis.Initialize()
-        if self.is_remeshing_used:
-            self.remeshing_process.ExecuteInitialize()
-
-    # --------------------------------------------------------------------------
-    def UpdateMeshAccordingInputVariable(self, variable):
-        KM.Logger.Print("")
-        KM.Logger.PrintInfo("ShapeOpt", "Starting to update the mesh...")
-        startTime = timer.time()
-
-        time_before_update = self.OptimizationModelPart.ProcessInfo.GetValue(KM.TIME)
-        step_before_update = self.OptimizationModelPart.ProcessInfo.GetValue(KM.STEP)
-        delta_time_before_update = self.OptimizationModelPart.ProcessInfo.GetValue(KM.DELTA_TIME)
-
-        # Reset step/time iterators such that they match the current iteration after calling RunSolutionLoop (which internally calls CloneTimeStep)
-        self.OptimizationModelPart.ProcessInfo.SetValue(KM.STEP, step_before_update-1)
-        self.OptimizationModelPart.ProcessInfo.SetValue(KM.TIME, time_before_update-1)
-        self.OptimizationModelPart.ProcessInfo.SetValue(KM.DELTA_TIME, 0)
-
-        KM.VariableUtils().CopyVectorVar(variable, KM.MESH_DISPLACEMENT, self.OptimizationModelPart.Nodes)
-
-        if self.has_automatic_boundary_process and self.is_remeshing_used:
-            self.OptimizationModelPart.GetSubModelPart("auto_surface_nodes").GetNodes().clear()
-            KSO.GeometryUtilities(self.OptimizationModelPart).ExtractBoundaryNodes("auto_surface_nodes")
-
-        if not self._mesh_moving_analysis.time < self._mesh_moving_analysis.end_time:
-            self._mesh_moving_analysis.end_time += 1
-        self._mesh_moving_analysis.RunSolutionLoop()
-
-        if self.is_remeshing_used:
-            self.OptimizationModelPart.Set(KM.MODIFIED, False)
-            self.remeshing_process.ExecuteInitializeSolutionStep()
-            self.remeshing_process.ExecuteFinalizeSolutionStep()
-
-        KSO.MeshControllerUtilities(self.OptimizationModelPart).LogMeshChangeAccordingInputVariable(KM.MESH_DISPLACEMENT)
-
-        self.OptimizationModelPart.ProcessInfo.SetValue(KM.STEP, step_before_update)
-        self.OptimizationModelPart.ProcessInfo.SetValue(KM.TIME, time_before_update)
-        self.OptimizationModelPart.ProcessInfo.SetValue(KM.DELTA_TIME, delta_time_before_update)
-
-        KM.Logger.PrintInfo("ShapeOpt", "Time needed for updating the mesh = ",round(timer.time() - startTime,2),"s")
-
-    # --------------------------------------------------------------------------
-    def Finalize(self):
-        self._mesh_moving_analysis.Finalize()
-
-        if self.is_remeshing_used:
-            self.remeshing_process.ExecuteFinalize()
-
-    # --------------------------------------------------------------------------
-    @staticmethod
-    def __AddDefaultProblemData(mesh_solver_settings):
-        problem_data = KM.Parameters("""{
-            "echo_level"    : 0,
-            "start_time"    : 0.0,
-            "end_time"      : 1.0,
-            "parallel_type" : "OpenMP"
-        }""")
-
-        mesh_solver_settings.AddValue("problem_data", problem_data)
-
-    # --------------------------------------------------------------------------
-    @staticmethod
-    def __FixWholeSurface(optimization_model_part, mesh_solver_settings):
-        optimization_model_part.CreateSubModelPart("auto_surface_nodes")
-
-        auto_process_settings = KM.Parameters(
-            """
-            {
-                "python_module" : "fix_vector_variable_process",
-                "kratos_module" : "KratosMultiphysics",
-                "help"          : "This process fixes the selected components of a given vector variable without modifying the value of the variable.",
-                "process_name"  : "FixVectorVariableProcess",
-                "Parameters"    : {
-                    "model_part_name"      : \""""+str(optimization_model_part.Name)+""".auto_surface_nodes\",
-                    "variable_name"        : "MESH_DISPLACEMENT",
-                    "constrained"          : [true,true,true]
-                }
-            }
-            """)
-
-        KM.Logger.PrintInfo("ShapeOpt", "Add automatic process to fix the whole surface to mesh motion solver:")
-        mesh_solver_settings["processes"]["boundary_conditions_process_list"].Append(auto_process_settings)
-
-    # --------------------------------------------------------------------------
-    def __CheckAndSetAutomaticMeshRefinementSettings(self, parameters):
-        if (parameters.Has("interpolate_nodal_values")):
-            if (parameters["interpolate_nodal_values"].GetBool()):
-                KM.Logger.PrintWarning("ShapeOpt", "Historical value interpolation is not allowed in automatic remeshing. Turning it off.")
-            parameters["interpolate_nodal_values"].SetBool(False)
-        else:
-            parameters.AddBool("interpolate_nodal_values", False)
-
-        if (parameters.Has("interpolate_non_historical")):
-            if (parameters["interpolate_non_historical"].GetBool()):
-                KM.Logger.PrintWarning("ShapeOpt", "Non-historical value interpolation is not allowed in automatic remeshing. Turning it off.")
-            parameters["interpolate_non_historical"].SetBool(False)
-        else:
-            parameters.AddBool("interpolate_non_historical", False)
-
-        if (parameters.Has("extrapolate_contour_values")):
-            if (parameters["extrapolate_contour_values"].GetBool()):
-                KM.Logger.PrintWarning("ShapeOpt", "Value extrapolation is not allowed in automatic remeshing. Turning it off.")
-            parameters["extrapolate_contour_values"].SetBool(False)
-        else:
-            parameters.AddBool("extrapolate_contour_values", False)
-
-        if (parameters.Has("model_part_name")):
-            if (parameters["model_part_name"].GetString() != self.OptimizationModelPart.Name):
-                KM.Logger.PrintWarning("ShapeOpt", "Mismatching model part name provided for automatic remeshing [ " + parameters["model_part_name"].GetString() + " ]. Using the optimization model part [ " + self.OptimizationModelPart.Name + " ].")
-            parameters["model_part_name"].SetString(self.OptimizationModelPart.Name)
-        else:
-            parameters.AddString("model_part_name", self.OptimizationModelPart.Name)
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#
+# ==============================================================================
+
+
+# Kratos Core and Apps
+import KratosMultiphysics as KM
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+
+# Additional imports
+import time as timer
+from KratosMultiphysics.ShapeOptimizationApplication.mesh_controllers.mesh_controller_base import MeshController
+from KratosMultiphysics.MeshMovingApplication.mesh_moving_analysis import MeshMovingAnalysis
+
+try:
+    import KratosMultiphysics.MeshingApplication as KMA
+    from KratosMultiphysics.MeshingApplication.mmg_process import MmgProcess as automatic_remeshing_process
+    if not hasattr(KMA, "MmgProcess2D"):
+        automatic_remeshing_process = None
+        automatic_remeshing_error_msg = "MeshingApplication is not compiled with '-DINCLUDE_MMG=ON'"
+except ImportError as err:
+    automatic_remeshing_process = None
+    automatic_remeshing_error_msg = str(err)
+
+# # ==============================================================================
+class MeshControllerWithSolver(MeshController) :
+    # --------------------------------------------------------------------------
+    def __init__(self, MeshSolverSettings, model):
+        default_settings = KM.Parameters("""
+        {
+            "apply_mesh_solver" : true,
+            "solver_settings" : {
+                "domain_size"     : 3,
+                "echo_level"      : 0,
+                "solver_type"     : "structural_similarity",
+                "model_part_name" : "NONE",
+                "model_import_settings"              : {
+                    "input_type"     : "use_input_model_part"
+                },
+                "time_stepping" : {
+                    "time_step"       : 1.0
+                },
+                "linear_solver_settings" : {
+                    "solver_type" : "amgcl",
+                    "smoother_type":"ilu0",
+                    "krylov_type": "gmres",
+                    "coarsening_type": "aggregation",
+                    "max_iteration": 200,
+                    "verbosity" : 0,
+                    "tolerance": 1e-7
+                },
+                "compute_reactions"                : false,
+                "calculate_mesh_velocity"          : false
+            },
+            "processes" : {
+                "boundary_conditions_process_list" : []
+            },
+            "use_automatic_remeshing"     : false,
+            "automatic_remeshing_settings": {
+                "strategy"        : "optimization",
+                "step_frequency"  : 1,
+                "automatic_remesh": true,
+                "automatic_remesh_parameters": {
+                    "automatic_remesh_type": "Ratio",
+                    "min_size_ratio": 1.0,
+                    "max_size_ratio": 5.0,
+                    "refer_type"    : "Mean"
+                },
+                "echo_level": 0,
+                "force_min" : true,
+                "force_max" : true
+            }
+        }""")
+        self.MeshSolverSettings = MeshSolverSettings
+        self.MeshSolverSettings.ValidateAndAssignDefaults(default_settings)
+        self.MeshSolverSettings["solver_settings"].ValidateAndAssignDefaults(default_settings["solver_settings"])
+        self.MeshSolverSettings["processes"].ValidateAndAssignDefaults(default_settings["processes"])
+
+        if not self.MeshSolverSettings["solver_settings"].Has("linear_solver_settings"):
+            MeshSolverSettings.AddValue("linear_solver_settings", default_settings["solver_settings"]["linear_solver_settings"])
+            KM.Logger.PrintInfo("ShapeOpt", "::[MeshControllerWithSolver]:: using default linear solver for mesh motion.")
+
+        if not MeshSolverSettings.Has("problem_data"):
+            self.__AddDefaultProblemData(self.MeshSolverSettings)
+        else:
+            KM.Logger.PrintInfo("ShapeOpt", "::[MeshControllerWithSolver]:: using custom problem data for mesh motion.")
+
+        self.OptimizationModelPart = model[self.MeshSolverSettings["solver_settings"]["model_part_name"].GetString()]
+
+        if self.MeshSolverSettings["processes"]["boundary_conditions_process_list"].size() == 0:
+            self.__FixWholeSurface(self.OptimizationModelPart, self.MeshSolverSettings)
+            self.has_automatic_boundary_process = True
+        else:
+            self.has_automatic_boundary_process = False
+
+        self.is_remeshing_used = self.MeshSolverSettings["use_automatic_remeshing"].GetBool()
+        if (self.is_remeshing_used):
+            automatic_remeshing_process_settings = self.MeshSolverSettings["automatic_remeshing_settings"]
+            if (automatic_remeshing_process is None):
+                raise RuntimeError("Automatic remeshing requires to import MeshingApplication. Importing failed with following error msg.\n\t" + automatic_remeshing_error_msg)
+
+            self.__CheckAndSetAutomaticMeshRefinementSettings(automatic_remeshing_process_settings)
+            self.remeshing_process = automatic_remeshing_process(model, automatic_remeshing_process_settings)
+
+            # remeshing requires to reinitialize the model_part of the mesh solver
+            self.MeshSolverSettings["solver_settings"].AddBool("reinitialize_model_part_each_step", True)
+
+            KM.Logger.PrintInfo("ShapeOpt", "Initialized automatic automatic remeshing process")
+
+        self._mesh_moving_analysis = MeshMovingAnalysis(model, self.MeshSolverSettings)
+
+    # --------------------------------------------------------------------------
+    def Initialize(self):
+        if self.has_automatic_boundary_process:
+            KSO.GeometryUtilities(self.OptimizationModelPart).ExtractBoundaryNodes("auto_surface_nodes")
+
+        self._mesh_moving_analysis.Initialize()
+        if self.is_remeshing_used:
+            self.remeshing_process.ExecuteInitialize()
+
+    # --------------------------------------------------------------------------
+    def UpdateMeshAccordingInputVariable(self, variable):
+        KM.Logger.Print("")
+        KM.Logger.PrintInfo("ShapeOpt", "Starting to update the mesh...")
+        startTime = timer.time()
+
+        time_before_update = self.OptimizationModelPart.ProcessInfo.GetValue(KM.TIME)
+        step_before_update = self.OptimizationModelPart.ProcessInfo.GetValue(KM.STEP)
+        delta_time_before_update = self.OptimizationModelPart.ProcessInfo.GetValue(KM.DELTA_TIME)
+
+        # Reset step/time iterators such that they match the current iteration after calling RunSolutionLoop (which internally calls CloneTimeStep)
+        self.OptimizationModelPart.ProcessInfo.SetValue(KM.STEP, step_before_update-1)
+        self.OptimizationModelPart.ProcessInfo.SetValue(KM.TIME, time_before_update-1)
+        self.OptimizationModelPart.ProcessInfo.SetValue(KM.DELTA_TIME, 0)
+
+        KM.VariableUtils().CopyVectorVar(variable, KM.MESH_DISPLACEMENT, self.OptimizationModelPart.Nodes)
+
+        if self.has_automatic_boundary_process and self.is_remeshing_used:
+            self.OptimizationModelPart.GetSubModelPart("auto_surface_nodes").GetNodes().clear()
+            KSO.GeometryUtilities(self.OptimizationModelPart).ExtractBoundaryNodes("auto_surface_nodes")
+
+        if not self._mesh_moving_analysis.time < self._mesh_moving_analysis.end_time:
+            self._mesh_moving_analysis.end_time += 1
+        self._mesh_moving_analysis.RunSolutionLoop()
+
+        if self.is_remeshing_used:
+            self.OptimizationModelPart.Set(KM.MODIFIED, False)
+            self.remeshing_process.ExecuteInitializeSolutionStep()
+            self.remeshing_process.ExecuteFinalizeSolutionStep()
+
+        KSO.MeshControllerUtilities(self.OptimizationModelPart).LogMeshChangeAccordingInputVariable(KM.MESH_DISPLACEMENT)
+
+        self.OptimizationModelPart.ProcessInfo.SetValue(KM.STEP, step_before_update)
+        self.OptimizationModelPart.ProcessInfo.SetValue(KM.TIME, time_before_update)
+        self.OptimizationModelPart.ProcessInfo.SetValue(KM.DELTA_TIME, delta_time_before_update)
+
+        KM.Logger.PrintInfo("ShapeOpt", "Time needed for updating the mesh = ",round(timer.time() - startTime,2),"s")
+
+    # --------------------------------------------------------------------------
+    def Finalize(self):
+        self._mesh_moving_analysis.Finalize()
+
+        if self.is_remeshing_used:
+            self.remeshing_process.ExecuteFinalize()
+
+    # --------------------------------------------------------------------------
+    @staticmethod
+    def __AddDefaultProblemData(mesh_solver_settings):
+        problem_data = KM.Parameters("""{
+            "echo_level"    : 0,
+            "start_time"    : 0.0,
+            "end_time"      : 1.0,
+            "parallel_type" : "OpenMP"
+        }""")
+
+        mesh_solver_settings.AddValue("problem_data", problem_data)
+
+    # --------------------------------------------------------------------------
+    @staticmethod
+    def __FixWholeSurface(optimization_model_part, mesh_solver_settings):
+        optimization_model_part.CreateSubModelPart("auto_surface_nodes")
+
+        auto_process_settings = KM.Parameters(
+            """
+            {
+                "python_module" : "fix_vector_variable_process",
+                "kratos_module" : "KratosMultiphysics",
+                "help"          : "This process fixes the selected components of a given vector variable without modifying the value of the variable.",
+                "process_name"  : "FixVectorVariableProcess",
+                "Parameters"    : {
+                    "model_part_name"      : \""""+str(optimization_model_part.Name)+""".auto_surface_nodes\",
+                    "variable_name"        : "MESH_DISPLACEMENT",
+                    "constrained"          : [true,true,true]
+                }
+            }
+            """)
+
+        KM.Logger.PrintInfo("ShapeOpt", "Add automatic process to fix the whole surface to mesh motion solver:")
+        mesh_solver_settings["processes"]["boundary_conditions_process_list"].Append(auto_process_settings)
+
+    # --------------------------------------------------------------------------
+    def __CheckAndSetAutomaticMeshRefinementSettings(self, parameters):
+        if (parameters.Has("interpolate_nodal_values")):
+            if (parameters["interpolate_nodal_values"].GetBool()):
+                KM.Logger.PrintWarning("ShapeOpt", "Historical value interpolation is not allowed in automatic remeshing. Turning it off.")
+            parameters["interpolate_nodal_values"].SetBool(False)
+        else:
+            parameters.AddBool("interpolate_nodal_values", False)
+
+        if (parameters.Has("interpolate_non_historical")):
+            if (parameters["interpolate_non_historical"].GetBool()):
+                KM.Logger.PrintWarning("ShapeOpt", "Non-historical value interpolation is not allowed in automatic remeshing. Turning it off.")
+            parameters["interpolate_non_historical"].SetBool(False)
+        else:
+            parameters.AddBool("interpolate_non_historical", False)
+
+        if (parameters.Has("extrapolate_contour_values")):
+            if (parameters["extrapolate_contour_values"].GetBool()):
+                KM.Logger.PrintWarning("ShapeOpt", "Value extrapolation is not allowed in automatic remeshing. Turning it off.")
+            parameters["extrapolate_contour_values"].SetBool(False)
+        else:
+            parameters.AddBool("extrapolate_contour_values", False)
+
+        if (parameters.Has("model_part_name")):
+            if (parameters["model_part_name"].GetString() != self.OptimizationModelPart.Name):
+                KM.Logger.PrintWarning("ShapeOpt", "Mismatching model part name provided for automatic remeshing [ " + parameters["model_part_name"].GetString() + " ]. Using the optimization model part [ " + self.OptimizationModelPart.Name + " ].")
+            parameters["model_part_name"].SetString(self.OptimizationModelPart.Name)
+        else:
+            parameters.AddString("model_part_name", self.OptimizationModelPart.Name)
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_base.py

 * *Ordering differences only*

```diff
@@ -1,22 +1,22 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#
-# ==============================================================================
-
-
-# ==============================================================================
-class MeshController:
-    # --------------------------------------------------------------------------
-    def Initialize(self):
-        pass
-
-    # --------------------------------------------------------------------------
-    def UpdateMeshAccordingInputVariable(self, variable):
-        raise NotImplementedError("Mesh controller base class is called. Please check your implementation of the function >> UpdateMeshAccordingInputVariable << .")
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#
+# ==============================================================================
+
+
+# ==============================================================================
+class MeshController:
+    # --------------------------------------------------------------------------
+    def Initialize(self):
+        pass
+
+    # --------------------------------------------------------------------------
+    def UpdateMeshAccordingInputVariable(self, variable):
+        raise NotImplementedError("Mesh controller base class is called. Please check your implementation of the function >> UpdateMeshAccordingInputVariable << .")
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/TemplateMainKratosShapeOptimization.py

 * *Ordering differences only*

```diff
@@ -1,31 +1,31 @@
-import KratosMultiphysics
-from KratosMultiphysics.ShapeOptimizationApplication.optimizer_factory import Optimizer
-
-import shutil
-import os, time, datetime
-
-if __name__ == "__main__":
-    from sys import argv
-
-    if len(argv) > 2:
-        err_msg =  'Too many input arguments!\n'
-        err_msg += 'Use this script in the following way:\n'
-        err_msg += '- With default ProjectParameters (read from "ProjectParameters.json"):\n'
-        err_msg += '    "python3 structural_mechanics_analysis.py"\n'
-        err_msg += '- With custom ProjectParameters:\n'
-        err_msg += '    "python3 structural_mechanics_analysis.py CustomProjectParameters.json"\n'
-        raise Exception(err_msg)
-
-    if len(argv) == 2: # ProjectParameters is being passed from outside
-        project_parameters_file_name = argv[1]
-    else: # using default name
-        project_parameters_file_name = "optimization_parameters.json"
-
-    with open(project_parameters_file_name,'r') as parameter_file:
-        parameters = KratosMultiphysics.Parameters(parameter_file.read())
-
-    model = KratosMultiphysics.Model()
-    # Create optimizer and perform optimization
-    optimizer = Optimizer(model, parameters["optimization_settings"])
-    optimizer.Optimize()
+import KratosMultiphysics
+from KratosMultiphysics.ShapeOptimizationApplication.optimizer_factory import Optimizer
+
+import shutil
+import os, time, datetime
+
+if __name__ == "__main__":
+    from sys import argv
+
+    if len(argv) > 2:
+        err_msg =  'Too many input arguments!\n'
+        err_msg += 'Use this script in the following way:\n'
+        err_msg += '- With default ProjectParameters (read from "ProjectParameters.json"):\n'
+        err_msg += '    "python3 structural_mechanics_analysis.py"\n'
+        err_msg += '- With custom ProjectParameters:\n'
+        err_msg += '    "python3 structural_mechanics_analysis.py CustomProjectParameters.json"\n'
+        raise Exception(err_msg)
+
+    if len(argv) == 2: # ProjectParameters is being passed from outside
+        project_parameters_file_name = argv[1]
+    else: # using default name
+        project_parameters_file_name = "optimization_parameters.json"
+
+    with open(project_parameters_file_name,'r') as parameter_file:
+        parameters = KratosMultiphysics.Parameters(parameter_file.read())
+
+    model = KratosMultiphysics.Model()
+    # Create optimizer and perform optimization
+    optimizer = Optimizer(model, parameters["optimization_settings"])
+    optimizer.Optimize()
     shutil.copyfile("optimization_parameters.json", "Optimization_Results/optimization_parameters.json")
```

## KratosMultiphysics/ShapeOptimizationApplication/mapper_factory.py

 * *Ordering differences only*

```diff
@@ -1,100 +1,100 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#
-# ==============================================================================
-
-
-# Kratos Core and Apps
-import KratosMultiphysics as KM
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-from .mapping import in_plane_vertex_morphing_mapper, sliding_vertex_morphing_mapper
-
-# ==============================================================================
-def CreateMapper(origin_model_part, destination_model_part, mapper_settings):
-    default_settings = KM.Parameters("""
-    {
-        "filter_function_type"       : "linear",
-        "filter_radius"              : 0.000000000001,
-        "max_nodes_in_filter_radius" : 10000,
-        "matrix_free_filtering"      : false,
-        "consistent_mapping"         : false,
-        "improved_integration"       : false,
-        "integration_method"         : "gauss_integration",
-        "number_of_gauss_points"     : 5,
-        "in_plane_morphing"          : false,
-        "in_plane_morphing_settings" : {},
-        "sliding_morphing"           : false,
-        "sliding_morphing_settings"  : {},
-        "plane_symmetry"             : false,
-        "plane_symmetry_settings"    : {
-            "point" : [0.0, 0.0, 0.0],
-            "normal": [0.0, 0.0, 0.0]
-        },
-        "revolution"                 : false,
-        "revolution_settings"        : {
-            "point" : [0.0, 0.0, 0.0],
-            "normal": [0.0, 0.0, 0.0]
-        },
-        "adaptive_filter_settings"   : {
-            "adaptive_filter_method": "curvature_based",
-            "radius_function": "analytic",
-            "radius_function_parameter": 1,
-            "minimum_filter_radius": 1e-3,
-            "curvature_limit": 1e-3,
-            "filter_radius_smoothing_iterations": 10
-        }
-    }""")
-
-    mapper_vertex_morphing_matrix_free = KSO.MapperVertexMorphingMatrixFree
-    mapper_vertex_morphing_improved_integration = KSO.MapperVertexMorphingImprovedIntegration
-    mapper_vertex_morphing_symmetric = KSO.MapperVertexMorphingSymmetric
-    mapper_vertex_morphing = KSO.MapperVertexMorphing
-    if mapper_settings.Has("filter_radius") and mapper_settings["filter_radius"].IsString():
-        if mapper_settings["filter_radius"].GetString() == "adaptive":
-            if mapper_settings.Has("adaptive_filter_method") and mapper_settings["adaptive_filter_method"].GetString() != "curvature_based":
-                raise Exception("For now, only \"curvature_based\" is available for \"adaptive_filter_method\".")
-            else:
-                mapper_vertex_morphing_matrix_free = KSO.MapperVertexMorphingMatrixFreeAdaptiveRadius
-                mapper_vertex_morphing_improved_integration = KSO.MapperVertexMorphingImprovedIntegrationAdaptiveRadius
-                mapper_vertex_morphing_symmetric = KSO.MapperVertexMorphingSymmetricAdaptiveRadius
-                mapper_vertex_morphing = KSO.MapperVertexMorphingAdaptiveRadius
-
-                if mapper_settings.Has("in_plane_morphing"):
-                    if mapper_settings["in_plane_morphing"].GetBool():
-                        raise Exception("\"in_plane_morphing\" is not yet supported with \"adaptive\" filter radius.")
-                mapper_settings["filter_radius"].SetDouble(-1.0)
-        else:
-            raise Exception("\"filter_radius\" either should be double value or \"adaptive\".")
-
-    mapper_settings.ValidateAndAssignDefaults(default_settings)
-
-    if mapper_settings["in_plane_morphing"].GetBool():
-        return in_plane_vertex_morphing_mapper.InPlaneVertexMorphingMapper(origin_model_part, destination_model_part, mapper_settings)
-    elif mapper_settings["sliding_morphing"].GetBool():
-        return sliding_vertex_morphing_mapper.SlidingVertexMorphingMapper(origin_model_part, destination_model_part, mapper_settings)
-    elif mapper_settings["matrix_free_filtering"].GetBool():
-        if mapper_settings["consistent_mapping"].GetBool():
-             raise ValueError ("Matrix free mapper has no option to map consistently yet!")
-        if mapper_settings["improved_integration"].GetBool():
-             raise ValueError ("Matrix free mapper does not yet allow for an improved integration!")
-        else:
-            return mapper_vertex_morphing_matrix_free(origin_model_part, destination_model_part, mapper_settings)
-    else:
-        if mapper_settings["revolution"].GetBool() and mapper_settings["plane_symmetry"].GetBool():
-            raise RuntimeError("revolution and plane_symmetry can not be combined!")
-
-        if mapper_settings["improved_integration"].GetBool():
-            return mapper_vertex_morphing_improved_integration(origin_model_part, destination_model_part, mapper_settings)
-        elif mapper_settings["plane_symmetry"].GetBool():
-            return mapper_vertex_morphing_symmetric(origin_model_part, destination_model_part, mapper_settings)
-        elif mapper_settings["revolution"].GetBool():
-            return mapper_vertex_morphing_symmetric(origin_model_part, destination_model_part, mapper_settings)
-        else:
-            return mapper_vertex_morphing(origin_model_part, destination_model_part, mapper_settings)
-
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#
+# ==============================================================================
+
+
+# Kratos Core and Apps
+import KratosMultiphysics as KM
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+from .mapping import in_plane_vertex_morphing_mapper, sliding_vertex_morphing_mapper
+
+# ==============================================================================
+def CreateMapper(origin_model_part, destination_model_part, mapper_settings):
+    default_settings = KM.Parameters("""
+    {
+        "filter_function_type"       : "linear",
+        "filter_radius"              : 0.000000000001,
+        "max_nodes_in_filter_radius" : 10000,
+        "matrix_free_filtering"      : false,
+        "consistent_mapping"         : false,
+        "improved_integration"       : false,
+        "integration_method"         : "gauss_integration",
+        "number_of_gauss_points"     : 5,
+        "in_plane_morphing"          : false,
+        "in_plane_morphing_settings" : {},
+        "sliding_morphing"           : false,
+        "sliding_morphing_settings"  : {},
+        "plane_symmetry"             : false,
+        "plane_symmetry_settings"    : {
+            "point" : [0.0, 0.0, 0.0],
+            "normal": [0.0, 0.0, 0.0]
+        },
+        "revolution"                 : false,
+        "revolution_settings"        : {
+            "point" : [0.0, 0.0, 0.0],
+            "normal": [0.0, 0.0, 0.0]
+        },
+        "adaptive_filter_settings"   : {
+            "adaptive_filter_method": "curvature_based",
+            "radius_function": "analytic",
+            "radius_function_parameter": 1,
+            "minimum_filter_radius": 1e-3,
+            "curvature_limit": 1e-3,
+            "filter_radius_smoothing_iterations": 10
+        }
+    }""")
+
+    mapper_vertex_morphing_matrix_free = KSO.MapperVertexMorphingMatrixFree
+    mapper_vertex_morphing_improved_integration = KSO.MapperVertexMorphingImprovedIntegration
+    mapper_vertex_morphing_symmetric = KSO.MapperVertexMorphingSymmetric
+    mapper_vertex_morphing = KSO.MapperVertexMorphing
+    if mapper_settings.Has("filter_radius") and mapper_settings["filter_radius"].IsString():
+        if mapper_settings["filter_radius"].GetString() == "adaptive":
+            if mapper_settings.Has("adaptive_filter_method") and mapper_settings["adaptive_filter_method"].GetString() != "curvature_based":
+                raise Exception("For now, only \"curvature_based\" is available for \"adaptive_filter_method\".")
+            else:
+                mapper_vertex_morphing_matrix_free = KSO.MapperVertexMorphingMatrixFreeAdaptiveRadius
+                mapper_vertex_morphing_improved_integration = KSO.MapperVertexMorphingImprovedIntegrationAdaptiveRadius
+                mapper_vertex_morphing_symmetric = KSO.MapperVertexMorphingSymmetricAdaptiveRadius
+                mapper_vertex_morphing = KSO.MapperVertexMorphingAdaptiveRadius
+
+                if mapper_settings.Has("in_plane_morphing"):
+                    if mapper_settings["in_plane_morphing"].GetBool():
+                        raise Exception("\"in_plane_morphing\" is not yet supported with \"adaptive\" filter radius.")
+                mapper_settings["filter_radius"].SetDouble(-1.0)
+        else:
+            raise Exception("\"filter_radius\" either should be double value or \"adaptive\".")
+
+    mapper_settings.ValidateAndAssignDefaults(default_settings)
+
+    if mapper_settings["in_plane_morphing"].GetBool():
+        return in_plane_vertex_morphing_mapper.InPlaneVertexMorphingMapper(origin_model_part, destination_model_part, mapper_settings)
+    elif mapper_settings["sliding_morphing"].GetBool():
+        return sliding_vertex_morphing_mapper.SlidingVertexMorphingMapper(origin_model_part, destination_model_part, mapper_settings)
+    elif mapper_settings["matrix_free_filtering"].GetBool():
+        if mapper_settings["consistent_mapping"].GetBool():
+             raise ValueError ("Matrix free mapper has no option to map consistently yet!")
+        if mapper_settings["improved_integration"].GetBool():
+             raise ValueError ("Matrix free mapper does not yet allow for an improved integration!")
+        else:
+            return mapper_vertex_morphing_matrix_free(origin_model_part, destination_model_part, mapper_settings)
+    else:
+        if mapper_settings["revolution"].GetBool() and mapper_settings["plane_symmetry"].GetBool():
+            raise RuntimeError("revolution and plane_symmetry can not be combined!")
+
+        if mapper_settings["improved_integration"].GetBool():
+            return mapper_vertex_morphing_improved_integration(origin_model_part, destination_model_part, mapper_settings)
+        elif mapper_settings["plane_symmetry"].GetBool():
+            return mapper_vertex_morphing_symmetric(origin_model_part, destination_model_part, mapper_settings)
+        elif mapper_settings["revolution"].GetBool():
+            return mapper_vertex_morphing_symmetric(origin_model_part, destination_model_part, mapper_settings)
+        else:
+            return mapper_vertex_morphing(origin_model_part, destination_model_part, mapper_settings)
+
 # ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_math.py

 * *Ordering differences only*

```diff
@@ -1,443 +1,443 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#
-# ==============================================================================
-
-
-# importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Import additional libraries
-import math
-
-# ==============================================================================
-def SafeConvertVectorToMatrix(_L):
-    if IsVector(_L):
-        return [_L]
-    else:
-        return _L
-
-# ------------------------------------------------------------------------------
-def IsVector(_X):
-    if len(_X)==0 or isinstance(_X[0],(float,int)):
-        return True
-    else:
-        return False
-
-# ------------------------------------------------------------------------------
-def IsEmpty(_A):
-    _A = SafeConvertVectorToMatrix(_A)
-
-    if len(_A)==0 or len(_A[0])==0:
-        return True
-    return False
-
-# ------------------------------------------------------------------------------
-def ZeroVector(m):
-    return [0.0 for i in range(m)]
-
-# ------------------------------------------------------------------------------
-def ZeroMatrix(m,n):
-    A = [[0.0 for i in range(m)] for j in range(n)]
-    return A
-
-# ------------------------------------------------------------------------------
-def Ones(n):
-    return [1.0 for i in range(n)]
-
-# ------------------------------------------------------------------------------
-def RowSize(_A):
-    _A = SafeConvertVectorToMatrix(_A)
-
-    if len(_A)==0:
-        return 0
-    return len(_A[0])
-
-# ------------------------------------------------------------------------------
-def CollSize(_A):
-    _A = SafeConvertVectorToMatrix(_A)
-
-    return len(_A)
-
-# ------------------------------------------------------------------------------
-# horizontal concatenation
-def HorzCat(_A,_B):
-    _A = SafeConvertVectorToMatrix(_A)
-    _B = SafeConvertVectorToMatrix(_B)
-
-    if IsEmpty(_B):
-        return _A
-    if IsEmpty(_A):
-        return _B
-
-    return _A+_B
-
-# ------------------------------------------------------------------------------
-# vertical concatenation
-def VertCat(_A,_B):
-    _A = SafeConvertVectorToMatrix(_A)
-    _B = SafeConvertVectorToMatrix(_B)
-
-    if IsEmpty(_B):
-        return _A
-    if IsEmpty(_A):
-        return _B
-
-    coll_size_A = CollSize(_A)
-    coll_size_B = CollSize(_B)
-
-    if coll_size_A!=coll_size_B:
-        raise ValueError("custom_math::VertCat: Wrong size in vertical concatenation detected!")
-
-    _C = []
-    for i in range(coll_size_A):
-        _C.append(_A[i]+_B[i])
-
-    if CollSize(_C) == 1:
-        return _C[0]
-    else:
-        return _C
-
-# ------------------------------------------------------------------------------
-def Norm2(_X):
-    temp_vec = [x**2 for x in _X]
-    temp_sum = sum(temp_vec)
-    return math.sqrt(temp_sum)
-
-# ------------------------------------------------------------------------------
-def NormInf3D(_X):
-    temp_vec = [_X[3*i]**2 + _X[3*i+1]**2 + _X[3*i+2]**2 for i in range(int(len(_X)/3))]
-    max_squared_value = max(temp_vec)
-    return math.sqrt(max_squared_value)
-
-# ------------------------------------------------------------------------------
-def Dot(_X, _Y):
-    if len(_X) != len(_Y):
-        raise RuntimeError("custom_math::Dot: Dot product to be computed but _X and _Y do not have the same dimension!")
-    return sum( [_X[i]*_Y[i] for i in range(len(_X))] )
-
-# ------------------------------------------------------------------------------
-def Plus(_X, _Y):
-    if len(_X)!=len(_Y):
-        raise ValueError("custom_math::Plus: Wrong size of input variables!")
-    return [ _X[i]+_Y[i] for i in range(len(_X)) ]
-
-# ------------------------------------------------------------------------------
-def ScalarVectorProduct(scal, _X):
-    return [x*scal for x in _X]
-
-# ------------------------------------------------------------------------------
-def ScalarMatrixProduct(scal, _A):
-    return [ [ scal*_A[i][j] for j in range(RowSize(_A)) ] for i in range(CollSize(_A)) ]
-
-# ------------------------------------------------------------------------------
-def Prod(_A,_B):
-    _A = SafeConvertVectorToMatrix(_A)
-    _B = SafeConvertVectorToMatrix(_B)
-
-    row_size_A = RowSize(_A)
-    row_size_B = RowSize(_B)
-    coll_size_A = CollSize(_A)
-    coll_size_B = CollSize(_B)
-
-    if IsEmpty(_A) or IsEmpty(_B):
-        return []
-    if coll_size_A!=row_size_B:
-        raise ValueError("cusom_math::Prod: Product detected wrong size in the specified input array!")
-
-    result = [ [ sum(_A[k][i]*_B[j][k] for k in range(coll_size_A)) for i in range(row_size_A) ] for j in range(coll_size_B) ]
-
-    if CollSize(result) == 1:
-        return result[0]
-    else:
-        return result
-
-# ------------------------------------------------------------------------------
-def ElemwiseProd(_X,_Y):
-    if len(_X)!=len(_Y):
-        raise ValueError("custom_math::ElemwiseProd: Wrong size of input vectors!")
-    return [_X[i]*_Y[i] for i in range(len(_X))]
-
-# ------------------------------------------------------------------------------
-def Trans(_A):
-    _A = SafeConvertVectorToMatrix(_A)
-
-    if IsEmpty(_A):
-        return []
-    return list(map(list, zip(*_A)))
-# ------------------------------------------------------------------------------
-def Minus(_X,_Y):
-    return [ _X[i]-_Y[i] for i in range(len(_X))]
-
-# ------------------------------------------------------------------------------
-def TranslateToNewBasis(_A, basis):
-    _A = SafeConvertVectorToMatrix(_A)
-
-    if IsEmpty(_A):
-        return []
-
-    trans_basis = Trans(basis)
-    return Prod(trans_basis,_A)
-
-# ------------------------------------------------------------------------------
-def TranslateToOriginalBasis(_A, basis):
-    _A = SafeConvertVectorToMatrix(_A)
-
-    if IsEmpty(_A):
-        return []
-
-    return Prod(basis,_A)
-
-# ------------------------------------------------------------------------------
-def SolveLinearSystem(A,b):
-    A = Trans(A)
-    n = len(A)
-    for i in range(n):
-        A[i].append(b[i])
-    for i in range(0, n):
-        # Search for maximum in this column
-        maxEl = abs(A[i][i])
-        maxRow = i
-        for k in range(i+1, n):
-            if abs(A[k][i]) > maxEl:
-                maxEl = abs(A[k][i])
-                maxRow = k
-
-        # Swap maximum row with current row (column by column)
-        for k in range(i, n+1):
-            tmp = A[maxRow][k]
-            A[maxRow][k] = A[i][k]
-            A[i][k] = tmp
-
-        # Make all rows below this one 0 in current column
-        for k in range(i+1, n):
-            c = -A[k][i]/A[i][i]
-            for j in range(i, n+1):
-                if i == j:
-                    A[k][j] = 0
-                else:
-                    A[k][j] += c * A[i][j]
-
-    # Solve equation Ax=b for an upper triangular matrix A
-    x = [0 for i in range(n)]
-    for i in range(n-1, -1, -1):
-        x[i] = A[i][n]/A[i][i]
-        for k in range(i-1, -1, -1):
-            A[k][n] -= A[k][i] * x[i]
-    return x
-
-# ------------------------------------------------------------------------------
-# Interior point algorithm
-# Nocedal & Wright, Numerical Optimization, 2nd edition, Algorithm 16.4, p.484, Springer
-# Solves min x'*x with A*x<=b (x is of size n and A of size m*n)
-# Note that original algorithm solves min x'*x with A*x>=b --> negation of input values in the beginning
-def QuadProg(A, b, max_itr, tolerance):
-    m = RowSize(A)
-    n = CollSize(A)
-
-    A = ScalarMatrixProduct(-1.0,A)
-    b = ScalarVectorProduct(-1.0,b)
-
-    def rdrp(x,y,l,A,b):
-        temp_vec = Prod(Trans(A),l)
-        rd = Minus(x,temp_vec)
-
-        temp_vec = Prod(A,x)
-        rp = Minus(Minus(temp_vec,y),b)
-        return (rd,rp)
-
-    def GradResidu(y,l,A):
-        m = RowSize(A)
-        n = CollSize(A)
-        grad = [ZeroVector(n+2*m) for i in range(n+2*m)]
-        for i in range(n):
-            grad[i][i] = 1
-        for i in range(n):
-            for j in range(m):
-                grad[n+m+j][i] = -A[i][j]
-        for i in range(m):
-            for j in range(n):
-                grad[j][n+i] = A[j][i]
-        for i in range(m):
-            grad[n+i][n+i] = -1
-        for i in range(m):
-            grad[n+i][n+m+i] = l[i]
-            grad[n+m+i][n+m+i] = y[i]
-        return grad
-
-    #init
-    x = ZeroVector(n)
-    y = Ones(m) # slack variables
-    l = Ones(m) # lagrange multipliers
-
-    rd, rp = rdrp(x,y,l,A,b)
-    k = 0
-    error = 100000
-    while error>tolerance and k <= max_itr:
-
-        # solve affine delta
-        gradRes = GradResidu(y,l,A)
-        deltaXYLAff = ZeroVector(n+2*m)
-        rhs = ScalarVectorProduct(-1, VertCat(rd,VertCat(rp,ElemwiseProd(y,l))))
-
-        deltaXYLAff = SolveLinearSystem(gradRes,rhs)
-
-        # Drop and error if divergence is detected
-        if Norm2(deltaXYLAff)>1e20:
-            KM.Logger.PrintWarning("ShapeOpt::custom_math::quadprodg", "deltaXYLAff is NAN. The reason is, that feasible domain might be empty. This happens e.g. when the dJdX is parallel to dCdX (like at convergence with a single constraint)")
-            exit_code = 2
-            return
-
-        dxAff = deltaXYLAff[:n]
-        dyAff = deltaXYLAff[n:n+m]
-        dlAff = deltaXYLAff[n+m:]
-
-        mu = Dot(y,l)/m
-        alphaS = 1
-        alphaZ = 1
-        for i in range(m):
-            if dyAff[i]<0:
-                alphaS = min(alphaS, abs(y[i]/dyAff[i]))
-            if dlAff[i]<0:
-                alphaZ = min(alphaZ, abs(l[i]/dlAff[i]))
-        alphaAff = 0.8*min(alphaS,alphaZ)
-
-        muAff = Dot(Plus(y,ScalarVectorProduct(alphaAff,dyAff)),Plus(l,ScalarVectorProduct(alphaAff,dlAff))) / m
-
-        sigma = (muAff/mu)**3
-
-        # solve for delta
-        rhs = ScalarVectorProduct(-1, VertCat(rd,VertCat(rp, Plus( Plus(ElemwiseProd(y,l),ElemwiseProd(dyAff,dlAff)) , ScalarVectorProduct(-sigma*mu,Ones(m)) ))))
-        deltaXYL = SolveLinearSystem(gradRes,rhs)
-
-        dx = deltaXYL[:n]
-        dy = deltaXYL[n:n+m]
-        dl = deltaXYL[n+m:]
-
-        alphaS = 1
-        alphaZ = 1
-        for i in range(m):
-            if dy[i]<0:
-                alphaS = min(alphaS, abs(y[i]/dy[i]))
-            if dl[i]<0:
-                alphaZ = min(alphaZ, abs(l[i]/dl[i]))
-        alpha = 0.8*min(alphaS,alphaZ)
-
-        # apply delta
-        x = Plus(x,ScalarVectorProduct(alpha,dx))
-        y = Plus(y,ScalarVectorProduct(alpha,dy))
-        l = Plus(l,ScalarVectorProduct(alpha,dl))
-        rd,rp = rdrp(x,y,l,A,b)
-        k = k+1
-
-        # Determine current error
-        error = Norm2(VertCat(rd,rp))
-
-    if k==max_itr:
-        raise RuntimeError("custom_math::quadprodg: Suboptimization for projection to halfspaces did not converge in the specified number of iterations")
-    else:
-        # Exit code of 0 if convergence is reached
-        exit_code = 0
-
-    return x, k, error, exit_code
-
-# ------------------------------------------------------------------------------
-def PerformBisectioning(func, a, b, target, tolerance, max_itr):
-
-    fa_value_0, fa_is_converged = func(a)
-    fb_value_0, fb_is_converged = func(b)
-
-    error = None
-    itr = 0
-
-    # Always safe last argument for which function converges and return this if no solution is found
-    if fa_is_converged:
-        last_allowed_function_argument = a
-    elif fb_is_converged:
-        last_allowed_function_argument = b
-
-    # Check special cases
-    if abs(fa_value_0-target) < tolerance:
-        res_function_argument = a
-        error = abs(fa_value_0-target)
-
-    elif abs(fb_value_0-target) < tolerance:
-        res_function_argument = b
-        error = abs(fb_value_0-target)
-
-    elif abs(fa_value_0-fb_value_0) < 1e-13:
-        KM.Logger.PrintWarning("ShapeOpt::PerformBisectioning", "Bisectioning intervall yiels to identical function values!")
-        res_function_argument = a
-        error = abs(fb_value_0-target)
-
-    elif (fa_value_0-target)*(fb_value_0-target)>0:
-        KM.Logger.PrintWarning("ShapeOpt::PerformBisectioning", "Bisectioning on function, that has no root in specified intervall!! Returning the argument which yiels a closer value to the target.")
-
-        if abs(fa_value_0-target) < abs(fb_value_0-target):
-            res_function_argument = a
-            error = fa_value_0-target
-        else:
-            res_function_argument = b
-            error = fb_value_0-target
-
-    # Perform bisectioning if no special case applies
-    else:
-        p = (a + b)/2
-
-        for itr in range(1,max_itr+1):
-            fa_value, fa_is_converged = func(a)
-            fp_value, fp_is_converged = func(p)
-
-            if (fa_value-target)*(fp_value-target) < 0:
-                b = p
-            else:
-                a = p
-
-            p = (a + b)/2
-
-            fp_value, fp_is_converged = func(p)
-            error = abs(fp_value-target)
-
-            if fp_is_converged:
-                last_allowed_function_argument = p
-
-            if itr == max_itr:
-                res_function_argument = last_allowed_function_argument
-                KM.Logger.PrintWarning("ShapeOpt::PerformBisectioning", "Bisectioning did not converge in the specified maximum number of iterations!")
-                break
-
-            elif error < tolerance:
-                res_function_argument = p
-                break
-
-    return res_function_argument, itr, error
-
-# --------------------------------------------------------------------------
-def PerformGramSchmidtOrthogonalization(vector_space):
-    V = vector_space
-    B = []
-
-    # Orthogonalization
-    norm2_V0 = Norm2(V[0])
-    B.append( ScalarVectorProduct(1/norm2_V0,V[0]) )
-    for v in V[1:]:
-        for b in B:
-            norm2_b = Norm2(b)
-            v = Minus( v , ScalarVectorProduct( Dot(v,b)/norm2_b**2 , b ) )
-
-        # Add only if vector is independent
-        norm2_v = Norm2(v)
-        if norm2_v>1e-10:
-            B.append( ScalarVectorProduct(1/norm2_v,v) )
-        else:
-            KM.Logger.PrintWarning("ShapeOpt::PerformGramSchmidtOrthogonalization", "Zero basis vector after Gram-Schmidt orthogonalization!")
-            B.append(v)
-
-    return B
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#
+# ==============================================================================
+
+
+# importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Import additional libraries
+import math
+
+# ==============================================================================
+def SafeConvertVectorToMatrix(_L):
+    if IsVector(_L):
+        return [_L]
+    else:
+        return _L
+
+# ------------------------------------------------------------------------------
+def IsVector(_X):
+    if len(_X)==0 or isinstance(_X[0],(float,int)):
+        return True
+    else:
+        return False
+
+# ------------------------------------------------------------------------------
+def IsEmpty(_A):
+    _A = SafeConvertVectorToMatrix(_A)
+
+    if len(_A)==0 or len(_A[0])==0:
+        return True
+    return False
+
+# ------------------------------------------------------------------------------
+def ZeroVector(m):
+    return [0.0 for i in range(m)]
+
+# ------------------------------------------------------------------------------
+def ZeroMatrix(m,n):
+    A = [[0.0 for i in range(m)] for j in range(n)]
+    return A
+
+# ------------------------------------------------------------------------------
+def Ones(n):
+    return [1.0 for i in range(n)]
+
+# ------------------------------------------------------------------------------
+def RowSize(_A):
+    _A = SafeConvertVectorToMatrix(_A)
+
+    if len(_A)==0:
+        return 0
+    return len(_A[0])
+
+# ------------------------------------------------------------------------------
+def CollSize(_A):
+    _A = SafeConvertVectorToMatrix(_A)
+
+    return len(_A)
+
+# ------------------------------------------------------------------------------
+# horizontal concatenation
+def HorzCat(_A,_B):
+    _A = SafeConvertVectorToMatrix(_A)
+    _B = SafeConvertVectorToMatrix(_B)
+
+    if IsEmpty(_B):
+        return _A
+    if IsEmpty(_A):
+        return _B
+
+    return _A+_B
+
+# ------------------------------------------------------------------------------
+# vertical concatenation
+def VertCat(_A,_B):
+    _A = SafeConvertVectorToMatrix(_A)
+    _B = SafeConvertVectorToMatrix(_B)
+
+    if IsEmpty(_B):
+        return _A
+    if IsEmpty(_A):
+        return _B
+
+    coll_size_A = CollSize(_A)
+    coll_size_B = CollSize(_B)
+
+    if coll_size_A!=coll_size_B:
+        raise ValueError("custom_math::VertCat: Wrong size in vertical concatenation detected!")
+
+    _C = []
+    for i in range(coll_size_A):
+        _C.append(_A[i]+_B[i])
+
+    if CollSize(_C) == 1:
+        return _C[0]
+    else:
+        return _C
+
+# ------------------------------------------------------------------------------
+def Norm2(_X):
+    temp_vec = [x**2 for x in _X]
+    temp_sum = sum(temp_vec)
+    return math.sqrt(temp_sum)
+
+# ------------------------------------------------------------------------------
+def NormInf3D(_X):
+    temp_vec = [_X[3*i]**2 + _X[3*i+1]**2 + _X[3*i+2]**2 for i in range(int(len(_X)/3))]
+    max_squared_value = max(temp_vec)
+    return math.sqrt(max_squared_value)
+
+# ------------------------------------------------------------------------------
+def Dot(_X, _Y):
+    if len(_X) != len(_Y):
+        raise RuntimeError("custom_math::Dot: Dot product to be computed but _X and _Y do not have the same dimension!")
+    return sum( [_X[i]*_Y[i] for i in range(len(_X))] )
+
+# ------------------------------------------------------------------------------
+def Plus(_X, _Y):
+    if len(_X)!=len(_Y):
+        raise ValueError("custom_math::Plus: Wrong size of input variables!")
+    return [ _X[i]+_Y[i] for i in range(len(_X)) ]
+
+# ------------------------------------------------------------------------------
+def ScalarVectorProduct(scal, _X):
+    return [x*scal for x in _X]
+
+# ------------------------------------------------------------------------------
+def ScalarMatrixProduct(scal, _A):
+    return [ [ scal*_A[i][j] for j in range(RowSize(_A)) ] for i in range(CollSize(_A)) ]
+
+# ------------------------------------------------------------------------------
+def Prod(_A,_B):
+    _A = SafeConvertVectorToMatrix(_A)
+    _B = SafeConvertVectorToMatrix(_B)
+
+    row_size_A = RowSize(_A)
+    row_size_B = RowSize(_B)
+    coll_size_A = CollSize(_A)
+    coll_size_B = CollSize(_B)
+
+    if IsEmpty(_A) or IsEmpty(_B):
+        return []
+    if coll_size_A!=row_size_B:
+        raise ValueError("cusom_math::Prod: Product detected wrong size in the specified input array!")
+
+    result = [ [ sum(_A[k][i]*_B[j][k] for k in range(coll_size_A)) for i in range(row_size_A) ] for j in range(coll_size_B) ]
+
+    if CollSize(result) == 1:
+        return result[0]
+    else:
+        return result
+
+# ------------------------------------------------------------------------------
+def ElemwiseProd(_X,_Y):
+    if len(_X)!=len(_Y):
+        raise ValueError("custom_math::ElemwiseProd: Wrong size of input vectors!")
+    return [_X[i]*_Y[i] for i in range(len(_X))]
+
+# ------------------------------------------------------------------------------
+def Trans(_A):
+    _A = SafeConvertVectorToMatrix(_A)
+
+    if IsEmpty(_A):
+        return []
+    return list(map(list, zip(*_A)))
+# ------------------------------------------------------------------------------
+def Minus(_X,_Y):
+    return [ _X[i]-_Y[i] for i in range(len(_X))]
+
+# ------------------------------------------------------------------------------
+def TranslateToNewBasis(_A, basis):
+    _A = SafeConvertVectorToMatrix(_A)
+
+    if IsEmpty(_A):
+        return []
+
+    trans_basis = Trans(basis)
+    return Prod(trans_basis,_A)
+
+# ------------------------------------------------------------------------------
+def TranslateToOriginalBasis(_A, basis):
+    _A = SafeConvertVectorToMatrix(_A)
+
+    if IsEmpty(_A):
+        return []
+
+    return Prod(basis,_A)
+
+# ------------------------------------------------------------------------------
+def SolveLinearSystem(A,b):
+    A = Trans(A)
+    n = len(A)
+    for i in range(n):
+        A[i].append(b[i])
+    for i in range(0, n):
+        # Search for maximum in this column
+        maxEl = abs(A[i][i])
+        maxRow = i
+        for k in range(i+1, n):
+            if abs(A[k][i]) > maxEl:
+                maxEl = abs(A[k][i])
+                maxRow = k
+
+        # Swap maximum row with current row (column by column)
+        for k in range(i, n+1):
+            tmp = A[maxRow][k]
+            A[maxRow][k] = A[i][k]
+            A[i][k] = tmp
+
+        # Make all rows below this one 0 in current column
+        for k in range(i+1, n):
+            c = -A[k][i]/A[i][i]
+            for j in range(i, n+1):
+                if i == j:
+                    A[k][j] = 0
+                else:
+                    A[k][j] += c * A[i][j]
+
+    # Solve equation Ax=b for an upper triangular matrix A
+    x = [0 for i in range(n)]
+    for i in range(n-1, -1, -1):
+        x[i] = A[i][n]/A[i][i]
+        for k in range(i-1, -1, -1):
+            A[k][n] -= A[k][i] * x[i]
+    return x
+
+# ------------------------------------------------------------------------------
+# Interior point algorithm
+# Nocedal & Wright, Numerical Optimization, 2nd edition, Algorithm 16.4, p.484, Springer
+# Solves min x'*x with A*x<=b (x is of size n and A of size m*n)
+# Note that original algorithm solves min x'*x with A*x>=b --> negation of input values in the beginning
+def QuadProg(A, b, max_itr, tolerance):
+    m = RowSize(A)
+    n = CollSize(A)
+
+    A = ScalarMatrixProduct(-1.0,A)
+    b = ScalarVectorProduct(-1.0,b)
+
+    def rdrp(x,y,l,A,b):
+        temp_vec = Prod(Trans(A),l)
+        rd = Minus(x,temp_vec)
+
+        temp_vec = Prod(A,x)
+        rp = Minus(Minus(temp_vec,y),b)
+        return (rd,rp)
+
+    def GradResidu(y,l,A):
+        m = RowSize(A)
+        n = CollSize(A)
+        grad = [ZeroVector(n+2*m) for i in range(n+2*m)]
+        for i in range(n):
+            grad[i][i] = 1
+        for i in range(n):
+            for j in range(m):
+                grad[n+m+j][i] = -A[i][j]
+        for i in range(m):
+            for j in range(n):
+                grad[j][n+i] = A[j][i]
+        for i in range(m):
+            grad[n+i][n+i] = -1
+        for i in range(m):
+            grad[n+i][n+m+i] = l[i]
+            grad[n+m+i][n+m+i] = y[i]
+        return grad
+
+    #init
+    x = ZeroVector(n)
+    y = Ones(m) # slack variables
+    l = Ones(m) # lagrange multipliers
+
+    rd, rp = rdrp(x,y,l,A,b)
+    k = 0
+    error = 100000
+    while error>tolerance and k <= max_itr:
+
+        # solve affine delta
+        gradRes = GradResidu(y,l,A)
+        deltaXYLAff = ZeroVector(n+2*m)
+        rhs = ScalarVectorProduct(-1, VertCat(rd,VertCat(rp,ElemwiseProd(y,l))))
+
+        deltaXYLAff = SolveLinearSystem(gradRes,rhs)
+
+        # Drop and error if divergence is detected
+        if Norm2(deltaXYLAff)>1e20:
+            KM.Logger.PrintWarning("ShapeOpt::custom_math::quadprodg", "deltaXYLAff is NAN. The reason is, that feasible domain might be empty. This happens e.g. when the dJdX is parallel to dCdX (like at convergence with a single constraint)")
+            exit_code = 2
+            return
+
+        dxAff = deltaXYLAff[:n]
+        dyAff = deltaXYLAff[n:n+m]
+        dlAff = deltaXYLAff[n+m:]
+
+        mu = Dot(y,l)/m
+        alphaS = 1
+        alphaZ = 1
+        for i in range(m):
+            if dyAff[i]<0:
+                alphaS = min(alphaS, abs(y[i]/dyAff[i]))
+            if dlAff[i]<0:
+                alphaZ = min(alphaZ, abs(l[i]/dlAff[i]))
+        alphaAff = 0.8*min(alphaS,alphaZ)
+
+        muAff = Dot(Plus(y,ScalarVectorProduct(alphaAff,dyAff)),Plus(l,ScalarVectorProduct(alphaAff,dlAff))) / m
+
+        sigma = (muAff/mu)**3
+
+        # solve for delta
+        rhs = ScalarVectorProduct(-1, VertCat(rd,VertCat(rp, Plus( Plus(ElemwiseProd(y,l),ElemwiseProd(dyAff,dlAff)) , ScalarVectorProduct(-sigma*mu,Ones(m)) ))))
+        deltaXYL = SolveLinearSystem(gradRes,rhs)
+
+        dx = deltaXYL[:n]
+        dy = deltaXYL[n:n+m]
+        dl = deltaXYL[n+m:]
+
+        alphaS = 1
+        alphaZ = 1
+        for i in range(m):
+            if dy[i]<0:
+                alphaS = min(alphaS, abs(y[i]/dy[i]))
+            if dl[i]<0:
+                alphaZ = min(alphaZ, abs(l[i]/dl[i]))
+        alpha = 0.8*min(alphaS,alphaZ)
+
+        # apply delta
+        x = Plus(x,ScalarVectorProduct(alpha,dx))
+        y = Plus(y,ScalarVectorProduct(alpha,dy))
+        l = Plus(l,ScalarVectorProduct(alpha,dl))
+        rd,rp = rdrp(x,y,l,A,b)
+        k = k+1
+
+        # Determine current error
+        error = Norm2(VertCat(rd,rp))
+
+    if k==max_itr:
+        raise RuntimeError("custom_math::quadprodg: Suboptimization for projection to halfspaces did not converge in the specified number of iterations")
+    else:
+        # Exit code of 0 if convergence is reached
+        exit_code = 0
+
+    return x, k, error, exit_code
+
+# ------------------------------------------------------------------------------
+def PerformBisectioning(func, a, b, target, tolerance, max_itr):
+
+    fa_value_0, fa_is_converged = func(a)
+    fb_value_0, fb_is_converged = func(b)
+
+    error = None
+    itr = 0
+
+    # Always safe last argument for which function converges and return this if no solution is found
+    if fa_is_converged:
+        last_allowed_function_argument = a
+    elif fb_is_converged:
+        last_allowed_function_argument = b
+
+    # Check special cases
+    if abs(fa_value_0-target) < tolerance:
+        res_function_argument = a
+        error = abs(fa_value_0-target)
+
+    elif abs(fb_value_0-target) < tolerance:
+        res_function_argument = b
+        error = abs(fb_value_0-target)
+
+    elif abs(fa_value_0-fb_value_0) < 1e-13:
+        KM.Logger.PrintWarning("ShapeOpt::PerformBisectioning", "Bisectioning intervall yiels to identical function values!")
+        res_function_argument = a
+        error = abs(fb_value_0-target)
+
+    elif (fa_value_0-target)*(fb_value_0-target)>0:
+        KM.Logger.PrintWarning("ShapeOpt::PerformBisectioning", "Bisectioning on function, that has no root in specified intervall!! Returning the argument which yiels a closer value to the target.")
+
+        if abs(fa_value_0-target) < abs(fb_value_0-target):
+            res_function_argument = a
+            error = fa_value_0-target
+        else:
+            res_function_argument = b
+            error = fb_value_0-target
+
+    # Perform bisectioning if no special case applies
+    else:
+        p = (a + b)/2
+
+        for itr in range(1,max_itr+1):
+            fa_value, fa_is_converged = func(a)
+            fp_value, fp_is_converged = func(p)
+
+            if (fa_value-target)*(fp_value-target) < 0:
+                b = p
+            else:
+                a = p
+
+            p = (a + b)/2
+
+            fp_value, fp_is_converged = func(p)
+            error = abs(fp_value-target)
+
+            if fp_is_converged:
+                last_allowed_function_argument = p
+
+            if itr == max_itr:
+                res_function_argument = last_allowed_function_argument
+                KM.Logger.PrintWarning("ShapeOpt::PerformBisectioning", "Bisectioning did not converge in the specified maximum number of iterations!")
+                break
+
+            elif error < tolerance:
+                res_function_argument = p
+                break
+
+    return res_function_argument, itr, error
+
+# --------------------------------------------------------------------------
+def PerformGramSchmidtOrthogonalization(vector_space):
+    V = vector_space
+    B = []
+
+    # Orthogonalization
+    norm2_V0 = Norm2(V[0])
+    B.append( ScalarVectorProduct(1/norm2_V0,V[0]) )
+    for v in V[1:]:
+        for b in B:
+            norm2_b = Norm2(b)
+            v = Minus( v , ScalarVectorProduct( Dot(v,b)/norm2_b**2 , b ) )
+
+        # Add only if vector is independent
+        norm2_v = Norm2(v)
+        if norm2_v>1e-10:
+            B.append( ScalarVectorProduct(1/norm2_v,v) )
+        else:
+            KM.Logger.PrintWarning("ShapeOpt::PerformGramSchmidtOrthogonalization", "Zero basis vector after Gram-Schmidt orthogonalization!")
+            B.append(v)
+
+    return B
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_variable_utilities.py

 * *Ordering differences only*

```diff
@@ -1,54 +1,54 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#
-# ==============================================================================
-def WriteDictionaryDataOnNodalVariable(data, model_part, nodal_variable):
-    for node_id, tmp_gradient in data.items():
-        model_part.Nodes[node_id].SetSolutionStepValue(nodal_variable, 0, tmp_gradient)
-
-# ------------------------------------------------------------------------------
-def ReadNodalVariableToList(model_part, nodal_variable, dimension=3):
-    variable_values_list = [0.0]*model_part.NumberOfNodes()*dimension
-
-    for itr, node in enumerate(model_part.Nodes):
-        tmp_values = node.GetSolutionStepValue(nodal_variable)
-
-        if dimension == 1:
-            variable_values_list[itr] = tmp_values
-        else:
-            for i in range(dimension):
-                variable_values_list[dimension*itr+i] = tmp_values[i]
-
-    return variable_values_list
-
-# --------------------------------------------------------------------------
-def WriteListToNodalVariable(input_list, model_part, nodal_variable, dimension=3):
-    if len(input_list) != model_part.NumberOfNodes()*dimension:
-        raise RuntimeError("custom_variable_utility::WriteListToNodalVariable: Wrong size of input_list!")
-
-    k = 0
-    for node in model_part.Nodes:
-        if dimension == 1:
-            tmp_values = input_list[k]
-        else:
-            tmp_values = input_list[k:k+dimension]
-        node.SetSolutionStepValue(nodal_variable, tmp_values)
-        k = k+dimension
-
-# --------------------------------------------------------------------------
-def WriteNodeCoordinatesToList(model_part):
-    variable_values_list = [0.0]*model_part.NumberOfNodes()*3
-
-    for itr, node in enumerate(model_part.Nodes):
-        variable_values_list[3*itr+0] = node.X
-        variable_values_list[3*itr+1] = node.Y
-        variable_values_list[3*itr+2] = node.Z
-
-    return variable_values_list
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#
+# ==============================================================================
+def WriteDictionaryDataOnNodalVariable(data, model_part, nodal_variable):
+    for node_id, tmp_gradient in data.items():
+        model_part.Nodes[node_id].SetSolutionStepValue(nodal_variable, 0, tmp_gradient)
+
+# ------------------------------------------------------------------------------
+def ReadNodalVariableToList(model_part, nodal_variable, dimension=3):
+    variable_values_list = [0.0]*model_part.NumberOfNodes()*dimension
+
+    for itr, node in enumerate(model_part.Nodes):
+        tmp_values = node.GetSolutionStepValue(nodal_variable)
+
+        if dimension == 1:
+            variable_values_list[itr] = tmp_values
+        else:
+            for i in range(dimension):
+                variable_values_list[dimension*itr+i] = tmp_values[i]
+
+    return variable_values_list
+
+# --------------------------------------------------------------------------
+def WriteListToNodalVariable(input_list, model_part, nodal_variable, dimension=3):
+    if len(input_list) != model_part.NumberOfNodes()*dimension:
+        raise RuntimeError("custom_variable_utility::WriteListToNodalVariable: Wrong size of input_list!")
+
+    k = 0
+    for node in model_part.Nodes:
+        if dimension == 1:
+            tmp_values = input_list[k]
+        else:
+            tmp_values = input_list[k:k+dimension]
+        node.SetSolutionStepValue(nodal_variable, tmp_values)
+        k = k+dimension
+
+# --------------------------------------------------------------------------
+def WriteNodeCoordinatesToList(model_part):
+    variable_values_list = [0.0]*model_part.NumberOfNodes()*3
+
+    for itr, node in enumerate(model_part.Nodes):
+        variable_values_list[3*itr+0] = node.X
+        variable_values_list[3*itr+1] = node.Y
+        variable_values_list[3*itr+2] = node.Z
+
+    return variable_values_list
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_sensitivity_heatmap.py

 * *Ordering differences only*

```diff
@@ -1,235 +1,235 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Schmölz David, https://github.com/dschmoelz
-#
-# ==============================================================================
-
-# Kratos Core and Apps
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-from KratosMultiphysics.ShapeOptimizationApplication.utilities import custom_math as cm
-# Import additional libraries
-
-# some response are continuously formulated
-continuous_response_gradients = ("plane_based_packaging", "mesh_based_packaging")
-
-# ==============================================================================
-# --------------------------------------------------------------------------
-class SensitivityHeatmapCalculator(object):
-
-    # --------------------------------------------------------------------------
-    def __init__(self, design_surface, objectives, constraints, settings):
-        self.design_surface = design_surface
-        self.objectives = objectives
-        self.constraints = constraints
-
-        if objectives.size() > 1:
-            raise RuntimeError("Sensitivity Heatmap only supports one objective function!")
-
-        self.settings = settings
-        self.norm_type = settings["norm_type"].GetString()
-        if self.norm_type not in ("max", "l2"):
-            raise NameError("""The following norm type is not supported by the
-                            sensitivity heatmap logger (name may be misspelled): """ + self.norm_type)
-
-        self.sensitivity_weighting = settings["sensitivity_weighting"].GetBool()
-        self.map_sensitivities = settings["mapping"].GetBool()
-        self.relaxation_method = settings["relaxation_method"].GetString()
-        if self.relaxation_method not in ("reciprocal", "constant"):
-            raise NameError("""The following relaxation method is not supported by the
-                            sensitivity heatmap logger (name may be misspelled): """ + self.relaxation_method)
-
-        self.design_variable_name = settings["design_variable_name"].GetString()
-        self.design_variable_dimension = settings["design_variable_dimension"].GetInt()
-
-        self.optimization_utilities = KSO.OptimizationUtilities
-
-    # --------------------------------------------------------------------------
-    def ComputeHeatmaps(self, optimization_iteration, mapper):
-
-        # calculate nodal areas for weighting
-        if self.sensitivity_weighting:
-            KSO.GeometryUtilities(self.design_surface).CalculateNodalAreasFromConditions()
-
-        self.__ComputeIndividualHeatmaps(optimization_iteration, mapper)
-        if self.constraints.size() != 0:
-            self.__ComputeAggregatedHeatmap(optimization_iteration, mapper)
-
-    # --------------------------------------------------------------------------
-    def __ComputeIndividualHeatmaps(self, optimization_iteration, mapper):
-
-        objective_gradient_name = f"DF1D{self.design_variable_name}"
-        objective_type = self.objectives[0]["response_settings"]["response_type"]
-        self.__ComputeResponseHeatmap(objective_gradient_name, objective_type, optimization_iteration, mapper)
-
-        if self.constraints.size() != 0:
-            for itr in range(self.constraints.size()):
-                constraint_gradient_name = f"DC{(itr+1)}D{self.design_variable_name}"
-                constraint_type = self.constraints[itr]["response_settings"]["response_type"]
-                self.__ComputeResponseHeatmap(constraint_gradient_name, constraint_type, optimization_iteration, mapper)
-
-    # --------------------------------------------------------------------------
-    def __ComputeAggregatedHeatmap(self, optimization_iteration, mapper):
-
-        # normalize objective gradient
-        objective_gradient_name = f"DF1D{self.design_variable_name}"
-        objective_type = self.objectives[0]["response_settings"]["response_type"]
-        df_dx_normalized = self.__NormalizeResponseGradient(objective_gradient_name, objective_type)
-
-        # normalize constraints
-        dc_dx_normalized = []
-        for itr in range(self.constraints.size()):
-            constraint_gradient_name = f"DC{(itr+1)}D{self.design_variable_name}"
-            constraint_type = self.constraints[itr]["response_settings"]["response_type"]
-            dc_dx_normalized.append(self.__NormalizeResponseGradient(constraint_gradient_name, constraint_type))
-
-        # fill heat map for each node
-        heat = Kratos.Vector(len(self.design_surface.Nodes))
-        for i in range(len(self.design_surface.Nodes)):
-            index = self.design_variable_dimension*i
-            df_dx_i = df_dx_normalized[index:index+self.design_variable_dimension]
-            df_dx_i_norm = cm.Norm2(df_dx_i)
-
-            heat_i = df_dx_i_norm
-            for dc_dx in dc_dx_normalized:
-                dc_dx_i = dc_dx[index:index+self.design_variable_dimension]
-                dc_dx_i_norm = cm.Norm2(dc_dx_i)
-                heat_i = max(heat_i, dc_dx_i_norm)
-
-            heat[i] = heat_i
-
-        if self.norm_type == "max":
-            heat_map_name = "HEATMAP_MAX"
-        elif self.norm_type == "l2":
-            heat_map_name = "HEATMAP_L2"
-
-        # relax heatmap
-        relaxation_coefficient = self.__GetRelaxationCoefficient(optimization_iteration)
-        if optimization_iteration == 1:
-            heat_relaxed = heat
-        else:
-            prev_heat = Kratos.Vector()
-            self.optimization_utilities.AssembleVector(self.design_surface, prev_heat, Kratos.KratosGlobals.GetVariable(heat_map_name))
-            heat_relaxed = Kratos.Vector(len(self.design_surface.Nodes))
-            for i in range(len(self.design_surface.Nodes)):
-                heat_relaxed[i] = relaxation_coefficient * heat[i] + (1 - relaxation_coefficient) * prev_heat[i]
-
-        self.optimization_utilities.AssignVectorToVariable(self.design_surface, heat_relaxed, Kratos.KratosGlobals.GetVariable(heat_map_name))
-
-    # --------------------------------------------------------------------------
-    def __ComputeResponseHeatmap( self, response_gradient_name, response_type, optimization_iteration, mapper):
-
-        response_is_weighted = False
-        if self.sensitivity_weighting and \
-            response_type not in continuous_response_gradients:
-            response_is_weighted = True
-
-        if response_is_weighted:
-            self.__WeightResponseGradient(response_gradient_name)
-            response_gradient_name += "_WEIGHTED"
-        if self.map_sensitivities:
-            # reponse has been already mapped by the optimization algorithm if it is not weighted
-            if response_is_weighted:
-                self.__MapResponseGradient(response_gradient_name, mapper)
-            response_gradient_name += "_MAPPED"
-
-        self.__RelaxResponseHeatmap(response_gradient_name, optimization_iteration)
-
-    # --------------------------------------------------------------------------
-    def __WeightResponseGradient( self, response_gradient_name ):
-
-        nodal_area = Kratos.Vector()
-        self.optimization_utilities.AssembleVector(self.design_surface, nodal_area, Kratos.KratosGlobals.GetVariable("NODAL_AREA"))
-
-        dg_dx = Kratos.Vector()
-        self.optimization_utilities.AssembleVector(self.design_surface, dg_dx, Kratos.KratosGlobals.GetVariable(response_gradient_name))
-
-        # weight response gradients with nodal area
-        dg_dx_weighted = Kratos.Vector(self.design_variable_dimension*len(self.design_surface.Nodes))
-        for i in range(len(self.design_surface.Nodes)):
-            for dim in range(self.design_variable_dimension):
-                index = self.design_variable_dimension * i + dim
-                if nodal_area[i] > 1e-8:
-                    dg_dx_weighted[index] = dg_dx[index] / nodal_area[i]
-                else:
-                    dg_dx_weighted[index] = dg_dx[index]
-
-        response_gradient_weighted_name = f"{response_gradient_name}_WEIGHTED"
-        self.optimization_utilities.AssignVectorToVariable(self.design_surface, dg_dx_weighted,
-                                                           Kratos.KratosGlobals.GetVariable(response_gradient_weighted_name))
-
-    # --------------------------------------------------------------------------
-    def __MapResponseGradient( self, response_gradient_name, mapper ):
-
-        response_gradient_mapped_name = f"{response_gradient_name}_MAPPED"
-        mapper.InverseMap(Kratos.KratosGlobals.GetVariable(response_gradient_name),
-                               Kratos.KratosGlobals.GetVariable(response_gradient_mapped_name))
-
-    # --------------------------------------------------------------------------
-    def __RelaxResponseHeatmap( self, response_gradient_name, optimization_iteration ):
-
-        relaxation_coefficient = self.__GetRelaxationCoefficient(optimization_iteration)
-
-        dg_dx = Kratos.Vector()
-        self.optimization_utilities.AssembleVector(self.design_surface, dg_dx, Kratos.KratosGlobals.GetVariable(response_gradient_name))
-
-        g_name = f"{response_gradient_name[0:4]}"
-        heatmap_dgdx_name = f"HEATMAP_{g_name}{self.design_variable_name}"
-        if optimization_iteration == 1:
-            heat_dfdx_relaxed = dg_dx
-        else:
-            prev_heat_dfdx = Kratos.Vector()
-            self.optimization_utilities.AssembleVector(self.design_surface, prev_heat_dfdx, Kratos.KratosGlobals.GetVariable(heatmap_dgdx_name))
-            heat_dfdx_relaxed = Kratos.Vector(self.design_variable_dimension*len(self.design_surface.Nodes))
-            for i in range(len(self.design_surface.Nodes)):
-                for dim in range(self.design_variable_dimension):
-                    index = self.design_variable_dimension * i + dim
-                    heat_dfdx_relaxed[index] = relaxation_coefficient * dg_dx[index] + (1 - relaxation_coefficient) * prev_heat_dfdx[index]
-
-        self.optimization_utilities.AssignVectorToVariable(self.design_surface, heat_dfdx_relaxed, Kratos.KratosGlobals.GetVariable(heatmap_dgdx_name))
-
-    # --------------------------------------------------------------------------
-    def __NormalizeResponseGradient( self, response_gradient_name, response_type ):
-
-        response_is_weighted = False
-        if self.sensitivity_weighting and \
-            response_type not in continuous_response_gradients:
-            response_is_weighted = True
-
-        if response_is_weighted:
-            response_gradient_name += "_WEIGHTED"
-        if self.map_sensitivities:
-            response_gradient_name += "_MAPPED"
-
-        optimization_utilities = KSO.OptimizationUtilities
-
-        dg_dx = Kratos.Vector()
-        optimization_utilities.AssembleVector(self.design_surface, dg_dx, Kratos.KratosGlobals.GetVariable(response_gradient_name))
-
-        if self.norm_type == "max":
-            dg_dx_norm = cm.NormInf3D(dg_dx)
-        elif self.norm_type == "l2":
-            dg_dx_norm = cm.Norm2(dg_dx)
-        else:
-            raise RuntimeError("Sensitivity Heatmap only supports 'max' or 'l2' norm!")
-
-        if dg_dx_norm != 0.0:
-            dg_dx_normalized = (1/dg_dx_norm) * dg_dx
-        else:
-            dg_dx_normalized = 0 * dg_dx
-
-        return dg_dx_normalized
-
-    # --------------------------------------------------------------------------
-    def __GetRelaxationCoefficient( self, optimization_iteration ):
-
-        if self.relaxation_method == "reciprocal":
-            return 1 / optimization_iteration
-        elif self.relaxation_method == "constant":
-            return self.settings["relaxation_coefficient"].GetDouble()
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Schmölz David, https://github.com/dschmoelz
+#
+# ==============================================================================
+
+# Kratos Core and Apps
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+from KratosMultiphysics.ShapeOptimizationApplication.utilities import custom_math as cm
+# Import additional libraries
+
+# some response are continuously formulated
+continuous_response_gradients = ("plane_based_packaging", "mesh_based_packaging")
+
+# ==============================================================================
+# --------------------------------------------------------------------------
+class SensitivityHeatmapCalculator(object):
+
+    # --------------------------------------------------------------------------
+    def __init__(self, design_surface, objectives, constraints, settings):
+        self.design_surface = design_surface
+        self.objectives = objectives
+        self.constraints = constraints
+
+        if objectives.size() > 1:
+            raise RuntimeError("Sensitivity Heatmap only supports one objective function!")
+
+        self.settings = settings
+        self.norm_type = settings["norm_type"].GetString()
+        if self.norm_type not in ("max", "l2"):
+            raise NameError("""The following norm type is not supported by the
+                            sensitivity heatmap logger (name may be misspelled): """ + self.norm_type)
+
+        self.sensitivity_weighting = settings["sensitivity_weighting"].GetBool()
+        self.map_sensitivities = settings["mapping"].GetBool()
+        self.relaxation_method = settings["relaxation_method"].GetString()
+        if self.relaxation_method not in ("reciprocal", "constant"):
+            raise NameError("""The following relaxation method is not supported by the
+                            sensitivity heatmap logger (name may be misspelled): """ + self.relaxation_method)
+
+        self.design_variable_name = settings["design_variable_name"].GetString()
+        self.design_variable_dimension = settings["design_variable_dimension"].GetInt()
+
+        self.optimization_utilities = KSO.OptimizationUtilities
+
+    # --------------------------------------------------------------------------
+    def ComputeHeatmaps(self, optimization_iteration, mapper):
+
+        # calculate nodal areas for weighting
+        if self.sensitivity_weighting:
+            KSO.GeometryUtilities(self.design_surface).CalculateNodalAreasFromConditions()
+
+        self.__ComputeIndividualHeatmaps(optimization_iteration, mapper)
+        if self.constraints.size() != 0:
+            self.__ComputeAggregatedHeatmap(optimization_iteration, mapper)
+
+    # --------------------------------------------------------------------------
+    def __ComputeIndividualHeatmaps(self, optimization_iteration, mapper):
+
+        objective_gradient_name = f"DF1D{self.design_variable_name}"
+        objective_type = self.objectives[0]["response_settings"]["response_type"]
+        self.__ComputeResponseHeatmap(objective_gradient_name, objective_type, optimization_iteration, mapper)
+
+        if self.constraints.size() != 0:
+            for itr in range(self.constraints.size()):
+                constraint_gradient_name = f"DC{(itr+1)}D{self.design_variable_name}"
+                constraint_type = self.constraints[itr]["response_settings"]["response_type"]
+                self.__ComputeResponseHeatmap(constraint_gradient_name, constraint_type, optimization_iteration, mapper)
+
+    # --------------------------------------------------------------------------
+    def __ComputeAggregatedHeatmap(self, optimization_iteration, mapper):
+
+        # normalize objective gradient
+        objective_gradient_name = f"DF1D{self.design_variable_name}"
+        objective_type = self.objectives[0]["response_settings"]["response_type"]
+        df_dx_normalized = self.__NormalizeResponseGradient(objective_gradient_name, objective_type)
+
+        # normalize constraints
+        dc_dx_normalized = []
+        for itr in range(self.constraints.size()):
+            constraint_gradient_name = f"DC{(itr+1)}D{self.design_variable_name}"
+            constraint_type = self.constraints[itr]["response_settings"]["response_type"]
+            dc_dx_normalized.append(self.__NormalizeResponseGradient(constraint_gradient_name, constraint_type))
+
+        # fill heat map for each node
+        heat = Kratos.Vector(len(self.design_surface.Nodes))
+        for i in range(len(self.design_surface.Nodes)):
+            index = self.design_variable_dimension*i
+            df_dx_i = df_dx_normalized[index:index+self.design_variable_dimension]
+            df_dx_i_norm = cm.Norm2(df_dx_i)
+
+            heat_i = df_dx_i_norm
+            for dc_dx in dc_dx_normalized:
+                dc_dx_i = dc_dx[index:index+self.design_variable_dimension]
+                dc_dx_i_norm = cm.Norm2(dc_dx_i)
+                heat_i = max(heat_i, dc_dx_i_norm)
+
+            heat[i] = heat_i
+
+        if self.norm_type == "max":
+            heat_map_name = "HEATMAP_MAX"
+        elif self.norm_type == "l2":
+            heat_map_name = "HEATMAP_L2"
+
+        # relax heatmap
+        relaxation_coefficient = self.__GetRelaxationCoefficient(optimization_iteration)
+        if optimization_iteration == 1:
+            heat_relaxed = heat
+        else:
+            prev_heat = Kratos.Vector()
+            self.optimization_utilities.AssembleVector(self.design_surface, prev_heat, Kratos.KratosGlobals.GetVariable(heat_map_name))
+            heat_relaxed = Kratos.Vector(len(self.design_surface.Nodes))
+            for i in range(len(self.design_surface.Nodes)):
+                heat_relaxed[i] = relaxation_coefficient * heat[i] + (1 - relaxation_coefficient) * prev_heat[i]
+
+        self.optimization_utilities.AssignVectorToVariable(self.design_surface, heat_relaxed, Kratos.KratosGlobals.GetVariable(heat_map_name))
+
+    # --------------------------------------------------------------------------
+    def __ComputeResponseHeatmap( self, response_gradient_name, response_type, optimization_iteration, mapper):
+
+        response_is_weighted = False
+        if self.sensitivity_weighting and \
+            response_type not in continuous_response_gradients:
+            response_is_weighted = True
+
+        if response_is_weighted:
+            self.__WeightResponseGradient(response_gradient_name)
+            response_gradient_name += "_WEIGHTED"
+        if self.map_sensitivities:
+            # reponse has been already mapped by the optimization algorithm if it is not weighted
+            if response_is_weighted:
+                self.__MapResponseGradient(response_gradient_name, mapper)
+            response_gradient_name += "_MAPPED"
+
+        self.__RelaxResponseHeatmap(response_gradient_name, optimization_iteration)
+
+    # --------------------------------------------------------------------------
+    def __WeightResponseGradient( self, response_gradient_name ):
+
+        nodal_area = Kratos.Vector()
+        self.optimization_utilities.AssembleVector(self.design_surface, nodal_area, Kratos.KratosGlobals.GetVariable("NODAL_AREA"))
+
+        dg_dx = Kratos.Vector()
+        self.optimization_utilities.AssembleVector(self.design_surface, dg_dx, Kratos.KratosGlobals.GetVariable(response_gradient_name))
+
+        # weight response gradients with nodal area
+        dg_dx_weighted = Kratos.Vector(self.design_variable_dimension*len(self.design_surface.Nodes))
+        for i in range(len(self.design_surface.Nodes)):
+            for dim in range(self.design_variable_dimension):
+                index = self.design_variable_dimension * i + dim
+                if nodal_area[i] > 1e-8:
+                    dg_dx_weighted[index] = dg_dx[index] / nodal_area[i]
+                else:
+                    dg_dx_weighted[index] = dg_dx[index]
+
+        response_gradient_weighted_name = f"{response_gradient_name}_WEIGHTED"
+        self.optimization_utilities.AssignVectorToVariable(self.design_surface, dg_dx_weighted,
+                                                           Kratos.KratosGlobals.GetVariable(response_gradient_weighted_name))
+
+    # --------------------------------------------------------------------------
+    def __MapResponseGradient( self, response_gradient_name, mapper ):
+
+        response_gradient_mapped_name = f"{response_gradient_name}_MAPPED"
+        mapper.InverseMap(Kratos.KratosGlobals.GetVariable(response_gradient_name),
+                               Kratos.KratosGlobals.GetVariable(response_gradient_mapped_name))
+
+    # --------------------------------------------------------------------------
+    def __RelaxResponseHeatmap( self, response_gradient_name, optimization_iteration ):
+
+        relaxation_coefficient = self.__GetRelaxationCoefficient(optimization_iteration)
+
+        dg_dx = Kratos.Vector()
+        self.optimization_utilities.AssembleVector(self.design_surface, dg_dx, Kratos.KratosGlobals.GetVariable(response_gradient_name))
+
+        g_name = f"{response_gradient_name[0:4]}"
+        heatmap_dgdx_name = f"HEATMAP_{g_name}{self.design_variable_name}"
+        if optimization_iteration == 1:
+            heat_dfdx_relaxed = dg_dx
+        else:
+            prev_heat_dfdx = Kratos.Vector()
+            self.optimization_utilities.AssembleVector(self.design_surface, prev_heat_dfdx, Kratos.KratosGlobals.GetVariable(heatmap_dgdx_name))
+            heat_dfdx_relaxed = Kratos.Vector(self.design_variable_dimension*len(self.design_surface.Nodes))
+            for i in range(len(self.design_surface.Nodes)):
+                for dim in range(self.design_variable_dimension):
+                    index = self.design_variable_dimension * i + dim
+                    heat_dfdx_relaxed[index] = relaxation_coefficient * dg_dx[index] + (1 - relaxation_coefficient) * prev_heat_dfdx[index]
+
+        self.optimization_utilities.AssignVectorToVariable(self.design_surface, heat_dfdx_relaxed, Kratos.KratosGlobals.GetVariable(heatmap_dgdx_name))
+
+    # --------------------------------------------------------------------------
+    def __NormalizeResponseGradient( self, response_gradient_name, response_type ):
+
+        response_is_weighted = False
+        if self.sensitivity_weighting and \
+            response_type not in continuous_response_gradients:
+            response_is_weighted = True
+
+        if response_is_weighted:
+            response_gradient_name += "_WEIGHTED"
+        if self.map_sensitivities:
+            response_gradient_name += "_MAPPED"
+
+        optimization_utilities = KSO.OptimizationUtilities
+
+        dg_dx = Kratos.Vector()
+        optimization_utilities.AssembleVector(self.design_surface, dg_dx, Kratos.KratosGlobals.GetVariable(response_gradient_name))
+
+        if self.norm_type == "max":
+            dg_dx_norm = cm.NormInf3D(dg_dx)
+        elif self.norm_type == "l2":
+            dg_dx_norm = cm.Norm2(dg_dx)
+        else:
+            raise RuntimeError("Sensitivity Heatmap only supports 'max' or 'l2' norm!")
+
+        if dg_dx_norm != 0.0:
+            dg_dx_normalized = (1/dg_dx_norm) * dg_dx
+        else:
+            dg_dx_normalized = 0 * dg_dx
+
+        return dg_dx_normalized
+
+    # --------------------------------------------------------------------------
+    def __GetRelaxationCoefficient( self, optimization_iteration ):
+
+        if self.relaxation_method == "reciprocal":
+            return 1 / optimization_iteration
+        elif self.relaxation_method == "constant":
+            return self.settings["relaxation_coefficient"].GetDouble()
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_timer.py

 * *Ordering differences only*

```diff
@@ -1,47 +1,47 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#                   Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-
-# Import additional libraries
-import time
-
-# ==============================================================================
-class Timer:
-    # --------------------------------------------------------------------------
-    def __init__( self ):
-        self.Precision = 3
-        self.StartGlobalTime = None
-        self.StartLapTime = None
-        self.LapTime = None
-    # --------------------------------------------------------------------------
-    def StartTimer( self ):
-        self.StartGlobalTime = time.time()
-        self.StartLapTime = time.time()
-
-    # --------------------------------------------------------------------------
-    def GetLapTime( self ):
-        LapTime = time.time() - self.StartLapTime
-        return round( LapTime, self.Precision )
-
-    # --------------------------------------------------------------------------
-    def StartNewLap( self ):
-        self.StartLapTime = time.time()
-
-    #---------------------------------------------------------------------------
-    def GetTotalTime( self ):
-        totalTime = time.time() - self.StartGlobalTime
-        return round( totalTime, self.Precision )
-
-    # --------------------------------------------------------------------------
-    def GetTimeStamp( self ):
-        return time.ctime()
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#                   Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+
+# Import additional libraries
+import time
+
+# ==============================================================================
+class Timer:
+    # --------------------------------------------------------------------------
+    def __init__( self ):
+        self.Precision = 3
+        self.StartGlobalTime = None
+        self.StartLapTime = None
+        self.LapTime = None
+    # --------------------------------------------------------------------------
+    def StartTimer( self ):
+        self.StartGlobalTime = time.time()
+        self.StartLapTime = time.time()
+
+    # --------------------------------------------------------------------------
+    def GetLapTime( self ):
+        LapTime = time.time() - self.StartLapTime
+        return round( LapTime, self.Precision )
+
+    # --------------------------------------------------------------------------
+    def StartNewLap( self ):
+        self.StartLapTime = time.time()
+
+    #---------------------------------------------------------------------------
+    def GetTotalTime( self ):
+        totalTime = time.time() - self.StartGlobalTime
+        return round( totalTime, self.Precision )
+
+    # --------------------------------------------------------------------------
+    def GetTimeStamp( self ):
+        return time.ctime()
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/communicator_factory.py

 * *Ordering differences only*

```diff
@@ -1,259 +1,259 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#
-# ==============================================================================
-
-
-# ==============================================================================
-def CreateCommunicator(optimization_settings):
-    return Communicator(optimization_settings)
-
-# ==============================================================================
-class Communicator:
-
-    # --------------------------------------------------------------------------
-    def __init__(self, optimization_settings):
-        self.optimization_settings = optimization_settings
-        self.supported_objective_types = ["minimization", "maximization"]
-        self.supported_constraint_types = ["=", "<", ">", "<=", ">="]
-        self.supported_constraint_references = ["initial_value", "specified_value"]
-
-        objective_settings = self.__ExtractResponseSettingsRecursively(optimization_settings["objectives"])
-        constraint_settings = self.__ExtractResponseSettingsRecursively(optimization_settings["constraints"])
-        all_response_settings = objective_settings + constraint_settings
-
-        self.list_of_requests = self.__initializeListOfRequests(all_response_settings)
-        self.list_of_responses = self.__initializeListOfObjectives(objective_settings)
-        self.list_of_responses.update(self.__initializeListOfConstraints(constraint_settings))
-
-    # --------------------------------------------------------------------------
-    def initializeCommunication(self):
-        self.__deleteAllRequests()
-        self.__deleteAllReportedValues()
-
-    # --------------------------------------------------------------------------
-    def updateRequest(self, response_id, **kwargs):
-        if "request_value" in kwargs.keys():
-            self.list_of_requests[response_id]["calculateValue"] = kwargs["request_value"]
-        if "request_gradient" in kwargs.keys():
-            self.list_of_requests[response_id]["calculateGradient"] = kwargs["request_gradient"]
-
-    # --------------------------------------------------------------------------
-    def requestValueOf(self, response_id):
-        self.list_of_requests[response_id]["calculateValue"] = True
-
-    # --------------------------------------------------------------------------
-    def requestGradientOf(self, response_id):
-        self.list_of_requests[response_id]["calculateGradient"] = True
-
-    # --------------------------------------------------------------------------
-    def isRequestingValueOf(self, response_id):
-        if response_id not in self.list_of_requests.keys():
-            return False
-        else:
-            return self.list_of_requests[response_id]["calculateValue"]
-
-    # --------------------------------------------------------------------------
-    def isRequestingGradientOf(self, response_id):
-        if response_id not in self.list_of_requests.keys():
-            return False
-        else:
-            return self.list_of_requests[response_id]["calculateGradient"]
-
-    # --------------------------------------------------------------------------
-    def reportValue(self, response_id, value):
-        self.__storeValue(response_id, value)
-        if self.__isResponseWaitingForInitialValueAsReference(response_id):
-            self.__setValueAsReference(response_id, value)
-
-        standardized_value = self.__translateValueToStandardForm(response_id, value)
-        self.__storeStandardizedValue(response_id, standardized_value)
-
-    # --------------------------------------------------------------------------
-    def reportGradient(self, response_id, gradient):
-        dimension = len(next(iter(gradient.values())))
-        if dimension == 1:
-            gradient = {key: [value[0], 0.0, 0.0] for key, value in gradient.items()}
-        elif dimension == 2:
-            gradient = {key: [value[0], value[1], 0.0] for key, value in gradient.items()}
-
-        standardized_gradient = self.__translateGradientToStandardForm(response_id, gradient)
-        self.__storeStandardizedGradient(response_id, standardized_gradient)
-
-    # --------------------------------------------------------------------------
-    def getValue(self, response_id):
-        if self.list_of_responses[response_id]["value"] is None:
-            raise RuntimeError("The requested value for ", response_id, " is None!")
-        return self.list_of_responses[response_id]["value"]
-
-    # --------------------------------------------------------------------------
-    def getReferenceValue(self, response_id):
-        if self.list_of_responses[response_id]["reference_value"] is None:
-            raise RuntimeError("The requested reference_value for ", response_id, " is None!")
-        return self.list_of_responses[response_id]["reference_value"]
-
-    # --------------------------------------------------------------------------
-    def getStandardizedValue(self, response_id):
-        if self.list_of_responses[response_id]["standardized_value"] is None:
-            raise RuntimeError("The requested standardized_value for ", response_id, " is None!")
-        return self.list_of_responses[response_id]["standardized_value"]
-
-    # --------------------------------------------------------------------------
-    def getStandardizedGradient(self, response_id):
-        if self.list_of_responses[response_id]["standardized_gradient"] is None:
-            raise RuntimeError("The requested standardized_gradient for ", response_id, " is None!")
-        return self.list_of_responses[response_id]["standardized_gradient"]
-
-    # --------------------------------------------------------------------------
-    @classmethod
-    def __ExtractResponseSettingsRecursively(cls, response_settings):
-        list_of_settings = []
-
-        for itr in range(response_settings.size()):
-            response_i = response_settings[itr]
-            if response_i.Has("is_combined"):
-                if response_i["is_combined"].GetBool():
-                    list_of_settings += cls.__ExtractResponseSettingsRecursively(response_i["combined_responses"])
-
-            list_of_settings += [response_i]
-
-        return list_of_settings
-
-    # --------------------------------------------------------------------------
-    @classmethod
-    def __initializeListOfRequests(cls, response_settings):
-        list_of_requests = {}
-
-        for response in response_settings:
-            response_id = response["identifier"].GetString()
-            list_of_requests[response_id] = {"calculateValue": False, "calculateGradient": False}
-
-        return list_of_requests
-
-    # --------------------------------------------------------------------------
-    def __initializeListOfObjectives(self, objective_settings):
-        list_of_objectives = {}
-
-        for objective in objective_settings:
-            objective_id =  objective["identifier"].GetString()
-
-            if objective["type"].GetString() not in self.supported_objective_types:
-                raise RuntimeError("Unsupported type defined for the following objective: " + objective_id)
-
-            list_of_objectives[objective_id] = { "type"                 : objective["type"].GetString(),
-                                                 "value"                : None,
-                                                 "scaling_factor"       : objective["scaling_factor"].GetDouble(),
-                                                 "standardized_value"   : None,
-                                                 "standardized_gradient": None }
-
-        return list_of_objectives
-
-    # --------------------------------------------------------------------------
-    def __initializeListOfConstraints(self, constraint_settings):
-        list_of_constraints = {}
-
-        for constraint in constraint_settings:
-            constraint_id = constraint["identifier"].GetString()
-
-            if constraint["type"].GetString() not in self.supported_constraint_types:
-                raise RuntimeError("Unsupported type defined for the following constraint: " + constraint_id)
-
-            if constraint["reference"].GetString() not in self.supported_constraint_references:
-                raise RuntimeError("Unsupported reference defined for the following constraint: " + constraint_id)
-
-            if  constraint["reference"].GetString() == "specified_value":
-                list_of_constraints[constraint_id] = { "type"                 : constraint["type"].GetString(),
-                                                        "value"                : None,
-                                                        "scaling_factor"       : constraint["scaling_factor"].GetDouble(),
-                                                        "standardized_value"   : None,
-                                                        "standardized_gradient": None,
-                                                        "reference_value"      : constraint["reference_value"].GetDouble() }
-            elif constraint["reference"].GetString() == "initial_value":
-                list_of_constraints[constraint_id] = { "type"                 : constraint["type"].GetString(),
-                                                        "value"                : None,
-                                                        "scaling_factor"       : constraint["scaling_factor"].GetDouble(),
-                                                        "standardized_value"   : None,
-                                                        "standardized_gradient": None,
-                                                        "reference_value"      : None }
-            else:
-                raise RuntimeError("Unsupported reference defined for the following constraint: " + constraint_id)
-
-        return list_of_constraints
-
-    # --------------------------------------------------------------------------
-    def __deleteAllRequests(self):
-        for response_id in self.list_of_requests:
-            self.list_of_requests[response_id]["calculateValue"] = False
-            self.list_of_requests[response_id]["calculateGradient"] = False
-
-    # --------------------------------------------------------------------------
-    def __deleteAllReportedValues(self):
-        for response_id in self.list_of_responses:
-            self.list_of_responses[response_id]["value"] = None
-            self.list_of_responses[response_id]["standardized_value"] = None
-            self.list_of_responses[response_id]["standardized_gradient"] = None
-
-    # --------------------------------------------------------------------------
-    def __isResponseWaitingForInitialValueAsReference(self, response_id):
-        response = self.list_of_responses[response_id]
-        if "reference_value" in response:
-            is_reference_value_missing = (response["reference_value"] is None)
-            if is_reference_value_missing:
-                return True
-        return False
-
-    # --------------------------------------------------------------------------
-    def __setValueAsReference(self, response_id, value):
-        self.list_of_responses[response_id]["reference_value"] = value
-
-    # --------------------------------------------------------------------------
-    def __translateValueToStandardForm(self, response_id, value):
-        response_type = self.list_of_responses[response_id]["type"]
-        scaling_factor = self.list_of_responses[response_id]["scaling_factor"]
-
-        if response_type in self.supported_objective_types:
-            if response_type == "maximization":
-                return -scaling_factor*value
-            else:
-                return scaling_factor*value
-        else:
-            reference_value = self.list_of_responses[response_id]["reference_value"]
-
-            if response_type == ">" or response_type == ">=":
-                return scaling_factor*(reference_value-value)
-            else:
-                return scaling_factor*(value-reference_value)
-
-    # --------------------------------------------------------------------------
-    def __translateGradientToStandardForm(self, response_id, gradient):
-        response_type = self.list_of_responses[response_id]["type"]
-        scaling_factor = self.list_of_responses[response_id]["scaling_factor"]
-
-        if response_type == "maximization" or response_type == ">" or response_type == ">=":
-            scaling_factor *= -1
-
-        for vector in gradient.values():
-            vector[0] *= scaling_factor
-            vector[1] *= scaling_factor
-            vector[2] *= scaling_factor
-
-        return gradient
-
-    # --------------------------------------------------------------------------
-    def __storeValue(self, response_id, value):
-        self.list_of_responses[response_id]["value"] = value
-
-    # --------------------------------------------------------------------------
-    def __storeStandardizedValue(self, response_id, value):
-        self.list_of_responses[response_id]["standardized_value"] = value
-
-    # --------------------------------------------------------------------------
-    def __storeStandardizedGradient(self, response_id, gradient):
-        self.list_of_responses[response_id]["standardized_gradient"] = gradient
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#
+# ==============================================================================
+
+
+# ==============================================================================
+def CreateCommunicator(optimization_settings):
+    return Communicator(optimization_settings)
+
+# ==============================================================================
+class Communicator:
+
+    # --------------------------------------------------------------------------
+    def __init__(self, optimization_settings):
+        self.optimization_settings = optimization_settings
+        self.supported_objective_types = ["minimization", "maximization"]
+        self.supported_constraint_types = ["=", "<", ">", "<=", ">="]
+        self.supported_constraint_references = ["initial_value", "specified_value"]
+
+        objective_settings = self.__ExtractResponseSettingsRecursively(optimization_settings["objectives"])
+        constraint_settings = self.__ExtractResponseSettingsRecursively(optimization_settings["constraints"])
+        all_response_settings = objective_settings + constraint_settings
+
+        self.list_of_requests = self.__initializeListOfRequests(all_response_settings)
+        self.list_of_responses = self.__initializeListOfObjectives(objective_settings)
+        self.list_of_responses.update(self.__initializeListOfConstraints(constraint_settings))
+
+    # --------------------------------------------------------------------------
+    def initializeCommunication(self):
+        self.__deleteAllRequests()
+        self.__deleteAllReportedValues()
+
+    # --------------------------------------------------------------------------
+    def updateRequest(self, response_id, **kwargs):
+        if "request_value" in kwargs.keys():
+            self.list_of_requests[response_id]["calculateValue"] = kwargs["request_value"]
+        if "request_gradient" in kwargs.keys():
+            self.list_of_requests[response_id]["calculateGradient"] = kwargs["request_gradient"]
+
+    # --------------------------------------------------------------------------
+    def requestValueOf(self, response_id):
+        self.list_of_requests[response_id]["calculateValue"] = True
+
+    # --------------------------------------------------------------------------
+    def requestGradientOf(self, response_id):
+        self.list_of_requests[response_id]["calculateGradient"] = True
+
+    # --------------------------------------------------------------------------
+    def isRequestingValueOf(self, response_id):
+        if response_id not in self.list_of_requests.keys():
+            return False
+        else:
+            return self.list_of_requests[response_id]["calculateValue"]
+
+    # --------------------------------------------------------------------------
+    def isRequestingGradientOf(self, response_id):
+        if response_id not in self.list_of_requests.keys():
+            return False
+        else:
+            return self.list_of_requests[response_id]["calculateGradient"]
+
+    # --------------------------------------------------------------------------
+    def reportValue(self, response_id, value):
+        self.__storeValue(response_id, value)
+        if self.__isResponseWaitingForInitialValueAsReference(response_id):
+            self.__setValueAsReference(response_id, value)
+
+        standardized_value = self.__translateValueToStandardForm(response_id, value)
+        self.__storeStandardizedValue(response_id, standardized_value)
+
+    # --------------------------------------------------------------------------
+    def reportGradient(self, response_id, gradient):
+        dimension = len(next(iter(gradient.values())))
+        if dimension == 1:
+            gradient = {key: [value[0], 0.0, 0.0] for key, value in gradient.items()}
+        elif dimension == 2:
+            gradient = {key: [value[0], value[1], 0.0] for key, value in gradient.items()}
+
+        standardized_gradient = self.__translateGradientToStandardForm(response_id, gradient)
+        self.__storeStandardizedGradient(response_id, standardized_gradient)
+
+    # --------------------------------------------------------------------------
+    def getValue(self, response_id):
+        if self.list_of_responses[response_id]["value"] is None:
+            raise RuntimeError("The requested value for ", response_id, " is None!")
+        return self.list_of_responses[response_id]["value"]
+
+    # --------------------------------------------------------------------------
+    def getReferenceValue(self, response_id):
+        if self.list_of_responses[response_id]["reference_value"] is None:
+            raise RuntimeError("The requested reference_value for ", response_id, " is None!")
+        return self.list_of_responses[response_id]["reference_value"]
+
+    # --------------------------------------------------------------------------
+    def getStandardizedValue(self, response_id):
+        if self.list_of_responses[response_id]["standardized_value"] is None:
+            raise RuntimeError("The requested standardized_value for ", response_id, " is None!")
+        return self.list_of_responses[response_id]["standardized_value"]
+
+    # --------------------------------------------------------------------------
+    def getStandardizedGradient(self, response_id):
+        if self.list_of_responses[response_id]["standardized_gradient"] is None:
+            raise RuntimeError("The requested standardized_gradient for ", response_id, " is None!")
+        return self.list_of_responses[response_id]["standardized_gradient"]
+
+    # --------------------------------------------------------------------------
+    @classmethod
+    def __ExtractResponseSettingsRecursively(cls, response_settings):
+        list_of_settings = []
+
+        for itr in range(response_settings.size()):
+            response_i = response_settings[itr]
+            if response_i.Has("is_combined"):
+                if response_i["is_combined"].GetBool():
+                    list_of_settings += cls.__ExtractResponseSettingsRecursively(response_i["combined_responses"])
+
+            list_of_settings += [response_i]
+
+        return list_of_settings
+
+    # --------------------------------------------------------------------------
+    @classmethod
+    def __initializeListOfRequests(cls, response_settings):
+        list_of_requests = {}
+
+        for response in response_settings:
+            response_id = response["identifier"].GetString()
+            list_of_requests[response_id] = {"calculateValue": False, "calculateGradient": False}
+
+        return list_of_requests
+
+    # --------------------------------------------------------------------------
+    def __initializeListOfObjectives(self, objective_settings):
+        list_of_objectives = {}
+
+        for objective in objective_settings:
+            objective_id =  objective["identifier"].GetString()
+
+            if objective["type"].GetString() not in self.supported_objective_types:
+                raise RuntimeError("Unsupported type defined for the following objective: " + objective_id)
+
+            list_of_objectives[objective_id] = { "type"                 : objective["type"].GetString(),
+                                                 "value"                : None,
+                                                 "scaling_factor"       : objective["scaling_factor"].GetDouble(),
+                                                 "standardized_value"   : None,
+                                                 "standardized_gradient": None }
+
+        return list_of_objectives
+
+    # --------------------------------------------------------------------------
+    def __initializeListOfConstraints(self, constraint_settings):
+        list_of_constraints = {}
+
+        for constraint in constraint_settings:
+            constraint_id = constraint["identifier"].GetString()
+
+            if constraint["type"].GetString() not in self.supported_constraint_types:
+                raise RuntimeError("Unsupported type defined for the following constraint: " + constraint_id)
+
+            if constraint["reference"].GetString() not in self.supported_constraint_references:
+                raise RuntimeError("Unsupported reference defined for the following constraint: " + constraint_id)
+
+            if  constraint["reference"].GetString() == "specified_value":
+                list_of_constraints[constraint_id] = { "type"                 : constraint["type"].GetString(),
+                                                        "value"                : None,
+                                                        "scaling_factor"       : constraint["scaling_factor"].GetDouble(),
+                                                        "standardized_value"   : None,
+                                                        "standardized_gradient": None,
+                                                        "reference_value"      : constraint["reference_value"].GetDouble() }
+            elif constraint["reference"].GetString() == "initial_value":
+                list_of_constraints[constraint_id] = { "type"                 : constraint["type"].GetString(),
+                                                        "value"                : None,
+                                                        "scaling_factor"       : constraint["scaling_factor"].GetDouble(),
+                                                        "standardized_value"   : None,
+                                                        "standardized_gradient": None,
+                                                        "reference_value"      : None }
+            else:
+                raise RuntimeError("Unsupported reference defined for the following constraint: " + constraint_id)
+
+        return list_of_constraints
+
+    # --------------------------------------------------------------------------
+    def __deleteAllRequests(self):
+        for response_id in self.list_of_requests:
+            self.list_of_requests[response_id]["calculateValue"] = False
+            self.list_of_requests[response_id]["calculateGradient"] = False
+
+    # --------------------------------------------------------------------------
+    def __deleteAllReportedValues(self):
+        for response_id in self.list_of_responses:
+            self.list_of_responses[response_id]["value"] = None
+            self.list_of_responses[response_id]["standardized_value"] = None
+            self.list_of_responses[response_id]["standardized_gradient"] = None
+
+    # --------------------------------------------------------------------------
+    def __isResponseWaitingForInitialValueAsReference(self, response_id):
+        response = self.list_of_responses[response_id]
+        if "reference_value" in response:
+            is_reference_value_missing = (response["reference_value"] is None)
+            if is_reference_value_missing:
+                return True
+        return False
+
+    # --------------------------------------------------------------------------
+    def __setValueAsReference(self, response_id, value):
+        self.list_of_responses[response_id]["reference_value"] = value
+
+    # --------------------------------------------------------------------------
+    def __translateValueToStandardForm(self, response_id, value):
+        response_type = self.list_of_responses[response_id]["type"]
+        scaling_factor = self.list_of_responses[response_id]["scaling_factor"]
+
+        if response_type in self.supported_objective_types:
+            if response_type == "maximization":
+                return -scaling_factor*value
+            else:
+                return scaling_factor*value
+        else:
+            reference_value = self.list_of_responses[response_id]["reference_value"]
+
+            if response_type == ">" or response_type == ">=":
+                return scaling_factor*(reference_value-value)
+            else:
+                return scaling_factor*(value-reference_value)
+
+    # --------------------------------------------------------------------------
+    def __translateGradientToStandardForm(self, response_id, gradient):
+        response_type = self.list_of_responses[response_id]["type"]
+        scaling_factor = self.list_of_responses[response_id]["scaling_factor"]
+
+        if response_type == "maximization" or response_type == ">" or response_type == ">=":
+            scaling_factor *= -1
+
+        for vector in gradient.values():
+            vector[0] *= scaling_factor
+            vector[1] *= scaling_factor
+            vector[2] *= scaling_factor
+
+        return gradient
+
+    # --------------------------------------------------------------------------
+    def __storeValue(self, response_id, value):
+        self.list_of_responses[response_id]["value"] = value
+
+    # --------------------------------------------------------------------------
+    def __storeStandardizedValue(self, response_id, value):
+        self.list_of_responses[response_id]["standardized_value"] = value
+
+    # --------------------------------------------------------------------------
+    def __storeStandardizedGradient(self, response_id, gradient):
+        self.list_of_responses[response_id]["standardized_gradient"] = gradient
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_base.py

 * *Ordering differences only*

```diff
@@ -1,30 +1,30 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#
-# ==============================================================================
-
-
-# ==============================================================================
-class AnalyzerBaseClass:
-    # --------------------------------------------------------------------------
-    def __init__(self):
-        pass
-
-    # --------------------------------------------------------------------------
-    def InitializeBeforeOptimizationLoop(self):
-        pass
-
-    # --------------------------------------------------------------------------
-    def AnalyzeDesignAndReportToCommunicator(self, current_design, optimization_iteration, communicator):
-        raise RuntimeError("Analyzer base class is called. Please check your implementation of the function >> AnalyzeDesignAndReportToCommunicator << .")
-
-    # --------------------------------------------------------------------------
-    def FinalizeAfterOptimizationLoop(self):
-        pass
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#
+# ==============================================================================
+
+
+# ==============================================================================
+class AnalyzerBaseClass:
+    # --------------------------------------------------------------------------
+    def __init__(self):
+        pass
+
+    # --------------------------------------------------------------------------
+    def InitializeBeforeOptimizationLoop(self):
+        pass
+
+    # --------------------------------------------------------------------------
+    def AnalyzeDesignAndReportToCommunicator(self, current_design, optimization_iteration, communicator):
+        raise RuntimeError("Analyzer base class is called. Please check your implementation of the function >> AnalyzeDesignAndReportToCommunicator << .")
+
+    # --------------------------------------------------------------------------
+    def FinalizeAfterOptimizationLoop(self):
+        pass
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_factory.py

 * *Ordering differences only*

```diff
@@ -1,310 +1,310 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#
-# ==============================================================================
-
-
-# additional imports
-from KratosMultiphysics.ShapeOptimizationApplication.analyzers.analyzer_internal import KratosInternalAnalyzer
-from KratosMultiphysics.ShapeOptimizationApplication.analyzers.analyzer_empty import EmptyAnalyzer
-from KratosMultiphysics.ShapeOptimizationApplication.analyzers.analyzer_base import AnalyzerBaseClass
-import KratosMultiphysics.kratos_utilities as kratos_utilities
-import csv, math
-import copy
-
-# ==============================================================================
-def CreateAnalyzer(optimization_settings, model_part_controller, external_analyzer):
-    objectives = optimization_settings["objectives"]
-    constraints = optimization_settings["constraints"]
-
-    internal_objectives = _IdentifyInternalResponsesRecursively(objectives)
-    internal_constraints = _IdentifyInternalResponsesRecursively(constraints)
-    internal_responses = internal_objectives + internal_constraints
-    # internal_responses = [ (response_id_1, kratos_settings_1),
-    #                        (response_id_2, kratos_settings_2),
-    #                        ... ]
-
-    if len(internal_responses) > 0:
-        internal_analyzer = KratosInternalAnalyzer(internal_responses, model_part_controller)
-    else:
-        internal_analyzer = EmptyAnalyzer()
-
-    dependency_graph, exist_dependencies = _CreateDependencyGraphRecursively(objectives)
-    # dependency_graph = [ (response_id_1, weight_1, [], combination_type),
-    #                      (response_id_2, weight_2, [], combination_type),
-    #                      (response_id_3, [ (response_id_3a, weight_3a, [], combination_type),
-    #                                        (response_id_3b, weight_3b, [], combination_type),
-    #                                        (response_id_3c, weight_3c, [...]) ], weight_3, combination_type),
-    #                      ... ]
-
-    if exist_dependencies:
-        return AnalyzerWithDependencies(internal_analyzer, model_part_controller, external_analyzer, dependency_graph)
-    else:
-        return Analyzer(internal_analyzer, model_part_controller, external_analyzer)
-
-# ------------------------------------------------------------------------------
-def _IdentifyInternalResponsesRecursively(responses):
-    internal_responses = []
-
-    for itr in range(responses.size()):
-        response_i = responses[itr]
-
-        if response_i.Has("is_combined"):
-            if response_i["is_combined"].GetBool():
-                internal_responses += _IdentifyInternalResponsesRecursively(response_i["combined_responses"])
-
-        if response_i["analyzer"].GetString() == "kratos":
-            identifier = response_i["identifier"].GetString()
-            kratos_settings = response_i["response_settings"]
-            internal_responses.append([identifier, kratos_settings])
-
-    return internal_responses
-
-# ------------------------------------------------------------------------------
-def _CreateDependencyGraphRecursively(responses):
-    dependency_graph = []
-    exist_dependencies = False
-
-    for itr in range(responses.size()):
-        response_i = responses[itr]
-        identifier = response_i["identifier"].GetString()
-        weight = response_i["weight"].GetDouble()
-        combination_type = response_i["combination_type"].GetString()
-
-        if response_i.Has("is_combined"):
-            if response_i["is_combined"].GetBool():
-                exist_dependencies = True
-                sub_dependency_graph, _ = _CreateDependencyGraphRecursively(response_i["combined_responses"])
-                dependency_graph.append((identifier, weight, sub_dependency_graph, combination_type))
-            else:
-                dependency_graph.append((identifier, weight, [], None))
-
-    return dependency_graph, exist_dependencies
-
-# ==============================================================================
-class Analyzer(AnalyzerBaseClass):
-    # --------------------------------------------------------------------------
-    def __init__(self, internal_analyzer, model_part_controller, external_analyzer):
-        self.model_part_controller = model_part_controller
-        self.internal_analyzer = internal_analyzer
-        self.external_analyzer = external_analyzer
-
-        if isinstance(internal_analyzer, EmptyAnalyzer) and  isinstance(external_analyzer, EmptyAnalyzer):
-            raise RuntimeError("Neither an internal nor an external analyzer is defined!")
-
-    # --------------------------------------------------------------------------
-    def InitializeBeforeOptimizationLoop(self):
-        self.internal_analyzer.InitializeBeforeOptimizationLoop()
-        self.external_analyzer.InitializeBeforeOptimizationLoop()
-
-    # --------------------------------------------------------------------------
-    def AnalyzeDesignAndReportToCommunicator(self, current_design, unique_iterator, communicator):
-        self.internal_analyzer.AnalyzeDesignAndReportToCommunicator(current_design, unique_iterator, communicator)
-        self.external_analyzer.AnalyzeDesignAndReportToCommunicator(current_design, unique_iterator, communicator)
-
-        self.__ResetPossibleShapeModificationsFromAnalysis()
-
-    # --------------------------------------------------------------------------
-    def FinalizeAfterOptimizationLoop(self):
-        self.internal_analyzer.FinalizeAfterOptimizationLoop()
-        self.external_analyzer.FinalizeAfterOptimizationLoop()
-
-    # --------------------------------------------------------------------------
-    def __ResetPossibleShapeModificationsFromAnalysis( self ):
-        self.model_part_controller.SetMeshToReferenceMesh()
-        self.model_part_controller.SetDeformationVariablesToZero()
-
-# ==============================================================================
-class AnalyzerWithDependencies(Analyzer):
-    # --------------------------------------------------------------------------
-    def __init__(self, internal_analyzer, model_part_controller, external_analyzer, dependency_graph):
-        super().__init__(internal_analyzer, model_part_controller, external_analyzer)
-
-        self.dependency_graph = dependency_graph
-        self.response_combination_filename = "response_combination.csv"
-        self.gradient_max_norms = {}
-
-    # --------------------------------------------------------------------------
-    def InitializeBeforeOptimizationLoop(self):
-        super().InitializeBeforeOptimizationLoop()
-
-        self.__InitializeOutputOfResponses()
-
-    # --------------------------------------------------------------------------
-    def AnalyzeDesignAndReportToCommunicator(self, current_design, unique_iterator, communicator):
-        self.__RequestResponsesAccordingDependencies(communicator)
-
-        super().AnalyzeDesignAndReportToCommunicator(current_design, unique_iterator, communicator)
-
-        self.__CombineResponsesAccordingDependencies(communicator)
-        self.__ComputeGradientNorms(communicator)
-        self.__WriteResultsOfCombinedResponses(unique_iterator,communicator)
-
-    # --------------------------------------------------------------------------
-    def __InitializeOutputOfResponses(self):
-        kratos_utilities.DeleteFileIfExisting(self.response_combination_filename)
-
-        with open(self.response_combination_filename, 'w') as csvfile:
-            writer = csv.writer(csvfile, delimiter=',')
-            response_ids = self.__GetIdentifiersRecursively(self.dependency_graph)
-
-            writer.writerow(["---------------------------------"])
-            for itr, identifier in enumerate(response_ids):
-                writer.writerow(["f"+str(itr)+": "+identifier])
-            writer.writerow(["---------------------------------"])
-
-            row = []
-            row.append("{:>4s}".format("itr"))
-            for itr, identifier in enumerate(response_ids):
-                row.append("{:>13s}".format("f"+str(itr)+"_value"))
-            for itr, identifier in enumerate(response_ids):
-                row.append("{:>13s}".format("||df"+str(itr)+"dx_st||"))
-            writer.writerow(row)
-
-    # --------------------------------------------------------------------------
-    def __GetIdentifiersRecursively(self, dependencies):
-        response_ids = []
-
-        for response_id, _, dependencies, _ in dependencies:
-            response_ids += [response_id]
-            if len(dependencies) > 0:
-                sub_identifiers = self.__GetIdentifiersRecursively(dependencies)
-                response_ids += sub_identifiers
-
-        return response_ids
-
-    # --------------------------------------------------------------------------
-    def __RequestResponsesAccordingDependencies(self, communicator):
-        for response_id, _, dependencies, _ in self.dependency_graph:
-            sub_response_ids = self.__GetIdentifiersRecursively(dependencies)
-
-            if communicator.isRequestingValueOf(response_id):
-                for sub_response_id in sub_response_ids:
-                    communicator.requestValueOf(sub_response_id)
-
-            if communicator.isRequestingGradientOf(response_id):
-                for sub_response_id in sub_response_ids:
-                    communicator.requestGradientOf(sub_response_id)
-
-    # --------------------------------------------------------------------------
-    def __CombineResponsesAccordingDependencies(self, communicator):
-        for response_id, _, dependencies, combination_type in self.dependency_graph:
-            if len(dependencies) > 0:
-                if communicator.isRequestingValueOf(response_id):
-                    combined_value = self.__ComputeCombinedValuesRecursively(dependencies, combination_type, communicator)
-                    communicator.reportValue(response_id, combined_value)
-
-        for response_id, _, dependencies, _ in self.dependency_graph:
-            if len(dependencies) > 0:
-                if communicator.isRequestingGradientOf(response_id):
-                    combined_gradient = self.__ComputeCombinedGradientsRecursively(dependencies, communicator)
-                    communicator.reportGradient(response_id, combined_gradient)
-
-    # --------------------------------------------------------------------------
-    def __ComputeCombinedValuesRecursively(self, dependencies, combination_type, communicator):
-        combined_value = None
-        relevant_responses = []
-
-        for response_id, weight, sub_dependencies, sub_combination_type in dependencies:
-            if len(sub_dependencies) > 0:
-                value = self.__ComputeCombinedValuesRecursively(sub_dependencies, sub_combination_type, communicator)
-                communicator.reportValue(response_id, value)
-            else:
-                value = communicator.getStandardizedValue(response_id)
-
-            value = weight*value
-
-            if combined_value is None:
-                combined_value = value
-                relevant_responses.append(response_id)
-            else:
-                if combination_type == "sum":
-                    combined_value += value
-                    relevant_responses.append(response_id)
-                elif combination_type == "max":
-                    if value > combined_value:
-                        relevant_responses = [response_id]
-                        combined_value = value
-                elif combination_type == "min":
-                    if value < combined_value:
-                        relevant_responses = [response_id]
-                        combined_value = value
-                else:
-                    raise NameError("The following combination_type is not supported:" + combination_type)
-
-        for response_id, _, _, _ in dependencies:
-            if response_id not in relevant_responses:
-                communicator.updateRequest(response_id, request_value=True, request_gradient=False)
-
-        return combined_value
-
-    # --------------------------------------------------------------------------
-    def __ComputeCombinedGradientsRecursively(self, dependencies, communicator):
-        combined_gradient = {}
-
-        for response_id, weight, sub_dependencies, _ in dependencies:
-            if communicator.isRequestingGradientOf(response_id):
-                if len(sub_dependencies) > 0:
-                    gradient = self.__ComputeCombinedGradientsRecursively(sub_dependencies, communicator)
-                    communicator.reportGradient(response_id, gradient)
-                else:
-                    gradient = communicator.getStandardizedGradient(response_id)
-
-                for vector in gradient.values():
-                    vector[0] *= weight
-                    vector[1] *= weight
-                    vector[2] *= weight
-
-                if not combined_gradient:
-                    # initialize combined gradient with zeros
-                    combined_gradient = {key: [0.0, 0.0, 0.0] for key in gradient.keys()}
-
-                # Perform nodal sum
-                for key_a, vector_a in combined_gradient.items():
-                    vector_b = gradient[key_a]
-                    vector_a[0] += vector_b[0]
-                    vector_a[1] += vector_b[1]
-                    vector_a[2] += vector_b[2]
-
-        return combined_gradient
-
-    # --------------------------------------------------------------------------
-    def __ComputeGradientNorms(self, communicator):
-        response_ids = self.__GetIdentifiersRecursively(self.dependency_graph)
-
-        for response_id in response_ids:
-            if communicator.isRequestingGradientOf(response_id):
-                gradient = communicator.getStandardizedGradient(response_id)
-
-                nodal_norms = [ entry[0]**2 + entry[1]**2 + entry[2]**2 for entry in gradient.values() ]
-                max_norm = math.sqrt(max(nodal_norms))
-                self.gradient_max_norms[response_id] = max_norm
-
-    # --------------------------------------------------------------------------
-    def __WriteResultsOfCombinedResponses(self, iteration, communicator):
-        with open(self.response_combination_filename, 'a') as csvfile:
-            writer = csv.writer(csvfile, delimiter=',')
-
-            identifiers = self.__GetIdentifiersRecursively(self.dependency_graph)
-            values = []
-            for response_id in identifiers:
-                values.append(communicator.getValue(response_id))
-
-            row = []
-            row.append("{:>4d}".format(iteration))
-            for identifier, value in zip(identifiers, values):
-                row.append(" {:> .5E}".format(value))
-            for identifier, value in zip(identifiers, values):
-                if communicator.isRequestingGradientOf(identifier):
-                    row.append(" {:> .5E}".format(self.gradient_max_norms[identifier]))
-                else:
-                    row.append("            -")
-
-            writer.writerow(row)
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#
+# ==============================================================================
+
+
+# additional imports
+from KratosMultiphysics.ShapeOptimizationApplication.analyzers.analyzer_internal import KratosInternalAnalyzer
+from KratosMultiphysics.ShapeOptimizationApplication.analyzers.analyzer_empty import EmptyAnalyzer
+from KratosMultiphysics.ShapeOptimizationApplication.analyzers.analyzer_base import AnalyzerBaseClass
+import KratosMultiphysics.kratos_utilities as kratos_utilities
+import csv, math
+import copy
+
+# ==============================================================================
+def CreateAnalyzer(optimization_settings, model_part_controller, external_analyzer):
+    objectives = optimization_settings["objectives"]
+    constraints = optimization_settings["constraints"]
+
+    internal_objectives = _IdentifyInternalResponsesRecursively(objectives)
+    internal_constraints = _IdentifyInternalResponsesRecursively(constraints)
+    internal_responses = internal_objectives + internal_constraints
+    # internal_responses = [ (response_id_1, kratos_settings_1),
+    #                        (response_id_2, kratos_settings_2),
+    #                        ... ]
+
+    if len(internal_responses) > 0:
+        internal_analyzer = KratosInternalAnalyzer(internal_responses, model_part_controller)
+    else:
+        internal_analyzer = EmptyAnalyzer()
+
+    dependency_graph, exist_dependencies = _CreateDependencyGraphRecursively(objectives)
+    # dependency_graph = [ (response_id_1, weight_1, [], combination_type),
+    #                      (response_id_2, weight_2, [], combination_type),
+    #                      (response_id_3, [ (response_id_3a, weight_3a, [], combination_type),
+    #                                        (response_id_3b, weight_3b, [], combination_type),
+    #                                        (response_id_3c, weight_3c, [...]) ], weight_3, combination_type),
+    #                      ... ]
+
+    if exist_dependencies:
+        return AnalyzerWithDependencies(internal_analyzer, model_part_controller, external_analyzer, dependency_graph)
+    else:
+        return Analyzer(internal_analyzer, model_part_controller, external_analyzer)
+
+# ------------------------------------------------------------------------------
+def _IdentifyInternalResponsesRecursively(responses):
+    internal_responses = []
+
+    for itr in range(responses.size()):
+        response_i = responses[itr]
+
+        if response_i.Has("is_combined"):
+            if response_i["is_combined"].GetBool():
+                internal_responses += _IdentifyInternalResponsesRecursively(response_i["combined_responses"])
+
+        if response_i["analyzer"].GetString() == "kratos":
+            identifier = response_i["identifier"].GetString()
+            kratos_settings = response_i["response_settings"]
+            internal_responses.append([identifier, kratos_settings])
+
+    return internal_responses
+
+# ------------------------------------------------------------------------------
+def _CreateDependencyGraphRecursively(responses):
+    dependency_graph = []
+    exist_dependencies = False
+
+    for itr in range(responses.size()):
+        response_i = responses[itr]
+        identifier = response_i["identifier"].GetString()
+        weight = response_i["weight"].GetDouble()
+        combination_type = response_i["combination_type"].GetString()
+
+        if response_i.Has("is_combined"):
+            if response_i["is_combined"].GetBool():
+                exist_dependencies = True
+                sub_dependency_graph, _ = _CreateDependencyGraphRecursively(response_i["combined_responses"])
+                dependency_graph.append((identifier, weight, sub_dependency_graph, combination_type))
+            else:
+                dependency_graph.append((identifier, weight, [], None))
+
+    return dependency_graph, exist_dependencies
+
+# ==============================================================================
+class Analyzer(AnalyzerBaseClass):
+    # --------------------------------------------------------------------------
+    def __init__(self, internal_analyzer, model_part_controller, external_analyzer):
+        self.model_part_controller = model_part_controller
+        self.internal_analyzer = internal_analyzer
+        self.external_analyzer = external_analyzer
+
+        if isinstance(internal_analyzer, EmptyAnalyzer) and  isinstance(external_analyzer, EmptyAnalyzer):
+            raise RuntimeError("Neither an internal nor an external analyzer is defined!")
+
+    # --------------------------------------------------------------------------
+    def InitializeBeforeOptimizationLoop(self):
+        self.internal_analyzer.InitializeBeforeOptimizationLoop()
+        self.external_analyzer.InitializeBeforeOptimizationLoop()
+
+    # --------------------------------------------------------------------------
+    def AnalyzeDesignAndReportToCommunicator(self, current_design, unique_iterator, communicator):
+        self.internal_analyzer.AnalyzeDesignAndReportToCommunicator(current_design, unique_iterator, communicator)
+        self.external_analyzer.AnalyzeDesignAndReportToCommunicator(current_design, unique_iterator, communicator)
+
+        self.__ResetPossibleShapeModificationsFromAnalysis()
+
+    # --------------------------------------------------------------------------
+    def FinalizeAfterOptimizationLoop(self):
+        self.internal_analyzer.FinalizeAfterOptimizationLoop()
+        self.external_analyzer.FinalizeAfterOptimizationLoop()
+
+    # --------------------------------------------------------------------------
+    def __ResetPossibleShapeModificationsFromAnalysis( self ):
+        self.model_part_controller.SetMeshToReferenceMesh()
+        self.model_part_controller.SetDeformationVariablesToZero()
+
+# ==============================================================================
+class AnalyzerWithDependencies(Analyzer):
+    # --------------------------------------------------------------------------
+    def __init__(self, internal_analyzer, model_part_controller, external_analyzer, dependency_graph):
+        super().__init__(internal_analyzer, model_part_controller, external_analyzer)
+
+        self.dependency_graph = dependency_graph
+        self.response_combination_filename = "response_combination.csv"
+        self.gradient_max_norms = {}
+
+    # --------------------------------------------------------------------------
+    def InitializeBeforeOptimizationLoop(self):
+        super().InitializeBeforeOptimizationLoop()
+
+        self.__InitializeOutputOfResponses()
+
+    # --------------------------------------------------------------------------
+    def AnalyzeDesignAndReportToCommunicator(self, current_design, unique_iterator, communicator):
+        self.__RequestResponsesAccordingDependencies(communicator)
+
+        super().AnalyzeDesignAndReportToCommunicator(current_design, unique_iterator, communicator)
+
+        self.__CombineResponsesAccordingDependencies(communicator)
+        self.__ComputeGradientNorms(communicator)
+        self.__WriteResultsOfCombinedResponses(unique_iterator,communicator)
+
+    # --------------------------------------------------------------------------
+    def __InitializeOutputOfResponses(self):
+        kratos_utilities.DeleteFileIfExisting(self.response_combination_filename)
+
+        with open(self.response_combination_filename, 'w') as csvfile:
+            writer = csv.writer(csvfile, delimiter=',')
+            response_ids = self.__GetIdentifiersRecursively(self.dependency_graph)
+
+            writer.writerow(["---------------------------------"])
+            for itr, identifier in enumerate(response_ids):
+                writer.writerow(["f"+str(itr)+": "+identifier])
+            writer.writerow(["---------------------------------"])
+
+            row = []
+            row.append("{:>4s}".format("itr"))
+            for itr, identifier in enumerate(response_ids):
+                row.append("{:>13s}".format("f"+str(itr)+"_value"))
+            for itr, identifier in enumerate(response_ids):
+                row.append("{:>13s}".format("||df"+str(itr)+"dx_st||"))
+            writer.writerow(row)
+
+    # --------------------------------------------------------------------------
+    def __GetIdentifiersRecursively(self, dependencies):
+        response_ids = []
+
+        for response_id, _, dependencies, _ in dependencies:
+            response_ids += [response_id]
+            if len(dependencies) > 0:
+                sub_identifiers = self.__GetIdentifiersRecursively(dependencies)
+                response_ids += sub_identifiers
+
+        return response_ids
+
+    # --------------------------------------------------------------------------
+    def __RequestResponsesAccordingDependencies(self, communicator):
+        for response_id, _, dependencies, _ in self.dependency_graph:
+            sub_response_ids = self.__GetIdentifiersRecursively(dependencies)
+
+            if communicator.isRequestingValueOf(response_id):
+                for sub_response_id in sub_response_ids:
+                    communicator.requestValueOf(sub_response_id)
+
+            if communicator.isRequestingGradientOf(response_id):
+                for sub_response_id in sub_response_ids:
+                    communicator.requestGradientOf(sub_response_id)
+
+    # --------------------------------------------------------------------------
+    def __CombineResponsesAccordingDependencies(self, communicator):
+        for response_id, _, dependencies, combination_type in self.dependency_graph:
+            if len(dependencies) > 0:
+                if communicator.isRequestingValueOf(response_id):
+                    combined_value = self.__ComputeCombinedValuesRecursively(dependencies, combination_type, communicator)
+                    communicator.reportValue(response_id, combined_value)
+
+        for response_id, _, dependencies, _ in self.dependency_graph:
+            if len(dependencies) > 0:
+                if communicator.isRequestingGradientOf(response_id):
+                    combined_gradient = self.__ComputeCombinedGradientsRecursively(dependencies, communicator)
+                    communicator.reportGradient(response_id, combined_gradient)
+
+    # --------------------------------------------------------------------------
+    def __ComputeCombinedValuesRecursively(self, dependencies, combination_type, communicator):
+        combined_value = None
+        relevant_responses = []
+
+        for response_id, weight, sub_dependencies, sub_combination_type in dependencies:
+            if len(sub_dependencies) > 0:
+                value = self.__ComputeCombinedValuesRecursively(sub_dependencies, sub_combination_type, communicator)
+                communicator.reportValue(response_id, value)
+            else:
+                value = communicator.getStandardizedValue(response_id)
+
+            value = weight*value
+
+            if combined_value is None:
+                combined_value = value
+                relevant_responses.append(response_id)
+            else:
+                if combination_type == "sum":
+                    combined_value += value
+                    relevant_responses.append(response_id)
+                elif combination_type == "max":
+                    if value > combined_value:
+                        relevant_responses = [response_id]
+                        combined_value = value
+                elif combination_type == "min":
+                    if value < combined_value:
+                        relevant_responses = [response_id]
+                        combined_value = value
+                else:
+                    raise NameError("The following combination_type is not supported:" + combination_type)
+
+        for response_id, _, _, _ in dependencies:
+            if response_id not in relevant_responses:
+                communicator.updateRequest(response_id, request_value=True, request_gradient=False)
+
+        return combined_value
+
+    # --------------------------------------------------------------------------
+    def __ComputeCombinedGradientsRecursively(self, dependencies, communicator):
+        combined_gradient = {}
+
+        for response_id, weight, sub_dependencies, _ in dependencies:
+            if communicator.isRequestingGradientOf(response_id):
+                if len(sub_dependencies) > 0:
+                    gradient = self.__ComputeCombinedGradientsRecursively(sub_dependencies, communicator)
+                    communicator.reportGradient(response_id, gradient)
+                else:
+                    gradient = communicator.getStandardizedGradient(response_id)
+
+                for vector in gradient.values():
+                    vector[0] *= weight
+                    vector[1] *= weight
+                    vector[2] *= weight
+
+                if not combined_gradient:
+                    # initialize combined gradient with zeros
+                    combined_gradient = {key: [0.0, 0.0, 0.0] for key in gradient.keys()}
+
+                # Perform nodal sum
+                for key_a, vector_a in combined_gradient.items():
+                    vector_b = gradient[key_a]
+                    vector_a[0] += vector_b[0]
+                    vector_a[1] += vector_b[1]
+                    vector_a[2] += vector_b[2]
+
+        return combined_gradient
+
+    # --------------------------------------------------------------------------
+    def __ComputeGradientNorms(self, communicator):
+        response_ids = self.__GetIdentifiersRecursively(self.dependency_graph)
+
+        for response_id in response_ids:
+            if communicator.isRequestingGradientOf(response_id):
+                gradient = communicator.getStandardizedGradient(response_id)
+
+                nodal_norms = [ entry[0]**2 + entry[1]**2 + entry[2]**2 for entry in gradient.values() ]
+                max_norm = math.sqrt(max(nodal_norms))
+                self.gradient_max_norms[response_id] = max_norm
+
+    # --------------------------------------------------------------------------
+    def __WriteResultsOfCombinedResponses(self, iteration, communicator):
+        with open(self.response_combination_filename, 'a') as csvfile:
+            writer = csv.writer(csvfile, delimiter=',')
+
+            identifiers = self.__GetIdentifiersRecursively(self.dependency_graph)
+            values = []
+            for response_id in identifiers:
+                values.append(communicator.getValue(response_id))
+
+            row = []
+            row.append("{:>4d}".format(iteration))
+            for identifier, value in zip(identifiers, values):
+                row.append(" {:> .5E}".format(value))
+            for identifier, value in zip(identifiers, values):
+                if communicator.isRequestingGradientOf(identifier):
+                    row.append(" {:> .5E}".format(self.gradient_max_norms[identifier]))
+                else:
+                    row.append("            -")
+
+            writer.writerow(row)
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_empty.py

 * *Ordering differences only*

```diff
@@ -1,21 +1,21 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#
-# ==============================================================================
-
-
-# Additional imports
-from .analyzer_base import AnalyzerBaseClass
-
-# ==============================================================================
-class EmptyAnalyzer( AnalyzerBaseClass ):
-    # --------------------------------------------------------------------------
-    def AnalyzeDesignAndReportToCommunicator( self, currentDesign, optimizationIteration, communicator ):
-        pass
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#
+# ==============================================================================
+
+
+# Additional imports
+from .analyzer_base import AnalyzerBaseClass
+
+# ==============================================================================
+class EmptyAnalyzer( AnalyzerBaseClass ):
+    # --------------------------------------------------------------------------
+    def AnalyzeDesignAndReportToCommunicator( self, currentDesign, optimizationIteration, communicator ):
+        pass
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_internal.py

 * *Ordering differences only*

```diff
@@ -1,155 +1,155 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#                   Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-import os, pathlib, sys
-
-# Kratos Core and Apps
-import KratosMultiphysics as KM
-
-# Additional imports
-from KratosMultiphysics.ShapeOptimizationApplication.analyzers.analyzer_base import AnalyzerBaseClass
-from KratosMultiphysics.ShapeOptimizationApplication.response_functions import response_function_factory as sho_response_factory
-try:
-    from KratosMultiphysics.StructuralMechanicsApplication import structural_response_function_factory as csm_response_factory
-except ImportError:
-    csm_response_factory = None
-try:
-    from KratosMultiphysics.ConvectionDiffusionApplication.response_functions import convection_diffusion_response_function_factory as convdiff_response_factory
-except ImportError:
-    convdiff_response_factory = None
-try:
-    from KratosMultiphysics.CompressiblePotentialFlowApplication import potential_flow_response_function_factory as potential_flow_response_factory
-except ImportError:
-    potential_flow_response_factory = None
-
-import time as timer
-
-class IterationScope:
-    def __init__(self, response_id, iteration_number, is_evaluated_in_folder):
-        self.is_evaluated_in_folder = is_evaluated_in_folder
-        if (self.is_evaluated_in_folder):
-            self.currentPath = pathlib.Path.cwd()
-            output_path = pathlib.Path("Design_Iterations")
-            response_text = "{:}/{:d}".format(response_id, iteration_number)
-            self.scope = output_path / response_text
-
-    def __enter__(self):
-        if (self.is_evaluated_in_folder):
-            self.scope.mkdir(parents=True, exist_ok=True)
-            sys.path.insert(0, str(self.scope.absolute()))
-            os.chdir(str(self.scope))
-
-    def __exit__(self, exc_type, exc_value, traceback):
-        if (self.is_evaluated_in_folder):
-            os.chdir(self.currentPath)
-            sys.path.remove(str(self.scope.absolute()))
-
-
-# ==============================================================================
-class KratosInternalAnalyzer( AnalyzerBaseClass ):
-    # --------------------------------------------------------------------------
-    def __init__( self, specified_responses, model_part_controller ):
-        self.model_part_controller = model_part_controller
-        self.response_functions = self.__CreateResponseFunctions(specified_responses, model_part_controller.GetModel())
-
-    # --------------------------------------------------------------------------
-    def InitializeBeforeOptimizationLoop( self ):
-        for response in self.response_functions.values():
-            response.Initialize()
-
-    # --------------------------------------------------------------------------
-    def AnalyzeDesignAndReportToCommunicator( self, currentDesign, optimizationIteration, communicator ):
-        optimization_model_part = self.model_part_controller.GetOptimizationModelPart()
-
-        time_before_analysis = optimization_model_part.ProcessInfo.GetValue(KM.TIME)
-        step_before_analysis = optimization_model_part.ProcessInfo.GetValue(KM.STEP)
-        delta_time_before_analysis = optimization_model_part.ProcessInfo.GetValue(KM.DELTA_TIME)
-
-        for identifier, response in self.response_functions.items():
-
-            # Reset step/time iterators such that they match the optimization iteration after calling CalculateValue (which internally calls CloneTimeStep)
-            optimization_model_part.ProcessInfo.SetValue(KM.STEP, step_before_analysis-1)
-            optimization_model_part.ProcessInfo.SetValue(KM.TIME, time_before_analysis-1)
-            optimization_model_part.ProcessInfo.SetValue(KM.DELTA_TIME, 0)
-
-            # now we scope in to the directory where response operations are done
-            with IterationScope(identifier, optimizationIteration, response.IsEvaluatedInFolder()):
-                response.UpdateDesign(optimization_model_part, KM.SHAPE_SENSITIVITY)
-
-                response.InitializeSolutionStep()
-
-                # response values
-                if communicator.isRequestingValueOf(identifier):
-                    response.CalculateValue()
-                    communicator.reportValue(identifier, response.GetValue())
-
-                # response gradients
-                if communicator.isRequestingGradientOf(identifier):
-                    response.CalculateGradient()
-                    communicator.reportGradient(identifier, response.GetNodalGradient(KM.SHAPE_SENSITIVITY))
-
-                response.FinalizeSolutionStep()
-
-            # Clear results or modifications on model part
-            optimization_model_part.ProcessInfo.SetValue(KM.STEP, step_before_analysis)
-            optimization_model_part.ProcessInfo.SetValue(KM.TIME, time_before_analysis)
-            optimization_model_part.ProcessInfo.SetValue(KM.DELTA_TIME, delta_time_before_analysis)
-
-            self.model_part_controller.SetMeshToReferenceMesh()
-            self.model_part_controller.SetDeformationVariablesToZero()
-
-    # --------------------------------------------------------------------------
-    def FinalizeAfterOptimizationLoop( self ):
-        for response in self.response_functions.values():
-            response.Finalize()
-
-    # --------------------------------------------------------------------------
-    @staticmethod
-    def __CreateResponseFunctions( specified_responses, model ):
-        response_functions = {}
-
-        sho_response_functions = [
-            "plane_based_packaging",
-            "mesh_based_packaging",
-            "surface_normal_shape_change",
-            "face_angle",
-            "airfoil_angle_of_attack",
-            "airfoil_chord_length",
-            "airfoil_perimeter"
-        ]
-        csm_response_functions = ["strain_energy", "mass", "eigenfrequency", "adjoint_local_stress", "adjoint_max_stress", "adjoint_nodal_displacement", "adjoint_linear_strain_energy", "adjoint_nodal_reaction"]
-        cps_response_functions = ["adjoint_lift_potential_jump", "stochastic_adjoint_lift_potential_jump"]
-        convdiff_response_functions = ["point_temperature"]
-
-        for (response_id, response_settings) in specified_responses:
-            if response_id in response_functions.keys():
-                raise NameError("There are multiple response functions with the following identifier: " + response_id)
-
-            response_type = response_settings["response_type"].GetString()
-
-            if response_type in csm_response_functions:
-                if csm_response_factory is None:
-                    raise RuntimeError("ShapeOpt: {} response function requires StructuralMechanicsApplication.".format(response_type))
-                response_functions[response_id] = csm_response_factory.CreateResponseFunction(response_id, response_settings, model)
-            elif response_type in convdiff_response_functions:
-                if convdiff_response_factory is None:
-                    raise RuntimeError("ShapeOpt: {} response function requires ConvectionDiffusionApplication.".format(response_type))
-                response_functions[response_id] = convdiff_response_factory.CreateResponseFunction(response_id, response_settings, model)
-            elif response_type in cps_response_functions:
-                if potential_flow_response_factory is None:
-                    raise RuntimeError("ShapeOpt: {} response function requires CompressiblePotentialFlowApplication.".format(response_type))
-                response_functions[response_id] = potential_flow_response_factory.CreateResponseFunction(response_id, response_settings, model)
-            elif response_type in sho_response_functions:
-                response_functions[response_id] = sho_response_factory.CreateResponseFunction(response_id, response_settings, model)
-            else:
-                raise NameError("The response function '{}' of type '{}' is not available.".format(response_id, response_type))
-
-        return response_functions
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#                   Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+import os, pathlib, sys
+
+# Kratos Core and Apps
+import KratosMultiphysics as KM
+
+# Additional imports
+from KratosMultiphysics.ShapeOptimizationApplication.analyzers.analyzer_base import AnalyzerBaseClass
+from KratosMultiphysics.ShapeOptimizationApplication.response_functions import response_function_factory as sho_response_factory
+try:
+    from KratosMultiphysics.StructuralMechanicsApplication import structural_response_function_factory as csm_response_factory
+except ImportError:
+    csm_response_factory = None
+try:
+    from KratosMultiphysics.ConvectionDiffusionApplication.response_functions import convection_diffusion_response_function_factory as convdiff_response_factory
+except ImportError:
+    convdiff_response_factory = None
+try:
+    from KratosMultiphysics.CompressiblePotentialFlowApplication import potential_flow_response_function_factory as potential_flow_response_factory
+except ImportError:
+    potential_flow_response_factory = None
+
+import time as timer
+
+class IterationScope:
+    def __init__(self, response_id, iteration_number, is_evaluated_in_folder):
+        self.is_evaluated_in_folder = is_evaluated_in_folder
+        if (self.is_evaluated_in_folder):
+            self.currentPath = pathlib.Path.cwd()
+            output_path = pathlib.Path("Design_Iterations")
+            response_text = "{:}/{:d}".format(response_id, iteration_number)
+            self.scope = output_path / response_text
+
+    def __enter__(self):
+        if (self.is_evaluated_in_folder):
+            self.scope.mkdir(parents=True, exist_ok=True)
+            sys.path.insert(0, str(self.scope.absolute()))
+            os.chdir(str(self.scope))
+
+    def __exit__(self, exc_type, exc_value, traceback):
+        if (self.is_evaluated_in_folder):
+            os.chdir(self.currentPath)
+            sys.path.remove(str(self.scope.absolute()))
+
+
+# ==============================================================================
+class KratosInternalAnalyzer( AnalyzerBaseClass ):
+    # --------------------------------------------------------------------------
+    def __init__( self, specified_responses, model_part_controller ):
+        self.model_part_controller = model_part_controller
+        self.response_functions = self.__CreateResponseFunctions(specified_responses, model_part_controller.GetModel())
+
+    # --------------------------------------------------------------------------
+    def InitializeBeforeOptimizationLoop( self ):
+        for response in self.response_functions.values():
+            response.Initialize()
+
+    # --------------------------------------------------------------------------
+    def AnalyzeDesignAndReportToCommunicator( self, currentDesign, optimizationIteration, communicator ):
+        optimization_model_part = self.model_part_controller.GetOptimizationModelPart()
+
+        time_before_analysis = optimization_model_part.ProcessInfo.GetValue(KM.TIME)
+        step_before_analysis = optimization_model_part.ProcessInfo.GetValue(KM.STEP)
+        delta_time_before_analysis = optimization_model_part.ProcessInfo.GetValue(KM.DELTA_TIME)
+
+        for identifier, response in self.response_functions.items():
+
+            # Reset step/time iterators such that they match the optimization iteration after calling CalculateValue (which internally calls CloneTimeStep)
+            optimization_model_part.ProcessInfo.SetValue(KM.STEP, step_before_analysis-1)
+            optimization_model_part.ProcessInfo.SetValue(KM.TIME, time_before_analysis-1)
+            optimization_model_part.ProcessInfo.SetValue(KM.DELTA_TIME, 0)
+
+            # now we scope in to the directory where response operations are done
+            with IterationScope(identifier, optimizationIteration, response.IsEvaluatedInFolder()):
+                response.UpdateDesign(optimization_model_part, KM.SHAPE_SENSITIVITY)
+
+                response.InitializeSolutionStep()
+
+                # response values
+                if communicator.isRequestingValueOf(identifier):
+                    response.CalculateValue()
+                    communicator.reportValue(identifier, response.GetValue())
+
+                # response gradients
+                if communicator.isRequestingGradientOf(identifier):
+                    response.CalculateGradient()
+                    communicator.reportGradient(identifier, response.GetNodalGradient(KM.SHAPE_SENSITIVITY))
+
+                response.FinalizeSolutionStep()
+
+            # Clear results or modifications on model part
+            optimization_model_part.ProcessInfo.SetValue(KM.STEP, step_before_analysis)
+            optimization_model_part.ProcessInfo.SetValue(KM.TIME, time_before_analysis)
+            optimization_model_part.ProcessInfo.SetValue(KM.DELTA_TIME, delta_time_before_analysis)
+
+            self.model_part_controller.SetMeshToReferenceMesh()
+            self.model_part_controller.SetDeformationVariablesToZero()
+
+    # --------------------------------------------------------------------------
+    def FinalizeAfterOptimizationLoop( self ):
+        for response in self.response_functions.values():
+            response.Finalize()
+
+    # --------------------------------------------------------------------------
+    @staticmethod
+    def __CreateResponseFunctions( specified_responses, model ):
+        response_functions = {}
+
+        sho_response_functions = [
+            "plane_based_packaging",
+            "mesh_based_packaging",
+            "surface_normal_shape_change",
+            "face_angle",
+            "airfoil_angle_of_attack",
+            "airfoil_chord_length",
+            "airfoil_perimeter"
+        ]
+        csm_response_functions = ["strain_energy", "mass", "eigenfrequency", "adjoint_local_stress", "adjoint_max_stress", "adjoint_nodal_displacement", "adjoint_linear_strain_energy", "adjoint_nodal_reaction"]
+        cps_response_functions = ["adjoint_lift_potential_jump", "stochastic_adjoint_lift_potential_jump"]
+        convdiff_response_functions = ["point_temperature"]
+
+        for (response_id, response_settings) in specified_responses:
+            if response_id in response_functions.keys():
+                raise NameError("There are multiple response functions with the following identifier: " + response_id)
+
+            response_type = response_settings["response_type"].GetString()
+
+            if response_type in csm_response_functions:
+                if csm_response_factory is None:
+                    raise RuntimeError("ShapeOpt: {} response function requires StructuralMechanicsApplication.".format(response_type))
+                response_functions[response_id] = csm_response_factory.CreateResponseFunction(response_id, response_settings, model)
+            elif response_type in convdiff_response_functions:
+                if convdiff_response_factory is None:
+                    raise RuntimeError("ShapeOpt: {} response function requires ConvectionDiffusionApplication.".format(response_type))
+                response_functions[response_id] = convdiff_response_factory.CreateResponseFunction(response_id, response_settings, model)
+            elif response_type in cps_response_functions:
+                if potential_flow_response_factory is None:
+                    raise RuntimeError("ShapeOpt: {} response function requires CompressiblePotentialFlowApplication.".format(response_type))
+                response_functions[response_id] = potential_flow_response_factory.CreateResponseFunction(response_id, response_settings, model)
+            elif response_type in sho_response_functions:
+                response_functions[response_id] = sho_response_factory.CreateResponseFunction(response_id, response_settings, model)
+            else:
+                raise NameError("The response function '{}' of type '{}' is not available.".format(response_id, response_type))
+
+        return response_functions
```

## KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_steepest_descent.py

 * *Ordering differences only*

```diff
@@ -1,255 +1,255 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#                   Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-
-# Kratos Core and Apps
-import KratosMultiphysics as KM
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-
-# Additional imports
-from KratosMultiphysics.ShapeOptimizationApplication.algorithms.algorithm_base import OptimizationAlgorithm
-from KratosMultiphysics.ShapeOptimizationApplication import mapper_factory
-from KratosMultiphysics.ShapeOptimizationApplication.loggers import data_logger_factory
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_variable_utilities import WriteDictionaryDataOnNodalVariable
-
-# ==============================================================================
-class AlgorithmSteepestDescent(OptimizationAlgorithm):
-    # --------------------------------------------------------------------------
-    def __init__(self, optimization_settings, analyzer, communicator, model_part_controller):
-        default_algorithm_settings = KM.Parameters("""
-        {
-            "name"               : "steepest_descent",
-            "max_iterations"     : 100,
-            "relative_tolerance" : 1e-3,
-            "gradient_tolerance" : 1e-5,
-            "line_search" : {
-                "line_search_type"           : "manual_stepping",
-                "normalize_search_direction" : true,
-                "step_size"                  : 1.0,
-                "estimation_tolerance"       : 0.1,
-                "increase_factor"            : 1.1,
-                "max_increase_factor"        : 10.0
-            }
-        }""")
-        self.algorithm_settings =  optimization_settings["optimization_algorithm"]
-        self.algorithm_settings.RecursivelyValidateAndAssignDefaults(default_algorithm_settings)
-
-        self.optimization_settings = optimization_settings
-        self.mapper_settings = optimization_settings["design_variables"]["filter"]
-
-        self.analyzer = analyzer
-        self.communicator = communicator
-        self.model_part_controller = model_part_controller
-
-        self.design_surface = None
-        self.mapper = None
-        self.data_logger = None
-        self.optimization_utilities = None
-
-        self.objectives = optimization_settings["objectives"]
-        self.constraints = optimization_settings["constraints"]
-
-        self.previos_objective_value = None
-
-        self.max_iterations = self.algorithm_settings["max_iterations"].GetInt() + 1
-        self.relative_tolerance = self.algorithm_settings["relative_tolerance"].GetDouble()
-        self.gradient_tolerance = self.algorithm_settings["gradient_tolerance"].GetDouble()
-        self.line_search_type = self.algorithm_settings["line_search"]["line_search_type"].GetString()
-        self.estimation_tolerance = self.algorithm_settings["line_search"]["estimation_tolerance"].GetDouble()
-        self.step_size = self.algorithm_settings["line_search"]["step_size"].GetDouble()
-        self.increase_factor = self.algorithm_settings["line_search"]["increase_factor"].GetDouble()
-        self.max_step_size = self.step_size*self.algorithm_settings["line_search"]["max_increase_factor"].GetDouble()
-
-        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.SEARCH_DIRECTION)
-
-    # --------------------------------------------------------------------------
-    def CheckApplicability(self):
-        if self.objectives.size() > 1:
-            raise RuntimeError("Steepest descent algorithm only supports one objective function!")
-        if self.constraints.size() > 0:
-            raise RuntimeError("Steepest descent algorithm does not allow for any constraints!")
-
-    # --------------------------------------------------------------------------
-    def InitializeOptimizationLoop(self):
-        self.model_part_controller.Initialize()
-
-        self.analyzer.InitializeBeforeOptimizationLoop()
-
-        self.design_surface = self.model_part_controller.GetDesignSurface()
-
-        self.mapper = mapper_factory.CreateMapper(self.design_surface, self.design_surface, self.mapper_settings)
-        self.mapper.Initialize()
-
-        self.model_part_controller.InitializeDamping()
-        self.data_logger = data_logger_factory.CreateDataLogger(self.model_part_controller, self.communicator, self.optimization_settings)
-        self.data_logger.InitializeDataLogging()
-
-        self.optimization_utilities = KSO.OptimizationUtilities
-
-    # --------------------------------------------------------------------------
-    def RunOptimizationLoop(self):
-        timer = Timer()
-        timer.StartTimer()
-
-        for self.optimization_iteration in range(1,self.max_iterations):
-            KM.Logger.Print("")
-            KM.Logger.Print("===============================================================================")
-            KM.Logger.PrintInfo("ShapeOpt", "",timer.GetTimeStamp(), ": Starting optimization iteration ",self.optimization_iteration)
-            KM.Logger.Print("===============================================================================\n")
-
-            timer.StartNewLap()
-
-            self.__initializeNewShape()
-
-            self.__analyzeShape()
-
-            if self.line_search_type == "adaptive_stepping" and self.optimization_iteration > 1:
-                self.__adjustStepSize()
-
-            self.__computeShapeUpdate()
-
-            self.__logCurrentOptimizationStep()
-
-            KM.Logger.Print("")
-            KM.Logger.PrintInfo("ShapeOpt", "Time needed for current optimization step = ", timer.GetLapTime(), "s")
-            KM.Logger.PrintInfo("ShapeOpt", "Time needed for total optimization so far = ", timer.GetTotalTime(), "s")
-
-            if self.__isAlgorithmConverged():
-                break
-            else:
-                self.__determineAbsoluteChanges()
-
-    # --------------------------------------------------------------------------
-    def FinalizeOptimizationLoop(self):
-        self.data_logger.FinalizeDataLogging()
-        self.analyzer.FinalizeAfterOptimizationLoop()
-
-    # --------------------------------------------------------------------------
-    def __initializeNewShape(self):
-        self.model_part_controller.UpdateTimeStep(self.optimization_iteration)
-        self.model_part_controller.UpdateMeshAccordingInputVariable(KSO.SHAPE_UPDATE)
-        self.model_part_controller.SetReferenceMeshToMesh()
-
-    # --------------------------------------------------------------------------
-    def __analyzeShape(self):
-        self.communicator.initializeCommunication()
-        self.communicator.requestValueOf(self.objectives[0]["identifier"].GetString())
-        self.communicator.requestGradientOf(self.objectives[0]["identifier"].GetString())
-
-        self.analyzer.AnalyzeDesignAndReportToCommunicator(self.optimization_model_part, self.optimization_iteration, self.communicator)
-
-        objGradientDict = self.communicator.getStandardizedGradient(self.objectives[0]["identifier"].GetString())
-        WriteDictionaryDataOnNodalVariable(objGradientDict, self.optimization_model_part, KSO.DF1DX)
-
-        if self.objectives[0]["project_gradient_on_surface_normals"].GetBool():
-            self.model_part_controller.ComputeUnitSurfaceNormals()
-            self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(KSO.DF1DX)
-
-        self.model_part_controller.DampNodalSensitivityVariableIfSpecified(KSO.DF1DX)
-
-    # --------------------------------------------------------------------------
-    def __adjustStepSize(self):
-        current_a = self.step_size
-
-        # Compare actual and estimated improvement using linear information from the previos step
-        dfda1 = 0.0
-        for node in self.design_surface.Nodes:
-            # The following variables are not yet updated and therefore contain the information from the previos step
-            s1 = node.GetSolutionStepValue(KSO.SEARCH_DIRECTION)
-            dfds1 = node.GetSolutionStepValue(KSO.DF1DX_MAPPED)
-            dfda1 += s1[0]*dfds1[0] + s1[1]*dfds1[1] + s1[2]*dfds1[2]
-
-        f2 = self.communicator.getStandardizedValue(self.objectives[0]["identifier"].GetString())
-        f1 = self.previos_objective_value
-
-        df_actual = f2 - f1
-        df_estimated = current_a*dfda1
-
-        # Adjust step size if necessary
-        if f2 < f1:
-            estimation_error = (df_actual-df_estimated)/df_actual
-
-            # Increase step size if estimation based on linear extrapolation matches the actual improvement within a specified tolerance
-            if estimation_error < self.estimation_tolerance:
-                new_a = min(current_a*self.increase_factor, self.max_step_size)
-
-            # Leave step size unchanged if a nonliner change in the objective is observed but still a descent direction is obtained
-            else:
-                new_a = current_a
-        else:
-            # Search approximation of optimal step using interpolation
-            a = current_a
-            corrected_step_size = - 0.5 * dfda1 * a**2 / (f2 - f1 - dfda1 * a )
-
-            # Starting from the new design, and assuming an opposite gradient direction, the step size to the approximated optimum behaves reciprocal
-            new_a = current_a-corrected_step_size
-
-        self.step_size = new_a
-
-    # --------------------------------------------------------------------------
-    def __computeShapeUpdate(self):
-        self.mapper.Update()
-        self.mapper.InverseMap(KSO.DF1DX, KSO.DF1DX_MAPPED)
-
-        self.optimization_utilities.ComputeSearchDirectionSteepestDescent(self.design_surface)
-        normalize = self.algorithm_settings["line_search"]["normalize_search_direction"].GetBool()
-        self.optimization_utilities.ComputeControlPointUpdate(self.design_surface, self.step_size, normalize)
-
-        self.mapper.Map(KSO.CONTROL_POINT_UPDATE, KSO.SHAPE_UPDATE)
-        self.model_part_controller.DampNodalUpdateVariableIfSpecified(KSO.SHAPE_UPDATE)
-
-    # --------------------------------------------------------------------------
-    def __logCurrentOptimizationStep(self):
-
-        self.previos_objective_value = self.communicator.getStandardizedValue(self.objectives[0]["identifier"].GetString())
-        self.norm_objective_gradient = self.optimization_utilities.ComputeL2NormOfNodalVariable(self.design_surface, KSO.DF1DX_MAPPED)
-
-        additional_values_to_log = {}
-        additional_values_to_log["step_size"] = self.step_size
-        additional_values_to_log["norm_objective_gradient"] = self.norm_objective_gradient
-        self.data_logger.LogSensitivityHeatmap(self.optimization_iteration, self.mapper)
-        self.data_logger.LogCurrentValues(self.optimization_iteration, additional_values_to_log)
-        self.data_logger.LogCurrentDesign(self.optimization_iteration)
-
-    # --------------------------------------------------------------------------
-    def __isAlgorithmConverged(self):
-
-        if self.optimization_iteration > 1 :
-            # Check if maximum iterations were reached
-            if self.optimization_iteration == self.max_iterations:
-                KM.Logger.Print("")
-                KM.Logger.PrintInfo("ShapeOpt", "Maximal iterations of optimization problem reached!")
-                return True
-
-            # Check gradient norm
-            if self.optimization_iteration == 2:
-                self.initial_norm_objective_gradient = self.norm_objective_gradient
-            else:
-                if self.norm_objective_gradient < self.gradient_tolerance*self.initial_norm_objective_gradient:
-                    KM.Logger.Print("")
-                    KM.Logger.PrintInfo("ShapeOpt", "Optimization problem converged as gradient norm reached specified tolerance of ",self.gradient_tolerance)
-                    return True
-
-            # Check for relative tolerance
-            relative_change_of_objective_value = self.data_logger.GetValues("rel_change_objective")[self.optimization_iteration]
-            if abs(relative_change_of_objective_value) < self.relative_tolerance:
-                KM.Logger.Print("")
-                KM.Logger.PrintInfo("ShapeOpt", "Optimization problem converged within a relative objective tolerance of ",self.relative_tolerance,"%.")
-                return True
-
-    # --------------------------------------------------------------------------
-    def __determineAbsoluteChanges(self):
-        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.CONTROL_POINT_UPDATE, KSO.CONTROL_POINT_CHANGE)
-        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.SHAPE_UPDATE, KSO.SHAPE_CHANGE)
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#                   Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+
+# Kratos Core and Apps
+import KratosMultiphysics as KM
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+
+# Additional imports
+from KratosMultiphysics.ShapeOptimizationApplication.algorithms.algorithm_base import OptimizationAlgorithm
+from KratosMultiphysics.ShapeOptimizationApplication import mapper_factory
+from KratosMultiphysics.ShapeOptimizationApplication.loggers import data_logger_factory
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_variable_utilities import WriteDictionaryDataOnNodalVariable
+
+# ==============================================================================
+class AlgorithmSteepestDescent(OptimizationAlgorithm):
+    # --------------------------------------------------------------------------
+    def __init__(self, optimization_settings, analyzer, communicator, model_part_controller):
+        default_algorithm_settings = KM.Parameters("""
+        {
+            "name"               : "steepest_descent",
+            "max_iterations"     : 100,
+            "relative_tolerance" : 1e-3,
+            "gradient_tolerance" : 1e-5,
+            "line_search" : {
+                "line_search_type"           : "manual_stepping",
+                "normalize_search_direction" : true,
+                "step_size"                  : 1.0,
+                "estimation_tolerance"       : 0.1,
+                "increase_factor"            : 1.1,
+                "max_increase_factor"        : 10.0
+            }
+        }""")
+        self.algorithm_settings =  optimization_settings["optimization_algorithm"]
+        self.algorithm_settings.RecursivelyValidateAndAssignDefaults(default_algorithm_settings)
+
+        self.optimization_settings = optimization_settings
+        self.mapper_settings = optimization_settings["design_variables"]["filter"]
+
+        self.analyzer = analyzer
+        self.communicator = communicator
+        self.model_part_controller = model_part_controller
+
+        self.design_surface = None
+        self.mapper = None
+        self.data_logger = None
+        self.optimization_utilities = None
+
+        self.objectives = optimization_settings["objectives"]
+        self.constraints = optimization_settings["constraints"]
+
+        self.previos_objective_value = None
+
+        self.max_iterations = self.algorithm_settings["max_iterations"].GetInt() + 1
+        self.relative_tolerance = self.algorithm_settings["relative_tolerance"].GetDouble()
+        self.gradient_tolerance = self.algorithm_settings["gradient_tolerance"].GetDouble()
+        self.line_search_type = self.algorithm_settings["line_search"]["line_search_type"].GetString()
+        self.estimation_tolerance = self.algorithm_settings["line_search"]["estimation_tolerance"].GetDouble()
+        self.step_size = self.algorithm_settings["line_search"]["step_size"].GetDouble()
+        self.increase_factor = self.algorithm_settings["line_search"]["increase_factor"].GetDouble()
+        self.max_step_size = self.step_size*self.algorithm_settings["line_search"]["max_increase_factor"].GetDouble()
+
+        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.SEARCH_DIRECTION)
+
+    # --------------------------------------------------------------------------
+    def CheckApplicability(self):
+        if self.objectives.size() > 1:
+            raise RuntimeError("Steepest descent algorithm only supports one objective function!")
+        if self.constraints.size() > 0:
+            raise RuntimeError("Steepest descent algorithm does not allow for any constraints!")
+
+    # --------------------------------------------------------------------------
+    def InitializeOptimizationLoop(self):
+        self.model_part_controller.Initialize()
+
+        self.analyzer.InitializeBeforeOptimizationLoop()
+
+        self.design_surface = self.model_part_controller.GetDesignSurface()
+
+        self.mapper = mapper_factory.CreateMapper(self.design_surface, self.design_surface, self.mapper_settings)
+        self.mapper.Initialize()
+
+        self.model_part_controller.InitializeDamping()
+        self.data_logger = data_logger_factory.CreateDataLogger(self.model_part_controller, self.communicator, self.optimization_settings)
+        self.data_logger.InitializeDataLogging()
+
+        self.optimization_utilities = KSO.OptimizationUtilities
+
+    # --------------------------------------------------------------------------
+    def RunOptimizationLoop(self):
+        timer = Timer()
+        timer.StartTimer()
+
+        for self.optimization_iteration in range(1,self.max_iterations):
+            KM.Logger.Print("")
+            KM.Logger.Print("===============================================================================")
+            KM.Logger.PrintInfo("ShapeOpt", "",timer.GetTimeStamp(), ": Starting optimization iteration ",self.optimization_iteration)
+            KM.Logger.Print("===============================================================================\n")
+
+            timer.StartNewLap()
+
+            self.__initializeNewShape()
+
+            self.__analyzeShape()
+
+            if self.line_search_type == "adaptive_stepping" and self.optimization_iteration > 1:
+                self.__adjustStepSize()
+
+            self.__computeShapeUpdate()
+
+            self.__logCurrentOptimizationStep()
+
+            KM.Logger.Print("")
+            KM.Logger.PrintInfo("ShapeOpt", "Time needed for current optimization step = ", timer.GetLapTime(), "s")
+            KM.Logger.PrintInfo("ShapeOpt", "Time needed for total optimization so far = ", timer.GetTotalTime(), "s")
+
+            if self.__isAlgorithmConverged():
+                break
+            else:
+                self.__determineAbsoluteChanges()
+
+    # --------------------------------------------------------------------------
+    def FinalizeOptimizationLoop(self):
+        self.data_logger.FinalizeDataLogging()
+        self.analyzer.FinalizeAfterOptimizationLoop()
+
+    # --------------------------------------------------------------------------
+    def __initializeNewShape(self):
+        self.model_part_controller.UpdateTimeStep(self.optimization_iteration)
+        self.model_part_controller.UpdateMeshAccordingInputVariable(KSO.SHAPE_UPDATE)
+        self.model_part_controller.SetReferenceMeshToMesh()
+
+    # --------------------------------------------------------------------------
+    def __analyzeShape(self):
+        self.communicator.initializeCommunication()
+        self.communicator.requestValueOf(self.objectives[0]["identifier"].GetString())
+        self.communicator.requestGradientOf(self.objectives[0]["identifier"].GetString())
+
+        self.analyzer.AnalyzeDesignAndReportToCommunicator(self.optimization_model_part, self.optimization_iteration, self.communicator)
+
+        objGradientDict = self.communicator.getStandardizedGradient(self.objectives[0]["identifier"].GetString())
+        WriteDictionaryDataOnNodalVariable(objGradientDict, self.optimization_model_part, KSO.DF1DX)
+
+        if self.objectives[0]["project_gradient_on_surface_normals"].GetBool():
+            self.model_part_controller.ComputeUnitSurfaceNormals()
+            self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(KSO.DF1DX)
+
+        self.model_part_controller.DampNodalSensitivityVariableIfSpecified(KSO.DF1DX)
+
+    # --------------------------------------------------------------------------
+    def __adjustStepSize(self):
+        current_a = self.step_size
+
+        # Compare actual and estimated improvement using linear information from the previos step
+        dfda1 = 0.0
+        for node in self.design_surface.Nodes:
+            # The following variables are not yet updated and therefore contain the information from the previos step
+            s1 = node.GetSolutionStepValue(KSO.SEARCH_DIRECTION)
+            dfds1 = node.GetSolutionStepValue(KSO.DF1DX_MAPPED)
+            dfda1 += s1[0]*dfds1[0] + s1[1]*dfds1[1] + s1[2]*dfds1[2]
+
+        f2 = self.communicator.getStandardizedValue(self.objectives[0]["identifier"].GetString())
+        f1 = self.previos_objective_value
+
+        df_actual = f2 - f1
+        df_estimated = current_a*dfda1
+
+        # Adjust step size if necessary
+        if f2 < f1:
+            estimation_error = (df_actual-df_estimated)/df_actual
+
+            # Increase step size if estimation based on linear extrapolation matches the actual improvement within a specified tolerance
+            if estimation_error < self.estimation_tolerance:
+                new_a = min(current_a*self.increase_factor, self.max_step_size)
+
+            # Leave step size unchanged if a nonliner change in the objective is observed but still a descent direction is obtained
+            else:
+                new_a = current_a
+        else:
+            # Search approximation of optimal step using interpolation
+            a = current_a
+            corrected_step_size = - 0.5 * dfda1 * a**2 / (f2 - f1 - dfda1 * a )
+
+            # Starting from the new design, and assuming an opposite gradient direction, the step size to the approximated optimum behaves reciprocal
+            new_a = current_a-corrected_step_size
+
+        self.step_size = new_a
+
+    # --------------------------------------------------------------------------
+    def __computeShapeUpdate(self):
+        self.mapper.Update()
+        self.mapper.InverseMap(KSO.DF1DX, KSO.DF1DX_MAPPED)
+
+        self.optimization_utilities.ComputeSearchDirectionSteepestDescent(self.design_surface)
+        normalize = self.algorithm_settings["line_search"]["normalize_search_direction"].GetBool()
+        self.optimization_utilities.ComputeControlPointUpdate(self.design_surface, self.step_size, normalize)
+
+        self.mapper.Map(KSO.CONTROL_POINT_UPDATE, KSO.SHAPE_UPDATE)
+        self.model_part_controller.DampNodalUpdateVariableIfSpecified(KSO.SHAPE_UPDATE)
+
+    # --------------------------------------------------------------------------
+    def __logCurrentOptimizationStep(self):
+
+        self.previos_objective_value = self.communicator.getStandardizedValue(self.objectives[0]["identifier"].GetString())
+        self.norm_objective_gradient = self.optimization_utilities.ComputeL2NormOfNodalVariable(self.design_surface, KSO.DF1DX_MAPPED)
+
+        additional_values_to_log = {}
+        additional_values_to_log["step_size"] = self.step_size
+        additional_values_to_log["norm_objective_gradient"] = self.norm_objective_gradient
+        self.data_logger.LogSensitivityHeatmap(self.optimization_iteration, self.mapper)
+        self.data_logger.LogCurrentValues(self.optimization_iteration, additional_values_to_log)
+        self.data_logger.LogCurrentDesign(self.optimization_iteration)
+
+    # --------------------------------------------------------------------------
+    def __isAlgorithmConverged(self):
+
+        if self.optimization_iteration > 1 :
+            # Check if maximum iterations were reached
+            if self.optimization_iteration == self.max_iterations:
+                KM.Logger.Print("")
+                KM.Logger.PrintInfo("ShapeOpt", "Maximal iterations of optimization problem reached!")
+                return True
+
+            # Check gradient norm
+            if self.optimization_iteration == 2:
+                self.initial_norm_objective_gradient = self.norm_objective_gradient
+            else:
+                if self.norm_objective_gradient < self.gradient_tolerance*self.initial_norm_objective_gradient:
+                    KM.Logger.Print("")
+                    KM.Logger.PrintInfo("ShapeOpt", "Optimization problem converged as gradient norm reached specified tolerance of ",self.gradient_tolerance)
+                    return True
+
+            # Check for relative tolerance
+            relative_change_of_objective_value = self.data_logger.GetValues("rel_change_objective")[self.optimization_iteration]
+            if abs(relative_change_of_objective_value) < self.relative_tolerance:
+                KM.Logger.Print("")
+                KM.Logger.PrintInfo("ShapeOpt", "Optimization problem converged within a relative objective tolerance of ",self.relative_tolerance,"%.")
+                return True
+
+    # --------------------------------------------------------------------------
+    def __determineAbsoluteChanges(self):
+        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.CONTROL_POINT_UPDATE, KSO.CONTROL_POINT_CHANGE)
+        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.SHAPE_UPDATE, KSO.SHAPE_CHANGE)
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_gradient_projection.py

 * *Ordering differences only*

```diff
@@ -1,317 +1,317 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#                   Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-
-# Kratos Core and Apps
-import KratosMultiphysics as KM
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-from KratosMultiphysics.LinearSolversApplication import dense_linear_solver_factory
-
-# Additional imports
-from KratosMultiphysics.ShapeOptimizationApplication.algorithms.algorithm_base import OptimizationAlgorithm
-from KratosMultiphysics.ShapeOptimizationApplication import mapper_factory
-from KratosMultiphysics.ShapeOptimizationApplication.loggers import data_logger_factory
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_variable_utilities import WriteDictionaryDataOnNodalVariable
-
-import math
-
-# ==============================================================================
-class AlgorithmGradientProjection(OptimizationAlgorithm):
-    # --------------------------------------------------------------------------
-    def __init__(self, optimization_settings, analyzer, communicator, model_part_controller):
-        default_algorithm_settings = KM.Parameters("""
-        {
-            "name"                    : "penalized_projection",
-            "max_correction_share"    : 0.75,
-            "max_iterations"          : 100,
-            "relative_tolerance"      : 1e-3,
-            "line_search" : {
-                "line_search_type"           : "manual_stepping",
-                "normalize_search_direction" : true,
-                "step_size"                  : 1.0
-            }
-        }""")
-        self.algorithm_settings =  optimization_settings["optimization_algorithm"]
-        self.algorithm_settings.RecursivelyValidateAndAssignDefaults(default_algorithm_settings)
-
-        self.optimization_settings = optimization_settings
-        self.mapper_settings = optimization_settings["design_variables"]["filter"]
-
-        self.analyzer = analyzer
-        self.communicator = communicator
-        self.model_part_controller = model_part_controller
-
-        self.design_surface = None
-        self.mapper = None
-        self.data_logger = None
-        self.optimization_utilities = None
-
-        self.objectives = optimization_settings["objectives"]
-        self.constraints = optimization_settings["constraints"]
-        self.constraint_gradient_variables = {}
-        for itr, constraint in enumerate(self.constraints.values()):
-            self.constraint_gradient_variables.update({
-                constraint["identifier"].GetString() : {
-                    "gradient": KM.KratosGlobals.GetVariable(f"DC{(itr+1)}DX"),
-                    "mapped_gradient": KM.KratosGlobals.GetVariable(f"DC{(itr+1)}DX_MAPPED")
-                }
-            })
-        self.max_correction_share = self.algorithm_settings["max_correction_share"].GetDouble()
-
-        self.step_size = self.algorithm_settings["line_search"]["step_size"].GetDouble()
-        self.max_iterations = self.algorithm_settings["max_iterations"].GetInt() + 1
-        self.relative_tolerance = self.algorithm_settings["relative_tolerance"].GetDouble()
-
-        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.SEARCH_DIRECTION)
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.CORRECTION)
-
-    # --------------------------------------------------------------------------
-    def CheckApplicability(self):
-        if self.objectives.size() > 1:
-            raise RuntimeError("Gradient projection algorithm only supports one objective function!")
-        if self.constraints.size() == 0:
-            raise RuntimeError("Gradient projection algorithm requires definition of at least one constraint!")
-
-    # --------------------------------------------------------------------------
-    def InitializeOptimizationLoop(self):
-        self.model_part_controller.Initialize()
-
-        self.analyzer.InitializeBeforeOptimizationLoop()
-
-        self.design_surface = self.model_part_controller.GetDesignSurface()
-
-        self.mapper = mapper_factory.CreateMapper(self.design_surface, self.design_surface, self.mapper_settings)
-        self.mapper.Initialize()
-        self.model_part_controller.InitializeDamping()
-
-        self.data_logger = data_logger_factory.CreateDataLogger(self.model_part_controller, self.communicator, self.optimization_settings)
-        self.data_logger.InitializeDataLogging()
-
-        self.optimization_utilities = KSO.OptimizationUtilities
-
-    # --------------------------------------------------------------------------
-    def RunOptimizationLoop(self):
-        timer = Timer()
-        timer.StartTimer()
-
-        for self.optimization_iteration in range(1,self.max_iterations):
-            KM.Logger.Print("")
-            KM.Logger.Print("===============================================================================")
-            KM.Logger.PrintInfo("ShapeOpt", timer.GetTimeStamp(), ": Starting optimization iteration ", self.optimization_iteration)
-            KM.Logger.Print("===============================================================================\n")
-
-            timer.StartNewLap()
-
-            self.__initializeNewShape()
-
-            self.__analyzeShape()
-
-            self.__computeShapeUpdate()
-
-            self.__logCurrentOptimizationStep()
-
-            KM.Logger.Print("")
-            KM.Logger.PrintInfo("ShapeOpt", "Time needed for current optimization step = ", timer.GetLapTime(), "s")
-            KM.Logger.PrintInfo("ShapeOpt", "Time needed for total optimization so far = ", timer.GetTotalTime(), "s")
-
-            if self.__isAlgorithmConverged():
-                break
-            else:
-                self.__determineAbsoluteChanges()
-
-    # --------------------------------------------------------------------------
-    def FinalizeOptimizationLoop(self):
-        self.data_logger.FinalizeDataLogging()
-        self.analyzer.FinalizeAfterOptimizationLoop()
-
-    # --------------------------------------------------------------------------
-    def __initializeNewShape(self):
-        self.model_part_controller.UpdateTimeStep(self.optimization_iteration)
-        self.model_part_controller.UpdateMeshAccordingInputVariable(KSO.SHAPE_UPDATE)
-        self.model_part_controller.SetReferenceMeshToMesh()
-
-    # --------------------------------------------------------------------------
-    def __analyzeShape(self):
-        self.communicator.initializeCommunication()
-        self.communicator.requestValueOf(self.objectives[0]["identifier"].GetString())
-        self.communicator.requestGradientOf(self.objectives[0]["identifier"].GetString())
-
-        for constraint in self.constraints.values():
-            con_id =  constraint["identifier"].GetString()
-            self.communicator.requestValueOf(con_id)
-            self.communicator.requestGradientOf(con_id)
-
-        self.analyzer.AnalyzeDesignAndReportToCommunicator(self.optimization_model_part, self.optimization_iteration, self.communicator)
-
-        # compute normals only if required
-        surface_normals_required = self.objectives[0]["project_gradient_on_surface_normals"].GetBool()
-        for constraint in self.constraints.values():
-            if constraint["project_gradient_on_surface_normals"].GetBool():
-                surface_normals_required = True
-
-        if surface_normals_required:
-            self.model_part_controller.ComputeUnitSurfaceNormals()
-
-        # project and damp objective gradients
-        objGradientDict = self.communicator.getStandardizedGradient(self.objectives[0]["identifier"].GetString())
-        WriteDictionaryDataOnNodalVariable(objGradientDict, self.optimization_model_part, KSO.DF1DX)
-
-        if self.objectives[0]["project_gradient_on_surface_normals"].GetBool():
-            self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(KSO.DF1DX)
-
-        self.model_part_controller.DampNodalSensitivityVariableIfSpecified(KSO.DF1DX)
-
-        # project and damp constraint gradients
-        for constraint in self.constraints.values():
-            con_id = constraint["identifier"].GetString()
-            conGradientDict = self.communicator.getStandardizedGradient(con_id)
-            gradient_variable = self.constraint_gradient_variables[con_id]["gradient"]
-            WriteDictionaryDataOnNodalVariable(conGradientDict, self.optimization_model_part, gradient_variable)
-
-            if constraint["project_gradient_on_surface_normals"].GetBool():
-                self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(gradient_variable)
-
-            self.model_part_controller.DampNodalSensitivityVariableIfSpecified(gradient_variable)
-
-    # --------------------------------------------------------------------------
-    def __computeShapeUpdate(self):
-        self.mapper.Update()
-        self.mapper.InverseMap(KSO.DF1DX, KSO.DF1DX_MAPPED)
-
-        for constraint in self.constraints.values():
-            con_id = constraint["identifier"].GetString()
-            gradient_variable = self.constraint_gradient_variables[con_id]["gradient"]
-            mapped_gradient_variable = self.constraint_gradient_variables[con_id]["mapped_gradient"]
-            self.mapper.InverseMap(gradient_variable, mapped_gradient_variable)
-
-        self.__computeControlPointUpdate()
-
-        self.mapper.Map(KSO.CONTROL_POINT_UPDATE, KSO.SHAPE_UPDATE)
-        self.model_part_controller.DampNodalUpdateVariableIfSpecified(KSO.SHAPE_UPDATE)
-
-    # --------------------------------------------------------------------------
-    def __computeControlPointUpdate(self):
-        """adapted from https://msulaiman.org/onewebmedia/GradProj_2.pdf"""
-        g_a, g_a_variables = self.__getActiveConstraints()
-
-        KM.Logger.PrintInfo("ShapeOpt", "Assemble vector of objective gradient.")
-        nabla_f = KM.Vector()
-        s = KM.Vector()
-        self.optimization_utilities.AssembleVector(self.design_surface, nabla_f, KSO.DF1DX_MAPPED)
-
-        if len(g_a) == 0:
-            KM.Logger.PrintInfo("ShapeOpt", "No constraints active, use negative objective gradient as search direction.")
-            s = nabla_f * (-1.0)
-            s *= self.step_size / s.norm_inf()
-            self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.SEARCH_DIRECTION)
-            self.optimization_utilities.AssignVectorToVariable(self.design_surface, [0.0]*len(s), KSO.CORRECTION)
-            self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.CONTROL_POINT_UPDATE)
-            return
-
-
-        KM.Logger.PrintInfo("ShapeOpt", "Assemble matrix of constraint gradient.")
-        N = KM.Matrix()
-        self.optimization_utilities.AssembleMatrix(self.design_surface, N, g_a_variables)
-
-        settings = KM.Parameters('{ "solver_type" : "LinearSolversApplication.dense_col_piv_householder_qr" }')
-        solver = dense_linear_solver_factory.ConstructSolver(settings)
-
-        KM.Logger.PrintInfo("ShapeOpt", "Calculate projected search direction and correction.")
-        c = KM.Vector()
-        self.optimization_utilities.CalculateProjectedSearchDirectionAndCorrection(
-            nabla_f,
-            N,
-            g_a,
-            solver,
-            s,
-            c)
-
-        if c.norm_inf() != 0.0:
-            if c.norm_inf() <= self.max_correction_share * self.step_size:
-                delta = self.step_size - c.norm_inf()
-                s *= delta/s.norm_inf()
-            else:
-                KM.Logger.PrintWarning("ShapeOpt", f"Correction is scaled down from {c.norm_inf()} to {self.max_correction_share * self.step_size}.")
-                c *= self.max_correction_share * self.step_size / c.norm_inf()
-                s *= (1.0 - self.max_correction_share) * self.step_size / s.norm_inf()
-        else:
-            s *= self.step_size / s.norm_inf()
-
-        self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.SEARCH_DIRECTION)
-        self.optimization_utilities.AssignVectorToVariable(self.design_surface, c, KSO.CORRECTION)
-        self.optimization_utilities.AssignVectorToVariable(self.design_surface, s+c, KSO.CONTROL_POINT_UPDATE)
-
-    # --------------------------------------------------------------------------
-    def __getActiveConstraints(self):
-        active_constraint_values = []
-        active_constraint_variables = []
-
-        for constraint in self.constraints.values():
-            if self.__isConstraintActive(constraint):
-                identifier = constraint["identifier"].GetString()
-                constraint_value = self.communicator.getStandardizedValue(identifier)
-                active_constraint_values.append(constraint_value)
-                active_constraint_variables.append(
-                    self.constraint_gradient_variables[identifier]["mapped_gradient"])
-
-        return active_constraint_values, active_constraint_variables
-
-    # --------------------------------------------------------------------------
-    def __isConstraintActive(self, constraint):
-        identifier = constraint["identifier"].GetString()
-        constraint_value = self.communicator.getStandardizedValue(identifier)
-        if constraint["type"].GetString() == "=" or constraint_value >= 0:
-            gradient_norm = self.optimization_utilities.ComputeMaxNormOfNodalVariable(
-                self.design_surface, self.constraint_gradient_variables[identifier]["mapped_gradient"]
-            )
-            if math.isclose(gradient_norm, 0.0, abs_tol=1e-16):
-                KM.Logger.PrintWarning("ShapeOpt", f"Gradient for constraint {identifier} is 0.0 - will not be considered!")
-                return False
-            return True
-        else:
-            return False
-
-    # --------------------------------------------------------------------------
-    def __logCurrentOptimizationStep(self):
-        additional_values_to_log = {}
-        additional_values_to_log["step_size"] = self.step_size
-        additional_values_to_log["inf_norm_s"] = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.SEARCH_DIRECTION)
-        additional_values_to_log["inf_norm_c"] = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.CORRECTION)
-        self.data_logger.LogSensitivityHeatmap(self.optimization_iteration, self.mapper)
-        self.data_logger.LogCurrentValues(self.optimization_iteration, additional_values_to_log)
-        self.data_logger.LogCurrentDesign(self.optimization_iteration)
-
-    # --------------------------------------------------------------------------
-    def __isAlgorithmConverged(self):
-
-        if self.optimization_iteration > 1 :
-
-            # Check if maximum iterations were reached
-            if self.optimization_iteration == self.max_iterations:
-                KM.Logger.Print("")
-                KM.Logger.PrintInfo("ShapeOpt", "Maximal iterations of optimization problem reached!")
-                return True
-
-            # Check for relative tolerance
-            relative_change_of_objective_value = self.data_logger.GetValues("rel_change_objective")[self.optimization_iteration]
-            if abs(relative_change_of_objective_value) < self.relative_tolerance:
-                KM.Logger.Print("")
-                KM.Logger.PrintInfo("ShapeOpt", "Optimization problem converged within a relative objective tolerance of ",self.relative_tolerance,"%.")
-                return True
-
-    # --------------------------------------------------------------------------
-    def __determineAbsoluteChanges(self):
-        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.CONTROL_POINT_UPDATE, KSO.CONTROL_POINT_CHANGE)
-        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.SHAPE_UPDATE, KSO.SHAPE_CHANGE)
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#                   Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+
+# Kratos Core and Apps
+import KratosMultiphysics as KM
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+from KratosMultiphysics.LinearSolversApplication import dense_linear_solver_factory
+
+# Additional imports
+from KratosMultiphysics.ShapeOptimizationApplication.algorithms.algorithm_base import OptimizationAlgorithm
+from KratosMultiphysics.ShapeOptimizationApplication import mapper_factory
+from KratosMultiphysics.ShapeOptimizationApplication.loggers import data_logger_factory
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_variable_utilities import WriteDictionaryDataOnNodalVariable
+
+import math
+
+# ==============================================================================
+class AlgorithmGradientProjection(OptimizationAlgorithm):
+    # --------------------------------------------------------------------------
+    def __init__(self, optimization_settings, analyzer, communicator, model_part_controller):
+        default_algorithm_settings = KM.Parameters("""
+        {
+            "name"                    : "penalized_projection",
+            "max_correction_share"    : 0.75,
+            "max_iterations"          : 100,
+            "relative_tolerance"      : 1e-3,
+            "line_search" : {
+                "line_search_type"           : "manual_stepping",
+                "normalize_search_direction" : true,
+                "step_size"                  : 1.0
+            }
+        }""")
+        self.algorithm_settings =  optimization_settings["optimization_algorithm"]
+        self.algorithm_settings.RecursivelyValidateAndAssignDefaults(default_algorithm_settings)
+
+        self.optimization_settings = optimization_settings
+        self.mapper_settings = optimization_settings["design_variables"]["filter"]
+
+        self.analyzer = analyzer
+        self.communicator = communicator
+        self.model_part_controller = model_part_controller
+
+        self.design_surface = None
+        self.mapper = None
+        self.data_logger = None
+        self.optimization_utilities = None
+
+        self.objectives = optimization_settings["objectives"]
+        self.constraints = optimization_settings["constraints"]
+        self.constraint_gradient_variables = {}
+        for itr, constraint in enumerate(self.constraints.values()):
+            self.constraint_gradient_variables.update({
+                constraint["identifier"].GetString() : {
+                    "gradient": KM.KratosGlobals.GetVariable(f"DC{(itr+1)}DX"),
+                    "mapped_gradient": KM.KratosGlobals.GetVariable(f"DC{(itr+1)}DX_MAPPED")
+                }
+            })
+        self.max_correction_share = self.algorithm_settings["max_correction_share"].GetDouble()
+
+        self.step_size = self.algorithm_settings["line_search"]["step_size"].GetDouble()
+        self.max_iterations = self.algorithm_settings["max_iterations"].GetInt() + 1
+        self.relative_tolerance = self.algorithm_settings["relative_tolerance"].GetDouble()
+
+        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.SEARCH_DIRECTION)
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.CORRECTION)
+
+    # --------------------------------------------------------------------------
+    def CheckApplicability(self):
+        if self.objectives.size() > 1:
+            raise RuntimeError("Gradient projection algorithm only supports one objective function!")
+        if self.constraints.size() == 0:
+            raise RuntimeError("Gradient projection algorithm requires definition of at least one constraint!")
+
+    # --------------------------------------------------------------------------
+    def InitializeOptimizationLoop(self):
+        self.model_part_controller.Initialize()
+
+        self.analyzer.InitializeBeforeOptimizationLoop()
+
+        self.design_surface = self.model_part_controller.GetDesignSurface()
+
+        self.mapper = mapper_factory.CreateMapper(self.design_surface, self.design_surface, self.mapper_settings)
+        self.mapper.Initialize()
+        self.model_part_controller.InitializeDamping()
+
+        self.data_logger = data_logger_factory.CreateDataLogger(self.model_part_controller, self.communicator, self.optimization_settings)
+        self.data_logger.InitializeDataLogging()
+
+        self.optimization_utilities = KSO.OptimizationUtilities
+
+    # --------------------------------------------------------------------------
+    def RunOptimizationLoop(self):
+        timer = Timer()
+        timer.StartTimer()
+
+        for self.optimization_iteration in range(1,self.max_iterations):
+            KM.Logger.Print("")
+            KM.Logger.Print("===============================================================================")
+            KM.Logger.PrintInfo("ShapeOpt", timer.GetTimeStamp(), ": Starting optimization iteration ", self.optimization_iteration)
+            KM.Logger.Print("===============================================================================\n")
+
+            timer.StartNewLap()
+
+            self.__initializeNewShape()
+
+            self.__analyzeShape()
+
+            self.__computeShapeUpdate()
+
+            self.__logCurrentOptimizationStep()
+
+            KM.Logger.Print("")
+            KM.Logger.PrintInfo("ShapeOpt", "Time needed for current optimization step = ", timer.GetLapTime(), "s")
+            KM.Logger.PrintInfo("ShapeOpt", "Time needed for total optimization so far = ", timer.GetTotalTime(), "s")
+
+            if self.__isAlgorithmConverged():
+                break
+            else:
+                self.__determineAbsoluteChanges()
+
+    # --------------------------------------------------------------------------
+    def FinalizeOptimizationLoop(self):
+        self.data_logger.FinalizeDataLogging()
+        self.analyzer.FinalizeAfterOptimizationLoop()
+
+    # --------------------------------------------------------------------------
+    def __initializeNewShape(self):
+        self.model_part_controller.UpdateTimeStep(self.optimization_iteration)
+        self.model_part_controller.UpdateMeshAccordingInputVariable(KSO.SHAPE_UPDATE)
+        self.model_part_controller.SetReferenceMeshToMesh()
+
+    # --------------------------------------------------------------------------
+    def __analyzeShape(self):
+        self.communicator.initializeCommunication()
+        self.communicator.requestValueOf(self.objectives[0]["identifier"].GetString())
+        self.communicator.requestGradientOf(self.objectives[0]["identifier"].GetString())
+
+        for constraint in self.constraints.values():
+            con_id =  constraint["identifier"].GetString()
+            self.communicator.requestValueOf(con_id)
+            self.communicator.requestGradientOf(con_id)
+
+        self.analyzer.AnalyzeDesignAndReportToCommunicator(self.optimization_model_part, self.optimization_iteration, self.communicator)
+
+        # compute normals only if required
+        surface_normals_required = self.objectives[0]["project_gradient_on_surface_normals"].GetBool()
+        for constraint in self.constraints.values():
+            if constraint["project_gradient_on_surface_normals"].GetBool():
+                surface_normals_required = True
+
+        if surface_normals_required:
+            self.model_part_controller.ComputeUnitSurfaceNormals()
+
+        # project and damp objective gradients
+        objGradientDict = self.communicator.getStandardizedGradient(self.objectives[0]["identifier"].GetString())
+        WriteDictionaryDataOnNodalVariable(objGradientDict, self.optimization_model_part, KSO.DF1DX)
+
+        if self.objectives[0]["project_gradient_on_surface_normals"].GetBool():
+            self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(KSO.DF1DX)
+
+        self.model_part_controller.DampNodalSensitivityVariableIfSpecified(KSO.DF1DX)
+
+        # project and damp constraint gradients
+        for constraint in self.constraints.values():
+            con_id = constraint["identifier"].GetString()
+            conGradientDict = self.communicator.getStandardizedGradient(con_id)
+            gradient_variable = self.constraint_gradient_variables[con_id]["gradient"]
+            WriteDictionaryDataOnNodalVariable(conGradientDict, self.optimization_model_part, gradient_variable)
+
+            if constraint["project_gradient_on_surface_normals"].GetBool():
+                self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(gradient_variable)
+
+            self.model_part_controller.DampNodalSensitivityVariableIfSpecified(gradient_variable)
+
+    # --------------------------------------------------------------------------
+    def __computeShapeUpdate(self):
+        self.mapper.Update()
+        self.mapper.InverseMap(KSO.DF1DX, KSO.DF1DX_MAPPED)
+
+        for constraint in self.constraints.values():
+            con_id = constraint["identifier"].GetString()
+            gradient_variable = self.constraint_gradient_variables[con_id]["gradient"]
+            mapped_gradient_variable = self.constraint_gradient_variables[con_id]["mapped_gradient"]
+            self.mapper.InverseMap(gradient_variable, mapped_gradient_variable)
+
+        self.__computeControlPointUpdate()
+
+        self.mapper.Map(KSO.CONTROL_POINT_UPDATE, KSO.SHAPE_UPDATE)
+        self.model_part_controller.DampNodalUpdateVariableIfSpecified(KSO.SHAPE_UPDATE)
+
+    # --------------------------------------------------------------------------
+    def __computeControlPointUpdate(self):
+        """adapted from https://msulaiman.org/onewebmedia/GradProj_2.pdf"""
+        g_a, g_a_variables = self.__getActiveConstraints()
+
+        KM.Logger.PrintInfo("ShapeOpt", "Assemble vector of objective gradient.")
+        nabla_f = KM.Vector()
+        s = KM.Vector()
+        self.optimization_utilities.AssembleVector(self.design_surface, nabla_f, KSO.DF1DX_MAPPED)
+
+        if len(g_a) == 0:
+            KM.Logger.PrintInfo("ShapeOpt", "No constraints active, use negative objective gradient as search direction.")
+            s = nabla_f * (-1.0)
+            s *= self.step_size / s.norm_inf()
+            self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.SEARCH_DIRECTION)
+            self.optimization_utilities.AssignVectorToVariable(self.design_surface, [0.0]*len(s), KSO.CORRECTION)
+            self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.CONTROL_POINT_UPDATE)
+            return
+
+
+        KM.Logger.PrintInfo("ShapeOpt", "Assemble matrix of constraint gradient.")
+        N = KM.Matrix()
+        self.optimization_utilities.AssembleMatrix(self.design_surface, N, g_a_variables)
+
+        settings = KM.Parameters('{ "solver_type" : "LinearSolversApplication.dense_col_piv_householder_qr" }')
+        solver = dense_linear_solver_factory.ConstructSolver(settings)
+
+        KM.Logger.PrintInfo("ShapeOpt", "Calculate projected search direction and correction.")
+        c = KM.Vector()
+        self.optimization_utilities.CalculateProjectedSearchDirectionAndCorrection(
+            nabla_f,
+            N,
+            g_a,
+            solver,
+            s,
+            c)
+
+        if c.norm_inf() != 0.0:
+            if c.norm_inf() <= self.max_correction_share * self.step_size:
+                delta = self.step_size - c.norm_inf()
+                s *= delta/s.norm_inf()
+            else:
+                KM.Logger.PrintWarning("ShapeOpt", f"Correction is scaled down from {c.norm_inf()} to {self.max_correction_share * self.step_size}.")
+                c *= self.max_correction_share * self.step_size / c.norm_inf()
+                s *= (1.0 - self.max_correction_share) * self.step_size / s.norm_inf()
+        else:
+            s *= self.step_size / s.norm_inf()
+
+        self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.SEARCH_DIRECTION)
+        self.optimization_utilities.AssignVectorToVariable(self.design_surface, c, KSO.CORRECTION)
+        self.optimization_utilities.AssignVectorToVariable(self.design_surface, s+c, KSO.CONTROL_POINT_UPDATE)
+
+    # --------------------------------------------------------------------------
+    def __getActiveConstraints(self):
+        active_constraint_values = []
+        active_constraint_variables = []
+
+        for constraint in self.constraints.values():
+            if self.__isConstraintActive(constraint):
+                identifier = constraint["identifier"].GetString()
+                constraint_value = self.communicator.getStandardizedValue(identifier)
+                active_constraint_values.append(constraint_value)
+                active_constraint_variables.append(
+                    self.constraint_gradient_variables[identifier]["mapped_gradient"])
+
+        return active_constraint_values, active_constraint_variables
+
+    # --------------------------------------------------------------------------
+    def __isConstraintActive(self, constraint):
+        identifier = constraint["identifier"].GetString()
+        constraint_value = self.communicator.getStandardizedValue(identifier)
+        if constraint["type"].GetString() == "=" or constraint_value >= 0:
+            gradient_norm = self.optimization_utilities.ComputeMaxNormOfNodalVariable(
+                self.design_surface, self.constraint_gradient_variables[identifier]["mapped_gradient"]
+            )
+            if math.isclose(gradient_norm, 0.0, abs_tol=1e-16):
+                KM.Logger.PrintWarning("ShapeOpt", f"Gradient for constraint {identifier} is 0.0 - will not be considered!")
+                return False
+            return True
+        else:
+            return False
+
+    # --------------------------------------------------------------------------
+    def __logCurrentOptimizationStep(self):
+        additional_values_to_log = {}
+        additional_values_to_log["step_size"] = self.step_size
+        additional_values_to_log["inf_norm_s"] = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.SEARCH_DIRECTION)
+        additional_values_to_log["inf_norm_c"] = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.CORRECTION)
+        self.data_logger.LogSensitivityHeatmap(self.optimization_iteration, self.mapper)
+        self.data_logger.LogCurrentValues(self.optimization_iteration, additional_values_to_log)
+        self.data_logger.LogCurrentDesign(self.optimization_iteration)
+
+    # --------------------------------------------------------------------------
+    def __isAlgorithmConverged(self):
+
+        if self.optimization_iteration > 1 :
+
+            # Check if maximum iterations were reached
+            if self.optimization_iteration == self.max_iterations:
+                KM.Logger.Print("")
+                KM.Logger.PrintInfo("ShapeOpt", "Maximal iterations of optimization problem reached!")
+                return True
+
+            # Check for relative tolerance
+            relative_change_of_objective_value = self.data_logger.GetValues("rel_change_objective")[self.optimization_iteration]
+            if abs(relative_change_of_objective_value) < self.relative_tolerance:
+                KM.Logger.Print("")
+                KM.Logger.PrintInfo("ShapeOpt", "Optimization problem converged within a relative objective tolerance of ",self.relative_tolerance,"%.")
+                return True
+
+    # --------------------------------------------------------------------------
+    def __determineAbsoluteChanges(self):
+        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.CONTROL_POINT_UPDATE, KSO.CONTROL_POINT_CHANGE)
+        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.SHAPE_UPDATE, KSO.SHAPE_CHANGE)
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_trust_region.py

 * *Ordering differences only*

```diff
@@ -1,657 +1,657 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#
-# ==============================================================================
-
-
-# Kratos Core and Apps
-import KratosMultiphysics as KM
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-
-# Additional imports
-from KratosMultiphysics.ShapeOptimizationApplication.algorithms.algorithm_base import OptimizationAlgorithm
-from KratosMultiphysics.ShapeOptimizationApplication import mapper_factory
-from KratosMultiphysics.ShapeOptimizationApplication.loggers import data_logger_factory
-from KratosMultiphysics.ShapeOptimizationApplication.utilities import custom_math as cm
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_variable_utilities import WriteDictionaryDataOnNodalVariable, ReadNodalVariableToList, WriteListToNodalVariable
-import copy
-
-# ==============================================================================
-class AlgorithmTrustRegion(OptimizationAlgorithm):
-    # --------------------------------------------------------------------------
-    def __init__(self, optimization_settings, analyzer, communicator, model_part_controller):
-        default_algorithm_settings = KM.Parameters("""
-        {
-            "name"                          : "trust_region",
-            "max_step_length"               : 1.0,
-            "step_length_tolerance"         : 1e-3,
-            "step_length_reduction_factor"  : 0.5,
-            "max_iterations"                : 10,
-            "far_away_length"               : 2.0,
-            "subopt_max_itr"                : 50,
-            "subopt_tolerance"              : 1e-10,
-            "bisectioning_max_itr"          : 30,
-            "bisectioning_tolerance"        : 1e-2,
-            "relative_tolerance"            : 1e-12,
-            "obj_share_during_correction"   : 1
-        }""")
-        self.algorithm_settings =  optimization_settings["optimization_algorithm"]
-        self.algorithm_settings.RecursivelyValidateAndAssignDefaults(default_algorithm_settings)
-
-        self.optimization_settings = optimization_settings
-        self.mapper_settings = optimization_settings["design_variables"]["filter"]
-
-        self.analyzer = analyzer
-        self.communicator = communicator
-        self.model_part_controller = model_part_controller
-
-        self.design_surface = None
-        self.mapper = None
-        self.data_logger = None
-        self.optimization_utilities = None
-
-        self.objectives = optimization_settings["objectives"]
-        self.constraints = optimization_settings["constraints"]
-
-        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
-
-    # --------------------------------------------------------------------------
-    def CheckApplicability(self):
-        if self.objectives.size() > 1:
-            raise RuntimeError("Trust-region algorithm only supports one objective function!")
-
-    # --------------------------------------------------------------------------
-    def InitializeOptimizationLoop(self):
-        self.model_part_controller.Initialize()
-
-        self.analyzer.InitializeBeforeOptimizationLoop()
-
-        self.design_surface = self.model_part_controller.GetDesignSurface()
-
-        self.mapper = mapper_factory.CreateMapper(self.design_surface, self.design_surface, self.mapper_settings)
-        self.mapper.Initialize()
-        self.model_part_controller.InitializeDamping()
-
-        self.data_logger = data_logger_factory.CreateDataLogger(self.model_part_controller, self.communicator, self.optimization_settings)
-        self.data_logger.InitializeDataLogging()
-
-        self.optimization_utilities = KSO.OptimizationUtilities
-
-    # --------------------------------------------------------------------------
-    def RunOptimizationLoop(self):
-        timer = Timer()
-        timer.StartTimer()
-
-        for self.opt_iteration in range(1,self.algorithm_settings["max_iterations"].GetInt()+1):
-            KM.Logger.Print("")
-            KM.Logger.Print("===============================================================================")
-            KM.Logger.PrintInfo("ShapeOpt", timer.GetTimeStamp(), ": Starting optimization iteration ",self.opt_iteration)
-            KM.Logger.Print("===============================================================================\n")
-
-            timer.StartNewLap()
-
-            self.__InitializeNewShape()
-
-            self.__AnalyzeShape()
-
-            self.__PostProcessGradientsObtainedFromAnalysis()
-
-            len_obj, dir_obj, len_eqs, dir_eqs, len_ineqs, dir_ineqs =  self.__ConvertAnalysisResultsToLengthDirectionFormat()
-
-            step_length = self.__DetermineMaxStepLength()
-
-            len_bar_obj, len_bar_eqs, len_bar_ineqs = self.__ExpressInStepLengthUnit(len_obj, len_eqs, len_ineqs, step_length)
-
-            dX_bar, process_details = self.__DetermineStep(len_bar_obj, dir_obj, len_bar_eqs, dir_eqs, len_bar_ineqs, dir_ineqs)
-
-            dX = self.__ComputeShapeUpdate(dX_bar, step_length)
-
-            values_to_be_logged = {}
-            values_to_be_logged["len_bar_obj"] = len_bar_obj
-            values_to_be_logged["len_bar_cons"] = self.__CombineConstraintDataToOrderedList(len_bar_eqs, len_bar_ineqs)
-            values_to_be_logged["step_length"] = step_length
-            values_to_be_logged["test_norm_dX_bar"] = process_details["test_norm_dX"]
-            values_to_be_logged["bi_itrs"] = process_details["bi_itrs"]
-            values_to_be_logged["bi_err"] = process_details["bi_err"]
-            values_to_be_logged["adj_len_bar_obj"] = process_details["adj_len_obj"]
-            values_to_be_logged["adj_len_bar_cons"] = self.__CombineConstraintDataToOrderedList(process_details["adj_len_eqs"], process_details["adj_len_ineqs"])
-            values_to_be_logged["norm_dX"] = cm.NormInf3D(dX)
-
-            self.__LogCurrentOptimizationStep(values_to_be_logged)
-
-            KM.Logger.Print("")
-            KM.Logger.PrintInfo("ShapeOpt", "Time needed for current optimization step = ", timer.GetLapTime(), "s")
-            KM.Logger.PrintInfo("ShapeOpt", "Time needed for total optimization so far = ", timer.GetTotalTime(), "s")
-
-            if self.__isAlgorithmConverged():
-                break
-
-    # --------------------------------------------------------------------------
-    def FinalizeOptimizationLoop(self):
-        self.analyzer.FinalizeAfterOptimizationLoop()
-        self.data_logger.FinalizeDataLogging()
-
-    # --------------------------------------------------------------------------
-    def __isAlgorithmConverged(self):
-
-        if self.opt_iteration > 1 :
-            # Check if maximum iterations were reached
-            if self.opt_iteration == self.algorithm_settings["max_iterations"].GetInt():
-                KM.Logger.Print("")
-                KM.Logger.PrintInfo("ShapeOpt", "Maximal iterations of optimization problem reached!")
-                return True
-
-            # Check for relative tolerance
-            relative_change_of_objective_value = self.data_logger.GetValues("rel_change_objective")[self.opt_iteration]
-            if abs(relative_change_of_objective_value) < self.algorithm_settings["relative_tolerance"].GetDouble():
-                KM.Logger.Print("")
-                KM.Logger.PrintInfo("ShapeOpt", "Optimization problem converged within a relative objective tolerance of ",self.algorithm_settings["relative_tolerance"].GetDouble(),"%.")
-                return True
-
-    # --------------------------------------------------------------------------
-    def __InitializeNewShape(self):
-        self.model_part_controller.UpdateTimeStep(self.opt_iteration)
-        self.model_part_controller.UpdateMeshAccordingInputVariable(KSO.SHAPE_UPDATE)
-        self.model_part_controller.SetReferenceMeshToMesh()
-
-    # --------------------------------------------------------------------------
-    def __AnalyzeShape(self):
-            self.communicator.initializeCommunication()
-
-            obj_id = self.objectives[0]["identifier"].GetString()
-            self.communicator.requestValueOf(obj_id)
-            self.communicator.requestGradientOf(obj_id)
-
-            for itr in range(self.constraints.size()):
-                con_id =  self.constraints[itr]["identifier"].GetString()
-                self.communicator.requestValueOf(con_id)
-                self.communicator.requestGradientOf(con_id)
-
-            self.analyzer.AnalyzeDesignAndReportToCommunicator(self.optimization_model_part, self.opt_iteration, self.communicator)
-
-    # --------------------------------------------------------------------------
-    def __PostProcessGradientsObtainedFromAnalysis(self):
-        # Compute surface normals if required
-        if self.objectives[0]["project_gradient_on_surface_normals"].GetBool():
-            self.model_part_controller.ComputeUnitSurfaceNormals()
-        else:
-            for itr in range(self.constraints.size()):
-                if self.constraints[itr]["project_gradient_on_surface_normals"].GetBool():
-                    self.model_part_controller.ComputeUnitSurfaceNormals()
-
-        # Process objective gradients
-        obj = self.objectives[0]
-        obj_id = obj["identifier"].GetString()
-
-        obj_gradients_dict = self.communicator.getStandardizedGradient(obj_id)
-
-        nodal_variable = KM.KratosGlobals.GetVariable("DF1DX")
-        WriteDictionaryDataOnNodalVariable(obj_gradients_dict, self.optimization_model_part, nodal_variable)
-
-        # Projection on surface normals
-        if obj["project_gradient_on_surface_normals"].GetBool():
-            self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(nodal_variable)
-
-        # Damping
-        self.model_part_controller.DampNodalSensitivityVariableIfSpecified(nodal_variable)
-
-        # Mapping
-        nodal_variable_mapped = KM.KratosGlobals.GetVariable("DF1DX_MAPPED")
-        self.mapper.Update()
-        self.mapper.InverseMap(nodal_variable, nodal_variable_mapped)
-        self.mapper.Map(nodal_variable_mapped, nodal_variable_mapped)
-
-        # Damping
-        self.model_part_controller.DampNodalUpdateVariableIfSpecified(nodal_variable_mapped)
-
-        # Process constraint gradients
-        for itr in range(self.constraints.size()):
-            con = self.constraints[itr]
-            con_id = con["identifier"].GetString()
-
-            eq_gradients_dict = self.communicator.getStandardizedGradient(con_id)
-
-            nodal_variable = KM.KratosGlobals.GetVariable("DC"+str(itr+1)+"DX")
-            WriteDictionaryDataOnNodalVariable(eq_gradients_dict, self.optimization_model_part, nodal_variable)
-
-            # Projection on surface normals
-            if con["project_gradient_on_surface_normals"].GetBool():
-                self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(nodal_variable)
-
-            # Damping
-            self.model_part_controller.DampNodalSensitivityVariableIfSpecified(nodal_variable)
-
-            # Mapping
-            nodal_variable_mapped = KM.KratosGlobals.GetVariable(f"DC{(itr+1)}DX_MAPPED")
-            self.mapper.InverseMap(nodal_variable, nodal_variable_mapped)
-            self.mapper.Map(nodal_variable_mapped, nodal_variable_mapped)
-
-            # Damping
-            self.model_part_controller.DampNodalUpdateVariableIfSpecified(nodal_variable_mapped)
-
-    # --------------------------------------------------------------------------
-    def __ConvertAnalysisResultsToLengthDirectionFormat(self):
-        # Convert objective results
-        obj = self.objectives[0]
-        obj_id = obj["identifier"].GetString()
-
-        nodal_variable = KM.KratosGlobals.GetVariable("DF1DX")
-        nodal_variable_mapped = KM.KratosGlobals.GetVariable("DF1DX_MAPPED")
-
-        obj_value = self.communicator.getStandardizedValue(obj_id)
-        obj_gradient = ReadNodalVariableToList(self.design_surface, nodal_variable)
-        obj_gradient_mapped = ReadNodalVariableToList(self.design_surface, nodal_variable_mapped)
-
-        dir_obj, len_obj = self.__ConvertToLengthDirectionFormat(obj_value, obj_gradient, obj_gradient_mapped)
-        dir_obj = dir_obj
-
-        # Convert constraints
-        len_eqs = []
-        dir_eqs = []
-        len_ineqs = []
-        dir_ineqs = []
-
-        for itr in range(self.constraints.size()):
-            con = self.constraints[itr]
-            con_id = con["identifier"].GetString()
-
-            nodal_variable = KM.KratosGlobals.GetVariable(f"DC{(itr+1)}DX")
-            nodal_variable_mapped = KM.KratosGlobals.GetVariable(f"DC{(itr+1)}DX_MAPPED")
-
-            value = self.communicator.getStandardizedValue(con_id)
-            gradient = ReadNodalVariableToList(self.design_surface, nodal_variable)
-            gradient_mapped = ReadNodalVariableToList(self.design_surface, nodal_variable_mapped)
-
-            direction, length = self.__ConvertToLengthDirectionFormat(value, gradient, gradient_mapped)
-
-            if con["type"].GetString()=="=":
-                dir_eqs.append(direction)
-                len_eqs.append(length)
-            else:
-                dir_ineqs.append(direction)
-                len_ineqs.append(length)
-
-        return len_obj, dir_obj, len_eqs, dir_eqs, len_ineqs, dir_ineqs
-
-    # --------------------------------------------------------------------------
-    @staticmethod
-    def __ConvertToLengthDirectionFormat(value, gradient, modified_gradient):
-        norm_inf = cm.NormInf3D(modified_gradient)
-        if norm_inf > 1e-12:
-            direction = cm.ScalarVectorProduct(-1/norm_inf,modified_gradient)
-            length = -value/cm.Dot(gradient, direction)
-        else:
-            KM.Logger.PrintWarning("ShapeOpt::AlgorithmTrustRegion", "Vanishing norm-infinity for gradient detected!")
-            direction = modified_gradient
-            length = 0.0
-
-        return direction, length
-
-    # --------------------------------------------------------------------------
-    def __DetermineMaxStepLength(self):
-        if self.opt_iteration < 4:
-            return self.algorithm_settings["max_step_length"].GetDouble()
-        else:
-            obj_id = self.objectives[0]["identifier"].GetString()
-            current_obj_val = self.communicator.getStandardizedValue(obj_id)
-            obj_history = self.data_logger.GetValues("response_value")[obj_id]
-            step_history = self.data_logger.GetValues("step_length")
-
-            # Check for osciallation
-            objective_is_oscillating = False
-            is_decrease_1 = (current_obj_val - obj_history[self.opt_iteration-1])< 0
-            is_decrease_2 = (obj_history[self.opt_iteration-1] - obj_history[self.opt_iteration-2])<0
-            is_decrease_3 = (current_obj_val - obj_history[self.opt_iteration-3])< 0
-            if (is_decrease_1 and is_decrease_2== False and is_decrease_3) or (is_decrease_1== False and is_decrease_2 and is_decrease_3==False):
-                objective_is_oscillating = True
-
-            # Reduce step length if certain conditions are fullfilled
-            if objective_is_oscillating:
-                return step_history[self.opt_iteration-1]*self.algorithm_settings["step_length_reduction_factor"].GetDouble()
-            else:
-                return step_history[self.opt_iteration-1]
-
-    # --------------------------------------------------------------------------
-    @staticmethod
-    def __ExpressInStepLengthUnit(len_obj, len_eqs, len_ineqs, step_length):
-        len_bar_obj = 1/step_length * len_obj
-        len_bar_eqs = cm.ScalarVectorProduct(1/step_length, len_eqs)
-        len_bar_ineqs = cm.ScalarVectorProduct(1/step_length, len_ineqs)
-        return len_bar_obj, len_bar_eqs, len_bar_ineqs
-
-    # --------------------------------------------------------------------------
-    def __DetermineStep(self, len_obj, dir_obj, len_eqs, dir_eqs, len_ineqs, dir_ineqs):
-        KM.Logger.Print("")
-        KM.Logger.PrintInfo("ShapeOpt", "Starting determination of step...")
-
-        timer = Timer()
-        timer.StartTimer()
-
-        # Create projector object wich can do the projection in the orthogonalized subspace
-        projector = Projector(len_obj, dir_obj, len_eqs, dir_eqs, len_ineqs, dir_ineqs, self.algorithm_settings)
-
-        # 1. Test projection if there is room for objective improvement
-        # I.e., the actual step length to become feasible for an inactive threshold is smaller than 1 and hence a part of the step can be dedicated to objective improvement
-        len_obj_test = 0.01
-        inactive_threshold = 100
-        test_norm_dX, is_projection_sucessfull = projector.RunProjection(len_obj_test, inactive_threshold)
-
-        KM.Logger.PrintInfo("ShapeOpt", "Time needed for one projection step = ", timer.GetTotalTime(), "s")
-
-        # 2. Determine step following two different modes depending on the previos found step length to the feasible domain
-        if is_projection_sucessfull:
-            if test_norm_dX < 1: # Minimizing mode
-                KM.Logger.Print("")
-                KM.Logger.PrintInfo("ShapeOpt", "Computing projection case 1...")
-
-                func = lambda len_obj: projector.RunProjection(len_obj, inactive_threshold)
-
-                len_obj_min = len_obj_test
-                len_obj_max = 1.3
-                bi_target = 1
-                bi_tolerance = self.algorithm_settings["bisectioning_tolerance"].GetDouble()
-                bi_max_itr = self.algorithm_settings["bisectioning_max_itr"].GetInt()
-                len_obj_result, bi_itrs, bi_err = cm.PerformBisectioning(func, len_obj_min, len_obj_max, bi_target, bi_tolerance, bi_max_itr)
-
-                projection_results = projector.GetDetailedResultsOfLatestProjection()
-
-            else: # Correction mode
-                KM.Logger.Print("")
-                KM.Logger.PrintInfo("ShapeOpt", "Computing projection case 2...")
-
-                len_obj = self.algorithm_settings["obj_share_during_correction"].GetDouble()
-                func = lambda threshold: projector.RunProjection(len_obj, threshold)
-
-                threshold_min = 0
-                threshold_max = 1.3
-                bi_target = 1
-                bi_tolerance = self.algorithm_settings["bisectioning_tolerance"].GetDouble()
-                bi_max_itr = self.algorithm_settings["bisectioning_max_itr"].GetInt()
-                l_threshold_result, bi_itrs, bi_err = cm.PerformBisectioning(func, threshold_min, threshold_max, bi_target, bi_tolerance, bi_max_itr)
-
-                projection_results = projector.GetDetailedResultsOfLatestProjection()
-        else:
-            raise RuntimeError("Case of not converged test projection not yet implemented yet!")
-
-        KM.Logger.Print("")
-        KM.Logger.PrintInfo("ShapeOpt", "Time needed for determining step = ", timer.GetTotalTime(), "s")
-
-        process_details = { "test_norm_dX": test_norm_dX,
-                            "bi_itrs":bi_itrs,
-                            "bi_err":bi_err,
-                            "adj_len_obj": projection_results["adj_len_obj"],
-                            "adj_len_eqs": projection_results["adj_len_eqs"],
-                            "adj_len_ineqs": projection_results["adj_len_ineqs"] }
-
-        return projection_results["dX"], process_details
-
-    # --------------------------------------------------------------------------
-    def __ComputeShapeUpdate(self, dX_bar, step_length):
-        # Compute update in regular units
-        dX = cm.ScalarVectorProduct(step_length,dX_bar)
-
-        WriteListToNodalVariable(dX, self.design_surface, KSO.SHAPE_UPDATE)
-        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.SHAPE_UPDATE, KSO.SHAPE_CHANGE)
-
-        return dX
-
-    # --------------------------------------------------------------------------
-    def __LogCurrentOptimizationStep(self, additional_values_to_log):
-        self.data_logger.LogSensitivityHeatmap(self.opt_iteration, self.mapper)
-        self.data_logger.LogCurrentValues(self.opt_iteration, additional_values_to_log)
-        self.data_logger.LogCurrentDesign(self.opt_iteration)
-
-    # --------------------------------------------------------------------------
-    def __CombineConstraintDataToOrderedList(self, eqs_data_list, ineqs_data_list):
-        num_eqs = 0
-        num_ineqs = 0
-        combined_list = []
-
-        # Order is given by appearance of constraints in optimization settings
-        for itr in range(self.constraints.size()):
-            if self.constraints[itr]["type"].GetString()=="=":
-                combined_list.append(eqs_data_list[num_eqs])
-                num_eqs = num_eqs+1
-            else:
-                combined_list.append(ineqs_data_list[num_ineqs])
-                num_ineqs = num_ineqs+1
-
-        return combined_list
-
-# ==============================================================================
-class Projector():
-    # --------------------------------------------------------------------------
-    def __init__(self, len_obj, dir_obj, len_eqs, dir_eqs, len_ineqs, dir_ineqs, settings):
-
-        # Store settings
-        self.far_away_length = settings["far_away_length"].GetDouble()
-        self.subopt_max_itr = settings["subopt_max_itr"].GetInt()
-        self.subopt_tolerance = settings["subopt_tolerance"].GetDouble()
-
-        # Initialize projection results
-        self.are_projection_restuls_stored = False
-        self.projection_results = {}
-
-        # Reduce input data to relevant info
-        self.input_len_obj = len_obj
-        self.input_len_eqs = len_eqs
-        self.input_len_ineqs = len_ineqs
-
-        len_eqs, dir_eqs, remaining_eqs_entries = self.__ReduceToRelevantEqualityConstraints(len_eqs, dir_eqs)
-        len_ineqs, dir_ineqs, remaining_ineqs_entries = self.__ReduceToRelevantInequalityConstraints(len_ineqs, dir_ineqs)
-
-        # Store some working variables depening on data reduction
-        self.remaining_eqs_entries = remaining_eqs_entries
-        self.remaining_ineqs_entries = remaining_ineqs_entries
-        self.len_eqs = len_eqs
-        self.len_ineqs = len_ineqs
-        self.num_eqs = len(len_eqs)
-        self.num_ineqs = len(len_ineqs)
-        self.num_unknowns = 1 + self.num_eqs + self.num_ineqs
-
-        # Create orthogonal basis
-        vector_space = [dir_obj]
-        for itr in range(len(dir_eqs)):
-            vector_space = cm.HorzCat(vector_space, dir_eqs[itr])
-        for itr in range(len(dir_ineqs)):
-            vector_space = cm.HorzCat(vector_space, dir_ineqs[itr])
-        self.ortho_basis = cm.PerformGramSchmidtOrthogonalization(vector_space)
-
-        # Transform directions to orthogonal space since they don't change with different projections
-        self.dir_obj_o = cm.TranslateToNewBasis(dir_obj, self.ortho_basis)
-        self.dir_eqs_o = cm.TranslateToNewBasis(dir_eqs, self.ortho_basis)
-        self.dir_ineqs_o = cm.TranslateToNewBasis(dir_ineqs, self.ortho_basis)
-
-        # Make sure directions of constraints are stored as matrix
-        self.dir_eqs_o = cm.SafeConvertVectorToMatrix(self.dir_eqs_o)
-        self.dir_ineqs_o = cm.SafeConvertVectorToMatrix(self.dir_ineqs_o)
-
-    # --------------------------------------------------------------------------
-    def RunProjection(self, len_obj, threshold):
-
-        # Adjust halfspaces according input
-        adj_len_obj, adj_len_eqs, adj_len_ineqs = self.__AdjustHalfSpacesAndHyperplanes(len_obj, threshold)
-
-        # Determine position of border of halfspaces and hyperplanes
-        pos_obj_o, pos_eqs_o, pos_ineqs_o = self.__DetermineConstraintBorders(adj_len_obj, adj_len_eqs, adj_len_ineqs)
-
-        # Project current position onto intersection of
-        current_position = cm.ZeroVector(self.num_unknowns)
-        dlambda_hp = self.__ProjectToHyperplanes(current_position, self.dir_eqs_o, pos_eqs_o)
-
-        # Project position and direction of halfspaces onto intersection of hyperplanes
-        zero_position_eqs_o = cm.ZeroMatrix(self.num_unknowns,self.num_eqs)
-
-        pos_obj_hp = self.__ProjectToHyperplanes(pos_obj_o, cm.HorzCat(self.dir_eqs_o, self.dir_obj_o), cm.HorzCat(pos_eqs_o, pos_obj_o))
-        dir_obj_hp = self.__ProjectToHyperplanes(self.dir_obj_o, self.dir_eqs_o, zero_position_eqs_o)
-
-        pos_ineqs_hp = []
-        dir_ineqs_hp = []
-        for itr in range(self.num_ineqs):
-            pos_ineqs_hp_i = self.__ProjectToHyperplanes(pos_ineqs_o[itr], cm.HorzCat(self.dir_eqs_o, self.dir_ineqs_o[itr]), cm.HorzCat(pos_eqs_o, pos_ineqs_o[itr]))
-            dir_ineqs_hp_i = self.__ProjectToHyperplanes(self.dir_ineqs_o[itr], self.dir_eqs_o, zero_position_eqs_o)
-
-            pos_ineqs_hp.append(pos_ineqs_hp_i)
-            dir_ineqs_hp.append(dir_ineqs_hp_i)
-
-        # Project onto adjusted halfspaces along the intersection of hyperplanes
-        dX_o, _, _, exit_code = self.__ProjectToHalfSpaces(dlambda_hp, cm.HorzCat(pos_ineqs_hp, pos_obj_hp), cm.HorzCat(dir_ineqs_hp, dir_obj_hp))
-
-        # Determine return values
-        if exit_code == 0:
-            is_projection_sucessfull = True
-
-            # Backtransformation and multiplication with -1 because the direction vectors are chosen opposite to the gradients such that the lengths are positive if violated
-            dX = cm.ScalarVectorProduct(-1, cm.TranslateToOriginalBasis(dX_o, self.ortho_basis))
-            norm_dX = cm.NormInf3D(dX)
-        else:
-            is_projection_sucessfull = False
-
-            dX = []
-            norm_dX = 1e10
-
-        self.__StoreProjectionResults(norm_dX, dX, is_projection_sucessfull, adj_len_obj, adj_len_eqs, adj_len_ineqs)
-
-        return norm_dX, is_projection_sucessfull
-
-
-    # --------------------------------------------------------------------------
-    def GetDetailedResultsOfLatestProjection(self):
-        if self.are_projection_restuls_stored == False:
-            raise RuntimeError("Projector::__StoreProjectionResults: No projection results stored yet!")
-
-        return self.projection_results
-
-    # --------------------------------------------------------------------------
-    @staticmethod
-    def __ReduceToRelevantEqualityConstraints(len_eqs, dir_eqs):
-        len_eqs_relevant = []
-        dir_eqs_relevant = []
-        remaining_entries = []
-
-        for itr in range(len(dir_eqs)):
-            len_i = len_eqs[itr]
-            dir_i = dir_eqs[itr]
-
-            is_no_gradient_info_available = cm.NormInf3D(dir_i) < 1e-13
-
-            if is_no_gradient_info_available:
-                pass
-            else:
-                remaining_entries.append(itr)
-                len_eqs_relevant.append(len_i)
-                dir_eqs_relevant.append(dir_i)
-
-        return len_eqs_relevant, dir_eqs_relevant, remaining_entries
-
-    # --------------------------------------------------------------------------
-    def __ReduceToRelevantInequalityConstraints(self, len_ineqs, dir_ineqs):
-        len_ineqs_relevant = []
-        dir_ineqs_relevant = []
-        remaining_entries = []
-
-        for itr in range(len(dir_ineqs)):
-            len_i = len_ineqs[itr]
-            dir_i = dir_ineqs[itr]
-
-            is_no_gradient_info_available = cm.NormInf3D(dir_i) < 1e-13
-            is_constraint_inactive_and_far_away = len_i < -self.far_away_length
-
-            if is_no_gradient_info_available or is_constraint_inactive_and_far_away:
-                pass
-            else:
-                remaining_entries.append(itr)
-                len_ineqs_relevant.append(len_i)
-                dir_ineqs_relevant.append(dir_i)
-
-        return len_ineqs_relevant, dir_ineqs_relevant, remaining_entries
-
-    # --------------------------------------------------------------------------
-    def __AdjustHalfSpacesAndHyperplanes(self, len_obj, threshold):
-        if threshold<len_obj:
-            len_obj = threshold
-
-        len_eqs = copy.deepcopy(self.len_eqs)
-        len_ineqs = copy.deepcopy(self.len_ineqs)
-
-        for itr in range(self.num_eqs):
-            len_eqs[itr] = min(max(self.len_eqs[itr],-threshold),threshold)
-
-        for itr in range(self.num_ineqs):
-            len_ineqs[itr] = min(self.len_ineqs[itr],threshold)
-
-        return len_obj, len_eqs, len_ineqs
-
-    # --------------------------------------------------------------------------
-    def __DetermineConstraintBorders(self, len_obj, len_eqs, len_ineqs):
-        pos_obj = cm.ScalarVectorProduct(-len_obj,self.dir_obj_o)
-
-        pos_eqs = []
-        pos_ineqs = []
-        for i in range(self.num_eqs):
-            pos_eqs.append(cm.ScalarVectorProduct(-len_eqs[i],self.dir_eqs_o[i]))
-
-        for i in range(self.num_ineqs):
-            pos_ineqs.append(cm.ScalarVectorProduct(-len_ineqs[i],self.dir_ineqs_o[i]))
-
-        return pos_obj, pos_eqs, pos_ineqs
-
-    # --------------------------------------------------------------------------
-    @staticmethod
-    def __ProjectToHyperplanes(vector, dir_hps, pos_hps):
-        if cm.IsEmpty(dir_hps):
-            return vector
-
-        num_hps = len(dir_hps)
-
-        tmp_mat = cm.Prod(cm.Trans(dir_hps),dir_hps)
-        tmp_vec = [ cm.Dot(dir_hps[j],cm.Minus(pos_hps[j],vector)) for j in range(num_hps) ]
-
-        tmp_solution = cm.SolveLinearSystem(tmp_mat,tmp_vec)
-
-        return cm.Plus(cm.Prod(dir_hps,tmp_solution),vector)
-
-    # --------------------------------------------------------------------------
-    def __ProjectToHalfSpaces(self, dX0, pos_hss, dir_hss):
-        A = cm.Trans(dir_hss)
-        b = [ cm.Dot(pos_hss[i],dir_hss[i]) for i in range(cm.RowSize(A)) ]
-
-        dX_o, subopt_itr, error, exit_code = cm.QuadProg(A, b, self.subopt_max_itr, self.subopt_tolerance)
-
-        # Consider initial delta
-        dX_o = cm.Plus(dX_o,dX0)
-
-        return dX_o, subopt_itr, error, exit_code
-
-    # --------------------------------------------------------------------------
-    def __StoreProjectionResults(self, norm_dX, dX, is_projection_sucessfull, adj_len_obj, adj_len_eqs, adj_len_ineqs):
-        self.are_projection_restuls_stored = True
-        self.projection_results["norm_dX"] = norm_dX
-        self.projection_results["dX"] = dX
-        self.projection_results["is_projection_sucessfull"] = is_projection_sucessfull
-        self.projection_results["adj_len_obj"] = adj_len_obj
-        self.projection_results["adj_len_eqs"], self.projection_results["adj_len_ineqs"] = self.__CompleteConstraintLengthsWithRemovedEntries(adj_len_eqs, adj_len_ineqs)
-
-    # --------------------------------------------------------------------------
-    def __CompleteConstraintLengthsWithRemovedEntries(self, len_eqs, len_ineqs):
-        # Complete list of eqs
-        complete_list_eqs = copy.deepcopy(self.input_len_eqs)
-        for itr in range(len(len_eqs)):
-            original_eq_number = self.remaining_eqs_entries[itr]
-            complete_list_eqs[original_eq_number] = len_eqs[itr]
-
-        # Complete list of ineqs
-        complete_list_ineqs = copy.deepcopy(self.input_len_ineqs)
-        for itr in range(len(len_ineqs)):
-            original_eq_number = self.remaining_ineqs_entries[itr]
-            complete_list_ineqs[original_eq_number] = len_ineqs[itr]
-
-        return complete_list_eqs, complete_list_ineqs
-
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#
+# ==============================================================================
+
+
+# Kratos Core and Apps
+import KratosMultiphysics as KM
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+
+# Additional imports
+from KratosMultiphysics.ShapeOptimizationApplication.algorithms.algorithm_base import OptimizationAlgorithm
+from KratosMultiphysics.ShapeOptimizationApplication import mapper_factory
+from KratosMultiphysics.ShapeOptimizationApplication.loggers import data_logger_factory
+from KratosMultiphysics.ShapeOptimizationApplication.utilities import custom_math as cm
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_variable_utilities import WriteDictionaryDataOnNodalVariable, ReadNodalVariableToList, WriteListToNodalVariable
+import copy
+
+# ==============================================================================
+class AlgorithmTrustRegion(OptimizationAlgorithm):
+    # --------------------------------------------------------------------------
+    def __init__(self, optimization_settings, analyzer, communicator, model_part_controller):
+        default_algorithm_settings = KM.Parameters("""
+        {
+            "name"                          : "trust_region",
+            "max_step_length"               : 1.0,
+            "step_length_tolerance"         : 1e-3,
+            "step_length_reduction_factor"  : 0.5,
+            "max_iterations"                : 10,
+            "far_away_length"               : 2.0,
+            "subopt_max_itr"                : 50,
+            "subopt_tolerance"              : 1e-10,
+            "bisectioning_max_itr"          : 30,
+            "bisectioning_tolerance"        : 1e-2,
+            "relative_tolerance"            : 1e-12,
+            "obj_share_during_correction"   : 1
+        }""")
+        self.algorithm_settings =  optimization_settings["optimization_algorithm"]
+        self.algorithm_settings.RecursivelyValidateAndAssignDefaults(default_algorithm_settings)
+
+        self.optimization_settings = optimization_settings
+        self.mapper_settings = optimization_settings["design_variables"]["filter"]
+
+        self.analyzer = analyzer
+        self.communicator = communicator
+        self.model_part_controller = model_part_controller
+
+        self.design_surface = None
+        self.mapper = None
+        self.data_logger = None
+        self.optimization_utilities = None
+
+        self.objectives = optimization_settings["objectives"]
+        self.constraints = optimization_settings["constraints"]
+
+        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
+
+    # --------------------------------------------------------------------------
+    def CheckApplicability(self):
+        if self.objectives.size() > 1:
+            raise RuntimeError("Trust-region algorithm only supports one objective function!")
+
+    # --------------------------------------------------------------------------
+    def InitializeOptimizationLoop(self):
+        self.model_part_controller.Initialize()
+
+        self.analyzer.InitializeBeforeOptimizationLoop()
+
+        self.design_surface = self.model_part_controller.GetDesignSurface()
+
+        self.mapper = mapper_factory.CreateMapper(self.design_surface, self.design_surface, self.mapper_settings)
+        self.mapper.Initialize()
+        self.model_part_controller.InitializeDamping()
+
+        self.data_logger = data_logger_factory.CreateDataLogger(self.model_part_controller, self.communicator, self.optimization_settings)
+        self.data_logger.InitializeDataLogging()
+
+        self.optimization_utilities = KSO.OptimizationUtilities
+
+    # --------------------------------------------------------------------------
+    def RunOptimizationLoop(self):
+        timer = Timer()
+        timer.StartTimer()
+
+        for self.opt_iteration in range(1,self.algorithm_settings["max_iterations"].GetInt()+1):
+            KM.Logger.Print("")
+            KM.Logger.Print("===============================================================================")
+            KM.Logger.PrintInfo("ShapeOpt", timer.GetTimeStamp(), ": Starting optimization iteration ",self.opt_iteration)
+            KM.Logger.Print("===============================================================================\n")
+
+            timer.StartNewLap()
+
+            self.__InitializeNewShape()
+
+            self.__AnalyzeShape()
+
+            self.__PostProcessGradientsObtainedFromAnalysis()
+
+            len_obj, dir_obj, len_eqs, dir_eqs, len_ineqs, dir_ineqs =  self.__ConvertAnalysisResultsToLengthDirectionFormat()
+
+            step_length = self.__DetermineMaxStepLength()
+
+            len_bar_obj, len_bar_eqs, len_bar_ineqs = self.__ExpressInStepLengthUnit(len_obj, len_eqs, len_ineqs, step_length)
+
+            dX_bar, process_details = self.__DetermineStep(len_bar_obj, dir_obj, len_bar_eqs, dir_eqs, len_bar_ineqs, dir_ineqs)
+
+            dX = self.__ComputeShapeUpdate(dX_bar, step_length)
+
+            values_to_be_logged = {}
+            values_to_be_logged["len_bar_obj"] = len_bar_obj
+            values_to_be_logged["len_bar_cons"] = self.__CombineConstraintDataToOrderedList(len_bar_eqs, len_bar_ineqs)
+            values_to_be_logged["step_length"] = step_length
+            values_to_be_logged["test_norm_dX_bar"] = process_details["test_norm_dX"]
+            values_to_be_logged["bi_itrs"] = process_details["bi_itrs"]
+            values_to_be_logged["bi_err"] = process_details["bi_err"]
+            values_to_be_logged["adj_len_bar_obj"] = process_details["adj_len_obj"]
+            values_to_be_logged["adj_len_bar_cons"] = self.__CombineConstraintDataToOrderedList(process_details["adj_len_eqs"], process_details["adj_len_ineqs"])
+            values_to_be_logged["norm_dX"] = cm.NormInf3D(dX)
+
+            self.__LogCurrentOptimizationStep(values_to_be_logged)
+
+            KM.Logger.Print("")
+            KM.Logger.PrintInfo("ShapeOpt", "Time needed for current optimization step = ", timer.GetLapTime(), "s")
+            KM.Logger.PrintInfo("ShapeOpt", "Time needed for total optimization so far = ", timer.GetTotalTime(), "s")
+
+            if self.__isAlgorithmConverged():
+                break
+
+    # --------------------------------------------------------------------------
+    def FinalizeOptimizationLoop(self):
+        self.analyzer.FinalizeAfterOptimizationLoop()
+        self.data_logger.FinalizeDataLogging()
+
+    # --------------------------------------------------------------------------
+    def __isAlgorithmConverged(self):
+
+        if self.opt_iteration > 1 :
+            # Check if maximum iterations were reached
+            if self.opt_iteration == self.algorithm_settings["max_iterations"].GetInt():
+                KM.Logger.Print("")
+                KM.Logger.PrintInfo("ShapeOpt", "Maximal iterations of optimization problem reached!")
+                return True
+
+            # Check for relative tolerance
+            relative_change_of_objective_value = self.data_logger.GetValues("rel_change_objective")[self.opt_iteration]
+            if abs(relative_change_of_objective_value) < self.algorithm_settings["relative_tolerance"].GetDouble():
+                KM.Logger.Print("")
+                KM.Logger.PrintInfo("ShapeOpt", "Optimization problem converged within a relative objective tolerance of ",self.algorithm_settings["relative_tolerance"].GetDouble(),"%.")
+                return True
+
+    # --------------------------------------------------------------------------
+    def __InitializeNewShape(self):
+        self.model_part_controller.UpdateTimeStep(self.opt_iteration)
+        self.model_part_controller.UpdateMeshAccordingInputVariable(KSO.SHAPE_UPDATE)
+        self.model_part_controller.SetReferenceMeshToMesh()
+
+    # --------------------------------------------------------------------------
+    def __AnalyzeShape(self):
+            self.communicator.initializeCommunication()
+
+            obj_id = self.objectives[0]["identifier"].GetString()
+            self.communicator.requestValueOf(obj_id)
+            self.communicator.requestGradientOf(obj_id)
+
+            for itr in range(self.constraints.size()):
+                con_id =  self.constraints[itr]["identifier"].GetString()
+                self.communicator.requestValueOf(con_id)
+                self.communicator.requestGradientOf(con_id)
+
+            self.analyzer.AnalyzeDesignAndReportToCommunicator(self.optimization_model_part, self.opt_iteration, self.communicator)
+
+    # --------------------------------------------------------------------------
+    def __PostProcessGradientsObtainedFromAnalysis(self):
+        # Compute surface normals if required
+        if self.objectives[0]["project_gradient_on_surface_normals"].GetBool():
+            self.model_part_controller.ComputeUnitSurfaceNormals()
+        else:
+            for itr in range(self.constraints.size()):
+                if self.constraints[itr]["project_gradient_on_surface_normals"].GetBool():
+                    self.model_part_controller.ComputeUnitSurfaceNormals()
+
+        # Process objective gradients
+        obj = self.objectives[0]
+        obj_id = obj["identifier"].GetString()
+
+        obj_gradients_dict = self.communicator.getStandardizedGradient(obj_id)
+
+        nodal_variable = KM.KratosGlobals.GetVariable("DF1DX")
+        WriteDictionaryDataOnNodalVariable(obj_gradients_dict, self.optimization_model_part, nodal_variable)
+
+        # Projection on surface normals
+        if obj["project_gradient_on_surface_normals"].GetBool():
+            self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(nodal_variable)
+
+        # Damping
+        self.model_part_controller.DampNodalSensitivityVariableIfSpecified(nodal_variable)
+
+        # Mapping
+        nodal_variable_mapped = KM.KratosGlobals.GetVariable("DF1DX_MAPPED")
+        self.mapper.Update()
+        self.mapper.InverseMap(nodal_variable, nodal_variable_mapped)
+        self.mapper.Map(nodal_variable_mapped, nodal_variable_mapped)
+
+        # Damping
+        self.model_part_controller.DampNodalUpdateVariableIfSpecified(nodal_variable_mapped)
+
+        # Process constraint gradients
+        for itr in range(self.constraints.size()):
+            con = self.constraints[itr]
+            con_id = con["identifier"].GetString()
+
+            eq_gradients_dict = self.communicator.getStandardizedGradient(con_id)
+
+            nodal_variable = KM.KratosGlobals.GetVariable("DC"+str(itr+1)+"DX")
+            WriteDictionaryDataOnNodalVariable(eq_gradients_dict, self.optimization_model_part, nodal_variable)
+
+            # Projection on surface normals
+            if con["project_gradient_on_surface_normals"].GetBool():
+                self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(nodal_variable)
+
+            # Damping
+            self.model_part_controller.DampNodalSensitivityVariableIfSpecified(nodal_variable)
+
+            # Mapping
+            nodal_variable_mapped = KM.KratosGlobals.GetVariable(f"DC{(itr+1)}DX_MAPPED")
+            self.mapper.InverseMap(nodal_variable, nodal_variable_mapped)
+            self.mapper.Map(nodal_variable_mapped, nodal_variable_mapped)
+
+            # Damping
+            self.model_part_controller.DampNodalUpdateVariableIfSpecified(nodal_variable_mapped)
+
+    # --------------------------------------------------------------------------
+    def __ConvertAnalysisResultsToLengthDirectionFormat(self):
+        # Convert objective results
+        obj = self.objectives[0]
+        obj_id = obj["identifier"].GetString()
+
+        nodal_variable = KM.KratosGlobals.GetVariable("DF1DX")
+        nodal_variable_mapped = KM.KratosGlobals.GetVariable("DF1DX_MAPPED")
+
+        obj_value = self.communicator.getStandardizedValue(obj_id)
+        obj_gradient = ReadNodalVariableToList(self.design_surface, nodal_variable)
+        obj_gradient_mapped = ReadNodalVariableToList(self.design_surface, nodal_variable_mapped)
+
+        dir_obj, len_obj = self.__ConvertToLengthDirectionFormat(obj_value, obj_gradient, obj_gradient_mapped)
+        dir_obj = dir_obj
+
+        # Convert constraints
+        len_eqs = []
+        dir_eqs = []
+        len_ineqs = []
+        dir_ineqs = []
+
+        for itr in range(self.constraints.size()):
+            con = self.constraints[itr]
+            con_id = con["identifier"].GetString()
+
+            nodal_variable = KM.KratosGlobals.GetVariable(f"DC{(itr+1)}DX")
+            nodal_variable_mapped = KM.KratosGlobals.GetVariable(f"DC{(itr+1)}DX_MAPPED")
+
+            value = self.communicator.getStandardizedValue(con_id)
+            gradient = ReadNodalVariableToList(self.design_surface, nodal_variable)
+            gradient_mapped = ReadNodalVariableToList(self.design_surface, nodal_variable_mapped)
+
+            direction, length = self.__ConvertToLengthDirectionFormat(value, gradient, gradient_mapped)
+
+            if con["type"].GetString()=="=":
+                dir_eqs.append(direction)
+                len_eqs.append(length)
+            else:
+                dir_ineqs.append(direction)
+                len_ineqs.append(length)
+
+        return len_obj, dir_obj, len_eqs, dir_eqs, len_ineqs, dir_ineqs
+
+    # --------------------------------------------------------------------------
+    @staticmethod
+    def __ConvertToLengthDirectionFormat(value, gradient, modified_gradient):
+        norm_inf = cm.NormInf3D(modified_gradient)
+        if norm_inf > 1e-12:
+            direction = cm.ScalarVectorProduct(-1/norm_inf,modified_gradient)
+            length = -value/cm.Dot(gradient, direction)
+        else:
+            KM.Logger.PrintWarning("ShapeOpt::AlgorithmTrustRegion", "Vanishing norm-infinity for gradient detected!")
+            direction = modified_gradient
+            length = 0.0
+
+        return direction, length
+
+    # --------------------------------------------------------------------------
+    def __DetermineMaxStepLength(self):
+        if self.opt_iteration < 4:
+            return self.algorithm_settings["max_step_length"].GetDouble()
+        else:
+            obj_id = self.objectives[0]["identifier"].GetString()
+            current_obj_val = self.communicator.getStandardizedValue(obj_id)
+            obj_history = self.data_logger.GetValues("response_value")[obj_id]
+            step_history = self.data_logger.GetValues("step_length")
+
+            # Check for osciallation
+            objective_is_oscillating = False
+            is_decrease_1 = (current_obj_val - obj_history[self.opt_iteration-1])< 0
+            is_decrease_2 = (obj_history[self.opt_iteration-1] - obj_history[self.opt_iteration-2])<0
+            is_decrease_3 = (current_obj_val - obj_history[self.opt_iteration-3])< 0
+            if (is_decrease_1 and is_decrease_2== False and is_decrease_3) or (is_decrease_1== False and is_decrease_2 and is_decrease_3==False):
+                objective_is_oscillating = True
+
+            # Reduce step length if certain conditions are fullfilled
+            if objective_is_oscillating:
+                return step_history[self.opt_iteration-1]*self.algorithm_settings["step_length_reduction_factor"].GetDouble()
+            else:
+                return step_history[self.opt_iteration-1]
+
+    # --------------------------------------------------------------------------
+    @staticmethod
+    def __ExpressInStepLengthUnit(len_obj, len_eqs, len_ineqs, step_length):
+        len_bar_obj = 1/step_length * len_obj
+        len_bar_eqs = cm.ScalarVectorProduct(1/step_length, len_eqs)
+        len_bar_ineqs = cm.ScalarVectorProduct(1/step_length, len_ineqs)
+        return len_bar_obj, len_bar_eqs, len_bar_ineqs
+
+    # --------------------------------------------------------------------------
+    def __DetermineStep(self, len_obj, dir_obj, len_eqs, dir_eqs, len_ineqs, dir_ineqs):
+        KM.Logger.Print("")
+        KM.Logger.PrintInfo("ShapeOpt", "Starting determination of step...")
+
+        timer = Timer()
+        timer.StartTimer()
+
+        # Create projector object wich can do the projection in the orthogonalized subspace
+        projector = Projector(len_obj, dir_obj, len_eqs, dir_eqs, len_ineqs, dir_ineqs, self.algorithm_settings)
+
+        # 1. Test projection if there is room for objective improvement
+        # I.e., the actual step length to become feasible for an inactive threshold is smaller than 1 and hence a part of the step can be dedicated to objective improvement
+        len_obj_test = 0.01
+        inactive_threshold = 100
+        test_norm_dX, is_projection_sucessfull = projector.RunProjection(len_obj_test, inactive_threshold)
+
+        KM.Logger.PrintInfo("ShapeOpt", "Time needed for one projection step = ", timer.GetTotalTime(), "s")
+
+        # 2. Determine step following two different modes depending on the previos found step length to the feasible domain
+        if is_projection_sucessfull:
+            if test_norm_dX < 1: # Minimizing mode
+                KM.Logger.Print("")
+                KM.Logger.PrintInfo("ShapeOpt", "Computing projection case 1...")
+
+                func = lambda len_obj: projector.RunProjection(len_obj, inactive_threshold)
+
+                len_obj_min = len_obj_test
+                len_obj_max = 1.3
+                bi_target = 1
+                bi_tolerance = self.algorithm_settings["bisectioning_tolerance"].GetDouble()
+                bi_max_itr = self.algorithm_settings["bisectioning_max_itr"].GetInt()
+                len_obj_result, bi_itrs, bi_err = cm.PerformBisectioning(func, len_obj_min, len_obj_max, bi_target, bi_tolerance, bi_max_itr)
+
+                projection_results = projector.GetDetailedResultsOfLatestProjection()
+
+            else: # Correction mode
+                KM.Logger.Print("")
+                KM.Logger.PrintInfo("ShapeOpt", "Computing projection case 2...")
+
+                len_obj = self.algorithm_settings["obj_share_during_correction"].GetDouble()
+                func = lambda threshold: projector.RunProjection(len_obj, threshold)
+
+                threshold_min = 0
+                threshold_max = 1.3
+                bi_target = 1
+                bi_tolerance = self.algorithm_settings["bisectioning_tolerance"].GetDouble()
+                bi_max_itr = self.algorithm_settings["bisectioning_max_itr"].GetInt()
+                l_threshold_result, bi_itrs, bi_err = cm.PerformBisectioning(func, threshold_min, threshold_max, bi_target, bi_tolerance, bi_max_itr)
+
+                projection_results = projector.GetDetailedResultsOfLatestProjection()
+        else:
+            raise RuntimeError("Case of not converged test projection not yet implemented yet!")
+
+        KM.Logger.Print("")
+        KM.Logger.PrintInfo("ShapeOpt", "Time needed for determining step = ", timer.GetTotalTime(), "s")
+
+        process_details = { "test_norm_dX": test_norm_dX,
+                            "bi_itrs":bi_itrs,
+                            "bi_err":bi_err,
+                            "adj_len_obj": projection_results["adj_len_obj"],
+                            "adj_len_eqs": projection_results["adj_len_eqs"],
+                            "adj_len_ineqs": projection_results["adj_len_ineqs"] }
+
+        return projection_results["dX"], process_details
+
+    # --------------------------------------------------------------------------
+    def __ComputeShapeUpdate(self, dX_bar, step_length):
+        # Compute update in regular units
+        dX = cm.ScalarVectorProduct(step_length,dX_bar)
+
+        WriteListToNodalVariable(dX, self.design_surface, KSO.SHAPE_UPDATE)
+        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.SHAPE_UPDATE, KSO.SHAPE_CHANGE)
+
+        return dX
+
+    # --------------------------------------------------------------------------
+    def __LogCurrentOptimizationStep(self, additional_values_to_log):
+        self.data_logger.LogSensitivityHeatmap(self.opt_iteration, self.mapper)
+        self.data_logger.LogCurrentValues(self.opt_iteration, additional_values_to_log)
+        self.data_logger.LogCurrentDesign(self.opt_iteration)
+
+    # --------------------------------------------------------------------------
+    def __CombineConstraintDataToOrderedList(self, eqs_data_list, ineqs_data_list):
+        num_eqs = 0
+        num_ineqs = 0
+        combined_list = []
+
+        # Order is given by appearance of constraints in optimization settings
+        for itr in range(self.constraints.size()):
+            if self.constraints[itr]["type"].GetString()=="=":
+                combined_list.append(eqs_data_list[num_eqs])
+                num_eqs = num_eqs+1
+            else:
+                combined_list.append(ineqs_data_list[num_ineqs])
+                num_ineqs = num_ineqs+1
+
+        return combined_list
+
+# ==============================================================================
+class Projector():
+    # --------------------------------------------------------------------------
+    def __init__(self, len_obj, dir_obj, len_eqs, dir_eqs, len_ineqs, dir_ineqs, settings):
+
+        # Store settings
+        self.far_away_length = settings["far_away_length"].GetDouble()
+        self.subopt_max_itr = settings["subopt_max_itr"].GetInt()
+        self.subopt_tolerance = settings["subopt_tolerance"].GetDouble()
+
+        # Initialize projection results
+        self.are_projection_restuls_stored = False
+        self.projection_results = {}
+
+        # Reduce input data to relevant info
+        self.input_len_obj = len_obj
+        self.input_len_eqs = len_eqs
+        self.input_len_ineqs = len_ineqs
+
+        len_eqs, dir_eqs, remaining_eqs_entries = self.__ReduceToRelevantEqualityConstraints(len_eqs, dir_eqs)
+        len_ineqs, dir_ineqs, remaining_ineqs_entries = self.__ReduceToRelevantInequalityConstraints(len_ineqs, dir_ineqs)
+
+        # Store some working variables depening on data reduction
+        self.remaining_eqs_entries = remaining_eqs_entries
+        self.remaining_ineqs_entries = remaining_ineqs_entries
+        self.len_eqs = len_eqs
+        self.len_ineqs = len_ineqs
+        self.num_eqs = len(len_eqs)
+        self.num_ineqs = len(len_ineqs)
+        self.num_unknowns = 1 + self.num_eqs + self.num_ineqs
+
+        # Create orthogonal basis
+        vector_space = [dir_obj]
+        for itr in range(len(dir_eqs)):
+            vector_space = cm.HorzCat(vector_space, dir_eqs[itr])
+        for itr in range(len(dir_ineqs)):
+            vector_space = cm.HorzCat(vector_space, dir_ineqs[itr])
+        self.ortho_basis = cm.PerformGramSchmidtOrthogonalization(vector_space)
+
+        # Transform directions to orthogonal space since they don't change with different projections
+        self.dir_obj_o = cm.TranslateToNewBasis(dir_obj, self.ortho_basis)
+        self.dir_eqs_o = cm.TranslateToNewBasis(dir_eqs, self.ortho_basis)
+        self.dir_ineqs_o = cm.TranslateToNewBasis(dir_ineqs, self.ortho_basis)
+
+        # Make sure directions of constraints are stored as matrix
+        self.dir_eqs_o = cm.SafeConvertVectorToMatrix(self.dir_eqs_o)
+        self.dir_ineqs_o = cm.SafeConvertVectorToMatrix(self.dir_ineqs_o)
+
+    # --------------------------------------------------------------------------
+    def RunProjection(self, len_obj, threshold):
+
+        # Adjust halfspaces according input
+        adj_len_obj, adj_len_eqs, adj_len_ineqs = self.__AdjustHalfSpacesAndHyperplanes(len_obj, threshold)
+
+        # Determine position of border of halfspaces and hyperplanes
+        pos_obj_o, pos_eqs_o, pos_ineqs_o = self.__DetermineConstraintBorders(adj_len_obj, adj_len_eqs, adj_len_ineqs)
+
+        # Project current position onto intersection of
+        current_position = cm.ZeroVector(self.num_unknowns)
+        dlambda_hp = self.__ProjectToHyperplanes(current_position, self.dir_eqs_o, pos_eqs_o)
+
+        # Project position and direction of halfspaces onto intersection of hyperplanes
+        zero_position_eqs_o = cm.ZeroMatrix(self.num_unknowns,self.num_eqs)
+
+        pos_obj_hp = self.__ProjectToHyperplanes(pos_obj_o, cm.HorzCat(self.dir_eqs_o, self.dir_obj_o), cm.HorzCat(pos_eqs_o, pos_obj_o))
+        dir_obj_hp = self.__ProjectToHyperplanes(self.dir_obj_o, self.dir_eqs_o, zero_position_eqs_o)
+
+        pos_ineqs_hp = []
+        dir_ineqs_hp = []
+        for itr in range(self.num_ineqs):
+            pos_ineqs_hp_i = self.__ProjectToHyperplanes(pos_ineqs_o[itr], cm.HorzCat(self.dir_eqs_o, self.dir_ineqs_o[itr]), cm.HorzCat(pos_eqs_o, pos_ineqs_o[itr]))
+            dir_ineqs_hp_i = self.__ProjectToHyperplanes(self.dir_ineqs_o[itr], self.dir_eqs_o, zero_position_eqs_o)
+
+            pos_ineqs_hp.append(pos_ineqs_hp_i)
+            dir_ineqs_hp.append(dir_ineqs_hp_i)
+
+        # Project onto adjusted halfspaces along the intersection of hyperplanes
+        dX_o, _, _, exit_code = self.__ProjectToHalfSpaces(dlambda_hp, cm.HorzCat(pos_ineqs_hp, pos_obj_hp), cm.HorzCat(dir_ineqs_hp, dir_obj_hp))
+
+        # Determine return values
+        if exit_code == 0:
+            is_projection_sucessfull = True
+
+            # Backtransformation and multiplication with -1 because the direction vectors are chosen opposite to the gradients such that the lengths are positive if violated
+            dX = cm.ScalarVectorProduct(-1, cm.TranslateToOriginalBasis(dX_o, self.ortho_basis))
+            norm_dX = cm.NormInf3D(dX)
+        else:
+            is_projection_sucessfull = False
+
+            dX = []
+            norm_dX = 1e10
+
+        self.__StoreProjectionResults(norm_dX, dX, is_projection_sucessfull, adj_len_obj, adj_len_eqs, adj_len_ineqs)
+
+        return norm_dX, is_projection_sucessfull
+
+
+    # --------------------------------------------------------------------------
+    def GetDetailedResultsOfLatestProjection(self):
+        if self.are_projection_restuls_stored == False:
+            raise RuntimeError("Projector::__StoreProjectionResults: No projection results stored yet!")
+
+        return self.projection_results
+
+    # --------------------------------------------------------------------------
+    @staticmethod
+    def __ReduceToRelevantEqualityConstraints(len_eqs, dir_eqs):
+        len_eqs_relevant = []
+        dir_eqs_relevant = []
+        remaining_entries = []
+
+        for itr in range(len(dir_eqs)):
+            len_i = len_eqs[itr]
+            dir_i = dir_eqs[itr]
+
+            is_no_gradient_info_available = cm.NormInf3D(dir_i) < 1e-13
+
+            if is_no_gradient_info_available:
+                pass
+            else:
+                remaining_entries.append(itr)
+                len_eqs_relevant.append(len_i)
+                dir_eqs_relevant.append(dir_i)
+
+        return len_eqs_relevant, dir_eqs_relevant, remaining_entries
+
+    # --------------------------------------------------------------------------
+    def __ReduceToRelevantInequalityConstraints(self, len_ineqs, dir_ineqs):
+        len_ineqs_relevant = []
+        dir_ineqs_relevant = []
+        remaining_entries = []
+
+        for itr in range(len(dir_ineqs)):
+            len_i = len_ineqs[itr]
+            dir_i = dir_ineqs[itr]
+
+            is_no_gradient_info_available = cm.NormInf3D(dir_i) < 1e-13
+            is_constraint_inactive_and_far_away = len_i < -self.far_away_length
+
+            if is_no_gradient_info_available or is_constraint_inactive_and_far_away:
+                pass
+            else:
+                remaining_entries.append(itr)
+                len_ineqs_relevant.append(len_i)
+                dir_ineqs_relevant.append(dir_i)
+
+        return len_ineqs_relevant, dir_ineqs_relevant, remaining_entries
+
+    # --------------------------------------------------------------------------
+    def __AdjustHalfSpacesAndHyperplanes(self, len_obj, threshold):
+        if threshold<len_obj:
+            len_obj = threshold
+
+        len_eqs = copy.deepcopy(self.len_eqs)
+        len_ineqs = copy.deepcopy(self.len_ineqs)
+
+        for itr in range(self.num_eqs):
+            len_eqs[itr] = min(max(self.len_eqs[itr],-threshold),threshold)
+
+        for itr in range(self.num_ineqs):
+            len_ineqs[itr] = min(self.len_ineqs[itr],threshold)
+
+        return len_obj, len_eqs, len_ineqs
+
+    # --------------------------------------------------------------------------
+    def __DetermineConstraintBorders(self, len_obj, len_eqs, len_ineqs):
+        pos_obj = cm.ScalarVectorProduct(-len_obj,self.dir_obj_o)
+
+        pos_eqs = []
+        pos_ineqs = []
+        for i in range(self.num_eqs):
+            pos_eqs.append(cm.ScalarVectorProduct(-len_eqs[i],self.dir_eqs_o[i]))
+
+        for i in range(self.num_ineqs):
+            pos_ineqs.append(cm.ScalarVectorProduct(-len_ineqs[i],self.dir_ineqs_o[i]))
+
+        return pos_obj, pos_eqs, pos_ineqs
+
+    # --------------------------------------------------------------------------
+    @staticmethod
+    def __ProjectToHyperplanes(vector, dir_hps, pos_hps):
+        if cm.IsEmpty(dir_hps):
+            return vector
+
+        num_hps = len(dir_hps)
+
+        tmp_mat = cm.Prod(cm.Trans(dir_hps),dir_hps)
+        tmp_vec = [ cm.Dot(dir_hps[j],cm.Minus(pos_hps[j],vector)) for j in range(num_hps) ]
+
+        tmp_solution = cm.SolveLinearSystem(tmp_mat,tmp_vec)
+
+        return cm.Plus(cm.Prod(dir_hps,tmp_solution),vector)
+
+    # --------------------------------------------------------------------------
+    def __ProjectToHalfSpaces(self, dX0, pos_hss, dir_hss):
+        A = cm.Trans(dir_hss)
+        b = [ cm.Dot(pos_hss[i],dir_hss[i]) for i in range(cm.RowSize(A)) ]
+
+        dX_o, subopt_itr, error, exit_code = cm.QuadProg(A, b, self.subopt_max_itr, self.subopt_tolerance)
+
+        # Consider initial delta
+        dX_o = cm.Plus(dX_o,dX0)
+
+        return dX_o, subopt_itr, error, exit_code
+
+    # --------------------------------------------------------------------------
+    def __StoreProjectionResults(self, norm_dX, dX, is_projection_sucessfull, adj_len_obj, adj_len_eqs, adj_len_ineqs):
+        self.are_projection_restuls_stored = True
+        self.projection_results["norm_dX"] = norm_dX
+        self.projection_results["dX"] = dX
+        self.projection_results["is_projection_sucessfull"] = is_projection_sucessfull
+        self.projection_results["adj_len_obj"] = adj_len_obj
+        self.projection_results["adj_len_eqs"], self.projection_results["adj_len_ineqs"] = self.__CompleteConstraintLengthsWithRemovedEntries(adj_len_eqs, adj_len_ineqs)
+
+    # --------------------------------------------------------------------------
+    def __CompleteConstraintLengthsWithRemovedEntries(self, len_eqs, len_ineqs):
+        # Complete list of eqs
+        complete_list_eqs = copy.deepcopy(self.input_len_eqs)
+        for itr in range(len(len_eqs)):
+            original_eq_number = self.remaining_eqs_entries[itr]
+            complete_list_eqs[original_eq_number] = len_eqs[itr]
+
+        # Complete list of ineqs
+        complete_list_ineqs = copy.deepcopy(self.input_len_ineqs)
+        for itr in range(len(len_ineqs)):
+            original_eq_number = self.remaining_ineqs_entries[itr]
+            complete_list_ineqs[original_eq_number] = len_ineqs[itr]
+
+        return complete_list_eqs, complete_list_ineqs
+
 # ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_bead_optimization.py

 * *Ordering differences only*

```diff
@@ -1,412 +1,412 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#                   Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-
-# Kratos Core and Apps
-import KratosMultiphysics as KM
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-
-# Additional imports
-from KratosMultiphysics.ShapeOptimizationApplication.algorithms.algorithm_base import OptimizationAlgorithm
-from KratosMultiphysics.ShapeOptimizationApplication import mapper_factory
-from KratosMultiphysics.ShapeOptimizationApplication.loggers import data_logger_factory
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_variable_utilities import WriteDictionaryDataOnNodalVariable
-import math
-
-# ==============================================================================
-class AlgorithmBeadOptimization(OptimizationAlgorithm):
-    # --------------------------------------------------------------------------
-    def __init__(self, optimization_settings, analyzer, communicator, model_part_controller):
-        default_algorithm_settings = KM.Parameters("""
-        {
-            "name"                          : "bead_optimization",
-            "bead_height"                   : 1.0,
-            "bead_direction"                : [],
-            "bead_side"                     : "both",
-            "fix_boundaries"                : [],
-            "estimated_lagrange_multiplier" : 1.0,
-            "max_total_iterations"          : 10000,
-            "max_outer_iterations"          : 10000,
-            "max_inner_iterations"          : 30,
-            "min_inner_iterations"          : 3,
-            "inner_iteration_tolerance"     : 1e-3,
-            "line_search" : {
-                "line_search_type"           : "manual_stepping",
-                "normalize_search_direction" : true,
-                "step_size"                  : 1.0
-            },
-            "filter_penalty_term"           : false,
-            "penalty_filter_radius"         : -1.0
-        }""")
-        self.algorithm_settings =  optimization_settings["optimization_algorithm"]
-        self.algorithm_settings.RecursivelyValidateAndAssignDefaults(default_algorithm_settings)
-
-        self.optimization_settings = optimization_settings
-        self.mapper_settings = optimization_settings["design_variables"]["filter"]
-
-        if self.algorithm_settings["filter_penalty_term"].GetBool():
-            if self.algorithm_settings["penalty_filter_radius"].GetDouble() == -1.0:
-                raise RuntimeError("The parameter `penalty_filter_radius` is missing in order to filter the penalty term!")
-
-        self.analyzer = analyzer
-        self.communicator = communicator
-        self.model_part_controller = model_part_controller
-
-        self.design_surface = None
-        self.mapper = None
-        self.penalty_filter = None
-        self.data_logger = None
-        self.optimization_utilities = None
-
-        self.objectives = optimization_settings["objectives"]
-        self.constraints = optimization_settings["constraints"]
-
-        self.bead_height = self.algorithm_settings["bead_height"].GetDouble()
-        self.bead_side = self.algorithm_settings["bead_side"].GetString()
-        self.filter_penalty_term = self.algorithm_settings["filter_penalty_term"].GetBool()
-        self.estimated_lagrange_multiplier = self.algorithm_settings["estimated_lagrange_multiplier"].GetDouble()
-        self.max_total_iterations = self.algorithm_settings["max_total_iterations"].GetInt()
-        self.max_outer_iterations = self.algorithm_settings["max_outer_iterations"].GetInt()
-        self.max_inner_iterations = self.algorithm_settings["max_inner_iterations"].GetInt()
-        self.min_inner_iterations = self.algorithm_settings["min_inner_iterations"].GetInt()
-        self.inner_iteration_tolerance = self.algorithm_settings["inner_iteration_tolerance"].GetDouble()
-        self.step_size = self.algorithm_settings["line_search"]["step_size"].GetDouble()
-
-        self.lower_bound = None
-        self.upper_bound = None
-
-        self.lambda0 = 0.0
-        self.penalty_scaling_0 = 1.0
-        self.penalty_factor_0 = 1.0
-
-        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.ALPHA)
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.ALPHA_MAPPED)
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.DF1DALPHA)
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.DF1DALPHA_MAPPED)
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.DPDALPHA)
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.DPDALPHA_MAPPED)
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.DLDALPHA)
-
-    # --------------------------------------------------------------------------
-    def CheckApplicability(self):
-        if self.objectives.size() > 1:
-            raise RuntimeError("The augmented lagrange algorithm for bead optimization only supports one objective function!")
-        if self.constraints.size() > 0:
-            raise RuntimeError("The augmented lagrange algorithm for bead does not allow for any constraints!")
-
-    # --------------------------------------------------------------------------
-    def InitializeOptimizationLoop(self):
-        self.model_part_controller.Initialize()
-        self.model_part_controller.SetMinimalBufferSize(2)
-
-        self.analyzer.InitializeBeforeOptimizationLoop()
-
-        self.design_surface = self.model_part_controller.GetDesignSurface()
-
-        self.mapper = mapper_factory.CreateMapper(self.design_surface, self.design_surface, self.mapper_settings)
-        self.mapper.Initialize()
-        self.model_part_controller.InitializeDamping()
-
-        if self.filter_penalty_term:
-            penalty_filter_radius = self.algorithm_settings["penalty_filter_radius"].GetDouble()
-            filter_radius = self.mapper_settings["filter_radius"].GetDouble()
-            if abs(filter_radius - penalty_filter_radius) > 1e-9:
-                penalty_filter_settings = self.mapper_settings.Clone()
-                penalty_filter_settings["filter_radius"].SetDouble(self.algorithm_settings["penalty_filter_radius"].GetDouble())
-                self.penalty_filter = mapper_factory.CreateMapper(self.design_surface, self.design_surface, penalty_filter_settings)
-                self.penalty_filter.Initialize()
-            else:
-                self.penalty_filter = self.mapper
-
-        self.data_logger = data_logger_factory.CreateDataLogger(self.model_part_controller, self.communicator, self.optimization_settings)
-        self.data_logger.InitializeDataLogging()
-
-        self.optimization_utilities = KSO.OptimizationUtilities
-
-        # Identify fixed design areas
-        KM.VariableUtils().SetFlag(KM.BOUNDARY, False, self.optimization_model_part.Nodes)
-
-        radius = self.mapper_settings["filter_radius"].GetDouble()
-        search_based_functions = KSO.SearchBasedFunctions(self.design_surface)
-
-        for itr in range(self.algorithm_settings["fix_boundaries"].size()):
-            sub_model_part_name = self.algorithm_settings["fix_boundaries"][itr].GetString()
-            node_set = self.optimization_model_part.GetSubModelPart(sub_model_part_name).Nodes
-            search_based_functions.FlagNodesInRadius(node_set, KM.BOUNDARY, radius)
-
-        # Specify bounds and assign starting values for ALPHA
-        if self.bead_side == "positive":
-            KM.VariableUtils().SetScalarVar(KSO.ALPHA, 0.5, self.design_surface.Nodes, KM.BOUNDARY, False)
-            self.lower_bound = 0.0
-            self.upper_bound = 1.0
-        elif self.bead_side == "negative":
-            KM.VariableUtils().SetScalarVar(KSO.ALPHA, -0.5, self.design_surface.Nodes, KM.BOUNDARY, False)
-            self.lower_bound = -1.0
-            self.upper_bound = 0.0
-        elif self.bead_side == "both":
-            KM.VariableUtils().SetScalarVar(KSO.ALPHA, 0.0, self.design_surface.Nodes, KM.BOUNDARY, False)
-            self.lower_bound = -1.0
-            self.upper_bound = 1.0
-        else:
-            raise RuntimeError("Specified bead direction mode not supported!")
-
-        # Initialize ALPHA_MAPPED according to initial ALPHA values
-        self.mapper.Map(KSO.ALPHA, KSO.ALPHA_MAPPED)
-
-        # Specify bead direction
-        bead_direction = self.algorithm_settings["bead_direction"].GetVector()
-        if len(bead_direction) == 0:
-            self.model_part_controller.ComputeUnitSurfaceNormals()
-            for node in self.design_surface.Nodes:
-                normalized_normal = node.GetSolutionStepValue(KSO.NORMALIZED_SURFACE_NORMAL)
-                node.SetValue(KSO.BEAD_DIRECTION,normalized_normal)
-
-        elif len(bead_direction) == 3:
-            norm = math.sqrt(bead_direction[0]**2 + bead_direction[1]**2 + bead_direction[2]**2)
-            normalized_bead_direction = [value/norm for value in bead_direction]
-            KM.VariableUtils().SetNonHistoricalVectorVar(KSO.BEAD_DIRECTION, normalized_bead_direction, self.design_surface.Nodes)
-        else:
-            raise RuntimeError("Wrong definition of bead direction. Options are: 1) [] -> takes surface normal, 2) [x.x,x.x,x.x] -> takes specified vector.")
-
-    # --------------------------------------------------------------------------
-    def RunOptimizationLoop(self):
-        timer = Timer()
-        timer.StartTimer()
-
-        current_lambda = self.lambda0
-        penalty_scaling = self.penalty_scaling_0
-        penalty_factor = self.penalty_factor_0
-
-        total_iteration = 0
-        is_design_converged = False
-        is_max_total_iterations_reached = False
-        previos_L = None
-
-        for outer_iteration in range(1,self.max_outer_iterations+1):
-            for inner_iteration in range(1,self.max_inner_iterations+1):
-
-                total_iteration += 1
-                timer.StartNewLap()
-
-                KM.Logger.Print("=======================================================================================")
-                KM.Logger.PrintInfo("ShapeOpt", timer.GetTimeStamp(), ": Starting iteration ",outer_iteration,".",inner_iteration,".",total_iteration,"(outer . inner . total)")
-                KM.Logger.Print("=======================================================================================\n")
-
-                # Initialize new shape
-                self.model_part_controller.UpdateTimeStep(total_iteration)
-
-                for node in self.design_surface.Nodes:
-                    new_shape_change = node.GetSolutionStepValue(KSO.ALPHA_MAPPED) * node.GetValue(KSO.BEAD_DIRECTION) * self.bead_height
-                    node.SetSolutionStepValue(KSO.SHAPE_CHANGE, new_shape_change)
-
-                self.model_part_controller.DampNodalUpdateVariableIfSpecified(KSO.SHAPE_CHANGE)
-
-                for node in self.design_surface.Nodes:
-                    shape_update = node.GetSolutionStepValue(KSO.SHAPE_CHANGE,0) - node.GetSolutionStepValue(KSO.SHAPE_CHANGE,1)
-                    node.SetSolutionStepValue(KSO.SHAPE_UPDATE, shape_update)
-
-                self.model_part_controller.UpdateMeshAccordingInputVariable(KSO.SHAPE_UPDATE)
-                self.model_part_controller.SetReferenceMeshToMesh()
-
-                # Analyze shape
-                self.communicator.initializeCommunication()
-                self.communicator.requestValueOf(self.objectives[0]["identifier"].GetString())
-                self.communicator.requestGradientOf(self.objectives[0]["identifier"].GetString())
-
-                self.analyzer.AnalyzeDesignAndReportToCommunicator(self.optimization_model_part, total_iteration, self.communicator)
-
-                objective_value = self.communicator.getStandardizedValue(self.objectives[0]["identifier"].GetString())
-                objGradientDict = self.communicator.getStandardizedGradient(self.objectives[0]["identifier"].GetString())
-                WriteDictionaryDataOnNodalVariable(objGradientDict, self.optimization_model_part, KSO.DF1DX)
-
-                self.model_part_controller.DampNodalSensitivityVariableIfSpecified(KSO.DF1DX)
-
-                # Compute sensitivities w.r.t. scalar design variable alpha
-                for node in self.design_surface.Nodes:
-                    raw_gradient = node.GetSolutionStepValue(KSO.DF1DX)
-                    bead_dir = node.GetValue(KSO.BEAD_DIRECTION)
-
-                    dF1dalpha_i = self.bead_height*(raw_gradient[0]*bead_dir[0] + raw_gradient[1]*bead_dir[1] + raw_gradient[2]*bead_dir[2])
-                    node.SetSolutionStepValue(KSO.DF1DALPHA, dF1dalpha_i)
-
-                # Map gradient of objective
-                self.mapper.InverseMap(KSO.DF1DALPHA, KSO.DF1DALPHA_MAPPED)
-
-                # Compute scaling
-                max_norm_objective_gradient = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.DF1DALPHA_MAPPED)
-
-                if outer_iteration == 1 and inner_iteration == min(3,self.max_inner_iterations):
-                    if self.bead_side == "positive" or self.bead_side == "negative":
-                        max_norm_penalty_gradient = 1.0
-                    elif self.bead_side == "both":
-                        max_norm_penalty_gradient = 2.0
-
-                    penalty_scaling = max_norm_objective_gradient/max_norm_penalty_gradient
-
-                # Compute penalization term
-                penalty_value = 0.0
-                if self.bead_side == "positive":
-                    for node in self.design_surface.Nodes:
-                        if not node.Is(KM.BOUNDARY):
-                            alpha_i = node.GetSolutionStepValue(KSO.ALPHA)
-                            penalty_value += penalty_scaling*(alpha_i-alpha_i**2)
-
-                            penalty_gradient_i = penalty_scaling*(1-2*alpha_i)
-                            node.SetSolutionStepValue(KSO.DPDALPHA, penalty_gradient_i)
-
-                elif self.bead_side == "negative":
-                    for node in self.design_surface.Nodes:
-                        if not node.Is(KM.BOUNDARY):
-                            alpha_i = node.GetSolutionStepValue(KSO.ALPHA)
-                            penalty_value += penalty_scaling*(-alpha_i-alpha_i**2)
-
-                            penalty_gradient_i = penalty_scaling*(-1-2*alpha_i)
-                            node.SetSolutionStepValue(KSO.DPDALPHA, penalty_gradient_i)
-
-                elif self.bead_side == "both":
-                    for node in self.design_surface.Nodes:
-                        if not node.Is(KM.BOUNDARY):
-                            alpha_i = node.GetSolutionStepValue(KSO.ALPHA)
-                            penalty_value += penalty_scaling*(-alpha_i**2+1)
-
-                            penalty_gradient_i = penalty_scaling*(-2*alpha_i)
-                            node.SetSolutionStepValue(KSO.DPDALPHA, penalty_gradient_i)
-
-                # Filter penalty term if specified
-                if self.filter_penalty_term:
-                    self.penalty_filter.InverseMap(KSO.DPDALPHA, KSO.DPDALPHA_MAPPED)
-
-                # Compute value of Lagrange function
-                L = objective_value + current_lambda*penalty_value + 0.5*penalty_factor*penalty_value**2
-                if inner_iteration == 1:
-                    dL_relative = 0.0
-                else:
-                    dL_relative = 100*(L/previos_L-1)
-
-                # Compute gradient of Lagrange function
-                if self.filter_penalty_term:
-                    penalty_gradient_variable = KSO.DPDALPHA_MAPPED
-                else:
-                    penalty_gradient_variable = KSO.DPDALPHA
-                for node in self.design_surface.Nodes:
-                    dLdalpha_i = node.GetSolutionStepValue(KSO.DF1DALPHA_MAPPED) + current_lambda*node.GetSolutionStepValue(penalty_gradient_variable)
-                    node.SetSolutionStepValue(KSO.DLDALPHA, dLdalpha_i)
-
-                # Normalization using infinity norm
-                dLdalpha_for_normalization = {}
-                for node in self.design_surface.Nodes:
-                    nodal_alpha = node.GetSolutionStepValue(KSO.ALPHA)
-                    if nodal_alpha==self.lower_bound or nodal_alpha==self.upper_bound or node.Is(KM.BOUNDARY):
-                        dLdalpha_for_normalization[node.Id] = 0.0
-                    else:
-                        dLdalpha_for_normalization[node.Id] = node.GetSolutionStepValue(KSO.DLDALPHA)**2
-
-                max_value = math.sqrt(max(dLdalpha_for_normalization.values()))
-                if max_value == 0.0:
-                    max_value = 1.0
-
-                # Compute updated design variable
-                for node in self.design_surface.Nodes:
-                    dalpha = -self.step_size*node.GetSolutionStepValue(KSO.DLDALPHA)/max_value
-                    alpha_new = node.GetSolutionStepValue(KSO.ALPHA) + dalpha
-
-                    # Enforce bounds
-                    alpha_new = max(alpha_new, self.lower_bound)
-                    alpha_new = min(alpha_new, self.upper_bound)
-
-                    # Enforce constraints
-                    if node.Is(KM.BOUNDARY):
-                        alpha_new = 0.0
-
-                    node.SetSolutionStepValue(KSO.ALPHA,alpha_new)
-
-                    alpha_new_vectorized = alpha_new * node.GetValue(KSO.BEAD_DIRECTION)
-                    node.SetSolutionStepValue(KSO.CONTROL_POINT_CHANGE,alpha_new_vectorized)
-
-                # Map design variables
-                self.mapper.Map(KSO.ALPHA, KSO.ALPHA_MAPPED)
-
-                # Log current optimization step and store values for next iteration
-                additional_values_to_log = {}
-                additional_values_to_log["step_size"] = self.algorithm_settings["line_search"]["step_size"].GetDouble()
-                additional_values_to_log["outer_iteration"] = outer_iteration
-                additional_values_to_log["inner_iteration"] = inner_iteration
-                additional_values_to_log["lagrange_value"] = L
-                additional_values_to_log["lagrange_value_relative_change"] = dL_relative
-                additional_values_to_log["penalty_value"] = penalty_value
-                additional_values_to_log["penalty_lambda"] = current_lambda
-                additional_values_to_log["penalty_scaling"] = penalty_scaling
-                additional_values_to_log["penalty_factor"] = penalty_factor
-                additional_values_to_log["max_norm_objective_gradient"] = max_norm_objective_gradient
-
-                self.data_logger.LogSensitivityHeatmap(total_iteration, self.mapper)
-                self.data_logger.LogCurrentValues(total_iteration, additional_values_to_log)
-                self.data_logger.LogCurrentDesign(total_iteration)
-
-                previos_L = L
-
-                # Convergence check of inner loop
-                if total_iteration == self.max_total_iterations:
-                    is_max_total_iterations_reached = True
-                    break
-
-                if inner_iteration >= self.min_inner_iterations and inner_iteration >1:
-                    # In the first outer iteration, the constraint is not yet active and properly scaled. Therefore, the objective is used to check the relative improvement
-                    if outer_iteration == 1:
-                        if abs(self.data_logger.GetValues("rel_change_objective")[total_iteration]) < self.inner_iteration_tolerance:
-                            break
-                    else:
-                        if abs(dL_relative) < self.inner_iteration_tolerance:
-                            break
-
-                if penalty_value == 0.0:
-                    is_design_converged = True
-                    break
-
-                KM.Logger.Print("")
-                KM.Logger.PrintInfo("ShapeOpt", "Time needed for current optimization step = ", timer.GetLapTime(), "s")
-                KM.Logger.PrintInfo("ShapeOpt", "Time needed for total optimization so far = ", timer.GetTotalTime(), "s")
-
-            # Compute penalty factor such that estimated Lagrange multiplier is obtained
-            if outer_iteration==1:
-                penalty_factor = self.estimated_lagrange_multiplier/penalty_value
-
-            # Update lambda
-            current_lambda = current_lambda + penalty_factor*penalty_value
-
-            KM.Logger.Print("")
-            KM.Logger.PrintInfo("ShapeOpt", "Time needed for current optimization step = ", timer.GetLapTime(), "s")
-            KM.Logger.PrintInfo("ShapeOpt", "Time needed for total optimization so far = ", timer.GetTotalTime(), "s")
-
-            # Check convergence of outer loop
-            if outer_iteration == self.max_outer_iterations:
-                KM.Logger.Print("")
-                KM.Logger.PrintInfo("ShapeOpt", "Maximal outer iterations of optimization problem reached!")
-                break
-
-            if is_max_total_iterations_reached:
-                KM.Logger.Print("")
-                KM.Logger.PrintInfo("ShapeOpt", "Maximal total iterations of optimization problem reached!")
-                break
-
-            if is_design_converged:
-                KM.Logger.Print("")
-                KM.Logger.PrintInfo("ShapeOpt", "Update of design variables is zero. Optimization converged!")
-                break
-
-    # --------------------------------------------------------------------------
-    def FinalizeOptimizationLoop(self):
-        self.data_logger.FinalizeDataLogging()
-        self.analyzer.FinalizeAfterOptimizationLoop()
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#                   Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+
+# Kratos Core and Apps
+import KratosMultiphysics as KM
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+
+# Additional imports
+from KratosMultiphysics.ShapeOptimizationApplication.algorithms.algorithm_base import OptimizationAlgorithm
+from KratosMultiphysics.ShapeOptimizationApplication import mapper_factory
+from KratosMultiphysics.ShapeOptimizationApplication.loggers import data_logger_factory
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_variable_utilities import WriteDictionaryDataOnNodalVariable
+import math
+
+# ==============================================================================
+class AlgorithmBeadOptimization(OptimizationAlgorithm):
+    # --------------------------------------------------------------------------
+    def __init__(self, optimization_settings, analyzer, communicator, model_part_controller):
+        default_algorithm_settings = KM.Parameters("""
+        {
+            "name"                          : "bead_optimization",
+            "bead_height"                   : 1.0,
+            "bead_direction"                : [],
+            "bead_side"                     : "both",
+            "fix_boundaries"                : [],
+            "estimated_lagrange_multiplier" : 1.0,
+            "max_total_iterations"          : 10000,
+            "max_outer_iterations"          : 10000,
+            "max_inner_iterations"          : 30,
+            "min_inner_iterations"          : 3,
+            "inner_iteration_tolerance"     : 1e-3,
+            "line_search" : {
+                "line_search_type"           : "manual_stepping",
+                "normalize_search_direction" : true,
+                "step_size"                  : 1.0
+            },
+            "filter_penalty_term"           : false,
+            "penalty_filter_radius"         : -1.0
+        }""")
+        self.algorithm_settings =  optimization_settings["optimization_algorithm"]
+        self.algorithm_settings.RecursivelyValidateAndAssignDefaults(default_algorithm_settings)
+
+        self.optimization_settings = optimization_settings
+        self.mapper_settings = optimization_settings["design_variables"]["filter"]
+
+        if self.algorithm_settings["filter_penalty_term"].GetBool():
+            if self.algorithm_settings["penalty_filter_radius"].GetDouble() == -1.0:
+                raise RuntimeError("The parameter `penalty_filter_radius` is missing in order to filter the penalty term!")
+
+        self.analyzer = analyzer
+        self.communicator = communicator
+        self.model_part_controller = model_part_controller
+
+        self.design_surface = None
+        self.mapper = None
+        self.penalty_filter = None
+        self.data_logger = None
+        self.optimization_utilities = None
+
+        self.objectives = optimization_settings["objectives"]
+        self.constraints = optimization_settings["constraints"]
+
+        self.bead_height = self.algorithm_settings["bead_height"].GetDouble()
+        self.bead_side = self.algorithm_settings["bead_side"].GetString()
+        self.filter_penalty_term = self.algorithm_settings["filter_penalty_term"].GetBool()
+        self.estimated_lagrange_multiplier = self.algorithm_settings["estimated_lagrange_multiplier"].GetDouble()
+        self.max_total_iterations = self.algorithm_settings["max_total_iterations"].GetInt()
+        self.max_outer_iterations = self.algorithm_settings["max_outer_iterations"].GetInt()
+        self.max_inner_iterations = self.algorithm_settings["max_inner_iterations"].GetInt()
+        self.min_inner_iterations = self.algorithm_settings["min_inner_iterations"].GetInt()
+        self.inner_iteration_tolerance = self.algorithm_settings["inner_iteration_tolerance"].GetDouble()
+        self.step_size = self.algorithm_settings["line_search"]["step_size"].GetDouble()
+
+        self.lower_bound = None
+        self.upper_bound = None
+
+        self.lambda0 = 0.0
+        self.penalty_scaling_0 = 1.0
+        self.penalty_factor_0 = 1.0
+
+        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.ALPHA)
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.ALPHA_MAPPED)
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.DF1DALPHA)
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.DF1DALPHA_MAPPED)
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.DPDALPHA)
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.DPDALPHA_MAPPED)
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.DLDALPHA)
+
+    # --------------------------------------------------------------------------
+    def CheckApplicability(self):
+        if self.objectives.size() > 1:
+            raise RuntimeError("The augmented lagrange algorithm for bead optimization only supports one objective function!")
+        if self.constraints.size() > 0:
+            raise RuntimeError("The augmented lagrange algorithm for bead does not allow for any constraints!")
+
+    # --------------------------------------------------------------------------
+    def InitializeOptimizationLoop(self):
+        self.model_part_controller.Initialize()
+        self.model_part_controller.SetMinimalBufferSize(2)
+
+        self.analyzer.InitializeBeforeOptimizationLoop()
+
+        self.design_surface = self.model_part_controller.GetDesignSurface()
+
+        self.mapper = mapper_factory.CreateMapper(self.design_surface, self.design_surface, self.mapper_settings)
+        self.mapper.Initialize()
+        self.model_part_controller.InitializeDamping()
+
+        if self.filter_penalty_term:
+            penalty_filter_radius = self.algorithm_settings["penalty_filter_radius"].GetDouble()
+            filter_radius = self.mapper_settings["filter_radius"].GetDouble()
+            if abs(filter_radius - penalty_filter_radius) > 1e-9:
+                penalty_filter_settings = self.mapper_settings.Clone()
+                penalty_filter_settings["filter_radius"].SetDouble(self.algorithm_settings["penalty_filter_radius"].GetDouble())
+                self.penalty_filter = mapper_factory.CreateMapper(self.design_surface, self.design_surface, penalty_filter_settings)
+                self.penalty_filter.Initialize()
+            else:
+                self.penalty_filter = self.mapper
+
+        self.data_logger = data_logger_factory.CreateDataLogger(self.model_part_controller, self.communicator, self.optimization_settings)
+        self.data_logger.InitializeDataLogging()
+
+        self.optimization_utilities = KSO.OptimizationUtilities
+
+        # Identify fixed design areas
+        KM.VariableUtils().SetFlag(KM.BOUNDARY, False, self.optimization_model_part.Nodes)
+
+        radius = self.mapper_settings["filter_radius"].GetDouble()
+        search_based_functions = KSO.SearchBasedFunctions(self.design_surface)
+
+        for itr in range(self.algorithm_settings["fix_boundaries"].size()):
+            sub_model_part_name = self.algorithm_settings["fix_boundaries"][itr].GetString()
+            node_set = self.optimization_model_part.GetSubModelPart(sub_model_part_name).Nodes
+            search_based_functions.FlagNodesInRadius(node_set, KM.BOUNDARY, radius)
+
+        # Specify bounds and assign starting values for ALPHA
+        if self.bead_side == "positive":
+            KM.VariableUtils().SetScalarVar(KSO.ALPHA, 0.5, self.design_surface.Nodes, KM.BOUNDARY, False)
+            self.lower_bound = 0.0
+            self.upper_bound = 1.0
+        elif self.bead_side == "negative":
+            KM.VariableUtils().SetScalarVar(KSO.ALPHA, -0.5, self.design_surface.Nodes, KM.BOUNDARY, False)
+            self.lower_bound = -1.0
+            self.upper_bound = 0.0
+        elif self.bead_side == "both":
+            KM.VariableUtils().SetScalarVar(KSO.ALPHA, 0.0, self.design_surface.Nodes, KM.BOUNDARY, False)
+            self.lower_bound = -1.0
+            self.upper_bound = 1.0
+        else:
+            raise RuntimeError("Specified bead direction mode not supported!")
+
+        # Initialize ALPHA_MAPPED according to initial ALPHA values
+        self.mapper.Map(KSO.ALPHA, KSO.ALPHA_MAPPED)
+
+        # Specify bead direction
+        bead_direction = self.algorithm_settings["bead_direction"].GetVector()
+        if len(bead_direction) == 0:
+            self.model_part_controller.ComputeUnitSurfaceNormals()
+            for node in self.design_surface.Nodes:
+                normalized_normal = node.GetSolutionStepValue(KSO.NORMALIZED_SURFACE_NORMAL)
+                node.SetValue(KSO.BEAD_DIRECTION,normalized_normal)
+
+        elif len(bead_direction) == 3:
+            norm = math.sqrt(bead_direction[0]**2 + bead_direction[1]**2 + bead_direction[2]**2)
+            normalized_bead_direction = [value/norm for value in bead_direction]
+            KM.VariableUtils().SetNonHistoricalVectorVar(KSO.BEAD_DIRECTION, normalized_bead_direction, self.design_surface.Nodes)
+        else:
+            raise RuntimeError("Wrong definition of bead direction. Options are: 1) [] -> takes surface normal, 2) [x.x,x.x,x.x] -> takes specified vector.")
+
+    # --------------------------------------------------------------------------
+    def RunOptimizationLoop(self):
+        timer = Timer()
+        timer.StartTimer()
+
+        current_lambda = self.lambda0
+        penalty_scaling = self.penalty_scaling_0
+        penalty_factor = self.penalty_factor_0
+
+        total_iteration = 0
+        is_design_converged = False
+        is_max_total_iterations_reached = False
+        previos_L = None
+
+        for outer_iteration in range(1,self.max_outer_iterations+1):
+            for inner_iteration in range(1,self.max_inner_iterations+1):
+
+                total_iteration += 1
+                timer.StartNewLap()
+
+                KM.Logger.Print("=======================================================================================")
+                KM.Logger.PrintInfo("ShapeOpt", timer.GetTimeStamp(), ": Starting iteration ",outer_iteration,".",inner_iteration,".",total_iteration,"(outer . inner . total)")
+                KM.Logger.Print("=======================================================================================\n")
+
+                # Initialize new shape
+                self.model_part_controller.UpdateTimeStep(total_iteration)
+
+                for node in self.design_surface.Nodes:
+                    new_shape_change = node.GetSolutionStepValue(KSO.ALPHA_MAPPED) * node.GetValue(KSO.BEAD_DIRECTION) * self.bead_height
+                    node.SetSolutionStepValue(KSO.SHAPE_CHANGE, new_shape_change)
+
+                self.model_part_controller.DampNodalUpdateVariableIfSpecified(KSO.SHAPE_CHANGE)
+
+                for node in self.design_surface.Nodes:
+                    shape_update = node.GetSolutionStepValue(KSO.SHAPE_CHANGE,0) - node.GetSolutionStepValue(KSO.SHAPE_CHANGE,1)
+                    node.SetSolutionStepValue(KSO.SHAPE_UPDATE, shape_update)
+
+                self.model_part_controller.UpdateMeshAccordingInputVariable(KSO.SHAPE_UPDATE)
+                self.model_part_controller.SetReferenceMeshToMesh()
+
+                # Analyze shape
+                self.communicator.initializeCommunication()
+                self.communicator.requestValueOf(self.objectives[0]["identifier"].GetString())
+                self.communicator.requestGradientOf(self.objectives[0]["identifier"].GetString())
+
+                self.analyzer.AnalyzeDesignAndReportToCommunicator(self.optimization_model_part, total_iteration, self.communicator)
+
+                objective_value = self.communicator.getStandardizedValue(self.objectives[0]["identifier"].GetString())
+                objGradientDict = self.communicator.getStandardizedGradient(self.objectives[0]["identifier"].GetString())
+                WriteDictionaryDataOnNodalVariable(objGradientDict, self.optimization_model_part, KSO.DF1DX)
+
+                self.model_part_controller.DampNodalSensitivityVariableIfSpecified(KSO.DF1DX)
+
+                # Compute sensitivities w.r.t. scalar design variable alpha
+                for node in self.design_surface.Nodes:
+                    raw_gradient = node.GetSolutionStepValue(KSO.DF1DX)
+                    bead_dir = node.GetValue(KSO.BEAD_DIRECTION)
+
+                    dF1dalpha_i = self.bead_height*(raw_gradient[0]*bead_dir[0] + raw_gradient[1]*bead_dir[1] + raw_gradient[2]*bead_dir[2])
+                    node.SetSolutionStepValue(KSO.DF1DALPHA, dF1dalpha_i)
+
+                # Map gradient of objective
+                self.mapper.InverseMap(KSO.DF1DALPHA, KSO.DF1DALPHA_MAPPED)
+
+                # Compute scaling
+                max_norm_objective_gradient = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.DF1DALPHA_MAPPED)
+
+                if outer_iteration == 1 and inner_iteration == min(3,self.max_inner_iterations):
+                    if self.bead_side == "positive" or self.bead_side == "negative":
+                        max_norm_penalty_gradient = 1.0
+                    elif self.bead_side == "both":
+                        max_norm_penalty_gradient = 2.0
+
+                    penalty_scaling = max_norm_objective_gradient/max_norm_penalty_gradient
+
+                # Compute penalization term
+                penalty_value = 0.0
+                if self.bead_side == "positive":
+                    for node in self.design_surface.Nodes:
+                        if not node.Is(KM.BOUNDARY):
+                            alpha_i = node.GetSolutionStepValue(KSO.ALPHA)
+                            penalty_value += penalty_scaling*(alpha_i-alpha_i**2)
+
+                            penalty_gradient_i = penalty_scaling*(1-2*alpha_i)
+                            node.SetSolutionStepValue(KSO.DPDALPHA, penalty_gradient_i)
+
+                elif self.bead_side == "negative":
+                    for node in self.design_surface.Nodes:
+                        if not node.Is(KM.BOUNDARY):
+                            alpha_i = node.GetSolutionStepValue(KSO.ALPHA)
+                            penalty_value += penalty_scaling*(-alpha_i-alpha_i**2)
+
+                            penalty_gradient_i = penalty_scaling*(-1-2*alpha_i)
+                            node.SetSolutionStepValue(KSO.DPDALPHA, penalty_gradient_i)
+
+                elif self.bead_side == "both":
+                    for node in self.design_surface.Nodes:
+                        if not node.Is(KM.BOUNDARY):
+                            alpha_i = node.GetSolutionStepValue(KSO.ALPHA)
+                            penalty_value += penalty_scaling*(-alpha_i**2+1)
+
+                            penalty_gradient_i = penalty_scaling*(-2*alpha_i)
+                            node.SetSolutionStepValue(KSO.DPDALPHA, penalty_gradient_i)
+
+                # Filter penalty term if specified
+                if self.filter_penalty_term:
+                    self.penalty_filter.InverseMap(KSO.DPDALPHA, KSO.DPDALPHA_MAPPED)
+
+                # Compute value of Lagrange function
+                L = objective_value + current_lambda*penalty_value + 0.5*penalty_factor*penalty_value**2
+                if inner_iteration == 1:
+                    dL_relative = 0.0
+                else:
+                    dL_relative = 100*(L/previos_L-1)
+
+                # Compute gradient of Lagrange function
+                if self.filter_penalty_term:
+                    penalty_gradient_variable = KSO.DPDALPHA_MAPPED
+                else:
+                    penalty_gradient_variable = KSO.DPDALPHA
+                for node in self.design_surface.Nodes:
+                    dLdalpha_i = node.GetSolutionStepValue(KSO.DF1DALPHA_MAPPED) + current_lambda*node.GetSolutionStepValue(penalty_gradient_variable)
+                    node.SetSolutionStepValue(KSO.DLDALPHA, dLdalpha_i)
+
+                # Normalization using infinity norm
+                dLdalpha_for_normalization = {}
+                for node in self.design_surface.Nodes:
+                    nodal_alpha = node.GetSolutionStepValue(KSO.ALPHA)
+                    if nodal_alpha==self.lower_bound or nodal_alpha==self.upper_bound or node.Is(KM.BOUNDARY):
+                        dLdalpha_for_normalization[node.Id] = 0.0
+                    else:
+                        dLdalpha_for_normalization[node.Id] = node.GetSolutionStepValue(KSO.DLDALPHA)**2
+
+                max_value = math.sqrt(max(dLdalpha_for_normalization.values()))
+                if max_value == 0.0:
+                    max_value = 1.0
+
+                # Compute updated design variable
+                for node in self.design_surface.Nodes:
+                    dalpha = -self.step_size*node.GetSolutionStepValue(KSO.DLDALPHA)/max_value
+                    alpha_new = node.GetSolutionStepValue(KSO.ALPHA) + dalpha
+
+                    # Enforce bounds
+                    alpha_new = max(alpha_new, self.lower_bound)
+                    alpha_new = min(alpha_new, self.upper_bound)
+
+                    # Enforce constraints
+                    if node.Is(KM.BOUNDARY):
+                        alpha_new = 0.0
+
+                    node.SetSolutionStepValue(KSO.ALPHA,alpha_new)
+
+                    alpha_new_vectorized = alpha_new * node.GetValue(KSO.BEAD_DIRECTION)
+                    node.SetSolutionStepValue(KSO.CONTROL_POINT_CHANGE,alpha_new_vectorized)
+
+                # Map design variables
+                self.mapper.Map(KSO.ALPHA, KSO.ALPHA_MAPPED)
+
+                # Log current optimization step and store values for next iteration
+                additional_values_to_log = {}
+                additional_values_to_log["step_size"] = self.algorithm_settings["line_search"]["step_size"].GetDouble()
+                additional_values_to_log["outer_iteration"] = outer_iteration
+                additional_values_to_log["inner_iteration"] = inner_iteration
+                additional_values_to_log["lagrange_value"] = L
+                additional_values_to_log["lagrange_value_relative_change"] = dL_relative
+                additional_values_to_log["penalty_value"] = penalty_value
+                additional_values_to_log["penalty_lambda"] = current_lambda
+                additional_values_to_log["penalty_scaling"] = penalty_scaling
+                additional_values_to_log["penalty_factor"] = penalty_factor
+                additional_values_to_log["max_norm_objective_gradient"] = max_norm_objective_gradient
+
+                self.data_logger.LogSensitivityHeatmap(total_iteration, self.mapper)
+                self.data_logger.LogCurrentValues(total_iteration, additional_values_to_log)
+                self.data_logger.LogCurrentDesign(total_iteration)
+
+                previos_L = L
+
+                # Convergence check of inner loop
+                if total_iteration == self.max_total_iterations:
+                    is_max_total_iterations_reached = True
+                    break
+
+                if inner_iteration >= self.min_inner_iterations and inner_iteration >1:
+                    # In the first outer iteration, the constraint is not yet active and properly scaled. Therefore, the objective is used to check the relative improvement
+                    if outer_iteration == 1:
+                        if abs(self.data_logger.GetValues("rel_change_objective")[total_iteration]) < self.inner_iteration_tolerance:
+                            break
+                    else:
+                        if abs(dL_relative) < self.inner_iteration_tolerance:
+                            break
+
+                if penalty_value == 0.0:
+                    is_design_converged = True
+                    break
+
+                KM.Logger.Print("")
+                KM.Logger.PrintInfo("ShapeOpt", "Time needed for current optimization step = ", timer.GetLapTime(), "s")
+                KM.Logger.PrintInfo("ShapeOpt", "Time needed for total optimization so far = ", timer.GetTotalTime(), "s")
+
+            # Compute penalty factor such that estimated Lagrange multiplier is obtained
+            if outer_iteration==1:
+                penalty_factor = self.estimated_lagrange_multiplier/penalty_value
+
+            # Update lambda
+            current_lambda = current_lambda + penalty_factor*penalty_value
+
+            KM.Logger.Print("")
+            KM.Logger.PrintInfo("ShapeOpt", "Time needed for current optimization step = ", timer.GetLapTime(), "s")
+            KM.Logger.PrintInfo("ShapeOpt", "Time needed for total optimization so far = ", timer.GetTotalTime(), "s")
+
+            # Check convergence of outer loop
+            if outer_iteration == self.max_outer_iterations:
+                KM.Logger.Print("")
+                KM.Logger.PrintInfo("ShapeOpt", "Maximal outer iterations of optimization problem reached!")
+                break
+
+            if is_max_total_iterations_reached:
+                KM.Logger.Print("")
+                KM.Logger.PrintInfo("ShapeOpt", "Maximal total iterations of optimization problem reached!")
+                break
+
+            if is_design_converged:
+                KM.Logger.Print("")
+                KM.Logger.PrintInfo("ShapeOpt", "Update of design variables is zero. Optimization converged!")
+                break
+
+    # --------------------------------------------------------------------------
+    def FinalizeOptimizationLoop(self):
+        self.data_logger.FinalizeDataLogging()
+        self.analyzer.FinalizeAfterOptimizationLoop()
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_relaxed_gradient_projection.py

 * *Ordering differences only*

```diff
@@ -1,580 +1,580 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Ihar Antonau
-#
-# ==============================================================================
-
-# Making KratosMultiphysics backward compatible with python 2.6 and 2.7
-from __future__ import print_function, absolute_import, division
-
-# Kratos Core and Apps
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-from KratosMultiphysics.LinearSolversApplication import dense_linear_solver_factory
-
-# Additional imports
-from .algorithm_base import OptimizationAlgorithm
-from .. import mapper_factory
-from KratosMultiphysics.ShapeOptimizationApplication.loggers import data_logger_factory
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_variable_utilities import WriteDictionaryDataOnNodalVariable
-import numpy as np
-
-
-# ==============================================================================
-class AlgorithmRelaxedGradientProjection(OptimizationAlgorithm):
-    # --------------------------------------------------------------------------
-    def __init__(self, optimization_settings, analyzer, communicator, model_part_controller):
-        default_algorithm_settings = Kratos.Parameters("""
-        {
-            "name"                    : "relaxed_gradient_projection",
-            "max_iterations"          : 100,
-            "max_inner_iter"          : 100,
-            "relative_tolerance"      : 1e-3,
-            "line_search" : {
-                "line_search_type"           : "manual_stepping",
-                "step_size"                  : 1.0
-            }
-        }""")
-        self.algorithm_settings =  optimization_settings["optimization_algorithm"]
-        self.algorithm_settings.RecursivelyValidateAndAssignDefaults(default_algorithm_settings)
-
-        self.optimization_settings = optimization_settings
-        self.mapper_settings = optimization_settings["design_variables"]["filter"]
-
-        self.analyzer = analyzer
-        self.communicator = communicator
-        self.model_part_controller = model_part_controller
-
-        self.design_surface = None
-        self.mapper = None
-        self.data_logger = None
-        self.optimization_utilities = None
-
-        self.objectives = optimization_settings["objectives"]
-        self.constraints = optimization_settings["constraints"]
-        self.constraint_gradient_variables = {}
-        self.constraint_buffer_variables = {}
-        self.constraint_laplace_multipliers = {}
-        for itr, constraint in enumerate(self.constraints.values()):
-            constraint_id = constraint["identifier"].GetString()
-            self.constraint_gradient_variables.update({
-                constraint_id : {
-                    "gradient": Kratos.KratosGlobals.GetVariable("DC"+str(itr+1)+"DX"),
-                    "mapped_gradient": Kratos.KratosGlobals.GetVariable("DC"+str(itr+1)+"DX_MAPPED")
-                }
-            })
-            self.constraint_buffer_variables.update({
-                constraint_id : {
-                    "buffer_value": 0.0,
-                    "buffer_value-1": 0.0,
-                    "buffer_size": 1e-12,
-                    "buffer_size_factor": 2.0,
-                    "central_buffer_value": 0.0,
-                    "lower_buffer_value": - 1e-12,
-                    "upper_buffer_value": 1e-12,
-                    "g_i-1": 0.0,
-                    "g_i-2": 0.0,
-                    "g_i-3": 0.0,
-                    "max_constraint_change": 0.0
-                }
-            })
-
-
-        self.step_size = self.algorithm_settings["line_search"]["step_size"].GetDouble()
-        self.line_search_type = self.algorithm_settings["line_search"]["line_search_type"].GetString()
-        self.max_iterations = self.algorithm_settings["max_iterations"].GetInt() + 1
-        self.relative_tolerance = self.algorithm_settings["relative_tolerance"].GetDouble()
-        self.s_norm = 0.0
-
-        self.max_inner_iter = self.algorithm_settings["max_inner_iter"].GetDouble()
-        self.buffer_coeff_update = 2.0 / self.max_inner_iter
-
-        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.INV_HESSIAN)
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.PROJECTION)
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.CORRECTION)
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.SEARCH_DIRECTION)
-
-
-    # --------------------------------------------------------------------------
-    def CheckApplicability(self):
-        if self.objectives.size() > 1:
-            raise RuntimeError("Gradient projection algorithm only supports one objective function!")
-        if self.constraints.size() == 0:
-            raise RuntimeError("Gradient projection algorithm requires definition of at least one constraint!")
-
-    # --------------------------------------------------------------------------
-    def InitializeOptimizationLoop(self):
-        self.model_part_controller.Initialize()
-
-        self.analyzer.InitializeBeforeOptimizationLoop()
-
-        self.design_surface = self.model_part_controller.GetDesignSurface()
-
-        self.mapper = mapper_factory.CreateMapper(self.design_surface, self.design_surface, self.mapper_settings)
-        self.mapper.Initialize()
-        self.model_part_controller.InitializeDamping()
-
-        self.data_logger = data_logger_factory.CreateDataLogger(self.model_part_controller, self.communicator, self.optimization_settings)
-        self.data_logger.InitializeDataLogging()
-
-        self.optimization_utilities = KSO.OptimizationUtilities
-
-    # --------------------------------------------------------------------------
-    def RunOptimizationLoop(self):
-        timer = Timer()
-        timer.StartTimer()
-
-        for self.optimization_iteration in range(1,self.max_iterations):
-            Kratos.Logger.Print("")
-            Kratos.Logger.Print("===============================================================================")
-            Kratos.Logger.PrintInfo("ShapeOpt", timer.GetTimeStamp(), ": Starting optimization iteration ", self.optimization_iteration)
-            Kratos.Logger.Print("===============================================================================\n")
-
-            timer.StartNewLap()
-
-            self.__initializeNewShape()
-
-            self.__analyzeShape()
-
-            self.__computeBufferValue()
-
-            self.__computeShapeUpdate()
-
-            self.__logCurrentOptimizationStep()
-
-            self.__updateBufferZone()
-
-            Kratos.Logger.Print("")
-            Kratos.Logger.PrintInfo("ShapeOpt", "Time needed for current optimization step = ", timer.GetLapTime(), "s")
-            Kratos.Logger.PrintInfo("ShapeOpt", "Time needed for total optimization so far = ", timer.GetTotalTime(), "s")
-
-            if self.__isAlgorithmConverged():
-                break
-            else:
-                self.__determineAbsoluteChanges()
-
-    # --------------------------------------------------------------------------
-    def FinalizeOptimizationLoop(self):
-        self.data_logger.FinalizeDataLogging()
-        self.analyzer.FinalizeAfterOptimizationLoop()
-
-    # --------------------------------------------------------------------------
-    def __initializeNewShape(self):
-        self.model_part_controller.UpdateTimeStep(self.optimization_iteration)
-        self.model_part_controller.UpdateMeshAccordingInputVariable(KSO.SHAPE_UPDATE)
-        self.model_part_controller.SetReferenceMeshToMesh()
-
-    # --------------------------------------------------------------------------
-    def __analyzeShape(self):
-        self.communicator.initializeCommunication()
-        self.communicator.requestValueOf(self.objectives[0]["identifier"].GetString())
-        self.communicator.requestGradientOf(self.objectives[0]["identifier"].GetString())
-
-        for constraint in self.constraints.values():
-            con_id =  constraint["identifier"].GetString()
-            self.communicator.requestValueOf(con_id)
-            self.communicator.requestGradientOf(con_id)
-
-        self.analyzer.AnalyzeDesignAndReportToCommunicator(self.optimization_model_part, self.optimization_iteration, self.communicator)
-
-        # compute normals only if required
-        surface_normals_required = self.objectives[0]["project_gradient_on_surface_normals"].GetBool()
-        for constraint in self.constraints.values():
-            if constraint["project_gradient_on_surface_normals"].GetBool():
-                surface_normals_required = True
-
-        if surface_normals_required:
-            self.model_part_controller.ComputeUnitSurfaceNormals()
-
-        # project and damp objective gradients
-        objGradientDict = self.communicator.getStandardizedGradient(self.objectives[0]["identifier"].GetString())
-        WriteDictionaryDataOnNodalVariable(objGradientDict, self.optimization_model_part, KSO.DF1DX)
-
-        if self.objectives[0]["project_gradient_on_surface_normals"].GetBool():
-            self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(KSO.DF1DX)
-
-        self.model_part_controller.DampNodalSensitivityVariableIfSpecified(KSO.DF1DX)
-
-        # project and damp constraint gradients
-        for constraint in self.constraints.values():
-            con_id = constraint["identifier"].GetString()
-            conGradientDict = self.communicator.getStandardizedGradient(con_id)
-            gradient_variable = self.constraint_gradient_variables[con_id]["gradient"]
-            WriteDictionaryDataOnNodalVariable(conGradientDict, self.optimization_model_part, gradient_variable)
-
-            if constraint["project_gradient_on_surface_normals"].GetBool():
-                self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(gradient_variable)
-
-            self.model_part_controller.DampNodalSensitivityVariableIfSpecified(gradient_variable)
-
-    # --------------------------------------------------------------------------
-    def __computeBufferValue(self):
-        # compute new buffer size and buffer values
-    	for constraint in self.constraints.values():
-            identifier = constraint["identifier"].GetString()
-            g_i = self.communicator.getStandardizedValue(identifier)
-            g_i_m1 = self.constraint_buffer_variables[identifier]["g_i-1"]
-            buffer_size_factor = self.constraint_buffer_variables[identifier]["buffer_size_factor"]
-
-
-            self.constraint_buffer_variables[identifier]["buffer_value-1"] = self.constraint_buffer_variables[identifier]["buffer_value"]
-
-            if self.optimization_iteration > 1:
-
-                if abs(g_i - g_i_m1) > self.constraint_buffer_variables[identifier]["max_constraint_change"]:
-                    self.constraint_buffer_variables[identifier]["max_constraint_change"] = abs(g_i - g_i_m1)
-
-                max_constraint_change = self.constraint_buffer_variables[identifier]["max_constraint_change"]
-                self.constraint_buffer_variables[identifier]["buffer_size"] = max(buffer_size_factor * max_constraint_change, 1e-12)
-
-            buffer_size = self.constraint_buffer_variables[identifier]["buffer_size"]
-            self.constraint_buffer_variables[identifier]["lower_buffer_value"] = self.constraint_buffer_variables[identifier]["central_buffer_value"] \
-                - buffer_size
-            self.constraint_buffer_variables[identifier]["upper_buffer_value"] = self.constraint_buffer_variables[identifier]["central_buffer_value"] \
-                + buffer_size
-
-            if self.__isConstraintActive(constraint):
-                if constraint["type"].GetString() == "=":
-                    self.constraint_buffer_variables[identifier]["buffer_value"] = min(1 - abs(g_i) / buffer_size, 2.0)
-                else:
-                    lower_buffer_value = self.constraint_buffer_variables[identifier]["lower_buffer_value"]
-                    self.constraint_buffer_variables[identifier]["buffer_value"] = min( (g_i - lower_buffer_value) / buffer_size, 2.0 )
-            else:
-                self.constraint_buffer_variables[identifier]["buffer_value"] = 0.0
-
-    # --------------------------------------------------------------------------
-    def __computeShapeUpdate(self):
-        self.mapper.Update()
-        self.mapper.InverseMap(KSO.DF1DX, KSO.DF1DX_MAPPED)
-
-        for constraint in self.constraints.values():
-            con_id = constraint["identifier"].GetString()
-            gradient_variable = self.constraint_gradient_variables[con_id]["gradient"]
-            mapped_gradient_variable = self.constraint_gradient_variables[con_id]["mapped_gradient"]
-            self.mapper.InverseMap(gradient_variable, mapped_gradient_variable)
-
-        self.inner_iter = 1
-
-        while not self.__checkInnerConvergence():
-
-            self.direction_has_changed = False
-
-            Kratos.Logger.PrintInfo("ShapeOpt", "Inner Iteration to Find Shape Update = ", self.inner_iter)
-
-            self.__computeControlPointUpdate()
-
-            self.mapper.Map(KSO.CONTROL_POINT_UPDATE, KSO.SHAPE_UPDATE)
-            self.model_part_controller.DampNodalUpdateVariableIfSpecified(KSO.SHAPE_UPDATE)
-
-            self.d_norm = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.SHAPE_UPDATE)
-
-            self.__checkConstraintValue()
-            self.inner_iter += 1
-        self.__saveLineSearchData()
-
-
-    # --------------------------------------------------------------------------
-
-    def __checkInnerConvergence(self):
-        Kratos.Logger.PrintInfo("Check Convergence of the inner loop:")
-        if self.inner_iter == 1:
-            return False
-        elif self.direction_has_changed and self.inner_iter <= self.max_inner_iter:
-            return False
-        else:
-            return True
-
-    def __checkConstraintValue(self):
-        index = -1
-        for constraint in self.constraints.values():
-            if self.__isConstraintActive(constraint):
-                index += 1
-                identifier = constraint["identifier"].GetString()
-                g_i = self.communicator.getStandardizedValue(identifier)
-                g_a_variable = self.constraint_gradient_variables[identifier]["gradient"]
-                shape_update = Kratos.Vector()
-                gradient = Kratos.Vector()
-                self.optimization_utilities.AssembleVector(self.design_surface, gradient, g_a_variable)
-                self.optimization_utilities.AssembleVector(self.design_surface, shape_update, KSO.SHAPE_UPDATE)
-                new_g_i = g_i + np.dot(gradient, shape_update)
-                Kratos.Logger.PrintInfo("Constraint ", identifier, "\n Linearized new value = ", new_g_i)
-                if new_g_i > 0.0:
-                    if self.relaxation_coefficients[index] < 1.0:
-                        self.relaxation_coefficients[index] = min(self.relaxation_coefficients[index] + self.buffer_coeff_update, 1.0)
-                        self.direction_has_changed = True
-                    elif self.correction_coefficients[index] < 2.0:
-                        self.correction_coefficients[index] = min (self.correction_coefficients[index] + self.buffer_coeff_update, 2.0)
-                        self.direction_has_changed = True
-                Kratos.Logger.PrintInfo("Constraint ", identifier, "\n W_R, W_C = ", self.relaxation_coefficients[index], self.correction_coefficients[index])
-
-    # --------------------------------------------------------------------------
-    def __LineSearch(self):
-        Kratos.Logger.PrintInfo("Line Search ...")
-        if self.line_search_type == "manual_stepping":
-            self.__manualStep()
-        elif self.line_search_type == "QNBB_method":
-            if self.optimization_iteration == 1:
-                self.max_step_size = self.step_size
-                # Do initial small step
-                self.step_size /= 5
-                self.__manualStep()
-            else:
-                self.__QNBBStep()
-        elif self.line_search_type == "BB_method":
-            if self.optimization_iteration == 1:
-                self.max_step_size = self.step_size
-                # Do initial small step
-                self.step_size /= 5
-                self.__manualStep()
-            else:
-                self.__BBStep()
-
-
-    def __manualStep(self):
-        step_norm = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.CONTROL_POINT_UPDATE)
-        if abs(step_norm) > 1e-10:
-            step = Kratos.Vector()
-            self.optimization_utilities.AssembleVector(self.design_surface, step, KSO.CONTROL_POINT_UPDATE)
-            step *= 1.0 / step_norm
-            self.optimization_utilities.AssignVectorToVariable(self.design_surface, step, KSO.SEARCH_DIRECTION)
-            step *= self.step_size
-            self.optimization_utilities.AssignVectorToVariable(self.design_surface, step, KSO.CONTROL_POINT_UPDATE)
-
-    def __QNBBStep(self):
-        self.s_norm = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.SEARCH_DIRECTION)
-        if abs(self.s_norm) > 1e-10:
-            s = Kratos.Vector()
-            self.optimization_utilities.AssembleVector(self.design_surface, s, KSO.SEARCH_DIRECTION)
-            s /= self.s_norm
-            self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.SEARCH_DIRECTION)
-
-            for index, node in enumerate(self.design_surface.Nodes):
-                i = index * 3
-                y_i = np.array(self.prev_s[i: i+3]) - np.array(s[i: i+3])
-                d_i = np.array(self.d[i:i+3])
-                if np.dot(y_i, y_i) < 1e-9:
-                    step_i = self.max_step_size
-                else:
-                    step_i = abs(np.dot(d_i, y_i) / np.dot(y_i, y_i))
-                if step_i > self.max_step_size:
-                    step_i = self.max_step_size
-                node.SetSolutionStepValue(KSO.INV_HESSIAN, step_i)
-                s[i] = s[i] * step_i
-                s[i+1] = s[i+1] * step_i
-                s[i+2] = s[i+2] * step_i
-            self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.CONTROL_POINT_UPDATE)
-
-    def __BBStep(self):
-        self.s_norm = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.SEARCH_DIRECTION)
-        if abs(self.s_norm) > 1e-10:
-            s = Kratos.Vector()
-            self.optimization_utilities.AssembleVector(self.design_surface, s, KSO.SEARCH_DIRECTION)
-            s /= self.s_norm
-            self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.SEARCH_DIRECTION)
-            y = self.prev_s - s
-            if np.dot(y, y) < 1e-9:
-                step = self.max_step_size
-            else:
-                step = abs(np.dot(y, self.d) / np.dot(y, y))
-            if step > self.max_step_size:
-                step = self.max_step_size
-            s = s * step
-            self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.CONTROL_POINT_UPDATE)
-
-    def __saveLineSearchData(self):
-        self.prev_s = Kratos.Vector()
-        self.d = Kratos.Vector()
-        self.optimization_utilities.AssembleVector(self.design_surface, self.d, KSO.CONTROL_POINT_UPDATE)
-        self.optimization_utilities.AssembleVector(self.design_surface, self.prev_s, KSO.SEARCH_DIRECTION)
-
-    # --------------------------------------------------------------------------
-    def __computeControlPointUpdate(self):
-        """adapted from https://msulaiman.org/onewebmedia/GradProj_2.pdf"""
-        if self.inner_iter == 1:
-            self.g_a, self.g_a_variables, self.relaxation_coefficients, self.correction_coefficients = self.__getActiveConstraints()
-
-        Kratos.Logger.PrintInfo("ShapeOpt", "Assemble vector of objective gradient.")
-        nabla_f = Kratos.Vector()
-        p = Kratos.Vector()
-        self.optimization_utilities.AssembleVector(self.design_surface, nabla_f, KSO.DF1DX_MAPPED)
-        f_norm = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.DF1DX_MAPPED)
-
-        if abs(f_norm) > 1e-10:
-            nabla_f *= 1.0/f_norm
-
-        if len(self.g_a) == 0:
-            Kratos.Logger.PrintInfo("ShapeOpt", "No constraints active, use negative objective gradient as search direction.")
-            p = nabla_f * (-1.0)
-            self.optimization_utilities.AssignVectorToVariable(self.design_surface, p, KSO.SEARCH_DIRECTION)
-            self.optimization_utilities.AssignVectorToVariable(self.design_surface, p, KSO.PROJECTION)
-            Kratos.VariableUtils().SetHistoricalVariableToZero(KSO.CORRECTION, self.design_surface.Nodes)
-            self.optimization_utilities.AssignVectorToVariable(self.design_surface, p, KSO.CONTROL_POINT_UPDATE)
-            self.__LineSearch()
-            return
-
-        omega_r = Kratos.Matrix()
-        self.optimization_utilities.AssembleBufferMatrix(omega_r, self.relaxation_coefficients)
-        omega_c = Kratos.Vector(self.correction_coefficients)
-
-        Kratos.Logger.PrintInfo("ShapeOpt", "Assemble matrix of constraint gradient.")
-        N = Kratos.Matrix()
-        self.optimization_utilities.AssembleMatrix(self.design_surface, N, self.g_a_variables)
-
-        settings = Kratos.Parameters('{ "solver_type" : "LinearSolversApplication.dense_col_piv_householder_qr" }')
-        solver = dense_linear_solver_factory.ConstructSolver(settings)
-
-        c = Kratos.Vector()
-
-        Kratos.Logger.PrintInfo("ShapeOpt", "Calculate projected search direction and correction.")
-        self.optimization_utilities.CalculateRelaxedProjectedSearchDirectionAndCorrection(
-            nabla_f,
-            N,
-            omega_r,
-            omega_c,
-            solver,
-            p,
-            c)
-
-        # additional normalization step
-
-        self.optimization_utilities.AssignVectorToVariable(self.design_surface, p, KSO.PROJECTION)
-        self.optimization_utilities.AssignVectorToVariable(self.design_surface, c, KSO.CORRECTION)
-        self.optimization_utilities.AssignVectorToVariable(self.design_surface, p+c, KSO.SEARCH_DIRECTION)
-        self.optimization_utilities.AssignVectorToVariable(self.design_surface, p+c, KSO.CONTROL_POINT_UPDATE)
-        self.__LineSearch()
-
-
-
-    # --------------------------------------------------------------------------
-    def __getActiveConstraints(self):
-        active_constraint_values = []
-        active_constraint_variables = []
-        active_relaxation_coefficient = []
-        active_correction_coefficient = []
-
-        for constraint in self.constraints.values():
-            if self.__isConstraintActive(constraint):
-                identifier = constraint["identifier"].GetString()
-                g_i = self.communicator.getStandardizedValue(identifier)
-                buffer_value = self.constraint_buffer_variables[identifier]["buffer_value"]
-
-                active_constraint_values.append(g_i)
-                g_a_variable = self.constraint_gradient_variables[identifier]["mapped_gradient"]
-                g_a_norm = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, g_a_variable)
-                g_a_variable_vector = Kratos.Vector()
-                self.optimization_utilities.AssembleVector(self.design_surface, g_a_variable_vector, g_a_variable)
-                if abs(g_a_norm) > 1e-10:
-                    g_a_variable_vector /= g_a_norm
-
-                self.optimization_utilities.AssignVectorToVariable(self.design_surface, g_a_variable_vector, g_a_variable)
-
-                active_constraint_variables.append(g_a_variable)
-                active_relaxation_coefficient.append(min(buffer_value,1.0))
-
-                max_buffer = 2.0
-                if buffer_value > 1.0:
-                    if buffer_value < max_buffer:
-                        active_correction_coefficient.append(2*(buffer_value - 1))
-                    else:
-                        active_correction_coefficient.append(2*(max_buffer-1))
-                else:
-                    active_correction_coefficient.append(0.0)
-
-
-        return active_constraint_values, active_constraint_variables, active_relaxation_coefficient, active_correction_coefficient
-
-    # --------------------------------------------------------------------------
-    def __isConstraintActive(self, constraint):
-        identifier = constraint["identifier"].GetString()
-        g_i = self.communicator.getStandardizedValue(identifier)
-        if constraint["type"].GetString() == "=":
-            return True
-        elif g_i >= self.constraint_buffer_variables[identifier]["lower_buffer_value"]:
-            return True
-        else:
-            return False
-    # --------------------------------------------------------------------------
-    def __updateBufferZone(self):
-        # adapt the buffer zones for zig-zagging, too much or too little correction
-        for constraint in self.constraints.values():
-
-            identifier = constraint["identifier"].GetString()
-            g_i = self.communicator.getStandardizedValue(identifier)
-            g_i_m1 = self.constraint_buffer_variables[identifier]["g_i-1"]
-            g_i_m2 = self.constraint_buffer_variables[identifier]["g_i-2"]
-            g_i_m3 = self.constraint_buffer_variables[identifier]["g_i-3"]
-
-            buffer_value = self.constraint_buffer_variables[identifier]["buffer_value"]
-            buffer_value_m1 = self.constraint_buffer_variables[identifier]["buffer_value-1"]
-
-            if self.optimization_iteration > 3:
-                delta_g_1 = g_i - g_i_m1
-                delta_g_2 = g_i_m1 -g_i_m2
-                delta_g_3 = g_i_m2 -g_i_m3
-
-                if delta_g_1*delta_g_2 < 0 and delta_g_2*delta_g_3 < 0:
-                    self.constraint_buffer_variables[identifier]["buffer_size_factor"] += abs(buffer_value - buffer_value_m1)
-
-            if self.optimization_iteration > 1:
-                delta_g = g_i - g_i_m1
-                if delta_g >= 0.0 and g_i_m1 > 0:
-                    self.constraint_buffer_variables[identifier]["central_buffer_value"] -= g_i_m1
-                elif delta_g <= 0.0 and g_i_m1 < 0:
-                    self.constraint_buffer_variables[identifier]["central_buffer_value"] += g_i_m1
-                    self.constraint_buffer_variables[identifier]["central_buffer_value"] = \
-                        max(self.constraint_buffer_variables[identifier]["central_buffer_value"], 0.0)
-
-            self.constraint_buffer_variables[identifier]["g_i-3"] = g_i_m2
-            self.constraint_buffer_variables[identifier]["g_i-2"] = g_i_m1
-            self.constraint_buffer_variables[identifier]["g_i-1"] = g_i
-
-    # --------------------------------------------------------------------------
-    def __logCurrentOptimizationStep(self):
-        additional_values_to_log = {}
-        additional_values_to_log["step_size"] = self.d_norm
-        additional_values_to_log["inf_norm_p"] = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.PROJECTION)
-        additional_values_to_log["inf_norm_c"] = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.CORRECTION)
-        additional_values_to_log["projection_norm"] = self.s_norm
-        itr = 0
-        for constraint in self.constraints.values():
-            identifier = constraint["identifier"].GetString()
-            additional_values_to_log["c"+str(itr+1)+"_buffer_value"] = self.constraint_buffer_variables[identifier]["buffer_value"]
-            additional_values_to_log["c"+str(itr+1)+"_buffer_size"] = self.constraint_buffer_variables[identifier]["buffer_size"]
-            additional_values_to_log["c"+str(itr+1)+"_buffer_size_factor"] = self.constraint_buffer_variables[identifier]["buffer_size_factor"]
-            additional_values_to_log["c"+str(itr+1)+"_central_buffer_value"] = self.constraint_buffer_variables[identifier]["central_buffer_value"]
-            additional_values_to_log["c"+str(itr+1)+"_lower_buffer_value"] = self.constraint_buffer_variables[identifier]["lower_buffer_value"]
-            additional_values_to_log["c"+str(itr+1)+"_upper_buffer_value"] = self.constraint_buffer_variables[identifier]["upper_buffer_value"]
-            itr += 1
-        self.data_logger.LogCurrentValues(self.optimization_iteration, additional_values_to_log)
-        self.data_logger.LogCurrentDesign(self.optimization_iteration)
-
-    # --------------------------------------------------------------------------
-    def __isAlgorithmConverged(self):
-
-        if self.optimization_iteration > 1 :
-
-            # Check if maximum iterations were reached
-            if self.optimization_iteration == self.max_iterations:
-                Kratos.Logger.Print("")
-                Kratos.Logger.PrintInfo("ShapeOpt", "Maximal iterations of optimization problem reached!")
-                return True
-
-            # Check for relative tolerance
-            relative_change_of_objective_value = self.data_logger.GetValues("rel_change_objective")[self.optimization_iteration]
-            if abs(relative_change_of_objective_value) < self.relative_tolerance:
-                Kratos.Logger.Print("")
-                Kratos.Logger.PrintInfo("ShapeOpt", "Optimization problem converged within a relative objective tolerance of ",self.relative_tolerance,"%.")
-                return True
-
-    # --------------------------------------------------------------------------
-    def __determineAbsoluteChanges(self):
-        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.CONTROL_POINT_UPDATE, KSO.CONTROL_POINT_CHANGE)
-        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.SHAPE_UPDATE, KSO.SHAPE_CHANGE)
-
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Ihar Antonau
+#
+# ==============================================================================
+
+# Making KratosMultiphysics backward compatible with python 2.6 and 2.7
+from __future__ import print_function, absolute_import, division
+
+# Kratos Core and Apps
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+from KratosMultiphysics.LinearSolversApplication import dense_linear_solver_factory
+
+# Additional imports
+from .algorithm_base import OptimizationAlgorithm
+from .. import mapper_factory
+from KratosMultiphysics.ShapeOptimizationApplication.loggers import data_logger_factory
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_variable_utilities import WriteDictionaryDataOnNodalVariable
+import numpy as np
+
+
+# ==============================================================================
+class AlgorithmRelaxedGradientProjection(OptimizationAlgorithm):
+    # --------------------------------------------------------------------------
+    def __init__(self, optimization_settings, analyzer, communicator, model_part_controller):
+        default_algorithm_settings = Kratos.Parameters("""
+        {
+            "name"                    : "relaxed_gradient_projection",
+            "max_iterations"          : 100,
+            "max_inner_iter"          : 100,
+            "relative_tolerance"      : 1e-3,
+            "line_search" : {
+                "line_search_type"           : "manual_stepping",
+                "step_size"                  : 1.0
+            }
+        }""")
+        self.algorithm_settings =  optimization_settings["optimization_algorithm"]
+        self.algorithm_settings.RecursivelyValidateAndAssignDefaults(default_algorithm_settings)
+
+        self.optimization_settings = optimization_settings
+        self.mapper_settings = optimization_settings["design_variables"]["filter"]
+
+        self.analyzer = analyzer
+        self.communicator = communicator
+        self.model_part_controller = model_part_controller
+
+        self.design_surface = None
+        self.mapper = None
+        self.data_logger = None
+        self.optimization_utilities = None
+
+        self.objectives = optimization_settings["objectives"]
+        self.constraints = optimization_settings["constraints"]
+        self.constraint_gradient_variables = {}
+        self.constraint_buffer_variables = {}
+        self.constraint_laplace_multipliers = {}
+        for itr, constraint in enumerate(self.constraints.values()):
+            constraint_id = constraint["identifier"].GetString()
+            self.constraint_gradient_variables.update({
+                constraint_id : {
+                    "gradient": Kratos.KratosGlobals.GetVariable("DC"+str(itr+1)+"DX"),
+                    "mapped_gradient": Kratos.KratosGlobals.GetVariable("DC"+str(itr+1)+"DX_MAPPED")
+                }
+            })
+            self.constraint_buffer_variables.update({
+                constraint_id : {
+                    "buffer_value": 0.0,
+                    "buffer_value-1": 0.0,
+                    "buffer_size": 1e-12,
+                    "buffer_size_factor": 2.0,
+                    "central_buffer_value": 0.0,
+                    "lower_buffer_value": - 1e-12,
+                    "upper_buffer_value": 1e-12,
+                    "g_i-1": 0.0,
+                    "g_i-2": 0.0,
+                    "g_i-3": 0.0,
+                    "max_constraint_change": 0.0
+                }
+            })
+
+
+        self.step_size = self.algorithm_settings["line_search"]["step_size"].GetDouble()
+        self.line_search_type = self.algorithm_settings["line_search"]["line_search_type"].GetString()
+        self.max_iterations = self.algorithm_settings["max_iterations"].GetInt() + 1
+        self.relative_tolerance = self.algorithm_settings["relative_tolerance"].GetDouble()
+        self.s_norm = 0.0
+
+        self.max_inner_iter = self.algorithm_settings["max_inner_iter"].GetDouble()
+        self.buffer_coeff_update = 2.0 / self.max_inner_iter
+
+        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.INV_HESSIAN)
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.PROJECTION)
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.CORRECTION)
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.SEARCH_DIRECTION)
+
+
+    # --------------------------------------------------------------------------
+    def CheckApplicability(self):
+        if self.objectives.size() > 1:
+            raise RuntimeError("Gradient projection algorithm only supports one objective function!")
+        if self.constraints.size() == 0:
+            raise RuntimeError("Gradient projection algorithm requires definition of at least one constraint!")
+
+    # --------------------------------------------------------------------------
+    def InitializeOptimizationLoop(self):
+        self.model_part_controller.Initialize()
+
+        self.analyzer.InitializeBeforeOptimizationLoop()
+
+        self.design_surface = self.model_part_controller.GetDesignSurface()
+
+        self.mapper = mapper_factory.CreateMapper(self.design_surface, self.design_surface, self.mapper_settings)
+        self.mapper.Initialize()
+        self.model_part_controller.InitializeDamping()
+
+        self.data_logger = data_logger_factory.CreateDataLogger(self.model_part_controller, self.communicator, self.optimization_settings)
+        self.data_logger.InitializeDataLogging()
+
+        self.optimization_utilities = KSO.OptimizationUtilities
+
+    # --------------------------------------------------------------------------
+    def RunOptimizationLoop(self):
+        timer = Timer()
+        timer.StartTimer()
+
+        for self.optimization_iteration in range(1,self.max_iterations):
+            Kratos.Logger.Print("")
+            Kratos.Logger.Print("===============================================================================")
+            Kratos.Logger.PrintInfo("ShapeOpt", timer.GetTimeStamp(), ": Starting optimization iteration ", self.optimization_iteration)
+            Kratos.Logger.Print("===============================================================================\n")
+
+            timer.StartNewLap()
+
+            self.__initializeNewShape()
+
+            self.__analyzeShape()
+
+            self.__computeBufferValue()
+
+            self.__computeShapeUpdate()
+
+            self.__logCurrentOptimizationStep()
+
+            self.__updateBufferZone()
+
+            Kratos.Logger.Print("")
+            Kratos.Logger.PrintInfo("ShapeOpt", "Time needed for current optimization step = ", timer.GetLapTime(), "s")
+            Kratos.Logger.PrintInfo("ShapeOpt", "Time needed for total optimization so far = ", timer.GetTotalTime(), "s")
+
+            if self.__isAlgorithmConverged():
+                break
+            else:
+                self.__determineAbsoluteChanges()
+
+    # --------------------------------------------------------------------------
+    def FinalizeOptimizationLoop(self):
+        self.data_logger.FinalizeDataLogging()
+        self.analyzer.FinalizeAfterOptimizationLoop()
+
+    # --------------------------------------------------------------------------
+    def __initializeNewShape(self):
+        self.model_part_controller.UpdateTimeStep(self.optimization_iteration)
+        self.model_part_controller.UpdateMeshAccordingInputVariable(KSO.SHAPE_UPDATE)
+        self.model_part_controller.SetReferenceMeshToMesh()
+
+    # --------------------------------------------------------------------------
+    def __analyzeShape(self):
+        self.communicator.initializeCommunication()
+        self.communicator.requestValueOf(self.objectives[0]["identifier"].GetString())
+        self.communicator.requestGradientOf(self.objectives[0]["identifier"].GetString())
+
+        for constraint in self.constraints.values():
+            con_id =  constraint["identifier"].GetString()
+            self.communicator.requestValueOf(con_id)
+            self.communicator.requestGradientOf(con_id)
+
+        self.analyzer.AnalyzeDesignAndReportToCommunicator(self.optimization_model_part, self.optimization_iteration, self.communicator)
+
+        # compute normals only if required
+        surface_normals_required = self.objectives[0]["project_gradient_on_surface_normals"].GetBool()
+        for constraint in self.constraints.values():
+            if constraint["project_gradient_on_surface_normals"].GetBool():
+                surface_normals_required = True
+
+        if surface_normals_required:
+            self.model_part_controller.ComputeUnitSurfaceNormals()
+
+        # project and damp objective gradients
+        objGradientDict = self.communicator.getStandardizedGradient(self.objectives[0]["identifier"].GetString())
+        WriteDictionaryDataOnNodalVariable(objGradientDict, self.optimization_model_part, KSO.DF1DX)
+
+        if self.objectives[0]["project_gradient_on_surface_normals"].GetBool():
+            self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(KSO.DF1DX)
+
+        self.model_part_controller.DampNodalSensitivityVariableIfSpecified(KSO.DF1DX)
+
+        # project and damp constraint gradients
+        for constraint in self.constraints.values():
+            con_id = constraint["identifier"].GetString()
+            conGradientDict = self.communicator.getStandardizedGradient(con_id)
+            gradient_variable = self.constraint_gradient_variables[con_id]["gradient"]
+            WriteDictionaryDataOnNodalVariable(conGradientDict, self.optimization_model_part, gradient_variable)
+
+            if constraint["project_gradient_on_surface_normals"].GetBool():
+                self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(gradient_variable)
+
+            self.model_part_controller.DampNodalSensitivityVariableIfSpecified(gradient_variable)
+
+    # --------------------------------------------------------------------------
+    def __computeBufferValue(self):
+        # compute new buffer size and buffer values
+    	for constraint in self.constraints.values():
+            identifier = constraint["identifier"].GetString()
+            g_i = self.communicator.getStandardizedValue(identifier)
+            g_i_m1 = self.constraint_buffer_variables[identifier]["g_i-1"]
+            buffer_size_factor = self.constraint_buffer_variables[identifier]["buffer_size_factor"]
+
+
+            self.constraint_buffer_variables[identifier]["buffer_value-1"] = self.constraint_buffer_variables[identifier]["buffer_value"]
+
+            if self.optimization_iteration > 1:
+
+                if abs(g_i - g_i_m1) > self.constraint_buffer_variables[identifier]["max_constraint_change"]:
+                    self.constraint_buffer_variables[identifier]["max_constraint_change"] = abs(g_i - g_i_m1)
+
+                max_constraint_change = self.constraint_buffer_variables[identifier]["max_constraint_change"]
+                self.constraint_buffer_variables[identifier]["buffer_size"] = max(buffer_size_factor * max_constraint_change, 1e-12)
+
+            buffer_size = self.constraint_buffer_variables[identifier]["buffer_size"]
+            self.constraint_buffer_variables[identifier]["lower_buffer_value"] = self.constraint_buffer_variables[identifier]["central_buffer_value"] \
+                - buffer_size
+            self.constraint_buffer_variables[identifier]["upper_buffer_value"] = self.constraint_buffer_variables[identifier]["central_buffer_value"] \
+                + buffer_size
+
+            if self.__isConstraintActive(constraint):
+                if constraint["type"].GetString() == "=":
+                    self.constraint_buffer_variables[identifier]["buffer_value"] = min(1 - abs(g_i) / buffer_size, 2.0)
+                else:
+                    lower_buffer_value = self.constraint_buffer_variables[identifier]["lower_buffer_value"]
+                    self.constraint_buffer_variables[identifier]["buffer_value"] = min( (g_i - lower_buffer_value) / buffer_size, 2.0 )
+            else:
+                self.constraint_buffer_variables[identifier]["buffer_value"] = 0.0
+
+    # --------------------------------------------------------------------------
+    def __computeShapeUpdate(self):
+        self.mapper.Update()
+        self.mapper.InverseMap(KSO.DF1DX, KSO.DF1DX_MAPPED)
+
+        for constraint in self.constraints.values():
+            con_id = constraint["identifier"].GetString()
+            gradient_variable = self.constraint_gradient_variables[con_id]["gradient"]
+            mapped_gradient_variable = self.constraint_gradient_variables[con_id]["mapped_gradient"]
+            self.mapper.InverseMap(gradient_variable, mapped_gradient_variable)
+
+        self.inner_iter = 1
+
+        while not self.__checkInnerConvergence():
+
+            self.direction_has_changed = False
+
+            Kratos.Logger.PrintInfo("ShapeOpt", "Inner Iteration to Find Shape Update = ", self.inner_iter)
+
+            self.__computeControlPointUpdate()
+
+            self.mapper.Map(KSO.CONTROL_POINT_UPDATE, KSO.SHAPE_UPDATE)
+            self.model_part_controller.DampNodalUpdateVariableIfSpecified(KSO.SHAPE_UPDATE)
+
+            self.d_norm = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.SHAPE_UPDATE)
+
+            self.__checkConstraintValue()
+            self.inner_iter += 1
+        self.__saveLineSearchData()
+
+
+    # --------------------------------------------------------------------------
+
+    def __checkInnerConvergence(self):
+        Kratos.Logger.PrintInfo("Check Convergence of the inner loop:")
+        if self.inner_iter == 1:
+            return False
+        elif self.direction_has_changed and self.inner_iter <= self.max_inner_iter:
+            return False
+        else:
+            return True
+
+    def __checkConstraintValue(self):
+        index = -1
+        for constraint in self.constraints.values():
+            if self.__isConstraintActive(constraint):
+                index += 1
+                identifier = constraint["identifier"].GetString()
+                g_i = self.communicator.getStandardizedValue(identifier)
+                g_a_variable = self.constraint_gradient_variables[identifier]["gradient"]
+                shape_update = Kratos.Vector()
+                gradient = Kratos.Vector()
+                self.optimization_utilities.AssembleVector(self.design_surface, gradient, g_a_variable)
+                self.optimization_utilities.AssembleVector(self.design_surface, shape_update, KSO.SHAPE_UPDATE)
+                new_g_i = g_i + np.dot(gradient, shape_update)
+                Kratos.Logger.PrintInfo("Constraint ", identifier, "\n Linearized new value = ", new_g_i)
+                if new_g_i > 0.0:
+                    if self.relaxation_coefficients[index] < 1.0:
+                        self.relaxation_coefficients[index] = min(self.relaxation_coefficients[index] + self.buffer_coeff_update, 1.0)
+                        self.direction_has_changed = True
+                    elif self.correction_coefficients[index] < 2.0:
+                        self.correction_coefficients[index] = min (self.correction_coefficients[index] + self.buffer_coeff_update, 2.0)
+                        self.direction_has_changed = True
+                Kratos.Logger.PrintInfo("Constraint ", identifier, "\n W_R, W_C = ", self.relaxation_coefficients[index], self.correction_coefficients[index])
+
+    # --------------------------------------------------------------------------
+    def __LineSearch(self):
+        Kratos.Logger.PrintInfo("Line Search ...")
+        if self.line_search_type == "manual_stepping":
+            self.__manualStep()
+        elif self.line_search_type == "QNBB_method":
+            if self.optimization_iteration == 1:
+                self.max_step_size = self.step_size
+                # Do initial small step
+                self.step_size /= 5
+                self.__manualStep()
+            else:
+                self.__QNBBStep()
+        elif self.line_search_type == "BB_method":
+            if self.optimization_iteration == 1:
+                self.max_step_size = self.step_size
+                # Do initial small step
+                self.step_size /= 5
+                self.__manualStep()
+            else:
+                self.__BBStep()
+
+
+    def __manualStep(self):
+        step_norm = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.CONTROL_POINT_UPDATE)
+        if abs(step_norm) > 1e-10:
+            step = Kratos.Vector()
+            self.optimization_utilities.AssembleVector(self.design_surface, step, KSO.CONTROL_POINT_UPDATE)
+            step *= 1.0 / step_norm
+            self.optimization_utilities.AssignVectorToVariable(self.design_surface, step, KSO.SEARCH_DIRECTION)
+            step *= self.step_size
+            self.optimization_utilities.AssignVectorToVariable(self.design_surface, step, KSO.CONTROL_POINT_UPDATE)
+
+    def __QNBBStep(self):
+        self.s_norm = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.SEARCH_DIRECTION)
+        if abs(self.s_norm) > 1e-10:
+            s = Kratos.Vector()
+            self.optimization_utilities.AssembleVector(self.design_surface, s, KSO.SEARCH_DIRECTION)
+            s /= self.s_norm
+            self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.SEARCH_DIRECTION)
+
+            for index, node in enumerate(self.design_surface.Nodes):
+                i = index * 3
+                y_i = np.array(self.prev_s[i: i+3]) - np.array(s[i: i+3])
+                d_i = np.array(self.d[i:i+3])
+                if np.dot(y_i, y_i) < 1e-9:
+                    step_i = self.max_step_size
+                else:
+                    step_i = abs(np.dot(d_i, y_i) / np.dot(y_i, y_i))
+                if step_i > self.max_step_size:
+                    step_i = self.max_step_size
+                node.SetSolutionStepValue(KSO.INV_HESSIAN, step_i)
+                s[i] = s[i] * step_i
+                s[i+1] = s[i+1] * step_i
+                s[i+2] = s[i+2] * step_i
+            self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.CONTROL_POINT_UPDATE)
+
+    def __BBStep(self):
+        self.s_norm = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.SEARCH_DIRECTION)
+        if abs(self.s_norm) > 1e-10:
+            s = Kratos.Vector()
+            self.optimization_utilities.AssembleVector(self.design_surface, s, KSO.SEARCH_DIRECTION)
+            s /= self.s_norm
+            self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.SEARCH_DIRECTION)
+            y = self.prev_s - s
+            if np.dot(y, y) < 1e-9:
+                step = self.max_step_size
+            else:
+                step = abs(np.dot(y, self.d) / np.dot(y, y))
+            if step > self.max_step_size:
+                step = self.max_step_size
+            s = s * step
+            self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.CONTROL_POINT_UPDATE)
+
+    def __saveLineSearchData(self):
+        self.prev_s = Kratos.Vector()
+        self.d = Kratos.Vector()
+        self.optimization_utilities.AssembleVector(self.design_surface, self.d, KSO.CONTROL_POINT_UPDATE)
+        self.optimization_utilities.AssembleVector(self.design_surface, self.prev_s, KSO.SEARCH_DIRECTION)
+
+    # --------------------------------------------------------------------------
+    def __computeControlPointUpdate(self):
+        """adapted from https://msulaiman.org/onewebmedia/GradProj_2.pdf"""
+        if self.inner_iter == 1:
+            self.g_a, self.g_a_variables, self.relaxation_coefficients, self.correction_coefficients = self.__getActiveConstraints()
+
+        Kratos.Logger.PrintInfo("ShapeOpt", "Assemble vector of objective gradient.")
+        nabla_f = Kratos.Vector()
+        p = Kratos.Vector()
+        self.optimization_utilities.AssembleVector(self.design_surface, nabla_f, KSO.DF1DX_MAPPED)
+        f_norm = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.DF1DX_MAPPED)
+
+        if abs(f_norm) > 1e-10:
+            nabla_f *= 1.0/f_norm
+
+        if len(self.g_a) == 0:
+            Kratos.Logger.PrintInfo("ShapeOpt", "No constraints active, use negative objective gradient as search direction.")
+            p = nabla_f * (-1.0)
+            self.optimization_utilities.AssignVectorToVariable(self.design_surface, p, KSO.SEARCH_DIRECTION)
+            self.optimization_utilities.AssignVectorToVariable(self.design_surface, p, KSO.PROJECTION)
+            Kratos.VariableUtils().SetHistoricalVariableToZero(KSO.CORRECTION, self.design_surface.Nodes)
+            self.optimization_utilities.AssignVectorToVariable(self.design_surface, p, KSO.CONTROL_POINT_UPDATE)
+            self.__LineSearch()
+            return
+
+        omega_r = Kratos.Matrix()
+        self.optimization_utilities.AssembleBufferMatrix(omega_r, self.relaxation_coefficients)
+        omega_c = Kratos.Vector(self.correction_coefficients)
+
+        Kratos.Logger.PrintInfo("ShapeOpt", "Assemble matrix of constraint gradient.")
+        N = Kratos.Matrix()
+        self.optimization_utilities.AssembleMatrix(self.design_surface, N, self.g_a_variables)
+
+        settings = Kratos.Parameters('{ "solver_type" : "LinearSolversApplication.dense_col_piv_householder_qr" }')
+        solver = dense_linear_solver_factory.ConstructSolver(settings)
+
+        c = Kratos.Vector()
+
+        Kratos.Logger.PrintInfo("ShapeOpt", "Calculate projected search direction and correction.")
+        self.optimization_utilities.CalculateRelaxedProjectedSearchDirectionAndCorrection(
+            nabla_f,
+            N,
+            omega_r,
+            omega_c,
+            solver,
+            p,
+            c)
+
+        # additional normalization step
+
+        self.optimization_utilities.AssignVectorToVariable(self.design_surface, p, KSO.PROJECTION)
+        self.optimization_utilities.AssignVectorToVariable(self.design_surface, c, KSO.CORRECTION)
+        self.optimization_utilities.AssignVectorToVariable(self.design_surface, p+c, KSO.SEARCH_DIRECTION)
+        self.optimization_utilities.AssignVectorToVariable(self.design_surface, p+c, KSO.CONTROL_POINT_UPDATE)
+        self.__LineSearch()
+
+
+
+    # --------------------------------------------------------------------------
+    def __getActiveConstraints(self):
+        active_constraint_values = []
+        active_constraint_variables = []
+        active_relaxation_coefficient = []
+        active_correction_coefficient = []
+
+        for constraint in self.constraints.values():
+            if self.__isConstraintActive(constraint):
+                identifier = constraint["identifier"].GetString()
+                g_i = self.communicator.getStandardizedValue(identifier)
+                buffer_value = self.constraint_buffer_variables[identifier]["buffer_value"]
+
+                active_constraint_values.append(g_i)
+                g_a_variable = self.constraint_gradient_variables[identifier]["mapped_gradient"]
+                g_a_norm = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, g_a_variable)
+                g_a_variable_vector = Kratos.Vector()
+                self.optimization_utilities.AssembleVector(self.design_surface, g_a_variable_vector, g_a_variable)
+                if abs(g_a_norm) > 1e-10:
+                    g_a_variable_vector /= g_a_norm
+
+                self.optimization_utilities.AssignVectorToVariable(self.design_surface, g_a_variable_vector, g_a_variable)
+
+                active_constraint_variables.append(g_a_variable)
+                active_relaxation_coefficient.append(min(buffer_value,1.0))
+
+                max_buffer = 2.0
+                if buffer_value > 1.0:
+                    if buffer_value < max_buffer:
+                        active_correction_coefficient.append(2*(buffer_value - 1))
+                    else:
+                        active_correction_coefficient.append(2*(max_buffer-1))
+                else:
+                    active_correction_coefficient.append(0.0)
+
+
+        return active_constraint_values, active_constraint_variables, active_relaxation_coefficient, active_correction_coefficient
+
+    # --------------------------------------------------------------------------
+    def __isConstraintActive(self, constraint):
+        identifier = constraint["identifier"].GetString()
+        g_i = self.communicator.getStandardizedValue(identifier)
+        if constraint["type"].GetString() == "=":
+            return True
+        elif g_i >= self.constraint_buffer_variables[identifier]["lower_buffer_value"]:
+            return True
+        else:
+            return False
+    # --------------------------------------------------------------------------
+    def __updateBufferZone(self):
+        # adapt the buffer zones for zig-zagging, too much or too little correction
+        for constraint in self.constraints.values():
+
+            identifier = constraint["identifier"].GetString()
+            g_i = self.communicator.getStandardizedValue(identifier)
+            g_i_m1 = self.constraint_buffer_variables[identifier]["g_i-1"]
+            g_i_m2 = self.constraint_buffer_variables[identifier]["g_i-2"]
+            g_i_m3 = self.constraint_buffer_variables[identifier]["g_i-3"]
+
+            buffer_value = self.constraint_buffer_variables[identifier]["buffer_value"]
+            buffer_value_m1 = self.constraint_buffer_variables[identifier]["buffer_value-1"]
+
+            if self.optimization_iteration > 3:
+                delta_g_1 = g_i - g_i_m1
+                delta_g_2 = g_i_m1 -g_i_m2
+                delta_g_3 = g_i_m2 -g_i_m3
+
+                if delta_g_1*delta_g_2 < 0 and delta_g_2*delta_g_3 < 0:
+                    self.constraint_buffer_variables[identifier]["buffer_size_factor"] += abs(buffer_value - buffer_value_m1)
+
+            if self.optimization_iteration > 1:
+                delta_g = g_i - g_i_m1
+                if delta_g >= 0.0 and g_i_m1 > 0:
+                    self.constraint_buffer_variables[identifier]["central_buffer_value"] -= g_i_m1
+                elif delta_g <= 0.0 and g_i_m1 < 0:
+                    self.constraint_buffer_variables[identifier]["central_buffer_value"] += g_i_m1
+                    self.constraint_buffer_variables[identifier]["central_buffer_value"] = \
+                        max(self.constraint_buffer_variables[identifier]["central_buffer_value"], 0.0)
+
+            self.constraint_buffer_variables[identifier]["g_i-3"] = g_i_m2
+            self.constraint_buffer_variables[identifier]["g_i-2"] = g_i_m1
+            self.constraint_buffer_variables[identifier]["g_i-1"] = g_i
+
+    # --------------------------------------------------------------------------
+    def __logCurrentOptimizationStep(self):
+        additional_values_to_log = {}
+        additional_values_to_log["step_size"] = self.d_norm
+        additional_values_to_log["inf_norm_p"] = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.PROJECTION)
+        additional_values_to_log["inf_norm_c"] = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.CORRECTION)
+        additional_values_to_log["projection_norm"] = self.s_norm
+        itr = 0
+        for constraint in self.constraints.values():
+            identifier = constraint["identifier"].GetString()
+            additional_values_to_log["c"+str(itr+1)+"_buffer_value"] = self.constraint_buffer_variables[identifier]["buffer_value"]
+            additional_values_to_log["c"+str(itr+1)+"_buffer_size"] = self.constraint_buffer_variables[identifier]["buffer_size"]
+            additional_values_to_log["c"+str(itr+1)+"_buffer_size_factor"] = self.constraint_buffer_variables[identifier]["buffer_size_factor"]
+            additional_values_to_log["c"+str(itr+1)+"_central_buffer_value"] = self.constraint_buffer_variables[identifier]["central_buffer_value"]
+            additional_values_to_log["c"+str(itr+1)+"_lower_buffer_value"] = self.constraint_buffer_variables[identifier]["lower_buffer_value"]
+            additional_values_to_log["c"+str(itr+1)+"_upper_buffer_value"] = self.constraint_buffer_variables[identifier]["upper_buffer_value"]
+            itr += 1
+        self.data_logger.LogCurrentValues(self.optimization_iteration, additional_values_to_log)
+        self.data_logger.LogCurrentDesign(self.optimization_iteration)
+
+    # --------------------------------------------------------------------------
+    def __isAlgorithmConverged(self):
+
+        if self.optimization_iteration > 1 :
+
+            # Check if maximum iterations were reached
+            if self.optimization_iteration == self.max_iterations:
+                Kratos.Logger.Print("")
+                Kratos.Logger.PrintInfo("ShapeOpt", "Maximal iterations of optimization problem reached!")
+                return True
+
+            # Check for relative tolerance
+            relative_change_of_objective_value = self.data_logger.GetValues("rel_change_objective")[self.optimization_iteration]
+            if abs(relative_change_of_objective_value) < self.relative_tolerance:
+                Kratos.Logger.Print("")
+                Kratos.Logger.PrintInfo("ShapeOpt", "Optimization problem converged within a relative objective tolerance of ",self.relative_tolerance,"%.")
+                return True
+
+    # --------------------------------------------------------------------------
+    def __determineAbsoluteChanges(self):
+        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.CONTROL_POINT_UPDATE, KSO.CONTROL_POINT_CHANGE)
+        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.SHAPE_UPDATE, KSO.SHAPE_CHANGE)
+
 # ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_base.py

 * *Ordering differences only*

```diff
@@ -1,31 +1,31 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#                   Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-
-# ==============================================================================
-class OptimizationAlgorithm:
-    # --------------------------------------------------------------------------
-    def CheckApplicability( self ):
-        raise RuntimeError("Algorithm base class is called. Please check your implementation of the function >> CheckApplicability << .")
-
-    # --------------------------------------------------------------------------
-    def InitializeOptimizationLoop( self ):
-        raise RuntimeError("Algorithm base class is called. Please check your implementation of the function >> InitializeOptimizationLoop << .")
-
-    # --------------------------------------------------------------------------
-    def RunOptimizationLoop( self ):
-        raise RuntimeError("Algorithm base class is called. Please check your implementation of the function >> RunOptimizationLoop << .")
-
-    # --------------------------------------------------------------------------
-    def FinalizeOptimizationLoop( self ):
-        raise RuntimeError("Algorithm base class is called. Please check your implementation of the function >> FinalizeOptimizationLoop << .")
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#                   Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+
+# ==============================================================================
+class OptimizationAlgorithm:
+    # --------------------------------------------------------------------------
+    def CheckApplicability( self ):
+        raise RuntimeError("Algorithm base class is called. Please check your implementation of the function >> CheckApplicability << .")
+
+    # --------------------------------------------------------------------------
+    def InitializeOptimizationLoop( self ):
+        raise RuntimeError("Algorithm base class is called. Please check your implementation of the function >> InitializeOptimizationLoop << .")
+
+    # --------------------------------------------------------------------------
+    def RunOptimizationLoop( self ):
+        raise RuntimeError("Algorithm base class is called. Please check your implementation of the function >> RunOptimizationLoop << .")
+
+    # --------------------------------------------------------------------------
+    def FinalizeOptimizationLoop( self ):
+        raise RuntimeError("Algorithm base class is called. Please check your implementation of the function >> FinalizeOptimizationLoop << .")
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_penalized_projection.py

 * *Ordering differences only*

```diff
@@ -1,225 +1,225 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#                   Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-
-# Kratos Core and Apps
-import KratosMultiphysics as KM
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-
-# Additional imports
-from KratosMultiphysics.ShapeOptimizationApplication.algorithms.algorithm_base import OptimizationAlgorithm
-from KratosMultiphysics.ShapeOptimizationApplication import mapper_factory
-from KratosMultiphysics.ShapeOptimizationApplication.loggers import data_logger_factory
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_variable_utilities import WriteDictionaryDataOnNodalVariable
-
-# ==============================================================================
-class AlgorithmPenalizedProjection(OptimizationAlgorithm):
-    # --------------------------------------------------------------------------
-    def __init__(self, optimization_settings, analyzer, communicator, model_part_controller):
-        default_algorithm_settings = KM.Parameters("""
-        {
-            "name"                    : "penalized_projection",
-            "correction_scaling"      : 1.0,
-            "use_adaptive_correction" : true,
-            "max_iterations"          : 100,
-            "relative_tolerance"      : 1e-3,
-            "line_search" : {
-                "line_search_type"           : "manual_stepping",
-                "normalize_search_direction" : true,
-                "step_size"                  : 1.0
-            }
-        }""")
-        self.algorithm_settings =  optimization_settings["optimization_algorithm"]
-        self.algorithm_settings.RecursivelyValidateAndAssignDefaults(default_algorithm_settings)
-
-        self.optimization_settings = optimization_settings
-        self.mapper_settings = optimization_settings["design_variables"]["filter"]
-
-        self.analyzer = analyzer
-        self.communicator = communicator
-        self.model_part_controller = model_part_controller
-
-        self.design_surface = None
-        self.mapper = None
-        self.data_logger = None
-        self.optimization_utilities = None
-        self.constraint_value = 0.0
-        self.correction_scaling = optimization_settings["optimization_algorithm"]["correction_scaling"].GetDouble()
-
-        self.objectives = optimization_settings["objectives"]
-        self.constraints = optimization_settings["constraints"]
-
-        self.step_size = self.algorithm_settings["line_search"]["step_size"].GetDouble()
-        self.max_iterations = self.algorithm_settings["max_iterations"].GetInt() + 1
-        self.relative_tolerance = self.algorithm_settings["relative_tolerance"].GetDouble()
-
-        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.SEARCH_DIRECTION)
-
-    # --------------------------------------------------------------------------
-    def CheckApplicability(self):
-        if self.objectives.size() > 1:
-            raise RuntimeError("Penalized projection algorithm only supports one objective function!")
-        if self.constraints.size() == 0:
-            raise RuntimeError("Penalized projection algorithm requires definition of a constraint!")
-        if self.constraints.size() > 1:
-            raise RuntimeError("Penalized projection algorithm only supports one constraint!")
-
-    # --------------------------------------------------------------------------
-    def InitializeOptimizationLoop(self):
-        self.model_part_controller.Initialize()
-
-        self.analyzer.InitializeBeforeOptimizationLoop()
-
-        self.design_surface = self.model_part_controller.GetDesignSurface()
-
-        self.mapper = mapper_factory.CreateMapper(self.design_surface, self.design_surface, self.mapper_settings)
-        self.mapper.Initialize()
-        self.model_part_controller.InitializeDamping()
-
-        self.data_logger = data_logger_factory.CreateDataLogger(self.model_part_controller, self.communicator, self.optimization_settings)
-        self.data_logger.InitializeDataLogging()
-
-        self.optimization_utilities = KSO.OptimizationUtilities
-
-    # --------------------------------------------------------------------------
-    def RunOptimizationLoop(self):
-        timer = Timer()
-        timer.StartTimer()
-
-        for self.optimization_iteration in range(1,self.max_iterations):
-            KM.Logger.Print("")
-            KM.Logger.Print("===============================================================================")
-            KM.Logger.PrintInfo("ShapeOpt", timer.GetTimeStamp(), ": Starting optimization iteration ", self.optimization_iteration)
-            KM.Logger.Print("===============================================================================\n")
-
-            timer.StartNewLap()
-
-            self.__initializeNewShape()
-
-            self.__analyzeShape()
-
-            self.__computeShapeUpdate()
-
-            self.__logCurrentOptimizationStep()
-
-            KM.Logger.Print("")
-            KM.Logger.PrintInfo("ShapeOpt", "Time needed for current optimization step = ", timer.GetLapTime(), "s")
-            KM.Logger.PrintInfo("ShapeOpt", "Time needed for total optimization so far = ", timer.GetTotalTime(), "s")
-
-            if self.__isAlgorithmConverged():
-                break
-            else:
-                self.__determineAbsoluteChanges()
-
-    # --------------------------------------------------------------------------
-    def FinalizeOptimizationLoop(self):
-        self.data_logger.FinalizeDataLogging()
-        self.analyzer.FinalizeAfterOptimizationLoop()
-
-    # --------------------------------------------------------------------------
-    def __initializeNewShape(self):
-        self.model_part_controller.UpdateTimeStep(self.optimization_iteration)
-        self.model_part_controller.UpdateMeshAccordingInputVariable(KSO.SHAPE_UPDATE)
-        self.model_part_controller.SetReferenceMeshToMesh()
-
-    # --------------------------------------------------------------------------
-    def __analyzeShape(self):
-        self.communicator.initializeCommunication()
-        self.communicator.requestValueOf(self.objectives[0]["identifier"].GetString())
-        self.communicator.requestGradientOf(self.objectives[0]["identifier"].GetString())
-        self.communicator.requestValueOf(self.constraints[0]["identifier"].GetString())
-        self.communicator.requestGradientOf(self.constraints[0]["identifier"].GetString())
-
-        self.analyzer.AnalyzeDesignAndReportToCommunicator(self.optimization_model_part, self.optimization_iteration, self.communicator)
-
-        objGradientDict = self.communicator.getStandardizedGradient(self.objectives[0]["identifier"].GetString())
-        conGradientDict = self.communicator.getStandardizedGradient(self.constraints[0]["identifier"].GetString())
-
-        WriteDictionaryDataOnNodalVariable(objGradientDict, self.optimization_model_part, KSO.DF1DX)
-        WriteDictionaryDataOnNodalVariable(conGradientDict, self.optimization_model_part, KSO.DC1DX)
-
-        if self.objectives[0]["project_gradient_on_surface_normals"].GetBool() or self.constraints[0]["project_gradient_on_surface_normals"].GetBool():
-            self.model_part_controller.ComputeUnitSurfaceNormals()
-
-        if self.objectives[0]["project_gradient_on_surface_normals"].GetBool():
-            self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(KSO.DF1DX)
-
-        if self.constraints[0]["project_gradient_on_surface_normals"].GetBool():
-            self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(KSO.DC1DX)
-
-        self.model_part_controller.DampNodalSensitivityVariableIfSpecified(KSO.DF1DX)
-        self.model_part_controller.DampNodalSensitivityVariableIfSpecified(KSO.DC1DX)
-
-    # --------------------------------------------------------------------------
-    def __computeShapeUpdate(self):
-        self.mapper.Update()
-        self.mapper.InverseMap(KSO.DF1DX, KSO.DF1DX_MAPPED)
-        self.mapper.InverseMap(KSO.DC1DX, KSO.DC1DX_MAPPED)
-        is_adaptive = self.algorithm_settings["use_adaptive_correction"].GetBool()
-
-        constraint_value = self.communicator.getStandardizedValue(self.constraints[0]["identifier"].GetString())
-        if self.__isConstraintActive(constraint_value):
-            self.optimization_utilities.ComputeProjectedSearchDirection(self.design_surface)
-            self.correction_scaling = self.optimization_utilities.CorrectProjectedSearchDirection(self.design_surface, self.constraint_value, constraint_value, self.correction_scaling, is_adaptive)
-            self.constraint_value = constraint_value
-        else:
-            self.optimization_utilities.ComputeSearchDirectionSteepestDescent(self.design_surface)
-
-        normalize = self.algorithm_settings["line_search"]["normalize_search_direction"].GetBool()
-        self.optimization_utilities.ComputeControlPointUpdate(self.design_surface, self.step_size, normalize)
-
-        self.mapper.Map(KSO.CONTROL_POINT_UPDATE, KSO.SHAPE_UPDATE)
-        self.model_part_controller.DampNodalUpdateVariableIfSpecified(KSO.SHAPE_UPDATE)
-
-    # --------------------------------------------------------------------------
-    def __isConstraintActive(self, constraintValue):
-        if self.constraints[0]["type"].GetString() == "=":
-            return True
-        elif constraintValue > 0:
-            return True
-        else:
-            return False
-
-    # --------------------------------------------------------------------------
-    def __logCurrentOptimizationStep(self):
-        additional_values_to_log = {}
-        additional_values_to_log["correction_scaling"] = self.correction_scaling
-        additional_values_to_log["step_size"] = self.step_size
-        self.data_logger.LogSensitivityHeatmap(self.optimization_iteration, self.mapper)
-        self.data_logger.LogCurrentValues(self.optimization_iteration, additional_values_to_log)
-        self.data_logger.LogCurrentDesign(self.optimization_iteration)
-
-    # --------------------------------------------------------------------------
-    def __isAlgorithmConverged(self):
-
-        if self.optimization_iteration > 1 :
-
-            # Check if maximum iterations were reached
-            if self.optimization_iteration == self.max_iterations:
-                KM.Logger.Print("")
-                KM.Logger.PrintInfo("ShapeOpt", "Maximal iterations of optimization problem reached!")
-                return True
-
-            # Check for relative tolerance
-            relative_change_of_objective_value = self.data_logger.GetValues("rel_change_objective")[self.optimization_iteration]
-            if abs(relative_change_of_objective_value) < self.relative_tolerance:
-                KM.Logger.Print("")
-                KM.Logger.PrintInfo("ShapeOpt", "Optimization problem converged within a relative objective tolerance of ",self.relative_tolerance,"%.")
-                return True
-
-    # --------------------------------------------------------------------------
-    def __determineAbsoluteChanges(self):
-        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.CONTROL_POINT_UPDATE, KSO.CONTROL_POINT_CHANGE)
-        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.SHAPE_UPDATE, KSO.SHAPE_CHANGE)
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#                   Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+
+# Kratos Core and Apps
+import KratosMultiphysics as KM
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+
+# Additional imports
+from KratosMultiphysics.ShapeOptimizationApplication.algorithms.algorithm_base import OptimizationAlgorithm
+from KratosMultiphysics.ShapeOptimizationApplication import mapper_factory
+from KratosMultiphysics.ShapeOptimizationApplication.loggers import data_logger_factory
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_variable_utilities import WriteDictionaryDataOnNodalVariable
+
+# ==============================================================================
+class AlgorithmPenalizedProjection(OptimizationAlgorithm):
+    # --------------------------------------------------------------------------
+    def __init__(self, optimization_settings, analyzer, communicator, model_part_controller):
+        default_algorithm_settings = KM.Parameters("""
+        {
+            "name"                    : "penalized_projection",
+            "correction_scaling"      : 1.0,
+            "use_adaptive_correction" : true,
+            "max_iterations"          : 100,
+            "relative_tolerance"      : 1e-3,
+            "line_search" : {
+                "line_search_type"           : "manual_stepping",
+                "normalize_search_direction" : true,
+                "step_size"                  : 1.0
+            }
+        }""")
+        self.algorithm_settings =  optimization_settings["optimization_algorithm"]
+        self.algorithm_settings.RecursivelyValidateAndAssignDefaults(default_algorithm_settings)
+
+        self.optimization_settings = optimization_settings
+        self.mapper_settings = optimization_settings["design_variables"]["filter"]
+
+        self.analyzer = analyzer
+        self.communicator = communicator
+        self.model_part_controller = model_part_controller
+
+        self.design_surface = None
+        self.mapper = None
+        self.data_logger = None
+        self.optimization_utilities = None
+        self.constraint_value = 0.0
+        self.correction_scaling = optimization_settings["optimization_algorithm"]["correction_scaling"].GetDouble()
+
+        self.objectives = optimization_settings["objectives"]
+        self.constraints = optimization_settings["constraints"]
+
+        self.step_size = self.algorithm_settings["line_search"]["step_size"].GetDouble()
+        self.max_iterations = self.algorithm_settings["max_iterations"].GetInt() + 1
+        self.relative_tolerance = self.algorithm_settings["relative_tolerance"].GetDouble()
+
+        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.SEARCH_DIRECTION)
+
+    # --------------------------------------------------------------------------
+    def CheckApplicability(self):
+        if self.objectives.size() > 1:
+            raise RuntimeError("Penalized projection algorithm only supports one objective function!")
+        if self.constraints.size() == 0:
+            raise RuntimeError("Penalized projection algorithm requires definition of a constraint!")
+        if self.constraints.size() > 1:
+            raise RuntimeError("Penalized projection algorithm only supports one constraint!")
+
+    # --------------------------------------------------------------------------
+    def InitializeOptimizationLoop(self):
+        self.model_part_controller.Initialize()
+
+        self.analyzer.InitializeBeforeOptimizationLoop()
+
+        self.design_surface = self.model_part_controller.GetDesignSurface()
+
+        self.mapper = mapper_factory.CreateMapper(self.design_surface, self.design_surface, self.mapper_settings)
+        self.mapper.Initialize()
+        self.model_part_controller.InitializeDamping()
+
+        self.data_logger = data_logger_factory.CreateDataLogger(self.model_part_controller, self.communicator, self.optimization_settings)
+        self.data_logger.InitializeDataLogging()
+
+        self.optimization_utilities = KSO.OptimizationUtilities
+
+    # --------------------------------------------------------------------------
+    def RunOptimizationLoop(self):
+        timer = Timer()
+        timer.StartTimer()
+
+        for self.optimization_iteration in range(1,self.max_iterations):
+            KM.Logger.Print("")
+            KM.Logger.Print("===============================================================================")
+            KM.Logger.PrintInfo("ShapeOpt", timer.GetTimeStamp(), ": Starting optimization iteration ", self.optimization_iteration)
+            KM.Logger.Print("===============================================================================\n")
+
+            timer.StartNewLap()
+
+            self.__initializeNewShape()
+
+            self.__analyzeShape()
+
+            self.__computeShapeUpdate()
+
+            self.__logCurrentOptimizationStep()
+
+            KM.Logger.Print("")
+            KM.Logger.PrintInfo("ShapeOpt", "Time needed for current optimization step = ", timer.GetLapTime(), "s")
+            KM.Logger.PrintInfo("ShapeOpt", "Time needed for total optimization so far = ", timer.GetTotalTime(), "s")
+
+            if self.__isAlgorithmConverged():
+                break
+            else:
+                self.__determineAbsoluteChanges()
+
+    # --------------------------------------------------------------------------
+    def FinalizeOptimizationLoop(self):
+        self.data_logger.FinalizeDataLogging()
+        self.analyzer.FinalizeAfterOptimizationLoop()
+
+    # --------------------------------------------------------------------------
+    def __initializeNewShape(self):
+        self.model_part_controller.UpdateTimeStep(self.optimization_iteration)
+        self.model_part_controller.UpdateMeshAccordingInputVariable(KSO.SHAPE_UPDATE)
+        self.model_part_controller.SetReferenceMeshToMesh()
+
+    # --------------------------------------------------------------------------
+    def __analyzeShape(self):
+        self.communicator.initializeCommunication()
+        self.communicator.requestValueOf(self.objectives[0]["identifier"].GetString())
+        self.communicator.requestGradientOf(self.objectives[0]["identifier"].GetString())
+        self.communicator.requestValueOf(self.constraints[0]["identifier"].GetString())
+        self.communicator.requestGradientOf(self.constraints[0]["identifier"].GetString())
+
+        self.analyzer.AnalyzeDesignAndReportToCommunicator(self.optimization_model_part, self.optimization_iteration, self.communicator)
+
+        objGradientDict = self.communicator.getStandardizedGradient(self.objectives[0]["identifier"].GetString())
+        conGradientDict = self.communicator.getStandardizedGradient(self.constraints[0]["identifier"].GetString())
+
+        WriteDictionaryDataOnNodalVariable(objGradientDict, self.optimization_model_part, KSO.DF1DX)
+        WriteDictionaryDataOnNodalVariable(conGradientDict, self.optimization_model_part, KSO.DC1DX)
+
+        if self.objectives[0]["project_gradient_on_surface_normals"].GetBool() or self.constraints[0]["project_gradient_on_surface_normals"].GetBool():
+            self.model_part_controller.ComputeUnitSurfaceNormals()
+
+        if self.objectives[0]["project_gradient_on_surface_normals"].GetBool():
+            self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(KSO.DF1DX)
+
+        if self.constraints[0]["project_gradient_on_surface_normals"].GetBool():
+            self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(KSO.DC1DX)
+
+        self.model_part_controller.DampNodalSensitivityVariableIfSpecified(KSO.DF1DX)
+        self.model_part_controller.DampNodalSensitivityVariableIfSpecified(KSO.DC1DX)
+
+    # --------------------------------------------------------------------------
+    def __computeShapeUpdate(self):
+        self.mapper.Update()
+        self.mapper.InverseMap(KSO.DF1DX, KSO.DF1DX_MAPPED)
+        self.mapper.InverseMap(KSO.DC1DX, KSO.DC1DX_MAPPED)
+        is_adaptive = self.algorithm_settings["use_adaptive_correction"].GetBool()
+
+        constraint_value = self.communicator.getStandardizedValue(self.constraints[0]["identifier"].GetString())
+        if self.__isConstraintActive(constraint_value):
+            self.optimization_utilities.ComputeProjectedSearchDirection(self.design_surface)
+            self.correction_scaling = self.optimization_utilities.CorrectProjectedSearchDirection(self.design_surface, self.constraint_value, constraint_value, self.correction_scaling, is_adaptive)
+            self.constraint_value = constraint_value
+        else:
+            self.optimization_utilities.ComputeSearchDirectionSteepestDescent(self.design_surface)
+
+        normalize = self.algorithm_settings["line_search"]["normalize_search_direction"].GetBool()
+        self.optimization_utilities.ComputeControlPointUpdate(self.design_surface, self.step_size, normalize)
+
+        self.mapper.Map(KSO.CONTROL_POINT_UPDATE, KSO.SHAPE_UPDATE)
+        self.model_part_controller.DampNodalUpdateVariableIfSpecified(KSO.SHAPE_UPDATE)
+
+    # --------------------------------------------------------------------------
+    def __isConstraintActive(self, constraintValue):
+        if self.constraints[0]["type"].GetString() == "=":
+            return True
+        elif constraintValue > 0:
+            return True
+        else:
+            return False
+
+    # --------------------------------------------------------------------------
+    def __logCurrentOptimizationStep(self):
+        additional_values_to_log = {}
+        additional_values_to_log["correction_scaling"] = self.correction_scaling
+        additional_values_to_log["step_size"] = self.step_size
+        self.data_logger.LogSensitivityHeatmap(self.optimization_iteration, self.mapper)
+        self.data_logger.LogCurrentValues(self.optimization_iteration, additional_values_to_log)
+        self.data_logger.LogCurrentDesign(self.optimization_iteration)
+
+    # --------------------------------------------------------------------------
+    def __isAlgorithmConverged(self):
+
+        if self.optimization_iteration > 1 :
+
+            # Check if maximum iterations were reached
+            if self.optimization_iteration == self.max_iterations:
+                KM.Logger.Print("")
+                KM.Logger.PrintInfo("ShapeOpt", "Maximal iterations of optimization problem reached!")
+                return True
+
+            # Check for relative tolerance
+            relative_change_of_objective_value = self.data_logger.GetValues("rel_change_objective")[self.optimization_iteration]
+            if abs(relative_change_of_objective_value) < self.relative_tolerance:
+                KM.Logger.Print("")
+                KM.Logger.PrintInfo("ShapeOpt", "Optimization problem converged within a relative objective tolerance of ",self.relative_tolerance,"%.")
+                return True
+
+    # --------------------------------------------------------------------------
+    def __determineAbsoluteChanges(self):
+        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.CONTROL_POINT_UPDATE, KSO.CONTROL_POINT_CHANGE)
+        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.SHAPE_UPDATE, KSO.SHAPE_CHANGE)
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_factory.py

 * *Ordering differences only*

```diff
@@ -1,62 +1,62 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#
-# ==============================================================================
-
-
-
-# ==============================================================================
-def CreateOptimizationAlgorithm(optimization_settings, analyzer, communicator, model_part_controller):
-    algorithm_name = optimization_settings["optimization_algorithm"]["name"].GetString()
-
-    if algorithm_name == "steepest_descent":
-        from .algorithm_steepest_descent import AlgorithmSteepestDescent
-        return AlgorithmSteepestDescent(optimization_settings,
-                                        analyzer,
-                                        communicator,
-                                        model_part_controller)
-    elif algorithm_name == "gradient_projection":
-        from .algorithm_gradient_projection import AlgorithmGradientProjection
-        return AlgorithmGradientProjection(optimization_settings,
-                                            analyzer,
-                                            communicator,
-                                            model_part_controller)
-    elif algorithm_name == "penalized_projection":
-        from .algorithm_penalized_projection import AlgorithmPenalizedProjection
-        return AlgorithmPenalizedProjection(optimization_settings,
-                                            analyzer,
-                                            communicator,
-                                            model_part_controller)
-    elif algorithm_name == "trust_region":
-        from .algorithm_trust_region import AlgorithmTrustRegion
-        return AlgorithmTrustRegion(optimization_settings,
-                                    analyzer,
-                                    communicator,
-                                    model_part_controller)
-    elif algorithm_name == "bead_optimization":
-        from .algorithm_bead_optimization import AlgorithmBeadOptimization
-        return AlgorithmBeadOptimization(optimization_settings,
-                                         analyzer,
-                                         communicator,
-                                         model_part_controller)
-    elif algorithm_name == "relaxed_gradient_projection":
-        from .algorithm_relaxed_gradient_projection import AlgorithmRelaxedGradientProjection
-        return AlgorithmRelaxedGradientProjection(optimization_settings,
-                                                  analyzer,
-                                                  communicator,
-                                                  model_part_controller)
-    elif algorithm_name == "shape_fraction_optimization":
-        from .algorithm_shape_fraction_optimization import AlgorithmShapeFractionOptimization
-        return AlgorithmShapeFractionOptimization(optimization_settings,
-                                         analyzer,
-                                         communicator,
-                                         model_part_controller)
-    else:
-        raise NameError("The following optimization algorithm is not supported by the algorithm factory: " + algorithm_name)
-
- # ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#
+# ==============================================================================
+
+
+
+# ==============================================================================
+def CreateOptimizationAlgorithm(optimization_settings, analyzer, communicator, model_part_controller):
+    algorithm_name = optimization_settings["optimization_algorithm"]["name"].GetString()
+
+    if algorithm_name == "steepest_descent":
+        from .algorithm_steepest_descent import AlgorithmSteepestDescent
+        return AlgorithmSteepestDescent(optimization_settings,
+                                        analyzer,
+                                        communicator,
+                                        model_part_controller)
+    elif algorithm_name == "gradient_projection":
+        from .algorithm_gradient_projection import AlgorithmGradientProjection
+        return AlgorithmGradientProjection(optimization_settings,
+                                            analyzer,
+                                            communicator,
+                                            model_part_controller)
+    elif algorithm_name == "penalized_projection":
+        from .algorithm_penalized_projection import AlgorithmPenalizedProjection
+        return AlgorithmPenalizedProjection(optimization_settings,
+                                            analyzer,
+                                            communicator,
+                                            model_part_controller)
+    elif algorithm_name == "trust_region":
+        from .algorithm_trust_region import AlgorithmTrustRegion
+        return AlgorithmTrustRegion(optimization_settings,
+                                    analyzer,
+                                    communicator,
+                                    model_part_controller)
+    elif algorithm_name == "bead_optimization":
+        from .algorithm_bead_optimization import AlgorithmBeadOptimization
+        return AlgorithmBeadOptimization(optimization_settings,
+                                         analyzer,
+                                         communicator,
+                                         model_part_controller)
+    elif algorithm_name == "relaxed_gradient_projection":
+        from .algorithm_relaxed_gradient_projection import AlgorithmRelaxedGradientProjection
+        return AlgorithmRelaxedGradientProjection(optimization_settings,
+                                                  analyzer,
+                                                  communicator,
+                                                  model_part_controller)
+    elif algorithm_name == "shape_fraction_optimization":
+        from .algorithm_shape_fraction_optimization import AlgorithmShapeFractionOptimization
+        return AlgorithmShapeFractionOptimization(optimization_settings,
+                                         analyzer,
+                                         communicator,
+                                         model_part_controller)
+    else:
+        raise NameError("The following optimization algorithm is not supported by the algorithm factory: " + algorithm_name)
+
+ # ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_shape_fraction_optimization.py

 * *Ordering differences only*

```diff
@@ -1,622 +1,622 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Schmölz David, https://github.com/dschmoelz
-#
-# ==============================================================================
-
-# Making KratosMultiphysics backward compatible with python 2.6 and 2.7
-from __future__ import print_function, absolute_import, division
-
-# Kratos Core and Apps
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-from KratosMultiphysics.LinearSolversApplication import dense_linear_solver_factory
-
-# Additional imports
-from KratosMultiphysics.ShapeOptimizationApplication.utilities import custom_math as cm
-from KratosMultiphysics.ShapeOptimizationApplication.algorithms.algorithm_base import OptimizationAlgorithm
-from KratosMultiphysics.ShapeOptimizationApplication import mapper_factory
-from KratosMultiphysics.ShapeOptimizationApplication.loggers import data_logger_factory
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
-from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_variable_utilities import WriteDictionaryDataOnNodalVariable, ReadNodalVariableToList
-
-import math
-import time as timer
-
-# ==============================================================================
-class AlgorithmShapeFractionOptimization(OptimizationAlgorithm):
-    # --------------------------------------------------------------------------
-    def __init__(self, optimization_settings, analyzer, communicator, model_part_controller):
-        default_algorithm_settings = Kratos.Parameters("""
-        {
-            "name"                    : "shape_fraction_optimization",
-            "max_correction_share"    : 0.75,
-            "max_iterations"          : 100,
-            "relative_tolerance"      : 1e-3,
-            "shape_fraction" : {
-                "penalty_method"      : "exterior",
-                "max_fraction"        : 0.5,
-                "nodal_tolerance"     : 0.1,
-                "inner_tolerance"     : 0.01,
-                "max_inner_steps"     : 10,
-                "initial_penalty_factor": 0.1,
-                "penalty_scale_factor": 1.25
-            },
-            "line_search" : {
-                "line_search_type"           : "manual_stepping",
-                "normalize_search_direction" : true,
-                "step_size"                  : 1.0
-            }
-        }""")
-        self.algorithm_settings =  optimization_settings["optimization_algorithm"]
-        self.algorithm_settings.RecursivelyValidateAndAssignDefaults(default_algorithm_settings)
-
-        self.optimization_settings = optimization_settings
-        self.mapper_settings = optimization_settings["design_variables"]["filter"]
-
-        self.analyzer = analyzer
-        self.communicator = communicator
-        self.model_part_controller = model_part_controller
-
-        self.design_surface = None
-        self.mapper = None
-        self.data_logger = None
-        self.optimization_utilities = None
-
-        self.objectives = optimization_settings["objectives"]
-        self.constraints = optimization_settings["constraints"]
-        self.constraint_gradient_variables = {}
-        for itr, constraint in enumerate(self.constraints.values()):
-            self.constraint_gradient_variables.update({
-                constraint["identifier"].GetString() : {
-                    "gradient": Kratos.KratosGlobals.GetVariable("DC"+str(itr+1)+"DX"),
-                    "mapped_gradient": Kratos.KratosGlobals.GetVariable("DC"+str(itr+1)+"DX_MAPPED")
-                }
-            })
-        self.max_correction_share = self.algorithm_settings["max_correction_share"].GetDouble()
-
-        self.step_size = self.algorithm_settings["line_search"]["step_size"].GetDouble()
-        self.max_iterations = self.algorithm_settings["max_iterations"].GetInt() + 1
-        self.relative_tolerance = self.algorithm_settings["relative_tolerance"].GetDouble()
-
-        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.SEARCH_DIRECTION)
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.CORRECTION)
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.DP1DX)
-        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.DPF1DX)
-
-        # shape fraction related settings
-        self.penalty_method = self.algorithm_settings["shape_fraction"]["penalty_method"].GetString()
-        self.max_shape_fraction = self.algorithm_settings["shape_fraction"]["max_fraction"].GetDouble()
-        self.frac_tolerance = self.algorithm_settings["shape_fraction"]["nodal_tolerance"].GetDouble()
-        self.inner_tolerance = self.algorithm_settings["shape_fraction"]["inner_tolerance"].GetDouble()
-        self.max_inner_steps = self.algorithm_settings["shape_fraction"]["max_inner_steps"].GetDouble()
-        self.initial_penalty_factor = self.algorithm_settings["shape_fraction"]["initial_penalty_factor"].GetDouble()
-        self.gamma = self.algorithm_settings["shape_fraction"]["penalty_scale_factor"].GetDouble()
-        if self.gamma <= 1.0:
-            raise RuntimeError("Shape fraction algorithm: 'penalty_scale_factor' has to be larger than 1.0!")
-        self.inner_step = 0
-        self.penalty_factor = 0.0
-        self.epsilon = -0.2
-        self.previous_objective_value = None
-
-    # --------------------------------------------------------------------------
-    def CheckApplicability(self):
-        if self.objectives.size() > 1:
-            raise RuntimeError("Shape fraction algorithm only supports one objective function!")
-
-    # --------------------------------------------------------------------------
-    def InitializeOptimizationLoop(self):
-        self.model_part_controller.Initialize()
-
-        self.analyzer.InitializeBeforeOptimizationLoop()
-
-        self.design_surface = self.model_part_controller.GetDesignSurface()
-
-        self.mapper = mapper_factory.CreateMapper(self.design_surface, self.design_surface, self.mapper_settings)
-        self.mapper.Initialize()
-        self.model_part_controller.InitializeDamping()
-
-        self.data_logger = data_logger_factory.CreateDataLogger(self.model_part_controller, self.communicator, self.optimization_settings)
-        self.data_logger.InitializeDataLogging()
-
-        self.optimization_utilities = KSO.OptimizationUtilities
-
-    # --------------------------------------------------------------------------
-    def RunOptimizationLoop(self):
-        timer = Timer()
-        timer.StartTimer()
-
-        for self.optimization_iteration in range(1,self.max_iterations):
-            Kratos.Logger.Print("")
-            Kratos.Logger.Print("===============================================================================")
-            Kratos.Logger.PrintInfo("ShapeOpt", timer.GetTimeStamp(), ": Starting optimization iteration ", self.optimization_iteration)
-            Kratos.Logger.Print("===============================================================================\n")
-
-            timer.StartNewLap()
-
-            self.__initializeNewShape()
-
-            self.__analyzeShape()
-
-            self.__computeShapeUpdate()
-
-            self.__logCurrentOptimizationStep()
-
-            Kratos.Logger.Print("")
-            Kratos.Logger.PrintInfo("ShapeOpt", "Time needed for current optimization step = ", timer.GetLapTime(), "s")
-            Kratos.Logger.PrintInfo("ShapeOpt", "Time needed for total optimization so far = ", timer.GetTotalTime(), "s")
-
-            if self.__isAlgorithmConverged():
-                break
-            else:
-                self.__determineAbsoluteChanges()
-
-    # --------------------------------------------------------------------------
-    def FinalizeOptimizationLoop(self):
-        self.data_logger.FinalizeDataLogging()
-        self.analyzer.FinalizeAfterOptimizationLoop()
-
-    # --------------------------------------------------------------------------
-    def __initializeNewShape(self):
-        self.model_part_controller.UpdateTimeStep(self.optimization_iteration)
-        self.model_part_controller.UpdateMeshAccordingInputVariable(KSO.SHAPE_UPDATE)
-        self.model_part_controller.SetReferenceMeshToMesh()
-
-    # --------------------------------------------------------------------------
-    def __analyzeShape(self):
-        self.communicator.initializeCommunication()
-        self.communicator.requestValueOf(self.objectives[0]["identifier"].GetString())
-        self.communicator.requestGradientOf(self.objectives[0]["identifier"].GetString())
-
-        for constraint in self.constraints.values():
-            con_id =  constraint["identifier"].GetString()
-            self.communicator.requestValueOf(con_id)
-            self.communicator.requestGradientOf(con_id)
-
-        self.analyzer.AnalyzeDesignAndReportToCommunicator(self.optimization_model_part, self.optimization_iteration, self.communicator)
-
-        # compute normals only if required
-        surface_normals_required = self.objectives[0]["project_gradient_on_surface_normals"].GetBool()
-        for constraint in self.constraints.values():
-            if constraint["project_gradient_on_surface_normals"].GetBool():
-                surface_normals_required = True
-
-        if surface_normals_required:
-            self.model_part_controller.ComputeUnitSurfaceNormals()
-
-        # objective value
-        objective_value = self.communicator.getStandardizedValue(self.objectives[0]["identifier"].GetString())
-
-        # objective gradient
-        objGradientDict = self.communicator.getStandardizedGradient(self.objectives[0]["identifier"].GetString())
-        WriteDictionaryDataOnNodalVariable(objGradientDict, self.optimization_model_part, KSO.DF1DX)
-        objective_gradient = Kratos.Vector()
-        self.optimization_utilities.AssembleVector(self.optimization_model_part, objective_gradient, KSO.DF1DX)
-        objective_gradient_norm = objective_gradient.norm_2()
-
-        # response value g of penalty method
-        response_value = self.__computeResponseValue()
-        Kratos.Logger.PrintInfo("ShapeFractionOptimization", f"Shape Fraction value = {response_value}")
-        # penalty value
-        # exterior:             p = max(0, g)**2
-        # extended interior:    p = -1/g                            if g =< epsilon (interior penalty)
-        #                       p = - 2*epsilon - g / epsilon**2    if g > epsilon  (exterior penalty)
-        self.penalty_value = self.__computePenaltyValue(response_value)
-
-        # set up initial penalty factor
-        if self.penalty_factor == 0.0:
-            self.__SetUpInitialPenaltyFactor(objective_value, objective_gradient_norm)
-        self.__IncrementInnerStep()
-
-        # pseudo objective value
-        pseudo_objective_value = self.__computePseudoObjectiveValue(objective_value)
-
-        # check inner convergence
-        inner_converged = self.__checkInnerConvergence(pseudo_objective_value)
-        # update penalty factor if inner loop converged
-        if inner_converged:
-            Kratos.Logger.PrintInfo("ShapeFractionOptimization", "Updating penalty factor.")
-            self.__updatePenaltyFactor()
-
-        # update pseudo objective value
-        self.pseudo_objective_value = self.__computePseudoObjectiveValue(objective_value)
-
-        # compute penalty gradient
-        # exterior:             p = 2 * g * dg/dx
-        # extended interior:    p = -1/g                            if g =< epsilon (interior penalty)
-        #                       p = - 2*epsilon - g / epsilon**2    if g > epsilon  (exterior penalty)
-        penalty_gradient = self.__computePenaltyGradient(response_value)
-        self.optimization_utilities.AssignVectorToVariable(self.optimization_model_part, penalty_gradient, KSO.DP1DX)
-
-        # pseudo objective gradient
-        pseudo_objective_gradient = objective_gradient + self.penalty_factor * penalty_gradient
-        self.optimization_utilities.AssignVectorToVariable(self.optimization_model_part, pseudo_objective_gradient, KSO.DPF1DX)
-
-        # project and damp objective gradients
-        if self.objectives[0]["project_gradient_on_surface_normals"].GetBool():
-            self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(KSO.DPF1DX)
-
-        self.model_part_controller.DampNodalSensitivityVariableIfSpecified(KSO.DPF1DX)
-
-        # project and damp constraint gradients
-        for constraint in self.constraints.values():
-            con_id = constraint["identifier"].GetString()
-            conGradientDict = self.communicator.getStandardizedGradient(con_id)
-            gradient_variable = self.constraint_gradient_variables[con_id]["gradient"]
-            WriteDictionaryDataOnNodalVariable(conGradientDict, self.optimization_model_part, gradient_variable)
-
-            if constraint["project_gradient_on_surface_normals"].GetBool():
-                self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(gradient_variable)
-
-            self.model_part_controller.DampNodalSensitivityVariableIfSpecified(gradient_variable)
-
-    # --------------------------------------------------------------------------
-    def __computePenaltyValue(self, response_value):
-
-        if self.penalty_method == "extended_interior":
-            g = response_value
-            if g > self.epsilon:
-                penalty_value = - (2*self.epsilon - g) / self.epsilon**2
-            else:
-                penalty_value = - 1 / g
-
-        elif self.penalty_method == "exterior":
-            penalty_value = response_value
-
-        return penalty_value
-
-    # --------------------------------------------------------------------------
-    def __computeResponseValue(self):
-
-        def __calculateNodalValueExterior(self, node, quantile):
-            shape_change = node.GetSolutionStepValue(KSO.SHAPE_CHANGE)
-            norm = cm.Norm2(shape_change)
-
-            if norm > quantile:
-                return 0.0
-
-            if norm > self.frac_tolerance:
-                return norm
-            else:
-                return 0.0
-
-        def __calculateNodalValueExtendedInterior(self, node, quantile):
-            shape_change = node.GetSolutionStepValue(KSO.SHAPE_CHANGE)
-            norm = cm.Norm2(shape_change)
-
-            if norm > quantile:
-                return 0.0
-            else:
-                return norm
-
-        def __calculateIntegralToleranceOfNode(self, node, quantile):
-            shape_change = node.GetSolutionStepValue(KSO.SHAPE_CHANGE)
-            norm = cm.Norm2(shape_change)
-
-            if norm > quantile:
-                return 0.0
-            else:
-                return norm
-
-        Kratos.Logger.PrintInfo("ShapeFractionOptimization", "Starting calculation of penalty response value:")
-
-        startTime = timer.time()
-        total_integral = 0.0
-        integral_tol = 0.0
-        quantile = self.__getQuantile()
-        for node in self.design_surface.Nodes:
-
-            if self.penalty_method == "exterior":
-                g_i = __calculateNodalValueExterior(self, node, quantile)
-            elif self.penalty_method == "extended_interior":
-                g_i = __calculateNodalValueExtendedInterior(self, node, quantile)
-                g_tol_i = __calculateIntegralToleranceOfNode(self, node, quantile)
-                integral_tol += g_tol_i
-
-            total_integral += g_i
-
-        if self.penalty_method == "extended_interior":
-            g = total_integral - integral_tol
-
-        elif self.penalty_method == "exterior":
-            g = total_integral
-
-        Kratos.Logger.PrintInfo("ShapeFractionOptimization", "Time needed for calculating the penalty response value = ",round(timer.time() - startTime,2),"s")
-
-        return g
-
-
-    # --------------------------------------------------------------------------
-    def __computePenaltyGradient(self, penalty_value):
-
-        def __calculateNodalGradient(self, node, quantile):
-            shape_change = node.GetSolutionStepValue(KSO.SHAPE_CHANGE)
-            norm = cm.Norm2(shape_change)
-
-            if norm > self.frac_tolerance:
-                if norm > quantile:
-                    return [0.0, 0.0, 0.0]
-                else:
-                    return [
-                        shape_change[0] / norm,
-                        shape_change[1] / norm,
-                        shape_change[2] / norm
-                    ]
-            else:
-                return [0.0, 0.0, 0.0]
-
-        Kratos.Logger.PrintInfo("ShapeFractionOptimization", "Starting calculation of penalty gradient:")
-
-        startTime = timer.time()
-        penalty_gradient = Kratos.Vector(3*len(self.design_surface.Nodes))
-        quantile = self.__getQuantile()
-
-        for i, node in enumerate(self.design_surface.Nodes):
-            if self.penalty_method == "exterior":
-                if penalty_value > 0.0:
-                    gradient_i = __calculateNodalGradient(self, node, quantile)
-                else:
-                    gradient_i = [0.0, 0.0, 0.0]
-
-            elif self.penalty_method == "extended_interior":
-                gradient_i = __calculateNodalGradient(self, node, quantile)
-                if penalty_value > self.epsilon:
-                    gradient_i[0] /= self.epsilon**2
-                    gradient_i[1] /= self.epsilon**2
-                    gradient_i[2] /= self.epsilon**2
-                else:
-                    gradient_i[0] /= penalty_value**2
-                    gradient_i[1] /= penalty_value**2
-                    gradient_i[2] /= penalty_value**2
-
-            penalty_gradient[3*i:3*i+3] = gradient_i
-
-        Kratos.Logger.PrintInfo("ShapeFractionOptimization", "Time needed for calculating the penalty gradient = ",round(timer.time() - startTime,2),"s")
-
-        return penalty_gradient
-
-    def __getQuantile(self):
-
-        nodal_variable = Kratos.KratosGlobals.GetVariable("SHAPE_CHANGE")
-        shape_change = ReadNodalVariableToList(self.design_surface, nodal_variable)
-
-        shape_change_norm = []
-
-        for i in range(int(len(shape_change)/3)):
-            shape_change_norm.append(cm.Norm2(shape_change[3*i:3*i+3]))
-
-        shape_change_norm.sort()
-
-        index = round(len(shape_change_norm)*(1-self.max_shape_fraction))
-
-        quantile = shape_change_norm[index]
-
-        Kratos.Logger.PrintInfo(f"ShapeFractionOptimization: Shape change quantile {(1-self.max_shape_fraction)} = {quantile}")
-
-        return quantile
-
-    def __computeShapeFraction(self):
-
-        n_active = 0
-        for node in self.design_surface.Nodes:
-            shape_change = node.GetSolutionStepValue(KSO.SHAPE_CHANGE)
-            norm = cm.Norm2(shape_change)
-
-            if norm > self.frac_tolerance:
-                n_active += 1
-
-        total_nodes = len(self.design_surface.Nodes)
-
-        shape_fraction = n_active / total_nodes
-
-        return shape_fraction
-
-    def __computePseudoObjectiveValue(self, objective_value):
-        if self.penalty_method == "exterior":
-            pseudo_objective_value = objective_value + self.penalty_factor * max(0, self.penalty_value)**2
-        elif self.penalty_method == "extended_interior":
-            pseudo_objective_value = objective_value + self.penalty_factor * self.penalty_value
-
-        return pseudo_objective_value
-
-    # --------------------------------------------------------------------------
-    def __IncrementInnerStep(self):
-        if self.penalty_method == "exterior" and self.penalty_value > 0:
-            self.inner_step += 1
-        elif self.penalty_method == "extended_interior":
-            self.inner_step += 1
-
-    # --------------------------------------------------------------------------
-    def __checkInnerConvergence(self, objective_value):
-
-        tolerance = self.inner_tolerance
-
-        is_converged = False
-        if self.previous_objective_value is None:
-            self.reference_objective_value = objective_value
-            self.previous_objective_value = objective_value
-            self.relative_change = 0
-        elif self.inner_step >= self.max_inner_steps:
-            self.previous_objective_value = objective_value
-            is_converged = True
-        else:
-            self.relative_change = (objective_value - self.previous_objective_value) / self.reference_objective_value
-            if abs(self.relative_change) < tolerance:
-                is_converged = True
-
-            self.previous_objective_value = objective_value
-
-        if is_converged:
-            self.inner_step = 0
-            self.reference_objective_value = objective_value
-
-        return is_converged
-
-    # --------------------------------------------------------------------------
-    def __SetUpInitialPenaltyFactor(self, objective_value, objective_gradient_norm):
-        if self.penalty_method == "exterior":
-            # compute penalty gradients for start penalty factor
-            penalty_gradient = self.__computePenaltyGradient(self.penalty_value)
-            penalty_gradient_norm = penalty_gradient.norm_2()
-            if penalty_gradient_norm > 0:
-                self.penalty_factor = self.initial_penalty_factor * objective_gradient_norm / penalty_gradient_norm
-        elif self.penalty_method == "extended_interior":
-            self.penalty_factor = self.initial_penalty_factor * abs(objective_value / self.penalty_value)
-            a = 0.5
-            self.C = - self.epsilon / (self.penalty_factor**a)
-
-    # --------------------------------------------------------------------------
-    def __updatePenaltyFactor(self):
-
-        if self.penalty_method == "exterior" and self.penalty_value > 0.0:
-            self.penalty_factor *= self.gamma # increase penalty factor by 25%
-
-        elif self.penalty_method == "extended_interior":
-            self.penalty_factor *= self.gamma # increase penalty factor by 25%
-            a = 0.5
-            self.epsilon = - self.C * (self.penalty_factor**a)
-
-        Kratos.Logger.PrintInfo("ShapeOpt", f"New penalty factor = {self.penalty_factor}")
-
-    # --------------------------------------------------------------------------
-    def __computeShapeUpdate(self):
-        self.mapper.Update()
-        self.mapper.InverseMap(KSO.DPF1DX, KSO.DF1DX_MAPPED)
-
-        for constraint in self.constraints.values():
-            con_id = constraint["identifier"].GetString()
-            gradient_variable = self.constraint_gradient_variables[con_id]["gradient"]
-            mapped_gradient_variable = self.constraint_gradient_variables[con_id]["mapped_gradient"]
-            self.mapper.InverseMap(gradient_variable, mapped_gradient_variable)
-
-        self.__computeControlPointUpdate()
-
-        self.mapper.Map(KSO.CONTROL_POINT_UPDATE, KSO.SHAPE_UPDATE)
-        self.model_part_controller.DampNodalUpdateVariableIfSpecified(KSO.SHAPE_UPDATE)
-
-    # --------------------------------------------------------------------------
-    def __computeControlPointUpdate(self):
-        """adapted from https://msulaiman.org/onewebmedia/GradProj_2.pdf"""
-        g_a, g_a_variables = self.__getActiveConstraints()
-
-        Kratos.Logger.PrintInfo("ShapeOpt", "Assemble vector of objective gradient.")
-        nabla_f = Kratos.Vector()
-        self.optimization_utilities.AssembleVector(self.design_surface, nabla_f, KSO.DF1DX_MAPPED)
-
-        s = Kratos.Vector()
-
-        if len(g_a) == 0:
-            Kratos.Logger.PrintInfo("ShapeOpt", "No constraints active, use negative objective gradient as search direction.")
-            s = nabla_f * (-1.0)
-            s *= self.step_size / s.norm_inf()
-            self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.SEARCH_DIRECTION)
-            self.optimization_utilities.AssignVectorToVariable(self.design_surface, [0.0]*len(s), KSO.CORRECTION)
-            self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.CONTROL_POINT_UPDATE)
-            return
-
-
-        Kratos.Logger.PrintInfo("ShapeOpt", "Assemble matrix of constraint gradient.")
-        N = Kratos.Matrix()
-        self.optimization_utilities.AssembleMatrix(self.design_surface, N, g_a_variables)
-
-        settings = Kratos.Parameters('{ "solver_type" : "LinearSolversApplication.dense_col_piv_householder_qr" }')
-        solver = dense_linear_solver_factory.ConstructSolver(settings)
-
-        Kratos.Logger.PrintInfo("ShapeOpt", "Calculate projected search direction and correction.")
-        c = Kratos.Vector()
-        self.optimization_utilities.CalculateProjectedSearchDirectionAndCorrection(
-            nabla_f,
-            N,
-            g_a,
-            solver,
-            s,
-            c)
-
-        if c.norm_inf() != 0.0:
-            if c.norm_inf() <= self.max_correction_share * self.step_size:
-                delta = self.step_size - c.norm_inf()
-                s *= delta/s.norm_inf()
-            else:
-                Kratos.Logger.PrintWarning("ShapeOpt", f"Correction is scaled down from {c.norm_inf()} to {self.max_correction_share * self.step_size}.")
-                c *= self.max_correction_share * self.step_size / c.norm_inf()
-                s *= (1.0 - self.max_correction_share) * self.step_size / s.norm_inf()
-        else:
-            s *= self.step_size / s.norm_inf()
-
-        self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.SEARCH_DIRECTION)
-        self.optimization_utilities.AssignVectorToVariable(self.design_surface, c, KSO.CORRECTION)
-        self.optimization_utilities.AssignVectorToVariable(self.design_surface, s+c, KSO.CONTROL_POINT_UPDATE)
-
-    # --------------------------------------------------------------------------
-    def __getActiveConstraints(self):
-        active_constraint_values = []
-        active_constraint_variables = []
-
-        for constraint in self.constraints.values():
-            if self.__isConstraintActive(constraint):
-                identifier = constraint["identifier"].GetString()
-                constraint_value = self.communicator.getStandardizedValue(identifier)
-                active_constraint_values.append(constraint_value)
-                active_constraint_variables.append(
-                    self.constraint_gradient_variables[identifier]["mapped_gradient"])
-
-        return active_constraint_values, active_constraint_variables
-
-    # --------------------------------------------------------------------------
-    def __isConstraintActive(self, constraint):
-        identifier = constraint["identifier"].GetString()
-        constraint_value = self.communicator.getStandardizedValue(identifier)
-        if constraint["type"].GetString() == "=" or constraint_value >= 0:
-            gradient_norm = self.optimization_utilities.ComputeMaxNormOfNodalVariable(
-                self.design_surface, self.constraint_gradient_variables[identifier]["mapped_gradient"]
-            )
-            if math.isclose(gradient_norm, 0.0, abs_tol=1e-16):
-                Kratos.Logger.PrintWarning("ShapeOpt", f"Gradient for constraint {identifier} is 0.0 - will not be considered!")
-                return False
-            return True
-        else:
-            return False
-
-    # --------------------------------------------------------------------------
-    def __logCurrentOptimizationStep(self):
-        additional_values_to_log = {}
-        additional_values_to_log["penalty_value"] = self.penalty_value
-        additional_values_to_log["penalty_factor"] = self.penalty_factor
-        additional_values_to_log["f_p"] = self.pseudo_objective_value
-        additional_values_to_log["df_rel_p"] = self.relative_change
-        additional_values_to_log["shape_fraction"] = self.__computeShapeFraction()
-        additional_values_to_log["step_size"] = self.step_size
-        additional_values_to_log["inf_norm_s"] = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.SEARCH_DIRECTION)
-        additional_values_to_log["inf_norm_c"] = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.CORRECTION)
-        self.data_logger.LogCurrentValues(self.optimization_iteration, additional_values_to_log)
-        self.data_logger.LogCurrentDesign(self.optimization_iteration)
-
-    # --------------------------------------------------------------------------
-    def __isAlgorithmConverged(self):
-
-        if self.optimization_iteration > 1 :
-
-            # Check if maximum iterations were reached
-            if self.optimization_iteration == self.max_iterations:
-                Kratos.Logger.Print("")
-                Kratos.Logger.PrintInfo("ShapeOpt", "Maximal iterations of optimization problem reached!")
-                return True
-
-            # Check for relative tolerance
-            relative_change_of_objective_value = self.data_logger.GetValues("rel_change_objective")[self.optimization_iteration]
-            if abs(relative_change_of_objective_value) < self.relative_tolerance:
-                Kratos.Logger.Print("")
-                Kratos.Logger.PrintInfo("ShapeOpt", "Optimization problem converged within a relative objective tolerance of ",self.relative_tolerance,"%.")
-                return True
-
-    # --------------------------------------------------------------------------
-    def __determineAbsoluteChanges(self):
-        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.CONTROL_POINT_UPDATE, KSO.CONTROL_POINT_CHANGE)
-        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.SHAPE_UPDATE, KSO.SHAPE_CHANGE)
-
-# ==============================================================================
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Schmölz David, https://github.com/dschmoelz
+#
+# ==============================================================================
+
+# Making KratosMultiphysics backward compatible with python 2.6 and 2.7
+from __future__ import print_function, absolute_import, division
+
+# Kratos Core and Apps
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+from KratosMultiphysics.LinearSolversApplication import dense_linear_solver_factory
+
+# Additional imports
+from KratosMultiphysics.ShapeOptimizationApplication.utilities import custom_math as cm
+from KratosMultiphysics.ShapeOptimizationApplication.algorithms.algorithm_base import OptimizationAlgorithm
+from KratosMultiphysics.ShapeOptimizationApplication import mapper_factory
+from KratosMultiphysics.ShapeOptimizationApplication.loggers import data_logger_factory
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_timer import Timer
+from KratosMultiphysics.ShapeOptimizationApplication.utilities.custom_variable_utilities import WriteDictionaryDataOnNodalVariable, ReadNodalVariableToList
+
+import math
+import time as timer
+
+# ==============================================================================
+class AlgorithmShapeFractionOptimization(OptimizationAlgorithm):
+    # --------------------------------------------------------------------------
+    def __init__(self, optimization_settings, analyzer, communicator, model_part_controller):
+        default_algorithm_settings = Kratos.Parameters("""
+        {
+            "name"                    : "shape_fraction_optimization",
+            "max_correction_share"    : 0.75,
+            "max_iterations"          : 100,
+            "relative_tolerance"      : 1e-3,
+            "shape_fraction" : {
+                "penalty_method"      : "exterior",
+                "max_fraction"        : 0.5,
+                "nodal_tolerance"     : 0.1,
+                "inner_tolerance"     : 0.01,
+                "max_inner_steps"     : 10,
+                "initial_penalty_factor": 0.1,
+                "penalty_scale_factor": 1.25
+            },
+            "line_search" : {
+                "line_search_type"           : "manual_stepping",
+                "normalize_search_direction" : true,
+                "step_size"                  : 1.0
+            }
+        }""")
+        self.algorithm_settings =  optimization_settings["optimization_algorithm"]
+        self.algorithm_settings.RecursivelyValidateAndAssignDefaults(default_algorithm_settings)
+
+        self.optimization_settings = optimization_settings
+        self.mapper_settings = optimization_settings["design_variables"]["filter"]
+
+        self.analyzer = analyzer
+        self.communicator = communicator
+        self.model_part_controller = model_part_controller
+
+        self.design_surface = None
+        self.mapper = None
+        self.data_logger = None
+        self.optimization_utilities = None
+
+        self.objectives = optimization_settings["objectives"]
+        self.constraints = optimization_settings["constraints"]
+        self.constraint_gradient_variables = {}
+        for itr, constraint in enumerate(self.constraints.values()):
+            self.constraint_gradient_variables.update({
+                constraint["identifier"].GetString() : {
+                    "gradient": Kratos.KratosGlobals.GetVariable("DC"+str(itr+1)+"DX"),
+                    "mapped_gradient": Kratos.KratosGlobals.GetVariable("DC"+str(itr+1)+"DX_MAPPED")
+                }
+            })
+        self.max_correction_share = self.algorithm_settings["max_correction_share"].GetDouble()
+
+        self.step_size = self.algorithm_settings["line_search"]["step_size"].GetDouble()
+        self.max_iterations = self.algorithm_settings["max_iterations"].GetInt() + 1
+        self.relative_tolerance = self.algorithm_settings["relative_tolerance"].GetDouble()
+
+        self.optimization_model_part = model_part_controller.GetOptimizationModelPart()
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.SEARCH_DIRECTION)
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.CORRECTION)
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.DP1DX)
+        self.optimization_model_part.AddNodalSolutionStepVariable(KSO.DPF1DX)
+
+        # shape fraction related settings
+        self.penalty_method = self.algorithm_settings["shape_fraction"]["penalty_method"].GetString()
+        self.max_shape_fraction = self.algorithm_settings["shape_fraction"]["max_fraction"].GetDouble()
+        self.frac_tolerance = self.algorithm_settings["shape_fraction"]["nodal_tolerance"].GetDouble()
+        self.inner_tolerance = self.algorithm_settings["shape_fraction"]["inner_tolerance"].GetDouble()
+        self.max_inner_steps = self.algorithm_settings["shape_fraction"]["max_inner_steps"].GetDouble()
+        self.initial_penalty_factor = self.algorithm_settings["shape_fraction"]["initial_penalty_factor"].GetDouble()
+        self.gamma = self.algorithm_settings["shape_fraction"]["penalty_scale_factor"].GetDouble()
+        if self.gamma <= 1.0:
+            raise RuntimeError("Shape fraction algorithm: 'penalty_scale_factor' has to be larger than 1.0!")
+        self.inner_step = 0
+        self.penalty_factor = 0.0
+        self.epsilon = -0.2
+        self.previous_objective_value = None
+
+    # --------------------------------------------------------------------------
+    def CheckApplicability(self):
+        if self.objectives.size() > 1:
+            raise RuntimeError("Shape fraction algorithm only supports one objective function!")
+
+    # --------------------------------------------------------------------------
+    def InitializeOptimizationLoop(self):
+        self.model_part_controller.Initialize()
+
+        self.analyzer.InitializeBeforeOptimizationLoop()
+
+        self.design_surface = self.model_part_controller.GetDesignSurface()
+
+        self.mapper = mapper_factory.CreateMapper(self.design_surface, self.design_surface, self.mapper_settings)
+        self.mapper.Initialize()
+        self.model_part_controller.InitializeDamping()
+
+        self.data_logger = data_logger_factory.CreateDataLogger(self.model_part_controller, self.communicator, self.optimization_settings)
+        self.data_logger.InitializeDataLogging()
+
+        self.optimization_utilities = KSO.OptimizationUtilities
+
+    # --------------------------------------------------------------------------
+    def RunOptimizationLoop(self):
+        timer = Timer()
+        timer.StartTimer()
+
+        for self.optimization_iteration in range(1,self.max_iterations):
+            Kratos.Logger.Print("")
+            Kratos.Logger.Print("===============================================================================")
+            Kratos.Logger.PrintInfo("ShapeOpt", timer.GetTimeStamp(), ": Starting optimization iteration ", self.optimization_iteration)
+            Kratos.Logger.Print("===============================================================================\n")
+
+            timer.StartNewLap()
+
+            self.__initializeNewShape()
+
+            self.__analyzeShape()
+
+            self.__computeShapeUpdate()
+
+            self.__logCurrentOptimizationStep()
+
+            Kratos.Logger.Print("")
+            Kratos.Logger.PrintInfo("ShapeOpt", "Time needed for current optimization step = ", timer.GetLapTime(), "s")
+            Kratos.Logger.PrintInfo("ShapeOpt", "Time needed for total optimization so far = ", timer.GetTotalTime(), "s")
+
+            if self.__isAlgorithmConverged():
+                break
+            else:
+                self.__determineAbsoluteChanges()
+
+    # --------------------------------------------------------------------------
+    def FinalizeOptimizationLoop(self):
+        self.data_logger.FinalizeDataLogging()
+        self.analyzer.FinalizeAfterOptimizationLoop()
+
+    # --------------------------------------------------------------------------
+    def __initializeNewShape(self):
+        self.model_part_controller.UpdateTimeStep(self.optimization_iteration)
+        self.model_part_controller.UpdateMeshAccordingInputVariable(KSO.SHAPE_UPDATE)
+        self.model_part_controller.SetReferenceMeshToMesh()
+
+    # --------------------------------------------------------------------------
+    def __analyzeShape(self):
+        self.communicator.initializeCommunication()
+        self.communicator.requestValueOf(self.objectives[0]["identifier"].GetString())
+        self.communicator.requestGradientOf(self.objectives[0]["identifier"].GetString())
+
+        for constraint in self.constraints.values():
+            con_id =  constraint["identifier"].GetString()
+            self.communicator.requestValueOf(con_id)
+            self.communicator.requestGradientOf(con_id)
+
+        self.analyzer.AnalyzeDesignAndReportToCommunicator(self.optimization_model_part, self.optimization_iteration, self.communicator)
+
+        # compute normals only if required
+        surface_normals_required = self.objectives[0]["project_gradient_on_surface_normals"].GetBool()
+        for constraint in self.constraints.values():
+            if constraint["project_gradient_on_surface_normals"].GetBool():
+                surface_normals_required = True
+
+        if surface_normals_required:
+            self.model_part_controller.ComputeUnitSurfaceNormals()
+
+        # objective value
+        objective_value = self.communicator.getStandardizedValue(self.objectives[0]["identifier"].GetString())
+
+        # objective gradient
+        objGradientDict = self.communicator.getStandardizedGradient(self.objectives[0]["identifier"].GetString())
+        WriteDictionaryDataOnNodalVariable(objGradientDict, self.optimization_model_part, KSO.DF1DX)
+        objective_gradient = Kratos.Vector()
+        self.optimization_utilities.AssembleVector(self.optimization_model_part, objective_gradient, KSO.DF1DX)
+        objective_gradient_norm = objective_gradient.norm_2()
+
+        # response value g of penalty method
+        response_value = self.__computeResponseValue()
+        Kratos.Logger.PrintInfo("ShapeFractionOptimization", f"Shape Fraction value = {response_value}")
+        # penalty value
+        # exterior:             p = max(0, g)**2
+        # extended interior:    p = -1/g                            if g =< epsilon (interior penalty)
+        #                       p = - 2*epsilon - g / epsilon**2    if g > epsilon  (exterior penalty)
+        self.penalty_value = self.__computePenaltyValue(response_value)
+
+        # set up initial penalty factor
+        if self.penalty_factor == 0.0:
+            self.__SetUpInitialPenaltyFactor(objective_value, objective_gradient_norm)
+        self.__IncrementInnerStep()
+
+        # pseudo objective value
+        pseudo_objective_value = self.__computePseudoObjectiveValue(objective_value)
+
+        # check inner convergence
+        inner_converged = self.__checkInnerConvergence(pseudo_objective_value)
+        # update penalty factor if inner loop converged
+        if inner_converged:
+            Kratos.Logger.PrintInfo("ShapeFractionOptimization", "Updating penalty factor.")
+            self.__updatePenaltyFactor()
+
+        # update pseudo objective value
+        self.pseudo_objective_value = self.__computePseudoObjectiveValue(objective_value)
+
+        # compute penalty gradient
+        # exterior:             p = 2 * g * dg/dx
+        # extended interior:    p = -1/g                            if g =< epsilon (interior penalty)
+        #                       p = - 2*epsilon - g / epsilon**2    if g > epsilon  (exterior penalty)
+        penalty_gradient = self.__computePenaltyGradient(response_value)
+        self.optimization_utilities.AssignVectorToVariable(self.optimization_model_part, penalty_gradient, KSO.DP1DX)
+
+        # pseudo objective gradient
+        pseudo_objective_gradient = objective_gradient + self.penalty_factor * penalty_gradient
+        self.optimization_utilities.AssignVectorToVariable(self.optimization_model_part, pseudo_objective_gradient, KSO.DPF1DX)
+
+        # project and damp objective gradients
+        if self.objectives[0]["project_gradient_on_surface_normals"].GetBool():
+            self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(KSO.DPF1DX)
+
+        self.model_part_controller.DampNodalSensitivityVariableIfSpecified(KSO.DPF1DX)
+
+        # project and damp constraint gradients
+        for constraint in self.constraints.values():
+            con_id = constraint["identifier"].GetString()
+            conGradientDict = self.communicator.getStandardizedGradient(con_id)
+            gradient_variable = self.constraint_gradient_variables[con_id]["gradient"]
+            WriteDictionaryDataOnNodalVariable(conGradientDict, self.optimization_model_part, gradient_variable)
+
+            if constraint["project_gradient_on_surface_normals"].GetBool():
+                self.model_part_controller.ProjectNodalVariableOnUnitSurfaceNormals(gradient_variable)
+
+            self.model_part_controller.DampNodalSensitivityVariableIfSpecified(gradient_variable)
+
+    # --------------------------------------------------------------------------
+    def __computePenaltyValue(self, response_value):
+
+        if self.penalty_method == "extended_interior":
+            g = response_value
+            if g > self.epsilon:
+                penalty_value = - (2*self.epsilon - g) / self.epsilon**2
+            else:
+                penalty_value = - 1 / g
+
+        elif self.penalty_method == "exterior":
+            penalty_value = response_value
+
+        return penalty_value
+
+    # --------------------------------------------------------------------------
+    def __computeResponseValue(self):
+
+        def __calculateNodalValueExterior(self, node, quantile):
+            shape_change = node.GetSolutionStepValue(KSO.SHAPE_CHANGE)
+            norm = cm.Norm2(shape_change)
+
+            if norm > quantile:
+                return 0.0
+
+            if norm > self.frac_tolerance:
+                return norm
+            else:
+                return 0.0
+
+        def __calculateNodalValueExtendedInterior(self, node, quantile):
+            shape_change = node.GetSolutionStepValue(KSO.SHAPE_CHANGE)
+            norm = cm.Norm2(shape_change)
+
+            if norm > quantile:
+                return 0.0
+            else:
+                return norm
+
+        def __calculateIntegralToleranceOfNode(self, node, quantile):
+            shape_change = node.GetSolutionStepValue(KSO.SHAPE_CHANGE)
+            norm = cm.Norm2(shape_change)
+
+            if norm > quantile:
+                return 0.0
+            else:
+                return norm
+
+        Kratos.Logger.PrintInfo("ShapeFractionOptimization", "Starting calculation of penalty response value:")
+
+        startTime = timer.time()
+        total_integral = 0.0
+        integral_tol = 0.0
+        quantile = self.__getQuantile()
+        for node in self.design_surface.Nodes:
+
+            if self.penalty_method == "exterior":
+                g_i = __calculateNodalValueExterior(self, node, quantile)
+            elif self.penalty_method == "extended_interior":
+                g_i = __calculateNodalValueExtendedInterior(self, node, quantile)
+                g_tol_i = __calculateIntegralToleranceOfNode(self, node, quantile)
+                integral_tol += g_tol_i
+
+            total_integral += g_i
+
+        if self.penalty_method == "extended_interior":
+            g = total_integral - integral_tol
+
+        elif self.penalty_method == "exterior":
+            g = total_integral
+
+        Kratos.Logger.PrintInfo("ShapeFractionOptimization", "Time needed for calculating the penalty response value = ",round(timer.time() - startTime,2),"s")
+
+        return g
+
+
+    # --------------------------------------------------------------------------
+    def __computePenaltyGradient(self, penalty_value):
+
+        def __calculateNodalGradient(self, node, quantile):
+            shape_change = node.GetSolutionStepValue(KSO.SHAPE_CHANGE)
+            norm = cm.Norm2(shape_change)
+
+            if norm > self.frac_tolerance:
+                if norm > quantile:
+                    return [0.0, 0.0, 0.0]
+                else:
+                    return [
+                        shape_change[0] / norm,
+                        shape_change[1] / norm,
+                        shape_change[2] / norm
+                    ]
+            else:
+                return [0.0, 0.0, 0.0]
+
+        Kratos.Logger.PrintInfo("ShapeFractionOptimization", "Starting calculation of penalty gradient:")
+
+        startTime = timer.time()
+        penalty_gradient = Kratos.Vector(3*len(self.design_surface.Nodes))
+        quantile = self.__getQuantile()
+
+        for i, node in enumerate(self.design_surface.Nodes):
+            if self.penalty_method == "exterior":
+                if penalty_value > 0.0:
+                    gradient_i = __calculateNodalGradient(self, node, quantile)
+                else:
+                    gradient_i = [0.0, 0.0, 0.0]
+
+            elif self.penalty_method == "extended_interior":
+                gradient_i = __calculateNodalGradient(self, node, quantile)
+                if penalty_value > self.epsilon:
+                    gradient_i[0] /= self.epsilon**2
+                    gradient_i[1] /= self.epsilon**2
+                    gradient_i[2] /= self.epsilon**2
+                else:
+                    gradient_i[0] /= penalty_value**2
+                    gradient_i[1] /= penalty_value**2
+                    gradient_i[2] /= penalty_value**2
+
+            penalty_gradient[3*i:3*i+3] = gradient_i
+
+        Kratos.Logger.PrintInfo("ShapeFractionOptimization", "Time needed for calculating the penalty gradient = ",round(timer.time() - startTime,2),"s")
+
+        return penalty_gradient
+
+    def __getQuantile(self):
+
+        nodal_variable = Kratos.KratosGlobals.GetVariable("SHAPE_CHANGE")
+        shape_change = ReadNodalVariableToList(self.design_surface, nodal_variable)
+
+        shape_change_norm = []
+
+        for i in range(int(len(shape_change)/3)):
+            shape_change_norm.append(cm.Norm2(shape_change[3*i:3*i+3]))
+
+        shape_change_norm.sort()
+
+        index = round(len(shape_change_norm)*(1-self.max_shape_fraction))
+
+        quantile = shape_change_norm[index]
+
+        Kratos.Logger.PrintInfo(f"ShapeFractionOptimization: Shape change quantile {(1-self.max_shape_fraction)} = {quantile}")
+
+        return quantile
+
+    def __computeShapeFraction(self):
+
+        n_active = 0
+        for node in self.design_surface.Nodes:
+            shape_change = node.GetSolutionStepValue(KSO.SHAPE_CHANGE)
+            norm = cm.Norm2(shape_change)
+
+            if norm > self.frac_tolerance:
+                n_active += 1
+
+        total_nodes = len(self.design_surface.Nodes)
+
+        shape_fraction = n_active / total_nodes
+
+        return shape_fraction
+
+    def __computePseudoObjectiveValue(self, objective_value):
+        if self.penalty_method == "exterior":
+            pseudo_objective_value = objective_value + self.penalty_factor * max(0, self.penalty_value)**2
+        elif self.penalty_method == "extended_interior":
+            pseudo_objective_value = objective_value + self.penalty_factor * self.penalty_value
+
+        return pseudo_objective_value
+
+    # --------------------------------------------------------------------------
+    def __IncrementInnerStep(self):
+        if self.penalty_method == "exterior" and self.penalty_value > 0:
+            self.inner_step += 1
+        elif self.penalty_method == "extended_interior":
+            self.inner_step += 1
+
+    # --------------------------------------------------------------------------
+    def __checkInnerConvergence(self, objective_value):
+
+        tolerance = self.inner_tolerance
+
+        is_converged = False
+        if self.previous_objective_value is None:
+            self.reference_objective_value = objective_value
+            self.previous_objective_value = objective_value
+            self.relative_change = 0
+        elif self.inner_step >= self.max_inner_steps:
+            self.previous_objective_value = objective_value
+            is_converged = True
+        else:
+            self.relative_change = (objective_value - self.previous_objective_value) / self.reference_objective_value
+            if abs(self.relative_change) < tolerance:
+                is_converged = True
+
+            self.previous_objective_value = objective_value
+
+        if is_converged:
+            self.inner_step = 0
+            self.reference_objective_value = objective_value
+
+        return is_converged
+
+    # --------------------------------------------------------------------------
+    def __SetUpInitialPenaltyFactor(self, objective_value, objective_gradient_norm):
+        if self.penalty_method == "exterior":
+            # compute penalty gradients for start penalty factor
+            penalty_gradient = self.__computePenaltyGradient(self.penalty_value)
+            penalty_gradient_norm = penalty_gradient.norm_2()
+            if penalty_gradient_norm > 0:
+                self.penalty_factor = self.initial_penalty_factor * objective_gradient_norm / penalty_gradient_norm
+        elif self.penalty_method == "extended_interior":
+            self.penalty_factor = self.initial_penalty_factor * abs(objective_value / self.penalty_value)
+            a = 0.5
+            self.C = - self.epsilon / (self.penalty_factor**a)
+
+    # --------------------------------------------------------------------------
+    def __updatePenaltyFactor(self):
+
+        if self.penalty_method == "exterior" and self.penalty_value > 0.0:
+            self.penalty_factor *= self.gamma # increase penalty factor by 25%
+
+        elif self.penalty_method == "extended_interior":
+            self.penalty_factor *= self.gamma # increase penalty factor by 25%
+            a = 0.5
+            self.epsilon = - self.C * (self.penalty_factor**a)
+
+        Kratos.Logger.PrintInfo("ShapeOpt", f"New penalty factor = {self.penalty_factor}")
+
+    # --------------------------------------------------------------------------
+    def __computeShapeUpdate(self):
+        self.mapper.Update()
+        self.mapper.InverseMap(KSO.DPF1DX, KSO.DF1DX_MAPPED)
+
+        for constraint in self.constraints.values():
+            con_id = constraint["identifier"].GetString()
+            gradient_variable = self.constraint_gradient_variables[con_id]["gradient"]
+            mapped_gradient_variable = self.constraint_gradient_variables[con_id]["mapped_gradient"]
+            self.mapper.InverseMap(gradient_variable, mapped_gradient_variable)
+
+        self.__computeControlPointUpdate()
+
+        self.mapper.Map(KSO.CONTROL_POINT_UPDATE, KSO.SHAPE_UPDATE)
+        self.model_part_controller.DampNodalUpdateVariableIfSpecified(KSO.SHAPE_UPDATE)
+
+    # --------------------------------------------------------------------------
+    def __computeControlPointUpdate(self):
+        """adapted from https://msulaiman.org/onewebmedia/GradProj_2.pdf"""
+        g_a, g_a_variables = self.__getActiveConstraints()
+
+        Kratos.Logger.PrintInfo("ShapeOpt", "Assemble vector of objective gradient.")
+        nabla_f = Kratos.Vector()
+        self.optimization_utilities.AssembleVector(self.design_surface, nabla_f, KSO.DF1DX_MAPPED)
+
+        s = Kratos.Vector()
+
+        if len(g_a) == 0:
+            Kratos.Logger.PrintInfo("ShapeOpt", "No constraints active, use negative objective gradient as search direction.")
+            s = nabla_f * (-1.0)
+            s *= self.step_size / s.norm_inf()
+            self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.SEARCH_DIRECTION)
+            self.optimization_utilities.AssignVectorToVariable(self.design_surface, [0.0]*len(s), KSO.CORRECTION)
+            self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.CONTROL_POINT_UPDATE)
+            return
+
+
+        Kratos.Logger.PrintInfo("ShapeOpt", "Assemble matrix of constraint gradient.")
+        N = Kratos.Matrix()
+        self.optimization_utilities.AssembleMatrix(self.design_surface, N, g_a_variables)
+
+        settings = Kratos.Parameters('{ "solver_type" : "LinearSolversApplication.dense_col_piv_householder_qr" }')
+        solver = dense_linear_solver_factory.ConstructSolver(settings)
+
+        Kratos.Logger.PrintInfo("ShapeOpt", "Calculate projected search direction and correction.")
+        c = Kratos.Vector()
+        self.optimization_utilities.CalculateProjectedSearchDirectionAndCorrection(
+            nabla_f,
+            N,
+            g_a,
+            solver,
+            s,
+            c)
+
+        if c.norm_inf() != 0.0:
+            if c.norm_inf() <= self.max_correction_share * self.step_size:
+                delta = self.step_size - c.norm_inf()
+                s *= delta/s.norm_inf()
+            else:
+                Kratos.Logger.PrintWarning("ShapeOpt", f"Correction is scaled down from {c.norm_inf()} to {self.max_correction_share * self.step_size}.")
+                c *= self.max_correction_share * self.step_size / c.norm_inf()
+                s *= (1.0 - self.max_correction_share) * self.step_size / s.norm_inf()
+        else:
+            s *= self.step_size / s.norm_inf()
+
+        self.optimization_utilities.AssignVectorToVariable(self.design_surface, s, KSO.SEARCH_DIRECTION)
+        self.optimization_utilities.AssignVectorToVariable(self.design_surface, c, KSO.CORRECTION)
+        self.optimization_utilities.AssignVectorToVariable(self.design_surface, s+c, KSO.CONTROL_POINT_UPDATE)
+
+    # --------------------------------------------------------------------------
+    def __getActiveConstraints(self):
+        active_constraint_values = []
+        active_constraint_variables = []
+
+        for constraint in self.constraints.values():
+            if self.__isConstraintActive(constraint):
+                identifier = constraint["identifier"].GetString()
+                constraint_value = self.communicator.getStandardizedValue(identifier)
+                active_constraint_values.append(constraint_value)
+                active_constraint_variables.append(
+                    self.constraint_gradient_variables[identifier]["mapped_gradient"])
+
+        return active_constraint_values, active_constraint_variables
+
+    # --------------------------------------------------------------------------
+    def __isConstraintActive(self, constraint):
+        identifier = constraint["identifier"].GetString()
+        constraint_value = self.communicator.getStandardizedValue(identifier)
+        if constraint["type"].GetString() == "=" or constraint_value >= 0:
+            gradient_norm = self.optimization_utilities.ComputeMaxNormOfNodalVariable(
+                self.design_surface, self.constraint_gradient_variables[identifier]["mapped_gradient"]
+            )
+            if math.isclose(gradient_norm, 0.0, abs_tol=1e-16):
+                Kratos.Logger.PrintWarning("ShapeOpt", f"Gradient for constraint {identifier} is 0.0 - will not be considered!")
+                return False
+            return True
+        else:
+            return False
+
+    # --------------------------------------------------------------------------
+    def __logCurrentOptimizationStep(self):
+        additional_values_to_log = {}
+        additional_values_to_log["penalty_value"] = self.penalty_value
+        additional_values_to_log["penalty_factor"] = self.penalty_factor
+        additional_values_to_log["f_p"] = self.pseudo_objective_value
+        additional_values_to_log["df_rel_p"] = self.relative_change
+        additional_values_to_log["shape_fraction"] = self.__computeShapeFraction()
+        additional_values_to_log["step_size"] = self.step_size
+        additional_values_to_log["inf_norm_s"] = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.SEARCH_DIRECTION)
+        additional_values_to_log["inf_norm_c"] = self.optimization_utilities.ComputeMaxNormOfNodalVariable(self.design_surface, KSO.CORRECTION)
+        self.data_logger.LogCurrentValues(self.optimization_iteration, additional_values_to_log)
+        self.data_logger.LogCurrentDesign(self.optimization_iteration)
+
+    # --------------------------------------------------------------------------
+    def __isAlgorithmConverged(self):
+
+        if self.optimization_iteration > 1 :
+
+            # Check if maximum iterations were reached
+            if self.optimization_iteration == self.max_iterations:
+                Kratos.Logger.Print("")
+                Kratos.Logger.PrintInfo("ShapeOpt", "Maximal iterations of optimization problem reached!")
+                return True
+
+            # Check for relative tolerance
+            relative_change_of_objective_value = self.data_logger.GetValues("rel_change_objective")[self.optimization_iteration]
+            if abs(relative_change_of_objective_value) < self.relative_tolerance:
+                Kratos.Logger.Print("")
+                Kratos.Logger.PrintInfo("ShapeOpt", "Optimization problem converged within a relative objective tolerance of ",self.relative_tolerance,"%.")
+                return True
+
+    # --------------------------------------------------------------------------
+    def __determineAbsoluteChanges(self):
+        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.CONTROL_POINT_UPDATE, KSO.CONTROL_POINT_CHANGE)
+        self.optimization_utilities.AddFirstVariableToSecondVariable(self.design_surface, KSO.SHAPE_UPDATE, KSO.SHAPE_CHANGE)
+
+# ==============================================================================
```

## KratosMultiphysics/ShapeOptimizationApplication/__init__.py

 * *Ordering differences only*

```diff
@@ -1,19 +1,19 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
-#
-# ==============================================================================
-
-# ------------------------------------------------------------------------------
-# Imports
-# ------------------------------------------------------------------------------
-from KratosMultiphysics import _ImportApplication
-from KratosShapeOptimizationApplication import *
-application = KratosShapeOptimizationApplication()
-application_name = "KratosShapeOptimizationApplication"
-
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Baumgaertner Daniel, https://github.com/dbaumgaertner
+#
+# ==============================================================================
+
+# ------------------------------------------------------------------------------
+# Imports
+# ------------------------------------------------------------------------------
+from KratosMultiphysics import _ImportApplication
+from KratosShapeOptimizationApplication import *
+application = KratosShapeOptimizationApplication()
+application_name = "KratosShapeOptimizationApplication"
+
 _ImportApplication(application, application_name)
```

## KratosMultiphysics/ShapeOptimizationApplication/mapping/in_plane_vertex_morphing_mapper.py

 * *Ordering differences only*

```diff
@@ -1,140 +1,140 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Geiser Armin, https://github.com/armingeiser
-#
-# ==============================================================================
-
-import KratosMultiphysics as KM
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-try:
-    import KratosMultiphysics.MappingApplication as KMA
-    SpacialMapperFactory = KMA.MapperFactory
-except ImportError:
-    SpacialMapperFactory = None
-from ..custom_ios.wrl_io import WrlIO
-
-class InPlaneVertexMorphingMapper():
-    """
-    The InPlaneVertexMorphingMapper extends the standard Vertex Morphing approach
-    by restricting the shape update of nodes to an in-plane motion only. The nodes
-    are only allowed to float on a predefined background mesh.
-    The background mesh can be the initial mesh of the design surface, or another mesh
-    describing the same geometry (ideally also filling holes in the surface).
-    This is especially important if the design surface extends during the optimization.
-
-    Limitations:
-    - Damping can only be used if all cartesian directions (x,y,z) are damped.
-    - The projection of gradients on the surface normals has to be deactivated.
-    """
-
-    def __init__(self, origin_model_part, destination_model_part, settings):
-        from KratosMultiphysics.ShapeOptimizationApplication import mapper_factory
-        if not SpacialMapperFactory:
-            raise Exception("InPlaneVertexMorphingMapper: MappingApplication is required!")
-
-        self.settings = settings
-        self.origin_model_part = origin_model_part
-        self.destination_model_part = destination_model_part
-
-        extracted_vm_settings = settings.Clone()
-        extracted_vm_settings["in_plane_morphing"].SetBool(False)
-        extracted_vm_settings.RemoveValue("in_plane_morphing_settings")
-        self.vm_mapper = mapper_factory.CreateMapper(origin_model_part, destination_model_part, extracted_vm_settings)
-
-        in_plane_settings = self.settings["in_plane_morphing_settings"]
-        in_plane_settings.RecursivelyValidateAndAssignDefaults(self.GetDefaultInPlaneSettings())
-
-        self._background_model = KM.Model()
-        if in_plane_settings["model_import_settings"]["input_type"].GetString() in ["mdpa", "vrml", "wrl"]:
-            background_main_mesh = self._background_model.CreateModelPart("background_mesh")
-            background_main_mesh.ProcessInfo.SetValue(KM.DOMAIN_SIZE, 3)
-            background_main_mesh.AddNodalSolutionStepVariable(KM.NORMAL)
-            background_main_mesh.AddNodalSolutionStepVariable(KSO.NORMALIZED_SURFACE_NORMAL)
-            background_main_mesh.AddNodalSolutionStepVariable(KSO.BACKGROUND_COORDINATE)
-        else:
-            raise Exception("Other model part input options are not yet implemented.")
-
-        self.background_mesh = None  # created in Initialize
-        self.spacial_mapper = None  # created in Initialize
-
-    @classmethod
-    def GetDefaultInPlaneSettings(cls):
-        return KM.Parameters("""{
-            "model_import_settings" : {
-                "input_type" : "mdpa",
-                "input_filename" : "UNKNOWN_NAME"
-            },
-            "background_sub_model_part_name" : "",
-            "spacial_mapper_settings" : {
-                "mapper_type": "nearest_element",
-                "echo_level" : 0
-            }
-        }""")
-
-    def Initialize(self):
-        self.vm_mapper.Initialize()
-
-        in_plane_settings = self.settings["in_plane_morphing_settings"]
-
-        background_main_mesh = self._background_model.GetModelPart("background_mesh")
-        if in_plane_settings["model_import_settings"]["input_type"].GetString() == "mdpa":
-            model_part_io = KM.ModelPartIO(in_plane_settings["model_import_settings"]["input_filename"].GetString())
-            model_part_io.ReadModelPart(background_main_mesh)
-        elif in_plane_settings["model_import_settings"]["input_type"].GetString() in ["vrml", "wrl"]:
-            model_part_io = WrlIO(in_plane_settings["model_import_settings"]["input_filename"].GetString())
-            model_part_io.ReadModelPart(background_main_mesh)
-
-        background_sub_model_part_name = in_plane_settings["background_sub_model_part_name"].GetString()
-        if background_sub_model_part_name == "":
-            self.background_mesh = background_main_mesh
-        else:
-            self.background_mesh = background_main_mesh.GetSubModelPart(background_sub_model_part_name)
-
-        background_geometry_utilities = KSO.GeometryUtilities(self.background_mesh)
-        background_geometry_utilities.ComputeUnitSurfaceNormals()
-        self.spacial_mapper = SpacialMapperFactory.CreateMapper(
-            self.background_mesh, self.destination_model_part, in_plane_settings["spacial_mapper_settings"])
-
-        KSO.MeshControllerUtilities(self.background_mesh).WriteCoordinatesToVariable(KSO.BACKGROUND_COORDINATE)
-
-    def Update(self):
-        self.vm_mapper.Update()
-        self.spacial_mapper.UpdateInterface()
-        self.spacial_mapper.Map(KSO.NORMALIZED_SURFACE_NORMAL, KSO.BACKGROUND_NORMAL)
-
-    def Map(self, origin_variable, destination_variable):
-        self.vm_mapper.Map(origin_variable, destination_variable)
-
-        geometry_utilities = KSO.GeometryUtilities(self.destination_model_part)
-        geometry_utilities.ProjectNodalVariableOnTangentPlane(
-            destination_variable, KSO.BACKGROUND_NORMAL)
-
-        self._CorrectOutOfPlanePart(destination_variable)
-
-    def InverseMap(self, destination_variable, origin_variable):
-        geometry_utilities = KSO.GeometryUtilities(self.destination_model_part)
-        geometry_utilities.ProjectNodalVariableOnTangentPlane(
-            destination_variable, KSO.BACKGROUND_NORMAL)
-
-        self.vm_mapper.InverseMap(destination_variable, origin_variable)
-
-    def _CorrectOutOfPlanePart(self, destination_variable):
-        geometry_utilities = KSO.GeometryUtilities(self.destination_model_part)
-        mesh_utilities = KSO.MeshControllerUtilities(self.destination_model_part)
-
-        mesh_utilities.UpdateMeshAccordingInputVariable(destination_variable)
-        mesh_utilities.SetReferenceMeshToMesh()
-
-        self.spacial_mapper.UpdateInterface()
-        self.spacial_mapper.Map(KSO.BACKGROUND_COORDINATE, KSO.BACKGROUND_COORDINATE)
-        mesh_utilities.SubtractCoordinatesFromVariable(KSO.BACKGROUND_COORDINATE, KSO.OUT_OF_PLANE_DELTA)
-        geometry_utilities.ProjectNodalVariableOnDirection(KSO.OUT_OF_PLANE_DELTA, KSO.BACKGROUND_NORMAL)
-
-        mesh_utilities.RevertMeshUpdateAccordingInputVariable(destination_variable)
-        mesh_utilities.SetReferenceMeshToMesh()
-
-        mesh_utilities.AddFirstVariableToSecondVariable(KSO.OUT_OF_PLANE_DELTA, destination_variable)
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Geiser Armin, https://github.com/armingeiser
+#
+# ==============================================================================
+
+import KratosMultiphysics as KM
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+try:
+    import KratosMultiphysics.MappingApplication as KMA
+    SpacialMapperFactory = KMA.MapperFactory
+except ImportError:
+    SpacialMapperFactory = None
+from ..custom_ios.wrl_io import WrlIO
+
+class InPlaneVertexMorphingMapper():
+    """
+    The InPlaneVertexMorphingMapper extends the standard Vertex Morphing approach
+    by restricting the shape update of nodes to an in-plane motion only. The nodes
+    are only allowed to float on a predefined background mesh.
+    The background mesh can be the initial mesh of the design surface, or another mesh
+    describing the same geometry (ideally also filling holes in the surface).
+    This is especially important if the design surface extends during the optimization.
+
+    Limitations:
+    - Damping can only be used if all cartesian directions (x,y,z) are damped.
+    - The projection of gradients on the surface normals has to be deactivated.
+    """
+
+    def __init__(self, origin_model_part, destination_model_part, settings):
+        from KratosMultiphysics.ShapeOptimizationApplication import mapper_factory
+        if not SpacialMapperFactory:
+            raise Exception("InPlaneVertexMorphingMapper: MappingApplication is required!")
+
+        self.settings = settings
+        self.origin_model_part = origin_model_part
+        self.destination_model_part = destination_model_part
+
+        extracted_vm_settings = settings.Clone()
+        extracted_vm_settings["in_plane_morphing"].SetBool(False)
+        extracted_vm_settings.RemoveValue("in_plane_morphing_settings")
+        self.vm_mapper = mapper_factory.CreateMapper(origin_model_part, destination_model_part, extracted_vm_settings)
+
+        in_plane_settings = self.settings["in_plane_morphing_settings"]
+        in_plane_settings.RecursivelyValidateAndAssignDefaults(self.GetDefaultInPlaneSettings())
+
+        self._background_model = KM.Model()
+        if in_plane_settings["model_import_settings"]["input_type"].GetString() in ["mdpa", "vrml", "wrl"]:
+            background_main_mesh = self._background_model.CreateModelPart("background_mesh")
+            background_main_mesh.ProcessInfo.SetValue(KM.DOMAIN_SIZE, 3)
+            background_main_mesh.AddNodalSolutionStepVariable(KM.NORMAL)
+            background_main_mesh.AddNodalSolutionStepVariable(KSO.NORMALIZED_SURFACE_NORMAL)
+            background_main_mesh.AddNodalSolutionStepVariable(KSO.BACKGROUND_COORDINATE)
+        else:
+            raise Exception("Other model part input options are not yet implemented.")
+
+        self.background_mesh = None  # created in Initialize
+        self.spacial_mapper = None  # created in Initialize
+
+    @classmethod
+    def GetDefaultInPlaneSettings(cls):
+        return KM.Parameters("""{
+            "model_import_settings" : {
+                "input_type" : "mdpa",
+                "input_filename" : "UNKNOWN_NAME"
+            },
+            "background_sub_model_part_name" : "",
+            "spacial_mapper_settings" : {
+                "mapper_type": "nearest_element",
+                "echo_level" : 0
+            }
+        }""")
+
+    def Initialize(self):
+        self.vm_mapper.Initialize()
+
+        in_plane_settings = self.settings["in_plane_morphing_settings"]
+
+        background_main_mesh = self._background_model.GetModelPart("background_mesh")
+        if in_plane_settings["model_import_settings"]["input_type"].GetString() == "mdpa":
+            model_part_io = KM.ModelPartIO(in_plane_settings["model_import_settings"]["input_filename"].GetString())
+            model_part_io.ReadModelPart(background_main_mesh)
+        elif in_plane_settings["model_import_settings"]["input_type"].GetString() in ["vrml", "wrl"]:
+            model_part_io = WrlIO(in_plane_settings["model_import_settings"]["input_filename"].GetString())
+            model_part_io.ReadModelPart(background_main_mesh)
+
+        background_sub_model_part_name = in_plane_settings["background_sub_model_part_name"].GetString()
+        if background_sub_model_part_name == "":
+            self.background_mesh = background_main_mesh
+        else:
+            self.background_mesh = background_main_mesh.GetSubModelPart(background_sub_model_part_name)
+
+        background_geometry_utilities = KSO.GeometryUtilities(self.background_mesh)
+        background_geometry_utilities.ComputeUnitSurfaceNormals()
+        self.spacial_mapper = SpacialMapperFactory.CreateMapper(
+            self.background_mesh, self.destination_model_part, in_plane_settings["spacial_mapper_settings"])
+
+        KSO.MeshControllerUtilities(self.background_mesh).WriteCoordinatesToVariable(KSO.BACKGROUND_COORDINATE)
+
+    def Update(self):
+        self.vm_mapper.Update()
+        self.spacial_mapper.UpdateInterface()
+        self.spacial_mapper.Map(KSO.NORMALIZED_SURFACE_NORMAL, KSO.BACKGROUND_NORMAL)
+
+    def Map(self, origin_variable, destination_variable):
+        self.vm_mapper.Map(origin_variable, destination_variable)
+
+        geometry_utilities = KSO.GeometryUtilities(self.destination_model_part)
+        geometry_utilities.ProjectNodalVariableOnTangentPlane(
+            destination_variable, KSO.BACKGROUND_NORMAL)
+
+        self._CorrectOutOfPlanePart(destination_variable)
+
+    def InverseMap(self, destination_variable, origin_variable):
+        geometry_utilities = KSO.GeometryUtilities(self.destination_model_part)
+        geometry_utilities.ProjectNodalVariableOnTangentPlane(
+            destination_variable, KSO.BACKGROUND_NORMAL)
+
+        self.vm_mapper.InverseMap(destination_variable, origin_variable)
+
+    def _CorrectOutOfPlanePart(self, destination_variable):
+        geometry_utilities = KSO.GeometryUtilities(self.destination_model_part)
+        mesh_utilities = KSO.MeshControllerUtilities(self.destination_model_part)
+
+        mesh_utilities.UpdateMeshAccordingInputVariable(destination_variable)
+        mesh_utilities.SetReferenceMeshToMesh()
+
+        self.spacial_mapper.UpdateInterface()
+        self.spacial_mapper.Map(KSO.BACKGROUND_COORDINATE, KSO.BACKGROUND_COORDINATE)
+        mesh_utilities.SubtractCoordinatesFromVariable(KSO.BACKGROUND_COORDINATE, KSO.OUT_OF_PLANE_DELTA)
+        geometry_utilities.ProjectNodalVariableOnDirection(KSO.OUT_OF_PLANE_DELTA, KSO.BACKGROUND_NORMAL)
+
+        mesh_utilities.RevertMeshUpdateAccordingInputVariable(destination_variable)
+        mesh_utilities.SetReferenceMeshToMesh()
+
+        mesh_utilities.AddFirstVariableToSecondVariable(KSO.OUT_OF_PLANE_DELTA, destination_variable)
```

## KratosMultiphysics/ShapeOptimizationApplication/mapping/sliding_vertex_morphing_mapper.py

 * *Ordering differences only*

```diff
@@ -1,379 +1,379 @@
-# ==============================================================================
-#  KratosShapeOptimizationApplication
-#
-#  License:         BSD License
-#                   license: ShapeOptimizationApplication/license.txt
-#
-#  Main authors:    Schmoelz David, https://github.com/dschmoelz
-#
-# ==============================================================================
-
-import KratosMultiphysics as KM
-import KratosMultiphysics.ShapeOptimizationApplication as KSO
-try:
-    import KratosMultiphysics.StructuralMechanicsApplication as KSM
-    from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_analysis import StructuralMechanicsAnalysis
-except ImportError:
-    KSM = None
-    StructuralMechanicsAnalysis = None
-SpacialMapperFactory = KM.MapperFactory
-
-from ..custom_ios.wrl_io import WrlIO
-
-class SlidingVertexMorphingMapper():
-    """
-    The SlidingVertexMorphingMapper extends the standard Vertex Morphing approach
-    by restricting the nodal shape update of a specified model part. The nodes of this model
-    part have to lie on a predefined background mesh and are only allowed to float/slide on it.
-    SlidingVertexMorphingMapper uses similar techniques as direction damping and
-    InPlaneVertexMorphingMapper.
-
-    Limitations:
-    - Damping can only be used if all cartesian directions (x,y,z) are damped.
-    - The projection of gradients on the surface normals has to be deactivated.
-    """
-
-    def __init__(self, origin_model_part, destination_model_part, settings):
-        from KratosMultiphysics.ShapeOptimizationApplication import mapper_factory
-        if not SpacialMapperFactory:
-            raise Exception("SlidingVertexMorphingMapper: MappingApplication is required!")
-        if not KSM:
-            raise Exception("SlidingVertexMorphingMapper: StructuralMechanicsApplication is required!")
-
-        self.settings = settings
-        self.origin_model_part = origin_model_part
-        self.destination_model_part = destination_model_part
-
-        extracted_vm_settings = settings.Clone()
-        extracted_vm_settings["sliding_morphing"].SetBool(False)
-        extracted_vm_settings.RemoveValue("sliding_morphing_settings")
-        self.vm_mapper = mapper_factory.CreateMapper(origin_model_part, destination_model_part, extracted_vm_settings)
-
-        in_plane_settings = self.settings["sliding_morphing_settings"]
-        in_plane_settings.RecursivelyValidateAndAssignDefaults(self.GetDefaultInPlaneSettings())
-
-        self._background_model = KM.Model()
-        if in_plane_settings["model_import_settings"]["input_type"].GetString() in ["mdpa", "vrml", "wrl"]:
-            background_main_mesh = self._background_model.CreateModelPart("background_mesh")
-            background_main_mesh.ProcessInfo.SetValue(KM.DOMAIN_SIZE, 3)
-            background_main_mesh.AddNodalSolutionStepVariable(KM.NORMAL)
-            background_main_mesh.AddNodalSolutionStepVariable(KSO.NORMALIZED_SURFACE_NORMAL)
-            background_main_mesh.AddNodalSolutionStepVariable(KSO.BACKGROUND_COORDINATE)
-        else:
-            raise Exception("Other model part input options are not yet implemented.")
-
-        self.background_mesh = None  # created in Initialize
-        self.spacial_mapper = None   # created in Initialize
-        self.sliding_mesh = None     # created in Initialize
-
-    @classmethod
-    def GetDefaultInPlaneSettings(cls):
-        return KM.Parameters("""{
-            "model_import_settings" : {
-                "input_type" : "mdpa",
-                "input_filename" : "UNKNOWN_NAME"
-            },
-            "sliding_sub_model_part_name" : "",
-            "background_sub_model_part_name" : "",
-            "spacial_mapper_settings" : {
-                "mapper_type": "nearest_element",
-                "echo_level" : 0
-            }
-        }""")
-
-    def GetStructuralSimilaritySettings(self):
-        return KM.Parameters(
-        """{
-            "problem_data"    : {
-                "problem_name"    : "structural_similarity",
-                "parallel_type"   : "OpenMP",
-                "start_time"      : 0.0,
-                "end_time"        : 1.0,
-                "echo_level"      : 0
-            },
-            "solver_settings" : {
-                "solver_type"     : "static",
-                "analysis_type"   : "linear",
-                "model_part_name" : "main",
-                "domain_size"     : 3,
-                "time_stepping" : {
-                    "time_step"       : 1.0
-                },
-                "model_import_settings"              : {
-                    "input_type"     : "use_input_model_part"
-                },
-                "rotation_dofs"                      : true
-            },
-            "processes" : {
-                "constraints_process_list" : [
-                {
-                    "python_module" : "assign_vector_variable_process",
-                    "kratos_module" : "KratosMultiphysics",
-                    "help"          : "This process fixes the selected components of a given vector variable",
-                    "process_name"  : "AssignVectorVariableProcess",
-                    "Parameters"    : {
-                        "mesh_id"         : 0,
-                        "model_part_name" : "main.fixed_bc",
-                        "variable_name"   : "DISPLACEMENT",
-                        "value"           : [0.0,0.0,0.0]
-                    }
-                }
-                ]
-            }
-        }""")
-
-    def Initialize(self):
-        self.vm_mapper.Initialize()
-
-        sliding_settings = self.settings["sliding_morphing_settings"]
-
-        background_main_mesh = self._background_model.GetModelPart("background_mesh")
-        if sliding_settings["model_import_settings"]["input_type"].GetString() == "mdpa":
-            model_part_io = KM.ModelPartIO(sliding_settings["model_import_settings"]["input_filename"].GetString())
-            model_part_io.ReadModelPart(background_main_mesh)
-        elif sliding_settings["model_import_settings"]["input_type"].GetString() in ["vrml", "wrl"]:
-            model_part_io = WrlIO(sliding_settings["model_import_settings"]["input_filename"].GetString())
-            model_part_io.ReadModelPart(background_main_mesh)
-
-        background_sub_model_part_name = sliding_settings["background_sub_model_part_name"].GetString()
-        if background_sub_model_part_name == "":
-            self.background_mesh = background_main_mesh
-        else:
-            self.background_mesh = background_main_mesh.GetSubModelPart(background_sub_model_part_name)
-
-        sliding_sub_model_part_name = sliding_settings["sliding_sub_model_part_name"].GetString()
-        root_model_part = self.destination_model_part.GetRootModelPart()
-        self.sliding_mesh = root_model_part.GetSubModelPart(sliding_sub_model_part_name)
-
-        background_geometry_utilities = KSO.GeometryUtilities(self.background_mesh)
-        background_geometry_utilities.ComputeUnitSurfaceNormals()
-        self.spacial_mapper = SpacialMapperFactory.CreateMapper(
-            self.background_mesh, self.sliding_mesh, sliding_settings["spacial_mapper_settings"])
-
-        KSO.MeshControllerUtilities(self.background_mesh).WriteCoordinatesToVariable(KSO.BACKGROUND_COORDINATE)
-
-    def Update(self):
-        self.vm_mapper.Update()
-        self.spacial_mapper.UpdateInterface()
-        self.spacial_mapper.Map(KSO.NORMALIZED_SURFACE_NORMAL, KSO.BACKGROUND_NORMAL)
-
-        # create structural similarity model and analysis
-        self._structural_model = KM.Model()
-        self._CreateStructuralModel(self._structural_model)
-
-        self._structural_model_correction = KM.Model()
-        self._CreateStructuralModel(self._structural_model_correction)
-
-        structural_mechanics_analysis_setings = self.GetStructuralSimilaritySettings()
-        # two structural similarity analysis for damping vectors and non-linear correction
-        self._structural_mechanics_analysis = StructuralMechanicsAnalysis(self._structural_model, structural_mechanics_analysis_setings)
-        self._structural_mechanics_analysis_correction = StructuralMechanicsAnalysis(self._structural_model_correction, structural_mechanics_analysis_setings)
-
-        # propagate background normal field from sliding mesh to destination
-        self._PerformStructuralSimilarityAnalysis(self._structural_mechanics_analysis, self._structural_model, KSO.BACKGROUND_NORMAL)
-
-    def Map(self, origin_variable, destination_variable):
-        self.vm_mapper.Map(origin_variable, destination_variable)
-
-        geometry_utilities = KSO.GeometryUtilities(self.destination_model_part)
-
-        geometry_utilities.ProjectNodalVariableOnTangentPlane(
-            destination_variable, KSO.BACKGROUND_NORMAL)
-
-        # non-linear correction on sliding mesh
-        self._CorrectOutOfPlanePart(destination_variable)
-
-        mesh_utilities_struct =  KSO.MeshControllerUtilities(self._structural_model_correction.GetModelPart("main"))
-
-        # map linear shape update to structural model
-        ne_mapper_settings = KM.Parameters("""{
-                                "mapper_type": "nearest_element",
-                                "echo_level" : 0
-                            }""")
-        model_mapper = SpacialMapperFactory.CreateMapper(
-            self.destination_model_part, self._structural_model_correction.GetModelPart("main"),
-            ne_mapper_settings)
-
-        model_mapper.Map(destination_variable, destination_variable)
-
-        # update structural model
-        mesh_utilities_struct.UpdateMeshAccordingInputVariable(destination_variable)
-        mesh_utilities_struct.SetReferenceMeshToMesh()
-
-        # propagate non-linear correction from sliding mesh to destination
-        self._PerformStructuralSimilarityAnalysis(self._structural_mechanics_analysis_correction, self._structural_model_correction, KSO.OUT_OF_PLANE_DELTA)
-
-        # revert structural model
-        mesh_utilities_struct.RevertMeshUpdateAccordingInputVariable(destination_variable)
-        mesh_utilities_struct.SetReferenceMeshToMesh()
-
-        # add non-linear correction to shape update
-        mesh_utilities = KSO.MeshControllerUtilities(self.destination_model_part)
-        mesh_utilities.AddFirstVariableToSecondVariable(KSO.OUT_OF_PLANE_DELTA, destination_variable)
-
-    def InverseMap(self, destination_variable, origin_variable):
-        geometry_utilities = KSO.GeometryUtilities(self.destination_model_part)
-
-        geometry_utilities.ProjectNodalVariableOnTangentPlane(
-            destination_variable, KSO.BACKGROUND_NORMAL)
-
-        self.vm_mapper.InverseMap(destination_variable, origin_variable)
-
-    def _CorrectOutOfPlanePart(self, destination_variable):
-        geometry_utilities = KSO.GeometryUtilities(self.sliding_mesh)
-        mesh_utilities = KSO.MeshControllerUtilities(self.sliding_mesh)
-
-        mesh_utilities.UpdateMeshAccordingInputVariable(destination_variable)
-        mesh_utilities.SetReferenceMeshToMesh()
-
-        self.spacial_mapper.UpdateInterface()
-        self.spacial_mapper.Map(KSO.BACKGROUND_COORDINATE, KSO.BACKGROUND_COORDINATE)
-        mesh_utilities.SubtractCoordinatesFromVariable(KSO.BACKGROUND_COORDINATE, KSO.OUT_OF_PLANE_DELTA)
-        geometry_utilities.ProjectNodalVariableOnDirection(KSO.OUT_OF_PLANE_DELTA, KSO.BACKGROUND_NORMAL)
-
-        mesh_utilities.RevertMeshUpdateAccordingInputVariable(destination_variable)
-        mesh_utilities.SetReferenceMeshToMesh()
-
-    def _PerformStructuralSimilarityAnalysis(self, structural_analysis, structural_model, input_variable):
-
-        mesh_utilities = KSO.MeshControllerUtilities(structural_model.GetModelPart("main"))
-        mesh_prescribed_part = structural_model.GetModelPart("main.prescribed_bc")
-
-        # nearest element mapping from destination to sliding mesh
-        ne_mapper_settings = KM.Parameters("""{
-                                "mapper_type": "nearest_element",
-                                "echo_level" : 0
-                            }""")
-        prescribed_mapper = SpacialMapperFactory.CreateMapper(
-            self.destination_model_part, mesh_prescribed_part,
-            ne_mapper_settings)
-
-        prescribed_mapper.Map(input_variable, KM.DISPLACEMENT)
-
-        # fix dbc on sliding mesh
-        KM.VariableUtils().ApplyFixity(KM.DISPLACEMENT_X, True, mesh_prescribed_part.Nodes)
-        KM.VariableUtils().ApplyFixity(KM.DISPLACEMENT_Y, True, mesh_prescribed_part.Nodes)
-        KM.VariableUtils().ApplyFixity(KM.DISPLACEMENT_Z, True, mesh_prescribed_part.Nodes)
-
-        structural_analysis.Initialize()
-        structural_analysis.RunSolutionLoop()
-        structural_analysis.Finalize()
-
-        # nearest element mapping from structural model to destination
-        mesh_utilities.RevertMeshUpdateAccordingInputVariable(KM.DISPLACEMENT)
-        mesh_utilities.SetReferenceMeshToMesh()
-
-        ne_mapper_settings = KM.Parameters("""{
-                                "mapper_type": "nearest_element",
-                                "echo_level" : 0
-                            }""")
-        main_mapper = SpacialMapperFactory.CreateMapper(
-            structural_model.GetModelPart("main"), self.destination_model_part,
-            ne_mapper_settings)
-        main_mapper.Map(KM.DISPLACEMENT, input_variable)
-
-    def _CreateStructuralModel(self, structural_model):
-
-        main_part = structural_model.CreateModelPart("main")
-        prescribed_part = main_part.CreateSubModelPart("prescribed_bc")
-        fixed_part = main_part.CreateSubModelPart("fixed_bc")
-
-        # add solution variables necessary for structural mechanics analysis
-        main_part.AddNodalSolutionStepVariable(KSO.SHAPE_UPDATE)
-        main_part.AddNodalSolutionStepVariable(KM.DISPLACEMENT)
-        main_part.AddNodalSolutionStepVariable(KM.ROTATION)
-        main_part.AddNodalSolutionStepVariable(KM.REACTION)
-        main_part.AddNodalSolutionStepVariable(KM.POSITIVE_FACE_PRESSURE)
-        main_part.AddNodalSolutionStepVariable(KM.NEGATIVE_FACE_PRESSURE)
-        main_part.AddNodalSolutionStepVariable(KSM.POINT_LOAD)
-        main_part.AddNodalSolutionStepVariable(KSM.LINE_LOAD)
-        main_part.AddNodalSolutionStepVariable(KSM.SURFACE_LOAD)
-        main_part.AddNodalSolutionStepVariable(KM.VOLUME_ACCELERATION)
-        main_part.AddNodalSolutionStepVariable(KM.ROTATION)
-        main_part.AddNodalSolutionStepVariable(KM.REACTION_MOMENT)
-        main_part.AddNodalSolutionStepVariable(KSM.POINT_MOMENT)
-        main_part.AddNodalSolutionStepVariable(KSO.NORMALIZED_SURFACE_NORMAL)
-
-        material_properties = main_part.GetProperties()[0]
-        self._ApplyMaterialProperties(material_properties)
-
-        # create nodes of prescribed bc
-        prescribed_nodes_added = set()
-        for node in self.sliding_mesh.Nodes:
-            prescribed_part.CreateNewNode(node.Id, node.X, node.Y, node.Z)
-            prescribed_nodes_added.add(node.Id)
-
-        # Identify mesh motion area / nodes to be damped
-        KM.VariableUtils().SetFlag(KM.STRUCTURE, False, main_part.Nodes)
-        radius = self.settings["filter_radius"].GetDouble()
-        search_based_functions = KSO.SearchBasedFunctions(self.destination_model_part)
-        search_based_functions.FlagNodesInRadius(prescribed_part.Nodes, KM.STRUCTURE, 2*radius)
-
-        # create nodes for main_part
-        main_nodes_added = set()
-        for node in self.destination_model_part.Nodes:
-            if node.Is(KM.STRUCTURE):
-                main_part.CreateNewNode(node.Id, node.X, node.Y, node.Z)
-                main_nodes_added.add(node.Id)
-
-        # create elements for main_part
-        ele_id = 0
-        node_ids_to_remove = []
-        fixed_node_ids = []
-        for surface_condition in self.destination_model_part.Conditions:
-            node_counter = 0
-            number_of_nodes = len(surface_condition.GetNodes())
-            ele_node_ids = []
-            for node in surface_condition.GetNodes():
-                if node.Id in main_nodes_added:
-                    ele_node_ids.append(node.Id)
-                    node_counter += 1
-            if node_counter == number_of_nodes:
-                ele_id += 1
-                condition_dim = surface_condition.GetGeometry().LocalSpaceDimension()
-                if condition_dim != 2:
-                    raise Exception("SlidingVertexMorphingMapper: Design model part can only be a surface!")
-                if number_of_nodes == 3:
-                    main_part.CreateNewElement("ShellThinElement3D3N", ele_id, ele_node_ids, material_properties)
-                elif number_of_nodes == 4:
-                    main_part.CreateNewElement("ShellThinElement3D4N", ele_id, ele_node_ids, material_properties)
-                elif number_of_nodes == 6:
-                    edge_nodes = ele_node_ids[:3]
-                    node_ids_to_remove.extend(ele_node_ids[3:])
-                    main_part.CreateNewElement("ShellThinElement3D3N", ele_id, edge_nodes, material_properties)
-                elif number_of_nodes == 8 or number_of_nodes == 9:
-                    edge_nodes = ele_node_ids[:4]
-                    node_ids_to_remove.extend(ele_node_ids[4:])
-                    main_part.CreateNewElement("ShellThinElement3D4N", ele_id, edge_nodes, material_properties)
-            else:
-                fixed_node_ids.extend(ele_node_ids)
-
-        # remove nodes if higher order surface conditions have been used
-        node_ids_to_remove = list(set(node_ids_to_remove))
-        nodes_to_remove = main_part.CreateSubModelPart("nodes_to_remove")
-        nodes_to_remove.AddNodes(node_ids_to_remove)
-
-        KM.VariableUtils().SetFlag(KM.TO_ERASE, True, nodes_to_remove.Nodes)
-        main_part.RemoveNodes(KM.TO_ERASE)
-
-        # add dofs
-        KM.VariableUtils().AddDof(KM.DISPLACEMENT_X, KM.REACTION_X, main_part)
-        KM.VariableUtils().AddDof(KM.DISPLACEMENT_Y, KM.REACTION_Y, main_part)
-        KM.VariableUtils().AddDof(KM.DISPLACEMENT_Z, KM.REACTION_Z, main_part)
-
-        # add fixed nodes to fixed_part
-        fixed_node_ids = list(set(fixed_node_ids) - set(node_ids_to_remove))
-        fixed_part.AddNodes(fixed_node_ids)
-
-    def _ApplyMaterialProperties(self, material_properties):
-        # define properties
-        # artificially high bending stiffness via large thickness
-        radius = self.settings["filter_radius"].GetDouble()
-        material_properties.SetValue(KM.YOUNG_MODULUS,1.0E+8)
-        material_properties.SetValue(KM.POISSON_RATIO,0.0)
-        material_properties.SetValue(KM.THICKNESS,2*radius)
-        material_properties.SetValue(KM.DENSITY,0.0)
-
-        constitutive_law = KSM.LinearElasticPlaneStress2DLaw()
-
-        material_properties.SetValue(KM.CONSTITUTIVE_LAW,constitutive_law)
+# ==============================================================================
+#  KratosShapeOptimizationApplication
+#
+#  License:         BSD License
+#                   license: ShapeOptimizationApplication/license.txt
+#
+#  Main authors:    Schmoelz David, https://github.com/dschmoelz
+#
+# ==============================================================================
+
+import KratosMultiphysics as KM
+import KratosMultiphysics.ShapeOptimizationApplication as KSO
+try:
+    import KratosMultiphysics.StructuralMechanicsApplication as KSM
+    from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_analysis import StructuralMechanicsAnalysis
+except ImportError:
+    KSM = None
+    StructuralMechanicsAnalysis = None
+SpacialMapperFactory = KM.MapperFactory
+
+from ..custom_ios.wrl_io import WrlIO
+
+class SlidingVertexMorphingMapper():
+    """
+    The SlidingVertexMorphingMapper extends the standard Vertex Morphing approach
+    by restricting the nodal shape update of a specified model part. The nodes of this model
+    part have to lie on a predefined background mesh and are only allowed to float/slide on it.
+    SlidingVertexMorphingMapper uses similar techniques as direction damping and
+    InPlaneVertexMorphingMapper.
+
+    Limitations:
+    - Damping can only be used if all cartesian directions (x,y,z) are damped.
+    - The projection of gradients on the surface normals has to be deactivated.
+    """
+
+    def __init__(self, origin_model_part, destination_model_part, settings):
+        from KratosMultiphysics.ShapeOptimizationApplication import mapper_factory
+        if not SpacialMapperFactory:
+            raise Exception("SlidingVertexMorphingMapper: MappingApplication is required!")
+        if not KSM:
+            raise Exception("SlidingVertexMorphingMapper: StructuralMechanicsApplication is required!")
+
+        self.settings = settings
+        self.origin_model_part = origin_model_part
+        self.destination_model_part = destination_model_part
+
+        extracted_vm_settings = settings.Clone()
+        extracted_vm_settings["sliding_morphing"].SetBool(False)
+        extracted_vm_settings.RemoveValue("sliding_morphing_settings")
+        self.vm_mapper = mapper_factory.CreateMapper(origin_model_part, destination_model_part, extracted_vm_settings)
+
+        in_plane_settings = self.settings["sliding_morphing_settings"]
+        in_plane_settings.RecursivelyValidateAndAssignDefaults(self.GetDefaultInPlaneSettings())
+
+        self._background_model = KM.Model()
+        if in_plane_settings["model_import_settings"]["input_type"].GetString() in ["mdpa", "vrml", "wrl"]:
+            background_main_mesh = self._background_model.CreateModelPart("background_mesh")
+            background_main_mesh.ProcessInfo.SetValue(KM.DOMAIN_SIZE, 3)
+            background_main_mesh.AddNodalSolutionStepVariable(KM.NORMAL)
+            background_main_mesh.AddNodalSolutionStepVariable(KSO.NORMALIZED_SURFACE_NORMAL)
+            background_main_mesh.AddNodalSolutionStepVariable(KSO.BACKGROUND_COORDINATE)
+        else:
+            raise Exception("Other model part input options are not yet implemented.")
+
+        self.background_mesh = None  # created in Initialize
+        self.spacial_mapper = None   # created in Initialize
+        self.sliding_mesh = None     # created in Initialize
+
+    @classmethod
+    def GetDefaultInPlaneSettings(cls):
+        return KM.Parameters("""{
+            "model_import_settings" : {
+                "input_type" : "mdpa",
+                "input_filename" : "UNKNOWN_NAME"
+            },
+            "sliding_sub_model_part_name" : "",
+            "background_sub_model_part_name" : "",
+            "spacial_mapper_settings" : {
+                "mapper_type": "nearest_element",
+                "echo_level" : 0
+            }
+        }""")
+
+    def GetStructuralSimilaritySettings(self):
+        return KM.Parameters(
+        """{
+            "problem_data"    : {
+                "problem_name"    : "structural_similarity",
+                "parallel_type"   : "OpenMP",
+                "start_time"      : 0.0,
+                "end_time"        : 1.0,
+                "echo_level"      : 0
+            },
+            "solver_settings" : {
+                "solver_type"     : "static",
+                "analysis_type"   : "linear",
+                "model_part_name" : "main",
+                "domain_size"     : 3,
+                "time_stepping" : {
+                    "time_step"       : 1.0
+                },
+                "model_import_settings"              : {
+                    "input_type"     : "use_input_model_part"
+                },
+                "rotation_dofs"                      : true
+            },
+            "processes" : {
+                "constraints_process_list" : [
+                {
+                    "python_module" : "assign_vector_variable_process",
+                    "kratos_module" : "KratosMultiphysics",
+                    "help"          : "This process fixes the selected components of a given vector variable",
+                    "process_name"  : "AssignVectorVariableProcess",
+                    "Parameters"    : {
+                        "mesh_id"         : 0,
+                        "model_part_name" : "main.fixed_bc",
+                        "variable_name"   : "DISPLACEMENT",
+                        "value"           : [0.0,0.0,0.0]
+                    }
+                }
+                ]
+            }
+        }""")
+
+    def Initialize(self):
+        self.vm_mapper.Initialize()
+
+        sliding_settings = self.settings["sliding_morphing_settings"]
+
+        background_main_mesh = self._background_model.GetModelPart("background_mesh")
+        if sliding_settings["model_import_settings"]["input_type"].GetString() == "mdpa":
+            model_part_io = KM.ModelPartIO(sliding_settings["model_import_settings"]["input_filename"].GetString())
+            model_part_io.ReadModelPart(background_main_mesh)
+        elif sliding_settings["model_import_settings"]["input_type"].GetString() in ["vrml", "wrl"]:
+            model_part_io = WrlIO(sliding_settings["model_import_settings"]["input_filename"].GetString())
+            model_part_io.ReadModelPart(background_main_mesh)
+
+        background_sub_model_part_name = sliding_settings["background_sub_model_part_name"].GetString()
+        if background_sub_model_part_name == "":
+            self.background_mesh = background_main_mesh
+        else:
+            self.background_mesh = background_main_mesh.GetSubModelPart(background_sub_model_part_name)
+
+        sliding_sub_model_part_name = sliding_settings["sliding_sub_model_part_name"].GetString()
+        root_model_part = self.destination_model_part.GetRootModelPart()
+        self.sliding_mesh = root_model_part.GetSubModelPart(sliding_sub_model_part_name)
+
+        background_geometry_utilities = KSO.GeometryUtilities(self.background_mesh)
+        background_geometry_utilities.ComputeUnitSurfaceNormals()
+        self.spacial_mapper = SpacialMapperFactory.CreateMapper(
+            self.background_mesh, self.sliding_mesh, sliding_settings["spacial_mapper_settings"])
+
+        KSO.MeshControllerUtilities(self.background_mesh).WriteCoordinatesToVariable(KSO.BACKGROUND_COORDINATE)
+
+    def Update(self):
+        self.vm_mapper.Update()
+        self.spacial_mapper.UpdateInterface()
+        self.spacial_mapper.Map(KSO.NORMALIZED_SURFACE_NORMAL, KSO.BACKGROUND_NORMAL)
+
+        # create structural similarity model and analysis
+        self._structural_model = KM.Model()
+        self._CreateStructuralModel(self._structural_model)
+
+        self._structural_model_correction = KM.Model()
+        self._CreateStructuralModel(self._structural_model_correction)
+
+        structural_mechanics_analysis_setings = self.GetStructuralSimilaritySettings()
+        # two structural similarity analysis for damping vectors and non-linear correction
+        self._structural_mechanics_analysis = StructuralMechanicsAnalysis(self._structural_model, structural_mechanics_analysis_setings)
+        self._structural_mechanics_analysis_correction = StructuralMechanicsAnalysis(self._structural_model_correction, structural_mechanics_analysis_setings)
+
+        # propagate background normal field from sliding mesh to destination
+        self._PerformStructuralSimilarityAnalysis(self._structural_mechanics_analysis, self._structural_model, KSO.BACKGROUND_NORMAL)
+
+    def Map(self, origin_variable, destination_variable):
+        self.vm_mapper.Map(origin_variable, destination_variable)
+
+        geometry_utilities = KSO.GeometryUtilities(self.destination_model_part)
+
+        geometry_utilities.ProjectNodalVariableOnTangentPlane(
+            destination_variable, KSO.BACKGROUND_NORMAL)
+
+        # non-linear correction on sliding mesh
+        self._CorrectOutOfPlanePart(destination_variable)
+
+        mesh_utilities_struct =  KSO.MeshControllerUtilities(self._structural_model_correction.GetModelPart("main"))
+
+        # map linear shape update to structural model
+        ne_mapper_settings = KM.Parameters("""{
+                                "mapper_type": "nearest_element",
+                                "echo_level" : 0
+                            }""")
+        model_mapper = SpacialMapperFactory.CreateMapper(
+            self.destination_model_part, self._structural_model_correction.GetModelPart("main"),
+            ne_mapper_settings)
+
+        model_mapper.Map(destination_variable, destination_variable)
+
+        # update structural model
+        mesh_utilities_struct.UpdateMeshAccordingInputVariable(destination_variable)
+        mesh_utilities_struct.SetReferenceMeshToMesh()
+
+        # propagate non-linear correction from sliding mesh to destination
+        self._PerformStructuralSimilarityAnalysis(self._structural_mechanics_analysis_correction, self._structural_model_correction, KSO.OUT_OF_PLANE_DELTA)
+
+        # revert structural model
+        mesh_utilities_struct.RevertMeshUpdateAccordingInputVariable(destination_variable)
+        mesh_utilities_struct.SetReferenceMeshToMesh()
+
+        # add non-linear correction to shape update
+        mesh_utilities = KSO.MeshControllerUtilities(self.destination_model_part)
+        mesh_utilities.AddFirstVariableToSecondVariable(KSO.OUT_OF_PLANE_DELTA, destination_variable)
+
+    def InverseMap(self, destination_variable, origin_variable):
+        geometry_utilities = KSO.GeometryUtilities(self.destination_model_part)
+
+        geometry_utilities.ProjectNodalVariableOnTangentPlane(
+            destination_variable, KSO.BACKGROUND_NORMAL)
+
+        self.vm_mapper.InverseMap(destination_variable, origin_variable)
+
+    def _CorrectOutOfPlanePart(self, destination_variable):
+        geometry_utilities = KSO.GeometryUtilities(self.sliding_mesh)
+        mesh_utilities = KSO.MeshControllerUtilities(self.sliding_mesh)
+
+        mesh_utilities.UpdateMeshAccordingInputVariable(destination_variable)
+        mesh_utilities.SetReferenceMeshToMesh()
+
+        self.spacial_mapper.UpdateInterface()
+        self.spacial_mapper.Map(KSO.BACKGROUND_COORDINATE, KSO.BACKGROUND_COORDINATE)
+        mesh_utilities.SubtractCoordinatesFromVariable(KSO.BACKGROUND_COORDINATE, KSO.OUT_OF_PLANE_DELTA)
+        geometry_utilities.ProjectNodalVariableOnDirection(KSO.OUT_OF_PLANE_DELTA, KSO.BACKGROUND_NORMAL)
+
+        mesh_utilities.RevertMeshUpdateAccordingInputVariable(destination_variable)
+        mesh_utilities.SetReferenceMeshToMesh()
+
+    def _PerformStructuralSimilarityAnalysis(self, structural_analysis, structural_model, input_variable):
+
+        mesh_utilities = KSO.MeshControllerUtilities(structural_model.GetModelPart("main"))
+        mesh_prescribed_part = structural_model.GetModelPart("main.prescribed_bc")
+
+        # nearest element mapping from destination to sliding mesh
+        ne_mapper_settings = KM.Parameters("""{
+                                "mapper_type": "nearest_element",
+                                "echo_level" : 0
+                            }""")
+        prescribed_mapper = SpacialMapperFactory.CreateMapper(
+            self.destination_model_part, mesh_prescribed_part,
+            ne_mapper_settings)
+
+        prescribed_mapper.Map(input_variable, KM.DISPLACEMENT)
+
+        # fix dbc on sliding mesh
+        KM.VariableUtils().ApplyFixity(KM.DISPLACEMENT_X, True, mesh_prescribed_part.Nodes)
+        KM.VariableUtils().ApplyFixity(KM.DISPLACEMENT_Y, True, mesh_prescribed_part.Nodes)
+        KM.VariableUtils().ApplyFixity(KM.DISPLACEMENT_Z, True, mesh_prescribed_part.Nodes)
+
+        structural_analysis.Initialize()
+        structural_analysis.RunSolutionLoop()
+        structural_analysis.Finalize()
+
+        # nearest element mapping from structural model to destination
+        mesh_utilities.RevertMeshUpdateAccordingInputVariable(KM.DISPLACEMENT)
+        mesh_utilities.SetReferenceMeshToMesh()
+
+        ne_mapper_settings = KM.Parameters("""{
+                                "mapper_type": "nearest_element",
+                                "echo_level" : 0
+                            }""")
+        main_mapper = SpacialMapperFactory.CreateMapper(
+            structural_model.GetModelPart("main"), self.destination_model_part,
+            ne_mapper_settings)
+        main_mapper.Map(KM.DISPLACEMENT, input_variable)
+
+    def _CreateStructuralModel(self, structural_model):
+
+        main_part = structural_model.CreateModelPart("main")
+        prescribed_part = main_part.CreateSubModelPart("prescribed_bc")
+        fixed_part = main_part.CreateSubModelPart("fixed_bc")
+
+        # add solution variables necessary for structural mechanics analysis
+        main_part.AddNodalSolutionStepVariable(KSO.SHAPE_UPDATE)
+        main_part.AddNodalSolutionStepVariable(KM.DISPLACEMENT)
+        main_part.AddNodalSolutionStepVariable(KM.ROTATION)
+        main_part.AddNodalSolutionStepVariable(KM.REACTION)
+        main_part.AddNodalSolutionStepVariable(KM.POSITIVE_FACE_PRESSURE)
+        main_part.AddNodalSolutionStepVariable(KM.NEGATIVE_FACE_PRESSURE)
+        main_part.AddNodalSolutionStepVariable(KSM.POINT_LOAD)
+        main_part.AddNodalSolutionStepVariable(KSM.LINE_LOAD)
+        main_part.AddNodalSolutionStepVariable(KSM.SURFACE_LOAD)
+        main_part.AddNodalSolutionStepVariable(KM.VOLUME_ACCELERATION)
+        main_part.AddNodalSolutionStepVariable(KM.ROTATION)
+        main_part.AddNodalSolutionStepVariable(KM.REACTION_MOMENT)
+        main_part.AddNodalSolutionStepVariable(KSM.POINT_MOMENT)
+        main_part.AddNodalSolutionStepVariable(KSO.NORMALIZED_SURFACE_NORMAL)
+
+        material_properties = main_part.GetProperties()[0]
+        self._ApplyMaterialProperties(material_properties)
+
+        # create nodes of prescribed bc
+        prescribed_nodes_added = set()
+        for node in self.sliding_mesh.Nodes:
+            prescribed_part.CreateNewNode(node.Id, node.X, node.Y, node.Z)
+            prescribed_nodes_added.add(node.Id)
+
+        # Identify mesh motion area / nodes to be damped
+        KM.VariableUtils().SetFlag(KM.STRUCTURE, False, main_part.Nodes)
+        radius = self.settings["filter_radius"].GetDouble()
+        search_based_functions = KSO.SearchBasedFunctions(self.destination_model_part)
+        search_based_functions.FlagNodesInRadius(prescribed_part.Nodes, KM.STRUCTURE, 2*radius)
+
+        # create nodes for main_part
+        main_nodes_added = set()
+        for node in self.destination_model_part.Nodes:
+            if node.Is(KM.STRUCTURE):
+                main_part.CreateNewNode(node.Id, node.X, node.Y, node.Z)
+                main_nodes_added.add(node.Id)
+
+        # create elements for main_part
+        ele_id = 0
+        node_ids_to_remove = []
+        fixed_node_ids = []
+        for surface_condition in self.destination_model_part.Conditions:
+            node_counter = 0
+            number_of_nodes = len(surface_condition.GetNodes())
+            ele_node_ids = []
+            for node in surface_condition.GetNodes():
+                if node.Id in main_nodes_added:
+                    ele_node_ids.append(node.Id)
+                    node_counter += 1
+            if node_counter == number_of_nodes:
+                ele_id += 1
+                condition_dim = surface_condition.GetGeometry().LocalSpaceDimension()
+                if condition_dim != 2:
+                    raise Exception("SlidingVertexMorphingMapper: Design model part can only be a surface!")
+                if number_of_nodes == 3:
+                    main_part.CreateNewElement("ShellThinElement3D3N", ele_id, ele_node_ids, material_properties)
+                elif number_of_nodes == 4:
+                    main_part.CreateNewElement("ShellThinElement3D4N", ele_id, ele_node_ids, material_properties)
+                elif number_of_nodes == 6:
+                    edge_nodes = ele_node_ids[:3]
+                    node_ids_to_remove.extend(ele_node_ids[3:])
+                    main_part.CreateNewElement("ShellThinElement3D3N", ele_id, edge_nodes, material_properties)
+                elif number_of_nodes == 8 or number_of_nodes == 9:
+                    edge_nodes = ele_node_ids[:4]
+                    node_ids_to_remove.extend(ele_node_ids[4:])
+                    main_part.CreateNewElement("ShellThinElement3D4N", ele_id, edge_nodes, material_properties)
+            else:
+                fixed_node_ids.extend(ele_node_ids)
+
+        # remove nodes if higher order surface conditions have been used
+        node_ids_to_remove = list(set(node_ids_to_remove))
+        nodes_to_remove = main_part.CreateSubModelPart("nodes_to_remove")
+        nodes_to_remove.AddNodes(node_ids_to_remove)
+
+        KM.VariableUtils().SetFlag(KM.TO_ERASE, True, nodes_to_remove.Nodes)
+        main_part.RemoveNodes(KM.TO_ERASE)
+
+        # add dofs
+        KM.VariableUtils().AddDof(KM.DISPLACEMENT_X, KM.REACTION_X, main_part)
+        KM.VariableUtils().AddDof(KM.DISPLACEMENT_Y, KM.REACTION_Y, main_part)
+        KM.VariableUtils().AddDof(KM.DISPLACEMENT_Z, KM.REACTION_Z, main_part)
+
+        # add fixed nodes to fixed_part
+        fixed_node_ids = list(set(fixed_node_ids) - set(node_ids_to_remove))
+        fixed_part.AddNodes(fixed_node_ids)
+
+    def _ApplyMaterialProperties(self, material_properties):
+        # define properties
+        # artificially high bending stiffness via large thickness
+        radius = self.settings["filter_radius"].GetDouble()
+        material_properties.SetValue(KM.YOUNG_MODULUS,1.0E+8)
+        material_properties.SetValue(KM.POISSON_RATIO,0.0)
+        material_properties.SetValue(KM.THICKNESS,2*radius)
+        material_properties.SetValue(KM.DENSITY,0.0)
+
+        constitutive_law = KSM.LinearElasticPlaneStress2DLaw()
+
+        material_properties.SetValue(KM.CONSTITUTIVE_LAW,constitutive_law)
```

## Comparing `KratosShapeOptimizationApplication-9.5.dist-info/METADATA` & `KratosShapeOptimizationApplication-9.5.1.dist-info/METADATA`

 * *Files 11% similar despite different names*

```diff
@@ -1,46 +1,47 @@
-Metadata-Version: 2.1
-Name: KratosShapeOptimizationApplication
-Version: 9.5
-Summary: KRATOS Multiphysics ("Kratos") is a framework for building parallel, multi-disciplinary simulation software, aiming at modularity, extensibility, and high performance. Kratos is written in C++, and counts with an extensive Python interface.
-Home-page: https://github.com/KratosMultiphysics/
-Author: Kratos Team
-Author-email: kratos@listas.cimne.upc.edu
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: C++
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: Topic :: Scientific/Engineering
-Classifier: Topic :: Scientific/Engineering :: Physics
-Classifier: Topic :: Scientific/Engineering :: Mathematics
-Classifier: Natural Language :: English
-Classifier: Intended Audience :: Science/Research
-Classifier: Intended Audience :: Other Audience
-Classifier: Intended Audience :: Developers
-Classifier: Development Status :: 5 - Production/Stable
-Classifier: Environment :: Console
-Classifier: License :: OSI Approved :: BSD License
-Requires-Python: >=3.8
-Description-Content-Type: text/markdown
-Requires-Dist: KratosMultiphysics ==9.5
-
-# ShapeOptimizationApplication
-
-The Kratos ShapeOptimizationApplication contains an implementation of the Vertex Morphing method for node-based shape optimzation.
-
-It can be used in combination with the Adjoint Sensitivity Analysis capabilities of the Kratos StructuralMechanicsApplication and ConvectionDiffusionApplication. 
-Additionally it offers an interface to use external response functions via custom python code.
-
-
-## Examples
-
-A few application examples can be found [here](https://github.com/KratosMultiphysics/Examples/tree/master/shape_optimization)
-
-
-### References
-
-- Bletzinger, K.-U. A consistent frame for sensitivity filtering and the vertex assigned morphing of optimal shape. Struct Multidisc Optim 49, 873–895 (2014). https://doi.org/10.1007/s00158-013-1031-5
-- Bletzinger, K.-U. (2017). Shape Optimization. In Encyclopedia of Computational Mechanics Second Edition (eds E. Stein, R. Borst and T.J.R. Hughes). https://doi.org/10.1002/9781119176817.ecm2109
-
+Metadata-Version: 2.1
+Name: KratosShapeOptimizationApplication
+Version: 9.5.1
+Summary: KRATOS Multiphysics ("Kratos") is a framework for building parallel, multi-disciplinary simulation software, aiming at modularity, extensibility, and high performance. Kratos is written in C++, and counts with an extensive Python interface.
+Home-page: https://github.com/KratosMultiphysics/
+Author: Kratos Team
+Author-email: kratos@listas.cimne.upc.edu
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: C++
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
+Classifier: Topic :: Scientific/Engineering
+Classifier: Topic :: Scientific/Engineering :: Physics
+Classifier: Topic :: Scientific/Engineering :: Mathematics
+Classifier: Natural Language :: English
+Classifier: Intended Audience :: Science/Research
+Classifier: Intended Audience :: Other Audience
+Classifier: Intended Audience :: Developers
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: Environment :: Console
+Classifier: License :: OSI Approved :: BSD License
+Requires-Python: >=3.8
+Description-Content-Type: text/markdown
+Requires-Dist: KratosMultiphysics ==9.5.1
+
+# ShapeOptimizationApplication
+
+The Kratos ShapeOptimizationApplication contains an implementation of the Vertex Morphing method for node-based shape optimzation.
+
+It can be used in combination with the Adjoint Sensitivity Analysis capabilities of the Kratos StructuralMechanicsApplication and ConvectionDiffusionApplication. 
+Additionally it offers an interface to use external response functions via custom python code.
+
+
+## Examples
+
+A few application examples can be found [here](https://github.com/KratosMultiphysics/Examples/tree/master/shape_optimization)
+
+
+### References
+
+- Bletzinger, K.-U. A consistent frame for sensitivity filtering and the vertex assigned morphing of optimal shape. Struct Multidisc Optim 49, 873–895 (2014). https://doi.org/10.1007/s00158-013-1031-5
+- Bletzinger, K.-U. (2017). Shape Optimization. In Encyclopedia of Computational Mechanics Second Edition (eds E. Stein, R. Borst and T.J.R. Hughes). https://doi.org/10.1002/9781119176817.ecm2109
+
```

## Comparing `KratosShapeOptimizationApplication-9.5.dist-info/RECORD` & `KratosShapeOptimizationApplication-9.5.1.dist-info/RECORD`

 * *Files 9% similar despite different names*

```diff
@@ -1,67 +1,67 @@
-KratosShapeOptimizationApplication.libs/libKratosShapeOptimizationCore-2091758f.so,sha256=wnCttD7X0nduPifpomLNGtKecmEatfazpicwcSXbZxU,5876785
-KratosShapeOptimizationApplication-9.5.dist-info/METADATA,sha256=580CC1siTQ4_HHEZaXBHtVC8bcAPyOEFZjPR6AGEOIU,2338
-KratosShapeOptimizationApplication-9.5.dist-info/WHEEL,sha256=rY0Y6THYM7EImsHfF-zs67o8pQciAsMw9_YuSvftjrQ,148
-KratosShapeOptimizationApplication-9.5.dist-info/top_level.txt,sha256=8Ov--opRCptLbHStjyiZUVpzN1OUU_F7c7fGmsR5cMc,19
-KratosShapeOptimizationApplication-9.5.dist-info/RECORD,,
-KratosMultiphysics/ShapeOptimizationApplication/optimizer_factory.py,sha256=U3VHdu1CFE6-VEYXOlmtBhMqSePRFqVjg-qOW93-i4o,13333
-KratosMultiphysics/ShapeOptimizationApplication/model_part_controller_factory.py,sha256=ZP_y4SZ-s0-5WxGGZzHyXj7LYg6frAUl5NxHTREWKFk,9727
-KratosMultiphysics/ShapeOptimizationApplication/TemplateMainKratosShapeOptimization.py,sha256=AfN_XDKyrCs5o9QVoeBBDrvSLIhMVrlt9C5zXHUDMMI,1343
-KratosMultiphysics/ShapeOptimizationApplication/mapper_factory.py,sha256=C2EVo5Zov9PO7ANfxoimtkAsOpyPxEGy-fVQVL9HuNw,5476
-KratosMultiphysics/ShapeOptimizationApplication/communicator_factory.py,sha256=YvM5Q_psPUe9KR0UgnS-XSOwS48RBgb3LQdD9Mgc6SE,13498
-KratosMultiphysics/ShapeOptimizationApplication/__init__.py,sha256=1P0_CzQiDhtVBO3QcOPUOb02FSIRfPMHcIh6nR0wyn8,811
-KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_penalized_projection.py,sha256=FlFMxlwHNU2teYva23XxkBw3l2E39Y0G_YF2ofKVnQw,4353
-KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_relaxed_gradient_projection.py,sha256=HZMrZgxwSm0RlmlucC_ycErObco7YE7_CYhXvViFBhs,6523
-KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_vtk.py,sha256=Q3oztFf6wp0CssJRMyyeBHzVagbKrPjZi1RJKBkHFxk,4488
-KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_gid.py,sha256=UlABuCjfV3fNo6luedL1xAbAHKi9OfQ7UZWKlOxtfp4,5466
-KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_gradient_projection.py,sha256=weeqZr-VpMcVlbeeHzVsjO6q4MzQAFV694cKMWxDWHw,4418
-KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_unv.py,sha256=rV4TSp8awUTHy5uCFvQujfR-9vIZI-oyTQZe0QzHW_g,3603
-KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_steepest_descent.py,sha256=DkKLvcX9Y0jETdptCv1p_J3aKvnr70FWLfPAVGdqEco,3445
-KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_bead_optimization.py,sha256=jJcfjvKAiEXKlztD4mAvONFzA97YC4qhDjcq3MQKob4,4791
-KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_shape_fraction_optimization.py,sha256=Iqz9LUCyKCrb_eMI5Vb9u4-1ye-jSNFPLh6oOUyyYoA,5161
-KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_base.py,sha256=2r_kDALwjPkxClOZzP5wA9-C_79Og9oMIhG4rFBFy0I,1423
-KratosMultiphysics/ShapeOptimizationApplication/loggers/sensitivity_heatmap_logger.py,sha256=W9bXwk2iLzfAPc9Z_5HzLrGVjVmPnSzDnLgv5XJzAdY,4893
-KratosMultiphysics/ShapeOptimizationApplication/loggers/data_logger_factory.py,sha256=BGaBqpgyIbv4TXNFmHaaBZSjCGvAZfcM9sOt4-02NVs,11563
-KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_trust_region.py,sha256=7sWCeWLt6QswCalSuoGAyVsghXVn6u2KiZftDHb60Po,5835
-KratosMultiphysics/ShapeOptimizationApplication/loggers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_base.py,sha256=UAgNb2hbnDVswkBl_89lezdWG_EeOa4Jva4AglWrOfU,6205
-KratosMultiphysics/ShapeOptimizationApplication/response_functions/mesh_based_packaging.py,sha256=b81rbJsbdyTkYeOM3cy_o_15YfJPUiGiL5k7IzIK4m8,3464
-KratosMultiphysics/ShapeOptimizationApplication/response_functions/airfoil_2d_responses.py,sha256=QOZBh24p3oYdkiAw3ODl2rvJdpdkUO_ts1Nqs2x-gdg,8085
-KratosMultiphysics/ShapeOptimizationApplication/response_functions/packaging_response_base.py,sha256=8TOtPgJUa2JRfGzj_Fiv84d9boZT3rcgEVaIIAotudY,6244
-KratosMultiphysics/ShapeOptimizationApplication/response_functions/total_volume.py,sha256=rYqbghaDCAQZMg_JvINRNjet1HpJy-33VbWhEbLyfuc,2030
-KratosMultiphysics/ShapeOptimizationApplication/response_functions/surface_normal_shape_change.py,sha256=Y9jr2KTGebjrF0s_xjhb56L0xwUH9uHIt9pZyq5kVy4,5308
-KratosMultiphysics/ShapeOptimizationApplication/response_functions/response_function_factory.py,sha256=fwGhvmGbNAqFKchUEMGckyWNyvXGya4_dtdnmqaNlkg,2202
-KratosMultiphysics/ShapeOptimizationApplication/response_functions/face_angle.py,sha256=P3w9KTZNsxSMoFPFxeCBt3n76T7q183yYTgZ0JliW98,6177
-KratosMultiphysics/ShapeOptimizationApplication/response_functions/plane_based_packaging.py,sha256=CyeCBx6EcWStVKWxQHKB7rP4PpCsaS84PsGfiGvufPs,2364
-KratosMultiphysics/ShapeOptimizationApplication/response_functions/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/ShapeOptimizationApplication/custom_ios/wrl_reader.py,sha256=ZH8I2bCv1PtWnKBrgYsf_aRQcDYp5SISfT28K3IyN4s,3596
-KratosMultiphysics/ShapeOptimizationApplication/custom_ios/wrl_io.py,sha256=Ap1UN-c2cmZ77MheXk9a-luQhaJP5xjZQb4RvxYuT_k,2924
-KratosMultiphysics/ShapeOptimizationApplication/custom_ios/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_basic_updating.py,sha256=Fv7Bf0waVdXxDBezHdEAwCCmAl4U7reaB1A67B8BEGY,1609
-KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_with_solver.py,sha256=9t7Ch4nGinngGnUEpky7ytHj_R4rtcusNqfmNAsVwk0,12262
-KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_base.py,sha256=l0sAcDyRpLXzJlbGG7uYCu3IzNBjta9OLi1mFcxuUNg,994
-KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_math.py,sha256=bTn0lCPIL43G3kbRl8LR63L-FagytxIxKQEjtNZontE,14277
-KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_variable_utilities.py,sha256=zgXXHFnFGxRqV4JYDDZsg1ACObeuZjnerwCA_uFlysU,2247
-KratosMultiphysics/ShapeOptimizationApplication/utilities/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_sensitivity_heatmap.py,sha256=WS7Zwp_RceelYMgsTkKxV5R6chFgk7tpx8_sUOMZ0Vg,11819
-KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_timer.py,sha256=_B5VyHa-NYHNAy2GlkC3D7AONkrQlxiPwL9Cov-Bydc,1807
-KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_base.py,sha256=3lANIAwI22R0WUMZwRAlOYRdaNnC35THTQDloZ09GZQ,1316
-KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_factory.py,sha256=LeHftBaQkFB72tHS4R--OYWSWcjiPQ8oTcKrj3eLUDM,15259
-KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_empty.py,sha256=llKIFS6yS0wjwFPngDU5iAAg9z-ysH7zgC2Zqv_gyEs,856
-KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_internal.py,sha256=co0MVNw7Gopdh_sG1QaNht6ccMQh927_1_CtOxOUSmA,8283
-KratosMultiphysics/ShapeOptimizationApplication/analyzers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_steepest_descent.py,sha256=pMmxcGn8oMlLhq0Id6yltdWkzNiTR4gEkPItAs1ZvAs,13163
-KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_gradient_projection.py,sha256=wY4yJc66vJNC7nVvIY6AIhWR17vk1z4fH6LaM51guxg,16325
-KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_trust_region.py,sha256=cuE8QrG7HNUJgPAe3krqAzM6DajMDZQTVaqlfJw0nhA,31404
-KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_bead_optimization.py,sha256=-itmON5GPfO-4OveYzBviQvpgiidgMP_J2P63v20ZnE,21979
-KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_relaxed_gradient_projection.py,sha256=fOD-WxxIE6CUgeX-OoJ3aGbJ0HGOA3m4LAF5RL21Vko,30146
-KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_base.py,sha256=_ob_wfceg7ERX5qy82wf2KA5SzCZbKOHZByzZJdzsy4,1694
-KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_penalized_projection.py,sha256=6irbx7BlkzegKD_MW3FlMJthQNgCdQC0PHeyPhdGbPU,11809
-KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_factory.py,sha256=YcckC9lvfgdo0qBNATS3Kvc2DGTAEdCa-QVYMKujcxg,3473
-KratosMultiphysics/ShapeOptimizationApplication/algorithms/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_shape_fraction_optimization.py,sha256=azOH5HfwmZYTzLDtcW4k0CoXOefIm-6-xO5wmk1J4KU,29713
-KratosMultiphysics/ShapeOptimizationApplication/mapping/in_plane_vertex_morphing_mapper.py,sha256=fU18L0CCsAsD7gNEIBYsWZOW3dH9LTMvu0iU5smOhYk,6901
-KratosMultiphysics/ShapeOptimizationApplication/mapping/sliding_vertex_morphing_mapper.py,sha256=8p7tcVLuFkpZ5wQY7lVOvi_CuGhiwcgY-QUZ8ZE9odY,18699
-KratosMultiphysics/ShapeOptimizationApplication/mapping/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/.libs/libKratosShapeOptimizationCore.so,sha256=Gv2fS75rFaVvGSTPSHkH3L3oZjBZpudB6ik2siJ0VZM,5586609
-KratosMultiphysics/.libs/KratosShapeOptimizationApplication.cpython-39-x86_64-linux-gnu.so,sha256=KbVlkD68TmqiwBamzYMGmFXRlBLnZxZe8-NskhF869o,2079457
+KratosMultiphysics/.libs/KratosShapeOptimizationApplication.pyd,sha256=igfjNBphFnFFRc7dJ3TUFM7sOASAFnyP0M2jSDGLh7g,654848
+KratosMultiphysics/.libs/KratosShapeOptimizationCore.dll,sha256=uPzggUu_NU_z54tzJBAVm3P5cB9O2XGMUOPjXcdYKuA,1359360
+KratosMultiphysics/.libs/KratosShapeOptimizationCore.lib,sha256=ZWkmVGaPh3GcuFh-NdgS7RVzsy41BZixmAJc0Ph5Odo,281238
+KratosMultiphysics/ShapeOptimizationApplication/TemplateMainKratosShapeOptimization.py,sha256=y0VemB2O1ZVUQ44pyBDpr1Gbp1rXVhvg-HYdLFAulGI,1373
+KratosMultiphysics/ShapeOptimizationApplication/__init__.py,sha256=P6Dvcf47_62TpHJxwsCB1TN9_mRem2H_fYz1xvcAU1M,829
+KratosMultiphysics/ShapeOptimizationApplication/communicator_factory.py,sha256=9NSATyaxhMW_yv5Ae67cfwKq27FyL689-LGEWFeYBiA,13757
+KratosMultiphysics/ShapeOptimizationApplication/mapper_factory.py,sha256=yVXN295yl_IXzSaYVTh7msxaPXECK1W8RNkgcJDZLQ8,5575
+KratosMultiphysics/ShapeOptimizationApplication/model_part_controller_factory.py,sha256=_HW1wpi_UZjf2I1ZAC0oYTkWbjYLmickyxYmx_Mt9XU,9924
+KratosMultiphysics/ShapeOptimizationApplication/optimizer_factory.py,sha256=HDCu_RK1zs_yCP17wuqumk_O-6fgn_JJgwF7Rmr78q8,13568
+KratosMultiphysics/ShapeOptimizationApplication/algorithms/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_base.py,sha256=lWeYNZA4_V4naLJrZd6EKC__T8RHfeJJXmQR8zxnLKk,1725
+KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_bead_optimization.py,sha256=I8OclO10pYi4_3wihNeNSC5XaqcEmacrGMmR4ZJcQac,22391
+KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_factory.py,sha256=2Iso4A9mwiapcY5_PZWwt0mHe64aoReaWsaeHdwO8n4,3535
+KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_gradient_projection.py,sha256=uEhNW4QoWhVNi2MYrpM4Z5Cj5RF5ej2_AhSJgeUXUpo,16642
+KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_penalized_projection.py,sha256=YcHqA9-UOUpDoYRng2NgBGYIfCN57gNo9EumjPjGVuI,12034
+KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_relaxed_gradient_projection.py,sha256=yKt3fvCFQNF2bRC1zbxrSnibFUBVWdxR2SpK-c2Q698,30725
+KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_shape_fraction_optimization.py,sha256=V78vXDkRYXCHdVKhGd3fms8rI8yCQqPt3-sdov1bJ94,30335
+KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_steepest_descent.py,sha256=S6q81kv_HlyhG5UY-_hyQ1FmspNrv3OY4_0zdaj9AzI,13418
+KratosMultiphysics/ShapeOptimizationApplication/algorithms/algorithm_trust_region.py,sha256=QoD7t3K50Jbxz2r4_gxsHGeoEmEMAkPygIXuDEHcIms,32060
+KratosMultiphysics/ShapeOptimizationApplication/analyzers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_base.py,sha256=giI6nevXndS6W0Qn9oBx-NKCde4YiWyhbGXWMqoVMz0,1346
+KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_empty.py,sha256=hZC9KN4bXuKyPzdZinPykhur1eXBhKUnMw0ZlkDsouY,877
+KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_factory.py,sha256=v0pjiLY3RoVxXgrrhiSC3uzlv4L-4nHPQ69FkZrZsQY,15569
+KratosMultiphysics/ShapeOptimizationApplication/analyzers/analyzer_internal.py,sha256=gie2Pykh-nWu3uCf1Ki3xwBxWW4o03aO4h7472G_ZB8,8438
+KratosMultiphysics/ShapeOptimizationApplication/custom_ios/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/ShapeOptimizationApplication/custom_ios/wrl_io.py,sha256=wDyapbQfSv_I0n5341NMZs0t1UCUnedWy7DJbljaSh4,3006
+KratosMultiphysics/ShapeOptimizationApplication/custom_ios/wrl_reader.py,sha256=HA6YZiXTDuZziB8aQ80BjEnzZT5euvrZLOR_035AX6s,3715
+KratosMultiphysics/ShapeOptimizationApplication/loggers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/ShapeOptimizationApplication/loggers/data_logger_factory.py,sha256=JXDimuQPnCzgA10_J72VvSN71MpHYIqkDMmoZf86eA0,11762
+KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_base.py,sha256=WRwt6hjkMQ7ANBHjFddFYchsBhFRqBqy1cgMB1PBLgA,1451
+KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_gid.py,sha256=GkfxW4LF8OuDO5lR9fE08GyylhQmbfw-zU85YGNSqvg,5577
+KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_unv.py,sha256=pFWRIeS5aqSNgUW8SzjMVwt4gmRGXuYErKomBzvyiFk,3676
+KratosMultiphysics/ShapeOptimizationApplication/loggers/design_logger_vtk.py,sha256=0Epj27iNFw3jorJtM5Ou302QVz8mY5AqEBakkdO-VOY,4584
+KratosMultiphysics/ShapeOptimizationApplication/loggers/sensitivity_heatmap_logger.py,sha256=QDggPERtmM1OVlBhWZ_qWJ9Gv57ibOsSQ8QhTHrIPgc,4984
+KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_base.py,sha256=9sam-J6Y6aSH2rcoNNbYRdK_TWZzFnNRE7iy4rtl328,6333
+KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_bead_optimization.py,sha256=iXMC6bTcXlDYpEjBHfnFkslsQEt_P2ujCDe1XAUkilo,4870
+KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_gradient_projection.py,sha256=HV8jixGVsQ8KO7mp0p3Lulx2dAzcECXzwdXmoTL1WCM,4498
+KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_penalized_projection.py,sha256=nRFIGTDCGkHc64B_PKvH3zdLIXQjbsbulK4BFax_AS4,4432
+KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_relaxed_gradient_projection.py,sha256=5GUGKr9zEoL4FGabNGnjVVYXr4hV5h62HSOSygIZzoo,6630
+KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_shape_fraction_optimization.py,sha256=xHLbt45DDSc6vGlJc417Ri4p2a4b8U9khEtsBQNkyzc,5253
+KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_steepest_descent.py,sha256=jskpwvsHtOQyNamzXx_5xtwFd8MD1IDaTeBsP6rp67A,3509
+KratosMultiphysics/ShapeOptimizationApplication/loggers/value_logger_trust_region.py,sha256=gtcW30-ql3ydM-tk6rc0KmC_HV-sClBWa9EtoWb1ffA,5935
+KratosMultiphysics/ShapeOptimizationApplication/mapping/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/ShapeOptimizationApplication/mapping/in_plane_vertex_morphing_mapper.py,sha256=11eMwIV1x2EgC97Zu7vwwEdG89O2H-BWYaOz3eoQ0nc,7041
+KratosMultiphysics/ShapeOptimizationApplication/mapping/sliding_vertex_morphing_mapper.py,sha256=Bc7c1_e3z8nhn6osIkcjS0J_Gmdj3wEbl1o3EB_Q6yE,19078
+KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_base.py,sha256=xgdzjI4A-vuc61bW37CCxkbKJMF0Pdx3CIt0oD1z9vs,1016
+KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_basic_updating.py,sha256=ugFexu1a0gLTrevVK2nX6vfmfrD68Lka3kmiWbaYCtc,1643
+KratosMultiphysics/ShapeOptimizationApplication/mesh_controllers/mesh_controller_with_solver.py,sha256=G9xP_nC0qQz0Q-jsHmtDrVgGE5RfPhhkSU2uHwg-yY4,12499
+KratosMultiphysics/ShapeOptimizationApplication/response_functions/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/ShapeOptimizationApplication/response_functions/airfoil_2d_responses.py,sha256=HkNwrTAeeFnBAMBDYQRMJpaX5vI7NYx4_ro7b2-tPZ8,8273
+KratosMultiphysics/ShapeOptimizationApplication/response_functions/face_angle.py,sha256=Gp0CnHkJa5hH7tfHzymlygwTNleNcekNcp-Ig4VNwRA,6317
+KratosMultiphysics/ShapeOptimizationApplication/response_functions/mesh_based_packaging.py,sha256=TNzRk1WQyRXcNLciG4aNk6K7bMXi9orOTO5B-zJnULw,3534
+KratosMultiphysics/ShapeOptimizationApplication/response_functions/packaging_response_base.py,sha256=RIuCPasV0Ap2v9iyxScmmeHKyldsfpzOInl2OI8gIsA,6400
+KratosMultiphysics/ShapeOptimizationApplication/response_functions/plane_based_packaging.py,sha256=sdKZaYg8Lc9AnXvp9MFVhAn0-Sfb9gDCRpuTy579ijY,2425
+KratosMultiphysics/ShapeOptimizationApplication/response_functions/response_function_factory.py,sha256=1GAmGJrukayEZroRYqltSrfs0J55iNc5dSnyIfNTV7Q,2242
+KratosMultiphysics/ShapeOptimizationApplication/response_functions/surface_normal_shape_change.py,sha256=IbIGNBWKO0OXWT1TANobctYkcO5dSdTpt61DXNHQyNo,5433
+KratosMultiphysics/ShapeOptimizationApplication/response_functions/total_volume.py,sha256=L_ZhN7p3-m-ER8bwaQGzPUWuKnVOHQi5srZwGwWY7L4,2086
+KratosMultiphysics/ShapeOptimizationApplication/utilities/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_math.py,sha256=ns-UiNH_qkBCQdz_GlaoDrhsOkYfKNiYhon7Cu060r4,14720
+KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_sensitivity_heatmap.py,sha256=IXt4bDPYCcSt0i0H-4f6ODvukzGiJnxFqTvFJ9ae4aE,12054
+KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_timer.py,sha256=KV99mW2APLHE90bIX3biGnzk7KjG3_kkeadlSiKGFas,1854
+KratosMultiphysics/ShapeOptimizationApplication/utilities/custom_variable_utilities.py,sha256=MtTU85ksxGYO0KbU0EQ7m81cENmnQo0QH6ZrMQc3Oro,2301
+KratosShapeOptimizationApplication-9.5.1.dist-info/METADATA,sha256=H8hNXQ3I8xyCFySC4DaFDudfVSUhz8BWHYHaMaywfZU,2440
+KratosShapeOptimizationApplication-9.5.1.dist-info/WHEEL,sha256=GZFS91_ufm4WrNPBaFVPB9MvOXR6bMZQhPcZRRTN5YM,100
+KratosShapeOptimizationApplication-9.5.1.dist-info/top_level.txt,sha256=8Ov--opRCptLbHStjyiZUVpzN1OUU_F7c7fGmsR5cMc,19
+KratosShapeOptimizationApplication-9.5.1.dist-info/RECORD,,
```


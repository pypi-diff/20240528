# Comparing `tmp/KratosDEMApplication-9.5-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip` & `tmp/KratosDEMApplication-9.5.1-cp39-cp39-win_amd64.whl.zip`

## zipinfo -v {}

 * *Differences in extra fields detected; using output from zipinfo -v*

```diff
@@ -1,2263 +1,1583 @@
 There is no zipfile comment.
 
 End-of-central-directory record:
 -------------------------------
 
-  Zip archive file size:                   4368511 (000000000042A87Fh)
-  Actual end-cent-dir record offset:       4368489 (000000000042A869h)
-  Expected end-cent-dir record offset:     4368489 (000000000042A869h)
+  Zip archive file size:                   1907633 (00000000001D1BB1h)
+  Actual end-cent-dir record offset:       1907611 (00000000001D1B9Bh)
+  Expected end-cent-dir record offset:     1907611 (00000000001D1B9Bh)
   (based on the length of the central directory and its expected offset)
 
   This zipfile constitutes the sole disk of a single-part archive; its
-  central directory contains 61 entries.
-  The central directory is 7854 (0000000000001EAEh) bytes long,
+  central directory contains 54 entries.
+  The central directory is 5791 (000000000000169Fh) bytes long,
   and its (expected) offset in bytes from the beginning of the zipfile
-  is 4360635 (00000000004289BBh).
+  is 1901820 (00000000001D04FCh).
 
 
 Central directory entry #1:
 ---------------------------
 
-  KratosDEMApplication-9.5.dist-info/
+  KratosMultiphysics/.libs/KratosDEMApplication.pyd
 
   offset of local header from start of archive:   0
                                                   (0000000000000000h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:25 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:25 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             35 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:30
+  32-bit CRC value (hex):                         d2ad072e
+  compressed size:                                443572 bytes
+  uncompressed size:                              1500160 bytes
+  length of filename:                             49 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #2:
 ---------------------------
 
-  KratosDEMApplication-9.5.dist-info/METADATA
+  KratosMultiphysics/.libs/KratosDEMCore.dll
 
-  offset of local header from start of archive:   93
-                                                  (000000000000005Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   443651
+                                                  (000000000006C503h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         584d6b1e
-  compressed size:                                4339 bytes
-  uncompressed size:                              10815 bytes
-  length of filename:                             43 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:30
+  32-bit CRC value (hex):                         25174ba6
+  compressed size:                                1176302 bytes
+  uncompressed size:                              3772928 bytes
+  length of filename:                             42 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #3:
 ---------------------------
 
-  KratosDEMApplication-9.5.dist-info/WHEEL
+  KratosMultiphysics/.libs/KratosDEMCore.lib
 
-  offset of local header from start of archive:   4533
-                                                  (00000000000011B5h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1620025
+                                                  (000000000018B839h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         90d34e0d
-  compressed size:                                116 bytes
-  uncompressed size:                              148 bytes
-  length of filename:                             40 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:30
+  32-bit CRC value (hex):                         1140ee43
+  compressed size:                                151232 bytes
+  uncompressed size:                              1317282 bytes
+  length of filename:                             42 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #4:
 ---------------------------
 
-  KratosDEMApplication-9.5.dist-info/top_level.txt
+  KratosMultiphysics/DEMApplication/Chung_Ooi_class.py
 
-  offset of local header from start of archive:   4747
-                                                  (000000000000128Bh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1771329
+                                                  (00000000001B0741h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         f32d789f
-  compressed size:                                19 bytes
-  uncompressed size:                              19 bytes
-  length of filename:                             48 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         c0c99708
+  compressed size:                                4256 bytes
+  uncompressed size:                              42099 bytes
+  length of filename:                             52 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #5:
 ---------------------------
 
-  KratosDEMApplication-9.5.dist-info/RECORD
+  KratosMultiphysics/DEMApplication/DEM_analysis_stage.py
 
-  offset of local header from start of archive:   4872
-                                                  (0000000000001308h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1775667
+                                                  (00000000001B1833h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:25 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:25 UTC
-  32-bit CRC value (hex):                         994c9f5d
-  compressed size:                                2776 bytes
-  uncompressed size:                              6431 bytes
-  length of filename:                             41 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         e1870ae7
+  compressed size:                                9252 bytes
+  uncompressed size:                              56120 bytes
+  length of filename:                             55 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100664 octal):            -rw-rw-r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #6:
 ---------------------------
 
-  KratosDEMApplication.libs/
+  KratosMultiphysics/DEMApplication/DEM_benchmarks_class.py
 
-  offset of local header from start of archive:   7747
-                                                  (0000000000001E43h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1785004
+                                                  (00000000001B3CACh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:25 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:25 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             26 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         acf0159c
+  compressed size:                                15861 bytes
+  uncompressed size:                              233222 bytes
+  length of filename:                             57 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #7:
 ---------------------------
 
-  KratosDEMApplication.libs/libKratosDEMCore-264e7349.so
+  KratosMultiphysics/DEMApplication/DEM_inlet_process.py
 
-  offset of local header from start of archive:   7831
-                                                  (0000000000001E97h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1800952
+                                                  (00000000001B7AF8h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         c53dd055
-  compressed size:                                2975803 bytes
-  uncompressed size:                              11346777 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         c472f4f7
+  compressed size:                                880 bytes
+  uncompressed size:                              3275 bytes
   length of filename:                             54 characters
-  length of extra field:                          24 bytes
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100755 octal):            -rwxr-xr-x
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #8:
 ---------------------------
 
-  KratosMultiphysics/
+  KratosMultiphysics/DEMApplication/DEM_material_test_script.py
 
-  offset of local header from start of archive:   2983746
-                                                  (00000000002D8742h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1801916
+                                                  (00000000001B7EBCh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             19 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         cc72075b
+  compressed size:                                6635 bytes
+  uncompressed size:                              37379 bytes
+  length of filename:                             61 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #9:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/
+  KratosMultiphysics/DEMApplication/DEM_material_test_script_mpi.py
 
-  offset of local header from start of archive:   2983823
-                                                  (00000000002D878Fh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1808642
+                                                  (00000000001B9902h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             34 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         685daa78
+  compressed size:                                2237 bytes
+  uncompressed size:                              9503 bytes
+  length of filename:                             65 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #10:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/continuum_sphere_strategy.py
+  KratosMultiphysics/DEMApplication/DEM_procedures.py
 
-  offset of local header from start of archive:   2983915
-                                                  (00000000002D87EBh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1810974
+                                                  (00000000001BA21Eh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         d3b41b15
-  compressed size:                                2075 bytes
-  uncompressed size:                              7979 bytes
-  length of filename:                             62 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         8a35ac0e
+  compressed size:                                16038 bytes
+  uncompressed size:                              100799 bytes
+  length of filename:                             51 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #11:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/concentric_element_size_coarsener.py
+  KratosMultiphysics/DEMApplication/DEM_procedures_mpi.py
 
-  offset of local header from start of archive:   2986110
-                                                  (00000000002D907Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1827093
+                                                  (00000000001BE115h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         722b597b
-  compressed size:                                2201 bytes
-  uncompressed size:                              10222 bytes
-  length of filename:                             70 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         7becf637
+  compressed size:                                1876 bytes
+  uncompressed size:                              6680 bytes
+  length of filename:                             55 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #12:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/KratosDEMAnalysis.py
+  KratosMultiphysics/DEMApplication/DEM_procedures_mpi_no_partitions.py
 
-  offset of local header from start of archive:   2988439
-                                                  (00000000002D9997h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1829054
+                                                  (00000000001BE8BEh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         111118bc
-  compressed size:                                458 bytes
-  uncompressed size:                              1195 bytes
-  length of filename:                             54 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         d50120c9
+  compressed size:                                421 bytes
+  uncompressed size:                              1328 bytes
+  length of filename:                             69 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #13:
 ---------------------------
 
   KratosMultiphysics/DEMApplication/DEM_restart_utility.py
 
-  offset of local header from start of archive:   2989009
-                                                  (00000000002D9BD1h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1829574
+                                                  (00000000001BEAC6h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         905809aa
-  compressed size:                                856 bytes
-  uncompressed size:                              2850 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         79c8513d
+  compressed size:                                868 bytes
+  uncompressed size:                              2914 bytes
   length of filename:                             56 characters
-  length of extra field:                          24 bytes
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #14:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/analytic_tools/
+  KratosMultiphysics/DEMApplication/DEM_save_restart_process.py
 
-  offset of local header from start of archive:   2989979
-                                                  (00000000002D9F9Bh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1830528
+                                                  (00000000001BEE80h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             49 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         a1c0924f
+  compressed size:                                890 bytes
+  uncompressed size:                              2235 bytes
+  length of filename:                             61 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #15:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/analytic_tools/analytic_data_procedures.py
+  KratosMultiphysics/DEMApplication/KratosDEM.py
 
-  offset of local header from start of archive:   2990086
-                                                  (00000000002DA006h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1831509
+                                                  (00000000001BF255h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         896b4e0b
-  compressed size:                                2452 bytes
-  uncompressed size:                              10484 bytes
-  length of filename:                             76 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         9cbe4700
+  compressed size:                                165 bytes
+  uncompressed size:                              320 bytes
+  length of filename:                             46 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #16:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/analytic_tools/__init__.py
+  KratosMultiphysics/DEMApplication/KratosDEMAnalysis.py
 
-  offset of local header from start of archive:   2992672
-                                                  (00000000002DAA20h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  offset of local header from start of archive:   1831750
+                                                  (00000000001BF346h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             60 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         b4fbc242
+  compressed size:                                465 bytes
+  uncompressed size:                              1229 bytes
+  length of filename:                             54 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #17:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/processes/
+  KratosMultiphysics/DEMApplication/MPIer.py
 
-  offset of local header from start of archive:   2992790
-                                                  (00000000002DAA96h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1832299
+                                                  (00000000001BF56Bh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             44 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         25ec3b0c
+  compressed size:                                632 bytes
+  uncompressed size:                              2821 bytes
+  length of filename:                             42 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #18:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/processes/multiaxial_control_module_generalized_2d_process.py
+  KratosMultiphysics/DEMApplication/__init__.py
 
-  offset of local header from start of archive:   2992892
-                                                  (00000000002DAAFCh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1833003
+                                                  (00000000001BF82Bh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         8af819af
-  compressed size:                                1243 bytes
-  uncompressed size:                              4621 bytes
-  length of filename:                             95 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         05872abb
+  compressed size:                                100 bytes
+  uncompressed size:                              223 bytes
+  length of filename:                             45 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #19:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/processes/apply_forces_and_moments_process.py
+  KratosMultiphysics/DEMApplication/angle_finder.py
 
-  offset of local header from start of archive:   2994288
-                                                  (00000000002DB070h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1833178
+                                                  (00000000001BF8DAh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         027d266a
-  compressed size:                                532 bytes
-  uncompressed size:                              1429 bytes
-  length of filename:                             79 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         0a7a7e73
+  compressed size:                                884 bytes
+  uncompressed size:                              2220 bytes
+  length of filename:                             49 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #20:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/processes/apply_kinematic_constraints_process.py
+  KratosMultiphysics/DEMApplication/automatic_dt_process.py
 
-  offset of local header from start of archive:   2994957
-                                                  (00000000002DB30Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1834141
+                                                  (00000000001BFC9Dh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         e0f7d0b4
-  compressed size:                                558 bytes
-  uncompressed size:                              1557 bytes
-  length of filename:                             82 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         31a5ebc8
+  compressed size:                                369 bytes
+  uncompressed size:                              820 bytes
+  length of filename:                             57 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #21:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/processes/__init__.py
+  KratosMultiphysics/DEMApplication/cartesian_specimen_mdpa_creator.py
 
-  offset of local header from start of archive:   2995655
-                                                  (00000000002DB5C7h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  offset of local header from start of archive:   1834597
+                                                  (00000000001BFE65h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             55 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         fbc6fdff
+  compressed size:                                365 bytes
+  uncompressed size:                              592 bytes
+  length of filename:                             68 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #22:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/processes/apply_forces_and_moments_to_walls_process.py
+  KratosMultiphysics/DEMApplication/cluster_file_reader.py
 
-  offset of local header from start of archive:   2995768
-                                                  (00000000002DB638h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1835060
+                                                  (00000000001C0034h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         e0a3892d
-  compressed size:                                551 bytes
-  uncompressed size:                              1451 bytes
-  length of filename:                             88 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         4a6a4ec0
+  compressed size:                                735 bytes
+  uncompressed size:                              2728 bytes
+  length of filename:                             56 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #23:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/processes/apply_kinematic_constraints_to_walls_process.py
+  KratosMultiphysics/DEMApplication/concentric_element_size_coarsener.py
 
-  offset of local header from start of archive:   2996465
-                                                  (00000000002DB8F1h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1835881
+                                                  (00000000001C0369h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         1136876d
-  compressed size:                                564 bytes
-  uncompressed size:                              1564 bytes
-  length of filename:                             91 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         98a7f007
+  compressed size:                                2214 bytes
+  uncompressed size:                              10399 bytes
+  length of filename:                             70 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #24:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/cluster_file_reader.py
+  KratosMultiphysics/DEMApplication/continuum_sphere_strategy.py
 
-  offset of local header from start of archive:   2997178
-                                                  (00000000002DBBBAh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1838195
+                                                  (00000000001C0C73h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         1d98f7ad
-  compressed size:                                730 bytes
-  uncompressed size:                              2654 bytes
-  length of filename:                             56 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         d3b41b15
+  compressed size:                                2075 bytes
+  uncompressed size:                              7979 bytes
+  length of filename:                             62 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #25:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/angle_finder.py
+  KratosMultiphysics/DEMApplication/control_module_2d_process.py
 
-  offset of local header from start of archive:   2998022
-                                                  (00000000002DBF06h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1840362
+                                                  (00000000001C14EAh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         a3ad3aa5
-  compressed size:                                871 bytes
-  uncompressed size:                              2165 bytes
-  length of filename:                             49 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         59705cc2
+  compressed size:                                560 bytes
+  uncompressed size:                              1347 bytes
+  length of filename:                             62 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #26:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/spreader.py
+  KratosMultiphysics/DEMApplication/dem_default_input_parameters.py
 
-  offset of local header from start of archive:   2999000
-                                                  (00000000002DC2D8h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1841014
+                                                  (00000000001C1776h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         a72c1c3c
-  compressed size:                                864 bytes
-  uncompressed size:                              3883 bytes
-  length of filename:                             45 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         53c7e3e6
+  compressed size:                                2158 bytes
+  uncompressed size:                              10145 bytes
+  length of filename:                             65 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #27:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/mesh_creator_cluster.py
+  KratosMultiphysics/DEMApplication/dem_vtk_output.py
 
-  offset of local header from start of archive:   2999967
-                                                  (00000000002DC69Fh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1843267
+                                                  (00000000001C2043h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         9097545e
-  compressed size:                                1168 bytes
-  uncompressed size:                              4935 bytes
-  length of filename:                             57 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         3be6c4ef
+  compressed size:                                3783 bytes
+  uncompressed size:                              23563 bytes
+  length of filename:                             51 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #28:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/mesh_to_mdpa_converter.py
+  KratosMultiphysics/DEMApplication/ice_continuum_sphere_strategy.py
 
-  offset of local header from start of archive:   3001250
-                                                  (00000000002DCBA2h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1847131
+                                                  (00000000001C2F5Bh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         4b83f967
-  compressed size:                                1511 bytes
-  uncompressed size:                              5756 bytes
-  length of filename:                             59 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         09edb34b
+  compressed size:                                317 bytes
+  uncompressed size:                              875 bytes
+  length of filename:                             66 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #29:
 ---------------------------
 
   KratosMultiphysics/DEMApplication/materials_assignation_utility.py
 
-  offset of local header from start of archive:   3002878
-                                                  (00000000002DD1FEh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1847544
+                                                  (00000000001C30F8h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         42c5ca4c
-  compressed size:                                1158 bytes
-  uncompressed size:                              5312 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         33f444a1
+  compressed size:                                1167 bytes
+  uncompressed size:                              5407 bytes
   length of filename:                             66 characters
-  length of extra field:                          24 bytes
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #30:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/MPIer.py
+  KratosMultiphysics/DEMApplication/mesh_creator_cluster.py
 
-  offset of local header from start of archive:   3004160
-                                                  (00000000002DD700h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1848807
+                                                  (00000000001C35E7h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         5d6112bf
-  compressed size:                                623 bytes
-  uncompressed size:                              2739 bytes
-  length of filename:                             42 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         c71cdc68
+  compressed size:                                1172 bytes
+  uncompressed size:                              5056 bytes
+  length of filename:                             57 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #31:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/dem_default_input_parameters.py
+  KratosMultiphysics/DEMApplication/mesh_creator_sphere.py
 
-  offset of local header from start of archive:   3004883
-                                                  (00000000002DD9D3h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1850066
+                                                  (00000000001C3AD2h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         9cea5ce4
-  compressed size:                                2145 bytes
-  uncompressed size:                              9954 bytes
-  length of filename:                             65 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         66095840
+  compressed size:                                503 bytes
+  uncompressed size:                              1547 bytes
+  length of filename:                             56 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #32:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/DEM_procedures_mpi.py
+  KratosMultiphysics/DEMApplication/mesh_to_mdpa_converter.py
 
-  offset of local header from start of archive:   3007151
-                                                  (00000000002DE2AFh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1850655
+                                                  (00000000001C3D1Fh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         df55f20b
-  compressed size:                                1867 bytes
-  uncompressed size:                              6492 bytes
-  length of filename:                             55 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         211f1501
+  compressed size:                                1538 bytes
+  uncompressed size:                              5948 bytes
+  length of filename:                             59 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #33:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/DEM_procedures_mpi_no_partitions.py
+  KratosMultiphysics/DEMApplication/multiaxial_control_module_generalized_2d_utility.py
 
-  offset of local header from start of archive:   3009131
-                                                  (00000000002DEA6Bh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1852282
+                                                  (00000000001C437Ah) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         131341b6
-  compressed size:                                412 bytes
-  uncompressed size:                              1296 bytes
-  length of filename:                             69 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         254e8924
+  compressed size:                                1888 bytes
+  uncompressed size:                              12540 bytes
+  length of filename:                             85 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #34:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/cartesian_specimen_mdpa_creator.py
+  KratosMultiphysics/DEMApplication/plot_variables.py
 
-  offset of local header from start of archive:   3009670
-                                                  (00000000002DEC86h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1854285
+                                                  (00000000001C4B4Dh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         22161039
-  compressed size:                                356 bytes
-  uncompressed size:                              580 bytes
-  length of filename:                             68 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         167f135a
+  compressed size:                                980 bytes
+  uncompressed size:                              5408 bytes
+  length of filename:                             51 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #35:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/Chung_Ooi_class.py
+  KratosMultiphysics/DEMApplication/sphere_strategy.py
 
-  offset of local header from start of archive:   3010152
-                                                  (00000000002DEE68h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1855346
+                                                  (00000000001C4F72h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         ddc3452f
-  compressed size:                                4223 bytes
-  uncompressed size:                              41250 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         ca109dc8
+  compressed size:                                8038 bytes
+  uncompressed size:                              40051 bytes
   length of filename:                             52 characters
-  length of extra field:                          24 bytes
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #36:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/dem_vtk_output.py
+  KratosMultiphysics/DEMApplication/spreader.py
 
-  offset of local header from start of archive:   3014485
-                                                  (00000000002DFF55h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1863466
+                                                  (00000000001C6F2Ah) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         d419f926
-  compressed size:                                3755 bytes
-  uncompressed size:                              23107 bytes
-  length of filename:                             51 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         00c1f0d9
+  compressed size:                                872 bytes
+  uncompressed size:                              3978 bytes
+  length of filename:                             45 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #37:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/control_module_2d_process.py
+  KratosMultiphysics/DEMApplication/time_step_testing_stage.py
 
-  offset of local header from start of archive:   3018349
-                                                  (00000000002E0E6Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1864413
+                                                  (00000000001C72DDh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         6c87de68
-  compressed size:                                553 bytes
-  uncompressed size:                              1319 bytes
-  length of filename:                             62 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         a492f83a
+  compressed size:                                3062 bytes
+  uncompressed size:                              13624 bytes
+  length of filename:                             60 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #38:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/DEM_analysis_stage.py
+  KratosMultiphysics/DEMApplication/triaxial2d_test.py
 
-  offset of local header from start of archive:   3019022
-                                                  (00000000002E110Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1867565
+                                                  (00000000001C7F2Dh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         3c63b9d7
-  compressed size:                                9214 bytes
-  uncompressed size:                              54973 bytes
-  length of filename:                             55 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         5e2d2a74
+  compressed size:                                1168 bytes
+  uncompressed size:                              3709 bytes
+  length of filename:                             52 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #39:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/custom_material_tests/
+  KratosMultiphysics/DEMApplication/verlet_continuum_sphere_strategy.py
 
-  offset of local header from start of archive:   3028349
-                                                  (00000000002E357Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1868815
+                                                  (00000000001C840Fh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             56 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         7388b904
+  compressed size:                                1470 bytes
+  uncompressed size:                              4939 bytes
+  length of filename:                             69 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #40:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_triaxial_test.py
+  KratosMultiphysics/DEMApplication/analytic_tools/__init__.py
 
-  offset of local header from start of archive:   3028463
-                                                  (00000000002E35EFh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1870384
+                                                  (00000000001C8A30h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         473195a0
-  compressed size:                                5516 bytes
-  uncompressed size:                              28791 bytes
-  length of filename:                             94 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                2 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             60 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #41:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_triaxials_and_bts_tests.py
+  KratosMultiphysics/DEMApplication/analytic_tools/analytic_data_procedures.py
 
-  offset of local header from start of archive:   3034131
-                                                  (00000000002E4C13h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1870476
+                                                  (00000000001C8A8Ch) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         80a3c913
-  compressed size:                                6849 bytes
-  uncompressed size:                              56180 bytes
-  length of filename:                             104 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         12e4d21e
+  compressed size:                                2471 bytes
+  uncompressed size:                              10743 bytes
+  length of filename:                             76 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #42:
 ---------------------------
 
   KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_bts_test.py
 
-  offset of local header from start of archive:   3041142
-                                                  (00000000002E6776h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1873053
+                                                  (00000000001C949Dh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         b0ac5e04
-  compressed size:                                4305 bytes
-  uncompressed size:                              24298 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         a2fda164
+  compressed size:                                4328 bytes
+  uncompressed size:                              24844 bytes
   length of filename:                             89 characters
-  length of extra field:                          24 bytes
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #43:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/DEM_material_test_script.py
+  KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_triaxial_test.py
 
-  offset of local header from start of archive:   3045594
-                                                  (00000000002E78DAh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1877500
+                                                  (00000000001CA5FCh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         92e283fd
-  compressed size:                                6631 bytes
-  uncompressed size:                              36500 bytes
-  length of filename:                             61 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         fa7c3284
+  compressed size:                                5540 bytes
+  uncompressed size:                              29425 bytes
+  length of filename:                             94 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #44:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/DEM_benchmarks_class.py
+  KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_triaxials_and_bts_tests.py
 
-  offset of local header from start of archive:   3052344
-                                                  (00000000002E9338h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1883164
+                                                  (00000000001CBC1Ch) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         8c51764e
-  compressed size:                                15719 bytes
-  uncompressed size:                              228284 bytes
-  length of filename:                             57 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         cb609f3f
+  compressed size:                                6846 bytes
+  uncompressed size:                              57414 bytes
+  length of filename:                             104 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #45:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/multiaxial_control_module_generalized_2d_utility.py
+  KratosMultiphysics/DEMApplication/processes/__init__.py
 
-  offset of local header from start of archive:   3068178
-                                                  (00000000002ED112h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1890144
+                                                  (00000000001CD760h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         254e8924
-  compressed size:                                1888 bytes
-  uncompressed size:                              12540 bytes
-  length of filename:                             85 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                2 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             55 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #46:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/ice_continuum_sphere_strategy.py
+  KratosMultiphysics/DEMApplication/processes/apply_forces_and_moments_process.py
 
-  offset of local header from start of archive:   3070209
-                                                  (00000000002ED901h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1890231
+                                                  (00000000001CD7B7h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         de0bd445
-  compressed size:                                315 bytes
-  uncompressed size:                              850 bytes
-  length of filename:                             66 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         380e20cf
+  compressed size:                                538 bytes
+  uncompressed size:                              1467 bytes
+  length of filename:                             79 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #47:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/plot_variables.py
+  KratosMultiphysics/DEMApplication/processes/apply_forces_and_moments_to_walls_process.py
 
-  offset of local header from start of archive:   3070648
-                                                  (00000000002EDAB8h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1890878
+                                                  (00000000001CDA3Eh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         82dd9ff2
-  compressed size:                                968 bytes
-  uncompressed size:                              5279 bytes
-  length of filename:                             51 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         b3e2bca7
+  compressed size:                                556 bytes
+  uncompressed size:                              1489 bytes
+  length of filename:                             88 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #48:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/time_step_testing_stage.py
+  KratosMultiphysics/DEMApplication/processes/apply_kinematic_constraints_process.py
 
-  offset of local header from start of archive:   3071725
-                                                  (00000000002EDEEDh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1891552
+                                                  (00000000001CDCE0h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         8f60bb27
-  compressed size:                                3046 bytes
-  uncompressed size:                              13341 bytes
-  length of filename:                             60 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         fcc54217
+  compressed size:                                563 bytes
+  uncompressed size:                              1599 bytes
+  length of filename:                             82 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #49:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/triaxial2d_test.py
+  KratosMultiphysics/DEMApplication/processes/apply_kinematic_constraints_to_walls_process.py
 
-  offset of local header from start of archive:   3074889
-                                                  (00000000002EEB49h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1892227
+                                                  (00000000001CDF83h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         47f345fa
-  compressed size:                                1158 bytes
-  uncompressed size:                              3609 bytes
-  length of filename:                             52 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         97fb38d5
+  compressed size:                                570 bytes
+  uncompressed size:                              1606 bytes
+  length of filename:                             91 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #50:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/DEM_procedures.py
+  KratosMultiphysics/DEMApplication/processes/multiaxial_control_module_generalized_2d_process.py
 
-  offset of local header from start of archive:   3076157
-                                                  (00000000002EF03Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1892918
+                                                  (00000000001CE236h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         04fa9195
-  compressed size:                                15998 bytes
-  uncompressed size:                              98872 bytes
-  length of filename:                             51 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         eb6e2104
+  compressed size:                                1254 bytes
+  uncompressed size:                              4731 bytes
+  length of filename:                             95 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #51:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/automatic_dt_process.py
+  KratosDEMApplication-9.5.1.dist-info/METADATA
 
-  offset of local header from start of archive:   3092264
-                                                  (00000000002F2F28h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1894297
+                                                  (00000000001CE799h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         665151f6
-  compressed size:                                362 bytes
-  uncompressed size:                              802 bytes
-  length of filename:                             57 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:30
+  32-bit CRC value (hex):                         e681a58b
+  compressed size:                                4367 bytes
+  uncompressed size:                              11037 bytes
+  length of filename:                             45 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #52:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/DEM_inlet_process.py
+  KratosDEMApplication-9.5.1.dist-info/WHEEL
 
-  offset of local header from start of archive:   3092741
-                                                  (00000000002F3105h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1898739
+                                                  (00000000001CF8F3h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         28ec14fe
-  compressed size:                                874 bytes
-  uncompressed size:                              3211 bytes
-  length of filename:                             54 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:30
+  32-bit CRC value (hex):                         86fb6b41
+  compressed size:                                96 bytes
+  uncompressed size:                              100 bytes
+  length of filename:                             42 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #53:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/verlet_continuum_sphere_strategy.py
+  KratosDEMApplication-9.5.1.dist-info/top_level.txt
 
-  offset of local header from start of archive:   3093727
-                                                  (00000000002F34DFh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1898907
+                                                  (00000000001CF99Bh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         c08abca4
-  compressed size:                                1467 bytes
-  uncompressed size:                              4851 bytes
-  length of filename:                             69 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:30
+  32-bit CRC value (hex):                         f32d789f
+  compressed size:                                21 bytes
+  uncompressed size:                              19 bytes
+  length of filename:                             50 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #54:
 ---------------------------
 
-  KratosMultiphysics/DEMApplication/__init__.py
+  KratosDEMApplication-9.5.1.dist-info/RECORD
 
-  offset of local header from start of archive:   3095321
-                                                  (00000000002F3B19h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1899008
+                                                  (00000000001CFA00h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         f1b5d04d
-  compressed size:                                97 bytes
-  uncompressed size:                              216 bytes
-  length of filename:                             45 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #55:
----------------------------
-
-  KratosMultiphysics/DEMApplication/DEM_material_test_script_mpi.py
-
-  offset of local header from start of archive:   3095521
-                                                  (00000000002F3BE1h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         ec954d6d
-  compressed size:                                2222 bytes
-  uncompressed size:                              9251 bytes
-  length of filename:                             65 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #56:
----------------------------
-
-  KratosMultiphysics/DEMApplication/KratosDEM.py
-
-  offset of local header from start of archive:   3097866
-                                                  (00000000002F450Ah) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         ff013db9
-  compressed size:                                160 bytes
-  uncompressed size:                              310 bytes
-  length of filename:                             46 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #57:
----------------------------
-
-  KratosMultiphysics/DEMApplication/DEM_save_restart_process.py
-
-  offset of local header from start of archive:   3098130
-                                                  (00000000002F4612h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         20ec936c
-  compressed size:                                881 bytes
-  uncompressed size:                              2190 bytes
-  length of filename:                             61 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #58:
----------------------------
-
-  KratosMultiphysics/DEMApplication/sphere_strategy.py
-
-  offset of local header from start of archive:   3099130
-                                                  (00000000002F49FAh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         64719d85
-  compressed size:                                8034 bytes
-  uncompressed size:                              39250 bytes
-  length of filename:                             52 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #59:
----------------------------
-
-  KratosMultiphysics/DEMApplication/mesh_creator_sphere.py
-
-  offset of local header from start of archive:   3107274
-                                                  (00000000002F69CAh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         c045857a
-  compressed size:                                498 bytes
-  uncompressed size:                              1511 bytes
-  length of filename:                             56 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #60:
----------------------------
-
-  KratosMultiphysics/.libs/
-
-  offset of local header from start of archive:   3107886
-                                                  (00000000002F6C2Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:25 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:25 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             25 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #61:
----------------------------
-
-  KratosMultiphysics/.libs/KratosDEMApplication.cpython-39-x86_64-linux-gnu.so
-
-  offset of local header from start of archive:   3107969
-                                                  (00000000002F6C81h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:58:18
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:58:18 UTC
-  32-bit CRC value (hex):                         3facb431
-  compressed size:                                1252532 bytes
-  uncompressed size:                              4023577 bytes
-  length of filename:                             76 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:32
+  32-bit CRC value (hex):                         e1dded47
+  compressed size:                                2739 bytes
+  uncompressed size:                              6344 bytes
+  length of filename:                             43 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100755 octal):            -rwxr-xr-x
+  non-MSDOS external file attributes:             81B400 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
```

## zipnote {}

```diff
@@ -1,184 +1,163 @@
-Filename: KratosDEMApplication-9.5.dist-info/
+Filename: KratosMultiphysics/.libs/KratosDEMApplication.pyd
 Comment: 
 
-Filename: KratosDEMApplication-9.5.dist-info/METADATA
+Filename: KratosMultiphysics/.libs/KratosDEMCore.dll
 Comment: 
 
-Filename: KratosDEMApplication-9.5.dist-info/WHEEL
+Filename: KratosMultiphysics/.libs/KratosDEMCore.lib
 Comment: 
 
-Filename: KratosDEMApplication-9.5.dist-info/top_level.txt
+Filename: KratosMultiphysics/DEMApplication/Chung_Ooi_class.py
 Comment: 
 
-Filename: KratosDEMApplication-9.5.dist-info/RECORD
+Filename: KratosMultiphysics/DEMApplication/DEM_analysis_stage.py
 Comment: 
 
-Filename: KratosDEMApplication.libs/
+Filename: KratosMultiphysics/DEMApplication/DEM_benchmarks_class.py
 Comment: 
 
-Filename: KratosDEMApplication.libs/libKratosDEMCore-264e7349.so
+Filename: KratosMultiphysics/DEMApplication/DEM_inlet_process.py
 Comment: 
 
-Filename: KratosMultiphysics/
+Filename: KratosMultiphysics/DEMApplication/DEM_material_test_script.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/
+Filename: KratosMultiphysics/DEMApplication/DEM_material_test_script_mpi.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/continuum_sphere_strategy.py
+Filename: KratosMultiphysics/DEMApplication/DEM_procedures.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/concentric_element_size_coarsener.py
+Filename: KratosMultiphysics/DEMApplication/DEM_procedures_mpi.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/KratosDEMAnalysis.py
+Filename: KratosMultiphysics/DEMApplication/DEM_procedures_mpi_no_partitions.py
 Comment: 
 
 Filename: KratosMultiphysics/DEMApplication/DEM_restart_utility.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/analytic_tools/
-Comment: 
-
-Filename: KratosMultiphysics/DEMApplication/analytic_tools/analytic_data_procedures.py
-Comment: 
-
-Filename: KratosMultiphysics/DEMApplication/analytic_tools/__init__.py
+Filename: KratosMultiphysics/DEMApplication/DEM_save_restart_process.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/processes/
+Filename: KratosMultiphysics/DEMApplication/KratosDEM.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/processes/multiaxial_control_module_generalized_2d_process.py
+Filename: KratosMultiphysics/DEMApplication/KratosDEMAnalysis.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/processes/apply_forces_and_moments_process.py
+Filename: KratosMultiphysics/DEMApplication/MPIer.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/processes/apply_kinematic_constraints_process.py
+Filename: KratosMultiphysics/DEMApplication/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/processes/__init__.py
+Filename: KratosMultiphysics/DEMApplication/angle_finder.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/processes/apply_forces_and_moments_to_walls_process.py
+Filename: KratosMultiphysics/DEMApplication/automatic_dt_process.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/processes/apply_kinematic_constraints_to_walls_process.py
+Filename: KratosMultiphysics/DEMApplication/cartesian_specimen_mdpa_creator.py
 Comment: 
 
 Filename: KratosMultiphysics/DEMApplication/cluster_file_reader.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/angle_finder.py
-Comment: 
-
-Filename: KratosMultiphysics/DEMApplication/spreader.py
-Comment: 
-
-Filename: KratosMultiphysics/DEMApplication/mesh_creator_cluster.py
-Comment: 
-
-Filename: KratosMultiphysics/DEMApplication/mesh_to_mdpa_converter.py
+Filename: KratosMultiphysics/DEMApplication/concentric_element_size_coarsener.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/materials_assignation_utility.py
+Filename: KratosMultiphysics/DEMApplication/continuum_sphere_strategy.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/MPIer.py
+Filename: KratosMultiphysics/DEMApplication/control_module_2d_process.py
 Comment: 
 
 Filename: KratosMultiphysics/DEMApplication/dem_default_input_parameters.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/DEM_procedures_mpi.py
-Comment: 
-
-Filename: KratosMultiphysics/DEMApplication/DEM_procedures_mpi_no_partitions.py
-Comment: 
-
-Filename: KratosMultiphysics/DEMApplication/cartesian_specimen_mdpa_creator.py
+Filename: KratosMultiphysics/DEMApplication/dem_vtk_output.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/Chung_Ooi_class.py
+Filename: KratosMultiphysics/DEMApplication/ice_continuum_sphere_strategy.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/dem_vtk_output.py
+Filename: KratosMultiphysics/DEMApplication/materials_assignation_utility.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/control_module_2d_process.py
+Filename: KratosMultiphysics/DEMApplication/mesh_creator_cluster.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/DEM_analysis_stage.py
+Filename: KratosMultiphysics/DEMApplication/mesh_creator_sphere.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/custom_material_tests/
+Filename: KratosMultiphysics/DEMApplication/mesh_to_mdpa_converter.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_triaxial_test.py
+Filename: KratosMultiphysics/DEMApplication/multiaxial_control_module_generalized_2d_utility.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_triaxials_and_bts_tests.py
+Filename: KratosMultiphysics/DEMApplication/plot_variables.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_bts_test.py
+Filename: KratosMultiphysics/DEMApplication/sphere_strategy.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/DEM_material_test_script.py
+Filename: KratosMultiphysics/DEMApplication/spreader.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/DEM_benchmarks_class.py
+Filename: KratosMultiphysics/DEMApplication/time_step_testing_stage.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/multiaxial_control_module_generalized_2d_utility.py
+Filename: KratosMultiphysics/DEMApplication/triaxial2d_test.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/ice_continuum_sphere_strategy.py
+Filename: KratosMultiphysics/DEMApplication/verlet_continuum_sphere_strategy.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/plot_variables.py
+Filename: KratosMultiphysics/DEMApplication/analytic_tools/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/time_step_testing_stage.py
+Filename: KratosMultiphysics/DEMApplication/analytic_tools/analytic_data_procedures.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/triaxial2d_test.py
+Filename: KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_bts_test.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/DEM_procedures.py
+Filename: KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_triaxial_test.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/automatic_dt_process.py
+Filename: KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_triaxials_and_bts_tests.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/DEM_inlet_process.py
+Filename: KratosMultiphysics/DEMApplication/processes/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/verlet_continuum_sphere_strategy.py
+Filename: KratosMultiphysics/DEMApplication/processes/apply_forces_and_moments_process.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/__init__.py
+Filename: KratosMultiphysics/DEMApplication/processes/apply_forces_and_moments_to_walls_process.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/DEM_material_test_script_mpi.py
+Filename: KratosMultiphysics/DEMApplication/processes/apply_kinematic_constraints_process.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/KratosDEM.py
+Filename: KratosMultiphysics/DEMApplication/processes/apply_kinematic_constraints_to_walls_process.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/DEM_save_restart_process.py
+Filename: KratosMultiphysics/DEMApplication/processes/multiaxial_control_module_generalized_2d_process.py
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/sphere_strategy.py
+Filename: KratosDEMApplication-9.5.1.dist-info/METADATA
 Comment: 
 
-Filename: KratosMultiphysics/DEMApplication/mesh_creator_sphere.py
+Filename: KratosDEMApplication-9.5.1.dist-info/WHEEL
 Comment: 
 
-Filename: KratosMultiphysics/.libs/
+Filename: KratosDEMApplication-9.5.1.dist-info/top_level.txt
 Comment: 
 
-Filename: KratosMultiphysics/.libs/KratosDEMApplication.cpython-39-x86_64-linux-gnu.so
+Filename: KratosDEMApplication-9.5.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v1.0 to extract, compression method=store
+Zip archive data, at least v2.0 to extract, compression method=deflate
```

## KratosMultiphysics/DEMApplication/concentric_element_size_coarsener.py

 * *Ordering differences only*

```diff
@@ -1,177 +1,177 @@
-import math
-import scipy.stats as stats
-
-import KratosMultiphysics
-import KratosMultiphysics.DEMApplication as DEM
-from KratosMultiphysics.DEMApplication.DEM_analysis_stage import DEMAnalysisStage
-
-def ComputeMeanRadiusOfThisParticle(x, y, z, fine_radius):
-
-    distance_to_origin = math.sqrt(x*x + y*y)
-
-    specimen_type = 1 # 1: CTW16, # 2: CTW10
-    if specimen_type == 1:
-        max_distance_for_fine_radius = 0.00762
-    else:
-        max_distance_for_fine_radius = 0.01651
-
-    slope = 0.01
-    if distance_to_origin < max_distance_for_fine_radius:
-        radius = fine_radius
-    else:
-        radius = fine_radius + slope * (distance_to_origin - max_distance_for_fine_radius)
-
-    return radius
-
-class ElementSizeModifier(DEMAnalysisStage):
-
-    def __init__(self, model, project_parameters, size_modifier_parameters, flush_frequency=10.0):
-
-
-        self.size_modifier_parameters = size_modifier_parameters
-
-        default_input_parameters = KratosMultiphysics.Parameters("""
-        {
-            "mean_diameter_of_particles": 0.1,
-            "standard_deviation": 0.5,
-            "max_diameter_of_particles": 0.2,
-            "min_diameter_of_particles": 0.05,
-            "initiation_time": 0.0,
-            "process_duration": 1.0,
-            "global_damping": 0.8,
-            "time_step": 5e-7,
-            "geometry_settings": {
-                "geometry_type": "Radial",
-                "inner_radius": 1.0,
-                "outer_radius": 5.0,
-                "tolerance": 0.001
-            },
-            "material_settings":{
-            "static_friction": 0.0,
-            "dynamic_friciton": 0.0,
-            "young_modulus": 5.0e7,
-            "density_for_artificial_concentric_weight": 2500
-            }
-        }
-        """)
-        self.size_modifier_parameters.ValidateAndAssignDefaults(default_input_parameters)
-        self.eraser_counter = 0
-        self.list_of_static_frictions_at_start = []
-        self.list_of_dynamic_frictions_at_start = []
-        self.list_of_young_modulus_at_start = []
-        self.list_of_coefficients_of_restittution_at_start = []
-        self.list_of_damping_gammas_at_start = []
-        project_parameters["GlobalDamping"].SetDouble(self.size_modifier_parameters["global_damping"].GetDouble())
-        project_parameters["GravityX"].SetDouble(0.0)
-        project_parameters["GravityY"].SetDouble(0.0)
-        project_parameters["GravityZ"].SetDouble(0.0)
-        project_parameters["RollingFrictionOption"].SetBool(False)
-        project_parameters["OutputFileType"].SetString("Ascii")
-        project_parameters["MaxTimeStep"].SetDouble(self.size_modifier_parameters["time_step"].GetDouble())
-        total_needed_time = self.size_modifier_parameters["initiation_time"].GetDouble() + self.size_modifier_parameters["process_duration"].GetDouble()
-        if project_parameters["FinalTime"].GetDouble() < total_needed_time:
-            project_parameters["FinalTime"].SetDouble(total_needed_time)
-        super().__init__(model, project_parameters)
-
-    def Initialize(self):
-        super().Initialize()
-        self._SaveInitialRadiusOfAllParticles()
-        self._GetDeviationFromMeanSizeOfAllParticles()
-        for props in self.spheres_model_part.Properties:
-            self.list_of_static_frictions_at_start.append(props[DEM.STATIC_FRICTION])
-            props.SetValue(DEM.STATIC_FRICTION, self.size_modifier_parameters["material_settings"]["static_friction"].GetDouble())
-            self.list_of_dynamic_frictions_at_start.append(props[DEM.DYNAMIC_FRICTION])
-            props.SetValue(DEM.DYNAMIC_FRICTION, self.size_modifier_parameters["material_settings"]["dynamic_friciton"].GetDouble())
-            self.list_of_young_modulus_at_start.append(props[KratosMultiphysics.YOUNG_MODULUS])
-            props.SetValue(KratosMultiphysics.YOUNG_MODULUS, self.size_modifier_parameters["material_settings"]["young_modulus"].GetDouble())
-            self.list_of_coefficients_of_restittution_at_start.append(props[DEM.COEFFICIENT_OF_RESTITUTION])
-            props.SetValue(DEM.COEFFICIENT_OF_RESTITUTION, self.size_modifier_parameters["material_settings"]["coefficient_of_restitution"].GetDouble())
-
-    def InitializeSolutionStep(self):
-        super().InitializeSolutionStep()
-        center = KratosMultiphysics.Array3()
-        center[0] = center[1] = center[2] = 0.0 #TODO: input
-        density = self.size_modifier_parameters["material_settings"]["density_for_artificial_concentric_weight"].GetDouble()
-        self.PreUtilities.ApplyConcentricForceOnParticles(self.spheres_model_part, center, density)
-
-    def FinalizeSolutionStep(self):
-        super().FinalizeSolutionStep()
-        self._ModifyRadiusOfAllParticles()
-        self._EraseElementsOutsideDomainAndMarkSkin()
-
-    def Finalize(self):
-        counter = 0
-        for props in self.spheres_model_part.Properties:
-            props.SetValue(DEM.STATIC_FRICTION, self.list_of_static_frictions_at_start[counter])
-            props.SetValue(DEM.DYNAMIC_FRICTION, self.list_of_dynamic_frictions_at_start[counter])
-            props.SetValue(KratosMultiphysics.YOUNG_MODULUS, self.list_of_young_modulus_at_start[counter])
-            props.SetValue(DEM.COEFFICIENT_OF_RESTITUTION, self.list_of_young_modulus_at_start[counter])
-            counter += 1
-        super().Finalize()
-
-    def _GetDeviationFromMeanSizeOfAllParticles(self):
-        min_radius = (self.size_modifier_parameters["max_diameter_of_particles"].GetDouble())/ 2.0
-        max_radius = (self.size_modifier_parameters["min_diameter_of_particles"].GetDouble())/ 2.0
-        mean_radius_of_particles = 0.5 * self.size_modifier_parameters["mean_diameter_of_particles"].GetDouble()
-        radius_standard_deviation = self.size_modifier_parameters["standard_deviation"].GetDouble() / 2.0
-
-        distribution = stats.truncnorm((min_radius - mean_radius_of_particles)/ radius_standard_deviation, (max_radius - mean_radius_of_particles) / radius_standard_deviation, loc=mean_radius_of_particles, scale=radius_standard_deviation)
-
-        for node in self.spheres_model_part.Nodes:
-            random_radius = distribution.rvs(1)
-            deviation = random_radius[0] - mean_radius_of_particles
-            node.SetValue(DEM.DEVIATION, deviation)
-
-    def _SaveInitialRadiusOfAllParticles(self):
-        for node in self.spheres_model_part.Nodes:
-            node.SetValue(DEM.INITIAL_RADIUS, node.GetSolutionStepValue(KratosMultiphysics.RADIUS))
-
-    def _ModifyRadiusOfAllParticles(self):
-        if self.time > self.size_modifier_parameters["initiation_time"].GetDouble() + self.size_modifier_parameters["process_duration"].GetDouble():
-            return
-        mean_diameter_of_particles = self.size_modifier_parameters["mean_diameter_of_particles"].GetDouble()
-        for node in self.spheres_model_part.Nodes:
-            x = node.X
-            y = node.Y
-            z = node.Z
-            radius_defined_by_function = ComputeMeanRadiusOfThisParticle(x, y, z, mean_diameter_of_particles/2.0)
-            deviation_for_mean_radius = node.GetValue(DEM.DEVIATION)
-            initial_radius = node.GetValue(DEM.INITIAL_RADIUS)
-            actual_deviation_for_current_radius = deviation_for_mean_radius * radius_defined_by_function / initial_radius
-            intended_radius_at_end = radius_defined_by_function + actual_deviation_for_current_radius
-            portion_of_process = (self.time - self.size_modifier_parameters["initiation_time"].GetDouble()) / self.size_modifier_parameters["process_duration"].GetDouble()
-            intended_radius_at_current_time = initial_radius + portion_of_process * (intended_radius_at_end - initial_radius)
-            node.SetSolutionStepValue(KratosMultiphysics.RADIUS, intended_radius_at_current_time)
-
-    def _EraseElementsOutsideDomainAndMarkSkin(self):
-        if self.eraser_counter == 1:
-            self.eraser_counter = 0
-            mean_diameter_of_particles = self.size_modifier_parameters["mean_diameter_of_particles"].GetDouble()
-            if self.size_modifier_parameters["geometry_settings"]["geometry_type"].GetString() == "Radial":
-                max_radius = self.size_modifier_parameters["geometry_settings"]["outer_radius"].GetDouble()
-                tolerance = self.size_modifier_parameters["geometry_settings"]["tolerance"].GetDouble()
-                center = KratosMultiphysics.Array3()
-                center[0] = center[1] = center[2] = 0.0
-                self.PreUtilities.ResetSkinParticles(self.spheres_model_part)
-                self.PreUtilities.MarkToEraseParticlesOutsideRadius(self.spheres_model_part, max_radius, center, tolerance)
-                inner_radius = self.size_modifier_parameters["geometry_settings"]["inner_radius"].GetDouble()
-                radius_at_inner_boundary = mean_diameter_of_particles/2.0
-                self.PreUtilities.SetSkinParticlesInnerBoundary(self.spheres_model_part, inner_radius, 2.0 * radius_at_inner_boundary)
-                radius_at_outer_boundary = ComputeMeanRadiusOfThisParticle(max_radius, 0.0, 0.0, mean_diameter_of_particles/2.0)
-                portion_of_process = (self.time - self.size_modifier_parameters["initiation_time"].GetDouble()) / self.size_modifier_parameters["process_duration"].GetDouble()
-                radius_at_outer_boundary_at_current_time = mean_diameter_of_particles/2.0 + portion_of_process * (radius_at_outer_boundary - mean_diameter_of_particles/2.0)
-                self.PreUtilities.SetSkinParticlesOuterBoundary(self.spheres_model_part, max_radius, 1.4 * radius_at_outer_boundary_at_current_time)
-        else:
-            self.eraser_counter += 1
-
-if __name__ == "__main__":
-    from KratosMultiphysics import Logger
-    Logger.GetDefaultOutput().SetSeverity(Logger.Severity.INFO)
-    with open("ProjectParametersDEM.json",'r') as parameter_file:
-        project_parameters = KratosMultiphysics.Parameters(parameter_file.read())
-
-    with open("SizeModifierParametersDEM.json",'r') as size_modifier_parameter_file:
-        size_modifier_parameters = KratosMultiphysics.Parameters(size_modifier_parameter_file.read())
-
-    model = KratosMultiphysics.Model()
-    ElementSizeModifier(model, project_parameters, size_modifier_parameters).Run()
+import math
+import scipy.stats as stats
+
+import KratosMultiphysics
+import KratosMultiphysics.DEMApplication as DEM
+from KratosMultiphysics.DEMApplication.DEM_analysis_stage import DEMAnalysisStage
+
+def ComputeMeanRadiusOfThisParticle(x, y, z, fine_radius):
+
+    distance_to_origin = math.sqrt(x*x + y*y)
+
+    specimen_type = 1 # 1: CTW16, # 2: CTW10
+    if specimen_type == 1:
+        max_distance_for_fine_radius = 0.00762
+    else:
+        max_distance_for_fine_radius = 0.01651
+
+    slope = 0.01
+    if distance_to_origin < max_distance_for_fine_radius:
+        radius = fine_radius
+    else:
+        radius = fine_radius + slope * (distance_to_origin - max_distance_for_fine_radius)
+
+    return radius
+
+class ElementSizeModifier(DEMAnalysisStage):
+
+    def __init__(self, model, project_parameters, size_modifier_parameters, flush_frequency=10.0):
+
+
+        self.size_modifier_parameters = size_modifier_parameters
+
+        default_input_parameters = KratosMultiphysics.Parameters("""
+        {
+            "mean_diameter_of_particles": 0.1,
+            "standard_deviation": 0.5,
+            "max_diameter_of_particles": 0.2,
+            "min_diameter_of_particles": 0.05,
+            "initiation_time": 0.0,
+            "process_duration": 1.0,
+            "global_damping": 0.8,
+            "time_step": 5e-7,
+            "geometry_settings": {
+                "geometry_type": "Radial",
+                "inner_radius": 1.0,
+                "outer_radius": 5.0,
+                "tolerance": 0.001
+            },
+            "material_settings":{
+            "static_friction": 0.0,
+            "dynamic_friciton": 0.0,
+            "young_modulus": 5.0e7,
+            "density_for_artificial_concentric_weight": 2500
+            }
+        }
+        """)
+        self.size_modifier_parameters.ValidateAndAssignDefaults(default_input_parameters)
+        self.eraser_counter = 0
+        self.list_of_static_frictions_at_start = []
+        self.list_of_dynamic_frictions_at_start = []
+        self.list_of_young_modulus_at_start = []
+        self.list_of_coefficients_of_restittution_at_start = []
+        self.list_of_damping_gammas_at_start = []
+        project_parameters["GlobalDamping"].SetDouble(self.size_modifier_parameters["global_damping"].GetDouble())
+        project_parameters["GravityX"].SetDouble(0.0)
+        project_parameters["GravityY"].SetDouble(0.0)
+        project_parameters["GravityZ"].SetDouble(0.0)
+        project_parameters["RollingFrictionOption"].SetBool(False)
+        project_parameters["OutputFileType"].SetString("Ascii")
+        project_parameters["MaxTimeStep"].SetDouble(self.size_modifier_parameters["time_step"].GetDouble())
+        total_needed_time = self.size_modifier_parameters["initiation_time"].GetDouble() + self.size_modifier_parameters["process_duration"].GetDouble()
+        if project_parameters["FinalTime"].GetDouble() < total_needed_time:
+            project_parameters["FinalTime"].SetDouble(total_needed_time)
+        super().__init__(model, project_parameters)
+
+    def Initialize(self):
+        super().Initialize()
+        self._SaveInitialRadiusOfAllParticles()
+        self._GetDeviationFromMeanSizeOfAllParticles()
+        for props in self.spheres_model_part.Properties:
+            self.list_of_static_frictions_at_start.append(props[DEM.STATIC_FRICTION])
+            props.SetValue(DEM.STATIC_FRICTION, self.size_modifier_parameters["material_settings"]["static_friction"].GetDouble())
+            self.list_of_dynamic_frictions_at_start.append(props[DEM.DYNAMIC_FRICTION])
+            props.SetValue(DEM.DYNAMIC_FRICTION, self.size_modifier_parameters["material_settings"]["dynamic_friciton"].GetDouble())
+            self.list_of_young_modulus_at_start.append(props[KratosMultiphysics.YOUNG_MODULUS])
+            props.SetValue(KratosMultiphysics.YOUNG_MODULUS, self.size_modifier_parameters["material_settings"]["young_modulus"].GetDouble())
+            self.list_of_coefficients_of_restittution_at_start.append(props[DEM.COEFFICIENT_OF_RESTITUTION])
+            props.SetValue(DEM.COEFFICIENT_OF_RESTITUTION, self.size_modifier_parameters["material_settings"]["coefficient_of_restitution"].GetDouble())
+
+    def InitializeSolutionStep(self):
+        super().InitializeSolutionStep()
+        center = KratosMultiphysics.Array3()
+        center[0] = center[1] = center[2] = 0.0 #TODO: input
+        density = self.size_modifier_parameters["material_settings"]["density_for_artificial_concentric_weight"].GetDouble()
+        self.PreUtilities.ApplyConcentricForceOnParticles(self.spheres_model_part, center, density)
+
+    def FinalizeSolutionStep(self):
+        super().FinalizeSolutionStep()
+        self._ModifyRadiusOfAllParticles()
+        self._EraseElementsOutsideDomainAndMarkSkin()
+
+    def Finalize(self):
+        counter = 0
+        for props in self.spheres_model_part.Properties:
+            props.SetValue(DEM.STATIC_FRICTION, self.list_of_static_frictions_at_start[counter])
+            props.SetValue(DEM.DYNAMIC_FRICTION, self.list_of_dynamic_frictions_at_start[counter])
+            props.SetValue(KratosMultiphysics.YOUNG_MODULUS, self.list_of_young_modulus_at_start[counter])
+            props.SetValue(DEM.COEFFICIENT_OF_RESTITUTION, self.list_of_young_modulus_at_start[counter])
+            counter += 1
+        super().Finalize()
+
+    def _GetDeviationFromMeanSizeOfAllParticles(self):
+        min_radius = (self.size_modifier_parameters["max_diameter_of_particles"].GetDouble())/ 2.0
+        max_radius = (self.size_modifier_parameters["min_diameter_of_particles"].GetDouble())/ 2.0
+        mean_radius_of_particles = 0.5 * self.size_modifier_parameters["mean_diameter_of_particles"].GetDouble()
+        radius_standard_deviation = self.size_modifier_parameters["standard_deviation"].GetDouble() / 2.0
+
+        distribution = stats.truncnorm((min_radius - mean_radius_of_particles)/ radius_standard_deviation, (max_radius - mean_radius_of_particles) / radius_standard_deviation, loc=mean_radius_of_particles, scale=radius_standard_deviation)
+
+        for node in self.spheres_model_part.Nodes:
+            random_radius = distribution.rvs(1)
+            deviation = random_radius[0] - mean_radius_of_particles
+            node.SetValue(DEM.DEVIATION, deviation)
+
+    def _SaveInitialRadiusOfAllParticles(self):
+        for node in self.spheres_model_part.Nodes:
+            node.SetValue(DEM.INITIAL_RADIUS, node.GetSolutionStepValue(KratosMultiphysics.RADIUS))
+
+    def _ModifyRadiusOfAllParticles(self):
+        if self.time > self.size_modifier_parameters["initiation_time"].GetDouble() + self.size_modifier_parameters["process_duration"].GetDouble():
+            return
+        mean_diameter_of_particles = self.size_modifier_parameters["mean_diameter_of_particles"].GetDouble()
+        for node in self.spheres_model_part.Nodes:
+            x = node.X
+            y = node.Y
+            z = node.Z
+            radius_defined_by_function = ComputeMeanRadiusOfThisParticle(x, y, z, mean_diameter_of_particles/2.0)
+            deviation_for_mean_radius = node.GetValue(DEM.DEVIATION)
+            initial_radius = node.GetValue(DEM.INITIAL_RADIUS)
+            actual_deviation_for_current_radius = deviation_for_mean_radius * radius_defined_by_function / initial_radius
+            intended_radius_at_end = radius_defined_by_function + actual_deviation_for_current_radius
+            portion_of_process = (self.time - self.size_modifier_parameters["initiation_time"].GetDouble()) / self.size_modifier_parameters["process_duration"].GetDouble()
+            intended_radius_at_current_time = initial_radius + portion_of_process * (intended_radius_at_end - initial_radius)
+            node.SetSolutionStepValue(KratosMultiphysics.RADIUS, intended_radius_at_current_time)
+
+    def _EraseElementsOutsideDomainAndMarkSkin(self):
+        if self.eraser_counter == 1:
+            self.eraser_counter = 0
+            mean_diameter_of_particles = self.size_modifier_parameters["mean_diameter_of_particles"].GetDouble()
+            if self.size_modifier_parameters["geometry_settings"]["geometry_type"].GetString() == "Radial":
+                max_radius = self.size_modifier_parameters["geometry_settings"]["outer_radius"].GetDouble()
+                tolerance = self.size_modifier_parameters["geometry_settings"]["tolerance"].GetDouble()
+                center = KratosMultiphysics.Array3()
+                center[0] = center[1] = center[2] = 0.0
+                self.PreUtilities.ResetSkinParticles(self.spheres_model_part)
+                self.PreUtilities.MarkToEraseParticlesOutsideRadius(self.spheres_model_part, max_radius, center, tolerance)
+                inner_radius = self.size_modifier_parameters["geometry_settings"]["inner_radius"].GetDouble()
+                radius_at_inner_boundary = mean_diameter_of_particles/2.0
+                self.PreUtilities.SetSkinParticlesInnerBoundary(self.spheres_model_part, inner_radius, 2.0 * radius_at_inner_boundary)
+                radius_at_outer_boundary = ComputeMeanRadiusOfThisParticle(max_radius, 0.0, 0.0, mean_diameter_of_particles/2.0)
+                portion_of_process = (self.time - self.size_modifier_parameters["initiation_time"].GetDouble()) / self.size_modifier_parameters["process_duration"].GetDouble()
+                radius_at_outer_boundary_at_current_time = mean_diameter_of_particles/2.0 + portion_of_process * (radius_at_outer_boundary - mean_diameter_of_particles/2.0)
+                self.PreUtilities.SetSkinParticlesOuterBoundary(self.spheres_model_part, max_radius, 1.4 * radius_at_outer_boundary_at_current_time)
+        else:
+            self.eraser_counter += 1
+
+if __name__ == "__main__":
+    from KratosMultiphysics import Logger
+    Logger.GetDefaultOutput().SetSeverity(Logger.Severity.INFO)
+    with open("ProjectParametersDEM.json",'r') as parameter_file:
+        project_parameters = KratosMultiphysics.Parameters(parameter_file.read())
+
+    with open("SizeModifierParametersDEM.json",'r') as size_modifier_parameter_file:
+        size_modifier_parameters = KratosMultiphysics.Parameters(size_modifier_parameter_file.read())
+
+    model = KratosMultiphysics.Model()
+    ElementSizeModifier(model, project_parameters, size_modifier_parameters).Run()
```

## KratosMultiphysics/DEMApplication/KratosDEMAnalysis.py

 * *Ordering differences only*

```diff
@@ -1,34 +1,34 @@
-import KratosMultiphysics
-import KratosMultiphysics.DEMApplication
-from KratosMultiphysics.DEMApplication.DEM_analysis_stage import DEMAnalysisStage
-
-import time
-import sys
-""" model = KratosMultiphysics.Model()
-solution = Main.Solution(model)
-solution.Run() """
-
-class DEMAnalysisStageWithFlush(DEMAnalysisStage):
-
-    def __init__(self, model, project_parameters, flush_frequency=10.0):
-        super().__init__(model, project_parameters)
-        self.flush_frequency = flush_frequency
-        self.last_flush = time.time()
-
-    def FinalizeSolutionStep(self):
-        super().FinalizeSolutionStep()
-
-        if self.parallel_type == "OpenMP":
-            now = time.time()
-            if now - self.last_flush > self.flush_frequency:
-                sys.stdout.flush()
-                self.last_flush = now
-
-if __name__ == "__main__":
-    from KratosMultiphysics import Logger
-    Logger.GetDefaultOutput().SetSeverity(Logger.Severity.INFO)
-    with open("ProjectParametersDEM.json",'r') as parameter_file:
-        project_parameters = KratosMultiphysics.Parameters(parameter_file.read())
-
-    model = KratosMultiphysics.Model()
-    DEMAnalysisStageWithFlush(model, project_parameters).Run()
+import KratosMultiphysics
+import KratosMultiphysics.DEMApplication
+from KratosMultiphysics.DEMApplication.DEM_analysis_stage import DEMAnalysisStage
+
+import time
+import sys
+""" model = KratosMultiphysics.Model()
+solution = Main.Solution(model)
+solution.Run() """
+
+class DEMAnalysisStageWithFlush(DEMAnalysisStage):
+
+    def __init__(self, model, project_parameters, flush_frequency=10.0):
+        super().__init__(model, project_parameters)
+        self.flush_frequency = flush_frequency
+        self.last_flush = time.time()
+
+    def FinalizeSolutionStep(self):
+        super().FinalizeSolutionStep()
+
+        if self.parallel_type == "OpenMP":
+            now = time.time()
+            if now - self.last_flush > self.flush_frequency:
+                sys.stdout.flush()
+                self.last_flush = now
+
+if __name__ == "__main__":
+    from KratosMultiphysics import Logger
+    Logger.GetDefaultOutput().SetSeverity(Logger.Severity.INFO)
+    with open("ProjectParametersDEM.json",'r') as parameter_file:
+        project_parameters = KratosMultiphysics.Parameters(parameter_file.read())
+
+    model = KratosMultiphysics.Model()
+    DEMAnalysisStageWithFlush(model, project_parameters).Run()
```

## KratosMultiphysics/DEMApplication/DEM_restart_utility.py

 * *Ordering differences only*

```diff
@@ -1,64 +1,64 @@
-# Importing the Kratos Library
-import KratosMultiphysics as Kratos
-from KratosMultiphysics.restart_utility import RestartUtility
-from KratosMultiphysics import kratos_utilities
-# Other imports
-import os
-
-class DEMRestartUtility(RestartUtility):
-    """
-    This class collects the common functionalities needed for
-    saving / loading restart files.
-
-    It can either be integrated into python-solvers or used directly
-    in the main-script
-    """
-    def __init__(self, model, settings, restart_save_location='', restart_load_location=''):
-        default_settings = Kratos.Parameters("""
-        {
-            "input_filenames"                 : [],
-            "echo_level"                     : 0,
-            "serializer_trace"               : "no_trace",
-            "restart_load_file_label"        : "",
-            "load_restart_files_from_folder" : true,
-            "restart_save_frequency"         : 0.0,
-            "restart_control_type"           : "time",
-            "save_restart_files_in_folder"   : true
-        }
-        """)
-
-        settings.ValidateAndAssignDefaults(default_settings)
-        self.file_names = []
-        self.restart_utilities = dict()
-        self.model_parts = dict()
-        for name in settings["input_filenames"].values():
-            self.file_names.append(name.GetString())
-            settings_copy = settings.Clone()
-            settings_copy.AddValue("input_filename", name)
-            settings_copy.RemoveValue("input_filenames")
-            model_part = model.GetModelPart(name.GetString())
-            self.restart_utilities[name.GetString()] = RestartUtility(model_part, settings_copy)
-            self.model_parts[name.GetString()] = model_part
-        self.restart_save_location = restart_save_location
-        super().__init__(list(self.model_parts.values())[0], settings_copy)
-        # self.restart_load_location = restart_load_location
-
-    def SaveRestart(self):
-        for name in self.file_names:
-            restart_utility = self.restart_utilities[name]
-
-            if restart_utility.IsRestartOutputStep():
-                restart_utility.raw_path, restart_utility.raw_file_name = os.path.split(name)
-                #self.raw_path = os.path.join(os.getcwd(), self.raw_path)
-                restart_utility.raw_path = os.path.join(os.getcwd(), self.raw_path)
-                restart_utility.SaveRestart()
-
-    def LoadRestart(self,  restart_file_name=""):
-        for name in self.file_names:
-            restart_utility = self.restart_utilities[name]
-            restart_utility.raw_path, restart_utility.raw_file_name = os.path.split(name)
-            restart_utility.raw_path = os.path.join(os.getcwd(), self.raw_path)
-
-            restart_utility.LoadRestart()
-
-            kratos_utilities.DeleteDirectoryIfExisting(restart_utility._RestartUtility__GetFolderPathLoad())
+# Importing the Kratos Library
+import KratosMultiphysics as Kratos
+from KratosMultiphysics.restart_utility import RestartUtility
+from KratosMultiphysics import kratos_utilities
+# Other imports
+import os
+
+class DEMRestartUtility(RestartUtility):
+    """
+    This class collects the common functionalities needed for
+    saving / loading restart files.
+
+    It can either be integrated into python-solvers or used directly
+    in the main-script
+    """
+    def __init__(self, model, settings, restart_save_location='', restart_load_location=''):
+        default_settings = Kratos.Parameters("""
+        {
+            "input_filenames"                 : [],
+            "echo_level"                     : 0,
+            "serializer_trace"               : "no_trace",
+            "restart_load_file_label"        : "",
+            "load_restart_files_from_folder" : true,
+            "restart_save_frequency"         : 0.0,
+            "restart_control_type"           : "time",
+            "save_restart_files_in_folder"   : true
+        }
+        """)
+
+        settings.ValidateAndAssignDefaults(default_settings)
+        self.file_names = []
+        self.restart_utilities = dict()
+        self.model_parts = dict()
+        for name in settings["input_filenames"].values():
+            self.file_names.append(name.GetString())
+            settings_copy = settings.Clone()
+            settings_copy.AddValue("input_filename", name)
+            settings_copy.RemoveValue("input_filenames")
+            model_part = model.GetModelPart(name.GetString())
+            self.restart_utilities[name.GetString()] = RestartUtility(model_part, settings_copy)
+            self.model_parts[name.GetString()] = model_part
+        self.restart_save_location = restart_save_location
+        super().__init__(list(self.model_parts.values())[0], settings_copy)
+        # self.restart_load_location = restart_load_location
+
+    def SaveRestart(self):
+        for name in self.file_names:
+            restart_utility = self.restart_utilities[name]
+
+            if restart_utility.IsRestartOutputStep():
+                restart_utility.raw_path, restart_utility.raw_file_name = os.path.split(name)
+                #self.raw_path = os.path.join(os.getcwd(), self.raw_path)
+                restart_utility.raw_path = os.path.join(os.getcwd(), self.raw_path)
+                restart_utility.SaveRestart()
+
+    def LoadRestart(self,  restart_file_name=""):
+        for name in self.file_names:
+            restart_utility = self.restart_utilities[name]
+            restart_utility.raw_path, restart_utility.raw_file_name = os.path.split(name)
+            restart_utility.raw_path = os.path.join(os.getcwd(), self.raw_path)
+
+            restart_utility.LoadRestart()
+
+            kratos_utilities.DeleteDirectoryIfExisting(restart_utility._RestartUtility__GetFolderPathLoad())
```

## KratosMultiphysics/DEMApplication/analytic_tools/analytic_data_procedures.py

 * *Ordering differences only*

```diff
@@ -1,259 +1,259 @@
-import os
-import numpy as np
-from KratosMultiphysics import *
-from KratosMultiphysics.DEMApplication import *
-
-class SurfaceAnalyzer:
-    def __init__(self, smp):
-        self.inlet = None
-        self.n_particles_accumulated = 0
-        self.mass_accumulated = 0.0
-        self.smp_name = smp.Name
-        self.face_watcher = AnalyticFaceWatcher(smp)
-
-    def MakeMeasurements(self):
-        '''
-        From python to c++'''
-        self.face_watcher.MakeMeasurements()
-
-    def MakeReading(self):
-        times, number_flux, mass_flux, vel_nr_mass, vel_tg_mass = [], [], [], [], []
-        self.face_watcher.GetTotalFlux(times, number_flux, mass_flux, vel_nr_mass, vel_tg_mass)
-        lists = [times, number_flux, mass_flux, vel_nr_mass, vel_tg_mass]
-        times, number_flux, mass_flux, vel_nr_mass, vel_tg_mass = [l for l in lists]
-        length = len(times)
-        assert length == len(number_flux) == len(mass_flux)
-        shape = (length, )
-        number_flux, mass_flux = self.CalculateAccumulatedVectors(length, number_flux, mass_flux)
-        if self.inlet is not None:
-            self.inlet_accumulated_mass.append(self.inlet.GetMassInjectedSoFar())
-            self.inlet_accumulated_number_of_particles.append(self.inlet.GetNumberOfParticlesInjectedSoFar())
-
-        return shape, times, number_flux, mass_flux, vel_nr_mass, vel_tg_mass
-
-    def CalculateAccumulatedVectors(self, length, number_flux, mass_flux):
-        acc_number_flux = self.CalculateAccumulated(original_list = number_flux, old_accumulated = self.n_particles_accumulated)
-        acc_mass_flux = self.CalculateAccumulated(original_list = mass_flux, old_accumulated = self.mass_accumulated)
-
-        return acc_number_flux, acc_mass_flux
-
-    def CalculateAccumulated(self, original_list, old_accumulated = 0):
-        new_accumulated = np.cumsum(np.array(original_list)) + old_accumulated
-        return new_accumulated
-
-    def UpdateData(self, time):
-        shape, time, n_particles, mass, vel_nr_mass = self.MakeReading()[:-1]
-        # initial with 1 for each surface, should be one for each condition in each surface
-        total_mass = sum(mass)
-        if total_mass:
-            avg_vel_nr = vel_nr_mass / total_mass
-            # sum (normal vel * particle_mass) / total mass flux of that timestep
-        else:
-            avg_vel_nr = [0.] * len(mass)
-        return shape, time, n_particles, mass, avg_vel_nr
-
-    def MakeInletMassPlot(self):
-        self.MakeInletReading()
-
-    def SetInlet(self, inlet):
-        self.inlet = inlet
-
-    def UpdateVariables(self, n_particles_old, n_mass_old):
-        self.n_particles_accumulated = n_particles_old
-        self.mass_accumulated = n_mass_old
-
-    def ClearData(self):
-        self.face_watcher.ClearData()
-
-
-class ParticlesAnalyzerClass:
-    def __init__(self, model_part):
-        self.analytic_model_part = model_part
-        self.particle_analyzer = AnalyticParticleWatcher()
-
-    def MakeAnalyticsMeasurements(self):
-       self.particle_analyzer.MakeMeasurements(self.analytic_model_part)
-
-    def SetNodalMaxImpactVelocities(self):
-        self.particle_analyzer.SetNodalMaxImpactVelocities(self.analytic_model_part)
-
-    def SetNodalMaxFaceImpactVelocities(self):
-        self.particle_analyzer.SetNodalMaxFaceImpactVelocities(self.analytic_model_part)
-
-
-class SurfacesAnalyzerClass:
-    def __init__(self, sub_model_parts, main_path, do_clear_data = True):
-        self.sub_model_parts = sub_model_parts
-        self.main_path = main_path
-
-        self.surface_analyzers_list = []
-        self.do_clear_data = do_clear_data
-        self.times_data_base_names = []
-        self.n_particles_data_base_names = []
-        self.mass_data_base_names = []
-        self.new_path = self.main_path + '/flux_data_new.hdf5'
-        self.old_path = self.new_path.replace('_new.hdf5', '.hdf5')
-        self.name_n_particles = 'n_accum'
-        self.name_mass = 'm_accum'
-        self.name_avg_vel_nr = 'mass_avg_normal_vel'
-        self.ghost_smp_detected = False
-
-        for smp in sub_model_parts:
-            if smp[IS_GHOST] == True:
-                self.ghost_smp_detected = True
-                self.surface_analyzers_list.append(SurfaceAnalyzer(smp))
-
-        self.RemoveFiles()
-
-
-    def MakeAnalyticsMeasurements(self):
-        '''
-        This function is used as interface to reach the SurfaceAnalyzer MakeMeasurements
-        and from there, the cpp function.'''
-        for analyzer in self.surface_analyzers_list:
-            analyzer.MakeMeasurements()
-
-    def MakeAnalyticsPipeLine(self, time):
-        if self.ghost_smp_detected:
-            self.CreateNewFile()
-            self.UpdateDataBases(time)
-            self.RemoveOldFile()
-
-    def CreateNewFile(self):
-        import h5py
-        if os.path.exists(self.new_path):
-            os.rename(self.new_path, self.old_path)
-
-        h5py.File(self.new_path, 'a')
-
-    def RemoveOldFile(self):
-        if os.path.exists(self.old_path):
-            os.remove(self.old_path)
-
-    def RemoveFiles(self):
-        for path in (p for p in [self.new_path, self.old_path] if os.path.exists(p)):
-            os.remove(path)
-
-    def UpdateDataBases(self, time):
-        if self.OldFileExists():
-            self.UpdateDataFile(time)
-        else:
-            self.CreateDataFile(time)
-
-
-    def UpdateDataFile(self, time):
-        import h5py
-        with h5py.File(self.new_path, 'a') as f, h5py.File(self.old_path, 'r') as f_old:
-            for analyzer in self.surface_analyzers_list:
-                shape, time, n_particles, mass, avg_vel_nr = analyzer.UpdateData(time)
-                shape_old = f_old['/' + analyzer.smp_name + '/time'].shape
-                current_shape = (shape_old[0] + shape[0], )
-                time_db, n_particles_db, mass_db, avg_vel_nr_db = self.CreateDataSets(f, current_shape, analyzer.smp_name)
-
-                time_db[:shape_old[0]] = f_old['/' + analyzer.smp_name + '/time'][:]
-                time_db[shape_old[0]:] = time[:]
-                n_particles_db[:shape_old[0]] = f_old['/' + analyzer.smp_name + '/' + self.name_n_particles][:]
-                n_particles_db[shape_old[0]:] = n_particles[:]
-                mass_db[:shape_old[0]] = f_old['/' + analyzer.smp_name + '/' + self.name_mass][:]
-                mass_db[shape_old[0]:] = mass[:]
-                avg_vel_nr_db[:shape_old[0]] = f_old['/' + analyzer.smp_name + '/' + self.name_avg_vel_nr][:]
-                avg_vel_nr_db[shape_old[0]:] = avg_vel_nr[:]
-                if self.do_clear_data:
-                    if len(n_particles):
-                        (analyzer).UpdateVariables(n_particles[-1], mass[-1])
-                    (analyzer).ClearData()
-
-        # how to extract data from h5 subgrouped datasets:
-        #input_data = h5py.File('Cemib_P660_SpreadPattern.dat.hdf5','r')
-        #x_h5 = input_data.get('/patch/X')
-        #x = np.array(x_h5)
-
-    def CreateDataFile(self, time):
-
-        # how to create subgrouped datasets with variable name:
-        # group2 = f.create_group('group2/subfolder')
-        # group2.create_dataset('data',data=d)
-        import h5py
-        with h5py.File(self.new_path, 'a') as f:
-            for analyzer in self.surface_analyzers_list:
-                    shape, time, n_particles, mass, avg_vel_nr = analyzer.UpdateData(time)
-                    time_db, n_particles_db, mass_db, avg_vel_nr_db = self.CreateDataSets(f, shape, analyzer.smp_name)
-                    time_db[:] = time[:]
-                    n_particles_db[:] = n_particles[:]
-                    mass_db[:] = mass[:]
-                    avg_vel_nr_db[:] = avg_vel_nr[:]
-                    if self.do_clear_data:
-                        if len(n_particles):
-                            analyzer.UpdateVariables(n_particles[-1], mass[-1])
-                        analyzer.ClearData()
-
-
-    def CreateDataSets(self, f, current_shape, sp_name):
-        surface_data = f.require_group(sp_name)
-        surface_data.attrs['Surface Identifier'] = sp_name
-
-        time_db = surface_data.require_dataset('time', shape = current_shape, dtype = np.float64)
-        n_particles_db = surface_data.require_dataset(self.name_n_particles, shape = current_shape, dtype = np.int64)
-        mass_db = surface_data.require_dataset(self.name_mass, shape = current_shape, dtype = np.float64)
-        avg_vel_nr_db = surface_data.require_dataset(self.name_avg_vel_nr, shape = current_shape, dtype = np.float64)
-
-        return time_db, n_particles_db, mass_db, avg_vel_nr_db
-
-    def OldFileExists(self):
-        return os.path.exists(self.old_path)
-
-
-
-
-
-    #TODO: Decide what to do with these unused.
-    # Currently not being used
-    def GetJointData(self, data_base_names):
-        data_list = []
-        import h5py
-        with h5py.File(self.new_path, 'r') as f:
-            if self.do_clear_data: # join all databases
-                for name in data_base_names:
-                    data_list.append(f['/' + name].value)
-                joint_list = np.concatenate(data_list, axis = 0)
-            else: # get the latest
-                joint_list = f['/' + data_base_names[-1]].value
-
-        return joint_list
-
-    # Currently not being used
-    def GetMassFlux(self):
-        return self.GetJointData(self.mass_data_base_names)
-
-    # Currently not being used
-    def MakeTotalFluxPlot(self):
-        import matplotlib.pyplot as plt
-        import h5py
-        with h5py.File(self.file_path) as f:
-            times = f['/' + self.face_watcher_name + '/' + '/time'].value
-            mass_flux = f['/' + self.face_watcher_name + '/' + '/m_accum'].value
-        plt.xlabel('time')
-        plt.ylabel('accumulated mass throughput')
-        plt.plot(times, mass_flux)
-        plt.savefig(self.main_path + '/mass_throughput.pdf', bbox_inches='tight')
-
-    # Currently not being used
-    def MakeFluxOfNumberOfParticlesPlot(self):
-        import matplotlib.pyplot as plt
-        self.MakeReading()
-        times = self.GetTimes()
-        flux = self.GetNumberOfParticlesFlux()
-        '''
-        plt.xlabel('time')
-        plt.ylabel('accumulated number of particles through surface')
-        plt.plot(times, flux)
-        plt.savefig(self.main_path + '/throughput.svg')
-        plt.clf()
-        '''
-    # Currently not being used
-    def GetNumberOfParticlesFlux(self):
-        return self.GetJointData(self.n_particles_data_base_names)
-
-    # Currently not being used
-    def GetTimes(self):
-        return self.GetJointData(self.times_data_base_names)
+import os
+import numpy as np
+from KratosMultiphysics import *
+from KratosMultiphysics.DEMApplication import *
+
+class SurfaceAnalyzer:
+    def __init__(self, smp):
+        self.inlet = None
+        self.n_particles_accumulated = 0
+        self.mass_accumulated = 0.0
+        self.smp_name = smp.Name
+        self.face_watcher = AnalyticFaceWatcher(smp)
+
+    def MakeMeasurements(self):
+        '''
+        From python to c++'''
+        self.face_watcher.MakeMeasurements()
+
+    def MakeReading(self):
+        times, number_flux, mass_flux, vel_nr_mass, vel_tg_mass = [], [], [], [], []
+        self.face_watcher.GetTotalFlux(times, number_flux, mass_flux, vel_nr_mass, vel_tg_mass)
+        lists = [times, number_flux, mass_flux, vel_nr_mass, vel_tg_mass]
+        times, number_flux, mass_flux, vel_nr_mass, vel_tg_mass = [l for l in lists]
+        length = len(times)
+        assert length == len(number_flux) == len(mass_flux)
+        shape = (length, )
+        number_flux, mass_flux = self.CalculateAccumulatedVectors(length, number_flux, mass_flux)
+        if self.inlet is not None:
+            self.inlet_accumulated_mass.append(self.inlet.GetMassInjectedSoFar())
+            self.inlet_accumulated_number_of_particles.append(self.inlet.GetNumberOfParticlesInjectedSoFar())
+
+        return shape, times, number_flux, mass_flux, vel_nr_mass, vel_tg_mass
+
+    def CalculateAccumulatedVectors(self, length, number_flux, mass_flux):
+        acc_number_flux = self.CalculateAccumulated(original_list = number_flux, old_accumulated = self.n_particles_accumulated)
+        acc_mass_flux = self.CalculateAccumulated(original_list = mass_flux, old_accumulated = self.mass_accumulated)
+
+        return acc_number_flux, acc_mass_flux
+
+    def CalculateAccumulated(self, original_list, old_accumulated = 0):
+        new_accumulated = np.cumsum(np.array(original_list)) + old_accumulated
+        return new_accumulated
+
+    def UpdateData(self, time):
+        shape, time, n_particles, mass, vel_nr_mass = self.MakeReading()[:-1]
+        # initial with 1 for each surface, should be one for each condition in each surface
+        total_mass = sum(mass)
+        if total_mass:
+            avg_vel_nr = vel_nr_mass / total_mass
+            # sum (normal vel * particle_mass) / total mass flux of that timestep
+        else:
+            avg_vel_nr = [0.] * len(mass)
+        return shape, time, n_particles, mass, avg_vel_nr
+
+    def MakeInletMassPlot(self):
+        self.MakeInletReading()
+
+    def SetInlet(self, inlet):
+        self.inlet = inlet
+
+    def UpdateVariables(self, n_particles_old, n_mass_old):
+        self.n_particles_accumulated = n_particles_old
+        self.mass_accumulated = n_mass_old
+
+    def ClearData(self):
+        self.face_watcher.ClearData()
+
+
+class ParticlesAnalyzerClass:
+    def __init__(self, model_part):
+        self.analytic_model_part = model_part
+        self.particle_analyzer = AnalyticParticleWatcher()
+
+    def MakeAnalyticsMeasurements(self):
+       self.particle_analyzer.MakeMeasurements(self.analytic_model_part)
+
+    def SetNodalMaxImpactVelocities(self):
+        self.particle_analyzer.SetNodalMaxImpactVelocities(self.analytic_model_part)
+
+    def SetNodalMaxFaceImpactVelocities(self):
+        self.particle_analyzer.SetNodalMaxFaceImpactVelocities(self.analytic_model_part)
+
+
+class SurfacesAnalyzerClass:
+    def __init__(self, sub_model_parts, main_path, do_clear_data = True):
+        self.sub_model_parts = sub_model_parts
+        self.main_path = main_path
+
+        self.surface_analyzers_list = []
+        self.do_clear_data = do_clear_data
+        self.times_data_base_names = []
+        self.n_particles_data_base_names = []
+        self.mass_data_base_names = []
+        self.new_path = self.main_path + '/flux_data_new.hdf5'
+        self.old_path = self.new_path.replace('_new.hdf5', '.hdf5')
+        self.name_n_particles = 'n_accum'
+        self.name_mass = 'm_accum'
+        self.name_avg_vel_nr = 'mass_avg_normal_vel'
+        self.ghost_smp_detected = False
+
+        for smp in sub_model_parts:
+            if smp[IS_GHOST] == True:
+                self.ghost_smp_detected = True
+                self.surface_analyzers_list.append(SurfaceAnalyzer(smp))
+
+        self.RemoveFiles()
+
+
+    def MakeAnalyticsMeasurements(self):
+        '''
+        This function is used as interface to reach the SurfaceAnalyzer MakeMeasurements
+        and from there, the cpp function.'''
+        for analyzer in self.surface_analyzers_list:
+            analyzer.MakeMeasurements()
+
+    def MakeAnalyticsPipeLine(self, time):
+        if self.ghost_smp_detected:
+            self.CreateNewFile()
+            self.UpdateDataBases(time)
+            self.RemoveOldFile()
+
+    def CreateNewFile(self):
+        import h5py
+        if os.path.exists(self.new_path):
+            os.rename(self.new_path, self.old_path)
+
+        h5py.File(self.new_path, 'a')
+
+    def RemoveOldFile(self):
+        if os.path.exists(self.old_path):
+            os.remove(self.old_path)
+
+    def RemoveFiles(self):
+        for path in (p for p in [self.new_path, self.old_path] if os.path.exists(p)):
+            os.remove(path)
+
+    def UpdateDataBases(self, time):
+        if self.OldFileExists():
+            self.UpdateDataFile(time)
+        else:
+            self.CreateDataFile(time)
+
+
+    def UpdateDataFile(self, time):
+        import h5py
+        with h5py.File(self.new_path, 'a') as f, h5py.File(self.old_path, 'r') as f_old:
+            for analyzer in self.surface_analyzers_list:
+                shape, time, n_particles, mass, avg_vel_nr = analyzer.UpdateData(time)
+                shape_old = f_old['/' + analyzer.smp_name + '/time'].shape
+                current_shape = (shape_old[0] + shape[0], )
+                time_db, n_particles_db, mass_db, avg_vel_nr_db = self.CreateDataSets(f, current_shape, analyzer.smp_name)
+
+                time_db[:shape_old[0]] = f_old['/' + analyzer.smp_name + '/time'][:]
+                time_db[shape_old[0]:] = time[:]
+                n_particles_db[:shape_old[0]] = f_old['/' + analyzer.smp_name + '/' + self.name_n_particles][:]
+                n_particles_db[shape_old[0]:] = n_particles[:]
+                mass_db[:shape_old[0]] = f_old['/' + analyzer.smp_name + '/' + self.name_mass][:]
+                mass_db[shape_old[0]:] = mass[:]
+                avg_vel_nr_db[:shape_old[0]] = f_old['/' + analyzer.smp_name + '/' + self.name_avg_vel_nr][:]
+                avg_vel_nr_db[shape_old[0]:] = avg_vel_nr[:]
+                if self.do_clear_data:
+                    if len(n_particles):
+                        (analyzer).UpdateVariables(n_particles[-1], mass[-1])
+                    (analyzer).ClearData()
+
+        # how to extract data from h5 subgrouped datasets:
+        #input_data = h5py.File('Cemib_P660_SpreadPattern.dat.hdf5','r')
+        #x_h5 = input_data.get('/patch/X')
+        #x = np.array(x_h5)
+
+    def CreateDataFile(self, time):
+
+        # how to create subgrouped datasets with variable name:
+        # group2 = f.create_group('group2/subfolder')
+        # group2.create_dataset('data',data=d)
+        import h5py
+        with h5py.File(self.new_path, 'a') as f:
+            for analyzer in self.surface_analyzers_list:
+                    shape, time, n_particles, mass, avg_vel_nr = analyzer.UpdateData(time)
+                    time_db, n_particles_db, mass_db, avg_vel_nr_db = self.CreateDataSets(f, shape, analyzer.smp_name)
+                    time_db[:] = time[:]
+                    n_particles_db[:] = n_particles[:]
+                    mass_db[:] = mass[:]
+                    avg_vel_nr_db[:] = avg_vel_nr[:]
+                    if self.do_clear_data:
+                        if len(n_particles):
+                            analyzer.UpdateVariables(n_particles[-1], mass[-1])
+                        analyzer.ClearData()
+
+
+    def CreateDataSets(self, f, current_shape, sp_name):
+        surface_data = f.require_group(sp_name)
+        surface_data.attrs['Surface Identifier'] = sp_name
+
+        time_db = surface_data.require_dataset('time', shape = current_shape, dtype = np.float64)
+        n_particles_db = surface_data.require_dataset(self.name_n_particles, shape = current_shape, dtype = np.int64)
+        mass_db = surface_data.require_dataset(self.name_mass, shape = current_shape, dtype = np.float64)
+        avg_vel_nr_db = surface_data.require_dataset(self.name_avg_vel_nr, shape = current_shape, dtype = np.float64)
+
+        return time_db, n_particles_db, mass_db, avg_vel_nr_db
+
+    def OldFileExists(self):
+        return os.path.exists(self.old_path)
+
+
+
+
+
+    #TODO: Decide what to do with these unused.
+    # Currently not being used
+    def GetJointData(self, data_base_names):
+        data_list = []
+        import h5py
+        with h5py.File(self.new_path, 'r') as f:
+            if self.do_clear_data: # join all databases
+                for name in data_base_names:
+                    data_list.append(f['/' + name].value)
+                joint_list = np.concatenate(data_list, axis = 0)
+            else: # get the latest
+                joint_list = f['/' + data_base_names[-1]].value
+
+        return joint_list
+
+    # Currently not being used
+    def GetMassFlux(self):
+        return self.GetJointData(self.mass_data_base_names)
+
+    # Currently not being used
+    def MakeTotalFluxPlot(self):
+        import matplotlib.pyplot as plt
+        import h5py
+        with h5py.File(self.file_path) as f:
+            times = f['/' + self.face_watcher_name + '/' + '/time'].value
+            mass_flux = f['/' + self.face_watcher_name + '/' + '/m_accum'].value
+        plt.xlabel('time')
+        plt.ylabel('accumulated mass throughput')
+        plt.plot(times, mass_flux)
+        plt.savefig(self.main_path + '/mass_throughput.pdf', bbox_inches='tight')
+
+    # Currently not being used
+    def MakeFluxOfNumberOfParticlesPlot(self):
+        import matplotlib.pyplot as plt
+        self.MakeReading()
+        times = self.GetTimes()
+        flux = self.GetNumberOfParticlesFlux()
+        '''
+        plt.xlabel('time')
+        plt.ylabel('accumulated number of particles through surface')
+        plt.plot(times, flux)
+        plt.savefig(self.main_path + '/throughput.svg')
+        plt.clf()
+        '''
+    # Currently not being used
+    def GetNumberOfParticlesFlux(self):
+        return self.GetJointData(self.n_particles_data_base_names)
+
+    # Currently not being used
+    def GetTimes(self):
+        return self.GetJointData(self.times_data_base_names)
```

## KratosMultiphysics/DEMApplication/processes/multiaxial_control_module_generalized_2d_process.py

 * *Ordering differences only*

```diff
@@ -1,110 +1,110 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-import KratosMultiphysics.DEMApplication as DEM
-
-def Factory(settings, Model):
-    if not isinstance(settings, KratosMultiphysics.Parameters):
-        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
-    return MultiaxialControlModuleGeneralized2DProcess(Model, settings["Parameters"])
-
-## All the processes python should be derived from "Process"
-class MultiaxialControlModuleGeneralized2DProcess(KratosMultiphysics.Process):
-
-    """This process assigns a given value (vector) to the nodes belonging a certain submodelpart
-
-    Only the member variables listed below should be accessed directly.
-
-    Public member variables:
-    Model -- the container of the different model parts.
-    settings -- Kratos parameters containing solver settings.
-    """
-
-    def __init__(self, Model, settings):
-
-        """ The default constructor of the class
-
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        Model -- the container of the different model parts.
-        settings -- Kratos parameters containing solver settings.
-        """
-
-        KratosMultiphysics.Process.__init__(self)
-
-        '''default_settings = KratosMultiphysics.Parameters("""
-        {
-            "help"                 : "This process applies a given stress to a sample by imposing displacements. The controlled, adaptable displacement is meant to achieve the target stress",
-            "dem_model_part_name"      : "please_specify_model_part_name",
-            "fem_model_part_name"      : "please_specify_model_part_name",
-            "Parameters" : {
-                "Parameters"    : {
-                    "control_module_delta_time": 2.0e-8,
-                    "perturbation_tolerance": 1.0e-4,
-                    "perturbation_period": 10,
-                    "max_reaction_rate_factor": 10.0,
-                    "stiffness_averaging_time_interval": 2.0e-6,
-                    "velocity_averaging_time_interval": 2.0e-4,
-                    "reaction_averaging_time_interval": 6.0e-8,
-                    "output_interval": 0
-                },
-                "list_of_actuators" : [{
-                    "Parameters"    : {
-                        "actuator_name": "Z",
-                        "initial_velocity" : 0.0,
-                        "compression_length" : 1.0,
-                        "young_modulus" : 7.0e9
-                    },
-                    "list_of_dem_boundaries": [{
-                        "model_part_name" : "dems",
-                        "outer_normal": [0.0,0.0,1.0]
-                    }],
-                    "list_of_fem_boundaries": [],
-                    "target_stress_table": {
-                        "input_variable": "TIME",
-                        "output_variable": "TARGET_STRESS",
-                        "data": [
-                            [0.0, 0.0],
-                            [2.0E-2, 0.0]
-                        ]
-                    }
-                },{
-                    "Parameters"    : {
-                        "actuator_name": "Radial",
-                        "initial_velocity" : 0.0,
-                        "compression_length" : 0.0505,
-                        "young_modulus" : 7.0e9
-                    },
-                    "list_of_dem_boundaries": [],
-                    "list_of_fem_boundaries": [{
-                        "model_part_name" : "1",
-                        "outer_normal": [0.0,0.0,0.0]
-                    }],
-                    "target_stress_table": {
-                        "input_variable": "TIME",
-                        "output_variable": "TARGET_STRESS",
-                        "data": [
-                            [0.0, 0.0],
-                            [2.0E-2, -1.0e9]
-                        ]
-                    }
-                }]
-            }
-        }
-        """
-        )'''
-
-        #settings.ValidateAndAssignDefaults(default_settings)
-
-        dem_model_part = Model[settings["dem_model_part_name"].GetString()]
-        fem_model_part = Model[settings["fem_model_part_name"].GetString()]
-        self.cplusplus_version_of_this_process = DEM.MultiaxialControlModuleGeneralized2DUtilities(dem_model_part, fem_model_part, settings)
-
-    def ExecuteInitialize(self):
-        self.cplusplus_version_of_this_process.ExecuteInitialize()
-
-    def ExecuteInitializeSolutionStep(self):
-        self.cplusplus_version_of_this_process.ExecuteInitializeSolutionStep()
-
-    def ExecuteFinalizeSolutionStep(self):
-        self.cplusplus_version_of_this_process.ExecuteFinalizeSolutionStep()
-
+# Importing the Kratos Library
+import KratosMultiphysics
+import KratosMultiphysics.DEMApplication as DEM
+
+def Factory(settings, Model):
+    if not isinstance(settings, KratosMultiphysics.Parameters):
+        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
+    return MultiaxialControlModuleGeneralized2DProcess(Model, settings["Parameters"])
+
+## All the processes python should be derived from "Process"
+class MultiaxialControlModuleGeneralized2DProcess(KratosMultiphysics.Process):
+
+    """This process assigns a given value (vector) to the nodes belonging a certain submodelpart
+
+    Only the member variables listed below should be accessed directly.
+
+    Public member variables:
+    Model -- the container of the different model parts.
+    settings -- Kratos parameters containing solver settings.
+    """
+
+    def __init__(self, Model, settings):
+
+        """ The default constructor of the class
+
+        Keyword arguments:
+        self -- It signifies an instance of a class.
+        Model -- the container of the different model parts.
+        settings -- Kratos parameters containing solver settings.
+        """
+
+        KratosMultiphysics.Process.__init__(self)
+
+        '''default_settings = KratosMultiphysics.Parameters("""
+        {
+            "help"                 : "This process applies a given stress to a sample by imposing displacements. The controlled, adaptable displacement is meant to achieve the target stress",
+            "dem_model_part_name"      : "please_specify_model_part_name",
+            "fem_model_part_name"      : "please_specify_model_part_name",
+            "Parameters" : {
+                "Parameters"    : {
+                    "control_module_delta_time": 2.0e-8,
+                    "perturbation_tolerance": 1.0e-4,
+                    "perturbation_period": 10,
+                    "max_reaction_rate_factor": 10.0,
+                    "stiffness_averaging_time_interval": 2.0e-6,
+                    "velocity_averaging_time_interval": 2.0e-4,
+                    "reaction_averaging_time_interval": 6.0e-8,
+                    "output_interval": 0
+                },
+                "list_of_actuators" : [{
+                    "Parameters"    : {
+                        "actuator_name": "Z",
+                        "initial_velocity" : 0.0,
+                        "compression_length" : 1.0,
+                        "young_modulus" : 7.0e9
+                    },
+                    "list_of_dem_boundaries": [{
+                        "model_part_name" : "dems",
+                        "outer_normal": [0.0,0.0,1.0]
+                    }],
+                    "list_of_fem_boundaries": [],
+                    "target_stress_table": {
+                        "input_variable": "TIME",
+                        "output_variable": "TARGET_STRESS",
+                        "data": [
+                            [0.0, 0.0],
+                            [2.0E-2, 0.0]
+                        ]
+                    }
+                },{
+                    "Parameters"    : {
+                        "actuator_name": "Radial",
+                        "initial_velocity" : 0.0,
+                        "compression_length" : 0.0505,
+                        "young_modulus" : 7.0e9
+                    },
+                    "list_of_dem_boundaries": [],
+                    "list_of_fem_boundaries": [{
+                        "model_part_name" : "1",
+                        "outer_normal": [0.0,0.0,0.0]
+                    }],
+                    "target_stress_table": {
+                        "input_variable": "TIME",
+                        "output_variable": "TARGET_STRESS",
+                        "data": [
+                            [0.0, 0.0],
+                            [2.0E-2, -1.0e9]
+                        ]
+                    }
+                }]
+            }
+        }
+        """
+        )'''
+
+        #settings.ValidateAndAssignDefaults(default_settings)
+
+        dem_model_part = Model[settings["dem_model_part_name"].GetString()]
+        fem_model_part = Model[settings["fem_model_part_name"].GetString()]
+        self.cplusplus_version_of_this_process = DEM.MultiaxialControlModuleGeneralized2DUtilities(dem_model_part, fem_model_part, settings)
+
+    def ExecuteInitialize(self):
+        self.cplusplus_version_of_this_process.ExecuteInitialize()
+
+    def ExecuteInitializeSolutionStep(self):
+        self.cplusplus_version_of_this_process.ExecuteInitializeSolutionStep()
+
+    def ExecuteFinalizeSolutionStep(self):
+        self.cplusplus_version_of_this_process.ExecuteFinalizeSolutionStep()
+
```

## KratosMultiphysics/DEMApplication/processes/apply_forces_and_moments_process.py

 * *Ordering differences only*

```diff
@@ -1,38 +1,38 @@
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.DEMApplication as DEM
-
-# Other imports
-
-def Factory(settings, Model):
-    if(type(settings) != KratosMultiphysics.Parameters):
-        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
-
-    process_settings = settings["Parameters"]
-
-    folder_settings = KratosMultiphysics.Parameters("""{
-            "help"                 : "This process applies loads over the particles in a certain submodelpart, for a certain time interval",
-            "mesh_id"              : 0,
-            "model_part_name"      : "please_specify_model_part_name",
-            "force_settings" : {
-                "value"            : [10.0, "3*t", "x+y"],
-                "table"            : [0, 0, 0]
-            },
-            "moment_settings" : {
-                "value"            : [10.0, "3*t", "x+y"],
-                "table"            : [0, 0, 0]
-            },
-            "interval"             : [0.0, 1e30]
-        }""" )
-
-    process_settings.AddMissingParameters(folder_settings)
-
-    if process_settings.Has("model_part_name"):
-        computing_model_part = Model[process_settings["model_part_name"].GetString()]
-    else: # using default name
-        computing_model_part = Model["DEM"]
-
-    process_settings.RemoveValue("help")
-
-    return DEM.ApplyForcesAndMomentsProcess(computing_model_part, process_settings)
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.DEMApplication as DEM
+
+# Other imports
+
+def Factory(settings, Model):
+    if(type(settings) != KratosMultiphysics.Parameters):
+        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
+
+    process_settings = settings["Parameters"]
+
+    folder_settings = KratosMultiphysics.Parameters("""{
+            "help"                 : "This process applies loads over the particles in a certain submodelpart, for a certain time interval",
+            "mesh_id"              : 0,
+            "model_part_name"      : "please_specify_model_part_name",
+            "force_settings" : {
+                "value"            : [10.0, "3*t", "x+y"],
+                "table"            : [0, 0, 0]
+            },
+            "moment_settings" : {
+                "value"            : [10.0, "3*t", "x+y"],
+                "table"            : [0, 0, 0]
+            },
+            "interval"             : [0.0, 1e30]
+        }""" )
+
+    process_settings.AddMissingParameters(folder_settings)
+
+    if process_settings.Has("model_part_name"):
+        computing_model_part = Model[process_settings["model_part_name"].GetString()]
+    else: # using default name
+        computing_model_part = Model["DEM"]
+
+    process_settings.RemoveValue("help")
+
+    return DEM.ApplyForcesAndMomentsProcess(computing_model_part, process_settings)
```

## KratosMultiphysics/DEMApplication/processes/apply_kinematic_constraints_process.py

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.DEMApplication as DEM
-
-# Other imports
-
-def Factory(settings, Model):
-    if(type(settings) != KratosMultiphysics.Parameters):
-        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
-
-    process_settings = settings["Parameters"]
-
-    folder_settings = KratosMultiphysics.Parameters("""
-    {
-        "help"                 : "This process applies constraints to the particles in a certain submodelpart, for a certain time interval",
-        "mesh_id"              : 0,
-        "model_part_name"      : "please_specify_model_part_name",
-        "velocity_constraints_settings" : {
-            "constrained"          : [true,true,true],
-            "value"                : [10.0, "3*t", "x+y"],
-            "table"                : [0, 0, 0]
-        },
-        "angular_velocity_constraints_settings" : {
-            "constrained"          : [true,true,true],
-            "value"                : [10.0, "3*t", "x+y"],
-            "table"                : [0, 0, 0]
-        },
-        "interval"             : [0.0, 1e30]
-    }
-    """)
-
-    process_settings.AddMissingParameters(folder_settings)
-
-    if process_settings.Has("model_part_name"):
-        computing_model_part = Model[process_settings["model_part_name"].GetString()]
-    else: # using default name
-        computing_model_part = Model["DEM"]
-
-    process_settings.RemoveValue("help")
-
-    return DEM.ApplyKinematicConstraintsProcess(computing_model_part, process_settings)
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.DEMApplication as DEM
+
+# Other imports
+
+def Factory(settings, Model):
+    if(type(settings) != KratosMultiphysics.Parameters):
+        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
+
+    process_settings = settings["Parameters"]
+
+    folder_settings = KratosMultiphysics.Parameters("""
+    {
+        "help"                 : "This process applies constraints to the particles in a certain submodelpart, for a certain time interval",
+        "mesh_id"              : 0,
+        "model_part_name"      : "please_specify_model_part_name",
+        "velocity_constraints_settings" : {
+            "constrained"          : [true,true,true],
+            "value"                : [10.0, "3*t", "x+y"],
+            "table"                : [0, 0, 0]
+        },
+        "angular_velocity_constraints_settings" : {
+            "constrained"          : [true,true,true],
+            "value"                : [10.0, "3*t", "x+y"],
+            "table"                : [0, 0, 0]
+        },
+        "interval"             : [0.0, 1e30]
+    }
+    """)
+
+    process_settings.AddMissingParameters(folder_settings)
+
+    if process_settings.Has("model_part_name"):
+        computing_model_part = Model[process_settings["model_part_name"].GetString()]
+    else: # using default name
+        computing_model_part = Model["DEM"]
+
+    process_settings.RemoveValue("help")
+
+    return DEM.ApplyKinematicConstraintsProcess(computing_model_part, process_settings)
```

## KratosMultiphysics/DEMApplication/processes/apply_forces_and_moments_to_walls_process.py

 * *Ordering differences only*

```diff
@@ -1,38 +1,38 @@
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.DEMApplication as DEM
-
-# Other imports
-
-def Factory(settings, Model):
-    if(type(settings) != KratosMultiphysics.Parameters):
-        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
-
-    process_settings = settings["Parameters"]
-
-    folder_settings = KratosMultiphysics.Parameters("""{
-            "help"                 : "This process applies loads over the rigid walls in a certain submodelpart, for a certain time interval",
-            "mesh_id"              : 0,
-            "model_part_name"      : "please_specify_model_part_name",
-            "force_settings" : {
-                "value"            : [10.0, "3*t", "x+y"],
-                "table"            : [0, 0, 0]
-            },
-            "moment_settings" : {
-                "value"            : [10.0, "3*t", "x+y"],
-                "table"            : [0, 0, 0]
-            },
-            "interval"             : [0.0, 1e30]
-        }""" )
-
-    process_settings.AddMissingParameters(folder_settings)
-
-    if process_settings.Has("model_part_name"):
-        computing_model_part = Model[process_settings["model_part_name"].GetString()]
-    else: # using default name
-        computing_model_part = Model["DEM_FEM_boundary"]
-
-    process_settings.RemoveValue("help")
-
-    return DEM.ApplyForcesAndMomentsToWallsProcess(computing_model_part, process_settings)
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.DEMApplication as DEM
+
+# Other imports
+
+def Factory(settings, Model):
+    if(type(settings) != KratosMultiphysics.Parameters):
+        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
+
+    process_settings = settings["Parameters"]
+
+    folder_settings = KratosMultiphysics.Parameters("""{
+            "help"                 : "This process applies loads over the rigid walls in a certain submodelpart, for a certain time interval",
+            "mesh_id"              : 0,
+            "model_part_name"      : "please_specify_model_part_name",
+            "force_settings" : {
+                "value"            : [10.0, "3*t", "x+y"],
+                "table"            : [0, 0, 0]
+            },
+            "moment_settings" : {
+                "value"            : [10.0, "3*t", "x+y"],
+                "table"            : [0, 0, 0]
+            },
+            "interval"             : [0.0, 1e30]
+        }""" )
+
+    process_settings.AddMissingParameters(folder_settings)
+
+    if process_settings.Has("model_part_name"):
+        computing_model_part = Model[process_settings["model_part_name"].GetString()]
+    else: # using default name
+        computing_model_part = Model["DEM_FEM_boundary"]
+
+    process_settings.RemoveValue("help")
+
+    return DEM.ApplyForcesAndMomentsToWallsProcess(computing_model_part, process_settings)
```

## KratosMultiphysics/DEMApplication/processes/apply_kinematic_constraints_to_walls_process.py

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.DEMApplication as DEM
-
-# Other imports
-
-def Factory(settings, Model):
-    if(type(settings) != KratosMultiphysics.Parameters):
-        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
-
-    process_settings = settings["Parameters"]
-
-    folder_settings = KratosMultiphysics.Parameters("""
-    {
-        "help"                 : "This process applies constraints to the particles in a certain submodelpart, for a certain time interval",
-        "mesh_id"              : 0,
-        "model_part_name"      : "please_specify_model_part_name",
-        "velocity_constraints_settings" : {
-            "constrained"          : [true,true,true],
-            "value"                : [10.0, "3*t", "x+y"],
-            "table"                : [0, 0, 0]
-        },
-        "angular_velocity_constraints_settings" : {
-            "constrained"          : [true,true,true],
-            "value"                : [10.0, "3*t", "x+y"],
-            "table"                : [0, 0, 0]
-        },
-        "interval"             : [0.0, 1e30]
-    }
-    """)
-
-    process_settings.AddMissingParameters(folder_settings)
-
-    if process_settings.Has("model_part_name"):
-        computing_model_part = Model[process_settings["model_part_name"].GetString()]
-    else: # using default name
-        computing_model_part = Model["DEM"]
-
-    process_settings.RemoveValue("help")
-
-    return DEM.ApplyKinematicConstraintsToWallsProcess(computing_model_part, process_settings)
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.DEMApplication as DEM
+
+# Other imports
+
+def Factory(settings, Model):
+    if(type(settings) != KratosMultiphysics.Parameters):
+        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
+
+    process_settings = settings["Parameters"]
+
+    folder_settings = KratosMultiphysics.Parameters("""
+    {
+        "help"                 : "This process applies constraints to the particles in a certain submodelpart, for a certain time interval",
+        "mesh_id"              : 0,
+        "model_part_name"      : "please_specify_model_part_name",
+        "velocity_constraints_settings" : {
+            "constrained"          : [true,true,true],
+            "value"                : [10.0, "3*t", "x+y"],
+            "table"                : [0, 0, 0]
+        },
+        "angular_velocity_constraints_settings" : {
+            "constrained"          : [true,true,true],
+            "value"                : [10.0, "3*t", "x+y"],
+            "table"                : [0, 0, 0]
+        },
+        "interval"             : [0.0, 1e30]
+    }
+    """)
+
+    process_settings.AddMissingParameters(folder_settings)
+
+    if process_settings.Has("model_part_name"):
+        computing_model_part = Model[process_settings["model_part_name"].GetString()]
+    else: # using default name
+        computing_model_part = Model["DEM"]
+
+    process_settings.RemoveValue("help")
+
+    return DEM.ApplyKinematicConstraintsToWallsProcess(computing_model_part, process_settings)
```

## KratosMultiphysics/DEMApplication/cluster_file_reader.py

 * *Ordering differences only*

```diff
@@ -1,74 +1,74 @@
-import KratosMultiphysics as Kratos
-
-
-def ReadNextLine(f):
-    while True:
-        nextline=next(f)
-        if nextline.startswith("//") == False :
-            return nextline.split()
-
-def ReadClusterFile(filename):
-    import os
-
-    f = open(filename, 'r')
-    list_of_coordinates = []
-    list_of_radii = []
-    inertias = []
-    volume = []
-    size = []
-
-    for line in f:
-        if line.startswith("//"):
-            continue
-        if line.startswith("Name"):
-            data = ReadNextLine(f)
-            name = data[0]
-        if line.startswith("Begin centers_and_radii"):
-            while True:
-                nextline=next(f)
-                if nextline.startswith("//"):
-                    continue
-                if nextline.startswith("End centers_and_radii"):
-                    break
-                data = nextline.split()
-                coordinates = [float(data[0]), float(data[1]), float(data[2])]
-                radius = float(data[3])
-                list_of_coordinates.append(coordinates)
-                list_of_radii.append(radius)
-        if line.startswith("Particle_center_and_diameter"):
-            data = ReadNextLine(f)
-            center = [float(data[0]), float(data[1]), float(data[2])]
-        if line.startswith("Size"):
-            data = ReadNextLine(f)
-            size = [float(data[0])]
-        if line.startswith("Volume"):
-            data = ReadNextLine(f)
-            volume = [float(data[0])]
-        if line.startswith("Inertia per unit mass"):
-            data = ReadNextLine(f)
-            IX = float(data[0])
-            data = ReadNextLine(f)
-            IY = float(data[0])
-            data = ReadNextLine(f)
-            IZ = float(data[0])
-            inertias = [IX, IY, IZ]
-
-    f.close()
-
-    try:
-        center
-    except NameError:
-        message = "\n\n" + "************  ERROR!   Problems reading cluster file: " + filename + "  The center could not be found ***************\n\n"
-        Kratos.Logger.PrintInfo(message)
-
-    for i in range(len(list_of_coordinates)):
-        list_of_coordinates[i] = [list_of_coordinates[i][0] - center[0], list_of_coordinates[i][1] - center[1], list_of_coordinates[i][2] - center[2]]
-
-    if len(inertias)==0 or len(volume)==0 or len(size)==0 or len(list_of_radii)==0 or len(list_of_coordinates)==0 :
-        message = "\n\n" + "************  ERROR!   Problems reading cluster file: " + filename + "   ***************\n\n"
-        Kratos.Logger.PrintInfo(message)
-    else:
-        Kratos.Logger.PrintInfo("Cluster file "+ filename + " was read correctly")
-
-    return [name, list_of_coordinates, list_of_radii, size[0], volume[0], inertias]
-
+import KratosMultiphysics as Kratos
+
+
+def ReadNextLine(f):
+    while True:
+        nextline=next(f)
+        if nextline.startswith("//") == False :
+            return nextline.split()
+
+def ReadClusterFile(filename):
+    import os
+
+    f = open(filename, 'r')
+    list_of_coordinates = []
+    list_of_radii = []
+    inertias = []
+    volume = []
+    size = []
+
+    for line in f:
+        if line.startswith("//"):
+            continue
+        if line.startswith("Name"):
+            data = ReadNextLine(f)
+            name = data[0]
+        if line.startswith("Begin centers_and_radii"):
+            while True:
+                nextline=next(f)
+                if nextline.startswith("//"):
+                    continue
+                if nextline.startswith("End centers_and_radii"):
+                    break
+                data = nextline.split()
+                coordinates = [float(data[0]), float(data[1]), float(data[2])]
+                radius = float(data[3])
+                list_of_coordinates.append(coordinates)
+                list_of_radii.append(radius)
+        if line.startswith("Particle_center_and_diameter"):
+            data = ReadNextLine(f)
+            center = [float(data[0]), float(data[1]), float(data[2])]
+        if line.startswith("Size"):
+            data = ReadNextLine(f)
+            size = [float(data[0])]
+        if line.startswith("Volume"):
+            data = ReadNextLine(f)
+            volume = [float(data[0])]
+        if line.startswith("Inertia per unit mass"):
+            data = ReadNextLine(f)
+            IX = float(data[0])
+            data = ReadNextLine(f)
+            IY = float(data[0])
+            data = ReadNextLine(f)
+            IZ = float(data[0])
+            inertias = [IX, IY, IZ]
+
+    f.close()
+
+    try:
+        center
+    except NameError:
+        message = "\n\n" + "************  ERROR!   Problems reading cluster file: " + filename + "  The center could not be found ***************\n\n"
+        Kratos.Logger.PrintInfo(message)
+
+    for i in range(len(list_of_coordinates)):
+        list_of_coordinates[i] = [list_of_coordinates[i][0] - center[0], list_of_coordinates[i][1] - center[1], list_of_coordinates[i][2] - center[2]]
+
+    if len(inertias)==0 or len(volume)==0 or len(size)==0 or len(list_of_radii)==0 or len(list_of_coordinates)==0 :
+        message = "\n\n" + "************  ERROR!   Problems reading cluster file: " + filename + "   ***************\n\n"
+        Kratos.Logger.PrintInfo(message)
+    else:
+        Kratos.Logger.PrintInfo("Cluster file "+ filename + " was read correctly")
+
+    return [name, list_of_coordinates, list_of_radii, size[0], volume[0], inertias]
+
```

## KratosMultiphysics/DEMApplication/angle_finder.py

 * *Ordering differences only*

```diff
@@ -1,55 +1,55 @@
-import sys
-import math
-
-Mailfile = sys.argv[1]
-
-in_file = open(Mailfile, 'r')
-
-number_of_sectors = 12
-span = 360.0 / number_of_sectors
-accumulation = [0] * number_of_sectors
-fraction = [0] * number_of_sectors
-fraction_exp_300 = [0.0, 0.005645342312008972, 0.030788274905921897, 0.2692645408331682, 0.3890479963028982, 0.19824427279329238, 0.06181699346405223, 0.006438106555753553, 0.0002079619726678139, 0.0, 0.0, 0.0]
-fraction_exp_500 = [0.0, 0.00490797546012256, 0.009815950920245342, 0.04539877300613493, 0.40981595092024536, 0.44417177914110423, 0.08036809815950907, 0.00490797546012256, 0.0, 0.0, 0.0, 0.0]
-fraction_exp_650 = [0.0, 0.0, 0.006341436575547199, 0.047897039000100894, 0.47890931765871014, 0.40405553364939345, 0.015909436868987936, 0.0, 0.0, 0.0, 0.0, 0.0]
-total_accumulation = 0
-
-for line in in_file.readlines():
-    numbers = line.split()
-    x_coor = float(numbers[1])
-    y_coor = float(numbers[2])
-    
-    angle_in_radians = math.atan2(y_coor,x_coor)
-    angle_in_degrees = angle_in_radians * 180 / math.pi
-
-    #CORRECTION
-    angle_in_degrees *= -1.0 #Due to the orientation chosen by Liederkerke (clockwise in his paper)
-    
-    if angle_in_degrees < 0.0:
-        angle_in_degrees += 360.0        
-    
-    for sector in range(0,number_of_sectors):
-        if angle_in_degrees <= (sector +1) * span:
-            final_sector = sector
-            accumulation[sector] += 1
-            total_accumulation += 1
-            break
-      
-print("Particle fractions:")
-for sector in range(0,number_of_sectors):
-    fraction[sector] = float( accumulation[sector] ) / float( total_accumulation )
-    print(fraction[sector])
-print("Total number of particles was: " + str(total_accumulation))
-        
-in_file.close()
-
-import matplotlib.pyplot as plotter
-x_range = range(0,number_of_sectors*30,30)
-plotter.plot(x_range, fraction, label="DEM")
-plotter.plot(x_range, fraction_exp_300,label="experiment, 300 rpm")
-plotter.plot(x_range, fraction_exp_500,label="experiment, 500 rpm")
-plotter.plot(x_range, fraction_exp_650,label="experiment, 650 rpm")
-plotter.xlabel('Compartment angle')
-plotter.ylabel('Mass fraction')
-plotter.legend()
-plotter.show()
+import sys
+import math
+
+Mailfile = sys.argv[1]
+
+in_file = open(Mailfile, 'r')
+
+number_of_sectors = 12
+span = 360.0 / number_of_sectors
+accumulation = [0] * number_of_sectors
+fraction = [0] * number_of_sectors
+fraction_exp_300 = [0.0, 0.005645342312008972, 0.030788274905921897, 0.2692645408331682, 0.3890479963028982, 0.19824427279329238, 0.06181699346405223, 0.006438106555753553, 0.0002079619726678139, 0.0, 0.0, 0.0]
+fraction_exp_500 = [0.0, 0.00490797546012256, 0.009815950920245342, 0.04539877300613493, 0.40981595092024536, 0.44417177914110423, 0.08036809815950907, 0.00490797546012256, 0.0, 0.0, 0.0, 0.0]
+fraction_exp_650 = [0.0, 0.0, 0.006341436575547199, 0.047897039000100894, 0.47890931765871014, 0.40405553364939345, 0.015909436868987936, 0.0, 0.0, 0.0, 0.0, 0.0]
+total_accumulation = 0
+
+for line in in_file.readlines():
+    numbers = line.split()
+    x_coor = float(numbers[1])
+    y_coor = float(numbers[2])
+    
+    angle_in_radians = math.atan2(y_coor,x_coor)
+    angle_in_degrees = angle_in_radians * 180 / math.pi
+
+    #CORRECTION
+    angle_in_degrees *= -1.0 #Due to the orientation chosen by Liederkerke (clockwise in his paper)
+    
+    if angle_in_degrees < 0.0:
+        angle_in_degrees += 360.0        
+    
+    for sector in range(0,number_of_sectors):
+        if angle_in_degrees <= (sector +1) * span:
+            final_sector = sector
+            accumulation[sector] += 1
+            total_accumulation += 1
+            break
+      
+print("Particle fractions:")
+for sector in range(0,number_of_sectors):
+    fraction[sector] = float( accumulation[sector] ) / float( total_accumulation )
+    print(fraction[sector])
+print("Total number of particles was: " + str(total_accumulation))
+        
+in_file.close()
+
+import matplotlib.pyplot as plotter
+x_range = range(0,number_of_sectors*30,30)
+plotter.plot(x_range, fraction, label="DEM")
+plotter.plot(x_range, fraction_exp_300,label="experiment, 300 rpm")
+plotter.plot(x_range, fraction_exp_500,label="experiment, 500 rpm")
+plotter.plot(x_range, fraction_exp_650,label="experiment, 650 rpm")
+plotter.xlabel('Compartment angle')
+plotter.ylabel('Mass fraction')
+plotter.legend()
+plotter.show()
```

## KratosMultiphysics/DEMApplication/spreader.py

 * *Ordering differences only*

```diff
@@ -1,95 +1,95 @@
-import math
-from KratosMultiphysics import *
-from KratosMultiphysics.DEMApplication import *
-
-def GetPolarRCoordinate2(node):
-    return node.X ** 2 + node.Y ** 2
-
-def GetPolarCoordinates(node):
-    x = math.sqrt(node.X ** 2 + node.Y ** 2)
-    y = math.atan2(node.Y, node.X)
-    return x, y
-
-class scanner:
-    def __init__(self, model_part, maximum_expected_particle_id,
-             outermost_disc_radius, cone_angle, number_of_vanes):
-        self.model_part = model_part
-        self.n_nodes = maximum_expected_particle_id
-        self.disc_radius_2 = outermost_disc_radius ** 2
-        self.n_vanes = number_of_vanes
-        self.cone_angle = cone_angle
-        self.cos_cone_angle_inv = 1. / math.cos(cone_angle)
-
-        zeros   = [0. for i in range(self.n_nodes)]
-        self.entered = [0  for i in range(self.n_nodes)]
-        self.escaped = [0  for i in range(self.n_nodes)]
-        self.ids = []
-        self.x0_values = zeros[:]
-        self.theta0_values = zeros[:]
-        self.t_values  = zeros[:]
-        self.x_values  = zeros[:]
-        self.y_values  = zeros[:]
-        self.z_values  = zeros[:]
-        self.vx_values = zeros[:]
-        self.vy_values = zeros[:]
-        self.vz_values = zeros[:]
-        self.wx_values = zeros[:]
-        self.wy_values = zeros[:]
-        self.wz_values = zeros[:]
-        self.D_values  = zeros[:]
-
-    def UpdateData(self, time):
-
-        for node in self.model_part.Nodes:
-            i = node.Id
-
-            if node.IsNot(BLOCKED):
-
-                if self.entered[i] == 0:
-                    self.entered[i] = 1
-                    r, theta = GetPolarCoordinates(node)
-                    self.x0_values[i] = r * self.cos_cone_angle_inv
-                    self.theta0_values[i] = theta
-                    self.D_values[i]  = 2. * node.GetSolutionStepValue(RADIUS, 0)
-
-                r2 = GetPolarRCoordinate2(node)
-
-                if r2 > self.disc_radius_2 and self.escaped[i] == 0:
-                    self.ids.append(i)
-                    self.escaped[i] = 1
-                    self.t_values[i]  = time
-                    self.x_values[i]  = node.X
-                    self.y_values[i]  = node.Y
-                    self.z_values[i]  = node.Z
-                    self.vx_values[i] = node.GetSolutionStepValue(VELOCITY_X)
-                    self.vy_values[i] = node.GetSolutionStepValue(VELOCITY_Y)
-                    self.vz_values[i] = node.GetSolutionStepValue(VELOCITY_Z)
-                    self.wx_values[i] = node.GetSolutionStepValue(ANGULAR_VELOCITY_X)
-                    self.wy_values[i] = node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)
-                    self.wz_values[i] = node.GetSolutionStepValue(ANGULAR_VELOCITY_Z)
-
-    def PrintData(self, in_file_path, out_file_path):
-        out_file = open(out_file_path, 'w')
-
-        for node_id in self.ids:
-            out_file.write(str( self.t_values[node_id]) + ' ' +
-                           str( self.x_values[node_id]) + ' ' +
-                           str( self.y_values[node_id]) + ' ' +
-                           str( self.z_values[node_id]) + ' ' +
-                           str(self.vx_values[node_id]) + ' ' +
-                           str(self.vy_values[node_id]) + ' ' +
-                           str(self.vz_values[node_id]) + ' ' +
-                           str(self.wx_values[node_id]) + ' ' +
-                           str(self.wy_values[node_id]) + ' ' +
-                           str(self.wz_values[node_id]) + ' ' +
-                           str( self.D_values[node_id]) + '\n')
-        out_file.close()
-
-        inputs_file = open(in_file_path, 'w')
-
-        for node_id in self.ids:
-            inputs_file.write(str(self.x0_values[node_id]) + ' ' +
-                              str(self.theta0_values[node_id]) + ' ' +
-                              str(self.D_values[node_id]) + '\n')
-
-        inputs_file.close()
+import math
+from KratosMultiphysics import *
+from KratosMultiphysics.DEMApplication import *
+
+def GetPolarRCoordinate2(node):
+    return node.X ** 2 + node.Y ** 2
+
+def GetPolarCoordinates(node):
+    x = math.sqrt(node.X ** 2 + node.Y ** 2)
+    y = math.atan2(node.Y, node.X)
+    return x, y
+
+class scanner:
+    def __init__(self, model_part, maximum_expected_particle_id,
+             outermost_disc_radius, cone_angle, number_of_vanes):
+        self.model_part = model_part
+        self.n_nodes = maximum_expected_particle_id
+        self.disc_radius_2 = outermost_disc_radius ** 2
+        self.n_vanes = number_of_vanes
+        self.cone_angle = cone_angle
+        self.cos_cone_angle_inv = 1. / math.cos(cone_angle)
+
+        zeros   = [0. for i in range(self.n_nodes)]
+        self.entered = [0  for i in range(self.n_nodes)]
+        self.escaped = [0  for i in range(self.n_nodes)]
+        self.ids = []
+        self.x0_values = zeros[:]
+        self.theta0_values = zeros[:]
+        self.t_values  = zeros[:]
+        self.x_values  = zeros[:]
+        self.y_values  = zeros[:]
+        self.z_values  = zeros[:]
+        self.vx_values = zeros[:]
+        self.vy_values = zeros[:]
+        self.vz_values = zeros[:]
+        self.wx_values = zeros[:]
+        self.wy_values = zeros[:]
+        self.wz_values = zeros[:]
+        self.D_values  = zeros[:]
+
+    def UpdateData(self, time):
+
+        for node in self.model_part.Nodes:
+            i = node.Id
+
+            if node.IsNot(BLOCKED):
+
+                if self.entered[i] == 0:
+                    self.entered[i] = 1
+                    r, theta = GetPolarCoordinates(node)
+                    self.x0_values[i] = r * self.cos_cone_angle_inv
+                    self.theta0_values[i] = theta
+                    self.D_values[i]  = 2. * node.GetSolutionStepValue(RADIUS, 0)
+
+                r2 = GetPolarRCoordinate2(node)
+
+                if r2 > self.disc_radius_2 and self.escaped[i] == 0:
+                    self.ids.append(i)
+                    self.escaped[i] = 1
+                    self.t_values[i]  = time
+                    self.x_values[i]  = node.X
+                    self.y_values[i]  = node.Y
+                    self.z_values[i]  = node.Z
+                    self.vx_values[i] = node.GetSolutionStepValue(VELOCITY_X)
+                    self.vy_values[i] = node.GetSolutionStepValue(VELOCITY_Y)
+                    self.vz_values[i] = node.GetSolutionStepValue(VELOCITY_Z)
+                    self.wx_values[i] = node.GetSolutionStepValue(ANGULAR_VELOCITY_X)
+                    self.wy_values[i] = node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)
+                    self.wz_values[i] = node.GetSolutionStepValue(ANGULAR_VELOCITY_Z)
+
+    def PrintData(self, in_file_path, out_file_path):
+        out_file = open(out_file_path, 'w')
+
+        for node_id in self.ids:
+            out_file.write(str( self.t_values[node_id]) + ' ' +
+                           str( self.x_values[node_id]) + ' ' +
+                           str( self.y_values[node_id]) + ' ' +
+                           str( self.z_values[node_id]) + ' ' +
+                           str(self.vx_values[node_id]) + ' ' +
+                           str(self.vy_values[node_id]) + ' ' +
+                           str(self.vz_values[node_id]) + ' ' +
+                           str(self.wx_values[node_id]) + ' ' +
+                           str(self.wy_values[node_id]) + ' ' +
+                           str(self.wz_values[node_id]) + ' ' +
+                           str( self.D_values[node_id]) + '\n')
+        out_file.close()
+
+        inputs_file = open(in_file_path, 'w')
+
+        for node_id in self.ids:
+            inputs_file.write(str(self.x0_values[node_id]) + ' ' +
+                              str(self.theta0_values[node_id]) + ' ' +
+                              str(self.D_values[node_id]) + '\n')
+
+        inputs_file.close()
```

## KratosMultiphysics/DEMApplication/mesh_creator_cluster.py

 * *Ordering differences only*

```diff
@@ -1,121 +1,121 @@
-import os
-
-import KratosMultiphysics
-import KratosMultiphysics.DEMApplication as KratosDEM
-
-# This function takes a ".dempack" file, form the cluster mesher, and a file with the properties and creates a "DEM_Clusters.mdpa"
-def WriteClusterMdpa(problem_name):
-
-    ClusterPropertiesInfo = open(problem_name + "_cluster_properties.info" , 'r')
-    ClusterMeshInfo       = open(problem_name + "_cluster_mesh.dempack", 'r')
-    ClusterMdpa           = open(problem_name + "DEM_Clusters.mdpa", 'w')
-
-    ClusterAvailableTypes  = []
-
-    for Line in ClusterPropertiesInfo:
-        ClusterMdpa.write(Line)
-        if 'CLUSTER_FILE_NAME' in Line:
-            Line = Line.strip('\n')# Remove the line-ending characters
-            ClusterAvailableTypes.append(Line.split(' ')[1])
-
-    ClusterType = []
-    NodeNumber  = []
-    NodeX       = []
-    NodeY       = []
-    NodeZ       = []
-    ChLength    = []
-    qX          = []
-    qY          = []
-    qZ          = []
-    qW          = []
-
-    for Line in ClusterMeshInfo:
-
-        if Line.startswith("Begin_Cluster"):
-            Line = Line.strip('\n')# Remove the line-ending characters
-            for i, cluster_type in enumerate(ClusterAvailableTypes):
-                if Line.split(' ')[1] + ".clu" == cluster_type:
-                    ClusterType.append(i+1)
-
-        if Line[0].isdigit():
-            Line = Line.strip('\n')# Remove the line-ending characters
-            NodeNumber.append(Line.split(' ')[0])
-            NodeX.append(Line.split(' ')[1])
-            NodeY.append(Line.split(' ')[2])
-            NodeZ.append(Line.split(' ')[3])
-            ChLength.append(Line.split(' ')[4])
-            qX.append(Line.split(' ')[5])
-            qY.append(Line.split(' ')[6])
-            qZ.append(Line.split(' ')[7])
-            qW.append(Line.split(' ')[8])
-
-    ClusterMdpa.write('\nBegin Nodes\n')
-
-    for j, node_number in enumerate(NodeNumber):
-        ClusterMdpa.write(node_number + ' ' + NodeX[j] + ' ' + NodeY[j] + ' ' + NodeZ[j] + '\n')
-
-    ClusterMdpa.write('End Nodes\n')
-
-    ClusterMdpa.write('\nBegin Elements Cluster3D\n')
-
-    for j, node_number in enumerate(NodeNumber):
-        ClusterMdpa.write(node_number + ' ' + str(ClusterType[j]) + ' ' + node_number + '\n')
-
-    ClusterMdpa.write('End Elements\n')
-
-    ClusterMdpa.write('\nBegin NodalData CHARACTERISTIC_LENGTH\n')
-
-    for j, node_number in enumerate(NodeNumber):
-        ClusterMdpa.write(node_number + ' 0 ' + ChLength[j] + '\n')
-
-    ClusterMdpa.write('End NodalData\n')
-
-    ClusterMdpa.write('\nBegin NodalData ORIENTATION\n')
-
-    for j, node_number in enumerate(NodeNumber):
-        ClusterMdpa.write(node_number + ' 0 [4] ( ' + qX[j] + ' , ' + qY[j] + ' , ' + qZ[j] + ' , ' + qW[j] + ' )\n')
-
-    ClusterMdpa.write('End NodalData\n')
-
-    ClusterPropertiesInfo.close()
-    ClusterMeshInfo.close()
-    ClusterMdpa.close()
-
-# This function creates a "DEM_Clusters.mdpa" from a simulation
-def WriteClusterMdpaFromResults(filename_pre, pre_path, filename_post, cluster_model_part):
-
-    ClusterMdpa_pre  = open(os.path.join(pre_path, filename_pre) + '.mdpa', 'r')
-    ClusterMdpa_post = open(os.path.join(pre_path, filename_post) + '.mdpa', 'w')
-
-    for Line in ClusterMdpa_pre:
-        # The next 4 lines mean that, while we do not get to 'Begin Nodes', we simply copy the mdpa contents, in this case the Properties part
-        ClusterMdpa_post.write(Line)
-        if Line.startswith('Begin Nodes'):
-            break
-
-    for node in cluster_model_part.Nodes:
-        ClusterMdpa_post.write(str(node.Id) + ' ' + str(node.X) + ' ' + str(node.Y) + ' ' + str(node.Z) + '\n')
-    ClusterMdpa_post.write('End Nodes\n\n')
-
-    for Line in ClusterMdpa_pre:
-        # We copy the element type line from the previous mdpa
-        if Line.startswith('Begin Elements'):
-            ClusterMdpa_post.write(Line)
-            break
-
-    for element in cluster_model_part.Elements:
-        ClusterMdpa_post.write(str(element.Id) + ' ' + str(element.Properties.Id) + ' ' + str(element.GetNode(0).Id) + '\n')
-    ClusterMdpa_post.write('End Elements\n')
-
-    ClusterMdpa_post.write('\nBegin NodalData CHARACTERISTIC_LENGTH\n')
-    for node in cluster_model_part.Nodes:
-        ClusterMdpa_post.write(str(node.Id) + ' 0 ' + str(node.GetSolutionStepValue(KratosDEM.CHARACTERISTIC_LENGTH)) + '\n')
-    ClusterMdpa_post.write('End NodalData\n')
-
-    ClusterMdpa_post.write('\nBegin NodalData ORIENTATION\n')
-    for node in cluster_model_part.Nodes:
-        ClusterMdpa_post.write(str(node.Id) + ' 0 [4] ( ' + str(node.GetSolutionStepValue(KratosMultiphysics.ORIENTATION).X) + ' , ' + str(node.GetSolutionStepValue(KratosMultiphysics.ORIENTATION).Y) + ' , ' + str(node.GetSolutionStepValue(KratosMultiphysics.ORIENTATION).Z) + ' , ' + str(node.GetSolutionStepValue(KratosMultiphysics.ORIENTATION).W) + ' )\n')
-    ClusterMdpa_post.write('End NodalData\n')
-
-    ClusterMdpa_pre.close()
-    ClusterMdpa_post.close()
+import os
+
+import KratosMultiphysics
+import KratosMultiphysics.DEMApplication as KratosDEM
+
+# This function takes a ".dempack" file, form the cluster mesher, and a file with the properties and creates a "DEM_Clusters.mdpa"
+def WriteClusterMdpa(problem_name):
+
+    ClusterPropertiesInfo = open(problem_name + "_cluster_properties.info" , 'r')
+    ClusterMeshInfo       = open(problem_name + "_cluster_mesh.dempack", 'r')
+    ClusterMdpa           = open(problem_name + "DEM_Clusters.mdpa", 'w')
+
+    ClusterAvailableTypes  = []
+
+    for Line in ClusterPropertiesInfo:
+        ClusterMdpa.write(Line)
+        if 'CLUSTER_FILE_NAME' in Line:
+            Line = Line.strip('\n')# Remove the line-ending characters
+            ClusterAvailableTypes.append(Line.split(' ')[1])
+
+    ClusterType = []
+    NodeNumber  = []
+    NodeX       = []
+    NodeY       = []
+    NodeZ       = []
+    ChLength    = []
+    qX          = []
+    qY          = []
+    qZ          = []
+    qW          = []
+
+    for Line in ClusterMeshInfo:
+
+        if Line.startswith("Begin_Cluster"):
+            Line = Line.strip('\n')# Remove the line-ending characters
+            for i, cluster_type in enumerate(ClusterAvailableTypes):
+                if Line.split(' ')[1] + ".clu" == cluster_type:
+                    ClusterType.append(i+1)
+
+        if Line[0].isdigit():
+            Line = Line.strip('\n')# Remove the line-ending characters
+            NodeNumber.append(Line.split(' ')[0])
+            NodeX.append(Line.split(' ')[1])
+            NodeY.append(Line.split(' ')[2])
+            NodeZ.append(Line.split(' ')[3])
+            ChLength.append(Line.split(' ')[4])
+            qX.append(Line.split(' ')[5])
+            qY.append(Line.split(' ')[6])
+            qZ.append(Line.split(' ')[7])
+            qW.append(Line.split(' ')[8])
+
+    ClusterMdpa.write('\nBegin Nodes\n')
+
+    for j, node_number in enumerate(NodeNumber):
+        ClusterMdpa.write(node_number + ' ' + NodeX[j] + ' ' + NodeY[j] + ' ' + NodeZ[j] + '\n')
+
+    ClusterMdpa.write('End Nodes\n')
+
+    ClusterMdpa.write('\nBegin Elements Cluster3D\n')
+
+    for j, node_number in enumerate(NodeNumber):
+        ClusterMdpa.write(node_number + ' ' + str(ClusterType[j]) + ' ' + node_number + '\n')
+
+    ClusterMdpa.write('End Elements\n')
+
+    ClusterMdpa.write('\nBegin NodalData CHARACTERISTIC_LENGTH\n')
+
+    for j, node_number in enumerate(NodeNumber):
+        ClusterMdpa.write(node_number + ' 0 ' + ChLength[j] + '\n')
+
+    ClusterMdpa.write('End NodalData\n')
+
+    ClusterMdpa.write('\nBegin NodalData ORIENTATION\n')
+
+    for j, node_number in enumerate(NodeNumber):
+        ClusterMdpa.write(node_number + ' 0 [4] ( ' + qX[j] + ' , ' + qY[j] + ' , ' + qZ[j] + ' , ' + qW[j] + ' )\n')
+
+    ClusterMdpa.write('End NodalData\n')
+
+    ClusterPropertiesInfo.close()
+    ClusterMeshInfo.close()
+    ClusterMdpa.close()
+
+# This function creates a "DEM_Clusters.mdpa" from a simulation
+def WriteClusterMdpaFromResults(filename_pre, pre_path, filename_post, cluster_model_part):
+
+    ClusterMdpa_pre  = open(os.path.join(pre_path, filename_pre) + '.mdpa', 'r')
+    ClusterMdpa_post = open(os.path.join(pre_path, filename_post) + '.mdpa', 'w')
+
+    for Line in ClusterMdpa_pre:
+        # The next 4 lines mean that, while we do not get to 'Begin Nodes', we simply copy the mdpa contents, in this case the Properties part
+        ClusterMdpa_post.write(Line)
+        if Line.startswith('Begin Nodes'):
+            break
+
+    for node in cluster_model_part.Nodes:
+        ClusterMdpa_post.write(str(node.Id) + ' ' + str(node.X) + ' ' + str(node.Y) + ' ' + str(node.Z) + '\n')
+    ClusterMdpa_post.write('End Nodes\n\n')
+
+    for Line in ClusterMdpa_pre:
+        # We copy the element type line from the previous mdpa
+        if Line.startswith('Begin Elements'):
+            ClusterMdpa_post.write(Line)
+            break
+
+    for element in cluster_model_part.Elements:
+        ClusterMdpa_post.write(str(element.Id) + ' ' + str(element.Properties.Id) + ' ' + str(element.GetNode(0).Id) + '\n')
+    ClusterMdpa_post.write('End Elements\n')
+
+    ClusterMdpa_post.write('\nBegin NodalData CHARACTERISTIC_LENGTH\n')
+    for node in cluster_model_part.Nodes:
+        ClusterMdpa_post.write(str(node.Id) + ' 0 ' + str(node.GetSolutionStepValue(KratosDEM.CHARACTERISTIC_LENGTH)) + '\n')
+    ClusterMdpa_post.write('End NodalData\n')
+
+    ClusterMdpa_post.write('\nBegin NodalData ORIENTATION\n')
+    for node in cluster_model_part.Nodes:
+        ClusterMdpa_post.write(str(node.Id) + ' 0 [4] ( ' + str(node.GetSolutionStepValue(KratosMultiphysics.ORIENTATION).X) + ' , ' + str(node.GetSolutionStepValue(KratosMultiphysics.ORIENTATION).Y) + ' , ' + str(node.GetSolutionStepValue(KratosMultiphysics.ORIENTATION).Z) + ' , ' + str(node.GetSolutionStepValue(KratosMultiphysics.ORIENTATION).W) + ' )\n')
+    ClusterMdpa_post.write('End NodalData\n')
+
+    ClusterMdpa_pre.close()
+    ClusterMdpa_post.close()
```

## KratosMultiphysics/DEMApplication/mesh_to_mdpa_converter.py

 * *Ordering differences only*

```diff
@@ -1,192 +1,192 @@
-# MESH TO COHESIVE MDPA CONVERTER
-import sys
-
-mesh_namefile = sys.argv[1] + '.msh'
-mdpa_namefile = sys.argv[2] + '.mdpa'
-
-SpheresMesh = open(mesh_namefile, 'r')
-SpheresMdpa = open(mdpa_namefile, 'w')
-
-'''
-If triaxial test, then Test_type = 1
-If BTS test, then Test_type = 2
-If SP, then Test_type = 3
-'''
-Test_type = 3
-top = 0.0
-bottom = 0.0
-radius = 0.0
-internal_tol_factor = 2.0
-external_tol_factor = 1.0
-mean_particle_radius = 2e-3
-# Ring dimensions
-internal_radius = 0.1
-external_radius = 0.15
-
-# Test type: Triaxial or BTS
-if Test_type == 1:
-    top = 0.002771549
-    bottom = 0.0
-    radius = 0.0006907713
-elif Test_type == 2:
-    top = 0.0008956682
-    bottom = 0.0
-    radius = 0.001222598
-
-node_section_started = False
-node_section_finished = False
-element_section_started = False
-node_list = []
-coord_x_list = []
-coord_y_list = []
-coord_z_list = []
-element_list = []
-radius_list = []
-props_list = []
-zeros_list = []
-skin_list = []
-
-for Line in SpheresMesh:
-
-    if Line.startswith('Coordinates'):
-        node_section_started = True
-        continue
-
-    if node_section_started and not node_section_finished:
-        if Line.startswith('End Coordinates'):
-            node_section_finished = True
-            continue
-        data = Line.split(" ")
-        data[0] = int(data[0])
-        data[1] = float(data[1])
-        data[2] = float(data[2])
-        data[3] = float(data[3])
-
-        if Test_type == 1:
-            if data[2] > top:
-                continue
-            if data[2] < bottom:
-                continue
-            if (data[1] * data[1] + data[3] * data[3] > radius * radius):
-                continue
-        elif Test_type == 2:
-            if data[3] > top:
-                continue
-            if data[3] < bottom:
-                continue
-            if (data[1] * data[1] + data[2] * data[2] > radius * radius):
-                continue
-        else:
-            if (data[1] * data[1] + data[2] * data[2] > external_radius * external_radius):
-                continue
-            if (data[1] * data[1] + data[2] * data[2] < (internal_radius + mean_particle_radius) * (internal_radius + mean_particle_radius)):
-                continue
-            if (data[1] * data[1] + data[2] * data[2] > (external_radius - external_tol_factor * mean_particle_radius) * (external_radius - external_tol_factor * mean_particle_radius)):
-                skin_list.append(data[0])
-            if (data[1] * data[1] + data[2] * data[2] < (internal_radius + internal_tol_factor * mean_particle_radius) * (internal_radius + internal_tol_factor * mean_particle_radius)):
-                skin_list.append(data[0])
-
-        node_list.append(data[0])
-        element_list.append(data[0])
-        coord_x_list.append(data[1])
-        coord_y_list.append(data[2])
-        coord_z_list.append(data[3])
-        zeros_list.append('0')
-
-    if Line.startswith('Elements'):
-        element_section_started = True
-        continue
-
-    if element_section_started:
-        if Line.startswith('End Elements'):
-            break
-        data = Line.split(" ")
-        data[0] = int(data[0])
-        data[2] = float(data[2])
-        data[3] = int(data[3])
-        if data[0] in element_list:
-            radius_list.append(data[2])
-            if Test_type < 3:
-                props_list.append(data[3])
-            else:
-                props_list.append(1)
-
-zeros_list = [int(i) for i in zeros_list]
-
-SpheresMesh.close()
-
-SpheresMdpa.write('''Begin ModelPartData
-//  VARIABLE_NAME value
-End ModelPartData\n
-Begin Properties 1
-PARTICLE_DENSITY 2650.0
-YOUNG_MODULUS 8.03e7
-POISSON_RATIO 0.25
-FRICTION 0.6
-PARTICLE_COHESION 0.0
-COEFFICIENT_OF_RESTITUTION 0.01
-PARTICLE_MATERIAL 1
-ROLLING_FRICTION 0.025
-ROLLING_FRICTION_WITH_WALLS 0.0
-DEM_CONTINUUM_CONSTITUTIVE_LAW_NAME DEM_KDEM_with_damage_parallel_bond_Hertz //_Hertz
-INTERNAL_COHESION 13.72
-INTERNAL_FRICTION_ANGLE 24.1
-DEM_DISCONTINUUM_CONSTITUTIVE_LAW_NAME DEM_D_Linear_HighStiffness //_Coulomb //DEM_D_Linear_HighStiffness
-CONTACT_TAU_ZERO 10e4
-CONTACT_SIGMA_MIN 13.72e6
-CONTACT_INTERNAL_FRICC 0.0
-ROTATIONAL_MOMENT_COEFFICIENT 0.01
-KDEM_STANDARD_DEVIATION_TAU_ZERO 3.43
-KDEM_STANDARD_DEVIATION_FRICTION 0.2235
-SHEAR_ENERGY_COEF 4.0
-LOOSE_MATERIAL_YOUNG_MODULUS 8e7
-FRACTURE_ENERGY 0.0
-End Properties\n
-Begin Nodes\n''')
-
-for i in range(len(node_list)):
-    SpheresMdpa.write("%i %12.8f %12.8f %12.8f\n" % (node_list[i], coord_x_list[i], coord_y_list[i], coord_z_list[i]))
-
-SpheresMdpa.write('''End Nodes\n
-Begin Elements SphericContinuumParticle3D\n''')
-
-for i in range(len(node_list)):
-    SpheresMdpa.write("%i %i %i\n" % (element_list[i], props_list[i], node_list[i]))
-
-SpheresMdpa.write('''End Elements\n
-Begin NodalData RADIUS\n''')
-
-for i in range(len(node_list)):
-    SpheresMdpa.write("%i %i %12.8f\n" % (node_list[i], zeros_list[i], radius_list[i]))
-
-SpheresMdpa.write('''End NodalData\n
-Begin NodalData COHESIVE_GROUP\n''')
-
-for i in range(len(node_list)):
-    SpheresMdpa.write("%i %i %i\n" % (node_list[i], zeros_list[i], props_list[i]))
-
-SpheresMdpa.write('''End NodalData\n
-Begin NodalData SKIN_SPHERE\n''')
-if Test_type == 3:
-    for i in range(len(skin_list)):
-        SpheresMdpa.write("%i %i %i\n" % (skin_list[i], zeros_list[i], props_list[i]))
-
-SpheresMdpa.write('''End NodalData\n
-Begin SubModelPart PartsCont_dem // Group dem // Subtree PartsCont
-    Begin SubModelPartNodes\n''')
-
-for i in range(len(node_list)):
-    SpheresMdpa.write("%i\n" % (node_list[i]))
-
-SpheresMdpa.write('''End SubModelPartNodes
-    Begin SubModelPartElements\n''')
-
-for i in range(len(node_list)):
-    SpheresMdpa.write("%i\n" % (element_list[i]))
-
-SpheresMdpa.write('''End SubModelPartElements
-    Begin SubModelPartConditions
-    End SubModelPartConditions
-End SubModelPart\n''')
-
-SpheresMdpa.close()
+# MESH TO COHESIVE MDPA CONVERTER
+import sys
+
+mesh_namefile = sys.argv[1] + '.msh'
+mdpa_namefile = sys.argv[2] + '.mdpa'
+
+SpheresMesh = open(mesh_namefile, 'r')
+SpheresMdpa = open(mdpa_namefile, 'w')
+
+'''
+If triaxial test, then Test_type = 1
+If BTS test, then Test_type = 2
+If SP, then Test_type = 3
+'''
+Test_type = 3
+top = 0.0
+bottom = 0.0
+radius = 0.0
+internal_tol_factor = 2.0
+external_tol_factor = 1.0
+mean_particle_radius = 2e-3
+# Ring dimensions
+internal_radius = 0.1
+external_radius = 0.15
+
+# Test type: Triaxial or BTS
+if Test_type == 1:
+    top = 0.002771549
+    bottom = 0.0
+    radius = 0.0006907713
+elif Test_type == 2:
+    top = 0.0008956682
+    bottom = 0.0
+    radius = 0.001222598
+
+node_section_started = False
+node_section_finished = False
+element_section_started = False
+node_list = []
+coord_x_list = []
+coord_y_list = []
+coord_z_list = []
+element_list = []
+radius_list = []
+props_list = []
+zeros_list = []
+skin_list = []
+
+for Line in SpheresMesh:
+
+    if Line.startswith('Coordinates'):
+        node_section_started = True
+        continue
+
+    if node_section_started and not node_section_finished:
+        if Line.startswith('End Coordinates'):
+            node_section_finished = True
+            continue
+        data = Line.split(" ")
+        data[0] = int(data[0])
+        data[1] = float(data[1])
+        data[2] = float(data[2])
+        data[3] = float(data[3])
+
+        if Test_type == 1:
+            if data[2] > top:
+                continue
+            if data[2] < bottom:
+                continue
+            if (data[1] * data[1] + data[3] * data[3] > radius * radius):
+                continue
+        elif Test_type == 2:
+            if data[3] > top:
+                continue
+            if data[3] < bottom:
+                continue
+            if (data[1] * data[1] + data[2] * data[2] > radius * radius):
+                continue
+        else:
+            if (data[1] * data[1] + data[2] * data[2] > external_radius * external_radius):
+                continue
+            if (data[1] * data[1] + data[2] * data[2] < (internal_radius + mean_particle_radius) * (internal_radius + mean_particle_radius)):
+                continue
+            if (data[1] * data[1] + data[2] * data[2] > (external_radius - external_tol_factor * mean_particle_radius) * (external_radius - external_tol_factor * mean_particle_radius)):
+                skin_list.append(data[0])
+            if (data[1] * data[1] + data[2] * data[2] < (internal_radius + internal_tol_factor * mean_particle_radius) * (internal_radius + internal_tol_factor * mean_particle_radius)):
+                skin_list.append(data[0])
+
+        node_list.append(data[0])
+        element_list.append(data[0])
+        coord_x_list.append(data[1])
+        coord_y_list.append(data[2])
+        coord_z_list.append(data[3])
+        zeros_list.append('0')
+
+    if Line.startswith('Elements'):
+        element_section_started = True
+        continue
+
+    if element_section_started:
+        if Line.startswith('End Elements'):
+            break
+        data = Line.split(" ")
+        data[0] = int(data[0])
+        data[2] = float(data[2])
+        data[3] = int(data[3])
+        if data[0] in element_list:
+            radius_list.append(data[2])
+            if Test_type < 3:
+                props_list.append(data[3])
+            else:
+                props_list.append(1)
+
+zeros_list = [int(i) for i in zeros_list]
+
+SpheresMesh.close()
+
+SpheresMdpa.write('''Begin ModelPartData
+//  VARIABLE_NAME value
+End ModelPartData\n
+Begin Properties 1
+PARTICLE_DENSITY 2650.0
+YOUNG_MODULUS 8.03e7
+POISSON_RATIO 0.25
+FRICTION 0.6
+PARTICLE_COHESION 0.0
+COEFFICIENT_OF_RESTITUTION 0.01
+PARTICLE_MATERIAL 1
+ROLLING_FRICTION 0.025
+ROLLING_FRICTION_WITH_WALLS 0.0
+DEM_CONTINUUM_CONSTITUTIVE_LAW_NAME DEM_KDEM_with_damage_parallel_bond_Hertz //_Hertz
+INTERNAL_COHESION 13.72
+INTERNAL_FRICTION_ANGLE 24.1
+DEM_DISCONTINUUM_CONSTITUTIVE_LAW_NAME DEM_D_Linear_HighStiffness //_Coulomb //DEM_D_Linear_HighStiffness
+CONTACT_TAU_ZERO 10e4
+CONTACT_SIGMA_MIN 13.72e6
+CONTACT_INTERNAL_FRICC 0.0
+ROTATIONAL_MOMENT_COEFFICIENT 0.01
+KDEM_STANDARD_DEVIATION_TAU_ZERO 3.43
+KDEM_STANDARD_DEVIATION_FRICTION 0.2235
+SHEAR_ENERGY_COEF 4.0
+LOOSE_MATERIAL_YOUNG_MODULUS 8e7
+FRACTURE_ENERGY 0.0
+End Properties\n
+Begin Nodes\n''')
+
+for i in range(len(node_list)):
+    SpheresMdpa.write("%i %12.8f %12.8f %12.8f\n" % (node_list[i], coord_x_list[i], coord_y_list[i], coord_z_list[i]))
+
+SpheresMdpa.write('''End Nodes\n
+Begin Elements SphericContinuumParticle3D\n''')
+
+for i in range(len(node_list)):
+    SpheresMdpa.write("%i %i %i\n" % (element_list[i], props_list[i], node_list[i]))
+
+SpheresMdpa.write('''End Elements\n
+Begin NodalData RADIUS\n''')
+
+for i in range(len(node_list)):
+    SpheresMdpa.write("%i %i %12.8f\n" % (node_list[i], zeros_list[i], radius_list[i]))
+
+SpheresMdpa.write('''End NodalData\n
+Begin NodalData COHESIVE_GROUP\n''')
+
+for i in range(len(node_list)):
+    SpheresMdpa.write("%i %i %i\n" % (node_list[i], zeros_list[i], props_list[i]))
+
+SpheresMdpa.write('''End NodalData\n
+Begin NodalData SKIN_SPHERE\n''')
+if Test_type == 3:
+    for i in range(len(skin_list)):
+        SpheresMdpa.write("%i %i %i\n" % (skin_list[i], zeros_list[i], props_list[i]))
+
+SpheresMdpa.write('''End NodalData\n
+Begin SubModelPart PartsCont_dem // Group dem // Subtree PartsCont
+    Begin SubModelPartNodes\n''')
+
+for i in range(len(node_list)):
+    SpheresMdpa.write("%i\n" % (node_list[i]))
+
+SpheresMdpa.write('''End SubModelPartNodes
+    Begin SubModelPartElements\n''')
+
+for i in range(len(node_list)):
+    SpheresMdpa.write("%i\n" % (element_list[i]))
+
+SpheresMdpa.write('''End SubModelPartElements
+    Begin SubModelPartConditions
+    End SubModelPartConditions
+End SubModelPart\n''')
+
+SpheresMdpa.close()
```

## KratosMultiphysics/DEMApplication/materials_assignation_utility.py

 * *Ordering differences only*

```diff
@@ -1,95 +1,95 @@
-import KratosMultiphysics as Kratos
-from KratosMultiphysics.DEMApplication import *
-
-import sys
-
-class MaterialsAssignationUtility:
-
-    def __init__(self, model, spheres_model_part, DEM_material_parameters):
-        self.model = model
-        self.spheres_model_part = spheres_model_part
-        self.DEM_material_parameters = DEM_material_parameters
-        self.read_materials_utility = Kratos.ReadMaterialsUtility(model)
-
-    def AssignMaterialParametersToProperties(self):
-
-        materials_parameters = self.DEM_material_parameters
-        list_of_materials = materials_parameters["materials"]
-        list_of_material_relations = materials_parameters["material_relations"]
-
-        for material in list_of_materials.values():
-            material_id = material["material_id"].GetInt()
-            if self.spheres_model_part.HasProperties(material_id):
-                self.spheres_model_part.RemoveProperties(material_id)
-            self.spheres_model_part.CreateNewProperties(material_id)
-
-            properties_of_model_part_with_this_id = self.spheres_model_part.GetProperties()[material_id]
-            properties = material["Variables"]
-            self.read_materials_utility.AssignVariablesToProperty(material, properties_of_model_part_with_this_id)
-            self.read_materials_utility.AssignTablesToProperty(material, properties_of_model_part_with_this_id)
-
-            for material_relation in list_of_material_relations.values():
-                subprops = None
-                material_ids_list = material_relation["material_ids_list"].GetVector()
-                if material_id == material_ids_list[0]:
-                    index_of_the_other_material = int(material_ids_list[1])
-                    subprops = Kratos.Properties(index_of_the_other_material)
-                elif material_id == material_ids_list[1]:
-                    index_of_the_other_material = int(material_ids_list[0])
-                    subprops = Kratos.Properties(index_of_the_other_material)
-
-                if subprops:
-                    contact_properties = material_relation["Variables"]
-                    self.read_materials_utility.AssignVariablesToProperty(material_relation, subprops)
-
-                    if subprops.Has(DEM_CONTINUUM_CONSTITUTIVE_LAW_NAME):
-                        continuum_constitutive_law_instance = globals().get(subprops[DEM_CONTINUUM_CONSTITUTIVE_LAW_NAME])()
-                        continuum_constitutive_law_instance.SetConstitutiveLawInPropertiesWithParameters(subprops, material_relation, True)
-
-                    properties_of_model_part_with_this_id.AddSubProperties(subprops)
-
-    def AssignPropertiesToEntities(self):
-        materials_parameters = self.DEM_material_parameters
-        list_of_materials = materials_parameters["materials"]
-        material_assignation_table = materials_parameters["material_assignation_table"]
-
-        for pair in material_assignation_table.values():
-            submodelpart_name_in_assignation_table = pair[0].GetString()
-            submodelpart = self.model.GetModelPart(submodelpart_name_in_assignation_table)
-            if submodelpart.Has(PROPERTIES_ID):
-                raise Exception("Error with (Sub)Modelpart "+ submodelpart.Name + " . ModelParts or SubModelParts with a pre-assigned variable PROPERTIES_ID may cause a bad assignation of materials. ")
-            for smp in submodelpart.SubModelParts:
-                if smp.Has(PROPERTIES_ID):
-                    raise Exception("Error with SubModelpart "+ smp.Name + " . ModelParts or SubModelParts with a pre-assigned variable PROPERTIES_ID may cause a bad assignation of materials. ")
-
-        for pair in material_assignation_table.values():
-            submodelpart_name_in_assignation_table = pair[0].GetString()
-            submodelpart = self.model.GetModelPart(submodelpart_name_in_assignation_table)
-
-            if pair[1].IsString():
-                material_name_in_assignation_table = pair[1].GetString()
-                material_id = None
-                for material in list_of_materials:
-                    material_name_in_materials_list = material["material_name"].GetString()
-                    if material_name_in_assignation_table == material_name_in_materials_list:
-                        material_id = material["material_id"].GetInt()
-                        break
-                if material_id is None:
-                    raise Exception("Error: while reading the materials assignation table, the material name " + material_name_in_assignation_table + " could not be found in the materials list.")
-
-            elif pair[1].IsInt():
-                material_id = pair[1].GetInt()
-            else:
-                raise Exception("While reading the materials assignation table, the material was not identified with a string or an integer.")
-
-            props = self.spheres_model_part.GetProperties()[material_id]
-            submodelpart.SetValue(PROPERTIES_ID, material_id)
-
-            for smp in submodelpart.SubModelParts:
-                if not smp.Has(PROPERTIES_ID):
-                    smp.SetValue(PROPERTIES_ID, material_id)
-
-            for element in submodelpart.Elements:
-                element.Properties = props
-            for condition in submodelpart.Conditions:
-                condition.Properties = props
+import KratosMultiphysics as Kratos
+from KratosMultiphysics.DEMApplication import *
+
+import sys
+
+class MaterialsAssignationUtility:
+
+    def __init__(self, model, spheres_model_part, DEM_material_parameters):
+        self.model = model
+        self.spheres_model_part = spheres_model_part
+        self.DEM_material_parameters = DEM_material_parameters
+        self.read_materials_utility = Kratos.ReadMaterialsUtility(model)
+
+    def AssignMaterialParametersToProperties(self):
+
+        materials_parameters = self.DEM_material_parameters
+        list_of_materials = materials_parameters["materials"]
+        list_of_material_relations = materials_parameters["material_relations"]
+
+        for material in list_of_materials.values():
+            material_id = material["material_id"].GetInt()
+            if self.spheres_model_part.HasProperties(material_id):
+                self.spheres_model_part.RemoveProperties(material_id)
+            self.spheres_model_part.CreateNewProperties(material_id)
+
+            properties_of_model_part_with_this_id = self.spheres_model_part.GetProperties()[material_id]
+            properties = material["Variables"]
+            self.read_materials_utility.AssignVariablesToProperty(material, properties_of_model_part_with_this_id)
+            self.read_materials_utility.AssignTablesToProperty(material, properties_of_model_part_with_this_id)
+
+            for material_relation in list_of_material_relations.values():
+                subprops = None
+                material_ids_list = material_relation["material_ids_list"].GetVector()
+                if material_id == material_ids_list[0]:
+                    index_of_the_other_material = int(material_ids_list[1])
+                    subprops = Kratos.Properties(index_of_the_other_material)
+                elif material_id == material_ids_list[1]:
+                    index_of_the_other_material = int(material_ids_list[0])
+                    subprops = Kratos.Properties(index_of_the_other_material)
+
+                if subprops:
+                    contact_properties = material_relation["Variables"]
+                    self.read_materials_utility.AssignVariablesToProperty(material_relation, subprops)
+
+                    if subprops.Has(DEM_CONTINUUM_CONSTITUTIVE_LAW_NAME):
+                        continuum_constitutive_law_instance = globals().get(subprops[DEM_CONTINUUM_CONSTITUTIVE_LAW_NAME])()
+                        continuum_constitutive_law_instance.SetConstitutiveLawInPropertiesWithParameters(subprops, material_relation, True)
+
+                    properties_of_model_part_with_this_id.AddSubProperties(subprops)
+
+    def AssignPropertiesToEntities(self):
+        materials_parameters = self.DEM_material_parameters
+        list_of_materials = materials_parameters["materials"]
+        material_assignation_table = materials_parameters["material_assignation_table"]
+
+        for pair in material_assignation_table.values():
+            submodelpart_name_in_assignation_table = pair[0].GetString()
+            submodelpart = self.model.GetModelPart(submodelpart_name_in_assignation_table)
+            if submodelpart.Has(PROPERTIES_ID):
+                raise Exception("Error with (Sub)Modelpart "+ submodelpart.Name + " . ModelParts or SubModelParts with a pre-assigned variable PROPERTIES_ID may cause a bad assignation of materials. ")
+            for smp in submodelpart.SubModelParts:
+                if smp.Has(PROPERTIES_ID):
+                    raise Exception("Error with SubModelpart "+ smp.Name + " . ModelParts or SubModelParts with a pre-assigned variable PROPERTIES_ID may cause a bad assignation of materials. ")
+
+        for pair in material_assignation_table.values():
+            submodelpart_name_in_assignation_table = pair[0].GetString()
+            submodelpart = self.model.GetModelPart(submodelpart_name_in_assignation_table)
+
+            if pair[1].IsString():
+                material_name_in_assignation_table = pair[1].GetString()
+                material_id = None
+                for material in list_of_materials:
+                    material_name_in_materials_list = material["material_name"].GetString()
+                    if material_name_in_assignation_table == material_name_in_materials_list:
+                        material_id = material["material_id"].GetInt()
+                        break
+                if material_id is None:
+                    raise Exception("Error: while reading the materials assignation table, the material name " + material_name_in_assignation_table + " could not be found in the materials list.")
+
+            elif pair[1].IsInt():
+                material_id = pair[1].GetInt()
+            else:
+                raise Exception("While reading the materials assignation table, the material was not identified with a string or an integer.")
+
+            props = self.spheres_model_part.GetProperties()[material_id]
+            submodelpart.SetValue(PROPERTIES_ID, material_id)
+
+            for smp in submodelpart.SubModelParts:
+                if not smp.Has(PROPERTIES_ID):
+                    smp.SetValue(PROPERTIES_ID, material_id)
+
+            for element in submodelpart.Elements:
+                element.Properties = props
+            for condition in submodelpart.Conditions:
+                condition.Properties = props
```

## KratosMultiphysics/DEMApplication/MPIer.py

 * *Ordering differences only*

```diff
@@ -1,82 +1,82 @@
-#Modelpart Fixer
-import sys
-import math
-import shutil as Shutil
-
-class MPIerClass:
-
-  def __init__(self,input_file):
-      tem_filename = 'temporal_file.mdpa'      
-      output_file = open(tem_filename,'w')
-      
-      with open(str(input_file)) as f:
-          content = f.readlines()
-          
-      fix_nodes = 0
-      old_id = 0
-
-      NodalData_VELOCITY_X = []
-      NodalData_VELOCITY_Y = []
-      NodalData_VELOCITY_Z = []
-      NodalData_RADIUS = []
-      NodalData_GROUP_ID = []
-      NodalData_PARTICLE_CONTINUUM = []
-
-      for l in content:
-        
-          if("Begin Nodes" in l):
-              fix_nodes = 1
-              output_file.write(l)
-              continue
-        
-          if("End Nodes" in l):
-              fix_nodes = 0
-              output_file.write(l)
-              continue
-                  
-          if(fix_nodes == 1):
-              a = l.split(' ',1)
-              
-              cur_id = int(a[0])
-              
-              while(cur_id-old_id != 1):
-                  old_id = old_id + 1
-                  
-                  NodalData_VELOCITY_X.append([old_id, 0])
-                  NodalData_VELOCITY_Y.append([old_id, 0])
-                  NodalData_VELOCITY_Z.append([old_id, 0])
-                  NodalData_RADIUS.append([old_id, 5.00000e-10])
-                  NodalData_GROUP_ID.append([old_id, 1])
-                  NodalData_PARTICLE_CONTINUUM.append([old_id, 1])
-              
-                  output_file.write(str(old_id) + " 0 0 0\n")
-                  
-              old_id = cur_id
-          
-          output_file.write(l)
-          
-          if("NodalData VELOCITY_X" in l):
-              for n in NodalData_VELOCITY_X:
-                  output_file.write(str(n[0]) + " 1 " + str(n[1]) + "\n")
-          if("NodalData VELOCITY_Y" in l):
-              for n in NodalData_VELOCITY_Y:
-                  output_file.write(str(n[0]) + " 1 " + str(n[1]) + "\n")      
-          if("NodalData VELOCITY_Z" in l):
-              for n in NodalData_VELOCITY_Z:
-                  output_file.write(str(n[0]) + " 1 " + str(n[1]) + "\n")
-          if("NodalData RADIUS" in l):
-              for n in NodalData_RADIUS:
-                  output_file.write(str(n[0]) + " 0 " + str(n[1]) + "\n")
-          if("NodalData GROUP_ID" in l):
-              for n in NodalData_GROUP_ID:
-                  output_file.write(str(n[0]) + " 0 " + str(n[1]) + "\n")
-          if("NodalData PARTICLE_CONTINUUM" in l):
-              for n in NodalData_PARTICLE_CONTINUUM:
-                  output_file.write(str(n[0]) + " 0 " + str(n[1]) + "\n")
-          
-      
-      output_file.close()
-      Shutil.copyfile(str(input_file),'backup.mdpa')
-      Shutil.move(tem_filename,str(input_file))
-          
-
+#Modelpart Fixer
+import sys
+import math
+import shutil as Shutil
+
+class MPIerClass:
+
+  def __init__(self,input_file):
+      tem_filename = 'temporal_file.mdpa'      
+      output_file = open(tem_filename,'w')
+      
+      with open(str(input_file)) as f:
+          content = f.readlines()
+          
+      fix_nodes = 0
+      old_id = 0
+
+      NodalData_VELOCITY_X = []
+      NodalData_VELOCITY_Y = []
+      NodalData_VELOCITY_Z = []
+      NodalData_RADIUS = []
+      NodalData_GROUP_ID = []
+      NodalData_PARTICLE_CONTINUUM = []
+
+      for l in content:
+        
+          if("Begin Nodes" in l):
+              fix_nodes = 1
+              output_file.write(l)
+              continue
+        
+          if("End Nodes" in l):
+              fix_nodes = 0
+              output_file.write(l)
+              continue
+                  
+          if(fix_nodes == 1):
+              a = l.split(' ',1)
+              
+              cur_id = int(a[0])
+              
+              while(cur_id-old_id != 1):
+                  old_id = old_id + 1
+                  
+                  NodalData_VELOCITY_X.append([old_id, 0])
+                  NodalData_VELOCITY_Y.append([old_id, 0])
+                  NodalData_VELOCITY_Z.append([old_id, 0])
+                  NodalData_RADIUS.append([old_id, 5.00000e-10])
+                  NodalData_GROUP_ID.append([old_id, 1])
+                  NodalData_PARTICLE_CONTINUUM.append([old_id, 1])
+              
+                  output_file.write(str(old_id) + " 0 0 0\n")
+                  
+              old_id = cur_id
+          
+          output_file.write(l)
+          
+          if("NodalData VELOCITY_X" in l):
+              for n in NodalData_VELOCITY_X:
+                  output_file.write(str(n[0]) + " 1 " + str(n[1]) + "\n")
+          if("NodalData VELOCITY_Y" in l):
+              for n in NodalData_VELOCITY_Y:
+                  output_file.write(str(n[0]) + " 1 " + str(n[1]) + "\n")      
+          if("NodalData VELOCITY_Z" in l):
+              for n in NodalData_VELOCITY_Z:
+                  output_file.write(str(n[0]) + " 1 " + str(n[1]) + "\n")
+          if("NodalData RADIUS" in l):
+              for n in NodalData_RADIUS:
+                  output_file.write(str(n[0]) + " 0 " + str(n[1]) + "\n")
+          if("NodalData GROUP_ID" in l):
+              for n in NodalData_GROUP_ID:
+                  output_file.write(str(n[0]) + " 0 " + str(n[1]) + "\n")
+          if("NodalData PARTICLE_CONTINUUM" in l):
+              for n in NodalData_PARTICLE_CONTINUUM:
+                  output_file.write(str(n[0]) + " 0 " + str(n[1]) + "\n")
+          
+      
+      output_file.close()
+      Shutil.copyfile(str(input_file),'backup.mdpa')
+      Shutil.move(tem_filename,str(input_file))
+          
+
```

## KratosMultiphysics/DEMApplication/dem_default_input_parameters.py

 * *Ordering differences only*

```diff
@@ -1,191 +1,191 @@
-import KratosMultiphysics
-
-def GetDefaultInputParameters():
-    default_settings = KratosMultiphysics.Parameters("""
-        {
-            "do_print_results_option"          : true,
-            "WriteMdpaFromResults"             : false,
-            "Dimension"                        : 3,
-            "PeriodicDomainOption"             : false,
-            "BoundingBoxOption"                : false,
-            "AutomaticBoundingBoxOption"       : false,
-            "BoundingBoxEnlargementFactor"     : 1.0,
-            "BoundingBoxStartTime"             : 0.0,
-            "BoundingBoxStopTime"              : 1000.0,
-            "BoundingBoxMaxX"                  : 10.0,
-            "BoundingBoxMaxY"                  : 10.0,
-            "BoundingBoxMaxZ"                  : 10.0,
-            "BoundingBoxMinX"                  : -10.0,
-            "BoundingBoxMinY"                  : -10.0,
-            "BoundingBoxMinZ"                  : -10.0,
-            "BoundingBoxMoveOption"            : false,
-            "BoundingBoxMoveVelocity"          : 0.001,
-            "dem_inlet_option"                 : true,
-            "dem_inlets_settings"              : {},
-            "seed"                             : 42,
-            "GravityX"                         : 0.0,
-            "GravityY"                         : 0.0,
-            "GravityZ"                         : -9.81,
-            "EnergyCalculationOption"          : false,
-            "PotentialEnergyReferencePointX"   : 0.0,
-            "PotentialEnergyReferencePointY"   : 0.0,
-            "PotentialEnergyReferencePointZ"   : 0.0,
-            "VelocityTrapOption"               : false,
-            "VelocityTrapMaxX"                 : 0.0,
-            "VelocityTrapMaxY"                 : 0.0,
-            "VelocityTrapMaxZ"                 : 0.0,
-            "VelocityTrapMinX"                 : 0.0,
-            "VelocityTrapMinY"                 : 0.0,
-            "VelocityTrapMinZ"                 : 0.0,
-            "RotationOption"                   : true,
-            "CleanIndentationsOption"          : false,
-            "RemoveBallsInEmbeddedOption"      : false,
-            "solver_settings" : {},
-            "creator_destructor_settings" : {},
-            "echo_level"                  : 1,
-            "problem_data"     : {
-                "problem_name"  : "dummy_name.Provide_a_real_one",
-                "parallel_type" : "OpenMP",
-                "echo_level"    : 1,
-                "start_time"    : 0.0,
-                "end_time"      : 1
-            },
-            "_json_output_process"  : [{
-            "python_module" : "json_output_process",
-            "kratos_module" : "KratosMultiphysics",
-            "process_name"  : "JsonOutputProcess",
-            "Parameters"    : {
-                "output_variables"     : ["DISPLACEMENT_X","DISPLACEMENT_Y"],
-                "output_file_name"     : "candelier_results.json",
-                "model_part_name"      : "CandelierDEM",
-                "time_frequency"       : 1
-            }
-            }],
-            "print_output_process" : [{
-            "python_module"   : "from_json_check_result_process",
-            "kratos_module"   : "KratosMultiphysics",
-            "process_name"    : "FromJsonCheckResultProcess",
-            "Parameters"      : {
-                "check_variables"      : ["DISPLACEMENT_X","DISPLACEMENT_Y"],
-                "input_file_name"      : "candelier_errors.json",
-                "model_part_name"      : "SpheresPart",
-                "time_frequency"       : 1
-            }
-            }],
-            "DeltaOption"                      : "Absolute",
-            "SearchTolerance"                  : 0.0,
-            "search_tolerance_against_walls"   : 0.0,
-            "CoordinationNumber"               : 10,
-            "LocalCoordinationNumberOption"    : false,
-            "GlobalCoordinationNumberOption"   : true,
-            "respect_preprocessor_marked_skin" : true,
-            "AutomaticSkinComputation" : false,
-            "SkinFactorRadius" : 1.0,
-            "AmplifiedSearchRadiusExtension"   : 0.0,
-            "MaxAmplificationRatioOfSearchRadius" : 10,
-            "YCoordinateOfCylinderBottomBase"     : 0.0,
-            "ZCoordinateOfCylinderBottomBase"     : 0.0,
-            "ModelDataInfo"                    : false,
-            "VirtualMassCoefficient"           : 1.0,
-            "RollingFrictionOption"            : false,
-            "ComputeStressTensorOption"        : false,
-            "ImposeZStrainIn2DOption"          : false,
-            "ZStrainValue"                     : "0.0*t",
-            "ImposeZStrainIn2DWithControlModule" : false,
-            "GlobalDamping"                    : 0.0,
-            "GlobalViscousDamping"             : 0.0,
-            "PoissonEffectOption"              : true,
-            "ShearStrainParallelToBondOption"  : true,
-            "DontSearchUntilFailure"           : false,
-            "ContactMeshOption"                : false,
-            "MaxNumberOfIntactBondsToConsiderASphereBroken" : 0,
-            "OutputFileType"                   : "Binary",
-            "Multifile"                        : "multiple_files",
-            "ElementType"                      : "SphericPartDEMElement3D",
-            "TranslationalIntegrationScheme"   : "Symplectic_Euler",
-            "RotationalIntegrationScheme"      : "Direct_Integration",
-            "AutomaticTimestep"                : false,
-            "DeltaTimeSafetyFactor"            : 1.0,
-            "MaxTimeStep"                      : 5e-5,
-            "FinalTime"                        : 0.05,
-            "ControlTime"                      : 4.0,
-            "NeighbourSearchFrequency"         : 50,
-            "virtual_sea_surface_settings"     : {
-                "print_sea_surface"            : false,
-                "PostVirtualSeaSurfaceX1"      : 0.0,
-                "PostVirtualSeaSurfaceY1"      : 0.0,
-                "PostVirtualSeaSurfaceX2"      : 0.0,
-                "PostVirtualSeaSurfaceY2"      : 0.0,
-                "PostVirtualSeaSurfaceX3"      : 0.0,
-                "PostVirtualSeaSurfaceY3"      : 0.0,
-                "PostVirtualSeaSurfaceX4"      : 0.0,
-                "PostVirtualSeaSurfaceY4"      : 0.0
-            },
-            "output_processes"                 : {},
-            "material_test_settings" : {
-                "TestType"                         : "None",
-                "ConfinementPressure"              : 0.0,
-                "LoadingVelocity"                  : -0.10,
-                "SpecimenLength"                   : 0.3,
-                "SpecimenDiameter"                 : 0.15,
-                "YCoordinateOfCylinderBottomBase"  : 0.0,
-                "ZCoordinateOfCylinderBottomBase"  : 0.0
-            },
-            "GraphExportFreq"                  : 1e-3,
-            "VelTrapGraphExportFreq"           : 1e-3,
-            "OutputTimeStep"                   : 1e-2,
-            "PostBoundingBox"                  : false,
-            "PostDisplacement"                 : false,
-            "PostVelocity"                     : true,
-            "PostTotalForces"                  : false,
-            "PostRigidElementForces"           : false,
-            "PostSkinSphere"                   : false,
-            "PostGluedSphere"                  : false,
-            "PostPoissonRatio"                 : false,
-            "PostRadius"                       : false,
-            "PostAngularVelocity"              : false,
-            "PostParticleMoment"               : false,
-            "PostEulerAngles"                  : false,
-            "PostRollingResistanceMoment"      : false,
-            "PostCharacteristicLength"         : false,
-            "PostElasticForces"                : false,
-            "PostContactForces"                : false,
-            "PostTangentialElasticForces"      : false,
-            "PostShearStress"                  : false,
-            "PostReactions"                    : false,
-            "PostPressure"                     : false,
-            "PostNonDimensionalVolumeWear"     : false,
-            "PostNodalArea"                    : false,
-            "PostStressStrainOption"           : false,
-            "PostContactSigma"                 : false,
-            "PostContactTau"                   : false,
-            "PostLocalContactForce"            : false,
-            "PostFailureCriterionState"        : false,
-            "PostContactFailureId"             : false,
-            "PostMeanContactArea"              : false,
-            "PostContactRadius"                : false,
-            "PostRHS"                          : false,
-            "PostDampForces"                   : false,
-            "PostAppliedForces"                : false,
-            "PostGroupId"                      : false,
-            "PostExportId"                     : false,
-            "PostNormalImpactVelocity"         : false,
-            "PostTangentialImpactVelocity"     : false,
-            "PostFaceNormalImpactVelocity"     : false,
-            "PostFaceTangentialImpactVelocity" : false,
-            "PostControlModule"                : false,
-            "PostDeltaDisplacement"            : false,
-            "print_CN_graph"                   : false,
-            "PostDamageRatio"                  : false,
-            "output_configuration" : {
-                "print_number_of_neighbours_histogram" : false
-            },
-            "post_gid_option"                  : true,
-            "post_vtk_option"                  : false,
-            "IntegrationScheme"                : "deprecated_key_since_6_december_2017",
-            "LoadingVelocityTop"               : 0.0,
-            "LoadingVelocityBot"               : 0.0,
-            "problem_name" : "dummy_name.Provide_a_real_one",
-            "processes" : {}
-        }""")
-    return default_settings
+import KratosMultiphysics
+
+def GetDefaultInputParameters():
+    default_settings = KratosMultiphysics.Parameters("""
+        {
+            "do_print_results_option"          : true,
+            "WriteMdpaFromResults"             : false,
+            "Dimension"                        : 3,
+            "PeriodicDomainOption"             : false,
+            "BoundingBoxOption"                : false,
+            "AutomaticBoundingBoxOption"       : false,
+            "BoundingBoxEnlargementFactor"     : 1.0,
+            "BoundingBoxStartTime"             : 0.0,
+            "BoundingBoxStopTime"              : 1000.0,
+            "BoundingBoxMaxX"                  : 10.0,
+            "BoundingBoxMaxY"                  : 10.0,
+            "BoundingBoxMaxZ"                  : 10.0,
+            "BoundingBoxMinX"                  : -10.0,
+            "BoundingBoxMinY"                  : -10.0,
+            "BoundingBoxMinZ"                  : -10.0,
+            "BoundingBoxMoveOption"            : false,
+            "BoundingBoxMoveVelocity"          : 0.001,
+            "dem_inlet_option"                 : true,
+            "dem_inlets_settings"              : {},
+            "seed"                             : 42,
+            "GravityX"                         : 0.0,
+            "GravityY"                         : 0.0,
+            "GravityZ"                         : -9.81,
+            "EnergyCalculationOption"          : false,
+            "PotentialEnergyReferencePointX"   : 0.0,
+            "PotentialEnergyReferencePointY"   : 0.0,
+            "PotentialEnergyReferencePointZ"   : 0.0,
+            "VelocityTrapOption"               : false,
+            "VelocityTrapMaxX"                 : 0.0,
+            "VelocityTrapMaxY"                 : 0.0,
+            "VelocityTrapMaxZ"                 : 0.0,
+            "VelocityTrapMinX"                 : 0.0,
+            "VelocityTrapMinY"                 : 0.0,
+            "VelocityTrapMinZ"                 : 0.0,
+            "RotationOption"                   : true,
+            "CleanIndentationsOption"          : false,
+            "RemoveBallsInEmbeddedOption"      : false,
+            "solver_settings" : {},
+            "creator_destructor_settings" : {},
+            "echo_level"                  : 1,
+            "problem_data"     : {
+                "problem_name"  : "dummy_name.Provide_a_real_one",
+                "parallel_type" : "OpenMP",
+                "echo_level"    : 1,
+                "start_time"    : 0.0,
+                "end_time"      : 1
+            },
+            "_json_output_process"  : [{
+            "python_module" : "json_output_process",
+            "kratos_module" : "KratosMultiphysics",
+            "process_name"  : "JsonOutputProcess",
+            "Parameters"    : {
+                "output_variables"     : ["DISPLACEMENT_X","DISPLACEMENT_Y"],
+                "output_file_name"     : "candelier_results.json",
+                "model_part_name"      : "CandelierDEM",
+                "time_frequency"       : 1
+            }
+            }],
+            "print_output_process" : [{
+            "python_module"   : "from_json_check_result_process",
+            "kratos_module"   : "KratosMultiphysics",
+            "process_name"    : "FromJsonCheckResultProcess",
+            "Parameters"      : {
+                "check_variables"      : ["DISPLACEMENT_X","DISPLACEMENT_Y"],
+                "input_file_name"      : "candelier_errors.json",
+                "model_part_name"      : "SpheresPart",
+                "time_frequency"       : 1
+            }
+            }],
+            "DeltaOption"                      : "Absolute",
+            "SearchTolerance"                  : 0.0,
+            "search_tolerance_against_walls"   : 0.0,
+            "CoordinationNumber"               : 10,
+            "LocalCoordinationNumberOption"    : false,
+            "GlobalCoordinationNumberOption"   : true,
+            "respect_preprocessor_marked_skin" : true,
+            "AutomaticSkinComputation" : false,
+            "SkinFactorRadius" : 1.0,
+            "AmplifiedSearchRadiusExtension"   : 0.0,
+            "MaxAmplificationRatioOfSearchRadius" : 10,
+            "YCoordinateOfCylinderBottomBase"     : 0.0,
+            "ZCoordinateOfCylinderBottomBase"     : 0.0,
+            "ModelDataInfo"                    : false,
+            "VirtualMassCoefficient"           : 1.0,
+            "RollingFrictionOption"            : false,
+            "ComputeStressTensorOption"        : false,
+            "ImposeZStrainIn2DOption"          : false,
+            "ZStrainValue"                     : "0.0*t",
+            "ImposeZStrainIn2DWithControlModule" : false,
+            "GlobalDamping"                    : 0.0,
+            "GlobalViscousDamping"             : 0.0,
+            "PoissonEffectOption"              : true,
+            "ShearStrainParallelToBondOption"  : true,
+            "DontSearchUntilFailure"           : false,
+            "ContactMeshOption"                : false,
+            "MaxNumberOfIntactBondsToConsiderASphereBroken" : 0,
+            "OutputFileType"                   : "Binary",
+            "Multifile"                        : "multiple_files",
+            "ElementType"                      : "SphericPartDEMElement3D",
+            "TranslationalIntegrationScheme"   : "Symplectic_Euler",
+            "RotationalIntegrationScheme"      : "Direct_Integration",
+            "AutomaticTimestep"                : false,
+            "DeltaTimeSafetyFactor"            : 1.0,
+            "MaxTimeStep"                      : 5e-5,
+            "FinalTime"                        : 0.05,
+            "ControlTime"                      : 4.0,
+            "NeighbourSearchFrequency"         : 50,
+            "virtual_sea_surface_settings"     : {
+                "print_sea_surface"            : false,
+                "PostVirtualSeaSurfaceX1"      : 0.0,
+                "PostVirtualSeaSurfaceY1"      : 0.0,
+                "PostVirtualSeaSurfaceX2"      : 0.0,
+                "PostVirtualSeaSurfaceY2"      : 0.0,
+                "PostVirtualSeaSurfaceX3"      : 0.0,
+                "PostVirtualSeaSurfaceY3"      : 0.0,
+                "PostVirtualSeaSurfaceX4"      : 0.0,
+                "PostVirtualSeaSurfaceY4"      : 0.0
+            },
+            "output_processes"                 : {},
+            "material_test_settings" : {
+                "TestType"                         : "None",
+                "ConfinementPressure"              : 0.0,
+                "LoadingVelocity"                  : -0.10,
+                "SpecimenLength"                   : 0.3,
+                "SpecimenDiameter"                 : 0.15,
+                "YCoordinateOfCylinderBottomBase"  : 0.0,
+                "ZCoordinateOfCylinderBottomBase"  : 0.0
+            },
+            "GraphExportFreq"                  : 1e-3,
+            "VelTrapGraphExportFreq"           : 1e-3,
+            "OutputTimeStep"                   : 1e-2,
+            "PostBoundingBox"                  : false,
+            "PostDisplacement"                 : false,
+            "PostVelocity"                     : true,
+            "PostTotalForces"                  : false,
+            "PostRigidElementForces"           : false,
+            "PostSkinSphere"                   : false,
+            "PostGluedSphere"                  : false,
+            "PostPoissonRatio"                 : false,
+            "PostRadius"                       : false,
+            "PostAngularVelocity"              : false,
+            "PostParticleMoment"               : false,
+            "PostEulerAngles"                  : false,
+            "PostRollingResistanceMoment"      : false,
+            "PostCharacteristicLength"         : false,
+            "PostElasticForces"                : false,
+            "PostContactForces"                : false,
+            "PostTangentialElasticForces"      : false,
+            "PostShearStress"                  : false,
+            "PostReactions"                    : false,
+            "PostPressure"                     : false,
+            "PostNonDimensionalVolumeWear"     : false,
+            "PostNodalArea"                    : false,
+            "PostStressStrainOption"           : false,
+            "PostContactSigma"                 : false,
+            "PostContactTau"                   : false,
+            "PostLocalContactForce"            : false,
+            "PostFailureCriterionState"        : false,
+            "PostContactFailureId"             : false,
+            "PostMeanContactArea"              : false,
+            "PostContactRadius"                : false,
+            "PostRHS"                          : false,
+            "PostDampForces"                   : false,
+            "PostAppliedForces"                : false,
+            "PostGroupId"                      : false,
+            "PostExportId"                     : false,
+            "PostNormalImpactVelocity"         : false,
+            "PostTangentialImpactVelocity"     : false,
+            "PostFaceNormalImpactVelocity"     : false,
+            "PostFaceTangentialImpactVelocity" : false,
+            "PostControlModule"                : false,
+            "PostDeltaDisplacement"            : false,
+            "print_CN_graph"                   : false,
+            "PostDamageRatio"                  : false,
+            "output_configuration" : {
+                "print_number_of_neighbours_histogram" : false
+            },
+            "post_gid_option"                  : true,
+            "post_vtk_option"                  : false,
+            "IntegrationScheme"                : "deprecated_key_since_6_december_2017",
+            "LoadingVelocityTop"               : 0.0,
+            "LoadingVelocityBot"               : 0.0,
+            "problem_name" : "dummy_name.Provide_a_real_one",
+            "processes" : {}
+        }""")
+    return default_settings
```

## KratosMultiphysics/DEMApplication/DEM_procedures_mpi.py

 * *Ordering differences only*

```diff
@@ -1,188 +1,188 @@
-from KratosMultiphysics import *
-from KratosMultiphysics.DEMApplication import *
-if not "DO_NOT_PARTITION_DOMAIN" in os.environ:
-    from KratosMultiphysics.MetisApplication import *
-    from KratosMultiphysics.MPISearchApplication import *
-    import KratosMultiphysics.DEMApplication.DEM_material_test_script_mpi as DEM_material_test_script
-else:
-    import KratosMultiphysics.DEMApplication.DEM_material_test_script as DEM_material_test_script
-
-from KratosMultiphysics.mpi import *
-import KratosMultiphysics.DEMApplication.DEM_procedures as DEM_procedures
-
-from glob import glob
-
-class MdpaCreator(DEM_procedures.MdpaCreator):
-
-    def __init__(self, path, DEM_parameters):
-        super().__init__(path, DEM_parameters)
-
-GranulometryUtils = DEM_procedures.GranulometryUtils
-
-class PostUtils(DEM_procedures.PostUtils):
-
-    def __init__(self, DEM_parameters, balls_model_part):
-        super().__init__(DEM_parameters, balls_model_part)
-
-
-class Procedures(DEM_procedures.Procedures):
-
-    def __init__(self, DEM_parameters):
-        super().__init__(DEM_parameters)
-
-    def Barrier(self):
-        mpi.world.barrier()
-
-    def AddMpiVariables(self, model_part):
-        model_part.AddNodalSolutionStepVariable(PARTITION_INDEX)
-        model_part.AddNodalSolutionStepVariable(PARTITION_MASK)
-
-    def CreateDirectories(self, main_path, problem_name, run_code='', do_print_results=True):
-
-        root = main_path + '/' + problem_name
-        post_path = root + '_Post_Files'
-        graphs_path = root + '_Graphs'
-
-        if mpi.rank == 0 and do_print_results:
-            for directory in [post_path, graphs_path]:
-                if not os.path.isdir(directory):
-                    os.makedirs(str(directory))
-
-        self.Barrier()
-
-        return [post_path, graphs_path]
-
-    def PreProcessModel(self, DEM_parameters):
-        Logger.PrintInfo("Creating MPIer...")
-        #MPIClassObject = MPIer.MPIerClass(str(DEM_parameters["problem_name"].GetString()) + "DEM.mdpa")
-        Logger.PrintInfo("done.")
-        self.Barrier() #TODO: maybe not necessary (debugging)
-
-    def FindMaxNodeIdInModelPart(self, model_part):
-
-        node_max = super().FindMaxNodeIdInModelPart(model_part)
-        node_max_gath = mpi.allgather_int(mpi.world,node_max)
-        total_max = reduce(lambda x,y: max(x,y), node_max_gath)
-        return total_max
-
-    def DeleteFiles(self):
-        if mpi.rank == 0:
-            files_to_delete_list = glob('*.time')
-            for to_erase_file in files_to_delete_list:
-                os.remove(to_erase_file)
-
-    def KratosPrintInfo(self, message):
-        Logger.PrintInfo(*args, label="DEM")
-        Logger.Flush()
-
-
-class DEMFEMProcedures(DEM_procedures.DEMFEMProcedures):
-    def PrintGraph(self, time):
-        if (mpi.rank == 0):
-            super().PrintGraph(time)
-
-    def FinalizeGraphs(self,rigid_face_model_part):
-        if (mpi.rank == 0):
-            super().FinalizeGraphs(rigid_face_model_part)
-
-    def FinalizeBallsGraphs(self,spheres_model_part):
-        if (mpi.rank == 0):
-            super().FinalizeBallsGraphs(spheres_model_part)
-
-
-class Report(DEM_procedures.Report):
-
-    def __init__(self):
-        super().__init__()
-
-
-class MaterialTest(DEM_procedures.MaterialTest):
-
-    def __init__(self):
-        super().__init__()
-
-    # Important: This has to be defined here as the imports from
-    # the superclase and the derived clase are different
-    def Initialize(self, DEM_parameters, procedures, solver, graphs_path, post_path, balls_model_part, rigid_face_model_part):
-        self.TestType = DEM_parameters["TestType"].GetString()
-
-        if self.TestType != "None":
-            self.script = DEM_material_test_script.MaterialTest(DEM_parameters, procedures, solver, graphs_path, post_path, balls_model_part, rigid_face_model_part)
-            self.script.Initialize()
-
-
-class MultifileList():
-
-    def __init__(self,name,step):
-        self.index = 0
-        self.step = step
-        self.name = name
-        self.which_folder = which_folder
-        if which_folder == "inner":
-            absolute_path_to_file = os.path.join(post_path, "_list_" + self.name + "_" + str(mpi.rank) + "_" + str(step) + ".post.lst")
-        else:
-            absolute_path_to_file = os.path.join(post_path, self.name + "_" + str(mpi.rank) + ".post.lst")
-        #THIS BREAKS THE AUTOMATIC OPENING OF POSTPROCESS FILES IN GID WHEN SWITCHING TO POST
-
-        self.file = open(absolute_path_to_file, "w")
-
-
-class DEMIo(DEM_procedures.DEMIo):
-
-    def __init__(self, model, DEM_parameters, post_path, all_model_parts):
-        super().__init__(model, DEM_parameters, post_path, all_model_parts)
-
-    def AddMpiVariables(self):
-        self.spheres_variables.append(PARTITION_INDEX)
-
-    def SetOutputName(self,name):
-        self.gid_io.ChangeOutputName(name + "_" + str(mpi.rank))
-
-    def GetMultiFileListName(self, name):
-        return name + "_" + str(mpi.rank)
-
-
-class ParallelUtils(DEM_procedures.ParallelUtils):
-
-    def __init__(self):
-        super().__init__()
-        self.mpi_utilities = MpiUtilities()
-
-    def Repart(self, balls_model_part):
-        self.mpi_utilities.Repart(balls_model_part, 0, 1)
-
-    def CalculateModelNewIds(self, balls_model_part):
-        self.mpi_utilities.CalculateModelNewIds(balls_model_part, 40000)
-
-    def PerformInitialPartition(self, model_part_io_spheres):
-        domain_size = 3
-
-        number_of_partitions = mpi.size
-
-        if mpi.rank == 0:
-            partitioner = MetisDivideNodalInputToPartitionsProcess(model_part_io_spheres, number_of_partitions, domain_size);
-            partitioner.Execute()
-
-        mpi.world.barrier()
-        #return model_part_io_spheres
-
-    def SetCommunicator(self, spheres_model_part, model_part_io_spheres, spheres_mp_filename):
-
-        ModelPartCommunicatorUtilities.SetMPICommunicator(spheres_model_part)
-
-        print("(" + str(mpi.rank) + "," + str(mpi.size) + ")" + "Communicator Set")
-        print("(" + str(mpi.rank) + "," + str(mpi.size) + ")" + "Reading: "+spheres_mp_filename+"_"+str(mpi.rank))
-
-        my_input_filename = spheres_mp_filename + "_" + str(mpi.rank)
-        model_part_io_spheres = ModelPartIO(my_input_filename)
-
-        return [model_part_io_spheres, spheres_model_part]
-
-    def GetSearchStrategy(self, solver, model_part):
-        return MPI_DEMSearch(model_part.GetCommunicator())
-
-class SetOfModelParts(DEM_procedures.SetOfModelParts):
-    pass
-
-class DEMEnergyCalculator(DEM_procedures.DEMEnergyCalculator):
-    pass
+from KratosMultiphysics import *
+from KratosMultiphysics.DEMApplication import *
+if not "DO_NOT_PARTITION_DOMAIN" in os.environ:
+    from KratosMultiphysics.MetisApplication import *
+    from KratosMultiphysics.MPISearchApplication import *
+    import KratosMultiphysics.DEMApplication.DEM_material_test_script_mpi as DEM_material_test_script
+else:
+    import KratosMultiphysics.DEMApplication.DEM_material_test_script as DEM_material_test_script
+
+from KratosMultiphysics.mpi import *
+import KratosMultiphysics.DEMApplication.DEM_procedures as DEM_procedures
+
+from glob import glob
+
+class MdpaCreator(DEM_procedures.MdpaCreator):
+
+    def __init__(self, path, DEM_parameters):
+        super().__init__(path, DEM_parameters)
+
+GranulometryUtils = DEM_procedures.GranulometryUtils
+
+class PostUtils(DEM_procedures.PostUtils):
+
+    def __init__(self, DEM_parameters, balls_model_part):
+        super().__init__(DEM_parameters, balls_model_part)
+
+
+class Procedures(DEM_procedures.Procedures):
+
+    def __init__(self, DEM_parameters):
+        super().__init__(DEM_parameters)
+
+    def Barrier(self):
+        mpi.world.barrier()
+
+    def AddMpiVariables(self, model_part):
+        model_part.AddNodalSolutionStepVariable(PARTITION_INDEX)
+        model_part.AddNodalSolutionStepVariable(PARTITION_MASK)
+
+    def CreateDirectories(self, main_path, problem_name, run_code='', do_print_results=True):
+
+        root = main_path + '/' + problem_name
+        post_path = root + '_Post_Files'
+        graphs_path = root + '_Graphs'
+
+        if mpi.rank == 0 and do_print_results:
+            for directory in [post_path, graphs_path]:
+                if not os.path.isdir(directory):
+                    os.makedirs(str(directory))
+
+        self.Barrier()
+
+        return [post_path, graphs_path]
+
+    def PreProcessModel(self, DEM_parameters):
+        Logger.PrintInfo("Creating MPIer...")
+        #MPIClassObject = MPIer.MPIerClass(str(DEM_parameters["problem_name"].GetString()) + "DEM.mdpa")
+        Logger.PrintInfo("done.")
+        self.Barrier() #TODO: maybe not necessary (debugging)
+
+    def FindMaxNodeIdInModelPart(self, model_part):
+
+        node_max = super().FindMaxNodeIdInModelPart(model_part)
+        node_max_gath = mpi.allgather_int(mpi.world,node_max)
+        total_max = reduce(lambda x,y: max(x,y), node_max_gath)
+        return total_max
+
+    def DeleteFiles(self):
+        if mpi.rank == 0:
+            files_to_delete_list = glob('*.time')
+            for to_erase_file in files_to_delete_list:
+                os.remove(to_erase_file)
+
+    def KratosPrintInfo(self, message):
+        Logger.PrintInfo(*args, label="DEM")
+        Logger.Flush()
+
+
+class DEMFEMProcedures(DEM_procedures.DEMFEMProcedures):
+    def PrintGraph(self, time):
+        if (mpi.rank == 0):
+            super().PrintGraph(time)
+
+    def FinalizeGraphs(self,rigid_face_model_part):
+        if (mpi.rank == 0):
+            super().FinalizeGraphs(rigid_face_model_part)
+
+    def FinalizeBallsGraphs(self,spheres_model_part):
+        if (mpi.rank == 0):
+            super().FinalizeBallsGraphs(spheres_model_part)
+
+
+class Report(DEM_procedures.Report):
+
+    def __init__(self):
+        super().__init__()
+
+
+class MaterialTest(DEM_procedures.MaterialTest):
+
+    def __init__(self):
+        super().__init__()
+
+    # Important: This has to be defined here as the imports from
+    # the superclase and the derived clase are different
+    def Initialize(self, DEM_parameters, procedures, solver, graphs_path, post_path, balls_model_part, rigid_face_model_part):
+        self.TestType = DEM_parameters["TestType"].GetString()
+
+        if self.TestType != "None":
+            self.script = DEM_material_test_script.MaterialTest(DEM_parameters, procedures, solver, graphs_path, post_path, balls_model_part, rigid_face_model_part)
+            self.script.Initialize()
+
+
+class MultifileList():
+
+    def __init__(self,name,step):
+        self.index = 0
+        self.step = step
+        self.name = name
+        self.which_folder = which_folder
+        if which_folder == "inner":
+            absolute_path_to_file = os.path.join(post_path, "_list_" + self.name + "_" + str(mpi.rank) + "_" + str(step) + ".post.lst")
+        else:
+            absolute_path_to_file = os.path.join(post_path, self.name + "_" + str(mpi.rank) + ".post.lst")
+        #THIS BREAKS THE AUTOMATIC OPENING OF POSTPROCESS FILES IN GID WHEN SWITCHING TO POST
+
+        self.file = open(absolute_path_to_file, "w")
+
+
+class DEMIo(DEM_procedures.DEMIo):
+
+    def __init__(self, model, DEM_parameters, post_path, all_model_parts):
+        super().__init__(model, DEM_parameters, post_path, all_model_parts)
+
+    def AddMpiVariables(self):
+        self.spheres_variables.append(PARTITION_INDEX)
+
+    def SetOutputName(self,name):
+        self.gid_io.ChangeOutputName(name + "_" + str(mpi.rank))
+
+    def GetMultiFileListName(self, name):
+        return name + "_" + str(mpi.rank)
+
+
+class ParallelUtils(DEM_procedures.ParallelUtils):
+
+    def __init__(self):
+        super().__init__()
+        self.mpi_utilities = MpiUtilities()
+
+    def Repart(self, balls_model_part):
+        self.mpi_utilities.Repart(balls_model_part, 0, 1)
+
+    def CalculateModelNewIds(self, balls_model_part):
+        self.mpi_utilities.CalculateModelNewIds(balls_model_part, 40000)
+
+    def PerformInitialPartition(self, model_part_io_spheres):
+        domain_size = 3
+
+        number_of_partitions = mpi.size
+
+        if mpi.rank == 0:
+            partitioner = MetisDivideNodalInputToPartitionsProcess(model_part_io_spheres, number_of_partitions, domain_size);
+            partitioner.Execute()
+
+        mpi.world.barrier()
+        #return model_part_io_spheres
+
+    def SetCommunicator(self, spheres_model_part, model_part_io_spheres, spheres_mp_filename):
+
+        ModelPartCommunicatorUtilities.SetMPICommunicator(spheres_model_part)
+
+        print("(" + str(mpi.rank) + "," + str(mpi.size) + ")" + "Communicator Set")
+        print("(" + str(mpi.rank) + "," + str(mpi.size) + ")" + "Reading: "+spheres_mp_filename+"_"+str(mpi.rank))
+
+        my_input_filename = spheres_mp_filename + "_" + str(mpi.rank)
+        model_part_io_spheres = ModelPartIO(my_input_filename)
+
+        return [model_part_io_spheres, spheres_model_part]
+
+    def GetSearchStrategy(self, solver, model_part):
+        return MPI_DEMSearch(model_part.GetCommunicator())
+
+class SetOfModelParts(DEM_procedures.SetOfModelParts):
+    pass
+
+class DEMEnergyCalculator(DEM_procedures.DEMEnergyCalculator):
+    pass
```

## KratosMultiphysics/DEMApplication/DEM_procedures_mpi_no_partitions.py

 * *Ordering differences only*

```diff
@@ -1,33 +1,33 @@
-from KratosMultiphysics import *
-from KratosMultiphysics.DEMApplication import *
-from KratosMultiphysics.mpi import *
-
-import KratosMultiphysics.DEMApplication.DEM_procedures as DEM_procedures
-import KratosMultiphysics.DEMApplication.DEM_procedures_mpi as DEM_procedures_mpi
-
-PostUtils = DEM_procedures.PostUtils
-
-class Procedures(DEM_procedures_mpi.Procedures):
-    def AddMpiVariables(self, model_part):
-        pass
-
-    def FindMaxNodeIdInModelPart(self, model_part):
-        DEM_procedures.Procedures.FindMaxNodeIdInModelPart(model_part)
-
-class MultifileList(DEM_procedures.MultifileList):
-    def __init__(self, name, step):
-        if (mpi.rank == 0):
-            DEM_procedures.MultifileList.__init__(name,step)
-
-DEMFEMProcedures = DEM_procedures_mpi.DEMFEMProcedures
-Report = DEM_procedures.Report
-MaterialTest = DEM_procedures.MaterialTest
-
-class DEMIo(DEM_procedures.DEMIo):
-    def PrintResults(self, all_model_parts, creator_destructor, dem_fem_search, time, bounding_box_time_limits):
-        if (mpi.rank == 0):
-            super().PrintResults(all_model_parts, creator_destructor, dem_fem_search, time, bounding_box_time_limits)
-
-ParallelUtils = DEM_procedures.ParallelUtils
-SetOfModelParts = DEM_procedures.SetOfModelParts
+from KratosMultiphysics import *
+from KratosMultiphysics.DEMApplication import *
+from KratosMultiphysics.mpi import *
+
+import KratosMultiphysics.DEMApplication.DEM_procedures as DEM_procedures
+import KratosMultiphysics.DEMApplication.DEM_procedures_mpi as DEM_procedures_mpi
+
+PostUtils = DEM_procedures.PostUtils
+
+class Procedures(DEM_procedures_mpi.Procedures):
+    def AddMpiVariables(self, model_part):
+        pass
+
+    def FindMaxNodeIdInModelPart(self, model_part):
+        DEM_procedures.Procedures.FindMaxNodeIdInModelPart(model_part)
+
+class MultifileList(DEM_procedures.MultifileList):
+    def __init__(self, name, step):
+        if (mpi.rank == 0):
+            DEM_procedures.MultifileList.__init__(name,step)
+
+DEMFEMProcedures = DEM_procedures_mpi.DEMFEMProcedures
+Report = DEM_procedures.Report
+MaterialTest = DEM_procedures.MaterialTest
+
+class DEMIo(DEM_procedures.DEMIo):
+    def PrintResults(self, all_model_parts, creator_destructor, dem_fem_search, time, bounding_box_time_limits):
+        if (mpi.rank == 0):
+            super().PrintResults(all_model_parts, creator_destructor, dem_fem_search, time, bounding_box_time_limits)
+
+ParallelUtils = DEM_procedures.ParallelUtils
+SetOfModelParts = DEM_procedures.SetOfModelParts
 DEMEnergyCalculator = DEM_procedures.DEMEnergyCalculator
```

## KratosMultiphysics/DEMApplication/cartesian_specimen_mdpa_creator.py

 * *Ordering differences only*

```diff
@@ -1,12 +1,12 @@
-# To use this script just type in the terminal: python (or python3) cartesian_specimen_mdpa_creator.py name_of_your_case
-# It creates a file called name_of_your_caseDEM.mdpa.
-# Remember to overwrite the Properties and the boundary conditions if necessary!!
-
-from KratosMultiphysics import *
-import KratosMultiphysics.DEMApplication as DEMapp
-import sys
-
-if len(sys.argv) < 2:
-    raise Exception("You must specify the name of the file to be printed. The string 'DEM.mdpa' will be appended to the provided string. ")
-
-DEMapp.PreUtilities().CreateCartesianSpecimenMdpa(sys.argv[1])
+# To use this script just type in the terminal: python (or python3) cartesian_specimen_mdpa_creator.py name_of_your_case
+# It creates a file called name_of_your_caseDEM.mdpa.
+# Remember to overwrite the Properties and the boundary conditions if necessary!!
+
+from KratosMultiphysics import *
+import KratosMultiphysics.DEMApplication as DEMapp
+import sys
+
+if len(sys.argv) < 2:
+    raise Exception("You must specify the name of the file to be printed. The string 'DEM.mdpa' will be appended to the provided string. ")
+
+DEMapp.PreUtilities().CreateCartesianSpecimenMdpa(sys.argv[1])
```

## KratosMultiphysics/DEMApplication/Chung_Ooi_class.py

 * *Ordering differences only*

```diff
@@ -1,849 +1,849 @@
-from KratosMultiphysics import *                                  # importing the Kratos Library
-from KratosMultiphysics.DEMApplication import *
-import shutil
-from glob import glob
-from math import pi, tan, fabs
-from os import system
-
-def initialize_time_parameters(benchmark_number):
-
-    if benchmark_number==5:
-
-        end_time                        = 0.0000005
-        dt                              = 3.3e-10  #3.6e-12 # Complies Rayleigh's condition
-        output_time_step                = 0.00000005
-        number_of_points_in_the_graphic = 17
-
-    elif benchmark_number==6:
-
-        end_time                        = 0.01
-        dt                              = 5.0e-7  #1.0e-7 # Complies Rayleigh's condition ????????????????
-        output_time_step                = 0.00025
-        number_of_points_in_the_graphic = 17
-
-    elif benchmark_number==7:
-
-        end_time                        = 0.0005
-        dt                              = 2e-7 #4.4614e-8 # Complies Rayleigh's condition ????????????????
-        output_time_step                = 0.000005
-        number_of_points_in_the_graphic = 17
-
-    elif benchmark_number==8:
-
-        end_time                        = 0.02
-        dt                              = 1.0e-6 #5.0e-7 # Complies Rayleigh's condition
-        output_time_step                = 0.0001
-        number_of_points_in_the_graphic = 17
-
-    elif benchmark_number==9:
-
-        end_time                        = 0.001 #0.0005
-        dt                              = 1e-7 #6.4e-8 # Complies Rayleigh's condition
-        output_time_step                = 0.000005
-        number_of_points_in_the_graphic = 6
-
-    else: #benchmark_number=10
-
-        end_time                        = 0.001 #0.0005
-        dt                              = 6.4e-8 # Complies Rayleigh's condition
-        output_time_step                = 0.000005
-        number_of_points_in_the_graphic = 10
-
-    return end_time, dt, output_time_step, number_of_points_in_the_graphic
-
-class Benchmark5:
-
-    def __init__(self):
-        self.initial_normal_vel = -5.0
-        self.initial_tangential_vel = 0
-        self.radius = 0.00001
-        self.Vst_div_mu_per_Vcn_list = []
-        self.Vst_prima_div_mu_per_Vcn_prima_list = []
-        self.r_w1_prima_div_mu_per_Vcn_list = []
-        self.Vst_prima_div_mu_per_Vcn_prima_list_outfile = None
-        self.r_w1_prima_div_mu_per_Vcn_list_outfile = None
-
-    def get_initial_data(self, modelpart, iteration, number_of_points_in_the_graphic):
-
-        degrees = 90 / (number_of_points_in_the_graphic + 1) * iteration
-        self.initial_tangential_vel =  -self.initial_normal_vel * tan(degrees * pi / 180.0)
-
-        for node in modelpart.Nodes:
-            node.SetSolutionStepValue(VELOCITY_Y, self.initial_tangential_vel)
-            node.SetSolutionStepValue(VELOCITY_Z, self.initial_normal_vel)
-
-    def get_final_data(self, modelpart):
-
-        mu = 0.3
-
-        for node in modelpart.Nodes:
-            final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_X)
-            final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_Y)
-            final_normal_center_velocity = node.GetSolutionStepValue(VELOCITY_Z)
-            Vst_div_mu_per_Vcn = -self.initial_tangential_vel / (mu * self.initial_normal_vel)
-            Vst_prima_div_mu_per_Vcn_prima = (final_tangential_center_velocity + final_angular_vel * self.radius) / (mu * final_normal_center_velocity)
-            r_w1_prima_div_mu_per_Vcn = -self.radius * final_angular_vel / (mu * self.initial_normal_vel)
-
-        self.Vst_div_mu_per_Vcn_list.append(Vst_div_mu_per_Vcn)
-        self.Vst_prima_div_mu_per_Vcn_prima_list.append(Vst_prima_div_mu_per_Vcn_prima)
-        self.r_w1_prima_div_mu_per_Vcn_list.append(r_w1_prima_div_mu_per_Vcn)
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0):
-
-        self.Vst_prima_div_mu_per_Vcn_prima_list_outfile_name = "benchmark5_dt_" + str(dt) + '_Vst_prima_div_mu_per_Vcn_prima_list_data.dat'
-        self.r_w1_prima_div_mu_per_Vcn_list_outfile_name = "benchmark5_dt_" + str(dt) + '_r_w1_prima_div_mu_per_Vcn_list_data.dat'
-        self.Vst_prima_div_mu_per_Vcn_prima_list_outfile = open(self.Vst_prima_div_mu_per_Vcn_prima_list_outfile_name, 'w')
-        self.r_w1_prima_div_mu_per_Vcn_list_outfile = open(self.r_w1_prima_div_mu_per_Vcn_list_outfile_name, 'w')
-
-        for i in range(0, number_of_points_in_the_graphic):
-            self.Vst_prima_div_mu_per_Vcn_prima_list_outfile.write("%14.8f %14.8f" % (self.Vst_div_mu_per_Vcn_list[i], self.Vst_prima_div_mu_per_Vcn_prima_list[i]) + '\n')
-            self.r_w1_prima_div_mu_per_Vcn_list_outfile.write("%14.8f %14.8f" % (self.Vst_div_mu_per_Vcn_list[i], self.r_w1_prima_div_mu_per_Vcn_list[i]) + '\n')
-        self.Vst_prima_div_mu_per_Vcn_prima_list_outfile.close()
-        self.r_w1_prima_div_mu_per_Vcn_list_outfile.close()
-
-        error1, error2, error3 = self.compute_errors(self.Vst_prima_div_mu_per_Vcn_prima_list_outfile_name, self.r_w1_prima_div_mu_per_Vcn_list_outfile_name)
-
-        error_filename = 'errors.txt'
-        error_file = open(error_filename, 'a')
-        error_file.write("Test 5:")
-
-        if (error1 < 10.0 and error2 < 10.0 and error3 < 10.0):
-            error_file.write(" OK!........ Test 5 SUCCESSFUL\n")
-        else:
-            error_file.write(" KO!........ Test 5 FAILED\n")
-        error_file.close()
-
-    def create_gnuplot_scripts(self, Vst_prima_div_mu_per_Vcn_prima_list_outfile_name, r_w1_prima_div_mu_per_Vcn_list_outfile_name, dt):
-
-        gnuplot_script_name_1 = 'benchmark5_comparison_1_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:14][-4:6] '" + Vst_prima_div_mu_per_Vcn_prima_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark5_graph1.dat' index 0 w lp ls 1 t 'Steel',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark5_graph1.dat' index 1 w lp ls 2 t 'Polyethylene',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark5_graph1.dat' index 2 w p pt 7 ps 2 lt -1 t 'FEM'\n")
-        self.gnuplot_outfile.close()
-
-        gnuplot_script_name_2 = 'benchmark5_comparison_2_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:20][-6:0] '" + r_w1_prima_div_mu_per_Vcn_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark5_graph2.dat' index 0 w lp ls 1 t 'Steel',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark5_graph2.dat' index 1 w lp ls 2 t 'Polyethylene',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark5_graph2.dat' index 2 w p pt 7 ps 2 lt -1 t 'FEM'\n")
-        self.gnuplot_outfile.close()
-
-        print_gnuplot_files_on_screen(gnuplot_script_name_1)
-        print_gnuplot_files_on_screen(gnuplot_script_name_2)
-
-    def compute_errors(self, Vst_prima_div_mu_per_Vcn_prima_list_outfile_name, r_w1_prima_div_mu_per_Vcn_list_outfile_name):
-
-        lines_Chung = list(range(49, 53)); lines_DEM = list(range(11, 15)) # Sliding regime for the time being
-        #lines_Chung = list(range(38, 53)); lines_DEM = list(range(0, 15)) # Whole diagram
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark5_graph1.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split(',')
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(Vst_prima_div_mu_per_Vcn_prima_list_outfile_name) as inf:
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_Vst_prima_div_mu_per_Vcn_prima_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-        for i, j in zip(DEM_data, Chung_data):
-            final_Vst_prima_div_mu_per_Vcn_prima_error+=fabs(i-j)
-
-        final_Vst_prima_div_mu_per_Vcn_prima_error/=summation_of_Chung_data
-
-        Logger.PrintInfo("Error in final Vst prima div mu per Vcn prima =", 100*final_Vst_prima_div_mu_per_Vcn_prima_error,"%")
-
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark5_graph2.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split(',')
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(r_w1_prima_div_mu_per_Vcn_list_outfile_name) as inf:
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_r_w1_prima_div_mu_per_Vcn_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-        for i, j in zip(DEM_data, Chung_data):
-            final_r_w1_prima_div_mu_per_Vcn_error+=fabs(i-j)
-
-        final_r_w1_prima_div_mu_per_Vcn_error/=summation_of_Chung_data
-        Logger.PrintInfo("Error in final r w1 prima div mu per Vcn =", 100*final_r_w1_prima_div_mu_per_Vcn_error,"%")
-
-        error1 = 100*final_Vst_prima_div_mu_per_Vcn_prima_error
-        error2 = 100*final_r_w1_prima_div_mu_per_Vcn_error
-        error3 = 0
-
-        return error1, error2, error3
-
-class Benchmark6:
-
-    def __init__(self):
-        self.initial_normal_vel = -0.2
-        self.initial_tangential_vel = 0
-        self.radius = 0.1
-        self.special_quantity_list = []
-        self.beta_list = []
-        self.Vst_div_Vcn_list = []
-        self.Vst_prima_div_Vcn_prima_list = []
-        self.beta_list_outfile = None
-        self.Vst_prima_div_Vcn_prima_list_outfile = None
-
-    def get_initial_data(self, modelpart, iteration, number_of_points_in_the_graphic):
-
-        degrees = 90 / (number_of_points_in_the_graphic + 1) * iteration
-        self.initial_tangential_vel = -self.initial_normal_vel * tan(degrees * pi / 180.0) # Here is tangential of the contact point, only. In X axis
-        initial_angular_vel = -self.initial_tangential_vel / self.radius # In Y axis
-
-        for node in modelpart.Nodes:
-            node.SetSolutionStepValue(VELOCITY_Z, self.initial_normal_vel)
-            node.SetSolutionStepValue(ANGULAR_VELOCITY_Y, initial_angular_vel)
-
-    def get_final_data(self, modelpart):
-
-        mu = 0.4
-        restitution_coeff = 0.5
-
-        for node in modelpart.Nodes:
-            special_quantity = -3.5 * mu * (1.0 + restitution_coeff) * self.initial_normal_vel / self.initial_tangential_vel
-            final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)
-            final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_X)
-            final_normal_center_velocity = node.GetSolutionStepValue(VELOCITY_Z)
-            beta = -(final_tangential_center_velocity - final_angular_vel * self.radius)/ self.initial_tangential_vel
-            Vst_div_Vcn = -self.initial_tangential_vel / self.initial_normal_vel
-            Vst_prima_div_Vcn_prima = (final_tangential_center_velocity - final_angular_vel * self.radius) / final_normal_center_velocity
-
-        self.special_quantity_list.append(special_quantity)
-        self.beta_list.append(beta)
-        self.Vst_div_Vcn_list.append(Vst_div_Vcn)
-        self.Vst_prima_div_Vcn_prima_list.append(Vst_prima_div_Vcn_prima)
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0):
-
-        self.beta_list_outfile_name = "benchmark6_dt_" + str(dt) + '_beta_list_data.dat'
-        self.Vst_prima_div_Vcn_prima_list_outfile_name = "benchmark6_dt_" + str(dt) + '_Vst_prima_div_Vcn_prima_data.dat'
-        self.beta_list_outfile = open(self.beta_list_outfile_name, 'w')
-        self.Vst_prima_div_Vcn_prima_list_outfile = open(self.Vst_prima_div_Vcn_prima_list_outfile_name, 'w')
-
-        for i in range(0, number_of_points_in_the_graphic):
-            self.beta_list_outfile.write("%14.8f %14.8f" % (self.special_quantity_list[i], self.beta_list[i]) + '\n')
-            self.Vst_prima_div_Vcn_prima_list_outfile.write("%14.8f %14.8f" % (self.Vst_div_Vcn_list[i], self.Vst_prima_div_Vcn_prima_list[i]) + '\n')
-        self.beta_list_outfile.close()
-        self.Vst_prima_div_Vcn_prima_list_outfile.close()
-
-        error1, error2, error3 = self.compute_errors(self.beta_list_outfile_name, self.Vst_prima_div_Vcn_prima_list_outfile_name)
-
-        error_filename = 'errors.txt'
-        error_file = open(error_filename, 'a')
-        error_file.write("Test 6:")
-
-        if (error1 < 10.0 and error2 < 10.0 and error3 < 10.0):
-            error_file.write(" OK!........ Test 6 SUCCESSFUL\n")
-        else:
-            error_file.write(" KO!........ Test 6 FAILED\n")
-        error_file.close()
-
-    def create_gnuplot_scripts(self, beta_list_outfile_name, Vst_prima_div_Vcn_prima_list_outfile_name, dt):
-
-        gnuplot_script_name_1 = 'benchmark6_comparison_1_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:25][-1:.6] '" + beta_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark6_graph1.dat' index 0 w lp ls 1 t 'Al. alloy',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark6_graph1.dat' index 1 w lp ls 2 t 'Nylon'\n")
-        self.gnuplot_outfile.close()
-
-        gnuplot_script_name_2 = 'benchmark6_comparison_2_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Tangent of incident angle'\nset ylabel 'Tangent of recoil angle'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:7][-2:8] '" + Vst_prima_div_Vcn_prima_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark6_graph2.dat' index 0 w lp ls 1 t 'Al. alloy',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark6_graph2.dat' index 1 w lp ls 2 t 'Nylon'\n")
-        self.gnuplot_outfile.close()
-
-        print_gnuplot_files_on_screen(gnuplot_script_name_1)
-        print_gnuplot_files_on_screen(gnuplot_script_name_2)
-
-    def compute_errors(self, beta_list_outfile_name, Vst_prima_div_Vcn_prima_list_outfile_name):
-
-        lines_Chung = list(range(1, 7)); lines_DEM = list(range(16, 10, -1)) # Sliding regime for the time being
-        #lines_Chung = list(range(1, 17)); lines_DEM = list(range(0, 16)) # Whole diagram
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark6_graph1.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split(',')
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-
-        with open(beta_list_outfile_name) as inf:
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_beta_list_outfile_name_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-        DEM_data.reverse()
-        for i, j in zip(DEM_data, Chung_data):
-            final_beta_list_outfile_name_error+=fabs(i-j)
-
-        final_beta_list_outfile_name_error/=summation_of_Chung_data
-        Logger.PrintInfo("Error in final beta =", 100*final_beta_list_outfile_name_error,"%")
-
-        lines_Chung = list(range(13, 17)); lines_DEM = list(range(12, 16)) # Sliding regime for the time being
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark6_graph2.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split(',')
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(Vst_prima_div_Vcn_prima_list_outfile_name) as inf:
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_Vst_prima_div_Vcn_prima_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-
-        for i, j in zip(DEM_data, Chung_data):
-            final_Vst_prima_div_Vcn_prima_error+=fabs(i-j)
-
-        final_Vst_prima_div_Vcn_prima_error/=summation_of_Chung_data
-        Logger.PrintInfo("Error in final Vst prima div Vcn =", 100*final_Vst_prima_div_Vcn_prima_error,"%")
-
-        error1 = 100*final_beta_list_outfile_name_error
-        error2 = 100*final_Vst_prima_div_Vcn_prima_error
-        error3 = 0
-
-        return error1, error2, error3
-
-class Benchmark7:
-
-    def __init__(self):
-        self.initial_angular_vel = 0
-        self.final_tangential_center_vel_list_outfile = None
-        self.final_angular_vel_list_outfile = None
-        self.initial_angular_vel_list = []
-        self.final_tangential_center_vel_list = []
-        self.final_angular_vel_list = []
-
-    def get_initial_data(self, modelpart, iteration, number_of_points_in_the_graphic):
-
-        initial_normal_vel = 0.2
-        radius = 0.1
-        degrees = 90 / (number_of_points_in_the_graphic + 1) * iteration
-        self.initial_angular_vel =  initial_normal_vel / radius * tan(degrees * pi / 180.0) # Here is tangential of the contact point, only
-
-        for node in modelpart.Nodes:
-            if node.Id == 1:
-                node.SetSolutionStepValue(VELOCITY_X,  initial_normal_vel)
-                node.SetSolutionStepValue(ANGULAR_VELOCITY_Y,  self.initial_angular_vel)
-            else:
-                node.SetSolutionStepValue(VELOCITY_X, -initial_normal_vel)
-                node.SetSolutionStepValue(ANGULAR_VELOCITY_Y, -self.initial_angular_vel)
-
-    def get_final_data(self, modelpart):
-
-        mu = 0.4
-
-        for node in modelpart.Nodes:
-            if node.Id == 1:
-                final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_Z)
-                final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)
-
-        self.initial_angular_vel_list.append(self.initial_angular_vel)
-        self.final_tangential_center_vel_list.append(final_tangential_center_velocity)
-        self.final_angular_vel_list.append(final_angular_vel)
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0):
-
-        self.final_tangential_center_vel_list_outfile_name = "benchmark7_dt_" + str(dt) + '_final_tangential_center_vel_list_data.dat'
-        self.final_angular_vel_list_outfile_name = "benchmark7_dt_" + str(dt) + '_final_angular_vel_list_data.dat'
-        self.final_tangential_center_vel_list_outfile = open(self.final_tangential_center_vel_list_outfile_name, 'w')
-        self.final_angular_vel_list_outfile = open(self.final_angular_vel_list_outfile_name, 'w')
-
-        for i in range(0, number_of_points_in_the_graphic):
-            self.final_tangential_center_vel_list_outfile.write("%14.8f %14.8f" % (self.initial_angular_vel_list[i], self.final_tangential_center_vel_list[i]) + '\n')
-            self.final_angular_vel_list_outfile.write("%14.8f %14.8f" % (self.initial_angular_vel_list[i], self.final_angular_vel_list[i]) + '\n')
-        self.final_tangential_center_vel_list_outfile.close()
-        self.final_angular_vel_list_outfile.close()
-
-        gnuplot_script_name = 'benchmark7_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name, 'w')
-        self.gnuplot_outfile.write("set multiplot layout 2, 1; set grid; set bmargin 0; set format x \"\"; set ytics -5, 5; set key bottom;\
-                                    plot [0:25][-10:10] '" + self.final_tangential_center_vel_list_outfile_name + "' w lp lw 1.5 ps 2 pt 4;\
-                                    set bmargin; set tmargin 0; set format x \"%g\"; set ytics 0, 5, 20; set key top;\
-                                    plot [0:25][0:25] '" + self.final_angular_vel_list_outfile_name + "' w lp lw 1.5 lt 3 ps 2 pt 6; unset multiplot")
-        self.gnuplot_outfile.close()
-
-        error1, error2, error3 = self.compute_errors(self.final_tangential_center_vel_list_outfile_name, self.final_angular_vel_list_outfile_name)
-
-        error_filename = 'errors.txt'
-        error_file = open(error_filename, 'a')
-        error_file.write("Test 7:")
-
-        if (error1 < 10.0 and error2 < 10.0 and error3 < 10.0):
-            error_file.write(" OK!........ Test 7 SUCCESSFUL\n")
-        else:
-            error_file.write(" KO!........ Test 7 FAILED\n")
-        error_file.close()
-
-    def create_gnuplot_scripts(self, final_tangential_center_vel_list_outfile_name, final_angular_vel_list_outfile_name, dt):
-
-        gnuplot_script_name_1 = 'benchmark7_comparison_1_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:25][-10:10] '" + final_tangential_center_vel_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark7_graph1.dat' w lp ls 1 t 'Al. alloy',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark7_graph1.dat' w lp ls 2 t 'Copper'\n")
-        self.gnuplot_outfile.close()
-
-        gnuplot_script_name_2 = 'benchmark7_comparison_2_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Initial angular velocity (rad/s)'\nset ylabel 'Final angular velocity (rad/s)'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:25][0:25] '" + final_angular_vel_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark7_graph2.dat' w lp ls 1 t 'Al. alloy',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark7_graph2.dat' w lp ls 2 t 'Copper'\n")
-        self.gnuplot_outfile.close()
-
-        print_gnuplot_files_on_screen(gnuplot_script_name_1)
-        print_gnuplot_files_on_screen(gnuplot_script_name_2)
-
-    def compute_errors(self, final_tangential_center_vel_list_outfile_name, final_angular_vel_list_outfile_name):
-
-        lines_Chung = []; lines_DEM = []; lines_Chung = list(range(0, 17)); lines_DEM = list(range(0, 17))
-        Chung_data = []; DEM_data = []
-        i = 0
-        with open('paper_data/benchmark7_graph1.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split()
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(final_tangential_center_vel_list_outfile_name) as inf:
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_tangential_center_vel_error = 0
-
-        for i, j in zip(DEM_data, Chung_data):
-            final_tangential_center_vel_error+=fabs(i-j)
-        Logger.PrintInfo("Error in final tangential center vel =", final_tangential_center_vel_error)
-
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark7_graph2.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split()
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(final_angular_vel_list_outfile_name) as inf:
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_angular_vel_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-        for i, j in zip(DEM_data, Chung_data):
-            final_angular_vel_error+=fabs(i-j)
-
-        final_angular_vel_error/=summation_of_Chung_data
-        Logger.PrintInfo("Error in final angular vel =", 100*final_angular_vel_error,"%")
-
-        error1 = 100*final_tangential_center_vel_error
-        error2 = 100*final_angular_vel_error
-        error3 = 0
-
-        return error1, error2, error3
-
-class Benchmark8:
-
-    def __init__(self):
-        self.initial_normal_vel = 0.2
-        self.initial_tangential_vel = 0
-        self.radius = 0.1
-        self.special_quantity_list = []
-        self.beta_list = []
-        self.Vst_div_Vcn_list = []
-        self.Vst_prima_div_Vcn_prima_list = []
-        self.beta_list_outfile = None
-        self.Vst_prima_div_Vcn_prima_list_outfile = None
-
-    def get_initial_data(self, modelpart, iteration, number_of_points_in_the_graphic):
-
-        degrees = 90 - 90 / (number_of_points_in_the_graphic + 1) * iteration
-        self.initial_tangential_vel =  self.initial_normal_vel * tan(degrees * pi / 180.0) # Here is tangential of the contact point, only
-        initial_angular_vel    =  -self.initial_tangential_vel / self.radius
-
-        for node in modelpart.Nodes:
-            if node.Id == 1:
-                node.SetSolutionStepValue(VELOCITY_X, self.initial_normal_vel)
-                node.SetSolutionStepValue(ANGULAR_VELOCITY_Y, initial_angular_vel)
-
-    def get_final_data(self, modelpart):
-
-        mu = 0.4
-        restitution_coeff = 0.5
-
-        for node in modelpart.Nodes:
-            if node.Id == 1:
-                special_quantity = 3.5 * mu * (1.0 + restitution_coeff) * self.initial_normal_vel / self.initial_tangential_vel
-                final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)
-                final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_Z)
-                final_normal_center_velocity = node.GetSolutionStepValue(VELOCITY_X)
-                beta = -(final_tangential_center_velocity - final_angular_vel * self.radius)/ self.initial_tangential_vel
-                Vst_div_Vcn = self.initial_tangential_vel / self.initial_normal_vel
-                Vst_prima_div_Vcn_prima = -(final_tangential_center_velocity - final_angular_vel * self.radius) / final_normal_center_velocity
-
-        self.special_quantity_list.append(special_quantity)
-        self.beta_list.append(beta)
-        self.Vst_div_Vcn_list.append(Vst_div_Vcn)
-        self.Vst_prima_div_Vcn_prima_list.append(Vst_prima_div_Vcn_prima)
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0):
-
-        self.beta_list_outfile_name = 'benchmark8_dt_' + str(dt) + 's_beta_list_data.dat'
-        self.Vst_prima_div_Vcn_prima_list_outfile_name = 'benchmark8_dt_' + str(dt) + 's_Vst_prima_div_Vcn_prima_list_data.dat'
-        self.beta_list_outfile = open(self.beta_list_outfile_name, 'w')
-        self.Vst_prima_div_Vcn_prima_list_outfile = open(self.Vst_prima_div_Vcn_prima_list_outfile_name, 'w')
-
-        for i in range(0, number_of_points_in_the_graphic):
-            self.beta_list_outfile.write("%14.8f %14.8f" % (self.special_quantity_list[i], self.beta_list[i]) + '\n')
-            self.Vst_prima_div_Vcn_prima_list_outfile.write("%14.8f %14.8f" % (self.Vst_div_Vcn_list[i], self.Vst_prima_div_Vcn_prima_list[i]) + '\n')
-
-        self.beta_list_outfile.close()
-        self.Vst_prima_div_Vcn_prima_list_outfile.close()
-
-        error1, error2, error3 = self.compute_errors(self.beta_list_outfile_name, self.Vst_prima_div_Vcn_prima_list_outfile_name)
-
-        error_filename = 'errors.txt'
-        error_file = open(error_filename, 'a')
-        error_file.write("Test 8:")
-
-        if (error1 < 10.0 and error2 < 10.0 and error3 < 10.0):
-            error_file.write(" OK!........ Test 8 SUCCESSFUL\n")
-        else:
-            error_file.write(" KO!........ Test 8 FAILED\n")
-        error_file.close()
-
-    def create_gnuplot_scripts(self, beta_list_outfile_name, Vst_prima_div_Vcn_prima_list_outfile_name, dt):
-
-        gnuplot_script_name_1 = 'benchmark8_comparison_1_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:25][-1:.6] '" + beta_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark8_graph1.dat' index 0 w lp ls 1 t 'Al. alloy',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark8_graph1.dat' index 1 w lp ls 2 t 'Nylon'\n")
-        self.gnuplot_outfile.close()
-
-        gnuplot_script_name_2 = 'benchmark8_comparison_2_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Tangent of incident angle'\nset ylabel 'Tangent of recoil angle'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:8][-2:8] '" + Vst_prima_div_Vcn_prima_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark8_graph2.dat' index 0 w lp ls 1 t 'Al. alloy',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark8_graph2.dat' index 1 w lp ls 2 t 'Nylon'\n")
-        self.gnuplot_outfile.close()
-
-        print_gnuplot_files_on_screen(gnuplot_script_name_1)
-        print_gnuplot_files_on_screen(gnuplot_script_name_2)
-
-    def compute_errors(self, beta_list_outfile_name, Vst_prima_div_Vcn_prima_list_outfile_name):
-
-        lines_Chung = []; lines_DEM = []; lines_Chung = list(range(1, 7)); lines_DEM = list(range(0, 6)) # Sliding regime for the time being
-        #lines_Chung = []; lines_DEM = []; lines_Chung = list(range(1, 18)); lines_DEM = list(range(0, 17)) # Whole diagram
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark8_graph1.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split(',')
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(beta_list_outfile_name) as inf:
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_beta_list_outfile_name_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-        for i, j in zip(DEM_data, Chung_data):
-            final_beta_list_outfile_name_error+=fabs(i-j)
-
-        final_beta_list_outfile_name_error/=summation_of_Chung_data
-        Logger.PrintInfo("Error in final beta =", 100*final_beta_list_outfile_name_error,"%")
-
-        lines_Chung = []; lines_DEM = []; lines_DEM = list(range(4, 0, -1)); lines_Chung = list(range(13, 17)) # Sliding regime for the time being
-        #lines_Chung = list(range(1, 17)); lines_DEM = list(range(0, 16)) # Whole diagram
-
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark8_graph2.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split(',')
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(Vst_prima_div_Vcn_prima_list_outfile_name) as inf:
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_Vst_prima_div_Vcn_prima_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-        DEM_data.reverse()
-        for i, j in zip(DEM_data, Chung_data):
-            final_Vst_prima_div_Vcn_prima_error+=fabs(i-j)
-
-        final_Vst_prima_div_Vcn_prima_error/=summation_of_Chung_data
-        Logger.PrintInfo("Error in final Vst prima div Vcn =", 100*final_Vst_prima_div_Vcn_prima_error,"%")
-
-        error1 = 100*final_beta_list_outfile_name_error
-        error2 = 100*final_Vst_prima_div_Vcn_prima_error
-        error3 = 0
-
-        return error1, error2, error3
-
-class Benchmark9:
-
-    def __init__(self):
-        self.initial_normal_vel = 200.0
-        self.restitution_numbers_list = []
-        self.restitution_numbers_vector_list_outfile = None
-
-    def get_initial_data(self, modelpart, iteration, number_of_points_in_the_graphic):
-
-        if number_of_points_in_the_graphic == 1:
-            number = 0
-        else:
-            number = 1.0/(number_of_points_in_the_graphic-1) * (iteration - 1)
-
-        for node in modelpart.Nodes:
-
-            if node.Id == 1:
-                node.SetSolutionStepValue(VELOCITY_X,  self.initial_normal_vel)
-                node.SetSolutionStepValue(VELOCITY_Z,  self.initial_normal_vel)
-                modelpart.GetProperties()[1][COEFFICIENT_OF_RESTITUTION] = number
-            else:
-                node.SetSolutionStepValue(VELOCITY_X, -self.initial_normal_vel)
-                node.SetSolutionStepValue(VELOCITY_Z,  self.initial_normal_vel)
-                modelpart.GetProperties()[1][COEFFICIENT_OF_RESTITUTION] = number
-
-    def get_final_data(self, modelpart):
-
-        for node in modelpart.Nodes:
-            if node.Id == 1:
-                final_vel = node.GetSolutionStepValue(VELOCITY_X)
-
-        restitution_coefficient = -final_vel / self.initial_normal_vel
-        self.restitution_numbers_list.append(restitution_coefficient)
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0):
-
-        self.restitution_numbers_vector_list_outfile_name = "benchmark9_dt_" + str(dt) + '_restitution_numbers_vector_list_data.dat'
-        self.restitution_numbers_vector_list_outfile = open(self.restitution_numbers_vector_list_outfile_name, 'w')
-
-        for i in range(0, number_of_points_in_the_graphic):
-            if number_of_points_in_the_graphic == 1:
-                first_col = 0
-            else:
-                first_col = 1/(number_of_points_in_the_graphic-1) * i
-            self.restitution_numbers_vector_list_outfile.write("%6.4f %6.4f %11.8f" % (first_col, first_col, self.restitution_numbers_list[i]) + '\n')
-        self.restitution_numbers_vector_list_outfile.close()
-
-        gnuplot_script_name = 'benchmark9_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name, 'w')
-        self.gnuplot_outfile.write("set grid; plot '" + self.restitution_numbers_vector_list_outfile_name + "' u 1:2 w lp lt 3 lw 1.5 ps 2 pt 4, '"\
-                                                      + self.restitution_numbers_vector_list_outfile_name + "' u 1:3 w lp lt 2 lw 1.5 ps 2 pt 6")
-        self.gnuplot_outfile.close()
-
-        error1, error2, error3 = self.compute_errors(self.restitution_numbers_vector_list_outfile_name)
-
-        error_filename = 'errors.txt'
-        error_file = open(error_filename, 'a')
-        error_file.write("Test 9:")
-
-        if (error1 < 10.0 and error2 < 10.0 and error3 < 10.0):
-            error_file.write(" OK!........ Test 9 SUCCESSFUL\n")
-        else:
-            error_file.write(" KO!........ Test 9 FAILED\n")
-        error_file.close()
-
-    def create_gnuplot_scripts(self, restitution_numbers_vector_list_outfile_name, dt):
-
-        gnuplot_script_name_1 = 'benchmark9_comparison_1_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Coefficient of restitution'\nset ylabel 'Damping ratio'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt  3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:1][0:1] '" + restitution_numbers_vector_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark9_graph1.dat' w lp ls 1 t 'Al. oxide',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark9_graph1.dat' w lp ls 2 t 'Cast iron'\n")
-        self.gnuplot_outfile.close()
-
-        print_gnuplot_files_on_screen(gnuplot_script_name_1)
-
-    def compute_errors(self, restitution_numbers_vector_list_outfile_name):
-
-        lines_Chung = lines_DEM = list(range(0, 6));
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark9_graph1.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split()
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(restitution_numbers_vector_list_outfile_name) as inf:
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_restitution_numbers_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-        for i, j in zip(DEM_data, Chung_data):
-            final_restitution_numbers_error+=fabs(i-j)
-        final_restitution_numbers_error/=summation_of_Chung_data
-
-        Logger.PrintInfo("Error in restitution numbers =", 100*final_restitution_numbers_error,"%")
-
-        error1 = 100*final_restitution_numbers_error
-
-        error2 = error3 = 0
-
-        return error1, error2, error3
-
-class Benchmark10:
-
-    def __init__(self):
-        self.initial_normal_vel = 10.0
-        self.restitution_numbers_list = []
-        self.restitution_numbers_vector_list_outfile = None
-
-    def get_initial_data(self, modelpart, iteration, number_of_points_in_the_graphic):
-
-        if number_of_points_in_the_graphic == 1:
-            coefficient_of_restitution = 0
-        else:
-            coefficient_of_restitution = 1.0/(number_of_points_in_the_graphic-1) * (iteration - 1)
-
-        for node in modelpart.Nodes:
-
-            if node.Id == 1:
-                node.SetSolutionStepValue(VELOCITY_X,  self.initial_normal_vel)
-                node.SetSolutionStepValue(VELOCITY_Z,  self.initial_normal_vel)
-                modelpart.GetProperties()[1][COEFFICIENT_OF_RESTITUTION] = coefficient_of_restitution
-            else:
-                node.SetSolutionStepValue(VELOCITY_X, -1.2 * self.initial_normal_vel)
-                node.SetSolutionStepValue(VELOCITY_Z,  1.6 * self.initial_normal_vel)
-                modelpart.GetProperties()[1][COEFFICIENT_OF_RESTITUTION] = coefficient_of_restitution
-
-    def get_final_data(self, modelpart):
-
-        for node in modelpart.Nodes:
-            if node.Id == 1:
-                final_vel = node.GetSolutionStepValue(VELOCITY_X)
-
-        restitution_coefficient = -final_vel / self.initial_normal_vel
-        self.restitution_numbers_list.append(restitution_coefficient)
-
-    def print_results(self, number_of_points_in_the_graphic, dt):
-
-        self.restitution_numbers_vector_list_outfile = open("benchmark10_dt_" + str(dt) + '_restitution_numbers_vector_list_data.dat', 'w')
-
-        for i in range(0, number_of_points_in_the_graphic):
-            if number_of_points_in_the_graphic == 1:
-                first_col = 0
-            else:
-                first_col = 1/(number_of_points_in_the_graphic-1) * i
-            self.restitution_numbers_vector_list_outfile.write("%6.4f %6.4f %11.8f" % (first_col, first_col, self.restitution_numbers_list[i]) + '\n')
-        self.restitution_numbers_vector_list_outfile.close()
-
-def delete_archives(nodeplotter):
-
-    #.......................Removing extra files
-    files_to_delete_list = glob('*.time')
-    for to_erase_file in files_to_delete_list:
-        os.remove(to_erase_file)
-
-    #............Getting rid of unuseful folders
-    folders_to_delete_list      = glob('*Data')
-    folders_to_delete_list.extend(glob('*ists'))
-    folders_to_delete_list.extend(glob('*ults'))
-    folders_to_delete_list.extend(glob('*he__'))
-    folders_to_delete_list.extend(glob('*aphs'))
-
-    for to_erase_folder in folders_to_delete_list:
-        shutil.rmtree(to_erase_folder)
-
-def print_gnuplot_files_on_screen(gnuplot_script_name):
-    system('gnuplot -persist ' + gnuplot_script_name)
-
-def create_pdf_document(pdf_script_name):
-    system('gnuplot -persist ' + pdf_script_name)
-
-def ComputeRelativeError(a, b):
-    sum_a = 0.0
-    diff_sum = 0.0
-    for a_comp, b_comp in zip(a, b):
-        diff_sum += abs(a_comp - b_comp)
-        sum_a += abs(a_comp)
-    relative_error = diff_sum / sum_a
-    return relative_error
+from KratosMultiphysics import *                                  # importing the Kratos Library
+from KratosMultiphysics.DEMApplication import *
+import shutil
+from glob import glob
+from math import pi, tan, fabs
+from os import system
+
+def initialize_time_parameters(benchmark_number):
+
+    if benchmark_number==5:
+
+        end_time                        = 0.0000005
+        dt                              = 3.3e-10  #3.6e-12 # Complies Rayleigh's condition
+        output_time_step                = 0.00000005
+        number_of_points_in_the_graphic = 17
+
+    elif benchmark_number==6:
+
+        end_time                        = 0.01
+        dt                              = 5.0e-7  #1.0e-7 # Complies Rayleigh's condition ????????????????
+        output_time_step                = 0.00025
+        number_of_points_in_the_graphic = 17
+
+    elif benchmark_number==7:
+
+        end_time                        = 0.0005
+        dt                              = 2e-7 #4.4614e-8 # Complies Rayleigh's condition ????????????????
+        output_time_step                = 0.000005
+        number_of_points_in_the_graphic = 17
+
+    elif benchmark_number==8:
+
+        end_time                        = 0.02
+        dt                              = 1.0e-6 #5.0e-7 # Complies Rayleigh's condition
+        output_time_step                = 0.0001
+        number_of_points_in_the_graphic = 17
+
+    elif benchmark_number==9:
+
+        end_time                        = 0.001 #0.0005
+        dt                              = 1e-7 #6.4e-8 # Complies Rayleigh's condition
+        output_time_step                = 0.000005
+        number_of_points_in_the_graphic = 6
+
+    else: #benchmark_number=10
+
+        end_time                        = 0.001 #0.0005
+        dt                              = 6.4e-8 # Complies Rayleigh's condition
+        output_time_step                = 0.000005
+        number_of_points_in_the_graphic = 10
+
+    return end_time, dt, output_time_step, number_of_points_in_the_graphic
+
+class Benchmark5:
+
+    def __init__(self):
+        self.initial_normal_vel = -5.0
+        self.initial_tangential_vel = 0
+        self.radius = 0.00001
+        self.Vst_div_mu_per_Vcn_list = []
+        self.Vst_prima_div_mu_per_Vcn_prima_list = []
+        self.r_w1_prima_div_mu_per_Vcn_list = []
+        self.Vst_prima_div_mu_per_Vcn_prima_list_outfile = None
+        self.r_w1_prima_div_mu_per_Vcn_list_outfile = None
+
+    def get_initial_data(self, modelpart, iteration, number_of_points_in_the_graphic):
+
+        degrees = 90 / (number_of_points_in_the_graphic + 1) * iteration
+        self.initial_tangential_vel =  -self.initial_normal_vel * tan(degrees * pi / 180.0)
+
+        for node in modelpart.Nodes:
+            node.SetSolutionStepValue(VELOCITY_Y, self.initial_tangential_vel)
+            node.SetSolutionStepValue(VELOCITY_Z, self.initial_normal_vel)
+
+    def get_final_data(self, modelpart):
+
+        mu = 0.3
+
+        for node in modelpart.Nodes:
+            final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_X)
+            final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_Y)
+            final_normal_center_velocity = node.GetSolutionStepValue(VELOCITY_Z)
+            Vst_div_mu_per_Vcn = -self.initial_tangential_vel / (mu * self.initial_normal_vel)
+            Vst_prima_div_mu_per_Vcn_prima = (final_tangential_center_velocity + final_angular_vel * self.radius) / (mu * final_normal_center_velocity)
+            r_w1_prima_div_mu_per_Vcn = -self.radius * final_angular_vel / (mu * self.initial_normal_vel)
+
+        self.Vst_div_mu_per_Vcn_list.append(Vst_div_mu_per_Vcn)
+        self.Vst_prima_div_mu_per_Vcn_prima_list.append(Vst_prima_div_mu_per_Vcn_prima)
+        self.r_w1_prima_div_mu_per_Vcn_list.append(r_w1_prima_div_mu_per_Vcn)
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0):
+
+        self.Vst_prima_div_mu_per_Vcn_prima_list_outfile_name = "benchmark5_dt_" + str(dt) + '_Vst_prima_div_mu_per_Vcn_prima_list_data.dat'
+        self.r_w1_prima_div_mu_per_Vcn_list_outfile_name = "benchmark5_dt_" + str(dt) + '_r_w1_prima_div_mu_per_Vcn_list_data.dat'
+        self.Vst_prima_div_mu_per_Vcn_prima_list_outfile = open(self.Vst_prima_div_mu_per_Vcn_prima_list_outfile_name, 'w')
+        self.r_w1_prima_div_mu_per_Vcn_list_outfile = open(self.r_w1_prima_div_mu_per_Vcn_list_outfile_name, 'w')
+
+        for i in range(0, number_of_points_in_the_graphic):
+            self.Vst_prima_div_mu_per_Vcn_prima_list_outfile.write("%14.8f %14.8f" % (self.Vst_div_mu_per_Vcn_list[i], self.Vst_prima_div_mu_per_Vcn_prima_list[i]) + '\n')
+            self.r_w1_prima_div_mu_per_Vcn_list_outfile.write("%14.8f %14.8f" % (self.Vst_div_mu_per_Vcn_list[i], self.r_w1_prima_div_mu_per_Vcn_list[i]) + '\n')
+        self.Vst_prima_div_mu_per_Vcn_prima_list_outfile.close()
+        self.r_w1_prima_div_mu_per_Vcn_list_outfile.close()
+
+        error1, error2, error3 = self.compute_errors(self.Vst_prima_div_mu_per_Vcn_prima_list_outfile_name, self.r_w1_prima_div_mu_per_Vcn_list_outfile_name)
+
+        error_filename = 'errors.txt'
+        error_file = open(error_filename, 'a')
+        error_file.write("Test 5:")
+
+        if (error1 < 10.0 and error2 < 10.0 and error3 < 10.0):
+            error_file.write(" OK!........ Test 5 SUCCESSFUL\n")
+        else:
+            error_file.write(" KO!........ Test 5 FAILED\n")
+        error_file.close()
+
+    def create_gnuplot_scripts(self, Vst_prima_div_mu_per_Vcn_prima_list_outfile_name, r_w1_prima_div_mu_per_Vcn_list_outfile_name, dt):
+
+        gnuplot_script_name_1 = 'benchmark5_comparison_1_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:14][-4:6] '" + Vst_prima_div_mu_per_Vcn_prima_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark5_graph1.dat' index 0 w lp ls 1 t 'Steel',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark5_graph1.dat' index 1 w lp ls 2 t 'Polyethylene',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark5_graph1.dat' index 2 w p pt 7 ps 2 lt -1 t 'FEM'\n")
+        self.gnuplot_outfile.close()
+
+        gnuplot_script_name_2 = 'benchmark5_comparison_2_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:20][-6:0] '" + r_w1_prima_div_mu_per_Vcn_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark5_graph2.dat' index 0 w lp ls 1 t 'Steel',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark5_graph2.dat' index 1 w lp ls 2 t 'Polyethylene',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark5_graph2.dat' index 2 w p pt 7 ps 2 lt -1 t 'FEM'\n")
+        self.gnuplot_outfile.close()
+
+        print_gnuplot_files_on_screen(gnuplot_script_name_1)
+        print_gnuplot_files_on_screen(gnuplot_script_name_2)
+
+    def compute_errors(self, Vst_prima_div_mu_per_Vcn_prima_list_outfile_name, r_w1_prima_div_mu_per_Vcn_list_outfile_name):
+
+        lines_Chung = list(range(49, 53)); lines_DEM = list(range(11, 15)) # Sliding regime for the time being
+        #lines_Chung = list(range(38, 53)); lines_DEM = list(range(0, 15)) # Whole diagram
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark5_graph1.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split(',')
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(Vst_prima_div_mu_per_Vcn_prima_list_outfile_name) as inf:
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_Vst_prima_div_mu_per_Vcn_prima_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+        for i, j in zip(DEM_data, Chung_data):
+            final_Vst_prima_div_mu_per_Vcn_prima_error+=fabs(i-j)
+
+        final_Vst_prima_div_mu_per_Vcn_prima_error/=summation_of_Chung_data
+
+        Logger.PrintInfo("Error in final Vst prima div mu per Vcn prima =", 100*final_Vst_prima_div_mu_per_Vcn_prima_error,"%")
+
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark5_graph2.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split(',')
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(r_w1_prima_div_mu_per_Vcn_list_outfile_name) as inf:
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_r_w1_prima_div_mu_per_Vcn_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+        for i, j in zip(DEM_data, Chung_data):
+            final_r_w1_prima_div_mu_per_Vcn_error+=fabs(i-j)
+
+        final_r_w1_prima_div_mu_per_Vcn_error/=summation_of_Chung_data
+        Logger.PrintInfo("Error in final r w1 prima div mu per Vcn =", 100*final_r_w1_prima_div_mu_per_Vcn_error,"%")
+
+        error1 = 100*final_Vst_prima_div_mu_per_Vcn_prima_error
+        error2 = 100*final_r_w1_prima_div_mu_per_Vcn_error
+        error3 = 0
+
+        return error1, error2, error3
+
+class Benchmark6:
+
+    def __init__(self):
+        self.initial_normal_vel = -0.2
+        self.initial_tangential_vel = 0
+        self.radius = 0.1
+        self.special_quantity_list = []
+        self.beta_list = []
+        self.Vst_div_Vcn_list = []
+        self.Vst_prima_div_Vcn_prima_list = []
+        self.beta_list_outfile = None
+        self.Vst_prima_div_Vcn_prima_list_outfile = None
+
+    def get_initial_data(self, modelpart, iteration, number_of_points_in_the_graphic):
+
+        degrees = 90 / (number_of_points_in_the_graphic + 1) * iteration
+        self.initial_tangential_vel = -self.initial_normal_vel * tan(degrees * pi / 180.0) # Here is tangential of the contact point, only. In X axis
+        initial_angular_vel = -self.initial_tangential_vel / self.radius # In Y axis
+
+        for node in modelpart.Nodes:
+            node.SetSolutionStepValue(VELOCITY_Z, self.initial_normal_vel)
+            node.SetSolutionStepValue(ANGULAR_VELOCITY_Y, initial_angular_vel)
+
+    def get_final_data(self, modelpart):
+
+        mu = 0.4
+        restitution_coeff = 0.5
+
+        for node in modelpart.Nodes:
+            special_quantity = -3.5 * mu * (1.0 + restitution_coeff) * self.initial_normal_vel / self.initial_tangential_vel
+            final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)
+            final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_X)
+            final_normal_center_velocity = node.GetSolutionStepValue(VELOCITY_Z)
+            beta = -(final_tangential_center_velocity - final_angular_vel * self.radius)/ self.initial_tangential_vel
+            Vst_div_Vcn = -self.initial_tangential_vel / self.initial_normal_vel
+            Vst_prima_div_Vcn_prima = (final_tangential_center_velocity - final_angular_vel * self.radius) / final_normal_center_velocity
+
+        self.special_quantity_list.append(special_quantity)
+        self.beta_list.append(beta)
+        self.Vst_div_Vcn_list.append(Vst_div_Vcn)
+        self.Vst_prima_div_Vcn_prima_list.append(Vst_prima_div_Vcn_prima)
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0):
+
+        self.beta_list_outfile_name = "benchmark6_dt_" + str(dt) + '_beta_list_data.dat'
+        self.Vst_prima_div_Vcn_prima_list_outfile_name = "benchmark6_dt_" + str(dt) + '_Vst_prima_div_Vcn_prima_data.dat'
+        self.beta_list_outfile = open(self.beta_list_outfile_name, 'w')
+        self.Vst_prima_div_Vcn_prima_list_outfile = open(self.Vst_prima_div_Vcn_prima_list_outfile_name, 'w')
+
+        for i in range(0, number_of_points_in_the_graphic):
+            self.beta_list_outfile.write("%14.8f %14.8f" % (self.special_quantity_list[i], self.beta_list[i]) + '\n')
+            self.Vst_prima_div_Vcn_prima_list_outfile.write("%14.8f %14.8f" % (self.Vst_div_Vcn_list[i], self.Vst_prima_div_Vcn_prima_list[i]) + '\n')
+        self.beta_list_outfile.close()
+        self.Vst_prima_div_Vcn_prima_list_outfile.close()
+
+        error1, error2, error3 = self.compute_errors(self.beta_list_outfile_name, self.Vst_prima_div_Vcn_prima_list_outfile_name)
+
+        error_filename = 'errors.txt'
+        error_file = open(error_filename, 'a')
+        error_file.write("Test 6:")
+
+        if (error1 < 10.0 and error2 < 10.0 and error3 < 10.0):
+            error_file.write(" OK!........ Test 6 SUCCESSFUL\n")
+        else:
+            error_file.write(" KO!........ Test 6 FAILED\n")
+        error_file.close()
+
+    def create_gnuplot_scripts(self, beta_list_outfile_name, Vst_prima_div_Vcn_prima_list_outfile_name, dt):
+
+        gnuplot_script_name_1 = 'benchmark6_comparison_1_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:25][-1:.6] '" + beta_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark6_graph1.dat' index 0 w lp ls 1 t 'Al. alloy',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark6_graph1.dat' index 1 w lp ls 2 t 'Nylon'\n")
+        self.gnuplot_outfile.close()
+
+        gnuplot_script_name_2 = 'benchmark6_comparison_2_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Tangent of incident angle'\nset ylabel 'Tangent of recoil angle'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:7][-2:8] '" + Vst_prima_div_Vcn_prima_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark6_graph2.dat' index 0 w lp ls 1 t 'Al. alloy',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark6_graph2.dat' index 1 w lp ls 2 t 'Nylon'\n")
+        self.gnuplot_outfile.close()
+
+        print_gnuplot_files_on_screen(gnuplot_script_name_1)
+        print_gnuplot_files_on_screen(gnuplot_script_name_2)
+
+    def compute_errors(self, beta_list_outfile_name, Vst_prima_div_Vcn_prima_list_outfile_name):
+
+        lines_Chung = list(range(1, 7)); lines_DEM = list(range(16, 10, -1)) # Sliding regime for the time being
+        #lines_Chung = list(range(1, 17)); lines_DEM = list(range(0, 16)) # Whole diagram
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark6_graph1.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split(',')
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+
+        with open(beta_list_outfile_name) as inf:
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_beta_list_outfile_name_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+        DEM_data.reverse()
+        for i, j in zip(DEM_data, Chung_data):
+            final_beta_list_outfile_name_error+=fabs(i-j)
+
+        final_beta_list_outfile_name_error/=summation_of_Chung_data
+        Logger.PrintInfo("Error in final beta =", 100*final_beta_list_outfile_name_error,"%")
+
+        lines_Chung = list(range(13, 17)); lines_DEM = list(range(12, 16)) # Sliding regime for the time being
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark6_graph2.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split(',')
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(Vst_prima_div_Vcn_prima_list_outfile_name) as inf:
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_Vst_prima_div_Vcn_prima_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+
+        for i, j in zip(DEM_data, Chung_data):
+            final_Vst_prima_div_Vcn_prima_error+=fabs(i-j)
+
+        final_Vst_prima_div_Vcn_prima_error/=summation_of_Chung_data
+        Logger.PrintInfo("Error in final Vst prima div Vcn =", 100*final_Vst_prima_div_Vcn_prima_error,"%")
+
+        error1 = 100*final_beta_list_outfile_name_error
+        error2 = 100*final_Vst_prima_div_Vcn_prima_error
+        error3 = 0
+
+        return error1, error2, error3
+
+class Benchmark7:
+
+    def __init__(self):
+        self.initial_angular_vel = 0
+        self.final_tangential_center_vel_list_outfile = None
+        self.final_angular_vel_list_outfile = None
+        self.initial_angular_vel_list = []
+        self.final_tangential_center_vel_list = []
+        self.final_angular_vel_list = []
+
+    def get_initial_data(self, modelpart, iteration, number_of_points_in_the_graphic):
+
+        initial_normal_vel = 0.2
+        radius = 0.1
+        degrees = 90 / (number_of_points_in_the_graphic + 1) * iteration
+        self.initial_angular_vel =  initial_normal_vel / radius * tan(degrees * pi / 180.0) # Here is tangential of the contact point, only
+
+        for node in modelpart.Nodes:
+            if node.Id == 1:
+                node.SetSolutionStepValue(VELOCITY_X,  initial_normal_vel)
+                node.SetSolutionStepValue(ANGULAR_VELOCITY_Y,  self.initial_angular_vel)
+            else:
+                node.SetSolutionStepValue(VELOCITY_X, -initial_normal_vel)
+                node.SetSolutionStepValue(ANGULAR_VELOCITY_Y, -self.initial_angular_vel)
+
+    def get_final_data(self, modelpart):
+
+        mu = 0.4
+
+        for node in modelpart.Nodes:
+            if node.Id == 1:
+                final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_Z)
+                final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)
+
+        self.initial_angular_vel_list.append(self.initial_angular_vel)
+        self.final_tangential_center_vel_list.append(final_tangential_center_velocity)
+        self.final_angular_vel_list.append(final_angular_vel)
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0):
+
+        self.final_tangential_center_vel_list_outfile_name = "benchmark7_dt_" + str(dt) + '_final_tangential_center_vel_list_data.dat'
+        self.final_angular_vel_list_outfile_name = "benchmark7_dt_" + str(dt) + '_final_angular_vel_list_data.dat'
+        self.final_tangential_center_vel_list_outfile = open(self.final_tangential_center_vel_list_outfile_name, 'w')
+        self.final_angular_vel_list_outfile = open(self.final_angular_vel_list_outfile_name, 'w')
+
+        for i in range(0, number_of_points_in_the_graphic):
+            self.final_tangential_center_vel_list_outfile.write("%14.8f %14.8f" % (self.initial_angular_vel_list[i], self.final_tangential_center_vel_list[i]) + '\n')
+            self.final_angular_vel_list_outfile.write("%14.8f %14.8f" % (self.initial_angular_vel_list[i], self.final_angular_vel_list[i]) + '\n')
+        self.final_tangential_center_vel_list_outfile.close()
+        self.final_angular_vel_list_outfile.close()
+
+        gnuplot_script_name = 'benchmark7_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name, 'w')
+        self.gnuplot_outfile.write("set multiplot layout 2, 1; set grid; set bmargin 0; set format x \"\"; set ytics -5, 5; set key bottom;\
+                                    plot [0:25][-10:10] '" + self.final_tangential_center_vel_list_outfile_name + "' w lp lw 1.5 ps 2 pt 4;\
+                                    set bmargin; set tmargin 0; set format x \"%g\"; set ytics 0, 5, 20; set key top;\
+                                    plot [0:25][0:25] '" + self.final_angular_vel_list_outfile_name + "' w lp lw 1.5 lt 3 ps 2 pt 6; unset multiplot")
+        self.gnuplot_outfile.close()
+
+        error1, error2, error3 = self.compute_errors(self.final_tangential_center_vel_list_outfile_name, self.final_angular_vel_list_outfile_name)
+
+        error_filename = 'errors.txt'
+        error_file = open(error_filename, 'a')
+        error_file.write("Test 7:")
+
+        if (error1 < 10.0 and error2 < 10.0 and error3 < 10.0):
+            error_file.write(" OK!........ Test 7 SUCCESSFUL\n")
+        else:
+            error_file.write(" KO!........ Test 7 FAILED\n")
+        error_file.close()
+
+    def create_gnuplot_scripts(self, final_tangential_center_vel_list_outfile_name, final_angular_vel_list_outfile_name, dt):
+
+        gnuplot_script_name_1 = 'benchmark7_comparison_1_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:25][-10:10] '" + final_tangential_center_vel_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark7_graph1.dat' w lp ls 1 t 'Al. alloy',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark7_graph1.dat' w lp ls 2 t 'Copper'\n")
+        self.gnuplot_outfile.close()
+
+        gnuplot_script_name_2 = 'benchmark7_comparison_2_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Initial angular velocity (rad/s)'\nset ylabel 'Final angular velocity (rad/s)'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:25][0:25] '" + final_angular_vel_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark7_graph2.dat' w lp ls 1 t 'Al. alloy',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark7_graph2.dat' w lp ls 2 t 'Copper'\n")
+        self.gnuplot_outfile.close()
+
+        print_gnuplot_files_on_screen(gnuplot_script_name_1)
+        print_gnuplot_files_on_screen(gnuplot_script_name_2)
+
+    def compute_errors(self, final_tangential_center_vel_list_outfile_name, final_angular_vel_list_outfile_name):
+
+        lines_Chung = []; lines_DEM = []; lines_Chung = list(range(0, 17)); lines_DEM = list(range(0, 17))
+        Chung_data = []; DEM_data = []
+        i = 0
+        with open('paper_data/benchmark7_graph1.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split()
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(final_tangential_center_vel_list_outfile_name) as inf:
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_tangential_center_vel_error = 0
+
+        for i, j in zip(DEM_data, Chung_data):
+            final_tangential_center_vel_error+=fabs(i-j)
+        Logger.PrintInfo("Error in final tangential center vel =", final_tangential_center_vel_error)
+
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark7_graph2.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split()
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(final_angular_vel_list_outfile_name) as inf:
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_angular_vel_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+        for i, j in zip(DEM_data, Chung_data):
+            final_angular_vel_error+=fabs(i-j)
+
+        final_angular_vel_error/=summation_of_Chung_data
+        Logger.PrintInfo("Error in final angular vel =", 100*final_angular_vel_error,"%")
+
+        error1 = 100*final_tangential_center_vel_error
+        error2 = 100*final_angular_vel_error
+        error3 = 0
+
+        return error1, error2, error3
+
+class Benchmark8:
+
+    def __init__(self):
+        self.initial_normal_vel = 0.2
+        self.initial_tangential_vel = 0
+        self.radius = 0.1
+        self.special_quantity_list = []
+        self.beta_list = []
+        self.Vst_div_Vcn_list = []
+        self.Vst_prima_div_Vcn_prima_list = []
+        self.beta_list_outfile = None
+        self.Vst_prima_div_Vcn_prima_list_outfile = None
+
+    def get_initial_data(self, modelpart, iteration, number_of_points_in_the_graphic):
+
+        degrees = 90 - 90 / (number_of_points_in_the_graphic + 1) * iteration
+        self.initial_tangential_vel =  self.initial_normal_vel * tan(degrees * pi / 180.0) # Here is tangential of the contact point, only
+        initial_angular_vel    =  -self.initial_tangential_vel / self.radius
+
+        for node in modelpart.Nodes:
+            if node.Id == 1:
+                node.SetSolutionStepValue(VELOCITY_X, self.initial_normal_vel)
+                node.SetSolutionStepValue(ANGULAR_VELOCITY_Y, initial_angular_vel)
+
+    def get_final_data(self, modelpart):
+
+        mu = 0.4
+        restitution_coeff = 0.5
+
+        for node in modelpart.Nodes:
+            if node.Id == 1:
+                special_quantity = 3.5 * mu * (1.0 + restitution_coeff) * self.initial_normal_vel / self.initial_tangential_vel
+                final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)
+                final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_Z)
+                final_normal_center_velocity = node.GetSolutionStepValue(VELOCITY_X)
+                beta = -(final_tangential_center_velocity - final_angular_vel * self.radius)/ self.initial_tangential_vel
+                Vst_div_Vcn = self.initial_tangential_vel / self.initial_normal_vel
+                Vst_prima_div_Vcn_prima = -(final_tangential_center_velocity - final_angular_vel * self.radius) / final_normal_center_velocity
+
+        self.special_quantity_list.append(special_quantity)
+        self.beta_list.append(beta)
+        self.Vst_div_Vcn_list.append(Vst_div_Vcn)
+        self.Vst_prima_div_Vcn_prima_list.append(Vst_prima_div_Vcn_prima)
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0):
+
+        self.beta_list_outfile_name = 'benchmark8_dt_' + str(dt) + 's_beta_list_data.dat'
+        self.Vst_prima_div_Vcn_prima_list_outfile_name = 'benchmark8_dt_' + str(dt) + 's_Vst_prima_div_Vcn_prima_list_data.dat'
+        self.beta_list_outfile = open(self.beta_list_outfile_name, 'w')
+        self.Vst_prima_div_Vcn_prima_list_outfile = open(self.Vst_prima_div_Vcn_prima_list_outfile_name, 'w')
+
+        for i in range(0, number_of_points_in_the_graphic):
+            self.beta_list_outfile.write("%14.8f %14.8f" % (self.special_quantity_list[i], self.beta_list[i]) + '\n')
+            self.Vst_prima_div_Vcn_prima_list_outfile.write("%14.8f %14.8f" % (self.Vst_div_Vcn_list[i], self.Vst_prima_div_Vcn_prima_list[i]) + '\n')
+
+        self.beta_list_outfile.close()
+        self.Vst_prima_div_Vcn_prima_list_outfile.close()
+
+        error1, error2, error3 = self.compute_errors(self.beta_list_outfile_name, self.Vst_prima_div_Vcn_prima_list_outfile_name)
+
+        error_filename = 'errors.txt'
+        error_file = open(error_filename, 'a')
+        error_file.write("Test 8:")
+
+        if (error1 < 10.0 and error2 < 10.0 and error3 < 10.0):
+            error_file.write(" OK!........ Test 8 SUCCESSFUL\n")
+        else:
+            error_file.write(" KO!........ Test 8 FAILED\n")
+        error_file.close()
+
+    def create_gnuplot_scripts(self, beta_list_outfile_name, Vst_prima_div_Vcn_prima_list_outfile_name, dt):
+
+        gnuplot_script_name_1 = 'benchmark8_comparison_1_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:25][-1:.6] '" + beta_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark8_graph1.dat' index 0 w lp ls 1 t 'Al. alloy',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark8_graph1.dat' index 1 w lp ls 2 t 'Nylon'\n")
+        self.gnuplot_outfile.close()
+
+        gnuplot_script_name_2 = 'benchmark8_comparison_2_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Tangent of incident angle'\nset ylabel 'Tangent of recoil angle'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:8][-2:8] '" + Vst_prima_div_Vcn_prima_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark8_graph2.dat' index 0 w lp ls 1 t 'Al. alloy',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark8_graph2.dat' index 1 w lp ls 2 t 'Nylon'\n")
+        self.gnuplot_outfile.close()
+
+        print_gnuplot_files_on_screen(gnuplot_script_name_1)
+        print_gnuplot_files_on_screen(gnuplot_script_name_2)
+
+    def compute_errors(self, beta_list_outfile_name, Vst_prima_div_Vcn_prima_list_outfile_name):
+
+        lines_Chung = []; lines_DEM = []; lines_Chung = list(range(1, 7)); lines_DEM = list(range(0, 6)) # Sliding regime for the time being
+        #lines_Chung = []; lines_DEM = []; lines_Chung = list(range(1, 18)); lines_DEM = list(range(0, 17)) # Whole diagram
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark8_graph1.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split(',')
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(beta_list_outfile_name) as inf:
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_beta_list_outfile_name_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+        for i, j in zip(DEM_data, Chung_data):
+            final_beta_list_outfile_name_error+=fabs(i-j)
+
+        final_beta_list_outfile_name_error/=summation_of_Chung_data
+        Logger.PrintInfo("Error in final beta =", 100*final_beta_list_outfile_name_error,"%")
+
+        lines_Chung = []; lines_DEM = []; lines_DEM = list(range(4, 0, -1)); lines_Chung = list(range(13, 17)) # Sliding regime for the time being
+        #lines_Chung = list(range(1, 17)); lines_DEM = list(range(0, 16)) # Whole diagram
+
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark8_graph2.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split(',')
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(Vst_prima_div_Vcn_prima_list_outfile_name) as inf:
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_Vst_prima_div_Vcn_prima_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+        DEM_data.reverse()
+        for i, j in zip(DEM_data, Chung_data):
+            final_Vst_prima_div_Vcn_prima_error+=fabs(i-j)
+
+        final_Vst_prima_div_Vcn_prima_error/=summation_of_Chung_data
+        Logger.PrintInfo("Error in final Vst prima div Vcn =", 100*final_Vst_prima_div_Vcn_prima_error,"%")
+
+        error1 = 100*final_beta_list_outfile_name_error
+        error2 = 100*final_Vst_prima_div_Vcn_prima_error
+        error3 = 0
+
+        return error1, error2, error3
+
+class Benchmark9:
+
+    def __init__(self):
+        self.initial_normal_vel = 200.0
+        self.restitution_numbers_list = []
+        self.restitution_numbers_vector_list_outfile = None
+
+    def get_initial_data(self, modelpart, iteration, number_of_points_in_the_graphic):
+
+        if number_of_points_in_the_graphic == 1:
+            number = 0
+        else:
+            number = 1.0/(number_of_points_in_the_graphic-1) * (iteration - 1)
+
+        for node in modelpart.Nodes:
+
+            if node.Id == 1:
+                node.SetSolutionStepValue(VELOCITY_X,  self.initial_normal_vel)
+                node.SetSolutionStepValue(VELOCITY_Z,  self.initial_normal_vel)
+                modelpart.GetProperties()[1][COEFFICIENT_OF_RESTITUTION] = number
+            else:
+                node.SetSolutionStepValue(VELOCITY_X, -self.initial_normal_vel)
+                node.SetSolutionStepValue(VELOCITY_Z,  self.initial_normal_vel)
+                modelpart.GetProperties()[1][COEFFICIENT_OF_RESTITUTION] = number
+
+    def get_final_data(self, modelpart):
+
+        for node in modelpart.Nodes:
+            if node.Id == 1:
+                final_vel = node.GetSolutionStepValue(VELOCITY_X)
+
+        restitution_coefficient = -final_vel / self.initial_normal_vel
+        self.restitution_numbers_list.append(restitution_coefficient)
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0):
+
+        self.restitution_numbers_vector_list_outfile_name = "benchmark9_dt_" + str(dt) + '_restitution_numbers_vector_list_data.dat'
+        self.restitution_numbers_vector_list_outfile = open(self.restitution_numbers_vector_list_outfile_name, 'w')
+
+        for i in range(0, number_of_points_in_the_graphic):
+            if number_of_points_in_the_graphic == 1:
+                first_col = 0
+            else:
+                first_col = 1/(number_of_points_in_the_graphic-1) * i
+            self.restitution_numbers_vector_list_outfile.write("%6.4f %6.4f %11.8f" % (first_col, first_col, self.restitution_numbers_list[i]) + '\n')
+        self.restitution_numbers_vector_list_outfile.close()
+
+        gnuplot_script_name = 'benchmark9_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name, 'w')
+        self.gnuplot_outfile.write("set grid; plot '" + self.restitution_numbers_vector_list_outfile_name + "' u 1:2 w lp lt 3 lw 1.5 ps 2 pt 4, '"\
+                                                      + self.restitution_numbers_vector_list_outfile_name + "' u 1:3 w lp lt 2 lw 1.5 ps 2 pt 6")
+        self.gnuplot_outfile.close()
+
+        error1, error2, error3 = self.compute_errors(self.restitution_numbers_vector_list_outfile_name)
+
+        error_filename = 'errors.txt'
+        error_file = open(error_filename, 'a')
+        error_file.write("Test 9:")
+
+        if (error1 < 10.0 and error2 < 10.0 and error3 < 10.0):
+            error_file.write(" OK!........ Test 9 SUCCESSFUL\n")
+        else:
+            error_file.write(" KO!........ Test 9 FAILED\n")
+        error_file.close()
+
+    def create_gnuplot_scripts(self, restitution_numbers_vector_list_outfile_name, dt):
+
+        gnuplot_script_name_1 = 'benchmark9_comparison_1_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Coefficient of restitution'\nset ylabel 'Damping ratio'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt  3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:1][0:1] '" + restitution_numbers_vector_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark9_graph1.dat' w lp ls 1 t 'Al. oxide',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark9_graph1.dat' w lp ls 2 t 'Cast iron'\n")
+        self.gnuplot_outfile.close()
+
+        print_gnuplot_files_on_screen(gnuplot_script_name_1)
+
+    def compute_errors(self, restitution_numbers_vector_list_outfile_name):
+
+        lines_Chung = lines_DEM = list(range(0, 6));
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark9_graph1.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split()
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(restitution_numbers_vector_list_outfile_name) as inf:
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_restitution_numbers_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+        for i, j in zip(DEM_data, Chung_data):
+            final_restitution_numbers_error+=fabs(i-j)
+        final_restitution_numbers_error/=summation_of_Chung_data
+
+        Logger.PrintInfo("Error in restitution numbers =", 100*final_restitution_numbers_error,"%")
+
+        error1 = 100*final_restitution_numbers_error
+
+        error2 = error3 = 0
+
+        return error1, error2, error3
+
+class Benchmark10:
+
+    def __init__(self):
+        self.initial_normal_vel = 10.0
+        self.restitution_numbers_list = []
+        self.restitution_numbers_vector_list_outfile = None
+
+    def get_initial_data(self, modelpart, iteration, number_of_points_in_the_graphic):
+
+        if number_of_points_in_the_graphic == 1:
+            coefficient_of_restitution = 0
+        else:
+            coefficient_of_restitution = 1.0/(number_of_points_in_the_graphic-1) * (iteration - 1)
+
+        for node in modelpart.Nodes:
+
+            if node.Id == 1:
+                node.SetSolutionStepValue(VELOCITY_X,  self.initial_normal_vel)
+                node.SetSolutionStepValue(VELOCITY_Z,  self.initial_normal_vel)
+                modelpart.GetProperties()[1][COEFFICIENT_OF_RESTITUTION] = coefficient_of_restitution
+            else:
+                node.SetSolutionStepValue(VELOCITY_X, -1.2 * self.initial_normal_vel)
+                node.SetSolutionStepValue(VELOCITY_Z,  1.6 * self.initial_normal_vel)
+                modelpart.GetProperties()[1][COEFFICIENT_OF_RESTITUTION] = coefficient_of_restitution
+
+    def get_final_data(self, modelpart):
+
+        for node in modelpart.Nodes:
+            if node.Id == 1:
+                final_vel = node.GetSolutionStepValue(VELOCITY_X)
+
+        restitution_coefficient = -final_vel / self.initial_normal_vel
+        self.restitution_numbers_list.append(restitution_coefficient)
+
+    def print_results(self, number_of_points_in_the_graphic, dt):
+
+        self.restitution_numbers_vector_list_outfile = open("benchmark10_dt_" + str(dt) + '_restitution_numbers_vector_list_data.dat', 'w')
+
+        for i in range(0, number_of_points_in_the_graphic):
+            if number_of_points_in_the_graphic == 1:
+                first_col = 0
+            else:
+                first_col = 1/(number_of_points_in_the_graphic-1) * i
+            self.restitution_numbers_vector_list_outfile.write("%6.4f %6.4f %11.8f" % (first_col, first_col, self.restitution_numbers_list[i]) + '\n')
+        self.restitution_numbers_vector_list_outfile.close()
+
+def delete_archives(nodeplotter):
+
+    #.......................Removing extra files
+    files_to_delete_list = glob('*.time')
+    for to_erase_file in files_to_delete_list:
+        os.remove(to_erase_file)
+
+    #............Getting rid of unuseful folders
+    folders_to_delete_list      = glob('*Data')
+    folders_to_delete_list.extend(glob('*ists'))
+    folders_to_delete_list.extend(glob('*ults'))
+    folders_to_delete_list.extend(glob('*he__'))
+    folders_to_delete_list.extend(glob('*aphs'))
+
+    for to_erase_folder in folders_to_delete_list:
+        shutil.rmtree(to_erase_folder)
+
+def print_gnuplot_files_on_screen(gnuplot_script_name):
+    system('gnuplot -persist ' + gnuplot_script_name)
+
+def create_pdf_document(pdf_script_name):
+    system('gnuplot -persist ' + pdf_script_name)
+
+def ComputeRelativeError(a, b):
+    sum_a = 0.0
+    diff_sum = 0.0
+    for a_comp, b_comp in zip(a, b):
+        diff_sum += abs(a_comp - b_comp)
+        sum_a += abs(a_comp)
+    relative_error = diff_sum / sum_a
+    return relative_error
```

## KratosMultiphysics/DEMApplication/dem_vtk_output.py

 * *Ordering differences only*

```diff
@@ -1,456 +1,456 @@
-#  Kratos Multi-Physics - DEM Application
-#
-#  License:       BSD License
-#                 Kratos default license: kratos/license.txt
-#
-#  Main authors:  Miguel Angel Celigueta (maceli@cimne.upc.edu)
-#                 Chengshun Shang (cshang@cimne.upc.edu)
-#
-
-import os
-from pyevtk import hl
-from pyevtk import vtk
-import numpy as np
-import weakref
-import shutil
-from KratosMultiphysics import *
-from KratosMultiphysics.DEMApplication import *
-
-def GetBoolParameterIfItExists(set_of_parameters, parameter_key):
-    if parameter_key in set_of_parameters.keys():
-        return set_of_parameters[parameter_key].GetBool()
-    return False
-
-class VtkOutput():
-    def __init__(self, main_path, problem_name, spheres_model_part, contact_model_part, rigid_face_model_part, DEM_parameters):
-        self.problem_name = problem_name
-        self.DEM_parameters = DEM_parameters
-
-        # Reading Post options from DEM_parameters
-        self.PostDisplacement = self.DEM_parameters["PostDisplacement"].GetBool()
-        self.PostVelocity = self.DEM_parameters["PostVelocity"].GetBool()
-        self.PostTotalForces = self.DEM_parameters["PostTotalForces"].GetBool()
-        self.PostNonDimensionalVolumeWear = self.DEM_parameters["PostNonDimensionalVolumeWear"].GetBool()
-        self.PostAppliedForces = self.DEM_parameters["PostAppliedForces"].GetBool()
-        self.PostDampForces = self.DEM_parameters["PostDampForces"].GetBool()
-        self.PostRadius = self.DEM_parameters["PostRadius"].GetBool()
-        self.PostGroupId = GetBoolParameterIfItExists(self.DEM_parameters, "PostGroupId")
-        self.PostExportId = self.DEM_parameters["PostExportId"].GetBool()
-        self.PostSkinSphere = GetBoolParameterIfItExists(self.DEM_parameters, "PostSkinSphere")
-        self.PostGluedSphere = GetBoolParameterIfItExists(self.DEM_parameters, "PostGluedSphere")
-        self.PostAngularVelocity = self.DEM_parameters["PostAngularVelocity"].GetBool()
-        self.PostParticleMoment = self.DEM_parameters["PostParticleMoment"].GetBool()
-        self.PostEulerAngles = self.DEM_parameters["PostEulerAngles"].GetBool()
-        self.PostRollingResistanceMoment = self.DEM_parameters["PostRollingResistanceMoment"].GetBool()
-        self.PostNeighbourSize = GetBoolParameterIfItExists(self.DEM_parameters, "PostNeighbourSize")
-        self.PostDamageRatio = GetBoolParameterIfItExists(self.DEM_parameters, "PostDamageRatio")
-        
-        # for contacts
-        self.PostLocalContactForce = GetBoolParameterIfItExists(self.DEM_parameters, "PostLocalContactForce")
-        self.PostFailureCriterionState = GetBoolParameterIfItExists(self.DEM_parameters, "PostFailureCriterionState")
-        self.PostContactFailureId = GetBoolParameterIfItExists(self.DEM_parameters, "PostContactFailureId")
-        self.PostContactTau = GetBoolParameterIfItExists(self.DEM_parameters, "PostContactTau")
-        self.PostContactSigma = GetBoolParameterIfItExists(self.DEM_parameters, "PostContactSigma")
-        self.PostContactRadius = GetBoolParameterIfItExists(self.DEM_parameters, "PostContactRadius")
-        
-        #TODO: those variables need to be added
-        ''' 
-        self.PostElasticForces = self.DEM_parameters["PostElasticForces"].GetBool()
-        self.PostContactForces = self.DEM_parameters["PostContactForces"].GetBool()
-        self.PostRigidElementForces = self.DEM_parameters["PostRigidElementForces"].GetBool()
-        self.PostPressure = self.DEM_parameters["PostPressure"].GetBool()
-        self.PostTangentialElasticForces = self.DEM_parameters["PostTangentialElasticForces"].GetBool()
-        self.PostShearStress = self.DEM_parameters["PostShearStress"].GetBool()
-        self.PostNodalArea = self.DEM_parameters["PostNodalArea"].GetBool()
-        self.PostNormalImpactVelocity = GetBoolParameterIfItExists(self.DEM_parameters, "PostNormalImpactVelocity")
-        self.PostTangentialImpactVelocity = GetBoolParameterIfItExists(self.DEM_parameters, "PostTangentialImpactVelocity")
-        self.PostControlModule = GetBoolParameterIfItExists(self.DEM_parameters, "PostControlModule")
-        self.VelTrapGraphExportFreq = self.DEM_parameters["VelTrapGraphExportFreq"].GetDouble()
-        self.PostDeltaDisplacement = GetBoolParameterIfItExists(self.DEM_parameters, "PostDeltaDisplacement")
-        self.PostCharacteristicLength = GetBoolParameterIfItExists(self.DEM_parameters, "PostCharacteristicLength")
-        self.PostBoundingBox = GetBoolParameterIfItExists(self.DEM_parameters, "PostBoundingBox")
-        '''
-        self.spheres_model_part = weakref.proxy(spheres_model_part)
-        self.contact_model_part = weakref.proxy(contact_model_part)
-        self.rigid_face_model_part = weakref.proxy(rigid_face_model_part)
-
-        self.vtk_post_path_directory = os.path.join(main_path, problem_name + "_Post_VTK_Files")
-        shutil.rmtree(self.vtk_post_path_directory, ignore_errors=True)
-        os.makedirs(str(self.vtk_post_path_directory))
-
-        self.counter = 0
-
-    def ConvertParticlesToNumpyArrays(self):
-        number_of_nodes = self.spheres_model_part.NumberOfNodes(0)
-
-        self.particles_X = np.empty(number_of_nodes)
-        self.particles_Y = np.empty(number_of_nodes)
-        self.particles_Z = np.empty(number_of_nodes)
-        self.particles_material = np.empty(number_of_nodes)
-
-        if self.PostRadius:
-            self.particles_R = np.empty(number_of_nodes)
-
-        if self.PostVelocity:
-            self.velocities_X = np.empty(number_of_nodes)
-            self.velocities_Y = np.empty(number_of_nodes)
-            self.velocities_Z = np.empty(number_of_nodes)
-        
-        if self.PostDisplacement:
-            self.displacement_X = np.empty(number_of_nodes)
-            self.displacement_Y = np.empty(number_of_nodes)
-            self.displacement_Z = np.empty(number_of_nodes)
-
-        if self.PostTotalForces:
-            self.total_force_X = np.empty(number_of_nodes)
-            self.total_force_Y = np.empty(number_of_nodes)
-            self.total_force_Z = np.empty(number_of_nodes)
-
-        if self.PostNonDimensionalVolumeWear:
-            self.non_dimensional_volume_wear = np.empty(number_of_nodes)
-        
-        if self.PostAppliedForces:
-            self.applied_force_X = np.empty(number_of_nodes)
-            self.applied_force_Y = np.empty(number_of_nodes)
-            self.applied_force_Z = np.empty(number_of_nodes)
-
-        if self.PostDampForces:
-            self.damp_force_X = np.empty(number_of_nodes)
-            self.damp_force_Y = np.empty(number_of_nodes)
-            self.damp_force_Z = np.empty(number_of_nodes)
-
-        if self.PostGroupId:
-            self.group_id = np.empty(number_of_nodes)
-
-        if self.PostExportId:
-            self.export_id = np.empty(number_of_nodes)
-
-        if self.PostSkinSphere:
-            self.skin_sphere = np.empty(number_of_nodes)
-
-        if self.PostGluedSphere:
-            self.glued_sphere = np.empty(number_of_nodes)
-        
-        if self.PostAngularVelocity:
-            self.angular_velocity_X = np.empty(number_of_nodes)
-            self.angular_velocity_Y = np.empty(number_of_nodes)
-            self.angular_velocity_Z = np.empty(number_of_nodes)
-        
-        if self.PostParticleMoment:
-            self.particle_moment_X = np.empty(number_of_nodes)
-            self.particle_moment_Y = np.empty(number_of_nodes)
-            self.particle_moment_Z = np.empty(number_of_nodes)
-        
-        if self.PostEulerAngles:
-            self.euler_angles_X = np.empty(number_of_nodes)
-            self.euler_angles_Y = np.empty(number_of_nodes)
-            self.euler_angles_Z = np.empty(number_of_nodes)
-        
-        if self.PostRollingResistanceMoment:
-            self.rolling_resistance_moment_X = np.empty(number_of_nodes)
-            self.rolling_resistance_moment_Y = np.empty(number_of_nodes)
-            self.rolling_resistance_moment_Z = np.empty(number_of_nodes)
-        
-        if self.PostNeighbourSize:
-            self.neighbour_size = np.empty(number_of_nodes)
-        
-        if self.PostDamageRatio:
-            self.damage_ratio = np.empty(number_of_nodes)
-
-        i = 0
-        for node in self.spheres_model_part.Nodes:
-            self.particles_X[i] = node.X
-            self.particles_Y[i] = node.Y
-            self.particles_Z[i] = node.Z
-            self.particles_material[i] = node.GetSolutionStepValue(PARTICLE_MATERIAL)
-
-            if self.PostRadius:
-                self.particles_R[i] = node.GetSolutionStepValue(RADIUS)
-
-            if self.PostVelocity:
-                self.velocities_X[i] = node.GetSolutionStepValue(VELOCITY_X)
-                self.velocities_Y[i] = node.GetSolutionStepValue(VELOCITY_Y)
-                self.velocities_Z[i] = node.GetSolutionStepValue(VELOCITY_Z)
-            
-            if self.PostDisplacement:
-                self.displacement_X[i] = node.GetSolutionStepValue(DISPLACEMENT_X)
-                self.displacement_Y[i] = node.GetSolutionStepValue(DISPLACEMENT_Y)
-                self.displacement_Z[i] = node.GetSolutionStepValue(DISPLACEMENT_Z)
-
-            if self.PostTotalForces:
-                self.total_force_X[i] = node.GetSolutionStepValue(TOTAL_FORCES)[0]
-                self.total_force_Y[i] = node.GetSolutionStepValue(TOTAL_FORCES)[1]
-                self.total_force_Z[i] = node.GetSolutionStepValue(TOTAL_FORCES)[2]
-
-            if self.PostNonDimensionalVolumeWear:
-                self.non_dimensional_volume_wear[i] = node.GetSolutionStepValue(NON_DIMENSIONAL_VOLUME_WEAR)
-            
-            if self.PostAppliedForces:
-                self.applied_force_X[i] = node.GetSolutionStepValue(EXTERNAL_APPLIED_FORCE)[0]
-                self.applied_force_Y[i] = node.GetSolutionStepValue(EXTERNAL_APPLIED_FORCE)[1]
-                self.applied_force_Z[i] = node.GetSolutionStepValue(EXTERNAL_APPLIED_FORCE)[2]
-
-            if self.PostDampForces:
-                self.damp_force_X[i] = node.GetSolutionStepValue(DAMP_FORCES)[0]
-                self.damp_force_Y[i] = node.GetSolutionStepValue(DAMP_FORCES)[1]
-                self.damp_force_Z[i] = node.GetSolutionStepValue(DAMP_FORCES)[2]
-
-            if self.PostGroupId:
-                self.group_id[i] = node.GetSolutionStepValue(GROUP_ID)
-
-            if self.PostExportId:
-                self.export_id[i] = node.GetSolutionStepValue(EXPORT_ID)
-
-            if self.PostSkinSphere:
-                self.skin_sphere[i] = node.GetSolutionStepValue(SKIN_SPHERE)
-
-            if self.PostGluedSphere:
-                self.glued_sphere[i] = node.GetSolutionStepValue(IS_STICKY)
-            
-            if self.PostAngularVelocity:
-                self.angular_velocity_X[i] = node.GetSolutionStepValue(ANGULAR_VELOCITY)[0]
-                self.angular_velocity_Y[i] = node.GetSolutionStepValue(ANGULAR_VELOCITY)[1]
-                self.angular_velocity_Z[i] = node.GetSolutionStepValue(ANGULAR_VELOCITY)[2]
-            
-            if self.PostParticleMoment:
-                self.particle_moment_X[i] = node.GetSolutionStepValue(PARTICLE_MOMENT)[0]
-                self.particle_moment_Y[i] = node.GetSolutionStepValue(PARTICLE_MOMENT)[1]
-                self.particle_moment_Z[i] = node.GetSolutionStepValue(PARTICLE_MOMENT)[2]
-            
-            if self.PostEulerAngles:
-                self.euler_angles_X[i] = node.GetSolutionStepValue(EULER_ANGLES)[0]
-                self.euler_angles_Y[i] = node.GetSolutionStepValue(EULER_ANGLES)[1]
-                self.euler_angles_Z[i] = node.GetSolutionStepValue(EULER_ANGLES)[2]
-            
-            if self.PostRollingResistanceMoment:
-                self.rolling_resistance_moment_X[i] = node.GetSolutionStepValue(ROLLING_RESISTANCE_MOMENT)[0]
-                self.rolling_resistance_moment_Y[i] = node.GetSolutionStepValue(ROLLING_RESISTANCE_MOMENT)[1]
-                self.rolling_resistance_moment_Z[i] = node.GetSolutionStepValue(ROLLING_RESISTANCE_MOMENT)[2]
-            
-            if self.PostNeighbourSize:
-                self.neighbour_size[i] = node.GetSolutionStepValue(EXTERNAL_APPLIED_FORCE)
-            
-            if self.PostDamageRatio:
-                self.damage_ratio[i] = node.GetSolutionStepValue(DAMAGE_RATIO)
-
-            i += 1
-
-    def ConvertContactsToNumpyArrays(self):
-        number_of_elements = self.contact_model_part.NumberOfElements(0)
-        number_of_nodes = number_of_elements * 2
-
-        self.start_and_end_points_X = np.empty(number_of_nodes)
-        self.start_and_end_points_Y = np.empty(number_of_nodes)
-        self.start_and_end_points_Z = np.empty(number_of_nodes)
-
-        if self.PostLocalContactForce:
-            self.local_contact_force_X = np.empty(number_of_elements)
-            self.local_contact_force_Y = np.empty(number_of_elements)
-            self.local_contact_force_Z = np.empty(number_of_elements)
-            self.local_contact_force_X_point = np.empty(number_of_nodes)
-            self.local_contact_force_Y_point = np.empty(number_of_nodes)
-            self.local_contact_force_Z_point = np.empty(number_of_nodes)
-
-        if self.PostFailureCriterionState:
-            self.failure_criterion_state = np.empty(number_of_elements)
-
-        if self.PostContactFailureId:
-            self.contact_failure_id = np.empty(number_of_elements)
-
-        if self.PostContactTau:
-            self.contact_tau = np.empty(number_of_elements)
-            self.contact_tau_point = np.empty(number_of_nodes)
-
-        if self.PostContactSigma:
-            self.contact_sigma = np.empty(number_of_elements)
-            self.contact_sigma_point = np.empty(number_of_nodes)
-
-        if self.PostContactRadius:
-            self.contact_radius = np.empty(number_of_elements)
-            self.contact_radius_point = np.empty(number_of_nodes)
-
-        i_point= 0
-        i_contact = 0
-        for element in self.contact_model_part.Elements:
-            
-            self.start_and_end_points_X[i_point] = element.GetNode(0).X
-            self.start_and_end_points_X[i_point+1] = element.GetNode(1).X
-            self.start_and_end_points_Y[i_point] = element.GetNode(0).Y
-            self.start_and_end_points_Y[i_point+1] = element.GetNode(1).Y
-            self.start_and_end_points_Z[i_point] = element.GetNode(0).Z
-            self.start_and_end_points_Z[i_point+1] = element.GetNode(1).Z
-
-            if self.PostLocalContactForce:
-                self.local_contact_force_X[i_contact] = element.GetValue(LOCAL_CONTACT_FORCE)[0]
-                self.local_contact_force_Y[i_contact] = element.GetValue(LOCAL_CONTACT_FORCE)[1]
-                self.local_contact_force_Z[i_contact] = element.GetValue(LOCAL_CONTACT_FORCE)[2]
-                self.local_contact_force_X_point[i_point] = element.GetValue(LOCAL_CONTACT_FORCE)[0]
-                self.local_contact_force_X_point[i_point+1] = element.GetValue(LOCAL_CONTACT_FORCE)[0]
-                self.local_contact_force_Y_point[i_point] = element.GetValue(LOCAL_CONTACT_FORCE)[1]
-                self.local_contact_force_Y_point[i_point+1] = element.GetValue(LOCAL_CONTACT_FORCE)[1]
-                self.local_contact_force_Z_point[i_point] = element.GetValue(LOCAL_CONTACT_FORCE)[2]
-                self.local_contact_force_Z_point[i_point+1] = element.GetValue(LOCAL_CONTACT_FORCE)[2]
-
-            if self.PostFailureCriterionState:
-                self.failure_criterion_state[i_contact] = element.GetValue(FAILURE_CRITERION_STATE)
-
-            if self.PostContactFailureId:
-                self.contact_failure_id[i_contact] = element.GetValue(CONTACT_FAILURE)
-
-            if self.PostContactTau:
-                self.contact_tau[i_contact] = element.GetValue(CONTACT_TAU)
-                self.contact_tau_point[i_point] = element.GetValue(CONTACT_TAU)
-                self.contact_tau_point[i_point+1] = element.GetValue(CONTACT_TAU)
-
-            if self.PostContactSigma:
-                self.contact_sigma[i_contact] = element.GetValue(CONTACT_SIGMA)
-                self.contact_sigma_point[i_point] = element.GetValue(CONTACT_SIGMA)
-                self.contact_sigma_point[i_point+1] = element.GetValue(CONTACT_SIGMA)
-
-            if self.PostContactRadius:
-                self.contact_radius[i_contact] = element.GetValue(CONTACT_RADIUS)
-                self.contact_radius_point[i_point] = element.GetValue(CONTACT_RADIUS)
-                self.contact_radius_point[i_point+1] = element.GetValue(CONTACT_RADIUS)
-
-            i_point += 2
-            i_contact += 1
-
-    def ConvertWallsToNumpyArrays(self):
-        number_of_nodes = self.rigid_face_model_part.NumberOfNodes(0)
-        self.walls_X = np.empty(number_of_nodes)
-        self.walls_Y = np.empty(number_of_nodes)
-        self.walls_Z = np.empty(number_of_nodes)
-
-        position_of_each_id = {}
-        i = 0
-        for node in self.rigid_face_model_part.Nodes:
-            self.walls_X[i] = node.X
-            self.walls_Y[i] = node.Y
-            self.walls_Z[i] = node.Z
-            position_of_each_id[node.Id] = i
-            i += 1
-
-        number_of_conditions = self.rigid_face_model_part.NumberOfConditions(0)
-        self.walls_connectivity = np.empty(number_of_conditions * 3)
-        self.walls_offsets = np.empty(number_of_conditions)
-        self.walls_cell_types = np.empty(number_of_conditions)
-        i = 0
-        j = 0
-        for cond in self.rigid_face_model_part.Conditions:
-            list_of_vertices = cond.GetNodes()
-            number_of_vertices = len(list_of_vertices)
-            for k in range(number_of_vertices):
-                index_in_array = position_of_each_id[list_of_vertices[k].Id]
-                self.walls_connectivity[i] = index_in_array
-                self.walls_offsets[j] = i+1
-                i += 1
-
-            self.walls_cell_types[j] = vtk.VtkTriangle.tid
-            j += 1
-
-
-    def WriteResults(self, time):
-
-        #---------------Partciles part---------------------
-        self.ConvertParticlesToNumpyArrays()
-        particles_filename = self.problem_name + "_Particles_" + str(self.counter)
-        path = os.path.join(self.vtk_post_path_directory, particles_filename)
-        
-        particles_output_dict = {'material':self.particles_material}
-        
-        if self.PostRadius:
-            particles_output_dict['radius'] = self.particles_R
-
-        if self.PostVelocity:
-            particles_output_dict['velocity'] = (self.velocities_X, self.velocities_Y, self.velocities_Z)
-        
-        if self.PostDisplacement:
-            particles_output_dict['displacement'] = (self.displacement_X, self.displacement_Y, self.displacement_Z)
-
-        if self.PostTotalForces:
-            particles_output_dict['total_forces'] = (self.total_force_X, self.total_force_Y, self.total_force_Z)
-
-        if self.PostNonDimensionalVolumeWear:
-            particles_output_dict['non_dimensional_volume_wear'] = self.non_dimensional_volume_wear
-        
-        if self.PostAppliedForces:
-            particles_output_dict['applied_forces'] = (self.applied_force_X, self.applied_force_Y, self.applied_force_Z)
-
-        if self.PostDampForces:
-            particles_output_dict['damp_forces'] = (self.damp_force_X, self.damp_force_Y, self.damp_force_Z)
-
-        if self.PostGroupId:
-            particles_output_dict['group_id'] = self.group_id
-
-        if self.PostExportId:
-            particles_output_dict['group_id'] = self.export_id
-
-        if self.PostSkinSphere:
-            particles_output_dict['skin_sphere'] = self.skin_sphere
-        
-        if self.PostAngularVelocity:
-            particles_output_dict['angular_velocity'] = (self.angular_velocity_X, self.angular_velocity_Y, self.angular_velocity_Z)
-        
-        if self.PostParticleMoment:
-            particles_output_dict['particle_moment'] = (self.particle_moment_X, self.particle_moment_Y, self.particle_moment_Z)
-        
-        if self.PostEulerAngles:
-            particles_output_dict['euler_angles'] = (self.euler_angles_X, self.euler_angles_Y, self.euler_angles_Z)
-        
-        if self.PostRollingResistanceMoment:
-            particles_output_dict['rolling_resistance_moment'] = (self.rolling_resistance_moment_X, self.rolling_resistance_moment_Y, self.rolling_resistance_moment_Z)
-        
-        if self.PostNeighbourSize:
-            particles_output_dict['neighbour_size'] = self.neighbour_size
-        
-        if self.PostDamageRatio:
-            particles_output_dict['damage_ratio'] = self.damage_ratio
-
-        hl.pointsToVTK(path, self.particles_X, self.particles_Y, self.particles_Z, particles_output_dict)
-
-        #------------------------------Contacts part---------------------------
-        # Tips:
-        #   To display force chain with tube of different radius,
-        #       1. Import the 'Contacts'.vtu file to Paraview;
-        #       2. Apply 'Extract Surface' filter;
-        #       3. Apply 'Tube' filter, and select 'Vary radius'->'By Ansolute Scalar', and set the 'Radius factor' as 1.
-        #----------------------------------------------------------------------
-        self.ConvertContactsToNumpyArrays()
-        contacts_filename = self.problem_name + "_Contacts_" + str(self.counter)
-        path = os.path.join(self.vtk_post_path_directory, contacts_filename)
-
-        contacts_output_dict_cell = {}
-        contacts_output_dict_point = {}
-
-        if self.PostLocalContactForce:
-            contacts_output_dict_cell['local_contact_force'] = (self.local_contact_force_X, self.local_contact_force_Y, self.local_contact_force_Z) 
-            contacts_output_dict_point['local_contact_force'] = (self.local_contact_force_X_point, self.local_contact_force_Y_point, self.local_contact_force_Z_point)
-
-        if self.PostFailureCriterionState:
-            contacts_output_dict_cell['failure_criterion_state'] = self.failure_criterion_state
-
-        if self.PostContactFailureId:
-            contacts_output_dict_cell['contact_failure_id'] = self.contact_failure_id
-
-        if self.PostContactTau:
-            contacts_output_dict_cell['contact_tau'] = self.contact_tau
-            contacts_output_dict_point['contact_tau'] = self.contact_tau_point
-
-        if self.PostContactSigma:
-            contacts_output_dict_cell['contact_sigma'] = self.contact_sigma
-            contacts_output_dict_point['contact_sigma'] = self.contact_sigma_point
-
-        if self.PostContactRadius:
-            contacts_output_dict_cell['contact_radius'] = self.contact_radius
-            contacts_output_dict_point['contact_radius'] = self.contact_radius_point
-
-        hl.linesToVTK(path, self.start_and_end_points_X, self.start_and_end_points_Y, self.start_and_end_points_Z, contacts_output_dict_cell, contacts_output_dict_point)
-        
-        #-------------------------------Walls part------------------------------
-        self.ConvertWallsToNumpyArrays()
-        walls_filename = self.problem_name + "_Walls_" + str(self.counter)
-        path = os.path.join(self.vtk_post_path_directory, walls_filename)
-        hl.unstructuredGridToVTK(path, self.walls_X, self.walls_Y, self.walls_Z, self.walls_connectivity, self.walls_offsets, self.walls_cell_types, cellData=None, pointData=None)
-
-        self.counter += 1
-
+#  Kratos Multi-Physics - DEM Application
+#
+#  License:       BSD License
+#                 Kratos default license: kratos/license.txt
+#
+#  Main authors:  Miguel Angel Celigueta (maceli@cimne.upc.edu)
+#                 Chengshun Shang (cshang@cimne.upc.edu)
+#
+
+import os
+from pyevtk import hl
+from pyevtk import vtk
+import numpy as np
+import weakref
+import shutil
+from KratosMultiphysics import *
+from KratosMultiphysics.DEMApplication import *
+
+def GetBoolParameterIfItExists(set_of_parameters, parameter_key):
+    if parameter_key in set_of_parameters.keys():
+        return set_of_parameters[parameter_key].GetBool()
+    return False
+
+class VtkOutput():
+    def __init__(self, main_path, problem_name, spheres_model_part, contact_model_part, rigid_face_model_part, DEM_parameters):
+        self.problem_name = problem_name
+        self.DEM_parameters = DEM_parameters
+
+        # Reading Post options from DEM_parameters
+        self.PostDisplacement = self.DEM_parameters["PostDisplacement"].GetBool()
+        self.PostVelocity = self.DEM_parameters["PostVelocity"].GetBool()
+        self.PostTotalForces = self.DEM_parameters["PostTotalForces"].GetBool()
+        self.PostNonDimensionalVolumeWear = self.DEM_parameters["PostNonDimensionalVolumeWear"].GetBool()
+        self.PostAppliedForces = self.DEM_parameters["PostAppliedForces"].GetBool()
+        self.PostDampForces = self.DEM_parameters["PostDampForces"].GetBool()
+        self.PostRadius = self.DEM_parameters["PostRadius"].GetBool()
+        self.PostGroupId = GetBoolParameterIfItExists(self.DEM_parameters, "PostGroupId")
+        self.PostExportId = self.DEM_parameters["PostExportId"].GetBool()
+        self.PostSkinSphere = GetBoolParameterIfItExists(self.DEM_parameters, "PostSkinSphere")
+        self.PostGluedSphere = GetBoolParameterIfItExists(self.DEM_parameters, "PostGluedSphere")
+        self.PostAngularVelocity = self.DEM_parameters["PostAngularVelocity"].GetBool()
+        self.PostParticleMoment = self.DEM_parameters["PostParticleMoment"].GetBool()
+        self.PostEulerAngles = self.DEM_parameters["PostEulerAngles"].GetBool()
+        self.PostRollingResistanceMoment = self.DEM_parameters["PostRollingResistanceMoment"].GetBool()
+        self.PostNeighbourSize = GetBoolParameterIfItExists(self.DEM_parameters, "PostNeighbourSize")
+        self.PostDamageRatio = GetBoolParameterIfItExists(self.DEM_parameters, "PostDamageRatio")
+        
+        # for contacts
+        self.PostLocalContactForce = GetBoolParameterIfItExists(self.DEM_parameters, "PostLocalContactForce")
+        self.PostFailureCriterionState = GetBoolParameterIfItExists(self.DEM_parameters, "PostFailureCriterionState")
+        self.PostContactFailureId = GetBoolParameterIfItExists(self.DEM_parameters, "PostContactFailureId")
+        self.PostContactTau = GetBoolParameterIfItExists(self.DEM_parameters, "PostContactTau")
+        self.PostContactSigma = GetBoolParameterIfItExists(self.DEM_parameters, "PostContactSigma")
+        self.PostContactRadius = GetBoolParameterIfItExists(self.DEM_parameters, "PostContactRadius")
+        
+        #TODO: those variables need to be added
+        ''' 
+        self.PostElasticForces = self.DEM_parameters["PostElasticForces"].GetBool()
+        self.PostContactForces = self.DEM_parameters["PostContactForces"].GetBool()
+        self.PostRigidElementForces = self.DEM_parameters["PostRigidElementForces"].GetBool()
+        self.PostPressure = self.DEM_parameters["PostPressure"].GetBool()
+        self.PostTangentialElasticForces = self.DEM_parameters["PostTangentialElasticForces"].GetBool()
+        self.PostShearStress = self.DEM_parameters["PostShearStress"].GetBool()
+        self.PostNodalArea = self.DEM_parameters["PostNodalArea"].GetBool()
+        self.PostNormalImpactVelocity = GetBoolParameterIfItExists(self.DEM_parameters, "PostNormalImpactVelocity")
+        self.PostTangentialImpactVelocity = GetBoolParameterIfItExists(self.DEM_parameters, "PostTangentialImpactVelocity")
+        self.PostControlModule = GetBoolParameterIfItExists(self.DEM_parameters, "PostControlModule")
+        self.VelTrapGraphExportFreq = self.DEM_parameters["VelTrapGraphExportFreq"].GetDouble()
+        self.PostDeltaDisplacement = GetBoolParameterIfItExists(self.DEM_parameters, "PostDeltaDisplacement")
+        self.PostCharacteristicLength = GetBoolParameterIfItExists(self.DEM_parameters, "PostCharacteristicLength")
+        self.PostBoundingBox = GetBoolParameterIfItExists(self.DEM_parameters, "PostBoundingBox")
+        '''
+        self.spheres_model_part = weakref.proxy(spheres_model_part)
+        self.contact_model_part = weakref.proxy(contact_model_part)
+        self.rigid_face_model_part = weakref.proxy(rigid_face_model_part)
+
+        self.vtk_post_path_directory = os.path.join(main_path, problem_name + "_Post_VTK_Files")
+        shutil.rmtree(self.vtk_post_path_directory, ignore_errors=True)
+        os.makedirs(str(self.vtk_post_path_directory))
+
+        self.counter = 0
+
+    def ConvertParticlesToNumpyArrays(self):
+        number_of_nodes = self.spheres_model_part.NumberOfNodes(0)
+
+        self.particles_X = np.empty(number_of_nodes)
+        self.particles_Y = np.empty(number_of_nodes)
+        self.particles_Z = np.empty(number_of_nodes)
+        self.particles_material = np.empty(number_of_nodes)
+
+        if self.PostRadius:
+            self.particles_R = np.empty(number_of_nodes)
+
+        if self.PostVelocity:
+            self.velocities_X = np.empty(number_of_nodes)
+            self.velocities_Y = np.empty(number_of_nodes)
+            self.velocities_Z = np.empty(number_of_nodes)
+        
+        if self.PostDisplacement:
+            self.displacement_X = np.empty(number_of_nodes)
+            self.displacement_Y = np.empty(number_of_nodes)
+            self.displacement_Z = np.empty(number_of_nodes)
+
+        if self.PostTotalForces:
+            self.total_force_X = np.empty(number_of_nodes)
+            self.total_force_Y = np.empty(number_of_nodes)
+            self.total_force_Z = np.empty(number_of_nodes)
+
+        if self.PostNonDimensionalVolumeWear:
+            self.non_dimensional_volume_wear = np.empty(number_of_nodes)
+        
+        if self.PostAppliedForces:
+            self.applied_force_X = np.empty(number_of_nodes)
+            self.applied_force_Y = np.empty(number_of_nodes)
+            self.applied_force_Z = np.empty(number_of_nodes)
+
+        if self.PostDampForces:
+            self.damp_force_X = np.empty(number_of_nodes)
+            self.damp_force_Y = np.empty(number_of_nodes)
+            self.damp_force_Z = np.empty(number_of_nodes)
+
+        if self.PostGroupId:
+            self.group_id = np.empty(number_of_nodes)
+
+        if self.PostExportId:
+            self.export_id = np.empty(number_of_nodes)
+
+        if self.PostSkinSphere:
+            self.skin_sphere = np.empty(number_of_nodes)
+
+        if self.PostGluedSphere:
+            self.glued_sphere = np.empty(number_of_nodes)
+        
+        if self.PostAngularVelocity:
+            self.angular_velocity_X = np.empty(number_of_nodes)
+            self.angular_velocity_Y = np.empty(number_of_nodes)
+            self.angular_velocity_Z = np.empty(number_of_nodes)
+        
+        if self.PostParticleMoment:
+            self.particle_moment_X = np.empty(number_of_nodes)
+            self.particle_moment_Y = np.empty(number_of_nodes)
+            self.particle_moment_Z = np.empty(number_of_nodes)
+        
+        if self.PostEulerAngles:
+            self.euler_angles_X = np.empty(number_of_nodes)
+            self.euler_angles_Y = np.empty(number_of_nodes)
+            self.euler_angles_Z = np.empty(number_of_nodes)
+        
+        if self.PostRollingResistanceMoment:
+            self.rolling_resistance_moment_X = np.empty(number_of_nodes)
+            self.rolling_resistance_moment_Y = np.empty(number_of_nodes)
+            self.rolling_resistance_moment_Z = np.empty(number_of_nodes)
+        
+        if self.PostNeighbourSize:
+            self.neighbour_size = np.empty(number_of_nodes)
+        
+        if self.PostDamageRatio:
+            self.damage_ratio = np.empty(number_of_nodes)
+
+        i = 0
+        for node in self.spheres_model_part.Nodes:
+            self.particles_X[i] = node.X
+            self.particles_Y[i] = node.Y
+            self.particles_Z[i] = node.Z
+            self.particles_material[i] = node.GetSolutionStepValue(PARTICLE_MATERIAL)
+
+            if self.PostRadius:
+                self.particles_R[i] = node.GetSolutionStepValue(RADIUS)
+
+            if self.PostVelocity:
+                self.velocities_X[i] = node.GetSolutionStepValue(VELOCITY_X)
+                self.velocities_Y[i] = node.GetSolutionStepValue(VELOCITY_Y)
+                self.velocities_Z[i] = node.GetSolutionStepValue(VELOCITY_Z)
+            
+            if self.PostDisplacement:
+                self.displacement_X[i] = node.GetSolutionStepValue(DISPLACEMENT_X)
+                self.displacement_Y[i] = node.GetSolutionStepValue(DISPLACEMENT_Y)
+                self.displacement_Z[i] = node.GetSolutionStepValue(DISPLACEMENT_Z)
+
+            if self.PostTotalForces:
+                self.total_force_X[i] = node.GetSolutionStepValue(TOTAL_FORCES)[0]
+                self.total_force_Y[i] = node.GetSolutionStepValue(TOTAL_FORCES)[1]
+                self.total_force_Z[i] = node.GetSolutionStepValue(TOTAL_FORCES)[2]
+
+            if self.PostNonDimensionalVolumeWear:
+                self.non_dimensional_volume_wear[i] = node.GetSolutionStepValue(NON_DIMENSIONAL_VOLUME_WEAR)
+            
+            if self.PostAppliedForces:
+                self.applied_force_X[i] = node.GetSolutionStepValue(EXTERNAL_APPLIED_FORCE)[0]
+                self.applied_force_Y[i] = node.GetSolutionStepValue(EXTERNAL_APPLIED_FORCE)[1]
+                self.applied_force_Z[i] = node.GetSolutionStepValue(EXTERNAL_APPLIED_FORCE)[2]
+
+            if self.PostDampForces:
+                self.damp_force_X[i] = node.GetSolutionStepValue(DAMP_FORCES)[0]
+                self.damp_force_Y[i] = node.GetSolutionStepValue(DAMP_FORCES)[1]
+                self.damp_force_Z[i] = node.GetSolutionStepValue(DAMP_FORCES)[2]
+
+            if self.PostGroupId:
+                self.group_id[i] = node.GetSolutionStepValue(GROUP_ID)
+
+            if self.PostExportId:
+                self.export_id[i] = node.GetSolutionStepValue(EXPORT_ID)
+
+            if self.PostSkinSphere:
+                self.skin_sphere[i] = node.GetSolutionStepValue(SKIN_SPHERE)
+
+            if self.PostGluedSphere:
+                self.glued_sphere[i] = node.GetSolutionStepValue(IS_STICKY)
+            
+            if self.PostAngularVelocity:
+                self.angular_velocity_X[i] = node.GetSolutionStepValue(ANGULAR_VELOCITY)[0]
+                self.angular_velocity_Y[i] = node.GetSolutionStepValue(ANGULAR_VELOCITY)[1]
+                self.angular_velocity_Z[i] = node.GetSolutionStepValue(ANGULAR_VELOCITY)[2]
+            
+            if self.PostParticleMoment:
+                self.particle_moment_X[i] = node.GetSolutionStepValue(PARTICLE_MOMENT)[0]
+                self.particle_moment_Y[i] = node.GetSolutionStepValue(PARTICLE_MOMENT)[1]
+                self.particle_moment_Z[i] = node.GetSolutionStepValue(PARTICLE_MOMENT)[2]
+            
+            if self.PostEulerAngles:
+                self.euler_angles_X[i] = node.GetSolutionStepValue(EULER_ANGLES)[0]
+                self.euler_angles_Y[i] = node.GetSolutionStepValue(EULER_ANGLES)[1]
+                self.euler_angles_Z[i] = node.GetSolutionStepValue(EULER_ANGLES)[2]
+            
+            if self.PostRollingResistanceMoment:
+                self.rolling_resistance_moment_X[i] = node.GetSolutionStepValue(ROLLING_RESISTANCE_MOMENT)[0]
+                self.rolling_resistance_moment_Y[i] = node.GetSolutionStepValue(ROLLING_RESISTANCE_MOMENT)[1]
+                self.rolling_resistance_moment_Z[i] = node.GetSolutionStepValue(ROLLING_RESISTANCE_MOMENT)[2]
+            
+            if self.PostNeighbourSize:
+                self.neighbour_size[i] = node.GetSolutionStepValue(EXTERNAL_APPLIED_FORCE)
+            
+            if self.PostDamageRatio:
+                self.damage_ratio[i] = node.GetSolutionStepValue(DAMAGE_RATIO)
+
+            i += 1
+
+    def ConvertContactsToNumpyArrays(self):
+        number_of_elements = self.contact_model_part.NumberOfElements(0)
+        number_of_nodes = number_of_elements * 2
+
+        self.start_and_end_points_X = np.empty(number_of_nodes)
+        self.start_and_end_points_Y = np.empty(number_of_nodes)
+        self.start_and_end_points_Z = np.empty(number_of_nodes)
+
+        if self.PostLocalContactForce:
+            self.local_contact_force_X = np.empty(number_of_elements)
+            self.local_contact_force_Y = np.empty(number_of_elements)
+            self.local_contact_force_Z = np.empty(number_of_elements)
+            self.local_contact_force_X_point = np.empty(number_of_nodes)
+            self.local_contact_force_Y_point = np.empty(number_of_nodes)
+            self.local_contact_force_Z_point = np.empty(number_of_nodes)
+
+        if self.PostFailureCriterionState:
+            self.failure_criterion_state = np.empty(number_of_elements)
+
+        if self.PostContactFailureId:
+            self.contact_failure_id = np.empty(number_of_elements)
+
+        if self.PostContactTau:
+            self.contact_tau = np.empty(number_of_elements)
+            self.contact_tau_point = np.empty(number_of_nodes)
+
+        if self.PostContactSigma:
+            self.contact_sigma = np.empty(number_of_elements)
+            self.contact_sigma_point = np.empty(number_of_nodes)
+
+        if self.PostContactRadius:
+            self.contact_radius = np.empty(number_of_elements)
+            self.contact_radius_point = np.empty(number_of_nodes)
+
+        i_point= 0
+        i_contact = 0
+        for element in self.contact_model_part.Elements:
+            
+            self.start_and_end_points_X[i_point] = element.GetNode(0).X
+            self.start_and_end_points_X[i_point+1] = element.GetNode(1).X
+            self.start_and_end_points_Y[i_point] = element.GetNode(0).Y
+            self.start_and_end_points_Y[i_point+1] = element.GetNode(1).Y
+            self.start_and_end_points_Z[i_point] = element.GetNode(0).Z
+            self.start_and_end_points_Z[i_point+1] = element.GetNode(1).Z
+
+            if self.PostLocalContactForce:
+                self.local_contact_force_X[i_contact] = element.GetValue(LOCAL_CONTACT_FORCE)[0]
+                self.local_contact_force_Y[i_contact] = element.GetValue(LOCAL_CONTACT_FORCE)[1]
+                self.local_contact_force_Z[i_contact] = element.GetValue(LOCAL_CONTACT_FORCE)[2]
+                self.local_contact_force_X_point[i_point] = element.GetValue(LOCAL_CONTACT_FORCE)[0]
+                self.local_contact_force_X_point[i_point+1] = element.GetValue(LOCAL_CONTACT_FORCE)[0]
+                self.local_contact_force_Y_point[i_point] = element.GetValue(LOCAL_CONTACT_FORCE)[1]
+                self.local_contact_force_Y_point[i_point+1] = element.GetValue(LOCAL_CONTACT_FORCE)[1]
+                self.local_contact_force_Z_point[i_point] = element.GetValue(LOCAL_CONTACT_FORCE)[2]
+                self.local_contact_force_Z_point[i_point+1] = element.GetValue(LOCAL_CONTACT_FORCE)[2]
+
+            if self.PostFailureCriterionState:
+                self.failure_criterion_state[i_contact] = element.GetValue(FAILURE_CRITERION_STATE)
+
+            if self.PostContactFailureId:
+                self.contact_failure_id[i_contact] = element.GetValue(CONTACT_FAILURE)
+
+            if self.PostContactTau:
+                self.contact_tau[i_contact] = element.GetValue(CONTACT_TAU)
+                self.contact_tau_point[i_point] = element.GetValue(CONTACT_TAU)
+                self.contact_tau_point[i_point+1] = element.GetValue(CONTACT_TAU)
+
+            if self.PostContactSigma:
+                self.contact_sigma[i_contact] = element.GetValue(CONTACT_SIGMA)
+                self.contact_sigma_point[i_point] = element.GetValue(CONTACT_SIGMA)
+                self.contact_sigma_point[i_point+1] = element.GetValue(CONTACT_SIGMA)
+
+            if self.PostContactRadius:
+                self.contact_radius[i_contact] = element.GetValue(CONTACT_RADIUS)
+                self.contact_radius_point[i_point] = element.GetValue(CONTACT_RADIUS)
+                self.contact_radius_point[i_point+1] = element.GetValue(CONTACT_RADIUS)
+
+            i_point += 2
+            i_contact += 1
+
+    def ConvertWallsToNumpyArrays(self):
+        number_of_nodes = self.rigid_face_model_part.NumberOfNodes(0)
+        self.walls_X = np.empty(number_of_nodes)
+        self.walls_Y = np.empty(number_of_nodes)
+        self.walls_Z = np.empty(number_of_nodes)
+
+        position_of_each_id = {}
+        i = 0
+        for node in self.rigid_face_model_part.Nodes:
+            self.walls_X[i] = node.X
+            self.walls_Y[i] = node.Y
+            self.walls_Z[i] = node.Z
+            position_of_each_id[node.Id] = i
+            i += 1
+
+        number_of_conditions = self.rigid_face_model_part.NumberOfConditions(0)
+        self.walls_connectivity = np.empty(number_of_conditions * 3)
+        self.walls_offsets = np.empty(number_of_conditions)
+        self.walls_cell_types = np.empty(number_of_conditions)
+        i = 0
+        j = 0
+        for cond in self.rigid_face_model_part.Conditions:
+            list_of_vertices = cond.GetNodes()
+            number_of_vertices = len(list_of_vertices)
+            for k in range(number_of_vertices):
+                index_in_array = position_of_each_id[list_of_vertices[k].Id]
+                self.walls_connectivity[i] = index_in_array
+                self.walls_offsets[j] = i+1
+                i += 1
+
+            self.walls_cell_types[j] = vtk.VtkTriangle.tid
+            j += 1
+
+
+    def WriteResults(self, time):
+
+        #---------------Partciles part---------------------
+        self.ConvertParticlesToNumpyArrays()
+        particles_filename = self.problem_name + "_Particles_" + str(self.counter)
+        path = os.path.join(self.vtk_post_path_directory, particles_filename)
+        
+        particles_output_dict = {'material':self.particles_material}
+        
+        if self.PostRadius:
+            particles_output_dict['radius'] = self.particles_R
+
+        if self.PostVelocity:
+            particles_output_dict['velocity'] = (self.velocities_X, self.velocities_Y, self.velocities_Z)
+        
+        if self.PostDisplacement:
+            particles_output_dict['displacement'] = (self.displacement_X, self.displacement_Y, self.displacement_Z)
+
+        if self.PostTotalForces:
+            particles_output_dict['total_forces'] = (self.total_force_X, self.total_force_Y, self.total_force_Z)
+
+        if self.PostNonDimensionalVolumeWear:
+            particles_output_dict['non_dimensional_volume_wear'] = self.non_dimensional_volume_wear
+        
+        if self.PostAppliedForces:
+            particles_output_dict['applied_forces'] = (self.applied_force_X, self.applied_force_Y, self.applied_force_Z)
+
+        if self.PostDampForces:
+            particles_output_dict['damp_forces'] = (self.damp_force_X, self.damp_force_Y, self.damp_force_Z)
+
+        if self.PostGroupId:
+            particles_output_dict['group_id'] = self.group_id
+
+        if self.PostExportId:
+            particles_output_dict['group_id'] = self.export_id
+
+        if self.PostSkinSphere:
+            particles_output_dict['skin_sphere'] = self.skin_sphere
+        
+        if self.PostAngularVelocity:
+            particles_output_dict['angular_velocity'] = (self.angular_velocity_X, self.angular_velocity_Y, self.angular_velocity_Z)
+        
+        if self.PostParticleMoment:
+            particles_output_dict['particle_moment'] = (self.particle_moment_X, self.particle_moment_Y, self.particle_moment_Z)
+        
+        if self.PostEulerAngles:
+            particles_output_dict['euler_angles'] = (self.euler_angles_X, self.euler_angles_Y, self.euler_angles_Z)
+        
+        if self.PostRollingResistanceMoment:
+            particles_output_dict['rolling_resistance_moment'] = (self.rolling_resistance_moment_X, self.rolling_resistance_moment_Y, self.rolling_resistance_moment_Z)
+        
+        if self.PostNeighbourSize:
+            particles_output_dict['neighbour_size'] = self.neighbour_size
+        
+        if self.PostDamageRatio:
+            particles_output_dict['damage_ratio'] = self.damage_ratio
+
+        hl.pointsToVTK(path, self.particles_X, self.particles_Y, self.particles_Z, particles_output_dict)
+
+        #------------------------------Contacts part---------------------------
+        # Tips:
+        #   To display force chain with tube of different radius,
+        #       1. Import the 'Contacts'.vtu file to Paraview;
+        #       2. Apply 'Extract Surface' filter;
+        #       3. Apply 'Tube' filter, and select 'Vary radius'->'By Ansolute Scalar', and set the 'Radius factor' as 1.
+        #----------------------------------------------------------------------
+        self.ConvertContactsToNumpyArrays()
+        contacts_filename = self.problem_name + "_Contacts_" + str(self.counter)
+        path = os.path.join(self.vtk_post_path_directory, contacts_filename)
+
+        contacts_output_dict_cell = {}
+        contacts_output_dict_point = {}
+
+        if self.PostLocalContactForce:
+            contacts_output_dict_cell['local_contact_force'] = (self.local_contact_force_X, self.local_contact_force_Y, self.local_contact_force_Z) 
+            contacts_output_dict_point['local_contact_force'] = (self.local_contact_force_X_point, self.local_contact_force_Y_point, self.local_contact_force_Z_point)
+
+        if self.PostFailureCriterionState:
+            contacts_output_dict_cell['failure_criterion_state'] = self.failure_criterion_state
+
+        if self.PostContactFailureId:
+            contacts_output_dict_cell['contact_failure_id'] = self.contact_failure_id
+
+        if self.PostContactTau:
+            contacts_output_dict_cell['contact_tau'] = self.contact_tau
+            contacts_output_dict_point['contact_tau'] = self.contact_tau_point
+
+        if self.PostContactSigma:
+            contacts_output_dict_cell['contact_sigma'] = self.contact_sigma
+            contacts_output_dict_point['contact_sigma'] = self.contact_sigma_point
+
+        if self.PostContactRadius:
+            contacts_output_dict_cell['contact_radius'] = self.contact_radius
+            contacts_output_dict_point['contact_radius'] = self.contact_radius_point
+
+        hl.linesToVTK(path, self.start_and_end_points_X, self.start_and_end_points_Y, self.start_and_end_points_Z, contacts_output_dict_cell, contacts_output_dict_point)
+        
+        #-------------------------------Walls part------------------------------
+        self.ConvertWallsToNumpyArrays()
+        walls_filename = self.problem_name + "_Walls_" + str(self.counter)
+        path = os.path.join(self.vtk_post_path_directory, walls_filename)
+        hl.unstructuredGridToVTK(path, self.walls_X, self.walls_Y, self.walls_Z, self.walls_connectivity, self.walls_offsets, self.walls_cell_types, cellData=None, pointData=None)
+
+        self.counter += 1
+
```

## KratosMultiphysics/DEMApplication/control_module_2d_process.py

 * *Ordering differences only*

```diff
@@ -1,29 +1,29 @@
-import KratosMultiphysics
-import KratosMultiphysics.DEMApplication as Dem
-
-def Factory(settings, Model):
-    if not isinstance(settings, KratosMultiphysics.Parameters):
-        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
-    return ControlModule2DProcess(Model, settings["Parameters"])
-
-## All the processes python should be derived from "Process"
-
-class ControlModule2DProcess(KratosMultiphysics.Process):
-    def __init__(self, Model, settings ):
-        KratosMultiphysics.Process.__init__(self)
-
-        # Control module process acting on the imposed direction: 0 (X), 1 (Y), 2 (Z) or 3 (radial)
-        # The radial direction is valid only for the vertical walls of a right cylinder with the base
-        # on the 'X-Y' plane centered on (0,0). Negative target_stress means compression.
-
-        self.model_part = Model[settings["model_part_name"].GetString()]
-        self.control_module_process = Dem.ControlModule2DProcess(self.model_part, settings)
-
-    def ExecuteInitialize(self):
-        self.control_module_process.ExecuteInitialize()
-
-    def ExecuteInitializeSolutionStep(self):
-        self.control_module_process.ExecuteInitializeSolutionStep()
-
-    def ExecuteFinalizeSolutionStep(self):
+import KratosMultiphysics
+import KratosMultiphysics.DEMApplication as Dem
+
+def Factory(settings, Model):
+    if not isinstance(settings, KratosMultiphysics.Parameters):
+        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
+    return ControlModule2DProcess(Model, settings["Parameters"])
+
+## All the processes python should be derived from "Process"
+
+class ControlModule2DProcess(KratosMultiphysics.Process):
+    def __init__(self, Model, settings ):
+        KratosMultiphysics.Process.__init__(self)
+
+        # Control module process acting on the imposed direction: 0 (X), 1 (Y), 2 (Z) or 3 (radial)
+        # The radial direction is valid only for the vertical walls of a right cylinder with the base
+        # on the 'X-Y' plane centered on (0,0). Negative target_stress means compression.
+
+        self.model_part = Model[settings["model_part_name"].GetString()]
+        self.control_module_process = Dem.ControlModule2DProcess(self.model_part, settings)
+
+    def ExecuteInitialize(self):
+        self.control_module_process.ExecuteInitialize()
+
+    def ExecuteInitializeSolutionStep(self):
+        self.control_module_process.ExecuteInitializeSolutionStep()
+
+    def ExecuteFinalizeSolutionStep(self):
         self.control_module_process.ExecuteFinalizeSolutionStep()
```

## KratosMultiphysics/DEMApplication/DEM_analysis_stage.py

 * *Ordering differences only*

```diff
@@ -1,1147 +1,1147 @@
-import time as timer
-import os
-import sys
-import pathlib
-import math
-import numpy as np
-from KratosMultiphysics import *
-from KratosMultiphysics.DEMApplication import *
-from KratosMultiphysics.analysis_stage import AnalysisStage
-from KratosMultiphysics.DEMApplication.DEM_restart_utility import DEMRestartUtility
-import KratosMultiphysics.DEMApplication.dem_default_input_parameters
-from KratosMultiphysics.DEMApplication.analytic_tools import analytic_data_procedures
-from KratosMultiphysics.DEMApplication.materials_assignation_utility import MaterialsAssignationUtility
-
-from importlib import import_module
-
-if IsDistributedRun():
-    if "DO_NOT_PARTITION_DOMAIN" in os.environ:
-        Logger.PrintInfo("DEM", "Running under MPI........")
-        from KratosMultiphysics.mpi import *
-        import KratosMultiphysics.DEMApplication.DEM_procedures_mpi_no_partitions as DEM_procedures
-    else:
-        Logger.PrintInfo("DEM", "Running under OpenMP........")
-        from KratosMultiphysics.MetisApplication import *
-        from KratosMultiphysics.MPISearchApplication import *
-        from KratosMultiphysics.mpi import *
-        import KratosMultiphysics.DEMApplication.DEM_procedures_mpi as DEM_procedures
-else:
-    Logger.PrintInfo("DEM", "Running under OpenMP........")
-    import KratosMultiphysics.DEMApplication.DEM_procedures as DEM_procedures
-
-class DEMAnalysisStage(AnalysisStage):
-
-    def GetParametersFileName(self):
-        return "ProjectParametersDEM.json"
-
-    def GetInputParameters(self):
-        self.KratosPrintWarning('Warning: Calls to this method (GetInputParameters) will become deprecated in the near future.')
-        parameters_file_name = self.GetParametersFileName()
-        parameters_file = open(parameters_file_name, 'r')
-        return Parameters(parameters_file.read())
-
-    def LoadParametersFile(self):
-        self.KratosPrintWarning('Warning: Calls to this method (LoadParametersFile) will become deprecated in the near future.')
-        self.DEM_parameters = self.GetInputParameters()
-        self.project_parameters = self.DEM_parameters
-        default_input_parameters = self.GetDefaultInputParameters()
-        self.DEM_parameters.ValidateAndAssignDefaults(default_input_parameters)
-        self.FixParametersInconsistencies()
-
-    def FixParametersInconsistencies(self): # TODO: This is here to avoid inconsistencies until the jsons become standard
-        final_time = self.DEM_parameters["FinalTime"].GetDouble()
-        problem_name = self.DEM_parameters["problem_name"].GetString()
-        self.project_parameters["problem_data"]["end_time"].SetDouble(final_time)
-        self.project_parameters["problem_data"]["problem_name"].SetString(problem_name)
-
-    def GetDefaultInputParameters(self):
-        return KratosMultiphysics.DEMApplication.dem_default_input_parameters.GetDefaultInputParameters()
-
-    def model_part_reader(self, modelpart, nodeid=0, elemid=0, condid=0):
-        return ReorderConsecutiveFromGivenIdsModelPartIO(modelpart, nodeid, elemid, condid, IO.SKIP_TIMER)
-
-    def GetMainPath(self):
-        return os.getcwd()
-
-    def __init__(self, model, DEM_parameters):
-        self.model = model
-        self.main_path = self.GetMainPath()
-        self.mdpas_folder_path = self.main_path
-
-        self.DEM_parameters = DEM_parameters    # TODO, can be improved
-        self.project_parameters = DEM_parameters
-        default_input_parameters = self.GetDefaultInputParameters()
-        self.DEM_parameters.ValidateAndAssignDefaults(default_input_parameters)
-        self.FixParametersInconsistencies()
-
-        self.do_print_results_option = self.DEM_parameters["do_print_results_option"].GetBool()
-        if not "WriteMdpaFromResults" in self.DEM_parameters.keys():
-            self.write_mdpa_from_results = False
-        else:
-            self.write_mdpa_from_results = self.DEM_parameters["WriteMdpaFromResults"].GetBool()
-        self.creator_destructor = self.SetParticleCreatorDestructor(DEM_parameters["creator_destructor_settings"])
-        self.dem_fem_search = self.SetDemFemSearch()
-        self.procedures = self.SetProcedures()
-        self.PreUtilities = PreUtilities()
-
-        # Set the print function TO_DO: do this better...
-        self.KratosPrintInfo = self.procedures.KratosPrintInfo
-
-        # Creating necessary directories:
-        self.problem_name = self.GetProblemTypeFileName()
-
-        [self.post_path, self.graphs_path] = self.procedures.CreateDirectories(str(self.main_path), str(self.problem_name), do_print_results=self.do_print_results_option)
-
-        # Prepare modelparts
-        self.CreateModelParts()
-
-        if self.do_print_results_option:
-            self.SetGraphicalOutput()
-        self.report = DEM_procedures.Report()
-        self.parallelutils = DEM_procedures.ParallelUtils()
-        self.translational_scheme = self.SetTranslationalScheme()
-        self.rotational_scheme = self.SetRotationalScheme()
-
-        # Define control variables
-        self.p_frequency = 100   # activate every 100 steps
-        self.step_count = 0
-        self.p_count = self.p_frequency
-
-        #self._solver = self._GetSolver()
-        self.SetFinalTime()
-        self.AddVariables()
-
-        super().__init__(model, self.DEM_parameters)
-
-    def CreateModelParts(self):
-        self.spheres_model_part = self.model.CreateModelPart("SpheresPart")
-        self.rigid_face_model_part = self.model.CreateModelPart("RigidFacePart")
-        self.cluster_model_part = self.model.CreateModelPart("ClusterPart")
-        self.dem_inlet_model_part = self.model.CreateModelPart("DEMInletPart")
-        self.mapping_model_part = self.model.CreateModelPart("MappingPart")
-        self.contact_model_part = self.model.CreateModelPart("ContactPart")
-
-        mp_list = []
-        mp_list.append(self.spheres_model_part)
-        mp_list.append(self.rigid_face_model_part)
-        mp_list.append(self.cluster_model_part)
-        mp_list.append(self.dem_inlet_model_part)
-        mp_list.append(self.mapping_model_part)
-        mp_list.append(self.contact_model_part)
-
-        self.all_model_parts = DEM_procedures.SetOfModelParts(mp_list)
-
-    def IsCountStep(self):
-        self.step_count += 1
-        if self.step_count == self.p_count:
-            self.p_count += self.p_frequency
-            return True
-
-        return False
-
-    def SetAnalyticWatchers(self):
-        self.SurfacesAnalyzerClass = analytic_data_procedures.SurfacesAnalyzerClass(self.rigid_face_model_part.SubModelParts, self.main_path)
-
-        if self.post_normal_impact_velocity_option:
-            self.ParticlesAnalyzerClass = analytic_data_procedures.ParticlesAnalyzerClass(self.analytic_model_part)
-
-    def MakeAnalyticsMeasurements(self):
-        self.SurfacesAnalyzerClass.MakeAnalyticsMeasurements()
-
-        if self.post_normal_impact_velocity_option:
-            self.ParticlesAnalyzerClass.MakeAnalyticsMeasurements()
-
-    def SetFinalTime(self):
-        self.end_time = self.DEM_parameters["FinalTime"].GetDouble()
-
-    def SetProcedures(self):
-        return DEM_procedures.Procedures(self.DEM_parameters)
-
-    def SetDemFemSearch(self):
-        return DEM_FEM_Search()
-
-    def GetParticleHistoryWatcher(self):
-        return None
-
-    def SetParticleCreatorDestructor(self, creator_destructor_settings):
-
-        self.watcher = self.GetParticleHistoryWatcher()
-
-        if self.watcher is None:
-            return ParticleCreatorDestructor(creator_destructor_settings)
-        return ParticleCreatorDestructor(self.watcher, creator_destructor_settings)
-
-    def SelectTranslationalScheme(self):
-        if self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Forward_Euler':
-            return ForwardEulerScheme()
-        elif self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Symplectic_Euler':
-            return SymplecticEulerScheme()
-        elif self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Taylor_Scheme':
-            return TaylorScheme()
-        elif self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Velocity_Verlet':
-            return VelocityVerletScheme()
-
-        return None
-
-    def SelectRotationalScheme(self):
-        if self.DEM_parameters["RotationalIntegrationScheme"].GetString() == 'Direct_Integration':
-            return self.SelectTranslationalScheme()
-        elif self.DEM_parameters["RotationalIntegrationScheme"].GetString() == 'Runge_Kutta':
-            return RungeKuttaScheme()
-        elif self.DEM_parameters["RotationalIntegrationScheme"].GetString() == 'Quaternion_Integration':
-            return QuaternionIntegrationScheme()
-
-        return None
-
-    def SetTranslationalScheme(self):
-        translational_scheme = self.SelectTranslationalScheme()
-
-        if translational_scheme is None:
-            raise Exception('Error: selected translational integration scheme not defined. Please select a different scheme')
-
-        return translational_scheme
-
-    def SetRotationalScheme(self):
-        rotational_scheme = self.SelectRotationalScheme()
-
-        if rotational_scheme is None:
-            raise Exception('Error: selected rotational integration scheme not defined. Please select a different scheme')
-
-        return rotational_scheme
-
-    def SetSolver(self):        # TODO why is this still here. -> main_script calls retrocompatibility
-        return self._CreateSolver()
-
-    def _CreateSolver(self):
-        def SetSolverStrategy():
-            strategy_file_name = self.DEM_parameters["solver_settings"]["strategy"].GetString()
-            imported_module = import_module("KratosMultiphysics.DEMApplication" + "." + strategy_file_name)
-            return imported_module
-
-        return SetSolverStrategy().ExplicitStrategy(self.all_model_parts,
-                                                    self.creator_destructor,
-                                                    self.dem_fem_search,
-                                                    self.DEM_parameters,
-                                                    self.procedures)
-
-    def AddVariables(self):
-        self.procedures.AddAllVariablesInAllModelParts(self._GetSolver(), self.translational_scheme, self.rotational_scheme, self.all_model_parts, self.DEM_parameters)
-
-    def FillAnalyticSubModelParts(self):
-        if not self.spheres_model_part.HasSubModelPart("AnalyticParticlesPart"):
-            self.spheres_model_part.CreateSubModelPart('AnalyticParticlesPart')
-        self.analytic_model_part = self.spheres_model_part.GetSubModelPart('AnalyticParticlesPart')
-        analytic_particle_ids = [elem.Id for elem in self.spheres_model_part.Elements]
-        self.analytic_model_part.AddElements(analytic_particle_ids)
-        analytic_node_ids = [node.Id for node in self.spheres_model_part.Nodes]
-        self.analytic_model_part.AddNodes(analytic_node_ids)
-
-    def FillAnalyticSubModelPartsWithNewParticles(self):
-        self.analytic_model_part = self.spheres_model_part.GetSubModelPart('AnalyticParticlesPart')
-        self.PreUtilities.FillAnalyticSubModelPartUtility(self.spheres_model_part, self.analytic_model_part)
-        #analytic_particle_ids = [elem.Id for elem in self.spheres_model_part.Elements]
-        #self.analytic_model_part.AddElements(analytic_particle_ids)
-
-    def Initialize(self):
-        self.time = 0.0
-        self.time_old_print = 0.0
-
-        self.ReadModelParts()
-
-        self.SetMaterials()
-
-        self.post_normal_impact_velocity_option = False
-        if "PostNormalImpactVelocity" in self.DEM_parameters.keys():
-            if self.DEM_parameters["PostNormalImpactVelocity"].GetBool():
-                self.post_normal_impact_velocity_option = True
-                self.FillAnalyticSubModelParts()
-
-        self.SetAnalyticWatchers()
-
-        # Setting up the buffer size
-        self.procedures.SetUpBufferSizeInAllModelParts(self.spheres_model_part, 1, self.cluster_model_part, 1, self.dem_inlet_model_part, 1, self.rigid_face_model_part, 1)
-
-        self.KratosPrintInfo("Initializing Problem...")
-
-        self.GraphicalOutputInitialize()
-
-        # Perform a partition to balance the problem
-        self.SetSearchStrategy()
-
-        self.SolverBeforeInitialize()
-
-        self.parallelutils.Repart(self.spheres_model_part)
-
-        #Setting up the BoundingBox
-        self.bounding_box_time_limits = self.procedures.SetBoundingBoxLimits(self.all_model_parts, self.creator_destructor)
-
-        self.creator_destructor.SetMaxNodeId(self.all_model_parts.MaxNodeId)
-
-        self.DEMFEMProcedures = DEM_procedures.DEMFEMProcedures(self.DEM_parameters, self.graphs_path, self.spheres_model_part, self.rigid_face_model_part)
-
-        self.DEMEnergyCalculator = DEM_procedures.DEMEnergyCalculator(self.DEM_parameters, self.spheres_model_part, self.cluster_model_part, self.graphs_path, "EnergyPlot.grf")
-
-        self.KratosPrintInfo("Initialization Complete")
-
-        self.report.Prepare(timer, self.DEM_parameters["ControlTime"].GetDouble())
-
-        self.post_utils = DEM_procedures.PostUtils(self.DEM_parameters, self.spheres_model_part)
-        self.report.total_steps_expected = int(self.end_time / self._GetSolver().dt)
-
-        super().Initialize()
-
-        self.seed = self.DEM_parameters["seed"].GetInt()
-        #Constructing a model part for the DEM inlet. It contains the DEM elements to be released during the simulation
-        #Initializing the DEM solver must be done before creating the DEM Inlet, because the Inlet configures itself according to some options of the DEM model part
-        self.SetInlet()
-
-        self.SetInitialNodalValues()
-
-        self.KratosPrintInfo(self.report.BeginReport(timer))
-
-        if self.DEM_parameters["output_configuration"]["print_number_of_neighbours_histogram"].GetBool():
-            self.PreUtilities.PrintNumberOfNeighboursHistogram(self.spheres_model_part, os.path.join(self.graphs_path, "number_of_neighbours_histogram.txt"))
-
-    def SetMaterials(self):
-
-        self.ReadMaterialsFile()
-
-        model_part_import_settings = self.DEM_parameters["solver_settings"]["model_import_settings"]
-        input_type = model_part_import_settings["input_type"].GetString()
-        if input_type == "rest":
-            return
-
-        materials_setter = MaterialsAssignationUtility(self.model, self.spheres_model_part, self.DEM_material_parameters)
-        materials_setter.AssignMaterialParametersToProperties()
-        materials_setter.AssignPropertiesToEntities()
-
-    def ReadMaterialsFile(self):
-        adapted_to_current_os_relative_path = pathlib.Path(self.DEM_parameters["solver_settings"]["material_import_settings"]["materials_filename"].GetString())
-        materials_file_abs_path = os.path.join(self.main_path, str(adapted_to_current_os_relative_path))
-        with open(materials_file_abs_path, 'r') as materials_file:
-            self.DEM_material_parameters = Parameters(materials_file.read())
-
-    def SetSearchStrategy(self):
-        self._GetSolver().search_strategy = self.parallelutils.GetSearchStrategy(self._GetSolver(), self.spheres_model_part)
-
-    def SolverBeforeInitialize(self):
-        self._GetSolver().BeforeInitialize()
-
-    def SolverInitialize(self):
-        self._GetSolver().Initialize() # Possible modifications of number of elements and number of nodes
-
-    def GetProblemNameWithPath(self):
-        return os.path.join(self.mdpas_folder_path, self.DEM_parameters["problem_name"].GetString())
-
-    def GetDiscreteElementsInputFileTag(self):
-        return 'DEM'
-
-    def GetDEMInletInputFileTag(self):
-        return 'DEM_Inlet'
-
-    def GetDEMWallsInputFileTag(self):
-        return 'DEM_FEM_boundary'
-
-    def GetDEMClustersInputFileTag(self):
-        return 'DEM_Clusters'
-
-    def GetDiscreteElementsInputFilePath(self):
-        return self.GetInputFilePath(self.GetDiscreteElementsInputFileTag())
-
-    def GetDEMInletInputFilePath(self):
-        return self.GetInputFilePath(self.GetDEMInletInputFileTag())
-
-    def GetDEMWallsInputFilePath(self):
-        return self.GetInputFilePath(self.GetDEMWallsInputFileTag())
-
-    def GetDEMClustersInputFilePath(self):
-        return self.GetInputFilePath(self.GetDEMClustersInputFileTag())
-
-    def GetMpFilePath(self):
-        return GetInputFilePath('DEM')
-
-    def GetInletFilePath(self):
-        return GetInputFilePath('DEM_Inlet')
-
-    def GetFemFilePath(self):
-        return GetInputFilePath('DEM_FEM_boundary')
-
-    def GetClusterFilePath(self):
-        return GetInputFilePath('DEM_Clusters')
-
-    def GetInputFilePath(self, file_tag=''):
-        return self.GetProblemNameWithPath() + file_tag
-
-    def GetProblemTypeFileName(self):
-        return self.DEM_parameters["problem_name"].GetString()
-
-    def ReadModelPartsFromRestartFile(self, model_part_import_settings):
-        Logger.PrintInfo('DEM', 'Loading model parts from restart file...')
-        DEMRestartUtility(self.model, self._GetSolver()._GetRestartSettings(model_part_import_settings)).LoadRestart()
-        Logger.PrintInfo('DEM', 'Finished loading model parts from restart file.')
-
-    def ReadModelPartsFromMdpaFile(self, max_node_id, max_elem_id, max_cond_id):
-        def UpdateMaxIds(max_node_id, max_elem_id, max_cond_id, model_part):
-            max_node_id = max(max_node_id, self.creator_destructor.FindMaxNodeIdInModelPart(model_part))
-            max_elem_id = max(max_elem_id, self.creator_destructor.FindMaxElementIdInModelPart(model_part))
-            max_cond_id = max(max_cond_id, self.creator_destructor.FindMaxConditionIdInModelPart(model_part))
-            return max_node_id, max_elem_id, max_cond_id
-
-        def ReadModelPart(model_part, file_tag, max_node_id, max_elem_id, max_cond_id):
-            file_path = self.GetInputFilePath(file_tag)
-
-            if not os.path.isfile(file_path + '.mdpa'):
-                self.KratosPrintInfo('Input file ' + file_tag + '.mdpa' + ' not found. Continuing.')
-                return
-
-            if model_part.Name == 'SpheresPart':
-                model_part_io = self.model_part_reader(file_path, max_node_id, max_elem_id, max_cond_id)
-
-                do_perform_initial_partition = True
-                if self.DEM_parameters.Has("do_not_perform_initial_partition"):
-                    if self.DEM_parameters["do_not_perform_initial_partition"].GetBool():
-                        do_perform_initial_partition = False
-
-                if do_perform_initial_partition:
-                    self.parallelutils.PerformInitialPartition(model_part_io)
-
-                model_part_io, model_part = self.parallelutils.SetCommunicator(
-                                                model_part,
-                                                model_part_io,
-                                                file_path)
-            else:
-                model_part_io = self.model_part_reader(file_path, max_node_id + 1, max_elem_id + 1, max_cond_id + 1)
-
-            model_part_io.ReadModelPart(model_part)
-
-        ReadModelPart(self.spheres_model_part, self.GetDiscreteElementsInputFileTag(), max_node_id, max_elem_id, max_cond_id)
-        max_node_id, max_elem_id, max_cond_id = UpdateMaxIds(max_node_id, max_elem_id, max_cond_id, self.spheres_model_part)
-        old_max_elem_id_spheres = max_elem_id
-
-        ReadModelPart(self.rigid_face_model_part, self.GetDEMWallsInputFileTag(), max_node_id, max_elem_id, max_cond_id)
-
-        max_node_id, max_elem_id, max_cond_id = UpdateMaxIds(max_node_id, max_elem_id, max_cond_id, self.rigid_face_model_part)
-
-        ReadModelPart(self.cluster_model_part, self.GetDEMClustersInputFileTag(), max_node_id, max_elem_id, max_cond_id)
-
-        max_elem_id = self.creator_destructor.FindMaxElementIdInModelPart(self.spheres_model_part)
-
-        # Clusters generate extra spheres, so the following step is necessary
-        if max_elem_id != old_max_elem_id_spheres:
-            self.creator_destructor.RenumberElementIdsFromGivenValue(self.cluster_model_part, max_elem_id)
-
-        max_node_id, max_elem_id, max_cond_id = UpdateMaxIds(max_node_id, max_elem_id, max_cond_id, self.cluster_model_part)
-
-        ReadModelPart(self.dem_inlet_model_part, self.GetDEMInletInputFileTag(), max_node_id, max_elem_id, max_cond_id)
-
-    def ReadModelParts(self, max_node_id=0, max_elem_id=0, max_cond_id=0):
-
-        model_part_import_settings = self.DEM_parameters["solver_settings"]["model_import_settings"]
-        input_type = model_part_import_settings["input_type"].GetString()
-
-        if input_type == "rest":
-            self.ReadModelPartsFromRestartFile(model_part_import_settings)
-        elif input_type == "mdpa":
-            self.ReadModelPartsFromMdpaFile(max_node_id, max_elem_id, max_cond_id)
-        else:
-            raise Exception('DEM', 'Model part input option \'' + input_type + '\' is not yet implemented.')
-
-        self.model_parts_have_been_read = True
-        self.all_model_parts.ComputeMaxIds()
-        self.ConvertClusterFileNamesFromRelativePathToAbsolutePath()
-        self.CheckConsistencyOfElementsAndNodesInEverySubModelPart()
-
-    def CheckConsistencyOfElementsAndNodesInEverySubModelPart(self):
-        def ErrorMessage(name):
-            raise Exception(" ModelPart (or SubModelPart) "+ name + " has a different number of nodes and elements (particles)! \n")
-
-        if self.spheres_model_part.NumberOfNodes(0) != self.spheres_model_part.NumberOfElements(0):
-            ErrorMessage(self.spheres_model_part.Name)
-        if self.cluster_model_part.NumberOfNodes(0) != self.cluster_model_part.NumberOfElements(0):
-            ErrorMessage(self.cluster_model_part.Name)
-
-        for submp in self.spheres_model_part.SubModelParts:
-            if submp.NumberOfNodes(0) != submp.NumberOfElements(0):
-                ErrorMessage(submp.Name)
-
-        for submp in self.cluster_model_part.SubModelParts:
-            if submp.NumberOfNodes(0) != submp.NumberOfElements(0):
-                ErrorMessage(submp.Name)
-
-    def ConvertClusterFileNamesFromRelativePathToAbsolutePath(self):
-        for properties in self.cluster_model_part.Properties:
-            if properties.Has(CLUSTER_FILE_NAME):
-                cluster_file_name = properties[CLUSTER_FILE_NAME]
-                properties[CLUSTER_FILE_NAME] = os.path.join(self.main_path, cluster_file_name)
-
-        for submp in self.dem_inlet_model_part.SubModelParts:
-            if submp.Has(CLUSTER_FILE_NAME):
-                cluster_file_name = submp[CLUSTER_FILE_NAME]
-                submp[CLUSTER_FILE_NAME] = os.path.join(self.main_path, cluster_file_name)
-
-    def RunAnalytics(self, time):
-        self.MakeAnalyticsMeasurements()
-        if self.IsTimeToPrintPostProcess():
-            self.SurfacesAnalyzerClass.MakeAnalyticsPipeLine(time)
-
-        if self.post_normal_impact_velocity_option and self.IsTimeToPrintPostProcess():
-            self.ParticlesAnalyzerClass.SetNodalMaxImpactVelocities()
-            self.ParticlesAnalyzerClass.SetNodalMaxFaceImpactVelocities()
-
-    def IsTimeToPrintPostProcess(self):
-        return self.do_print_results_option and self.DEM_parameters["OutputTimeStep"].GetDouble() - (self.time - self.time_old_print) < 1e-2 * self._GetSolver().dt
-
-    def PrintResults(self):
-        #### GiD IO ##########################################
-        if self.IsTimeToPrintPostProcess():
-            self.PrintResultsForGid(self.time)
-            self.time_old_print = self.time
-
-    def SolverSolve(self):
-        self._GetSolver().SolveSolutionStep()
-
-    def SetInlet(self):
-        if self.DEM_parameters["dem_inlet_option"].GetBool():
-            #Constructing the inlet and initializing it (must be done AFTER the self.spheres_model_part Initialize)
-            self.DEM_inlet = DEM_Inlet(self.dem_inlet_model_part, self.DEM_parameters["dem_inlets_settings"], self.seed)
-            self.DEM_inlet.InitializeDEM_Inlet(self.spheres_model_part, self.creator_destructor, self._GetSolver().continuum_type)
-
-    def SetInitialNodalValues(self):
-        self.procedures.SetInitialNodalValues(self.spheres_model_part, self.cluster_model_part, self.dem_inlet_model_part, self.rigid_face_model_part)
-
-    def InitializeSolutionStep(self):
-        super().InitializeSolutionStep()
-        if self.post_normal_impact_velocity_option:
-            if self.IsCountStep():
-                self.FillAnalyticSubModelPartsWithNewParticles()
-        if self.DEM_parameters["ContactMeshOption"].GetBool():
-            self.UpdateIsTimeToPrintInModelParts(self.IsTimeToPrintPostProcess())
-
-        if self.DEM_parameters["Dimension"].GetInt() == 2:
-            self.spheres_model_part.ProcessInfo[IMPOSED_Z_STRAIN_OPTION] = self.DEM_parameters["ImposeZStrainIn2DOption"].GetBool()
-            if not self.DEM_parameters["ImposeZStrainIn2DWithControlModule"].GetBool():
-                if self.spheres_model_part.ProcessInfo[IMPOSED_Z_STRAIN_OPTION]:
-                    self.spheres_model_part.ProcessInfo.SetValue(IMPOSED_Z_STRAIN_VALUE, eval(self.DEM_parameters["ZStrainValue"].GetString()))
-
-        if "BoundingBoxMoveOption" in self.DEM_parameters.keys():
-            if self.DEM_parameters["BoundingBoxMoveOption"].GetBool():
-                self.UpdateSearchStartegyAndCPlusPlusStrategy()
-                self.procedures.UpdateBoundingBox(self.spheres_model_part, self.creator_destructor)
-        
-
-    def UpdateSearchStartegyAndCPlusPlusStrategy(self):
-
-        move_velocity = self.DEM_parameters["BoundingBoxMoveVelocity"].GetDouble()
-
-        BoundingBoxMinX_update = self.DEM_parameters["BoundingBoxMinX"].GetDouble() + self.time * move_velocity
-        BoundingBoxMinY_update = self.DEM_parameters["BoundingBoxMinY"].GetDouble() + self.time * move_velocity
-        BoundingBoxMinZ_update = self.DEM_parameters["BoundingBoxMinZ"].GetDouble() + self.time * move_velocity
-        BoundingBoxMaxX_update = self.DEM_parameters["BoundingBoxMaxX"].GetDouble() - self.time * move_velocity
-        BoundingBoxMaxY_update = self.DEM_parameters["BoundingBoxMaxY"].GetDouble() - self.time * move_velocity
-        BoundingBoxMaxZ_update = self.DEM_parameters["BoundingBoxMaxZ"].GetDouble() - self.time * move_velocity
-
-        self._GetSolver().search_strategy = OMP_DEMSearch(BoundingBoxMinX_update,
-                                                        BoundingBoxMinY_update,
-                                                        BoundingBoxMinZ_update,
-                                                        BoundingBoxMaxX_update,
-                                                        BoundingBoxMaxY_update,
-                                                        BoundingBoxMaxZ_update)
-        self._GetSolver().UpdateCPlusPlusStrategy()
-
-    def UpdateIsTimeToPrintInModelParts(self, is_time_to_print):
-        self.UpdateIsTimeToPrintInOneModelPart(self.spheres_model_part, is_time_to_print)
-        self.UpdateIsTimeToPrintInOneModelPart(self.cluster_model_part, is_time_to_print)
-        self.UpdateIsTimeToPrintInOneModelPart(self.dem_inlet_model_part, is_time_to_print)
-        self.UpdateIsTimeToPrintInOneModelPart(self.rigid_face_model_part, is_time_to_print)
-
-    def UpdateIsTimeToPrintInOneModelPart(self, model_part, is_time_to_print):
-        model_part.ProcessInfo[IS_TIME_TO_PRINT] = is_time_to_print
-
-    def BeforePrintingOperations(self, time):
-        pass
-
-    def PrintAnalysisStageProgressInformation(self):
-        step = self.spheres_model_part.ProcessInfo[TIME_STEPS]
-        stepinfo = self.report.StepiReport(timer, self.time, step)
-        if stepinfo:
-            self.KratosPrintInfo(stepinfo)
-
-    def FinalizeSolutionStep(self):
-        super().FinalizeSolutionStep()
-
-        #Phantom Walls
-        self.RunAnalytics(self.time)
-
-        ##### adding DEM elements by the inlet ######
-        if self.DEM_parameters["dem_inlet_option"].GetBool():
-            self.DEM_inlet.CreateElementsFromInletMesh(self.spheres_model_part, self.cluster_model_part, self.creator_destructor)  # After solving, to make sure that neighbours are already set.
-
-    def OutputSolutionStep(self):
-        #### PRINTING GRAPHS ####
-        self.post_utils.ComputeMeanVelocitiesInTrap("Average_Velocity.txt", self.time, self.graphs_path)
-        self.DEMFEMProcedures.PrintGraph(self.time)
-        self.DEMFEMProcedures.PrintBallsGraph(self.time)
-        self.DEMFEMProcedures.PrintAdditionalGraphs(self.time, self._GetSolver())
-        self.DEMEnergyCalculator.CalculateEnergyAndPlot(self.time)
-        self.BeforePrintingOperations(self.time)
-        self.PrintResults()
-
-        for output_process in self._GetListOfOutputProcesses():
-            if output_process.IsOutputStep():
-                output_process.PrintOutput()
-
-    def BreakSolutionStepsLoop(self):
-        return False
-
-    def TheSimulationMustGoOn(self):
-        it_must_or_not = self.time < self.end_time
-        it_must_or_not = it_must_or_not and not self.BreakSolutionStepsLoop()
-        return it_must_or_not
-
-    def __SafeDeleteModelParts(self):
-        self.model.DeleteModelPart(self.cluster_model_part.Name)
-        self.model.DeleteModelPart(self.rigid_face_model_part.Name)
-        self.model.DeleteModelPart(self.dem_inlet_model_part.Name)
-        self.model.DeleteModelPart(self.mapping_model_part.Name)
-        self.model.DeleteModelPart(self.spheres_model_part.Name)
-
-    def Finalize(self):
-        self.KratosPrintInfo("Finalizing execution...")
-        super().Finalize()
-        if self.do_print_results_option:
-            self.GraphicalOutputFinalize()
-        self.DEMFEMProcedures.FinalizeGraphs(self.rigid_face_model_part)
-        self.DEMFEMProcedures.FinalizeBallsGraphs(self.spheres_model_part)
-        self.DEMEnergyCalculator.FinalizeEnergyPlot()
-
-        self.CleanUpOperations()
-
-    def __SafeDeleteModelParts(self):
-        self.model.DeleteModelPart(self.cluster_model_part.Name)
-        self.model.DeleteModelPart(self.rigid_face_model_part.Name)
-        self.model.DeleteModelPart(self.dem_inlet_model_part.Name)
-        self.model.DeleteModelPart(self.mapping_model_part.Name)
-        self.model.DeleteModelPart(self.spheres_model_part.Name)
-
-    def CleanUpOperations(self):
-
-        self.procedures.DeleteFiles()
-
-        self.KratosPrintInfo(self.report.FinalReport(timer))
-
-        if self.post_normal_impact_velocity_option:
-            del self.analytic_model_part
-
-        del self.KratosPrintInfo
-        del self.all_model_parts
-        if self.do_print_results_option:
-            del self.demio
-        del self.procedures
-        del self.creator_destructor
-        del self.dem_fem_search
-        #del self._solver
-        del self.DEMFEMProcedures
-        del self.post_utils
-        self.__SafeDeleteModelParts()
-        del self.cluster_model_part
-        del self.rigid_face_model_part
-        del self.spheres_model_part
-        del self.dem_inlet_model_part
-        del self.mapping_model_part
-        del self.contact_model_part
-
-        if self.DEM_parameters["dem_inlet_option"].GetBool():
-            del self.DEM_inlet
-
-    def SetGraphicalOutput(self):
-        self.demio = DEM_procedures.DEMIo(self.model, self.DEM_parameters, self.post_path, self.all_model_parts)
-        if self.DEM_parameters["post_vtk_option"].GetBool():
-            import KratosMultiphysics.DEMApplication.dem_vtk_output as dem_vtk_output
-            self.vtk_output = dem_vtk_output.VtkOutput(self.main_path, self.problem_name, self.spheres_model_part, self.contact_model_part, self.rigid_face_model_part, self.DEM_parameters)
-
-    def GraphicalOutputInitialize(self):
-        if self.do_print_results_option:
-            self.demio.Initialize(self.DEM_parameters)
-            self.demio.InitializeMesh(self.all_model_parts)
-
-    def PrintResultsForGid(self, time):
-        if self._GetSolver().poisson_ratio_option:
-            self.DEMFEMProcedures.PrintPoisson(self.spheres_model_part, self.DEM_parameters, "Poisson_ratio.txt", time)
-
-        if self.DEM_parameters["PostEulerAngles"].GetBool():
-            self.post_utils.PrintEulerAngles(self.spheres_model_part, self.cluster_model_part)
-
-        self.demio.PrintMultifileLists(time, self.post_path)
-        self._GetSolver().PrepareElementsForPrinting()
-        if self.DEM_parameters["ContactMeshOption"].GetBool():
-            self._GetSolver().PrepareContactElementsForPrinting()
-
-        if "post_gid_option" in self.DEM_parameters.keys():
-            if self.DEM_parameters["post_gid_option"].GetBool() != False:
-                self.demio.ShowPrintingResultsOnScreen(self.all_model_parts, 'GID')
-                self.demio.PrintResults(self.all_model_parts, self.creator_destructor, self.dem_fem_search, time, self.bounding_box_time_limits)
-
-        if "post_vtk_option" in self.DEM_parameters.keys():
-            if self.DEM_parameters["post_vtk_option"].GetBool():
-                self.demio.ShowPrintingResultsOnScreen(self.all_model_parts, 'VTK')
-                self.vtk_output.WriteResults(self.time)
-
-        self.file_msh = self.demio.GetMultiFileListName(self.problem_name + "_" + "%.12g"%time + ".post.msh")
-        self.file_res = self.demio.GetMultiFileListName(self.problem_name + "_" + "%.12g"%time + ".post.res")
-
-    def GraphicalOutputFinalize(self):
-        self.demio.FinalizeMesh()
-        self.demio.CloseMultifiles()
-
-    #these functions are needed for coupling, so that single time loops can be done
-
-    def InitializeTime(self):
-        self.time = 0.0
-        self.time_old_print = 0.0
-
-    def FinalizeSingleTimeStep(self):
-        message = 'Warning!'
-        message += '\nFunction \'FinalizeSingleTimeStep\' is deprecated. Use FinalizeSolutionStep instead.'
-        message += '\nIt will be removed after 10/31/2019.\n'
-        Logger.PrintWarning("DEM_analysis_stage.py", message)
-        ##### adding DEM elements by the inlet ######
-        if self.DEM_parameters["dem_inlet_option"].GetBool():
-            self.DEM_inlet.CreateElementsFromInletMesh(self.spheres_model_part, self.cluster_model_part, self.creator_destructor)  # After solving, to make sure that neighbours are already set.
-        stepinfo = self.report.StepiReport(timer, self.time, self.step)
-        if stepinfo:
-            self.KratosPrintInfo(stepinfo)
-
-    def OutputSingleTimeLoop(self):
-        #### PRINTING GRAPHS ####
-        os.chdir(self.graphs_path)
-        self.post_utils.ComputeMeanVelocitiesInTrap("Average_Velocity.txt", self.time, self.graphs_path)
-        self.DEMFEMProcedures.PrintGraph(self.time)
-        self.DEMFEMProcedures.PrintBallsGraph(self.time)
-        self.DEMEnergyCalculator.CalculateEnergyAndPlot(self.time)
-        self.BeforePrintingOperations(self.time)
-        #### GiD IO ##########################################
-        time_to_print = self.time - self.time_old_print
-        if self.DEM_parameters["OutputTimeStep"].GetDouble() - time_to_print < 1e-2 * self._GetSolver().dt:
-            self.PrintResultsForGid(self.time)
-            self.time_old_print = self.time
-
-    def MeasureSphereForGettingPackingProperties(self, radius, center_x, center_y, center_z, type):
-        '''
-        This is a function to establish a sphere to measure local packing properties
-        The type could be "porosity", "averaged_coordination_number", "fabric_tensor", "stress" or "strain" 
-        This funtion is only valid for 3D model now
-        '''
-        if type == "porosity":
-
-            measure_sphere_volume = 4/3 * math.pi * radius * radius * radius
-            sphere_volume_inside_range = 0.0
-            measured_porosity = 0.0
-
-            for node in self.spheres_model_part.Nodes:
-
-                r = node.GetSolutionStepValue(RADIUS)
-                x = node.X
-                y = node.Y
-                z = node.Z
-
-                center_to_sphere_distance = ((x - center_x)**2 + (y - center_y)**2 + (z - center_z)**2)**0.5
-
-                if center_to_sphere_distance < (radius - r):
-
-                    sphere_volume_inside_range += 4/3 * math.pi * r * r * r
-
-                elif center_to_sphere_distance < (radius + r):
-
-                    other_part_d = radius - (radius * radius + center_to_sphere_distance * center_to_sphere_distance - r * r) / (center_to_sphere_distance * 2)
-
-                    my_part_d = r - (r * r + center_to_sphere_distance * center_to_sphere_distance - radius * radius) / (center_to_sphere_distance * 2)
-                    
-                    cross_volume = math.pi * other_part_d * other_part_d * (radius - 1/3 * other_part_d) + math.pi * my_part_d * my_part_d * (r - 1/3 * my_part_d)
-                    
-                    sphere_volume_inside_range += cross_volume
-
-            measured_porosity = 1 - (sphere_volume_inside_range / measure_sphere_volume)
-
-            return measured_porosity
-        
-        if type == "averaged_coordination_number":
-            
-            measured_coordination_number = 0
-            if self.DEM_parameters["ContactMeshOption"].GetBool():
-                
-                total_particle_number = 0
-                total_contact_number  = 0
-                for element in self.contact_model_part.Elements:
-            
-                    x_0 = element.GetNode(0).X
-                    x_1 = element.GetNode(1).X
-                    y_0 = element.GetNode(0).Y
-                    y_1 = element.GetNode(1).Y
-                    z_0 = element.GetNode(0).Z
-                    z_1 = element.GetNode(1).Z
-                    r_0 = element.GetNode(0).GetSolutionStepValue(RADIUS)
-                    r_1 = element.GetNode(1).GetSolutionStepValue(RADIUS)
-                    r   = 0.5 * (r_0 + r_1)
-
-                    center_to_sphere_distance_0 = ((x_0 - center_x)**2 + (y_0 - center_y)**2 + (z_0 - center_z)**2)**0.5
-                    center_to_sphere_distance_1 = ((x_1 - center_x)**2 + (y_1 - center_y)**2 + (z_1 - center_z)**2)**0.5
-
-                    if (center_to_sphere_distance_0 < (radius - r)) and (center_to_sphere_distance_1 < (radius - r)):
-                        total_particle_number += 2
-                        total_contact_number += 2
-                    elif (center_to_sphere_distance_0 < (radius - r)) or (center_to_sphere_distance_1 < (radius - r)):
-                        total_particle_number += 1
-                        total_contact_number += 1
-                
-                if total_particle_number:
-                    measured_coordination_number = total_contact_number / total_particle_number
-                
-                return measured_coordination_number
-
-            else:
-                raise Exception('The \"ContactMeshOption\" in the [ProjectParametersDEM.json] should be [True].')
-        
-        if type == "fabric_tensor":
-
-            if self.DEM_parameters["ContactMeshOption"].GetBool():
-                
-                total_tensor = np.empty((3, 3))
-                total_contact_number  = 0
-                number_of_contacts_in_a_direction = np.zeros((36, 36))
-
-                for element in self.contact_model_part.Elements:
-            
-                    x_0 = element.GetNode(0).X
-                    x_1 = element.GetNode(1).X
-                    y_0 = element.GetNode(0).Y
-                    y_1 = element.GetNode(1).Y
-                    z_0 = element.GetNode(0).Z
-                    z_1 = element.GetNode(1).Z
-                    r_0 = element.GetNode(0).GetSolutionStepValue(RADIUS)
-                    r_1 = element.GetNode(1).GetSolutionStepValue(RADIUS)
-                    r   = 0.5 * (r_0 + r_1)
-
-                    center_to_sphere_distance_0 = ((x_0 - center_x)**2 + (y_0 - center_y)**2 + (z_0 - center_z)**2)**0.5
-                    center_to_sphere_distance_1 = ((x_1 - center_x)**2 + (y_1 - center_y)**2 + (z_1 - center_z)**2)**0.5
-
-                    if (center_to_sphere_distance_0 < (radius - r)) or (center_to_sphere_distance_1 < (radius - r)):
-                        
-                        vector1 = np.array([x_1 - x_0 , y_1 - y_0, z_1 - z_0])
-                        vector2 = np.array([x_1 - x_0 , y_1 - y_0, z_1 - z_0])
-                        tensor = np.outer(vector1, vector2)
-                        total_tensor += tensor
-                        total_contact_number += 1
-
-                        #calculate the contact direction
-                        x, y, z = vector1
-                        vector_length = np.linalg.norm(vector1)
-                        theta = np.arccos(z / vector_length)
-                        phi = np.arctan2(y, x)
-                        
-                        theta_index = int(theta / (2 * np.pi) * 36)
-                        phi_index = int(phi / (2 * np.pi) * 36)
-                        
-                        number_of_contacts_in_a_direction[phi_index, theta_index] += 1
-                
-                if total_contact_number:
-                    measured_fabric_tensor = total_tensor / total_contact_number
-
-                eigenvalues, eigenvectors = np.linalg.eig(measured_fabric_tensor)
-
-                output_file_name = "number_of_contacts_in_all_directions_of_size_" + str(radius) +".txt"
-                np.savetxt(os.path.join(self.graphs_path, output_file_name), number_of_contacts_in_a_direction, fmt='%d', delimiter=' ')
-                
-                return eigenvalues
-
-            else:
-                raise Exception('The \"ContactMeshOption\" in the [ProjectParametersDEM.json] should be [True].')
-                
-        if type == "voronoi_input_data":
-
-            particle_id_positions_and_radius = np.empty((0, 5))
-            particle_number_count = 0
-            for node in self.spheres_model_part.Nodes:
-
-                r = node.GetSolutionStepValue(RADIUS)
-                x = node.X
-                y = node.Y
-                z = node.Z
-
-                center_to_sphere_distance = ((x - center_x)**2 + (y - center_y)**2 + (z - center_z)**2)**0.5
-
-                if center_to_sphere_distance < (radius - r):
-
-                    particle_number_count += 1
-                    this_particle_info = np.array([particle_number_count,x, y, z, r])
-                    particle_id_positions_and_radius = np.vstack((particle_id_positions_and_radius, this_particle_info))
-
-            output_file_name = "voronoi_input_data_of_size_" + str(radius) +".txt"
-            fmt_list = ['%d', '%.6f', '%.6f', '%.6f', '%.6f']
-            np.savetxt(os.path.join(self.graphs_path, output_file_name), particle_id_positions_and_radius, fmt=fmt_list, delimiter='\t', comments='')
-        
-        if type == "stress":
-            pass
-
-        if type == "strain":
-            pass
-    
-    def MeasureSphereForGettingRadialDistributionFunction(self, radius, center_x, center_y, center_z, delta_r, d_mean):
-        
-        min_reference_particle_to_center_distance = 1e10
-        particle_positions = np.empty((0, 3))
-        IsTheFirstParticle = True
-        TotalParticleNumber = 0
-        reference_particle = np.empty((0, 3))
-        for node in self.spheres_model_part.Nodes:
-
-                r = node.GetSolutionStepValue(RADIUS)
-                x = node.X
-                y = node.Y
-                z = node.Z
-
-                center_to_sphere_distance = ((x - center_x)**2 + (y - center_y)**2 + (z - center_z)**2)**0.5
-
-                if center_to_sphere_distance < radius:
-
-                    this_particle_position = np.array([x, y, z])
-
-                    if center_to_sphere_distance < min_reference_particle_to_center_distance:
-                        min_reference_particle_to_center_distance = center_to_sphere_distance
-                        if not IsTheFirstParticle:
-                            particle_positions = np.vstack((particle_positions, reference_particle))
-                            TotalParticleNumber += 1
-                        reference_particle = this_particle_position
-                        if IsTheFirstParticle:
-                            IsTheFirstParticle = False
-                    else:
-                        particle_positions = np.vstack((particle_positions, this_particle_position))
-                        TotalParticleNumber += 1
-        
-        # Calculation of distances from reference particles to other particles
-        distances = np.linalg.norm(particle_positions - reference_particle, axis=1)
-
-        # Set histogram parameters
-        max_distance = radius
-        num_bins = int(max_distance // delta_r)
-        bin_edges = np.linspace(0, max_distance, num_bins + 1)
-
-        # Calculate histogram
-        hist, _ = np.histogram(distances, bins=bin_edges)
-
-        # Normalized histogram
-        bin_width = bin_edges[1] - bin_edges[0]
-        measure_sphere_volume = 4/3 * math.pi * radius * radius * radius
-        rdf = hist / (4 * np.pi * bin_edges[1:]**2 * bin_width * TotalParticleNumber / measure_sphere_volume)
-
-        data_to_save = np.column_stack((bin_edges[1:] / d_mean, rdf))
-        output_file_name = "rdf_data_of_size_" + str(radius * 2) +".txt"
-        np.savetxt(os.path.join(self.graphs_path, output_file_name), data_to_save, fmt='%.6f', delimiter='\t', comments='')
-
-    def MeasureCubicForGettingPackingProperties(self, side_length, center_x, center_y, center_z, type):
-        '''
-        This is a function to establish a cubic with 'side_length' to measure local packing properties
-        The type could be "porosity", "averaged_coordination_number", "fabric_tensor", "stress" or "strain" 
-        This funtion is only valid for 3D model now
-        '''
-        if type == "porosity":
-            measure_cubic_volume = side_length ** 3
-            sphere_volume_inside = 0.0
-            measured_porosity = 0.0
-
-            for node in self.spheres_model_part.Nodes:
-
-                r = node.GetSolutionStepValue(RADIUS)
-                x = node.X
-                y = node.Y
-                z = node.Z
-
-                if (center_x - 0.5 * side_length + r) < x < (center_x + 0.5 * side_length - r):
-                    if (center_y - 0.5 * side_length + r) < y < (center_y + 0.5 * side_length - r):
-                        if (center_z - 0.5 * side_length + r) < z < (center_z + 0.5 * side_length - r):
-                            sphere_volume_inside += 4/3 * math.pi * r * r * r
-
-            if measure_cubic_volume:
-                measured_porosity = 1 - (sphere_volume_inside / measure_cubic_volume)
-
-            return measured_porosity
-        
-        if type == "averaged_coordination_number":
-            
-            measured_coordination_number = 0
-            if self.DEM_parameters["ContactMeshOption"].GetBool():
-                
-                total_particle_number = 0
-                total_contact_number  = 0
-                for element in self.contact_model_part.Elements:
-            
-                    x_0 = element.GetNode(0).X
-                    x_1 = element.GetNode(1).X
-                    y_0 = element.GetNode(0).Y
-                    y_1 = element.GetNode(1).Y
-                    z_0 = element.GetNode(0).Z
-                    z_1 = element.GetNode(1).Z
-                    r_0 = element.GetNode(0).GetSolutionStepValue(RADIUS)
-                    r_1 = element.GetNode(1).GetSolutionStepValue(RADIUS)
-                    r   = 0.5 * (r_0 + r_1)
-
-                    if (center_x - 0.5 * side_length + r) < x_0 < (center_x + 0.5 * side_length - r):
-                        if (center_y - 0.5 * side_length + r) < y_0 < (center_y + 0.5 * side_length - r):
-                            if (center_z - 0.5 * side_length + r) < z_0 < (center_z + 0.5 * side_length - r):
-                                total_contact_number += 1
-
-                    if (center_x - 0.5 * side_length + r) < x_1 < (center_x + 0.5 * side_length - r):
-                        if (center_y - 0.5 * side_length + r) < y_1 < (center_y + 0.5 * side_length - r):
-                            if (center_z - 0.5 * side_length + r) < z_1 < (center_z + 0.5 * side_length - r):
-                                total_contact_number += 1
-                
-                for node in self.spheres_model_part.Nodes:
-
-                    r = node.GetSolutionStepValue(RADIUS)
-                    x = node.X
-                    y = node.Y
-                    z = node.Z
-
-                    if (center_x - 0.5 * side_length + r) < x < (center_x + 0.5 * side_length - r):
-                        if (center_y - 0.5 * side_length + r) < y < (center_y + 0.5 * side_length - r):
-                            if (center_z - 0.5 * side_length + r) < z < (center_z + 0.5 * side_length - r):
-                                total_particle_number += 1
-                
-                
-                if total_particle_number:
-                    measured_coordination_number = total_contact_number / total_particle_number
-                
-                return measured_coordination_number
-
-            else:
-                raise Exception('The \"ContactMeshOption\" in the [ProjectParametersDEM.json] should be [True].')
-        
-        if type == "fabric_tensor":
-
-            if self.DEM_parameters["ContactMeshOption"].GetBool():
-                
-                total_tensor = np.empty((3, 3))
-                total_contact_number  = 0
-                number_of_contacts_in_a_direction = np.zeros((18, 36))
-
-                for element in self.contact_model_part.Elements:
-            
-                    x_0 = element.GetNode(0).X
-                    x_1 = element.GetNode(1).X
-                    y_0 = element.GetNode(0).Y
-                    y_1 = element.GetNode(1).Y
-                    z_0 = element.GetNode(0).Z
-                    z_1 = element.GetNode(1).Z
-                    r_0 = element.GetNode(0).GetSolutionStepValue(RADIUS)
-                    r_1 = element.GetNode(1).GetSolutionStepValue(RADIUS)
-                    r   = 0.5 * (r_0 + r_1)
-
-                    sphere_0_is_inside = False
-                    sphere_1_is_inside = False
-
-                    if (center_x - 0.5 * side_length + r) < x_0 < (center_x + 0.5 * side_length - r):
-                        if (center_y - 0.5 * side_length + r) < y_0 < (center_y + 0.5 * side_length - r):
-                            if (center_z - 0.5 * side_length + r) < z_0 < (center_z + 0.5 * side_length - r):
-                                sphere_0_is_inside = True
-
-                    if (center_x - 0.5 * side_length + r) < x_1 < (center_x + 0.5 * side_length - r):
-                        if (center_y - 0.5 * side_length + r) < y_1 < (center_y + 0.5 * side_length - r):
-                            if (center_z - 0.5 * side_length + r) < z_1 < (center_z + 0.5 * side_length - r):
-                                sphere_1_is_inside = True
-
-                    if sphere_0_is_inside or sphere_1_is_inside:
-                        
-                        vector1 = np.array([x_1 - x_0 , y_1 - y_0, z_1 - z_0])
-                        #vector2 = np.array([x_1 - x_0 , y_1 - y_0, z_1 - z_0])
-                        v1_norm = np.linalg.norm(vector1)
-                        if v1_norm:
-                            vector1_unit = vector1 / v1_norm
-                        tensor = np.outer(vector1_unit, vector1_unit)
-                        total_tensor += tensor
-                        total_contact_number += 1
-
-                        #calculate the contact direction
-                        # here, y is the north direction
-                        x, y, z = vector1
-                        vector_length = np.linalg.norm(vector1)
-                        theta = np.arccos(y / vector_length)
-                        phi = np.arctan2(z, x)
-                        if z < 0:
-                            phi += 2 * np.pi
-
-                        theta_index = int(theta / (np.pi) * 18)
-                        phi_index = int(phi / (2 * np.pi) * 36)
-                        
-                        number_of_contacts_in_a_direction[theta_index, phi_index] += 1
-
-                        
-                        vector2 = np.array([x_0 - x_1 , y_0 - y_1, z_0 - z_1])
-                        x, y, z = vector2
-                        vector_length = np.linalg.norm(vector1)
-                        theta = np.arccos(y / vector_length)
-                        phi = np.arctan2(z, x)
-                        if z < 0:
-                            phi += 2 * np.pi
-                        
-                        theta_index = int(theta / (np.pi) * 18)
-                        phi_index = int(phi / (2 * np.pi) * 36)
-                        
-                        number_of_contacts_in_a_direction[theta_index, phi_index] += 1
-                        
-                
-                if total_contact_number:
-                    measured_fabric_tensor = total_tensor / total_contact_number
-                
-                deviatoric_tensor = 4 * (measured_fabric_tensor - 1/3 * np.eye(3)) 
-
-                second_invariant_of_deviatoric_tensor = (0.5 * np.sum(deviatoric_tensor * deviatoric_tensor))**0.5
-
-                eigenvalues, eigenvectors = np.linalg.eig(measured_fabric_tensor)
-
-                output_file_name = "number_of_contacts_in_all_directions_of_size_" + str(side_length) +".txt"
-                np.savetxt(os.path.join(self.graphs_path, output_file_name), number_of_contacts_in_a_direction, fmt='%d', delimiter=' ')
-                
-                return eigenvalues, second_invariant_of_deviatoric_tensor
-
-            else:
-                raise Exception('The \"ContactMeshOption\" in the [ProjectParametersDEM.json] should be [True].')
-            
-        if type == "voronoi_input_data":
-
-            particle_id_positions_and_radius = np.empty((0, 5))
-            particle_number_count = 0
-            for node in self.spheres_model_part.Nodes:
-
-                r = node.GetSolutionStepValue(RADIUS)
-                x = node.X
-                y = node.Y
-                z = node.Z
-
-                sphere_is_inside = False
-
-                if (center_x - 0.5 * side_length + r) < x < (center_x + 0.5 * side_length - r):
-                    if (center_y - 0.5 * side_length + r) < y < (center_y + 0.5 * side_length - r):
-                        if (center_z - 0.5 * side_length + r) < z < (center_z + 0.5 * side_length - r):
-                            sphere_is_inside = True
-
-                if sphere_is_inside:
-
-                    particle_number_count += 1
-                    this_particle_info = np.array([particle_number_count,x, y, z, r])
-                    particle_id_positions_and_radius = np.vstack((particle_id_positions_and_radius, this_particle_info))
-
-            output_file_name = "voronoi_input_data_of_size_" + str(side_length) +".txt"
-            fmt_list = ['%d', '%.6f', '%.6f', '%.6f', '%.6f']
-            np.savetxt(os.path.join(self.graphs_path, output_file_name), particle_id_positions_and_radius, fmt=fmt_list, delimiter='\t', comments='')
-
-        if type == "stress":
-            pass
-
-        if type == "strain":
-            pass
-
-if __name__ == "__main__":
-    with open("ProjectParametersDEM.json",'r') as parameter_file:
-        project_parameters = KratosMultiphysics.Parameters(parameter_file.read())
-
-    model = KratosMultiphysics.Model()
-    DEMAnalysisStage(model, project_parameters).Run()
+import time as timer
+import os
+import sys
+import pathlib
+import math
+import numpy as np
+from KratosMultiphysics import *
+from KratosMultiphysics.DEMApplication import *
+from KratosMultiphysics.analysis_stage import AnalysisStage
+from KratosMultiphysics.DEMApplication.DEM_restart_utility import DEMRestartUtility
+import KratosMultiphysics.DEMApplication.dem_default_input_parameters
+from KratosMultiphysics.DEMApplication.analytic_tools import analytic_data_procedures
+from KratosMultiphysics.DEMApplication.materials_assignation_utility import MaterialsAssignationUtility
+
+from importlib import import_module
+
+if IsDistributedRun():
+    if "DO_NOT_PARTITION_DOMAIN" in os.environ:
+        Logger.PrintInfo("DEM", "Running under MPI........")
+        from KratosMultiphysics.mpi import *
+        import KratosMultiphysics.DEMApplication.DEM_procedures_mpi_no_partitions as DEM_procedures
+    else:
+        Logger.PrintInfo("DEM", "Running under OpenMP........")
+        from KratosMultiphysics.MetisApplication import *
+        from KratosMultiphysics.MPISearchApplication import *
+        from KratosMultiphysics.mpi import *
+        import KratosMultiphysics.DEMApplication.DEM_procedures_mpi as DEM_procedures
+else:
+    Logger.PrintInfo("DEM", "Running under OpenMP........")
+    import KratosMultiphysics.DEMApplication.DEM_procedures as DEM_procedures
+
+class DEMAnalysisStage(AnalysisStage):
+
+    def GetParametersFileName(self):
+        return "ProjectParametersDEM.json"
+
+    def GetInputParameters(self):
+        self.KratosPrintWarning('Warning: Calls to this method (GetInputParameters) will become deprecated in the near future.')
+        parameters_file_name = self.GetParametersFileName()
+        parameters_file = open(parameters_file_name, 'r')
+        return Parameters(parameters_file.read())
+
+    def LoadParametersFile(self):
+        self.KratosPrintWarning('Warning: Calls to this method (LoadParametersFile) will become deprecated in the near future.')
+        self.DEM_parameters = self.GetInputParameters()
+        self.project_parameters = self.DEM_parameters
+        default_input_parameters = self.GetDefaultInputParameters()
+        self.DEM_parameters.ValidateAndAssignDefaults(default_input_parameters)
+        self.FixParametersInconsistencies()
+
+    def FixParametersInconsistencies(self): # TODO: This is here to avoid inconsistencies until the jsons become standard
+        final_time = self.DEM_parameters["FinalTime"].GetDouble()
+        problem_name = self.DEM_parameters["problem_name"].GetString()
+        self.project_parameters["problem_data"]["end_time"].SetDouble(final_time)
+        self.project_parameters["problem_data"]["problem_name"].SetString(problem_name)
+
+    def GetDefaultInputParameters(self):
+        return KratosMultiphysics.DEMApplication.dem_default_input_parameters.GetDefaultInputParameters()
+
+    def model_part_reader(self, modelpart, nodeid=0, elemid=0, condid=0):
+        return ReorderConsecutiveFromGivenIdsModelPartIO(modelpart, nodeid, elemid, condid, IO.SKIP_TIMER)
+
+    def GetMainPath(self):
+        return os.getcwd()
+
+    def __init__(self, model, DEM_parameters):
+        self.model = model
+        self.main_path = self.GetMainPath()
+        self.mdpas_folder_path = self.main_path
+
+        self.DEM_parameters = DEM_parameters    # TODO, can be improved
+        self.project_parameters = DEM_parameters
+        default_input_parameters = self.GetDefaultInputParameters()
+        self.DEM_parameters.ValidateAndAssignDefaults(default_input_parameters)
+        self.FixParametersInconsistencies()
+
+        self.do_print_results_option = self.DEM_parameters["do_print_results_option"].GetBool()
+        if not "WriteMdpaFromResults" in self.DEM_parameters.keys():
+            self.write_mdpa_from_results = False
+        else:
+            self.write_mdpa_from_results = self.DEM_parameters["WriteMdpaFromResults"].GetBool()
+        self.creator_destructor = self.SetParticleCreatorDestructor(DEM_parameters["creator_destructor_settings"])
+        self.dem_fem_search = self.SetDemFemSearch()
+        self.procedures = self.SetProcedures()
+        self.PreUtilities = PreUtilities()
+
+        # Set the print function TO_DO: do this better...
+        self.KratosPrintInfo = self.procedures.KratosPrintInfo
+
+        # Creating necessary directories:
+        self.problem_name = self.GetProblemTypeFileName()
+
+        [self.post_path, self.graphs_path] = self.procedures.CreateDirectories(str(self.main_path), str(self.problem_name), do_print_results=self.do_print_results_option)
+
+        # Prepare modelparts
+        self.CreateModelParts()
+
+        if self.do_print_results_option:
+            self.SetGraphicalOutput()
+        self.report = DEM_procedures.Report()
+        self.parallelutils = DEM_procedures.ParallelUtils()
+        self.translational_scheme = self.SetTranslationalScheme()
+        self.rotational_scheme = self.SetRotationalScheme()
+
+        # Define control variables
+        self.p_frequency = 100   # activate every 100 steps
+        self.step_count = 0
+        self.p_count = self.p_frequency
+
+        #self._solver = self._GetSolver()
+        self.SetFinalTime()
+        self.AddVariables()
+
+        super().__init__(model, self.DEM_parameters)
+
+    def CreateModelParts(self):
+        self.spheres_model_part = self.model.CreateModelPart("SpheresPart")
+        self.rigid_face_model_part = self.model.CreateModelPart("RigidFacePart")
+        self.cluster_model_part = self.model.CreateModelPart("ClusterPart")
+        self.dem_inlet_model_part = self.model.CreateModelPart("DEMInletPart")
+        self.mapping_model_part = self.model.CreateModelPart("MappingPart")
+        self.contact_model_part = self.model.CreateModelPart("ContactPart")
+
+        mp_list = []
+        mp_list.append(self.spheres_model_part)
+        mp_list.append(self.rigid_face_model_part)
+        mp_list.append(self.cluster_model_part)
+        mp_list.append(self.dem_inlet_model_part)
+        mp_list.append(self.mapping_model_part)
+        mp_list.append(self.contact_model_part)
+
+        self.all_model_parts = DEM_procedures.SetOfModelParts(mp_list)
+
+    def IsCountStep(self):
+        self.step_count += 1
+        if self.step_count == self.p_count:
+            self.p_count += self.p_frequency
+            return True
+
+        return False
+
+    def SetAnalyticWatchers(self):
+        self.SurfacesAnalyzerClass = analytic_data_procedures.SurfacesAnalyzerClass(self.rigid_face_model_part.SubModelParts, self.main_path)
+
+        if self.post_normal_impact_velocity_option:
+            self.ParticlesAnalyzerClass = analytic_data_procedures.ParticlesAnalyzerClass(self.analytic_model_part)
+
+    def MakeAnalyticsMeasurements(self):
+        self.SurfacesAnalyzerClass.MakeAnalyticsMeasurements()
+
+        if self.post_normal_impact_velocity_option:
+            self.ParticlesAnalyzerClass.MakeAnalyticsMeasurements()
+
+    def SetFinalTime(self):
+        self.end_time = self.DEM_parameters["FinalTime"].GetDouble()
+
+    def SetProcedures(self):
+        return DEM_procedures.Procedures(self.DEM_parameters)
+
+    def SetDemFemSearch(self):
+        return DEM_FEM_Search()
+
+    def GetParticleHistoryWatcher(self):
+        return None
+
+    def SetParticleCreatorDestructor(self, creator_destructor_settings):
+
+        self.watcher = self.GetParticleHistoryWatcher()
+
+        if self.watcher is None:
+            return ParticleCreatorDestructor(creator_destructor_settings)
+        return ParticleCreatorDestructor(self.watcher, creator_destructor_settings)
+
+    def SelectTranslationalScheme(self):
+        if self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Forward_Euler':
+            return ForwardEulerScheme()
+        elif self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Symplectic_Euler':
+            return SymplecticEulerScheme()
+        elif self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Taylor_Scheme':
+            return TaylorScheme()
+        elif self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Velocity_Verlet':
+            return VelocityVerletScheme()
+
+        return None
+
+    def SelectRotationalScheme(self):
+        if self.DEM_parameters["RotationalIntegrationScheme"].GetString() == 'Direct_Integration':
+            return self.SelectTranslationalScheme()
+        elif self.DEM_parameters["RotationalIntegrationScheme"].GetString() == 'Runge_Kutta':
+            return RungeKuttaScheme()
+        elif self.DEM_parameters["RotationalIntegrationScheme"].GetString() == 'Quaternion_Integration':
+            return QuaternionIntegrationScheme()
+
+        return None
+
+    def SetTranslationalScheme(self):
+        translational_scheme = self.SelectTranslationalScheme()
+
+        if translational_scheme is None:
+            raise Exception('Error: selected translational integration scheme not defined. Please select a different scheme')
+
+        return translational_scheme
+
+    def SetRotationalScheme(self):
+        rotational_scheme = self.SelectRotationalScheme()
+
+        if rotational_scheme is None:
+            raise Exception('Error: selected rotational integration scheme not defined. Please select a different scheme')
+
+        return rotational_scheme
+
+    def SetSolver(self):        # TODO why is this still here. -> main_script calls retrocompatibility
+        return self._CreateSolver()
+
+    def _CreateSolver(self):
+        def SetSolverStrategy():
+            strategy_file_name = self.DEM_parameters["solver_settings"]["strategy"].GetString()
+            imported_module = import_module("KratosMultiphysics.DEMApplication" + "." + strategy_file_name)
+            return imported_module
+
+        return SetSolverStrategy().ExplicitStrategy(self.all_model_parts,
+                                                    self.creator_destructor,
+                                                    self.dem_fem_search,
+                                                    self.DEM_parameters,
+                                                    self.procedures)
+
+    def AddVariables(self):
+        self.procedures.AddAllVariablesInAllModelParts(self._GetSolver(), self.translational_scheme, self.rotational_scheme, self.all_model_parts, self.DEM_parameters)
+
+    def FillAnalyticSubModelParts(self):
+        if not self.spheres_model_part.HasSubModelPart("AnalyticParticlesPart"):
+            self.spheres_model_part.CreateSubModelPart('AnalyticParticlesPart')
+        self.analytic_model_part = self.spheres_model_part.GetSubModelPart('AnalyticParticlesPart')
+        analytic_particle_ids = [elem.Id for elem in self.spheres_model_part.Elements]
+        self.analytic_model_part.AddElements(analytic_particle_ids)
+        analytic_node_ids = [node.Id for node in self.spheres_model_part.Nodes]
+        self.analytic_model_part.AddNodes(analytic_node_ids)
+
+    def FillAnalyticSubModelPartsWithNewParticles(self):
+        self.analytic_model_part = self.spheres_model_part.GetSubModelPart('AnalyticParticlesPart')
+        self.PreUtilities.FillAnalyticSubModelPartUtility(self.spheres_model_part, self.analytic_model_part)
+        #analytic_particle_ids = [elem.Id for elem in self.spheres_model_part.Elements]
+        #self.analytic_model_part.AddElements(analytic_particle_ids)
+
+    def Initialize(self):
+        self.time = 0.0
+        self.time_old_print = 0.0
+
+        self.ReadModelParts()
+
+        self.SetMaterials()
+
+        self.post_normal_impact_velocity_option = False
+        if "PostNormalImpactVelocity" in self.DEM_parameters.keys():
+            if self.DEM_parameters["PostNormalImpactVelocity"].GetBool():
+                self.post_normal_impact_velocity_option = True
+                self.FillAnalyticSubModelParts()
+
+        self.SetAnalyticWatchers()
+
+        # Setting up the buffer size
+        self.procedures.SetUpBufferSizeInAllModelParts(self.spheres_model_part, 1, self.cluster_model_part, 1, self.dem_inlet_model_part, 1, self.rigid_face_model_part, 1)
+
+        self.KratosPrintInfo("Initializing Problem...")
+
+        self.GraphicalOutputInitialize()
+
+        # Perform a partition to balance the problem
+        self.SetSearchStrategy()
+
+        self.SolverBeforeInitialize()
+
+        self.parallelutils.Repart(self.spheres_model_part)
+
+        #Setting up the BoundingBox
+        self.bounding_box_time_limits = self.procedures.SetBoundingBoxLimits(self.all_model_parts, self.creator_destructor)
+
+        self.creator_destructor.SetMaxNodeId(self.all_model_parts.MaxNodeId)
+
+        self.DEMFEMProcedures = DEM_procedures.DEMFEMProcedures(self.DEM_parameters, self.graphs_path, self.spheres_model_part, self.rigid_face_model_part)
+
+        self.DEMEnergyCalculator = DEM_procedures.DEMEnergyCalculator(self.DEM_parameters, self.spheres_model_part, self.cluster_model_part, self.graphs_path, "EnergyPlot.grf")
+
+        self.KratosPrintInfo("Initialization Complete")
+
+        self.report.Prepare(timer, self.DEM_parameters["ControlTime"].GetDouble())
+
+        self.post_utils = DEM_procedures.PostUtils(self.DEM_parameters, self.spheres_model_part)
+        self.report.total_steps_expected = int(self.end_time / self._GetSolver().dt)
+
+        super().Initialize()
+
+        self.seed = self.DEM_parameters["seed"].GetInt()
+        #Constructing a model part for the DEM inlet. It contains the DEM elements to be released during the simulation
+        #Initializing the DEM solver must be done before creating the DEM Inlet, because the Inlet configures itself according to some options of the DEM model part
+        self.SetInlet()
+
+        self.SetInitialNodalValues()
+
+        self.KratosPrintInfo(self.report.BeginReport(timer))
+
+        if self.DEM_parameters["output_configuration"]["print_number_of_neighbours_histogram"].GetBool():
+            self.PreUtilities.PrintNumberOfNeighboursHistogram(self.spheres_model_part, os.path.join(self.graphs_path, "number_of_neighbours_histogram.txt"))
+
+    def SetMaterials(self):
+
+        self.ReadMaterialsFile()
+
+        model_part_import_settings = self.DEM_parameters["solver_settings"]["model_import_settings"]
+        input_type = model_part_import_settings["input_type"].GetString()
+        if input_type == "rest":
+            return
+
+        materials_setter = MaterialsAssignationUtility(self.model, self.spheres_model_part, self.DEM_material_parameters)
+        materials_setter.AssignMaterialParametersToProperties()
+        materials_setter.AssignPropertiesToEntities()
+
+    def ReadMaterialsFile(self):
+        adapted_to_current_os_relative_path = pathlib.Path(self.DEM_parameters["solver_settings"]["material_import_settings"]["materials_filename"].GetString())
+        materials_file_abs_path = os.path.join(self.main_path, str(adapted_to_current_os_relative_path))
+        with open(materials_file_abs_path, 'r') as materials_file:
+            self.DEM_material_parameters = Parameters(materials_file.read())
+
+    def SetSearchStrategy(self):
+        self._GetSolver().search_strategy = self.parallelutils.GetSearchStrategy(self._GetSolver(), self.spheres_model_part)
+
+    def SolverBeforeInitialize(self):
+        self._GetSolver().BeforeInitialize()
+
+    def SolverInitialize(self):
+        self._GetSolver().Initialize() # Possible modifications of number of elements and number of nodes
+
+    def GetProblemNameWithPath(self):
+        return os.path.join(self.mdpas_folder_path, self.DEM_parameters["problem_name"].GetString())
+
+    def GetDiscreteElementsInputFileTag(self):
+        return 'DEM'
+
+    def GetDEMInletInputFileTag(self):
+        return 'DEM_Inlet'
+
+    def GetDEMWallsInputFileTag(self):
+        return 'DEM_FEM_boundary'
+
+    def GetDEMClustersInputFileTag(self):
+        return 'DEM_Clusters'
+
+    def GetDiscreteElementsInputFilePath(self):
+        return self.GetInputFilePath(self.GetDiscreteElementsInputFileTag())
+
+    def GetDEMInletInputFilePath(self):
+        return self.GetInputFilePath(self.GetDEMInletInputFileTag())
+
+    def GetDEMWallsInputFilePath(self):
+        return self.GetInputFilePath(self.GetDEMWallsInputFileTag())
+
+    def GetDEMClustersInputFilePath(self):
+        return self.GetInputFilePath(self.GetDEMClustersInputFileTag())
+
+    def GetMpFilePath(self):
+        return GetInputFilePath('DEM')
+
+    def GetInletFilePath(self):
+        return GetInputFilePath('DEM_Inlet')
+
+    def GetFemFilePath(self):
+        return GetInputFilePath('DEM_FEM_boundary')
+
+    def GetClusterFilePath(self):
+        return GetInputFilePath('DEM_Clusters')
+
+    def GetInputFilePath(self, file_tag=''):
+        return self.GetProblemNameWithPath() + file_tag
+
+    def GetProblemTypeFileName(self):
+        return self.DEM_parameters["problem_name"].GetString()
+
+    def ReadModelPartsFromRestartFile(self, model_part_import_settings):
+        Logger.PrintInfo('DEM', 'Loading model parts from restart file...')
+        DEMRestartUtility(self.model, self._GetSolver()._GetRestartSettings(model_part_import_settings)).LoadRestart()
+        Logger.PrintInfo('DEM', 'Finished loading model parts from restart file.')
+
+    def ReadModelPartsFromMdpaFile(self, max_node_id, max_elem_id, max_cond_id):
+        def UpdateMaxIds(max_node_id, max_elem_id, max_cond_id, model_part):
+            max_node_id = max(max_node_id, self.creator_destructor.FindMaxNodeIdInModelPart(model_part))
+            max_elem_id = max(max_elem_id, self.creator_destructor.FindMaxElementIdInModelPart(model_part))
+            max_cond_id = max(max_cond_id, self.creator_destructor.FindMaxConditionIdInModelPart(model_part))
+            return max_node_id, max_elem_id, max_cond_id
+
+        def ReadModelPart(model_part, file_tag, max_node_id, max_elem_id, max_cond_id):
+            file_path = self.GetInputFilePath(file_tag)
+
+            if not os.path.isfile(file_path + '.mdpa'):
+                self.KratosPrintInfo('Input file ' + file_tag + '.mdpa' + ' not found. Continuing.')
+                return
+
+            if model_part.Name == 'SpheresPart':
+                model_part_io = self.model_part_reader(file_path, max_node_id, max_elem_id, max_cond_id)
+
+                do_perform_initial_partition = True
+                if self.DEM_parameters.Has("do_not_perform_initial_partition"):
+                    if self.DEM_parameters["do_not_perform_initial_partition"].GetBool():
+                        do_perform_initial_partition = False
+
+                if do_perform_initial_partition:
+                    self.parallelutils.PerformInitialPartition(model_part_io)
+
+                model_part_io, model_part = self.parallelutils.SetCommunicator(
+                                                model_part,
+                                                model_part_io,
+                                                file_path)
+            else:
+                model_part_io = self.model_part_reader(file_path, max_node_id + 1, max_elem_id + 1, max_cond_id + 1)
+
+            model_part_io.ReadModelPart(model_part)
+
+        ReadModelPart(self.spheres_model_part, self.GetDiscreteElementsInputFileTag(), max_node_id, max_elem_id, max_cond_id)
+        max_node_id, max_elem_id, max_cond_id = UpdateMaxIds(max_node_id, max_elem_id, max_cond_id, self.spheres_model_part)
+        old_max_elem_id_spheres = max_elem_id
+
+        ReadModelPart(self.rigid_face_model_part, self.GetDEMWallsInputFileTag(), max_node_id, max_elem_id, max_cond_id)
+
+        max_node_id, max_elem_id, max_cond_id = UpdateMaxIds(max_node_id, max_elem_id, max_cond_id, self.rigid_face_model_part)
+
+        ReadModelPart(self.cluster_model_part, self.GetDEMClustersInputFileTag(), max_node_id, max_elem_id, max_cond_id)
+
+        max_elem_id = self.creator_destructor.FindMaxElementIdInModelPart(self.spheres_model_part)
+
+        # Clusters generate extra spheres, so the following step is necessary
+        if max_elem_id != old_max_elem_id_spheres:
+            self.creator_destructor.RenumberElementIdsFromGivenValue(self.cluster_model_part, max_elem_id)
+
+        max_node_id, max_elem_id, max_cond_id = UpdateMaxIds(max_node_id, max_elem_id, max_cond_id, self.cluster_model_part)
+
+        ReadModelPart(self.dem_inlet_model_part, self.GetDEMInletInputFileTag(), max_node_id, max_elem_id, max_cond_id)
+
+    def ReadModelParts(self, max_node_id=0, max_elem_id=0, max_cond_id=0):
+
+        model_part_import_settings = self.DEM_parameters["solver_settings"]["model_import_settings"]
+        input_type = model_part_import_settings["input_type"].GetString()
+
+        if input_type == "rest":
+            self.ReadModelPartsFromRestartFile(model_part_import_settings)
+        elif input_type == "mdpa":
+            self.ReadModelPartsFromMdpaFile(max_node_id, max_elem_id, max_cond_id)
+        else:
+            raise Exception('DEM', 'Model part input option \'' + input_type + '\' is not yet implemented.')
+
+        self.model_parts_have_been_read = True
+        self.all_model_parts.ComputeMaxIds()
+        self.ConvertClusterFileNamesFromRelativePathToAbsolutePath()
+        self.CheckConsistencyOfElementsAndNodesInEverySubModelPart()
+
+    def CheckConsistencyOfElementsAndNodesInEverySubModelPart(self):
+        def ErrorMessage(name):
+            raise Exception(" ModelPart (or SubModelPart) "+ name + " has a different number of nodes and elements (particles)! \n")
+
+        if self.spheres_model_part.NumberOfNodes(0) != self.spheres_model_part.NumberOfElements(0):
+            ErrorMessage(self.spheres_model_part.Name)
+        if self.cluster_model_part.NumberOfNodes(0) != self.cluster_model_part.NumberOfElements(0):
+            ErrorMessage(self.cluster_model_part.Name)
+
+        for submp in self.spheres_model_part.SubModelParts:
+            if submp.NumberOfNodes(0) != submp.NumberOfElements(0):
+                ErrorMessage(submp.Name)
+
+        for submp in self.cluster_model_part.SubModelParts:
+            if submp.NumberOfNodes(0) != submp.NumberOfElements(0):
+                ErrorMessage(submp.Name)
+
+    def ConvertClusterFileNamesFromRelativePathToAbsolutePath(self):
+        for properties in self.cluster_model_part.Properties:
+            if properties.Has(CLUSTER_FILE_NAME):
+                cluster_file_name = properties[CLUSTER_FILE_NAME]
+                properties[CLUSTER_FILE_NAME] = os.path.join(self.main_path, cluster_file_name)
+
+        for submp in self.dem_inlet_model_part.SubModelParts:
+            if submp.Has(CLUSTER_FILE_NAME):
+                cluster_file_name = submp[CLUSTER_FILE_NAME]
+                submp[CLUSTER_FILE_NAME] = os.path.join(self.main_path, cluster_file_name)
+
+    def RunAnalytics(self, time):
+        self.MakeAnalyticsMeasurements()
+        if self.IsTimeToPrintPostProcess():
+            self.SurfacesAnalyzerClass.MakeAnalyticsPipeLine(time)
+
+        if self.post_normal_impact_velocity_option and self.IsTimeToPrintPostProcess():
+            self.ParticlesAnalyzerClass.SetNodalMaxImpactVelocities()
+            self.ParticlesAnalyzerClass.SetNodalMaxFaceImpactVelocities()
+
+    def IsTimeToPrintPostProcess(self):
+        return self.do_print_results_option and self.DEM_parameters["OutputTimeStep"].GetDouble() - (self.time - self.time_old_print) < 1e-2 * self._GetSolver().dt
+
+    def PrintResults(self):
+        #### GiD IO ##########################################
+        if self.IsTimeToPrintPostProcess():
+            self.PrintResultsForGid(self.time)
+            self.time_old_print = self.time
+
+    def SolverSolve(self):
+        self._GetSolver().SolveSolutionStep()
+
+    def SetInlet(self):
+        if self.DEM_parameters["dem_inlet_option"].GetBool():
+            #Constructing the inlet and initializing it (must be done AFTER the self.spheres_model_part Initialize)
+            self.DEM_inlet = DEM_Inlet(self.dem_inlet_model_part, self.DEM_parameters["dem_inlets_settings"], self.seed)
+            self.DEM_inlet.InitializeDEM_Inlet(self.spheres_model_part, self.creator_destructor, self._GetSolver().continuum_type)
+
+    def SetInitialNodalValues(self):
+        self.procedures.SetInitialNodalValues(self.spheres_model_part, self.cluster_model_part, self.dem_inlet_model_part, self.rigid_face_model_part)
+
+    def InitializeSolutionStep(self):
+        super().InitializeSolutionStep()
+        if self.post_normal_impact_velocity_option:
+            if self.IsCountStep():
+                self.FillAnalyticSubModelPartsWithNewParticles()
+        if self.DEM_parameters["ContactMeshOption"].GetBool():
+            self.UpdateIsTimeToPrintInModelParts(self.IsTimeToPrintPostProcess())
+
+        if self.DEM_parameters["Dimension"].GetInt() == 2:
+            self.spheres_model_part.ProcessInfo[IMPOSED_Z_STRAIN_OPTION] = self.DEM_parameters["ImposeZStrainIn2DOption"].GetBool()
+            if not self.DEM_parameters["ImposeZStrainIn2DWithControlModule"].GetBool():
+                if self.spheres_model_part.ProcessInfo[IMPOSED_Z_STRAIN_OPTION]:
+                    self.spheres_model_part.ProcessInfo.SetValue(IMPOSED_Z_STRAIN_VALUE, eval(self.DEM_parameters["ZStrainValue"].GetString()))
+
+        if "BoundingBoxMoveOption" in self.DEM_parameters.keys():
+            if self.DEM_parameters["BoundingBoxMoveOption"].GetBool():
+                self.UpdateSearchStartegyAndCPlusPlusStrategy()
+                self.procedures.UpdateBoundingBox(self.spheres_model_part, self.creator_destructor)
+        
+
+    def UpdateSearchStartegyAndCPlusPlusStrategy(self):
+
+        move_velocity = self.DEM_parameters["BoundingBoxMoveVelocity"].GetDouble()
+
+        BoundingBoxMinX_update = self.DEM_parameters["BoundingBoxMinX"].GetDouble() + self.time * move_velocity
+        BoundingBoxMinY_update = self.DEM_parameters["BoundingBoxMinY"].GetDouble() + self.time * move_velocity
+        BoundingBoxMinZ_update = self.DEM_parameters["BoundingBoxMinZ"].GetDouble() + self.time * move_velocity
+        BoundingBoxMaxX_update = self.DEM_parameters["BoundingBoxMaxX"].GetDouble() - self.time * move_velocity
+        BoundingBoxMaxY_update = self.DEM_parameters["BoundingBoxMaxY"].GetDouble() - self.time * move_velocity
+        BoundingBoxMaxZ_update = self.DEM_parameters["BoundingBoxMaxZ"].GetDouble() - self.time * move_velocity
+
+        self._GetSolver().search_strategy = OMP_DEMSearch(BoundingBoxMinX_update,
+                                                        BoundingBoxMinY_update,
+                                                        BoundingBoxMinZ_update,
+                                                        BoundingBoxMaxX_update,
+                                                        BoundingBoxMaxY_update,
+                                                        BoundingBoxMaxZ_update)
+        self._GetSolver().UpdateCPlusPlusStrategy()
+
+    def UpdateIsTimeToPrintInModelParts(self, is_time_to_print):
+        self.UpdateIsTimeToPrintInOneModelPart(self.spheres_model_part, is_time_to_print)
+        self.UpdateIsTimeToPrintInOneModelPart(self.cluster_model_part, is_time_to_print)
+        self.UpdateIsTimeToPrintInOneModelPart(self.dem_inlet_model_part, is_time_to_print)
+        self.UpdateIsTimeToPrintInOneModelPart(self.rigid_face_model_part, is_time_to_print)
+
+    def UpdateIsTimeToPrintInOneModelPart(self, model_part, is_time_to_print):
+        model_part.ProcessInfo[IS_TIME_TO_PRINT] = is_time_to_print
+
+    def BeforePrintingOperations(self, time):
+        pass
+
+    def PrintAnalysisStageProgressInformation(self):
+        step = self.spheres_model_part.ProcessInfo[TIME_STEPS]
+        stepinfo = self.report.StepiReport(timer, self.time, step)
+        if stepinfo:
+            self.KratosPrintInfo(stepinfo)
+
+    def FinalizeSolutionStep(self):
+        super().FinalizeSolutionStep()
+
+        #Phantom Walls
+        self.RunAnalytics(self.time)
+
+        ##### adding DEM elements by the inlet ######
+        if self.DEM_parameters["dem_inlet_option"].GetBool():
+            self.DEM_inlet.CreateElementsFromInletMesh(self.spheres_model_part, self.cluster_model_part, self.creator_destructor)  # After solving, to make sure that neighbours are already set.
+
+    def OutputSolutionStep(self):
+        #### PRINTING GRAPHS ####
+        self.post_utils.ComputeMeanVelocitiesInTrap("Average_Velocity.txt", self.time, self.graphs_path)
+        self.DEMFEMProcedures.PrintGraph(self.time)
+        self.DEMFEMProcedures.PrintBallsGraph(self.time)
+        self.DEMFEMProcedures.PrintAdditionalGraphs(self.time, self._GetSolver())
+        self.DEMEnergyCalculator.CalculateEnergyAndPlot(self.time)
+        self.BeforePrintingOperations(self.time)
+        self.PrintResults()
+
+        for output_process in self._GetListOfOutputProcesses():
+            if output_process.IsOutputStep():
+                output_process.PrintOutput()
+
+    def BreakSolutionStepsLoop(self):
+        return False
+
+    def TheSimulationMustGoOn(self):
+        it_must_or_not = self.time < self.end_time
+        it_must_or_not = it_must_or_not and not self.BreakSolutionStepsLoop()
+        return it_must_or_not
+
+    def __SafeDeleteModelParts(self):
+        self.model.DeleteModelPart(self.cluster_model_part.Name)
+        self.model.DeleteModelPart(self.rigid_face_model_part.Name)
+        self.model.DeleteModelPart(self.dem_inlet_model_part.Name)
+        self.model.DeleteModelPart(self.mapping_model_part.Name)
+        self.model.DeleteModelPart(self.spheres_model_part.Name)
+
+    def Finalize(self):
+        self.KratosPrintInfo("Finalizing execution...")
+        super().Finalize()
+        if self.do_print_results_option:
+            self.GraphicalOutputFinalize()
+        self.DEMFEMProcedures.FinalizeGraphs(self.rigid_face_model_part)
+        self.DEMFEMProcedures.FinalizeBallsGraphs(self.spheres_model_part)
+        self.DEMEnergyCalculator.FinalizeEnergyPlot()
+
+        self.CleanUpOperations()
+
+    def __SafeDeleteModelParts(self):
+        self.model.DeleteModelPart(self.cluster_model_part.Name)
+        self.model.DeleteModelPart(self.rigid_face_model_part.Name)
+        self.model.DeleteModelPart(self.dem_inlet_model_part.Name)
+        self.model.DeleteModelPart(self.mapping_model_part.Name)
+        self.model.DeleteModelPart(self.spheres_model_part.Name)
+
+    def CleanUpOperations(self):
+
+        self.procedures.DeleteFiles()
+
+        self.KratosPrintInfo(self.report.FinalReport(timer))
+
+        if self.post_normal_impact_velocity_option:
+            del self.analytic_model_part
+
+        del self.KratosPrintInfo
+        del self.all_model_parts
+        if self.do_print_results_option:
+            del self.demio
+        del self.procedures
+        del self.creator_destructor
+        del self.dem_fem_search
+        #del self._solver
+        del self.DEMFEMProcedures
+        del self.post_utils
+        self.__SafeDeleteModelParts()
+        del self.cluster_model_part
+        del self.rigid_face_model_part
+        del self.spheres_model_part
+        del self.dem_inlet_model_part
+        del self.mapping_model_part
+        del self.contact_model_part
+
+        if self.DEM_parameters["dem_inlet_option"].GetBool():
+            del self.DEM_inlet
+
+    def SetGraphicalOutput(self):
+        self.demio = DEM_procedures.DEMIo(self.model, self.DEM_parameters, self.post_path, self.all_model_parts)
+        if self.DEM_parameters["post_vtk_option"].GetBool():
+            import KratosMultiphysics.DEMApplication.dem_vtk_output as dem_vtk_output
+            self.vtk_output = dem_vtk_output.VtkOutput(self.main_path, self.problem_name, self.spheres_model_part, self.contact_model_part, self.rigid_face_model_part, self.DEM_parameters)
+
+    def GraphicalOutputInitialize(self):
+        if self.do_print_results_option:
+            self.demio.Initialize(self.DEM_parameters)
+            self.demio.InitializeMesh(self.all_model_parts)
+
+    def PrintResultsForGid(self, time):
+        if self._GetSolver().poisson_ratio_option:
+            self.DEMFEMProcedures.PrintPoisson(self.spheres_model_part, self.DEM_parameters, "Poisson_ratio.txt", time)
+
+        if self.DEM_parameters["PostEulerAngles"].GetBool():
+            self.post_utils.PrintEulerAngles(self.spheres_model_part, self.cluster_model_part)
+
+        self.demio.PrintMultifileLists(time, self.post_path)
+        self._GetSolver().PrepareElementsForPrinting()
+        if self.DEM_parameters["ContactMeshOption"].GetBool():
+            self._GetSolver().PrepareContactElementsForPrinting()
+
+        if "post_gid_option" in self.DEM_parameters.keys():
+            if self.DEM_parameters["post_gid_option"].GetBool() != False:
+                self.demio.ShowPrintingResultsOnScreen(self.all_model_parts, 'GID')
+                self.demio.PrintResults(self.all_model_parts, self.creator_destructor, self.dem_fem_search, time, self.bounding_box_time_limits)
+
+        if "post_vtk_option" in self.DEM_parameters.keys():
+            if self.DEM_parameters["post_vtk_option"].GetBool():
+                self.demio.ShowPrintingResultsOnScreen(self.all_model_parts, 'VTK')
+                self.vtk_output.WriteResults(self.time)
+
+        self.file_msh = self.demio.GetMultiFileListName(self.problem_name + "_" + "%.12g"%time + ".post.msh")
+        self.file_res = self.demio.GetMultiFileListName(self.problem_name + "_" + "%.12g"%time + ".post.res")
+
+    def GraphicalOutputFinalize(self):
+        self.demio.FinalizeMesh()
+        self.demio.CloseMultifiles()
+
+    #these functions are needed for coupling, so that single time loops can be done
+
+    def InitializeTime(self):
+        self.time = 0.0
+        self.time_old_print = 0.0
+
+    def FinalizeSingleTimeStep(self):
+        message = 'Warning!'
+        message += '\nFunction \'FinalizeSingleTimeStep\' is deprecated. Use FinalizeSolutionStep instead.'
+        message += '\nIt will be removed after 10/31/2019.\n'
+        Logger.PrintWarning("DEM_analysis_stage.py", message)
+        ##### adding DEM elements by the inlet ######
+        if self.DEM_parameters["dem_inlet_option"].GetBool():
+            self.DEM_inlet.CreateElementsFromInletMesh(self.spheres_model_part, self.cluster_model_part, self.creator_destructor)  # After solving, to make sure that neighbours are already set.
+        stepinfo = self.report.StepiReport(timer, self.time, self.step)
+        if stepinfo:
+            self.KratosPrintInfo(stepinfo)
+
+    def OutputSingleTimeLoop(self):
+        #### PRINTING GRAPHS ####
+        os.chdir(self.graphs_path)
+        self.post_utils.ComputeMeanVelocitiesInTrap("Average_Velocity.txt", self.time, self.graphs_path)
+        self.DEMFEMProcedures.PrintGraph(self.time)
+        self.DEMFEMProcedures.PrintBallsGraph(self.time)
+        self.DEMEnergyCalculator.CalculateEnergyAndPlot(self.time)
+        self.BeforePrintingOperations(self.time)
+        #### GiD IO ##########################################
+        time_to_print = self.time - self.time_old_print
+        if self.DEM_parameters["OutputTimeStep"].GetDouble() - time_to_print < 1e-2 * self._GetSolver().dt:
+            self.PrintResultsForGid(self.time)
+            self.time_old_print = self.time
+
+    def MeasureSphereForGettingPackingProperties(self, radius, center_x, center_y, center_z, type):
+        '''
+        This is a function to establish a sphere to measure local packing properties
+        The type could be "porosity", "averaged_coordination_number", "fabric_tensor", "stress" or "strain" 
+        This funtion is only valid for 3D model now
+        '''
+        if type == "porosity":
+
+            measure_sphere_volume = 4/3 * math.pi * radius * radius * radius
+            sphere_volume_inside_range = 0.0
+            measured_porosity = 0.0
+
+            for node in self.spheres_model_part.Nodes:
+
+                r = node.GetSolutionStepValue(RADIUS)
+                x = node.X
+                y = node.Y
+                z = node.Z
+
+                center_to_sphere_distance = ((x - center_x)**2 + (y - center_y)**2 + (z - center_z)**2)**0.5
+
+                if center_to_sphere_distance < (radius - r):
+
+                    sphere_volume_inside_range += 4/3 * math.pi * r * r * r
+
+                elif center_to_sphere_distance < (radius + r):
+
+                    other_part_d = radius - (radius * radius + center_to_sphere_distance * center_to_sphere_distance - r * r) / (center_to_sphere_distance * 2)
+
+                    my_part_d = r - (r * r + center_to_sphere_distance * center_to_sphere_distance - radius * radius) / (center_to_sphere_distance * 2)
+                    
+                    cross_volume = math.pi * other_part_d * other_part_d * (radius - 1/3 * other_part_d) + math.pi * my_part_d * my_part_d * (r - 1/3 * my_part_d)
+                    
+                    sphere_volume_inside_range += cross_volume
+
+            measured_porosity = 1 - (sphere_volume_inside_range / measure_sphere_volume)
+
+            return measured_porosity
+        
+        if type == "averaged_coordination_number":
+            
+            measured_coordination_number = 0
+            if self.DEM_parameters["ContactMeshOption"].GetBool():
+                
+                total_particle_number = 0
+                total_contact_number  = 0
+                for element in self.contact_model_part.Elements:
+            
+                    x_0 = element.GetNode(0).X
+                    x_1 = element.GetNode(1).X
+                    y_0 = element.GetNode(0).Y
+                    y_1 = element.GetNode(1).Y
+                    z_0 = element.GetNode(0).Z
+                    z_1 = element.GetNode(1).Z
+                    r_0 = element.GetNode(0).GetSolutionStepValue(RADIUS)
+                    r_1 = element.GetNode(1).GetSolutionStepValue(RADIUS)
+                    r   = 0.5 * (r_0 + r_1)
+
+                    center_to_sphere_distance_0 = ((x_0 - center_x)**2 + (y_0 - center_y)**2 + (z_0 - center_z)**2)**0.5
+                    center_to_sphere_distance_1 = ((x_1 - center_x)**2 + (y_1 - center_y)**2 + (z_1 - center_z)**2)**0.5
+
+                    if (center_to_sphere_distance_0 < (radius - r)) and (center_to_sphere_distance_1 < (radius - r)):
+                        total_particle_number += 2
+                        total_contact_number += 2
+                    elif (center_to_sphere_distance_0 < (radius - r)) or (center_to_sphere_distance_1 < (radius - r)):
+                        total_particle_number += 1
+                        total_contact_number += 1
+                
+                if total_particle_number:
+                    measured_coordination_number = total_contact_number / total_particle_number
+                
+                return measured_coordination_number
+
+            else:
+                raise Exception('The \"ContactMeshOption\" in the [ProjectParametersDEM.json] should be [True].')
+        
+        if type == "fabric_tensor":
+
+            if self.DEM_parameters["ContactMeshOption"].GetBool():
+                
+                total_tensor = np.empty((3, 3))
+                total_contact_number  = 0
+                number_of_contacts_in_a_direction = np.zeros((36, 36))
+
+                for element in self.contact_model_part.Elements:
+            
+                    x_0 = element.GetNode(0).X
+                    x_1 = element.GetNode(1).X
+                    y_0 = element.GetNode(0).Y
+                    y_1 = element.GetNode(1).Y
+                    z_0 = element.GetNode(0).Z
+                    z_1 = element.GetNode(1).Z
+                    r_0 = element.GetNode(0).GetSolutionStepValue(RADIUS)
+                    r_1 = element.GetNode(1).GetSolutionStepValue(RADIUS)
+                    r   = 0.5 * (r_0 + r_1)
+
+                    center_to_sphere_distance_0 = ((x_0 - center_x)**2 + (y_0 - center_y)**2 + (z_0 - center_z)**2)**0.5
+                    center_to_sphere_distance_1 = ((x_1 - center_x)**2 + (y_1 - center_y)**2 + (z_1 - center_z)**2)**0.5
+
+                    if (center_to_sphere_distance_0 < (radius - r)) or (center_to_sphere_distance_1 < (radius - r)):
+                        
+                        vector1 = np.array([x_1 - x_0 , y_1 - y_0, z_1 - z_0])
+                        vector2 = np.array([x_1 - x_0 , y_1 - y_0, z_1 - z_0])
+                        tensor = np.outer(vector1, vector2)
+                        total_tensor += tensor
+                        total_contact_number += 1
+
+                        #calculate the contact direction
+                        x, y, z = vector1
+                        vector_length = np.linalg.norm(vector1)
+                        theta = np.arccos(z / vector_length)
+                        phi = np.arctan2(y, x)
+                        
+                        theta_index = int(theta / (2 * np.pi) * 36)
+                        phi_index = int(phi / (2 * np.pi) * 36)
+                        
+                        number_of_contacts_in_a_direction[phi_index, theta_index] += 1
+                
+                if total_contact_number:
+                    measured_fabric_tensor = total_tensor / total_contact_number
+
+                eigenvalues, eigenvectors = np.linalg.eig(measured_fabric_tensor)
+
+                output_file_name = "number_of_contacts_in_all_directions_of_size_" + str(radius) +".txt"
+                np.savetxt(os.path.join(self.graphs_path, output_file_name), number_of_contacts_in_a_direction, fmt='%d', delimiter=' ')
+                
+                return eigenvalues
+
+            else:
+                raise Exception('The \"ContactMeshOption\" in the [ProjectParametersDEM.json] should be [True].')
+                
+        if type == "voronoi_input_data":
+
+            particle_id_positions_and_radius = np.empty((0, 5))
+            particle_number_count = 0
+            for node in self.spheres_model_part.Nodes:
+
+                r = node.GetSolutionStepValue(RADIUS)
+                x = node.X
+                y = node.Y
+                z = node.Z
+
+                center_to_sphere_distance = ((x - center_x)**2 + (y - center_y)**2 + (z - center_z)**2)**0.5
+
+                if center_to_sphere_distance < (radius - r):
+
+                    particle_number_count += 1
+                    this_particle_info = np.array([particle_number_count,x, y, z, r])
+                    particle_id_positions_and_radius = np.vstack((particle_id_positions_and_radius, this_particle_info))
+
+            output_file_name = "voronoi_input_data_of_size_" + str(radius) +".txt"
+            fmt_list = ['%d', '%.6f', '%.6f', '%.6f', '%.6f']
+            np.savetxt(os.path.join(self.graphs_path, output_file_name), particle_id_positions_and_radius, fmt=fmt_list, delimiter='\t', comments='')
+        
+        if type == "stress":
+            pass
+
+        if type == "strain":
+            pass
+    
+    def MeasureSphereForGettingRadialDistributionFunction(self, radius, center_x, center_y, center_z, delta_r, d_mean):
+        
+        min_reference_particle_to_center_distance = 1e10
+        particle_positions = np.empty((0, 3))
+        IsTheFirstParticle = True
+        TotalParticleNumber = 0
+        reference_particle = np.empty((0, 3))
+        for node in self.spheres_model_part.Nodes:
+
+                r = node.GetSolutionStepValue(RADIUS)
+                x = node.X
+                y = node.Y
+                z = node.Z
+
+                center_to_sphere_distance = ((x - center_x)**2 + (y - center_y)**2 + (z - center_z)**2)**0.5
+
+                if center_to_sphere_distance < radius:
+
+                    this_particle_position = np.array([x, y, z])
+
+                    if center_to_sphere_distance < min_reference_particle_to_center_distance:
+                        min_reference_particle_to_center_distance = center_to_sphere_distance
+                        if not IsTheFirstParticle:
+                            particle_positions = np.vstack((particle_positions, reference_particle))
+                            TotalParticleNumber += 1
+                        reference_particle = this_particle_position
+                        if IsTheFirstParticle:
+                            IsTheFirstParticle = False
+                    else:
+                        particle_positions = np.vstack((particle_positions, this_particle_position))
+                        TotalParticleNumber += 1
+        
+        # Calculation of distances from reference particles to other particles
+        distances = np.linalg.norm(particle_positions - reference_particle, axis=1)
+
+        # Set histogram parameters
+        max_distance = radius
+        num_bins = int(max_distance // delta_r)
+        bin_edges = np.linspace(0, max_distance, num_bins + 1)
+
+        # Calculate histogram
+        hist, _ = np.histogram(distances, bins=bin_edges)
+
+        # Normalized histogram
+        bin_width = bin_edges[1] - bin_edges[0]
+        measure_sphere_volume = 4/3 * math.pi * radius * radius * radius
+        rdf = hist / (4 * np.pi * bin_edges[1:]**2 * bin_width * TotalParticleNumber / measure_sphere_volume)
+
+        data_to_save = np.column_stack((bin_edges[1:] / d_mean, rdf))
+        output_file_name = "rdf_data_of_size_" + str(radius * 2) +".txt"
+        np.savetxt(os.path.join(self.graphs_path, output_file_name), data_to_save, fmt='%.6f', delimiter='\t', comments='')
+
+    def MeasureCubicForGettingPackingProperties(self, side_length, center_x, center_y, center_z, type):
+        '''
+        This is a function to establish a cubic with 'side_length' to measure local packing properties
+        The type could be "porosity", "averaged_coordination_number", "fabric_tensor", "stress" or "strain" 
+        This funtion is only valid for 3D model now
+        '''
+        if type == "porosity":
+            measure_cubic_volume = side_length ** 3
+            sphere_volume_inside = 0.0
+            measured_porosity = 0.0
+
+            for node in self.spheres_model_part.Nodes:
+
+                r = node.GetSolutionStepValue(RADIUS)
+                x = node.X
+                y = node.Y
+                z = node.Z
+
+                if (center_x - 0.5 * side_length + r) < x < (center_x + 0.5 * side_length - r):
+                    if (center_y - 0.5 * side_length + r) < y < (center_y + 0.5 * side_length - r):
+                        if (center_z - 0.5 * side_length + r) < z < (center_z + 0.5 * side_length - r):
+                            sphere_volume_inside += 4/3 * math.pi * r * r * r
+
+            if measure_cubic_volume:
+                measured_porosity = 1 - (sphere_volume_inside / measure_cubic_volume)
+
+            return measured_porosity
+        
+        if type == "averaged_coordination_number":
+            
+            measured_coordination_number = 0
+            if self.DEM_parameters["ContactMeshOption"].GetBool():
+                
+                total_particle_number = 0
+                total_contact_number  = 0
+                for element in self.contact_model_part.Elements:
+            
+                    x_0 = element.GetNode(0).X
+                    x_1 = element.GetNode(1).X
+                    y_0 = element.GetNode(0).Y
+                    y_1 = element.GetNode(1).Y
+                    z_0 = element.GetNode(0).Z
+                    z_1 = element.GetNode(1).Z
+                    r_0 = element.GetNode(0).GetSolutionStepValue(RADIUS)
+                    r_1 = element.GetNode(1).GetSolutionStepValue(RADIUS)
+                    r   = 0.5 * (r_0 + r_1)
+
+                    if (center_x - 0.5 * side_length + r) < x_0 < (center_x + 0.5 * side_length - r):
+                        if (center_y - 0.5 * side_length + r) < y_0 < (center_y + 0.5 * side_length - r):
+                            if (center_z - 0.5 * side_length + r) < z_0 < (center_z + 0.5 * side_length - r):
+                                total_contact_number += 1
+
+                    if (center_x - 0.5 * side_length + r) < x_1 < (center_x + 0.5 * side_length - r):
+                        if (center_y - 0.5 * side_length + r) < y_1 < (center_y + 0.5 * side_length - r):
+                            if (center_z - 0.5 * side_length + r) < z_1 < (center_z + 0.5 * side_length - r):
+                                total_contact_number += 1
+                
+                for node in self.spheres_model_part.Nodes:
+
+                    r = node.GetSolutionStepValue(RADIUS)
+                    x = node.X
+                    y = node.Y
+                    z = node.Z
+
+                    if (center_x - 0.5 * side_length + r) < x < (center_x + 0.5 * side_length - r):
+                        if (center_y - 0.5 * side_length + r) < y < (center_y + 0.5 * side_length - r):
+                            if (center_z - 0.5 * side_length + r) < z < (center_z + 0.5 * side_length - r):
+                                total_particle_number += 1
+                
+                
+                if total_particle_number:
+                    measured_coordination_number = total_contact_number / total_particle_number
+                
+                return measured_coordination_number
+
+            else:
+                raise Exception('The \"ContactMeshOption\" in the [ProjectParametersDEM.json] should be [True].')
+        
+        if type == "fabric_tensor":
+
+            if self.DEM_parameters["ContactMeshOption"].GetBool():
+                
+                total_tensor = np.empty((3, 3))
+                total_contact_number  = 0
+                number_of_contacts_in_a_direction = np.zeros((18, 36))
+
+                for element in self.contact_model_part.Elements:
+            
+                    x_0 = element.GetNode(0).X
+                    x_1 = element.GetNode(1).X
+                    y_0 = element.GetNode(0).Y
+                    y_1 = element.GetNode(1).Y
+                    z_0 = element.GetNode(0).Z
+                    z_1 = element.GetNode(1).Z
+                    r_0 = element.GetNode(0).GetSolutionStepValue(RADIUS)
+                    r_1 = element.GetNode(1).GetSolutionStepValue(RADIUS)
+                    r   = 0.5 * (r_0 + r_1)
+
+                    sphere_0_is_inside = False
+                    sphere_1_is_inside = False
+
+                    if (center_x - 0.5 * side_length + r) < x_0 < (center_x + 0.5 * side_length - r):
+                        if (center_y - 0.5 * side_length + r) < y_0 < (center_y + 0.5 * side_length - r):
+                            if (center_z - 0.5 * side_length + r) < z_0 < (center_z + 0.5 * side_length - r):
+                                sphere_0_is_inside = True
+
+                    if (center_x - 0.5 * side_length + r) < x_1 < (center_x + 0.5 * side_length - r):
+                        if (center_y - 0.5 * side_length + r) < y_1 < (center_y + 0.5 * side_length - r):
+                            if (center_z - 0.5 * side_length + r) < z_1 < (center_z + 0.5 * side_length - r):
+                                sphere_1_is_inside = True
+
+                    if sphere_0_is_inside or sphere_1_is_inside:
+                        
+                        vector1 = np.array([x_1 - x_0 , y_1 - y_0, z_1 - z_0])
+                        #vector2 = np.array([x_1 - x_0 , y_1 - y_0, z_1 - z_0])
+                        v1_norm = np.linalg.norm(vector1)
+                        if v1_norm:
+                            vector1_unit = vector1 / v1_norm
+                        tensor = np.outer(vector1_unit, vector1_unit)
+                        total_tensor += tensor
+                        total_contact_number += 1
+
+                        #calculate the contact direction
+                        # here, y is the north direction
+                        x, y, z = vector1
+                        vector_length = np.linalg.norm(vector1)
+                        theta = np.arccos(y / vector_length)
+                        phi = np.arctan2(z, x)
+                        if z < 0:
+                            phi += 2 * np.pi
+
+                        theta_index = int(theta / (np.pi) * 18)
+                        phi_index = int(phi / (2 * np.pi) * 36)
+                        
+                        number_of_contacts_in_a_direction[theta_index, phi_index] += 1
+
+                        
+                        vector2 = np.array([x_0 - x_1 , y_0 - y_1, z_0 - z_1])
+                        x, y, z = vector2
+                        vector_length = np.linalg.norm(vector1)
+                        theta = np.arccos(y / vector_length)
+                        phi = np.arctan2(z, x)
+                        if z < 0:
+                            phi += 2 * np.pi
+                        
+                        theta_index = int(theta / (np.pi) * 18)
+                        phi_index = int(phi / (2 * np.pi) * 36)
+                        
+                        number_of_contacts_in_a_direction[theta_index, phi_index] += 1
+                        
+                
+                if total_contact_number:
+                    measured_fabric_tensor = total_tensor / total_contact_number
+                
+                deviatoric_tensor = 4 * (measured_fabric_tensor - 1/3 * np.eye(3)) 
+
+                second_invariant_of_deviatoric_tensor = (0.5 * np.sum(deviatoric_tensor * deviatoric_tensor))**0.5
+
+                eigenvalues, eigenvectors = np.linalg.eig(measured_fabric_tensor)
+
+                output_file_name = "number_of_contacts_in_all_directions_of_size_" + str(side_length) +".txt"
+                np.savetxt(os.path.join(self.graphs_path, output_file_name), number_of_contacts_in_a_direction, fmt='%d', delimiter=' ')
+                
+                return eigenvalues, second_invariant_of_deviatoric_tensor
+
+            else:
+                raise Exception('The \"ContactMeshOption\" in the [ProjectParametersDEM.json] should be [True].')
+            
+        if type == "voronoi_input_data":
+
+            particle_id_positions_and_radius = np.empty((0, 5))
+            particle_number_count = 0
+            for node in self.spheres_model_part.Nodes:
+
+                r = node.GetSolutionStepValue(RADIUS)
+                x = node.X
+                y = node.Y
+                z = node.Z
+
+                sphere_is_inside = False
+
+                if (center_x - 0.5 * side_length + r) < x < (center_x + 0.5 * side_length - r):
+                    if (center_y - 0.5 * side_length + r) < y < (center_y + 0.5 * side_length - r):
+                        if (center_z - 0.5 * side_length + r) < z < (center_z + 0.5 * side_length - r):
+                            sphere_is_inside = True
+
+                if sphere_is_inside:
+
+                    particle_number_count += 1
+                    this_particle_info = np.array([particle_number_count,x, y, z, r])
+                    particle_id_positions_and_radius = np.vstack((particle_id_positions_and_radius, this_particle_info))
+
+            output_file_name = "voronoi_input_data_of_size_" + str(side_length) +".txt"
+            fmt_list = ['%d', '%.6f', '%.6f', '%.6f', '%.6f']
+            np.savetxt(os.path.join(self.graphs_path, output_file_name), particle_id_positions_and_radius, fmt=fmt_list, delimiter='\t', comments='')
+
+        if type == "stress":
+            pass
+
+        if type == "strain":
+            pass
+
+if __name__ == "__main__":
+    with open("ProjectParametersDEM.json",'r') as parameter_file:
+        project_parameters = KratosMultiphysics.Parameters(parameter_file.read())
+
+    model = KratosMultiphysics.Model()
+    DEMAnalysisStage(model, project_parameters).Run()
```

## KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_triaxial_test.py

 * *Ordering differences only*

```diff
@@ -1,634 +1,634 @@
-import KratosMultiphysics
-from KratosMultiphysics import *
-from KratosMultiphysics.DEMApplication import *
-import KratosMultiphysics.DEMApplication as DEM
-from KratosMultiphysics.DEMApplication.DEM_analysis_stage import DEMAnalysisStage
-from KratosMultiphysics.DEMApplication import DEM_procedures as DEM_procedures
-import math
-import datetime
-
-class DecompressedMaterialTriaxialTest(DEMAnalysisStage):
-
-    def __init__(self, model, parameters):
-        super().__init__(model, parameters)
-
-        self.parameters = parameters
-        self.compression_stage_completed = False
-        self.decompression_stage_completed = False
-        # Units in Pa and m/s respectively
-        self.SigmaHorizontal = self.parameters["material_test_settings"]["SigmaHorizontal"].GetDouble()
-        self.SigmaVertical = self.parameters["material_test_settings"]["SigmaVertical"].GetDouble()
-        self.SigmaVerticalAlmostZero = self.parameters["material_test_settings"]["SigmaVerticalAlmostZero"].GetDouble()
-        self.PlatesDecompressionVelocity = self.parameters["material_test_settings"]["PlatesDecompressionVelocity"].GetDouble()
-
-    def Initialize(self):
-        super().Initialize()
-        self.GetMainProblemParameters()
-        self.InitializeMaterialTest()
-        self.PrepareDataForGraph()
-        self._GetSolver().cplusplus_strategy.BreakAllBonds()
-        self.ApplyPrecompression()
-        self._GetSolver().cplusplus_strategy.HealAllBonds()
-        ParallelBondUtilities().SetCurrentIndentationAsAReferenceInParallelBonds(self.spheres_model_part)
-        PreUtilities().ResetSkinParticles(self.spheres_model_part)
-        self._GetSolver().cplusplus_strategy.ComputeSkin(self.spheres_model_part, 1.5)
-        self.ApplyDecompression()
-        self.RestoreLoadingVelocity()
-
-    def GetMainProblemParameters(self):
-        list_of_material_relations = self.DEM_material_parameters["material_relations"]        
-        for material_relation in list_of_material_relations:
-            contact_properties = material_relation["Variables"]
-        self.loose_young = contact_properties["LOOSE_MATERIAL_YOUNG_MODULUS"].GetDouble()
-        self.bonded_young = contact_properties["BONDED_MATERIAL_YOUNG_MODULUS"].GetDouble()
-        self.friction = contact_properties["STATIC_FRICTION"].GetDouble()
-        self.contact_tau = contact_properties["CONTACT_TAU_ZERO"].GetDouble()
-
-    def ApplyPrecompression(self):
-
-        print("\n************************************ Applying Precompression...\n", flush=True)
-        while not self.compression_stage_completed:
-            self.time = self._GetSolver().AdvanceInTime(self.time)
-            self.InitializeSolutionStep()
-            self._GetSolver().Predict()
-            self._GetSolver().SolveSolutionStep()
-            self.FinalizeSolutionStepPrecompression()
-            self.OutputSolutionStep()
-        print("\n*************************** Finished Applying Precompression!!!\n", flush=True)
-
-    def ResetLoadingVelocity(self):
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                smp[LINEAR_VELOCITY_Y] = 0.5 * self.PlatesDecompressionVelocity
-            if smp[IDENTIFIER] == 'BOTTOM':
-                smp[LINEAR_VELOCITY_Y] = -0.5 * self.PlatesDecompressionVelocity
-
-    def RestoreLoadingVelocity(self):
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                smp[LINEAR_VELOCITY_Y] =  0.5 * self.LoadingVelocity
-            if smp[IDENTIFIER] == 'BOTTOM':
-                smp[LINEAR_VELOCITY_Y] = -0.5 * self.LoadingVelocity
-
-    def ApplyDecompression(self):
-
-        print("\n************************************ Applying Decompression...\n", flush=True)
-        while not self.decompression_stage_completed:
-            self.time = self._GetSolver().AdvanceInTime(self.time)
-            self.InitializeSolutionStep()
-            self._GetSolver().Predict()
-            self.ResetLoadingVelocity()
-            self._GetSolver().SolveSolutionStep()
-            self.FinalizeSolutionStepDecompression()
-            self.OutputSolutionStep()
-        print("\n*************************** Finished Applying Decompression!!!\n", flush=True)
-
-    def RunSolutionLoop(self):
-
-        print("\n************************************ Applying standard triaxial...\n", flush=True)
-        while self.KeepAdvancingSolutionLoop():
-            self.time = self._GetSolver().AdvanceInTime(self.time)
-            self.InitializeSolutionStep()
-            self._GetSolver().Predict()
-            self._GetSolver().SolveSolutionStep()
-            self.FinalizeSolutionStep()
-            self.OutputSolutionStep()
-        print("\n*************************** Finished Applying standard triaxial...\n", flush=True)
-
-    def OutputSolutionStep(self):
-        super().OutputSolutionStep()
-        self.PrintGraph(self.time)
-
-    def FinalizeSolutionStepPrecompression(self):
-        super().FinalizeSolutionStep()
-        self.MeasureForcesAndPressurePrecompression()
-
-    def FinalizeSolutionStepDecompression(self):
-        super().FinalizeSolutionStep()
-        self.MeasureForcesAndPressureDecompression()
-
-    def FinalizeSolutionStep(self):
-        super().FinalizeSolutionStep()
-        self.MeasureForcesAndPressure()
-
-    def Finalize(self):
-        super().Finalize()
-
-        # TODO: After self.CleanUpOperations() in base class!!
-        self.FinalizeGraphs()
-        self.PrintMachineLearningData()
-    
-    def PrintMachineLearningData(self):
-        import numpy as np
-        from scipy import interpolate
-
-        filename1 = self.absolute_path_to_file1
-        filename2 = os.path.join(os.getcwd(), 'triaxial_experiment_' + str(simulation_number) + '.grf')
-        filename3 = os.path.join(os.getcwd(), 'triaxial_DEM_' + str(simulation_number) + '.grf')
-        X, Y = [], []
-        f1 = open(filename1, 'r')
-        for line in f1:
-            values = [float(s) for s in line.split()]
-            X.append(values[0])
-            q = 145.0 * values[1]
-            Y.append(q)
-        f1.close()
-        minimum = min(Y)
-        min_index = Y.index(minimum)
-        X1 = X[:min_index]
-        X2 = X[min_index:]
-        Y1 = Y[:min_index]
-        Y2 = Y[min_index:]
-        Y2 = [x - 0.000145 * self.ConfinementPressure * 1e6 for x in Y2]
-        index_zero = min(range(len(Y2)), key=lambda i: abs(Y2[i] - 0.0))
-        close_zero = X2[index_zero]
-        X2 = [x - close_zero for x in X2]
-        X2 = X2[index_zero:]
-        Y2 = Y2[index_zero:]
-        f3 = open(filename3, 'w')
-        for i in range(len(X2)):
-            f3.write(str(X2[i]) + "  " + str(Y2[i]) + "\n")
-        f3.close()
-        X3, Y3 = [], []
-        f2 = open(filename2, 'r')
-        for line in f2:
-            values = [float(s) for s in line.split()]
-            X3.append(values[0])
-            q = values[1]
-            Y3.append(q)
-        f2.close()
-        X_0 = max(min(X2), min(X3))
-        X_N = min(max(X2), max(X3))
-        X4 = np.linspace(X_0, X_N, num_of_discretization_points)
-        F2 = interpolate.interp1d(X2, Y2, kind = 'linear')
-        F3 = interpolate.interp1d(X3, Y3, kind = 'linear')
-        minimumX = 1.2 * min(min(X2), min(X3))
-        maximumX = 1.2 * max(max(X2), max(X3))
-        minimumY = 1.2 * min(min(Y2), min(Y3))
-        maximumY = 1.2 * max(max(Y2), max(Y3))
-        
-        if print_images:
-            import matplotlib.pyplot as plt
-            plt.axis([minimumX, maximumX, minimumY, maximumY])
-            plt.xlabel("vertical strain (%)")
-            plt.ylabel("q' (psi)")
-            plt.plot(X2, Y2, color='blue', linewidth=1, linestyle='solid', marker='None', label="DEM")
-            plt.plot(X4, F2(X4), color='blue', markersize=2, linewidth=1, linestyle='dashed', marker='o', label="DEM interpolation")
-            plt.plot(X3, Y3, color='red',  linewidth=1, linestyle='solid', marker='None', label="experiment")
-            plt.plot(X4, F3(X4), color='red',  markersize=2, linewidth=1, linestyle='dashed', marker='o', label="experiment interpolation")
-            plt.title('Triaxial deviatoric effective stress. Precompressed results vs experiments', fontdict = {'fontsize':8})
-            plt.legend(loc='lower right')
-            plt.grid()
-            printfilename = 'dem_triaxial_vs_experiments_' + str(simulation_number) + '.png'
-            plt.savefig(printfilename, dpi=300)
-            plt.close()
-
-        error = []
-        length = len(F2(X4))
-        for i in range(length):
-            error.append(100 * (F2(X4[i]) - F3(X4[i]))/F3(X4[i]))
-        if simulation_number == simulation_number_list[0]:
-            machine_learning_data.write(str("%.8g"%self.loose_young).rjust(13) + '\n')
-            machine_learning_data.write(str("%.8g"%self.bonded_young).rjust(13) + '\n')
-            machine_learning_data.write(str("%.8g"%self.friction).rjust(13) + '\n')
-            machine_learning_data.write(str("%.8g"%self.contact_tau).rjust(13) + '\n')
-        for i in error:
-            machine_learning_data.write(str("%.8g"%i).rjust(13) + '\n')
-        machine_learning_data.flush()
-        if simulation_number == simulation_number_list[-1]:
-            machine_learning_data.close()
-
-    def InitializeMaterialTest(self):
-
-        self.top_mesh_nodes = []; self.bot_mesh_nodes = []; self.top_mesh_fem_nodes = []; self.bot_mesh_fem_nodes = []
-        self.xtop_area = 0.0
-        self.xbot_area = 0.0
-        self.xlat_area = 0.0
-        self.xtopcorner_area = 0.0
-        self.xbotcorner_area = 0.0
-        self.SKIN = list()
-        self.LAT = list()
-        self.BOT = list()
-        self.TOP = list()
-        self.XLAT = list()  # only lat, not the corner ones
-        self.XTOP = list()  # only top, not corner ones...
-        self.XBOT = list()
-        self.XTOPCORNER = list()
-        self.XBOTCORNER = list()
-        self.bond_00_05 = list(); self.bond_05_10 = list(); self.bond_10_15 = list(); self.bond_15_20 = list(); self.bond_20_25 = list(); self.bond_25_30 = list(); self.bond_30_35 = list()
-        self.bond_35_40 = list(); self.bond_40_45 = list(); self.bond_45_50 = list(); self.bond_50_55 = list(); self.bond_55_60 = list(); self.bond_60_65 = list(); self.bond_65_70 = list()
-        self.bond_70_75 = list(); self.bond_75_80 = list(); self.bond_80_85 = list(); self.bond_85_90 = list()
-        self.sizes = []
-        self.sigma_mean_table = []; self.tau_mean_table = []; self.sigma_rel_std_dev_table = []; self.tau_rel_std_dev_table = []; self.sigma_ratio_table = [];
-
-        for i in range(0,18):
-            self.sizes.append(0.0)
-            self.sigma_mean_table.append(0.0)
-            self.tau_mean_table.append(0.0)
-            self.sigma_rel_std_dev_table.append(0.0)
-            self.tau_rel_std_dev_table.append(0.0)
-            self.sigma_ratio_table.append(0.0)
-
-        self.graph_counter = 0; self.renew_pressure = 0; self.Pressure = 0.0; self.pressure_to_apply = 0.0; self.CN_graph_counter = 0
-        self.length_correction_factor = 1.0
-        self.graph_frequency        = int(self.parameters["GraphExportFreq"].GetDouble()/self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME))
-        self.strain = 0.0; self.strain_bts = 0.0; self.volumetric_strain = 0.0; self.radial_strain = 0.0; self.first_time_entry = 1; self.first_time_entry_2 = 1
-        self.total_stress_top = 0.0; self.total_stress_bot = 0.0; self.total_stress_mean = 0.0
-        self.LoadingVelocity = 0.0
-        self.MeasuringSurface = 0.0
-
-        if "material_test_settings" in self.parameters.keys():
-            self.height = self.parameters["material_test_settings"]["SpecimenLength"].GetDouble()
-            self.diameter = self.parameters["material_test_settings"]["SpecimenDiameter"].GetDouble()
-            self.ConfinementPressure = self.parameters["material_test_settings"]["ConfinementPressure"].GetDouble()
-            self.y_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["YCoordinateOfCylinderBottomBase"].GetDouble()
-            self.z_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["ZCoordinateOfCylinderBottomBase"].GetDouble()
-        else:
-            self.height = self.parameters["SpecimenLength"].GetDouble()
-            self.diameter = self.parameters["SpecimenDiameter"].GetDouble()
-            self.ConfinementPressure = self.parameters["ConfinementPressure"].GetDouble()
-            self.y_coordinate_of_cylinder_bottom_base = self.parameters["YCoordinateOfCylinderBottomBase"].GetDouble()
-            self.z_coordinate_of_cylinder_bottom_base = self.parameters["ZCoordinateOfCylinderBottomBase"].GetDouble()
-        
-        self.ConfinementPressure = ConfinementPressure
-
-        self.ComputeLoadingVelocity()
-        self.ComputeMeasuringSurface()
-        self.problem_name = self.parameters["problem_name"].GetString()
-        self.initial_time = datetime.datetime.now()
-        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_Parameter_chart.grf")
-        self.chart = open(absolute_path_to_file, 'w')
-        self.aux = AuxiliaryUtilities()
-        self.PreUtilities = PreUtilities()
-        self.PrepareTests()
-        self.PrepareTestTriaxialHydro()
-        domain_volume = math.pi * 0.5 * 0.5 * self.diameter * self.diameter * self.height
-        DEM_procedures.GranulometryUtils(domain_volume, self.spheres_model_part)
-
-    def MeasureForcesAndPressurePrecompression(self):
-
-        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
-        self.strain += -100 * self.length_correction_factor * self.LoadingVelocity * dt / self.height
-
-        total_force_top = 0.0
-        for node in self.top_mesh_nodes:
-            force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-            total_force_top += force_node_y
-        self.total_stress_top = total_force_top / self.MeasuringSurface
-
-        total_force_bot = 0.0
-        for node in self.bot_mesh_nodes:
-            force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-            total_force_bot += force_node_y
-        self.total_stress_bot = total_force_bot / self.MeasuringSurface
-
-        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
-
-        if self.SigmaHorizontal:
-            self.Pressure = min(self.total_stress_mean, self.SigmaHorizontal)
-            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
-
-        if self.total_stress_mean > self.SigmaVertical:
-            self.compression_stage_completed = True
-
-    def MeasureForcesAndPressureDecompression(self):
-
-        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
-        self.strain += -100 * self.length_correction_factor * self.PlatesDecompressionVelocity * dt / self.height
-
-        total_force_top = 0.0
-        for node in self.top_mesh_nodes:
-            force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-            total_force_top += force_node_y
-        self.total_stress_top = total_force_top / self.MeasuringSurface
-
-        total_force_bot = 0.0
-        for node in self.bot_mesh_nodes:
-            force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-            total_force_bot += force_node_y
-        self.total_stress_bot = total_force_bot / self.MeasuringSurface
-
-        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
-
-        if self.SigmaHorizontal:
-            self.Pressure = min(self.total_stress_mean, self.SigmaHorizontal)
-            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
-
-        if self.total_stress_mean < self.SigmaVerticalAlmostZero:
-            self.decompression_stage_completed = True
-
-    def MeasureForcesAndPressure(self):
-
-        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
-        self.strain += -100 * self.length_correction_factor * self.LoadingVelocity * dt / self.height
-
-        total_force_top = 0.0
-        for node in self.top_mesh_nodes:
-            force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-            total_force_top += force_node_y
-        self.total_stress_top = total_force_top / self.MeasuringSurface
-
-        total_force_bot = 0.0
-        for node in self.bot_mesh_nodes:
-            force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-            total_force_bot += force_node_y
-        self.total_stress_bot = total_force_bot / self.MeasuringSurface
-
-        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
-
-        if self.ConfinementPressure:
-            self.Pressure = min(self.total_stress_mean, self.ConfinementPressure * 1e6)
-            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
-
-    def ComputeLoadingVelocity(self):
-        top_vel = bot_vel = 0.0
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                top_vel = smp[LINEAR_VELOCITY_Y]
-            if smp[IDENTIFIER] == 'BOTTOM':
-                bot_vel = smp[LINEAR_VELOCITY_Y]
-        self.LoadingVelocity = top_vel - bot_vel
-
-    def ComputeMeasuringSurface(self):
-        self.MeasuringSurface = 0.25 * math.pi * self.diameter * self.diameter
-
-    def PrepareTestTriaxialHydro(self):
-
-        ####### Correction Coefs  TODO 0.25* for cylinder section EXXON
-        self.alpha_top = math.pi*self.diameter*self.diameter*0.25/(self.xtop_area + 0.70710678*self.xtopcorner_area)
-        self.alpha_bot = math.pi*self.diameter*self.diameter*0.25/(self.xbot_area + 0.70710678*self.xbotcorner_area)
-        self.alpha_lat = math.pi*self.diameter*self.height/(self.xlat_area + 0.70710678*self.xtopcorner_area + 0.70710678*self.xbotcorner_area)
-
-    def PrepareTests(self):
-
-        absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
-        absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_graph_top.grf")
-        absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_bot.grf")
-        absolute_path_to_file4 = os.path.join(self.graphs_path, self.problem_name + "_graph_strain_vs_q_in_psi.grf")
-        self.graph_export_1 = open(absolute_path_to_file1, 'w')
-        self.graph_export_2 = open(absolute_path_to_file2, 'w')
-        self.graph_export_3 = open(absolute_path_to_file3, 'w')
-        self.graph_export_4 = open(absolute_path_to_file4, 'w')
-
-        (self.xtop_area,self.xbot_area,self.xlat_area,self.xtopcorner_area,self.xbotcorner_area,y_top_total,weight_top, y_bot_total, weight_bot) = self.CylinderSkinDetermination()
-
-        initial_height_top = y_top_total/weight_top
-        initial_height_bot = y_bot_total/weight_bot
-
-        inner_initial_height = initial_height_top - initial_height_bot
-        extended_length = self.height + (self.height - inner_initial_height)
-
-        self.length_correction_factor = self.height/extended_length
-
-        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_CN.grf")
-        self.CN_export = open(absolute_path_to_file, 'w')
-
-    def CylinderSkinDetermination(self):
-
-        # Cylinder dimensions
-        h = self.height
-        d = self.diameter
-        y_min = self.y_coordinate_of_cylinder_bottom_base
-
-        eps = 3.0 #2.0
-        xlat_area = 0.0
-        xbot_area = 0.0
-        xtop_area = 0.0
-        xbotcorner_area = 0.0
-        xtopcorner_area = 0.0
-        y_top_total = 0.0
-        y_bot_total = 0.0
-        weight_top = 0.0
-        weight_bot = 0.0
-
-        for element in self.spheres_model_part.Elements:
-
-            element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 0)
-
-            node = element.GetNode(0)
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            cross_section = math.pi * r * r
-
-            if (x * x + z * z) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
-
-                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
-                self.LAT.append(node)
-
-                if (y > y_min + eps * r) and (y < y_min + (h - eps * r)):
-
-                    self.SKIN.append(element)
-                    self.XLAT.append(node)
-
-                    xlat_area = xlat_area + cross_section
-
-            if (y <= y_min + eps * r) or (y >= y_min + (h - eps * r)):
-
-                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
-                self.SKIN.append(element)
-
-                if y <= y_min + eps * r:
-
-                    self.BOT.append(node)
-                    y_bot_total += y*r
-                    weight_bot += r
-
-                elif y >= y_min + (h - eps * r):
-
-                    self.TOP.append(node)
-
-                    y_top_total += y*r
-                    weight_top += r
-
-                if (x * x + z * z) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
-
-                    if y > y_min + h / 2:
-
-                        self.XTOPCORNER.append(node)
-                        xtopcorner_area = xtopcorner_area + cross_section
-
-                    else:
-
-                        self.XBOTCORNER.append(node)
-                        xbotcorner_area = xbotcorner_area + cross_section
-                else:
-
-                    if y <= y_min + eps * r:
-
-                        self.XBOT.append(node)
-                        xbot_area = xbot_area + cross_section
-
-                    elif y >= y_min + (h - eps * r):
-
-                        self.XTOP.append(node)
-                        xtop_area = xtop_area + cross_section
-        #checks:
-        if len(self.XLAT)==0:
-            self.procedures.KratosPrintWarning("ERROR! in Cylinder Skin Determination - NO LATERAL PARTICLES" + "\n")
-        else:
-            self.procedures.KratosPrintInfo(str(h) + " * " + str(d) + " cylinder skin determination" + "\n")
-
-        return (xtop_area, xbot_area, xlat_area, xtopcorner_area, xbotcorner_area, y_top_total, weight_top, y_bot_total, weight_bot)
-
-    def ApplyLateralPressure(self, Pressure, XLAT, XBOT, XTOP, XBOTCORNER, XTOPCORNER, alpha_top, alpha_bot, alpha_lat):
-
-        for node in XLAT:
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            values = Array3()
-            vect = Array3()
-
-            cross_section = math.pi * r * r
-
-            # normal vector to the center:
-            vect_moduli = math.sqrt(x * x + z * z)
-
-            if vect_moduli > 0.0:
-                vect[0] = -x / vect_moduli
-                vect[1] = 0
-                vect[2] = -z / vect_moduli
-
-            values[0] = cross_section * alpha_lat * Pressure * vect[0]
-            values[1] = 0.0
-            values[2] = cross_section * alpha_lat * Pressure * vect[2]
-
-            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
-
-        for node in XTOPCORNER:
-
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            values = Array3()
-            vect = Array3()
-
-            cross_section = math.pi * r * r
-
-            # normal vector to the center:
-            vect_moduli = math.sqrt(x * x + z * z)
-
-            if vect_moduli > 0.0:
-                vect[0] = -x / vect_moduli
-                vect[1] = 0
-                vect[2] = -z / vect_moduli
-
-            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
-            values[1] = 0.0
-            values[2] = cross_section * alpha_lat * Pressure * vect[2] * 0.70710678
-
-            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
-
-        for node in XBOTCORNER:
-
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            values = Array3()
-            vect = Array3()
-
-            cross_section = math.pi * r * r
-
-            # vector normal al centre:
-            vect_moduli = math.sqrt(x * x + z * z)
-
-            if vect_moduli > 0.0:
-                vect[0] = -x / vect_moduli
-                vect[1] = 0
-                vect[2] = -z / vect_moduli
-
-            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
-            values[1] = 0.0
-            values[2] = cross_section * alpha_lat * Pressure * vect[2] * 0.70710678
-
-            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
-
-    def PrepareDataForGraph(self):
-
-        prepare_check = [0,0,0,0]
-        self.total_check = 0
-
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                self.top_mesh_nodes = smp.Nodes
-                prepare_check[0] = 1
-            if smp[IDENTIFIER] == 'BOTTOM':
-                self.bot_mesh_nodes = smp.Nodes
-                prepare_check[1] = 1
-
-        for smp in self.spheres_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                self.top_mesh_nodes = smp.Nodes
-                prepare_check[2] = -1
-
-            if smp[IDENTIFIER] == 'BOTTOM':
-                self.bot_mesh_nodes = smp.Nodes
-                prepare_check[3] = -1
-
-        for it in range(len(prepare_check)):
-            self.total_check += prepare_check[it]
-
-        if math.fabs(self.total_check) != 2:
-            self.Procedures.KratosPrintWarning(" ERROR in the definition of TOP BOT groups. Both groups are required to be defined, they have to be either on FEM groups or in DEM groups")
-
-    def PrintGraph(self, time):
-
-        if self.graph_counter == self.graph_frequency:
-            self.graph_counter = 0
-            self.graph_export_1.write(str("%.6g"%self.strain).rjust(13) + "  " + str("%.6g"%(self.total_stress_mean * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
-            self.graph_export_2.write(str("%.8g"%self.strain).rjust(13) + "  " + str("%.6g"%(self.total_stress_top  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
-            self.graph_export_3.write(str("%.8g"%self.strain).rjust(13) + "  " + str("%.6g"%(self.total_stress_bot  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
-            self.graph_export_1.flush()
-            self.graph_export_2.flush()
-            self.graph_export_3.flush()
-            self.graph_export_4.write(str("%.8g"%self.strain).rjust(15) + "  " + str("%.6g"%(self.total_stress_mean * 145 * 1e-6 - 145 * self.ConfinementPressure)).rjust(13) +  "  " + str("%.8g"%time).rjust(12) + '\n')
-            self.graph_export_4.flush()
-        self.graph_counter += 1
-
-    def FinalizeGraphs(self):
-        # Create a copy and renaming
-        self.absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
-        absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_bts.grf")
-        absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_VOL.grf")
-        for filename in os.listdir("."):
-            if filename.startswith(self.absolute_path_to_file1):
-                shutil.copy(filename, filename + "COPY")
-                os.rename(filename+"COPY", self.absolute_path_to_file1 + str(self.initial_time).replace(":", "") + ".grf")
-            if filename.startswith(absolute_path_to_file2):
-                shutil.copy(filename, filename + "COPY")
-                os.rename(filename+"COPY", absolute_path_to_file2 + str(self.initial_time).replace(":", "") + ".grf")
-            if filename.startswith(absolute_path_to_file3):
-                shutil.copy(filename, filename + "COPY")
-                os.rename(filename+"COPY", absolute_path_to_file3 + str(self.initial_time).replace(":", "") + ".grf")
-        self.graph_export_1.close()
-        self.graph_export_2.close()
-        self.graph_export_3.close()
-        self.graph_export_4.close()
-
-if __name__ == "__main__":
-
-    with open("ProjectParametersDEM.json", 'r') as parameter_file:
-        parameters = KratosMultiphysics.Parameters(parameter_file.read())
-
-    machine_learning_file = "machine_learning_data.grf"
-    machine_learning_data = open(machine_learning_file, 'w')
-
-    confinement_pressure_list = [0.05, 0.1] # For the triaxials, in MPa
-    num_of_discretization_points = 10 # To compute relative errors
-    print_images = False
-    
-    number_of_triaxials = len(confinement_pressure_list)
-    simulation_number_list = [i for i in range(1, number_of_triaxials + 1)]
-
-    for simulation_number, ConfinementPressure in zip(simulation_number_list, confinement_pressure_list):
-        model = KratosMultiphysics.Model()
-        DecompressedMaterialTriaxialTest(model, parameters).Run()
+import KratosMultiphysics
+from KratosMultiphysics import *
+from KratosMultiphysics.DEMApplication import *
+import KratosMultiphysics.DEMApplication as DEM
+from KratosMultiphysics.DEMApplication.DEM_analysis_stage import DEMAnalysisStage
+from KratosMultiphysics.DEMApplication import DEM_procedures as DEM_procedures
+import math
+import datetime
+
+class DecompressedMaterialTriaxialTest(DEMAnalysisStage):
+
+    def __init__(self, model, parameters):
+        super().__init__(model, parameters)
+
+        self.parameters = parameters
+        self.compression_stage_completed = False
+        self.decompression_stage_completed = False
+        # Units in Pa and m/s respectively
+        self.SigmaHorizontal = self.parameters["material_test_settings"]["SigmaHorizontal"].GetDouble()
+        self.SigmaVertical = self.parameters["material_test_settings"]["SigmaVertical"].GetDouble()
+        self.SigmaVerticalAlmostZero = self.parameters["material_test_settings"]["SigmaVerticalAlmostZero"].GetDouble()
+        self.PlatesDecompressionVelocity = self.parameters["material_test_settings"]["PlatesDecompressionVelocity"].GetDouble()
+
+    def Initialize(self):
+        super().Initialize()
+        self.GetMainProblemParameters()
+        self.InitializeMaterialTest()
+        self.PrepareDataForGraph()
+        self._GetSolver().cplusplus_strategy.BreakAllBonds()
+        self.ApplyPrecompression()
+        self._GetSolver().cplusplus_strategy.HealAllBonds()
+        ParallelBondUtilities().SetCurrentIndentationAsAReferenceInParallelBonds(self.spheres_model_part)
+        PreUtilities().ResetSkinParticles(self.spheres_model_part)
+        self._GetSolver().cplusplus_strategy.ComputeSkin(self.spheres_model_part, 1.5)
+        self.ApplyDecompression()
+        self.RestoreLoadingVelocity()
+
+    def GetMainProblemParameters(self):
+        list_of_material_relations = self.DEM_material_parameters["material_relations"]        
+        for material_relation in list_of_material_relations:
+            contact_properties = material_relation["Variables"]
+        self.loose_young = contact_properties["LOOSE_MATERIAL_YOUNG_MODULUS"].GetDouble()
+        self.bonded_young = contact_properties["BONDED_MATERIAL_YOUNG_MODULUS"].GetDouble()
+        self.friction = contact_properties["STATIC_FRICTION"].GetDouble()
+        self.contact_tau = contact_properties["CONTACT_TAU_ZERO"].GetDouble()
+
+    def ApplyPrecompression(self):
+
+        print("\n************************************ Applying Precompression...\n", flush=True)
+        while not self.compression_stage_completed:
+            self.time = self._GetSolver().AdvanceInTime(self.time)
+            self.InitializeSolutionStep()
+            self._GetSolver().Predict()
+            self._GetSolver().SolveSolutionStep()
+            self.FinalizeSolutionStepPrecompression()
+            self.OutputSolutionStep()
+        print("\n*************************** Finished Applying Precompression!!!\n", flush=True)
+
+    def ResetLoadingVelocity(self):
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                smp[LINEAR_VELOCITY_Y] = 0.5 * self.PlatesDecompressionVelocity
+            if smp[IDENTIFIER] == 'BOTTOM':
+                smp[LINEAR_VELOCITY_Y] = -0.5 * self.PlatesDecompressionVelocity
+
+    def RestoreLoadingVelocity(self):
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                smp[LINEAR_VELOCITY_Y] =  0.5 * self.LoadingVelocity
+            if smp[IDENTIFIER] == 'BOTTOM':
+                smp[LINEAR_VELOCITY_Y] = -0.5 * self.LoadingVelocity
+
+    def ApplyDecompression(self):
+
+        print("\n************************************ Applying Decompression...\n", flush=True)
+        while not self.decompression_stage_completed:
+            self.time = self._GetSolver().AdvanceInTime(self.time)
+            self.InitializeSolutionStep()
+            self._GetSolver().Predict()
+            self.ResetLoadingVelocity()
+            self._GetSolver().SolveSolutionStep()
+            self.FinalizeSolutionStepDecompression()
+            self.OutputSolutionStep()
+        print("\n*************************** Finished Applying Decompression!!!\n", flush=True)
+
+    def RunSolutionLoop(self):
+
+        print("\n************************************ Applying standard triaxial...\n", flush=True)
+        while self.KeepAdvancingSolutionLoop():
+            self.time = self._GetSolver().AdvanceInTime(self.time)
+            self.InitializeSolutionStep()
+            self._GetSolver().Predict()
+            self._GetSolver().SolveSolutionStep()
+            self.FinalizeSolutionStep()
+            self.OutputSolutionStep()
+        print("\n*************************** Finished Applying standard triaxial...\n", flush=True)
+
+    def OutputSolutionStep(self):
+        super().OutputSolutionStep()
+        self.PrintGraph(self.time)
+
+    def FinalizeSolutionStepPrecompression(self):
+        super().FinalizeSolutionStep()
+        self.MeasureForcesAndPressurePrecompression()
+
+    def FinalizeSolutionStepDecompression(self):
+        super().FinalizeSolutionStep()
+        self.MeasureForcesAndPressureDecompression()
+
+    def FinalizeSolutionStep(self):
+        super().FinalizeSolutionStep()
+        self.MeasureForcesAndPressure()
+
+    def Finalize(self):
+        super().Finalize()
+
+        # TODO: After self.CleanUpOperations() in base class!!
+        self.FinalizeGraphs()
+        self.PrintMachineLearningData()
+    
+    def PrintMachineLearningData(self):
+        import numpy as np
+        from scipy import interpolate
+
+        filename1 = self.absolute_path_to_file1
+        filename2 = os.path.join(os.getcwd(), 'triaxial_experiment_' + str(simulation_number) + '.grf')
+        filename3 = os.path.join(os.getcwd(), 'triaxial_DEM_' + str(simulation_number) + '.grf')
+        X, Y = [], []
+        f1 = open(filename1, 'r')
+        for line in f1:
+            values = [float(s) for s in line.split()]
+            X.append(values[0])
+            q = 145.0 * values[1]
+            Y.append(q)
+        f1.close()
+        minimum = min(Y)
+        min_index = Y.index(minimum)
+        X1 = X[:min_index]
+        X2 = X[min_index:]
+        Y1 = Y[:min_index]
+        Y2 = Y[min_index:]
+        Y2 = [x - 0.000145 * self.ConfinementPressure * 1e6 for x in Y2]
+        index_zero = min(range(len(Y2)), key=lambda i: abs(Y2[i] - 0.0))
+        close_zero = X2[index_zero]
+        X2 = [x - close_zero for x in X2]
+        X2 = X2[index_zero:]
+        Y2 = Y2[index_zero:]
+        f3 = open(filename3, 'w')
+        for i in range(len(X2)):
+            f3.write(str(X2[i]) + "  " + str(Y2[i]) + "\n")
+        f3.close()
+        X3, Y3 = [], []
+        f2 = open(filename2, 'r')
+        for line in f2:
+            values = [float(s) for s in line.split()]
+            X3.append(values[0])
+            q = values[1]
+            Y3.append(q)
+        f2.close()
+        X_0 = max(min(X2), min(X3))
+        X_N = min(max(X2), max(X3))
+        X4 = np.linspace(X_0, X_N, num_of_discretization_points)
+        F2 = interpolate.interp1d(X2, Y2, kind = 'linear')
+        F3 = interpolate.interp1d(X3, Y3, kind = 'linear')
+        minimumX = 1.2 * min(min(X2), min(X3))
+        maximumX = 1.2 * max(max(X2), max(X3))
+        minimumY = 1.2 * min(min(Y2), min(Y3))
+        maximumY = 1.2 * max(max(Y2), max(Y3))
+        
+        if print_images:
+            import matplotlib.pyplot as plt
+            plt.axis([minimumX, maximumX, minimumY, maximumY])
+            plt.xlabel("vertical strain (%)")
+            plt.ylabel("q' (psi)")
+            plt.plot(X2, Y2, color='blue', linewidth=1, linestyle='solid', marker='None', label="DEM")
+            plt.plot(X4, F2(X4), color='blue', markersize=2, linewidth=1, linestyle='dashed', marker='o', label="DEM interpolation")
+            plt.plot(X3, Y3, color='red',  linewidth=1, linestyle='solid', marker='None', label="experiment")
+            plt.plot(X4, F3(X4), color='red',  markersize=2, linewidth=1, linestyle='dashed', marker='o', label="experiment interpolation")
+            plt.title('Triaxial deviatoric effective stress. Precompressed results vs experiments', fontdict = {'fontsize':8})
+            plt.legend(loc='lower right')
+            plt.grid()
+            printfilename = 'dem_triaxial_vs_experiments_' + str(simulation_number) + '.png'
+            plt.savefig(printfilename, dpi=300)
+            plt.close()
+
+        error = []
+        length = len(F2(X4))
+        for i in range(length):
+            error.append(100 * (F2(X4[i]) - F3(X4[i]))/F3(X4[i]))
+        if simulation_number == simulation_number_list[0]:
+            machine_learning_data.write(str("%.8g"%self.loose_young).rjust(13) + '\n')
+            machine_learning_data.write(str("%.8g"%self.bonded_young).rjust(13) + '\n')
+            machine_learning_data.write(str("%.8g"%self.friction).rjust(13) + '\n')
+            machine_learning_data.write(str("%.8g"%self.contact_tau).rjust(13) + '\n')
+        for i in error:
+            machine_learning_data.write(str("%.8g"%i).rjust(13) + '\n')
+        machine_learning_data.flush()
+        if simulation_number == simulation_number_list[-1]:
+            machine_learning_data.close()
+
+    def InitializeMaterialTest(self):
+
+        self.top_mesh_nodes = []; self.bot_mesh_nodes = []; self.top_mesh_fem_nodes = []; self.bot_mesh_fem_nodes = []
+        self.xtop_area = 0.0
+        self.xbot_area = 0.0
+        self.xlat_area = 0.0
+        self.xtopcorner_area = 0.0
+        self.xbotcorner_area = 0.0
+        self.SKIN = list()
+        self.LAT = list()
+        self.BOT = list()
+        self.TOP = list()
+        self.XLAT = list()  # only lat, not the corner ones
+        self.XTOP = list()  # only top, not corner ones...
+        self.XBOT = list()
+        self.XTOPCORNER = list()
+        self.XBOTCORNER = list()
+        self.bond_00_05 = list(); self.bond_05_10 = list(); self.bond_10_15 = list(); self.bond_15_20 = list(); self.bond_20_25 = list(); self.bond_25_30 = list(); self.bond_30_35 = list()
+        self.bond_35_40 = list(); self.bond_40_45 = list(); self.bond_45_50 = list(); self.bond_50_55 = list(); self.bond_55_60 = list(); self.bond_60_65 = list(); self.bond_65_70 = list()
+        self.bond_70_75 = list(); self.bond_75_80 = list(); self.bond_80_85 = list(); self.bond_85_90 = list()
+        self.sizes = []
+        self.sigma_mean_table = []; self.tau_mean_table = []; self.sigma_rel_std_dev_table = []; self.tau_rel_std_dev_table = []; self.sigma_ratio_table = [];
+
+        for i in range(0,18):
+            self.sizes.append(0.0)
+            self.sigma_mean_table.append(0.0)
+            self.tau_mean_table.append(0.0)
+            self.sigma_rel_std_dev_table.append(0.0)
+            self.tau_rel_std_dev_table.append(0.0)
+            self.sigma_ratio_table.append(0.0)
+
+        self.graph_counter = 0; self.renew_pressure = 0; self.Pressure = 0.0; self.pressure_to_apply = 0.0; self.CN_graph_counter = 0
+        self.length_correction_factor = 1.0
+        self.graph_frequency        = int(self.parameters["GraphExportFreq"].GetDouble()/self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME))
+        self.strain = 0.0; self.strain_bts = 0.0; self.volumetric_strain = 0.0; self.radial_strain = 0.0; self.first_time_entry = 1; self.first_time_entry_2 = 1
+        self.total_stress_top = 0.0; self.total_stress_bot = 0.0; self.total_stress_mean = 0.0
+        self.LoadingVelocity = 0.0
+        self.MeasuringSurface = 0.0
+
+        if "material_test_settings" in self.parameters.keys():
+            self.height = self.parameters["material_test_settings"]["SpecimenLength"].GetDouble()
+            self.diameter = self.parameters["material_test_settings"]["SpecimenDiameter"].GetDouble()
+            self.ConfinementPressure = self.parameters["material_test_settings"]["ConfinementPressure"].GetDouble()
+            self.y_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["YCoordinateOfCylinderBottomBase"].GetDouble()
+            self.z_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["ZCoordinateOfCylinderBottomBase"].GetDouble()
+        else:
+            self.height = self.parameters["SpecimenLength"].GetDouble()
+            self.diameter = self.parameters["SpecimenDiameter"].GetDouble()
+            self.ConfinementPressure = self.parameters["ConfinementPressure"].GetDouble()
+            self.y_coordinate_of_cylinder_bottom_base = self.parameters["YCoordinateOfCylinderBottomBase"].GetDouble()
+            self.z_coordinate_of_cylinder_bottom_base = self.parameters["ZCoordinateOfCylinderBottomBase"].GetDouble()
+        
+        self.ConfinementPressure = ConfinementPressure
+
+        self.ComputeLoadingVelocity()
+        self.ComputeMeasuringSurface()
+        self.problem_name = self.parameters["problem_name"].GetString()
+        self.initial_time = datetime.datetime.now()
+        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_Parameter_chart.grf")
+        self.chart = open(absolute_path_to_file, 'w')
+        self.aux = AuxiliaryUtilities()
+        self.PreUtilities = PreUtilities()
+        self.PrepareTests()
+        self.PrepareTestTriaxialHydro()
+        domain_volume = math.pi * 0.5 * 0.5 * self.diameter * self.diameter * self.height
+        DEM_procedures.GranulometryUtils(domain_volume, self.spheres_model_part)
+
+    def MeasureForcesAndPressurePrecompression(self):
+
+        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
+        self.strain += -100 * self.length_correction_factor * self.LoadingVelocity * dt / self.height
+
+        total_force_top = 0.0
+        for node in self.top_mesh_nodes:
+            force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+            total_force_top += force_node_y
+        self.total_stress_top = total_force_top / self.MeasuringSurface
+
+        total_force_bot = 0.0
+        for node in self.bot_mesh_nodes:
+            force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+            total_force_bot += force_node_y
+        self.total_stress_bot = total_force_bot / self.MeasuringSurface
+
+        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
+
+        if self.SigmaHorizontal:
+            self.Pressure = min(self.total_stress_mean, self.SigmaHorizontal)
+            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
+
+        if self.total_stress_mean > self.SigmaVertical:
+            self.compression_stage_completed = True
+
+    def MeasureForcesAndPressureDecompression(self):
+
+        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
+        self.strain += -100 * self.length_correction_factor * self.PlatesDecompressionVelocity * dt / self.height
+
+        total_force_top = 0.0
+        for node in self.top_mesh_nodes:
+            force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+            total_force_top += force_node_y
+        self.total_stress_top = total_force_top / self.MeasuringSurface
+
+        total_force_bot = 0.0
+        for node in self.bot_mesh_nodes:
+            force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+            total_force_bot += force_node_y
+        self.total_stress_bot = total_force_bot / self.MeasuringSurface
+
+        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
+
+        if self.SigmaHorizontal:
+            self.Pressure = min(self.total_stress_mean, self.SigmaHorizontal)
+            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
+
+        if self.total_stress_mean < self.SigmaVerticalAlmostZero:
+            self.decompression_stage_completed = True
+
+    def MeasureForcesAndPressure(self):
+
+        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
+        self.strain += -100 * self.length_correction_factor * self.LoadingVelocity * dt / self.height
+
+        total_force_top = 0.0
+        for node in self.top_mesh_nodes:
+            force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+            total_force_top += force_node_y
+        self.total_stress_top = total_force_top / self.MeasuringSurface
+
+        total_force_bot = 0.0
+        for node in self.bot_mesh_nodes:
+            force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+            total_force_bot += force_node_y
+        self.total_stress_bot = total_force_bot / self.MeasuringSurface
+
+        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
+
+        if self.ConfinementPressure:
+            self.Pressure = min(self.total_stress_mean, self.ConfinementPressure * 1e6)
+            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
+
+    def ComputeLoadingVelocity(self):
+        top_vel = bot_vel = 0.0
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                top_vel = smp[LINEAR_VELOCITY_Y]
+            if smp[IDENTIFIER] == 'BOTTOM':
+                bot_vel = smp[LINEAR_VELOCITY_Y]
+        self.LoadingVelocity = top_vel - bot_vel
+
+    def ComputeMeasuringSurface(self):
+        self.MeasuringSurface = 0.25 * math.pi * self.diameter * self.diameter
+
+    def PrepareTestTriaxialHydro(self):
+
+        ####### Correction Coefs  TODO 0.25* for cylinder section EXXON
+        self.alpha_top = math.pi*self.diameter*self.diameter*0.25/(self.xtop_area + 0.70710678*self.xtopcorner_area)
+        self.alpha_bot = math.pi*self.diameter*self.diameter*0.25/(self.xbot_area + 0.70710678*self.xbotcorner_area)
+        self.alpha_lat = math.pi*self.diameter*self.height/(self.xlat_area + 0.70710678*self.xtopcorner_area + 0.70710678*self.xbotcorner_area)
+
+    def PrepareTests(self):
+
+        absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
+        absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_graph_top.grf")
+        absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_bot.grf")
+        absolute_path_to_file4 = os.path.join(self.graphs_path, self.problem_name + "_graph_strain_vs_q_in_psi.grf")
+        self.graph_export_1 = open(absolute_path_to_file1, 'w')
+        self.graph_export_2 = open(absolute_path_to_file2, 'w')
+        self.graph_export_3 = open(absolute_path_to_file3, 'w')
+        self.graph_export_4 = open(absolute_path_to_file4, 'w')
+
+        (self.xtop_area,self.xbot_area,self.xlat_area,self.xtopcorner_area,self.xbotcorner_area,y_top_total,weight_top, y_bot_total, weight_bot) = self.CylinderSkinDetermination()
+
+        initial_height_top = y_top_total/weight_top
+        initial_height_bot = y_bot_total/weight_bot
+
+        inner_initial_height = initial_height_top - initial_height_bot
+        extended_length = self.height + (self.height - inner_initial_height)
+
+        self.length_correction_factor = self.height/extended_length
+
+        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_CN.grf")
+        self.CN_export = open(absolute_path_to_file, 'w')
+
+    def CylinderSkinDetermination(self):
+
+        # Cylinder dimensions
+        h = self.height
+        d = self.diameter
+        y_min = self.y_coordinate_of_cylinder_bottom_base
+
+        eps = 3.0 #2.0
+        xlat_area = 0.0
+        xbot_area = 0.0
+        xtop_area = 0.0
+        xbotcorner_area = 0.0
+        xtopcorner_area = 0.0
+        y_top_total = 0.0
+        y_bot_total = 0.0
+        weight_top = 0.0
+        weight_bot = 0.0
+
+        for element in self.spheres_model_part.Elements:
+
+            element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 0)
+
+            node = element.GetNode(0)
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            cross_section = math.pi * r * r
+
+            if (x * x + z * z) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
+
+                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
+                self.LAT.append(node)
+
+                if (y > y_min + eps * r) and (y < y_min + (h - eps * r)):
+
+                    self.SKIN.append(element)
+                    self.XLAT.append(node)
+
+                    xlat_area = xlat_area + cross_section
+
+            if (y <= y_min + eps * r) or (y >= y_min + (h - eps * r)):
+
+                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
+                self.SKIN.append(element)
+
+                if y <= y_min + eps * r:
+
+                    self.BOT.append(node)
+                    y_bot_total += y*r
+                    weight_bot += r
+
+                elif y >= y_min + (h - eps * r):
+
+                    self.TOP.append(node)
+
+                    y_top_total += y*r
+                    weight_top += r
+
+                if (x * x + z * z) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
+
+                    if y > y_min + h / 2:
+
+                        self.XTOPCORNER.append(node)
+                        xtopcorner_area = xtopcorner_area + cross_section
+
+                    else:
+
+                        self.XBOTCORNER.append(node)
+                        xbotcorner_area = xbotcorner_area + cross_section
+                else:
+
+                    if y <= y_min + eps * r:
+
+                        self.XBOT.append(node)
+                        xbot_area = xbot_area + cross_section
+
+                    elif y >= y_min + (h - eps * r):
+
+                        self.XTOP.append(node)
+                        xtop_area = xtop_area + cross_section
+        #checks:
+        if len(self.XLAT)==0:
+            self.procedures.KratosPrintWarning("ERROR! in Cylinder Skin Determination - NO LATERAL PARTICLES" + "\n")
+        else:
+            self.procedures.KratosPrintInfo(str(h) + " * " + str(d) + " cylinder skin determination" + "\n")
+
+        return (xtop_area, xbot_area, xlat_area, xtopcorner_area, xbotcorner_area, y_top_total, weight_top, y_bot_total, weight_bot)
+
+    def ApplyLateralPressure(self, Pressure, XLAT, XBOT, XTOP, XBOTCORNER, XTOPCORNER, alpha_top, alpha_bot, alpha_lat):
+
+        for node in XLAT:
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            values = Array3()
+            vect = Array3()
+
+            cross_section = math.pi * r * r
+
+            # normal vector to the center:
+            vect_moduli = math.sqrt(x * x + z * z)
+
+            if vect_moduli > 0.0:
+                vect[0] = -x / vect_moduli
+                vect[1] = 0
+                vect[2] = -z / vect_moduli
+
+            values[0] = cross_section * alpha_lat * Pressure * vect[0]
+            values[1] = 0.0
+            values[2] = cross_section * alpha_lat * Pressure * vect[2]
+
+            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
+
+        for node in XTOPCORNER:
+
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            values = Array3()
+            vect = Array3()
+
+            cross_section = math.pi * r * r
+
+            # normal vector to the center:
+            vect_moduli = math.sqrt(x * x + z * z)
+
+            if vect_moduli > 0.0:
+                vect[0] = -x / vect_moduli
+                vect[1] = 0
+                vect[2] = -z / vect_moduli
+
+            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
+            values[1] = 0.0
+            values[2] = cross_section * alpha_lat * Pressure * vect[2] * 0.70710678
+
+            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
+
+        for node in XBOTCORNER:
+
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            values = Array3()
+            vect = Array3()
+
+            cross_section = math.pi * r * r
+
+            # vector normal al centre:
+            vect_moduli = math.sqrt(x * x + z * z)
+
+            if vect_moduli > 0.0:
+                vect[0] = -x / vect_moduli
+                vect[1] = 0
+                vect[2] = -z / vect_moduli
+
+            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
+            values[1] = 0.0
+            values[2] = cross_section * alpha_lat * Pressure * vect[2] * 0.70710678
+
+            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
+
+    def PrepareDataForGraph(self):
+
+        prepare_check = [0,0,0,0]
+        self.total_check = 0
+
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                self.top_mesh_nodes = smp.Nodes
+                prepare_check[0] = 1
+            if smp[IDENTIFIER] == 'BOTTOM':
+                self.bot_mesh_nodes = smp.Nodes
+                prepare_check[1] = 1
+
+        for smp in self.spheres_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                self.top_mesh_nodes = smp.Nodes
+                prepare_check[2] = -1
+
+            if smp[IDENTIFIER] == 'BOTTOM':
+                self.bot_mesh_nodes = smp.Nodes
+                prepare_check[3] = -1
+
+        for it in range(len(prepare_check)):
+            self.total_check += prepare_check[it]
+
+        if math.fabs(self.total_check) != 2:
+            self.Procedures.KratosPrintWarning(" ERROR in the definition of TOP BOT groups. Both groups are required to be defined, they have to be either on FEM groups or in DEM groups")
+
+    def PrintGraph(self, time):
+
+        if self.graph_counter == self.graph_frequency:
+            self.graph_counter = 0
+            self.graph_export_1.write(str("%.6g"%self.strain).rjust(13) + "  " + str("%.6g"%(self.total_stress_mean * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
+            self.graph_export_2.write(str("%.8g"%self.strain).rjust(13) + "  " + str("%.6g"%(self.total_stress_top  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
+            self.graph_export_3.write(str("%.8g"%self.strain).rjust(13) + "  " + str("%.6g"%(self.total_stress_bot  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
+            self.graph_export_1.flush()
+            self.graph_export_2.flush()
+            self.graph_export_3.flush()
+            self.graph_export_4.write(str("%.8g"%self.strain).rjust(15) + "  " + str("%.6g"%(self.total_stress_mean * 145 * 1e-6 - 145 * self.ConfinementPressure)).rjust(13) +  "  " + str("%.8g"%time).rjust(12) + '\n')
+            self.graph_export_4.flush()
+        self.graph_counter += 1
+
+    def FinalizeGraphs(self):
+        # Create a copy and renaming
+        self.absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
+        absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_bts.grf")
+        absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_VOL.grf")
+        for filename in os.listdir("."):
+            if filename.startswith(self.absolute_path_to_file1):
+                shutil.copy(filename, filename + "COPY")
+                os.rename(filename+"COPY", self.absolute_path_to_file1 + str(self.initial_time).replace(":", "") + ".grf")
+            if filename.startswith(absolute_path_to_file2):
+                shutil.copy(filename, filename + "COPY")
+                os.rename(filename+"COPY", absolute_path_to_file2 + str(self.initial_time).replace(":", "") + ".grf")
+            if filename.startswith(absolute_path_to_file3):
+                shutil.copy(filename, filename + "COPY")
+                os.rename(filename+"COPY", absolute_path_to_file3 + str(self.initial_time).replace(":", "") + ".grf")
+        self.graph_export_1.close()
+        self.graph_export_2.close()
+        self.graph_export_3.close()
+        self.graph_export_4.close()
+
+if __name__ == "__main__":
+
+    with open("ProjectParametersDEM.json", 'r') as parameter_file:
+        parameters = KratosMultiphysics.Parameters(parameter_file.read())
+
+    machine_learning_file = "machine_learning_data.grf"
+    machine_learning_data = open(machine_learning_file, 'w')
+
+    confinement_pressure_list = [0.05, 0.1] # For the triaxials, in MPa
+    num_of_discretization_points = 10 # To compute relative errors
+    print_images = False
+    
+    number_of_triaxials = len(confinement_pressure_list)
+    simulation_number_list = [i for i in range(1, number_of_triaxials + 1)]
+
+    for simulation_number, ConfinementPressure in zip(simulation_number_list, confinement_pressure_list):
+        model = KratosMultiphysics.Model()
+        DecompressedMaterialTriaxialTest(model, parameters).Run()
```

## KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_triaxials_and_bts_tests.py

 * *Ordering differences only*

```diff
@@ -1,1234 +1,1234 @@
-import KratosMultiphysics
-from KratosMultiphysics import *
-from KratosMultiphysics.DEMApplication import *
-import KratosMultiphysics.DEMApplication as DEM
-from KratosMultiphysics.DEMApplication.DEM_analysis_stage import DEMAnalysisStage
-from KratosMultiphysics.DEMApplication import DEM_procedures as DEM_procedures
-import math
-import datetime
-
-class DecompressedMaterialTriaxialTest(DEMAnalysisStage):
-
-    def __init__(self, model, parameters):
-        super().__init__(model, parameters)
-        self.parameters = parameters
-        self.compression_stage_completed = False
-        self.decompression_stage_completed = False
-        # Units in Pa and m/s respectively
-        self.SigmaHorizontal = self.parameters["material_test_settings"]["SigmaHorizontal"].GetDouble()
-        self.SigmaVertical = self.parameters["material_test_settings"]["SigmaVertical"].GetDouble()
-        self.SigmaVerticalAlmostZero = self.parameters["material_test_settings"]["SigmaVerticalAlmostZero"].GetDouble()
-        self.PlatesDecompressionVelocity = self.parameters["material_test_settings"]["PlatesDecompressionVelocity"].GetDouble()
-
-    def Initialize(self):
-        super().Initialize()
-        self.GetMainProblemParameters()
-        self.InitializeMaterialTest()
-        self.PrepareDataForGraph()
-        self._GetSolver().cplusplus_strategy.BreakAllBonds()
-        self.ApplyPrecompression()
-        self._GetSolver().cplusplus_strategy.HealAllBonds()
-        ParallelBondUtilities().SetCurrentIndentationAsAReferenceInParallelBonds(self.spheres_model_part)
-        PreUtilities().ResetSkinParticles(self.spheres_model_part)
-        self._GetSolver().cplusplus_strategy.ComputeSkin(self.spheres_model_part, 1.5)
-        self.ApplyDecompression()
-        self.RestoreLoadingVelocity()
-
-    def GetMainProblemParameters(self):
-        list_of_material_relations = self.DEM_material_parameters["material_relations"]        
-        for material_relation in list_of_material_relations:
-            contact_properties = material_relation["Variables"]
-        self.loose_young = contact_properties["LOOSE_MATERIAL_YOUNG_MODULUS"].GetDouble()
-        self.bonded_young = contact_properties["BONDED_MATERIAL_YOUNG_MODULUS"].GetDouble()
-        self.friction = contact_properties["STATIC_FRICTION"].GetDouble()
-        self.contact_tau = contact_properties["CONTACT_TAU_ZERO"].GetDouble()
-
-    def ApplyPrecompression(self):
-
-        print("\n************************************ Applying Precompression...\n", flush=True)
-        while not self.compression_stage_completed:
-            self.time = self._GetSolver().AdvanceInTime(self.time)
-            self.InitializeSolutionStep()
-            self._GetSolver().Predict()
-            self._GetSolver().SolveSolutionStep()
-            self.FinalizeSolutionStepPrecompression()
-            self.OutputSolutionStep()
-        print("\n*************************** Finished Applying Precompression!!!\n", flush=True)
-
-    def ResetLoadingVelocity(self):
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                smp[LINEAR_VELOCITY_Y] = 0.5 * self.PlatesDecompressionVelocity
-            if smp[IDENTIFIER] == 'BOTTOM':
-                smp[LINEAR_VELOCITY_Y] = -0.5 * self.PlatesDecompressionVelocity
-    def RestoreLoadingVelocity(self):
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                smp[LINEAR_VELOCITY_Y] =  0.5 * self.LoadingVelocity
-            if smp[IDENTIFIER] == 'BOTTOM':
-                smp[LINEAR_VELOCITY_Y] = -0.5 * self.LoadingVelocity
-
-    def ApplyDecompression(self):
-
-        print("\n************************************ Applying Decompression...\n", flush=True)
-        while not self.decompression_stage_completed:
-            self.time = self._GetSolver().AdvanceInTime(self.time)
-            self.InitializeSolutionStep()
-            self._GetSolver().Predict()
-            self.ResetLoadingVelocity()
-            self._GetSolver().SolveSolutionStep()
-            self.FinalizeSolutionStepDecompression()
-            self.OutputSolutionStep()
-        print("\n*************************** Finished Applying Decompression!!!\n", flush=True)
-    def RunSolutionLoop(self):
-
-        print("\n************************************ Applying standard triaxial...\n", flush=True)
-        while self.KeepAdvancingSolutionLoop():
-            self.time = self._GetSolver().AdvanceInTime(self.time)
-            self.InitializeSolutionStep()
-            self._GetSolver().Predict()
-            self._GetSolver().SolveSolutionStep()
-            self.FinalizeSolutionStep()
-            self.OutputSolutionStep()
-        print("\n*************************** Finished Applying standard triaxial...\n", flush=True)
-
-    def OutputSolutionStep(self):
-        super().OutputSolutionStep()
-        self.PrintGraph(self.time)
-
-    def FinalizeSolutionStepPrecompression(self):
-        super().FinalizeSolutionStep()
-        self.MeasureForcesAndPressurePrecompression()
-    def FinalizeSolutionStepDecompression(self):
-        super().FinalizeSolutionStep()
-        self.MeasureForcesAndPressureDecompression()
-    def FinalizeSolutionStep(self):
-        super().FinalizeSolutionStep()
-        self.MeasureForcesAndPressure()
-
-    def Finalize(self):
-        super().Finalize()
-        # TODO: After self.CleanUpOperations() in base class!!
-        self.FinalizeGraphs()
-        self.PrintMachineLearningData()
-    
-    def PrintMachineLearningData(self):
-        import numpy as np
-        from scipy import interpolate
-
-        filename1 = self.absolute_path_to_file1
-        filename2 = os.path.join(os.getcwd(), 'triaxial_experiment_' + str(simulation_number) + '.grf')
-        filename3 = os.path.join(os.getcwd(), 'triaxial_DEM_' + str(simulation_number) + '.grf')
-        X, Y = [], []
-        f1 = open(filename1, 'r')
-        for line in f1:
-            values = [float(s) for s in line.split()]
-            X.append(values[0])
-            q = 145.0 * values[1]
-            Y.append(q)
-        f1.close()
-        minimum = min(Y)
-        min_index = Y.index(minimum)
-        X1 = X[:min_index]
-        X2 = X[min_index:]
-        Y1 = Y[:min_index]
-        Y2 = Y[min_index:]
-        Y2 = [x - 0.000145 * self.ConfinementPressure * 1e6 for x in Y2]
-        index_zero = min(range(len(Y2)), key=lambda i: abs(Y2[i] - 0.0))
-        close_zero = X2[index_zero]
-        X2 = [x - close_zero for x in X2]
-        X2 = X2[index_zero:]
-        Y2 = Y2[index_zero:]
-        f3 = open(filename3, 'w')
-        for i in range(len(X2)):
-            f3.write(str(X2[i]) + "  " + str(Y2[i]) + "\n")
-        f3.close()
-        X3, Y3 = [], []
-        f2 = open(filename2, 'r')
-        for line in f2:
-            values = [float(s) for s in line.split()]
-            X3.append(values[0])
-            q = values[1]
-            Y3.append(q)
-        f2.close()
-        X_0 = max(min(X2), min(X3))
-        X_N = min(max(X2), max(X3))
-        X4 = np.linspace(X_0, X_N, num_of_discretization_points)
-        F2 = interpolate.interp1d(X2, Y2, kind = 'linear')
-        F3 = interpolate.interp1d(X3, Y3, kind = 'linear')
-        minimumX = 1.2 * min(min(X2), min(X3))
-        maximumX = 1.2 * max(max(X2), max(X3))
-        minimumY = 1.2 * min(min(Y2), min(Y3))
-        maximumY = 1.2 * max(max(Y2), max(Y3))
-        
-        if print_images:
-            import matplotlib.pyplot as plt
-            plt.axis([minimumX, maximumX, minimumY, maximumY])
-            plt.xlabel("vertical strain (%)")
-            plt.ylabel("q' (psi)")
-            plt.plot(X2, Y2, color='blue', linewidth=1, linestyle='solid', marker='None', label="DEM")
-            plt.plot(X4, F2(X4), color='blue', markersize=2, linewidth=1, linestyle='dashed', marker='o', label="DEM interpolation")
-            plt.plot(X3, Y3, color='red',  linewidth=1, linestyle='solid', marker='None', label="experiment")
-            plt.plot(X4, F3(X4), color='red',  markersize=2, linewidth=1, linestyle='dashed', marker='o', label="experiment interpolation")
-            plt.title('Triaxial deviatoric effective stress. Precompressed results vs experiments', fontdict = {'fontsize':8})
-            plt.legend(loc='lower right')
-            plt.grid()
-            printfilename = 'dem_triaxial_vs_experiments_' + str(simulation_number) + '.png'
-            plt.savefig(printfilename, dpi=300)
-            plt.close()
-
-        error = []
-        length = len(F2(X4))
-        for i in range(length):
-            error.append(100 * (F2(X4[i]) - F3(X4[i]))/F3(X4[i]))
-        if simulation_number == simulation_number_list[0]:
-            machine_learning_data.write(str("%.8g"%self.loose_young).rjust(13) + '\n')
-            machine_learning_data.write(str("%.8g"%self.bonded_young).rjust(13) + '\n')
-            machine_learning_data.write(str("%.8g"%self.friction).rjust(13) + '\n')
-            machine_learning_data.write(str("%.8g"%self.contact_tau).rjust(13) + '\n')
-        for i in error:
-            machine_learning_data.write(str("%.8g"%i).rjust(13) + '\n')
-        machine_learning_data.flush()
-
-    def InitializeMaterialTest(self):
-
-        self.top_mesh_nodes = []; self.bot_mesh_nodes = []; self.top_mesh_fem_nodes = []; self.bot_mesh_fem_nodes = []
-        self.xtop_area = 0.0
-        self.xbot_area = 0.0
-        self.xlat_area = 0.0
-        self.xtopcorner_area = 0.0
-        self.xbotcorner_area = 0.0
-        self.SKIN = list()
-        self.LAT = list()
-        self.BOT = list()
-        self.TOP = list()
-        self.XLAT = list()  # only lat, not the corner ones
-        self.XTOP = list()  # only top, not corner ones...
-        self.XBOT = list()
-        self.XTOPCORNER = list()
-        self.XBOTCORNER = list()
-        self.bond_00_05 = list(); self.bond_05_10 = list(); self.bond_10_15 = list(); self.bond_15_20 = list(); self.bond_20_25 = list(); self.bond_25_30 = list(); self.bond_30_35 = list()
-        self.bond_35_40 = list(); self.bond_40_45 = list(); self.bond_45_50 = list(); self.bond_50_55 = list(); self.bond_55_60 = list(); self.bond_60_65 = list(); self.bond_65_70 = list()
-        self.bond_70_75 = list(); self.bond_75_80 = list(); self.bond_80_85 = list(); self.bond_85_90 = list()
-        self.sizes = []
-        self.sigma_mean_table = []; self.tau_mean_table = []; self.sigma_rel_std_dev_table = []; self.tau_rel_std_dev_table = []; self.sigma_ratio_table = [];
-
-        for i in range(0,18):
-            self.sizes.append(0.0)
-            self.sigma_mean_table.append(0.0)
-            self.tau_mean_table.append(0.0)
-            self.sigma_rel_std_dev_table.append(0.0)
-            self.tau_rel_std_dev_table.append(0.0)
-            self.sigma_ratio_table.append(0.0)
-
-        self.graph_counter = 0; self.renew_pressure = 0; self.Pressure = 0.0; self.pressure_to_apply = 0.0; self.CN_graph_counter = 0
-        self.length_correction_factor = 1.0
-        self.graph_frequency        = int(self.parameters["GraphExportFreq"].GetDouble()/self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME))
-        self.strain = 0.0; self.strain_bts = 0.0; self.volumetric_strain = 0.0; self.radial_strain = 0.0; self.first_time_entry = 1; self.first_time_entry_2 = 1
-        self.total_stress_top = 0.0; self.total_stress_bot = 0.0; self.total_stress_mean = 0.0
-        self.LoadingVelocity = 0.0
-        self.MeasuringSurface = 0.0
-
-        if "material_test_settings" in self.parameters.keys():
-            self.height = self.parameters["material_test_settings"]["SpecimenLength"].GetDouble()
-            self.diameter = self.parameters["material_test_settings"]["SpecimenDiameter"].GetDouble()
-            self.ConfinementPressure = self.parameters["material_test_settings"]["ConfinementPressure"].GetDouble()
-            self.y_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["YCoordinateOfCylinderBottomBase"].GetDouble()
-            self.z_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["ZCoordinateOfCylinderBottomBase"].GetDouble()
-        else:
-            self.height = self.parameters["SpecimenLength"].GetDouble()
-            self.diameter = self.parameters["SpecimenDiameter"].GetDouble()
-            self.ConfinementPressure = self.parameters["ConfinementPressure"].GetDouble()
-            self.y_coordinate_of_cylinder_bottom_base = self.parameters["YCoordinateOfCylinderBottomBase"].GetDouble()
-            self.z_coordinate_of_cylinder_bottom_base = self.parameters["ZCoordinateOfCylinderBottomBase"].GetDouble()
-        
-        self.ConfinementPressure = ConfinementPressure
-
-        self.ComputeLoadingVelocity()
-        self.ComputeMeasuringSurface()
-        self.problem_name = self.parameters["problem_name"].GetString()
-        self.initial_time = datetime.datetime.now()
-        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_Parameter_chart.grf")
-        self.chart = open(absolute_path_to_file, 'w')
-        self.aux = AuxiliaryUtilities()
-        self.PreUtilities = PreUtilities()
-        self.PrepareTests()
-        self.PrepareTestTriaxialHydro()
-        domain_volume = math.pi * 0.5 * 0.5 * self.diameter * self.diameter * self.height
-        DEM_procedures.GranulometryUtils(domain_volume, self.spheres_model_part)
-
-    def MeasureForcesAndPressurePrecompression(self):
-
-        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
-        self.strain += -100 * self.length_correction_factor * self.LoadingVelocity * dt / self.height
-
-        total_force_top = 0.0
-        for node in self.top_mesh_nodes:
-            force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-            total_force_top += force_node_y
-        self.total_stress_top = total_force_top / self.MeasuringSurface
-
-        total_force_bot = 0.0
-        for node in self.bot_mesh_nodes:
-            force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-            total_force_bot += force_node_y
-        self.total_stress_bot = total_force_bot / self.MeasuringSurface
-        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
-
-        if self.SigmaHorizontal:
-            self.Pressure = min(self.total_stress_mean, self.SigmaHorizontal)
-            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
-        if self.total_stress_mean > self.SigmaVertical:
-            self.compression_stage_completed = True
-    def MeasureForcesAndPressureDecompression(self):
-
-        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
-        self.strain += -100 * self.length_correction_factor * self.PlatesDecompressionVelocity * dt / self.height
-
-        total_force_top = 0.0
-        for node in self.top_mesh_nodes:
-            force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-            total_force_top += force_node_y
-        self.total_stress_top = total_force_top / self.MeasuringSurface
-
-        total_force_bot = 0.0
-        for node in self.bot_mesh_nodes:
-            force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-            total_force_bot += force_node_y
-        self.total_stress_bot = total_force_bot / self.MeasuringSurface
-        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
-
-        if self.SigmaHorizontal:
-            self.Pressure = min(self.total_stress_mean, self.SigmaHorizontal)
-            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
-        if self.total_stress_mean < self.SigmaVerticalAlmostZero:
-            self.decompression_stage_completed = True
-    def MeasureForcesAndPressure(self):
-
-        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
-        self.strain += -100 * self.length_correction_factor * self.LoadingVelocity * dt / self.height
-
-        total_force_top = 0.0
-        for node in self.top_mesh_nodes:
-            force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-            total_force_top += force_node_y
-        self.total_stress_top = total_force_top / self.MeasuringSurface
-
-        total_force_bot = 0.0
-        for node in self.bot_mesh_nodes:
-            force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-            total_force_bot += force_node_y
-        self.total_stress_bot = total_force_bot / self.MeasuringSurface
-        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
-
-        if self.ConfinementPressure:
-            self.Pressure = min(self.total_stress_mean, self.ConfinementPressure * 1e6)
-            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
-
-    def ComputeLoadingVelocity(self):
-        top_vel = bot_vel = 0.0
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                top_vel = smp[LINEAR_VELOCITY_Y]
-            if smp[IDENTIFIER] == 'BOTTOM':
-                bot_vel = smp[LINEAR_VELOCITY_Y]
-        self.LoadingVelocity = top_vel - bot_vel
-
-    def ComputeMeasuringSurface(self):
-        self.MeasuringSurface = 0.25 * math.pi * self.diameter * self.diameter
-
-    def PrepareTestTriaxialHydro(self):
-
-        ####### Correction Coefs  TODO 0.25* for cylinder section EXXON
-        self.alpha_top = math.pi*self.diameter*self.diameter*0.25/(self.xtop_area + 0.70710678*self.xtopcorner_area)
-        self.alpha_bot = math.pi*self.diameter*self.diameter*0.25/(self.xbot_area + 0.70710678*self.xbotcorner_area)
-        self.alpha_lat = math.pi*self.diameter*self.height/(self.xlat_area + 0.70710678*self.xtopcorner_area + 0.70710678*self.xbotcorner_area)
-
-    def PrepareTests(self):
-
-        absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
-        absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_graph_top.grf")
-        absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_bot.grf")
-        absolute_path_to_file4 = os.path.join(self.graphs_path, self.problem_name + "_graph_strain_vs_q_in_psi.grf")
-        self.graph_export_1 = open(absolute_path_to_file1, 'w')
-        self.graph_export_2 = open(absolute_path_to_file2, 'w')
-        self.graph_export_3 = open(absolute_path_to_file3, 'w')
-        self.graph_export_4 = open(absolute_path_to_file4, 'w')
-
-        (self.xtop_area,self.xbot_area,self.xlat_area,self.xtopcorner_area,self.xbotcorner_area,y_top_total,weight_top, y_bot_total, weight_bot) = self.CylinderSkinDetermination()
-
-        initial_height_top = y_top_total/weight_top
-        initial_height_bot = y_bot_total/weight_bot
-
-        inner_initial_height = initial_height_top - initial_height_bot
-        extended_length = self.height + (self.height - inner_initial_height)
-
-        self.length_correction_factor = self.height/extended_length
-
-        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_CN.grf")
-        self.CN_export = open(absolute_path_to_file, 'w')
-
-    def CylinderSkinDetermination(self):
-
-        # Cylinder dimensions
-        h = self.height
-        d = self.diameter
-        y_min = self.y_coordinate_of_cylinder_bottom_base
-
-        eps = 3.0 #2.0
-        xlat_area = 0.0
-        xbot_area = 0.0
-        xtop_area = 0.0
-        xbotcorner_area = 0.0
-        xtopcorner_area = 0.0
-        y_top_total = 0.0
-        y_bot_total = 0.0
-        weight_top = 0.0
-        weight_bot = 0.0
-
-        for element in self.spheres_model_part.Elements:
-
-            element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 0)
-
-            node = element.GetNode(0)
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            cross_section = math.pi * r * r
-
-            if (x * x + z * z) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
-
-                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
-                self.LAT.append(node)
-
-                if (y > y_min + eps * r) and (y < y_min + (h - eps * r)):
-
-                    self.SKIN.append(element)
-                    self.XLAT.append(node)
-
-                    xlat_area = xlat_area + cross_section
-
-            if (y <= y_min + eps * r) or (y >= y_min + (h - eps * r)):
-
-                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
-                self.SKIN.append(element)
-
-                if y <= y_min + eps * r:
-
-                    self.BOT.append(node)
-                    y_bot_total += y*r
-                    weight_bot += r
-
-                elif y >= y_min + (h - eps * r):
-
-                    self.TOP.append(node)
-
-                    y_top_total += y*r
-                    weight_top += r
-
-                if (x * x + z * z) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
-
-                    if y > y_min + h / 2:
-
-                        self.XTOPCORNER.append(node)
-                        xtopcorner_area = xtopcorner_area + cross_section
-
-                    else:
-
-                        self.XBOTCORNER.append(node)
-                        xbotcorner_area = xbotcorner_area + cross_section
-                else:
-
-                    if y <= y_min + eps * r:
-
-                        self.XBOT.append(node)
-                        xbot_area = xbot_area + cross_section
-
-                    elif y >= y_min + (h - eps * r):
-
-                        self.XTOP.append(node)
-                        xtop_area = xtop_area + cross_section
-        #checks:
-        if len(self.XLAT)==0:
-            self.procedures.KratosPrintWarning("ERROR! in Cylinder Skin Determination - NO LATERAL PARTICLES" + "\n")
-        else:
-            self.procedures.KratosPrintInfo(str(h) + " * " + str(d) + " cylinder skin determination" + "\n")
-
-        return (xtop_area, xbot_area, xlat_area, xtopcorner_area, xbotcorner_area, y_top_total, weight_top, y_bot_total, weight_bot)
-
-    def ApplyLateralPressure(self, Pressure, XLAT, XBOT, XTOP, XBOTCORNER, XTOPCORNER, alpha_top, alpha_bot, alpha_lat):
-
-        for node in XLAT:
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            values = Array3()
-            vect = Array3()
-
-            cross_section = math.pi * r * r
-
-            # normal vector to the center:
-            vect_moduli = math.sqrt(x * x + z * z)
-
-            if vect_moduli > 0.0:
-                vect[0] = -x / vect_moduli
-                vect[1] = 0
-                vect[2] = -z / vect_moduli
-
-            values[0] = cross_section * alpha_lat * Pressure * vect[0]
-            values[1] = 0.0
-            values[2] = cross_section * alpha_lat * Pressure * vect[2]
-
-            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
-
-        for node in XTOPCORNER:
-
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            values = Array3()
-            vect = Array3()
-
-            cross_section = math.pi * r * r
-
-            # normal vector to the center:
-            vect_moduli = math.sqrt(x * x + z * z)
-
-            if vect_moduli > 0.0:
-                vect[0] = -x / vect_moduli
-                vect[1] = 0
-                vect[2] = -z / vect_moduli
-
-            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
-            values[1] = 0.0
-            values[2] = cross_section * alpha_lat * Pressure * vect[2] * 0.70710678
-
-            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
-
-        for node in XBOTCORNER:
-
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            values = Array3()
-            vect = Array3()
-
-            cross_section = math.pi * r * r
-
-            # vector normal al centre:
-            vect_moduli = math.sqrt(x * x + z * z)
-
-            if vect_moduli > 0.0:
-                vect[0] = -x / vect_moduli
-                vect[1] = 0
-                vect[2] = -z / vect_moduli
-
-            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
-            values[1] = 0.0
-            values[2] = cross_section * alpha_lat * Pressure * vect[2] * 0.70710678
-
-            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
-
-    def PrepareDataForGraph(self):
-
-        prepare_check = [0,0,0,0]
-        self.total_check = 0
-
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                self.top_mesh_nodes = smp.Nodes
-                prepare_check[0] = 1
-            if smp[IDENTIFIER] == 'BOTTOM':
-                self.bot_mesh_nodes = smp.Nodes
-                prepare_check[1] = 1
-
-        for smp in self.spheres_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                self.top_mesh_nodes = smp.Nodes
-                prepare_check[2] = -1
-
-            if smp[IDENTIFIER] == 'BOTTOM':
-                self.bot_mesh_nodes = smp.Nodes
-                prepare_check[3] = -1
-
-        for it in range(len(prepare_check)):
-            self.total_check += prepare_check[it]
-
-        if math.fabs(self.total_check) != 2:
-            self.Procedures.KratosPrintWarning(" ERROR in the definition of TOP BOT groups. Both groups are required to be defined, they have to be either on FEM groups or in DEM groups")
-
-    def PrintGraph(self, time):
-
-        if self.graph_counter == self.graph_frequency:
-            self.graph_counter = 0
-            self.graph_export_1.write(str("%.6g"%self.strain).rjust(13) + "  " + str("%.6g"%(self.total_stress_mean * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
-            self.graph_export_2.write(str("%.8g"%self.strain).rjust(13) + "  " + str("%.6g"%(self.total_stress_top  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
-            self.graph_export_3.write(str("%.8g"%self.strain).rjust(13) + "  " + str("%.6g"%(self.total_stress_bot  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
-            self.graph_export_1.flush()
-            self.graph_export_2.flush()
-            self.graph_export_3.flush()
-            self.graph_export_4.write(str("%.8g"%self.strain).rjust(15) + "  " + str("%.6g"%(self.total_stress_mean * 145 * 1e-6 - 145 * self.ConfinementPressure)).rjust(13) +  "  " + str("%.8g"%time).rjust(12) + '\n')
-            self.graph_export_4.flush()
-        self.graph_counter += 1
-
-    def FinalizeGraphs(self):
-        # Create a copy and renaming
-        self.absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
-        absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_bts.grf")
-        absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_VOL.grf")
-        for filename in os.listdir("."):
-            if filename.startswith(self.absolute_path_to_file1):
-                shutil.copy(filename, filename + "COPY")
-                os.rename(filename+"COPY", self.absolute_path_to_file1 + str(self.initial_time).replace(":", "") + ".grf")
-            if filename.startswith(absolute_path_to_file2):
-                shutil.copy(filename, filename + "COPY")
-                os.rename(filename+"COPY", absolute_path_to_file2 + str(self.initial_time).replace(":", "") + ".grf")
-            if filename.startswith(absolute_path_to_file3):
-                shutil.copy(filename, filename + "COPY")
-                os.rename(filename+"COPY", absolute_path_to_file3 + str(self.initial_time).replace(":", "") + ".grf")
-        self.graph_export_1.close()
-        self.graph_export_2.close()
-        self.graph_export_3.close()
-        self.graph_export_4.close()
-        
-class DecompressedMaterialBTSTest(DEMAnalysisStage):
-
-    def __init__(self, model, parameters):
-        super().__init__(model, parameters)
-
-        self.parameters = parameters
-        self.compression_stage_completed = False
-        self.decompression_stage_completed = False
-        self.time_to_print_bts_graph = False
-
-        # Units in Pa and m/s respectively
-        self.SigmaHorizontal = self.parameters["material_test_settings"]["SigmaHorizontal"].GetDouble()
-        self.SigmaVertical = self.parameters["material_test_settings"]["SigmaVertical"].GetDouble()
-        self.SigmaVerticalAlmostZero = self.parameters["material_test_settings"]["SigmaVerticalAlmostZero"].GetDouble()
-        self.PlatesDecompressionVelocity = self.parameters["material_test_settings"]["PlatesDecompressionVelocity"].GetDouble()
-
-    def Initialize(self):
-        super().Initialize()
-        self.InitializeMaterialTest()
-        self.PrepareDataForGraph()
-        self.ApplyPrecompression()
-        self.ApplyDecompression()
-        self.PrepareBTSTest()
-        self.ApplyLoadingVelocityToBTSPlates()
-    
-    def ApplyLoadingVelocityToBTSPlates(self):
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP_BTS':
-                smp[LINEAR_VELOCITY_Y] = 0.5 * self.LoadingVelocity
-            if smp[IDENTIFIER] == 'BOTTOM_BTS':
-                smp[LINEAR_VELOCITY_Y] = -0.5 * self.LoadingVelocity
-
-    def ApplyPrecompression(self):
-
-        self._GetSolver().cplusplus_strategy.BreakAllBonds()
-        
-        print("\n************************************ Applying Precompression...\n", flush=True)
-        while not self.compression_stage_completed:
-            self.time = self._GetSolver().AdvanceInTime(self.time)
-            self.InitializeSolutionStep()
-            self._GetSolver().Predict()
-            self._GetSolver().SolveSolutionStep()
-            self.FinalizeSolutionStepPreCompression()
-            self.OutputSolutionStep()
-        print("\n*************************** Finished Applying Precompression!!!\n", flush=True)        
-
-        self._GetSolver().cplusplus_strategy.HealAllBonds()
-        ParallelBondUtilities().SetCurrentIndentationAsAReferenceInParallelBonds(self.spheres_model_part)
-        PreUtilities().ResetSkinParticles(self.spheres_model_part)
-        self._GetSolver().cplusplus_strategy.ComputeSkin(self.spheres_model_part, 1.5)
-        
-    def ResetLoadingVelocity(self):
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                smp[LINEAR_VELOCITY_Z] = 0.5 * self.PlatesDecompressionVelocity
-            if smp[IDENTIFIER] == 'BOTTOM':
-                smp[LINEAR_VELOCITY_Z] = -0.5 * self.PlatesDecompressionVelocity
-
-    def ApplyDecompression(self):
-
-        print("\n************************************ Applying Decompression...\n", flush=True)
-        while not self.decompression_stage_completed:
-            self.time = self._GetSolver().AdvanceInTime(self.time)
-            self.InitializeSolutionStep()
-            self._GetSolver().Predict()
-            self.ResetLoadingVelocity()
-            self._GetSolver().SolveSolutionStep()
-            self.FinalizeSolutionStepDeCompression()
-            self.OutputSolutionStep()
-        print("\n*************************** Finished Applying Decompression!!!\n", flush=True)
-        
-        self.IncreaseLateralPlatesVelocitySoTheyWillNotInterfere()
-    
-    def IncreaseLateralPlatesVelocitySoTheyWillNotInterfere(self):
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                smp[LINEAR_VELOCITY_Z] = 2.5 * self.PlatesDecompressionVelocity
-            if smp[IDENTIFIER] == 'BOTTOM':
-                smp[LINEAR_VELOCITY_Z] = -2.5 * self.PlatesDecompressionVelocity
-        
-    def RunSolutionLoop(self):
-
-        print("\n************************************ Applying standard BTS...\n", flush=True)
-        while self.KeepAdvancingSolutionLoop():
-            self.time = self._GetSolver().AdvanceInTime(self.time)
-            self.InitializeSolutionStep()
-            self._GetSolver().Predict()
-            self._GetSolver().SolveSolutionStep()
-            self.FinalizeSolutionStep()
-            self.OutputSolutionStep()
-        print("\n*************************** Finished Applying standard BTS...\n", flush=True)
-
-    def OutputSolutionStep(self):
-        super().OutputSolutionStep()
-        self.PrintGraph(self.time)
-
-    def FinalizeSolutionStepPreCompression(self):
-        super().FinalizeSolutionStep()
-        self.MeasureForcesAndPressurePreCompression()
-        
-    def FinalizeSolutionStepDeCompression(self):
-        super().FinalizeSolutionStep()
-        self.MeasureForcesAndPressureDeCompression()
-    
-    def FinalizeSolutionStep(self):
-        super().FinalizeSolutionStep()
-        self.MeasureForcesAndPressure()
-
-    def Finalize(self):
-        super().Finalize()
-
-        # TODO: After self.CleanUpOperations() in base class!!
-        self.FinalizeGraphs()
-        self.PrintMachineLearningData()
-    
-    def PrintMachineLearningData(self):
-        import numpy as np
-        from scipy import interpolate
-
-        filename1 = self.absolute_path_to_file5
-        filename2 = os.path.join(os.getcwd(), 'bts_experiment.grf')
-        filename3 = os.path.join(os.getcwd(), 'bts_DEM.grf')
-        X1, Y1 = [], []
-        f1 = open(filename1, 'r')
-        for line in f1:
-            values = [float(s) for s in line.split()]
-            X1.append(values[0])
-            Y1.append(values[1])
-        f1.close()
-        f3 = open(filename3, 'w')
-        for i in range(len(X1)):
-            f3.write(str(X1[i]) + "  " + str(Y1[i]) + "\n")
-        f3.close()
-        X2, Y2 = [], []
-        f2 = open(filename2, 'r')
-        for line in f2:
-            values = [float(s) for s in line.split()]
-            X2.append(values[0])
-            q = values[1]
-            Y2.append(q)
-        f2.close()
-        X_0 = max(min(X1), min(X2))
-        X_N = min(max(X1), max(X2))
-        X3 = np.linspace(X_0, X_N, num_of_discretization_points)
-        F1 = interpolate.interp1d(X1, Y1, kind = 'linear')
-        F2 = interpolate.interp1d(X2, Y2, kind = 'linear')
-        minimumX = 1.2 * min(min(X1), min(X2))
-        maximumX = 1.2 * max(max(X1), max(X2))
-        minimumY = 1.2 * min(min(Y1), min(Y2))
-        maximumY = 1.2 * max(max(Y1), max(Y2))
-        
-        if print_images:
-            import matplotlib.pyplot as plt
-            plt.axis([minimumX, maximumX, minimumY, maximumY])
-            plt.xlabel("vertical strain (%)")
-            plt.ylabel("sigma vertical (psi)")
-            plt.plot(X1, Y1, color='blue', linewidth=1, linestyle='solid', marker='None', label="DEM")
-            plt.plot(X3, F1(X3), color='blue', markersize=2, linewidth=1, linestyle='dashed', marker='o', label="DEM interpolation")
-            plt.plot(X2, Y2, color='red',  linewidth=1, linestyle='solid', marker='None', label="experiment")
-            plt.plot(X3, F2(X3), color='red',  markersize=2, linewidth=1, linestyle='dashed', marker='o', label="experiment interpolation")
-            plt.title('BTS vertical stress. Precompressed results vs experiments', fontdict = {'fontsize':8})
-            plt.legend(loc='lower right')
-            plt.grid()
-            printfilename = 'dem_bts_vs_experiments.png'
-            plt.savefig(printfilename, dpi=300)
-            plt.close()
-
-        error = []
-        length = len(F1(X3))
-        for i in range(length):
-            error.append(100 * (F1(X3[i]) - F2(X3[i]))/F2(X3[i]))
-        for i in error:
-            machine_learning_data.write(str("%.8g"%i).rjust(13) + '\n')
-        machine_learning_data.flush()
-        machine_learning_data.close()
-
-    def InitializeMaterialTest(self):
-
-        self.top_mesh_nodes = []; self.bot_mesh_nodes = []; self.top_mesh_nodes_bts = []; self.bot_mesh_nodes_bts = []
-        self.xtop_area = 0.0
-        self.xbot_area = 0.0
-        self.xlat_area = 0.0
-        self.xtopcorner_area = 0.0
-        self.xbotcorner_area = 0.0
-        self.SKIN = list()
-        self.LAT = list()
-        self.BOT = list()
-        self.TOP = list()
-        self.XLAT = list()  # only lat, not the corner ones
-        self.XTOP = list()  # only top, not corner ones...
-        self.XBOT = list()
-        self.XTOPCORNER = list()
-        self.XBOTCORNER = list()
-        self.bond_00_05 = list(); self.bond_05_10 = list(); self.bond_10_15 = list(); self.bond_15_20 = list(); self.bond_20_25 = list(); self.bond_25_30 = list(); self.bond_30_35 = list()
-        self.bond_35_40 = list(); self.bond_40_45 = list(); self.bond_45_50 = list(); self.bond_50_55 = list(); self.bond_55_60 = list(); self.bond_60_65 = list(); self.bond_65_70 = list()
-        self.bond_70_75 = list(); self.bond_75_80 = list(); self.bond_80_85 = list(); self.bond_85_90 = list()
-        self.sizes = []
-        self.sigma_mean_table = []; self.tau_mean_table = []; self.sigma_rel_std_dev_table = []; self.tau_rel_std_dev_table = []; self.sigma_ratio_table = [];
-
-        for i in range(0,18):
-            self.sizes.append(0.0)
-            self.sigma_mean_table.append(0.0)
-            self.tau_mean_table.append(0.0)
-            self.sigma_rel_std_dev_table.append(0.0)
-            self.tau_rel_std_dev_table.append(0.0)
-            self.sigma_ratio_table.append(0.0)
-
-        self.graph_counter = 0; self.renew_pressure = 0; self.Pressure = 0.0; self.pressure_to_apply = 0.0; self.CN_graph_counter = 0
-        self.length_correction_factor = 1.0
-        self.graph_frequency        = int(self.parameters["GraphExportFreq"].GetDouble()/self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME))
-        self.strain = 0.0; self.strain_bts = 0.0; self.volumetric_strain = 0.0; self.radial_strain = 0.0; self.first_time_entry = 1; self.first_time_entry_2 = 1
-        self.total_stress_top = 0.0; self.total_stress_bot = 0.0; self.total_stress_mean = 0.0
-        self.LoadingVelocity = 0.0
-        self.MeasuringSurface = 0.0
-
-        if "material_test_settings" in self.parameters.keys():
-            self.height = self.parameters["material_test_settings"]["SpecimenLength"].GetDouble()
-            self.diameter = self.parameters["material_test_settings"]["SpecimenDiameter"].GetDouble()
-            self.ConfinementPressure = self.parameters["material_test_settings"]["ConfinementPressure"].GetDouble()
-            self.y_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["YCoordinateOfCylinderBottomBase"].GetDouble()
-            self.z_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["ZCoordinateOfCylinderBottomBase"].GetDouble()
-        else:
-            self.height = self.parameters["SpecimenLength"].GetDouble()
-            self.diameter = self.parameters["SpecimenDiameter"].GetDouble()
-            self.ConfinementPressure = self.parameters["ConfinementPressure"].GetDouble()
-            self.y_coordinate_of_cylinder_bottom_base = self.parameters["YCoordinateOfCylinderBottomBase"].GetDouble()
-            self.z_coordinate_of_cylinder_bottom_base = self.parameters["ZCoordinateOfCylinderBottomBase"].GetDouble()
-
-        self.ComputeLoadingVelocity()
-        self.ComputeMeasuringSurface()
-        self.problem_name = self.parameters["problem_name"].GetString()
-        self.initial_time = datetime.datetime.now()
-        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_Parameter_chart.grf")
-        self.chart = open(absolute_path_to_file, 'w')
-        self.aux = AuxiliaryUtilities()
-        self.PreUtilities = PreUtilities()
-        self.PrepareTests()
-        self.PrepareTestTriaxialHydro()
-        domain_volume = math.pi * 0.5 * 0.5 * self.diameter * self.diameter * self.height
-        DEM_procedures.GranulometryUtils(domain_volume, self.spheres_model_part)
-
-    def MeasureForcesAndPressurePreCompression(self):
-
-        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
-        self.strain += -100 * self.length_correction_factor * self.LoadingVelocity * dt / self.height
-
-        total_force_top = 0.0
-        for node in self.top_mesh_nodes:
-            force_node_z = node.GetSolutionStepValue(ELASTIC_FORCES)[2]
-            total_force_top += force_node_z
-        self.total_stress_top = total_force_top / self.MeasuringSurface
-
-        total_force_bot = 0.0
-        for node in self.bot_mesh_nodes:
-            force_node_z = -node.GetSolutionStepValue(ELASTIC_FORCES)[2]
-            total_force_bot += force_node_z
-        self.total_stress_bot = total_force_bot / self.MeasuringSurface
-        
-        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
-
-        if self.SigmaHorizontal:
-            self.Pressure = min(self.total_stress_mean, self.SigmaHorizontal)
-            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
-        
-        if self.total_stress_mean > self.SigmaVertical:
-            self.compression_stage_completed = True
-    
-    def MeasureForcesAndPressureDeCompression(self):
-
-        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
-        self.strain += -100 * self.length_correction_factor * self.PlatesDecompressionVelocity * dt / self.height
-
-        total_force_top = 0.0
-        for node in self.top_mesh_nodes:
-            force_node_z = node.GetSolutionStepValue(ELASTIC_FORCES)[2]
-            total_force_top += force_node_z
-        self.total_stress_top = total_force_top / self.MeasuringSurface
-
-        total_force_bot = 0.0
-        for node in self.bot_mesh_nodes:
-            force_node_z = -node.GetSolutionStepValue(ELASTIC_FORCES)[2]
-            total_force_bot += force_node_z
-        self.total_stress_bot = total_force_bot / self.MeasuringSurface
-        
-        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
-
-        if self.SigmaHorizontal:
-            self.Pressure = min(self.total_stress_mean, self.SigmaHorizontal)
-            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
-        
-        if self.total_stress_mean < self.SigmaVerticalAlmostZero:
-            self.decompression_stage_completed = True
-            
-    def MeasureForcesAndPressure(self):
-
-        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
-        
-        total_force_top = 0.0
-        for node in self.top_mesh_nodes_bts:
-            force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-            total_force_top += force_node_y
-
-        total_force_bot = 0.0
-        for node in self.bot_mesh_nodes_bts:
-            force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-            total_force_bot += force_node_y
-        
-        total_force_bts = 0.5 * (total_force_bot + total_force_top)
-        self.total_stress_bts = 2.0 * total_force_bts / (math.pi * self.height * self.diameter)
-        self.strain_bts += -100 * self.LoadingVelocity * dt / self.diameter
-
-    def ComputeLoadingVelocity(self):
-        top_vel = bot_vel = 0.0
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                top_vel = smp[LINEAR_VELOCITY_Z]
-            if smp[IDENTIFIER] == 'BOTTOM':
-                bot_vel = smp[LINEAR_VELOCITY_Z]
-        self.LoadingVelocity = top_vel - bot_vel
-
-    def ComputeMeasuringSurface(self):
-        self.MeasuringSurface = 0.25 * math.pi * self.diameter * self.diameter
-
-    def PrepareTestTriaxialHydro(self):
-
-        ####### Correction Coefs  TODO 0.25* for cylinder section EXXON
-        self.alpha_top = math.pi*self.diameter*self.diameter*0.25/(self.xtop_area + 0.70710678*self.xtopcorner_area)
-        self.alpha_bot = math.pi*self.diameter*self.diameter*0.25/(self.xbot_area + 0.70710678*self.xbotcorner_area)
-        self.alpha_lat = math.pi*self.diameter*self.height/(self.xlat_area + 0.70710678*self.xtopcorner_area + 0.70710678*self.xbotcorner_area)
-
-    def PrepareBTSTest(self):
-        self.absolute_path_to_file5 = os.path.join(self.graphs_path, self.problem_name + "_graph_bts_in_psi.grf")
-        self.graph_export_5 = open(self.absolute_path_to_file5, 'w')
-        self.time_to_print_bts_graph = True
-
-    def PrepareTests(self):
-
-        absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
-        absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_graph_top.grf")
-        absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_bot.grf")
-        absolute_path_to_file4 = os.path.join(self.graphs_path, self.problem_name + "_graph_strain_vs_q.grf")
-        self.graph_export_1 = open(absolute_path_to_file1, 'w')
-        self.graph_export_2 = open(absolute_path_to_file2, 'w')
-        self.graph_export_3 = open(absolute_path_to_file3, 'w')
-        self.graph_export_4 = open(absolute_path_to_file4, 'w')
-
-        (self.xtop_area,self.xbot_area,self.xlat_area,self.xtopcorner_area,self.xbotcorner_area,y_top_total,weight_top, y_bot_total, weight_bot) = self.CylinderSkinDetermination()
-
-        initial_height_top = y_top_total/weight_top
-        initial_height_bot = y_bot_total/weight_bot
-
-        inner_initial_height = initial_height_top - initial_height_bot
-        extended_length = self.height + (self.height - inner_initial_height)
-
-        self.length_correction_factor = self.height/extended_length
-
-        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_CN.grf")
-        self.CN_export = open(absolute_path_to_file, 'w')
-
-    def CylinderSkinDetermination(self):
-
-        # SKIN DETERMINATION
-        total_cross_section = 0.0
-
-        # Cylinder dimensions
-        h = self.height
-        d = self.diameter
-        z_min = self.z_coordinate_of_cylinder_bottom_base
-
-        eps = 3.0 #2.0
-        xlat_area = 0.0
-        xbot_area = 0.0
-        xtop_area = 0.0
-        xbotcorner_area = 0.0
-        xtopcorner_area = 0.0
-        z_top_total = 0.0
-        z_bot_total = 0.0
-        weight_top = 0.0
-        weight_bot = 0.0
-
-        for element in self.spheres_model_part.Elements:
-
-            element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 0)
-
-            node = element.GetNode(0)
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            cross_section = math.pi * r * r
-
-            if (x * x + y * y) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
-
-                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
-                self.LAT.append(node)
-
-                if (z > z_min + eps * r) and (z < z_min + (h - eps * r)):
-
-                    self.SKIN.append(element)
-                    self.XLAT.append(node)
-
-                    xlat_area = xlat_area + cross_section
-
-            if (z <= z_min + eps * r) or (z >= z_min + (h - eps * r)):
-
-                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
-                self.SKIN.append(element)
-
-                if z <= z_min + eps * r:
-
-                    self.BOT.append(node)
-                    z_bot_total += z*r
-                    weight_bot += r
-
-                elif z >= z_min + (h - eps * r):
-
-                    self.TOP.append(node)
-
-                    z_top_total += z*r
-                    weight_top += r
-
-                if (x * x + y * y) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
-
-                    if z > z_min + h / 2:
-
-                        self.XTOPCORNER.append(node)
-                        xtopcorner_area = xtopcorner_area + cross_section
-
-                    else:
-
-                        self.XBOTCORNER.append(node)
-                        xbotcorner_area = xbotcorner_area + cross_section
-                else:
-
-                    if z <= z_min + eps * r:
-
-                        self.XBOT.append(node)
-                        xbot_area = xbot_area + cross_section
-
-                    elif z >= z_min + (h - eps * r):
-
-                        self.XTOP.append(node)
-                        xtop_area = xtop_area + cross_section
-        #checks:
-        if len(self.XLAT)==0:
-            self.procedures.KratosPrintWarning("ERROR! in Cylinder Skin Determination - NO LATERAL PARTICLES" + "\n")
-        else:
-            self.procedures.KratosPrintInfo(str(h) + " * " + str(d) + " cylinder skin determination" + "\n")
-
-        return (xtop_area, xbot_area, xlat_area, xtopcorner_area, xbotcorner_area, z_top_total, weight_top, z_bot_total, weight_bot)
-
-    def ApplyLateralPressure(self, Pressure, XLAT, XBOT, XTOP, XBOTCORNER, XTOPCORNER, alpha_top, alpha_bot, alpha_lat):
-
-        for node in XLAT:
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            values = Array3()
-            vect = Array3()
-
-            cross_section = math.pi * r * r
-
-            # normal vector to the center:
-            vect_moduli = math.sqrt(x * x + y * y)
-
-            if vect_moduli > 0.0:
-                vect[0] = -x / vect_moduli
-                vect[1] = -y / vect_moduli
-                vect[2] = 0.0
-
-            values[0] = cross_section * alpha_lat * Pressure * vect[0]
-            values[1] = cross_section * alpha_lat * Pressure * vect[1]
-            values[2] = 0.0
-
-            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
-
-        for node in XTOPCORNER:
-
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            values = Array3()
-            vect = Array3()
-
-            cross_section = math.pi * r * r
-
-            # normal vector to the center:
-            vect_moduli = math.sqrt(x * x + y * y)
-
-            if vect_moduli > 0.0:
-                vect[0] = -x / vect_moduli
-                vect[1] = -y / vect_moduli
-                vect[2] = 0.0
-
-            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
-            values[1] = cross_section * alpha_lat * Pressure * vect[1] * 0.70710678
-            values[2] = 0.0
-
-            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
-
-        for node in XBOTCORNER:
-
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            values = Array3()
-            vect = Array3()
-
-            cross_section = math.pi * r * r
-
-            # vector normal al centre:
-            vect_moduli = math.sqrt(x * x + z * z)
-
-            if vect_moduli > 0.0:
-                vect[0] = -x / vect_moduli
-                vect[1] = -y / vect_moduli
-                vect[2] = 0.0
-
-            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
-            values[1] = cross_section * alpha_lat * Pressure * vect[1] * 0.70710678
-            values[2] = 0.0
-
-            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
-
-    def PrepareDataForGraph(self):
-
-        prepare_check = [0,0,0,0]
-        self.total_check = 0
-
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                self.top_mesh_nodes = smp.Nodes
-                prepare_check[0] = 1
-            if smp[IDENTIFIER] == 'BOTTOM':
-                self.bot_mesh_nodes = smp.Nodes
-                prepare_check[1] = 1
-
-        for smp in self.spheres_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                self.top_mesh_nodes = smp.Nodes
-                prepare_check[2] = -1
-
-            if smp[IDENTIFIER] == 'BOTTOM':
-                self.bot_mesh_nodes = smp.Nodes
-                prepare_check[3] = -1
-
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP_BTS':
-                self.top_mesh_nodes_bts = smp.Nodes
-            if smp[IDENTIFIER] == 'BOTTOM_BTS':
-                self.bot_mesh_nodes_bts = smp.Nodes
-
-        for it in range(len(prepare_check)):
-            self.total_check += prepare_check[it]
-
-        if math.fabs(self.total_check) != 2:
-            self.Procedures.KratosPrintWarning(" ERROR in the definition of TOP BOT groups. Both groups are required to be defined, they have to be either on FEM groups or in DEM groups")
-
-    def PrintGraph(self, time):
-
-        if self.graph_counter == self.graph_frequency:
-            self.graph_counter = 0
-            total_stress_q = self.total_stress_mean * 1e-6 - self.ConfinementPressure
-            self.graph_export_1.write(str("%.6g"%self.strain).rjust(13)     + "  " + str("%.6g"%(self.total_stress_mean * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
-            self.graph_export_2.write(str("%.8g"%self.strain).rjust(13)     + "  " + str("%.6g"%(self.total_stress_top  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
-            self.graph_export_3.write(str("%.8g"%self.strain).rjust(13)     + "  " + str("%.6g"%(self.total_stress_bot  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
-            self.graph_export_4.write(str("%.8g"%self.strain).rjust(13)     + "  " + str("%.6g"%(total_stress_q)).rjust(13)                + "  " + str("%.8g"%time).rjust(12) + '\n')
-            self.graph_export_1.flush()
-            self.graph_export_2.flush()
-            self.graph_export_3.flush()
-            self.graph_export_4.flush()
-            if self.time_to_print_bts_graph:
-                self.graph_export_5.write(str("%.8g"%self.strain_bts).rjust(13) + "  " + str("%.6g"%(self.total_stress_bts  * 1e-6 * 145)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
-                self.graph_export_5.flush()
-        self.graph_counter += 1
-    
-    def FinalizeGraphs(self):
-        # Create a copy and renaming
-        absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
-        absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_bts.grf")
-        absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_VOL.grf")
-        for filename in os.listdir("."):
-            if filename.startswith(absolute_path_to_file1):
-                shutil.copy(filename, filename + "COPY")
-                os.rename(filename+"COPY", absolute_path_to_file1 + str(self.initial_time).replace(":", "") + ".grf")
-            if filename.startswith(absolute_path_to_file2):
-                shutil.copy(filename, filename + "COPY")
-                os.rename(filename+"COPY", absolute_path_to_file2 + str(self.initial_time).replace(":", "") + ".grf")
-            if filename.startswith(absolute_path_to_file3):
-                shutil.copy(filename, filename + "COPY")
-                os.rename(filename+"COPY", absolute_path_to_file3 + str(self.initial_time).replace(":", "") + ".grf")
-        self.graph_export_1.close()
-        self.graph_export_2.close()
-        self.graph_export_3.close()
-        self.graph_export_4.close()
-        self.graph_export_5.close()
-
-if __name__ == "__main__":
-
-    with open("ProjectParametersDEM_triaxials.json", 'r') as parameter_file:
-        parameters = KratosMultiphysics.Parameters(parameter_file.read())
-
-    machine_learning_file = "machine_learning_data.grf"
-    machine_learning_data = open(machine_learning_file, 'w')
-
-    # TEST DATA
-    confinement_pressure_list = [0.34, 6.9, 13.8] # For the triaxials, in MPa
-    num_of_discretization_points = 10 # To compute relative errors
-    run_also_bts = True
-    print_images = False
-    
-    number_of_triaxials = len(confinement_pressure_list)
-    simulation_number_list = [i for i in range(1, number_of_triaxials + 1)]
-
-    for simulation_number, ConfinementPressure in zip(simulation_number_list, confinement_pressure_list):
-        model = KratosMultiphysics.Model()
-        DecompressedMaterialTriaxialTest(model, parameters).Run()
-
-    if run_also_bts:
-        with open("ProjectParametersDEM_bts.json", 'r') as parameter_file:
-            parameters = KratosMultiphysics.Parameters(parameter_file.read())
-
-        model = KratosMultiphysics.Model()
-        DecompressedMaterialBTSTest(model, parameters).Run()
-    else:
-        machine_learning_data.close()
+import KratosMultiphysics
+from KratosMultiphysics import *
+from KratosMultiphysics.DEMApplication import *
+import KratosMultiphysics.DEMApplication as DEM
+from KratosMultiphysics.DEMApplication.DEM_analysis_stage import DEMAnalysisStage
+from KratosMultiphysics.DEMApplication import DEM_procedures as DEM_procedures
+import math
+import datetime
+
+class DecompressedMaterialTriaxialTest(DEMAnalysisStage):
+
+    def __init__(self, model, parameters):
+        super().__init__(model, parameters)
+        self.parameters = parameters
+        self.compression_stage_completed = False
+        self.decompression_stage_completed = False
+        # Units in Pa and m/s respectively
+        self.SigmaHorizontal = self.parameters["material_test_settings"]["SigmaHorizontal"].GetDouble()
+        self.SigmaVertical = self.parameters["material_test_settings"]["SigmaVertical"].GetDouble()
+        self.SigmaVerticalAlmostZero = self.parameters["material_test_settings"]["SigmaVerticalAlmostZero"].GetDouble()
+        self.PlatesDecompressionVelocity = self.parameters["material_test_settings"]["PlatesDecompressionVelocity"].GetDouble()
+
+    def Initialize(self):
+        super().Initialize()
+        self.GetMainProblemParameters()
+        self.InitializeMaterialTest()
+        self.PrepareDataForGraph()
+        self._GetSolver().cplusplus_strategy.BreakAllBonds()
+        self.ApplyPrecompression()
+        self._GetSolver().cplusplus_strategy.HealAllBonds()
+        ParallelBondUtilities().SetCurrentIndentationAsAReferenceInParallelBonds(self.spheres_model_part)
+        PreUtilities().ResetSkinParticles(self.spheres_model_part)
+        self._GetSolver().cplusplus_strategy.ComputeSkin(self.spheres_model_part, 1.5)
+        self.ApplyDecompression()
+        self.RestoreLoadingVelocity()
+
+    def GetMainProblemParameters(self):
+        list_of_material_relations = self.DEM_material_parameters["material_relations"]        
+        for material_relation in list_of_material_relations:
+            contact_properties = material_relation["Variables"]
+        self.loose_young = contact_properties["LOOSE_MATERIAL_YOUNG_MODULUS"].GetDouble()
+        self.bonded_young = contact_properties["BONDED_MATERIAL_YOUNG_MODULUS"].GetDouble()
+        self.friction = contact_properties["STATIC_FRICTION"].GetDouble()
+        self.contact_tau = contact_properties["CONTACT_TAU_ZERO"].GetDouble()
+
+    def ApplyPrecompression(self):
+
+        print("\n************************************ Applying Precompression...\n", flush=True)
+        while not self.compression_stage_completed:
+            self.time = self._GetSolver().AdvanceInTime(self.time)
+            self.InitializeSolutionStep()
+            self._GetSolver().Predict()
+            self._GetSolver().SolveSolutionStep()
+            self.FinalizeSolutionStepPrecompression()
+            self.OutputSolutionStep()
+        print("\n*************************** Finished Applying Precompression!!!\n", flush=True)
+
+    def ResetLoadingVelocity(self):
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                smp[LINEAR_VELOCITY_Y] = 0.5 * self.PlatesDecompressionVelocity
+            if smp[IDENTIFIER] == 'BOTTOM':
+                smp[LINEAR_VELOCITY_Y] = -0.5 * self.PlatesDecompressionVelocity
+    def RestoreLoadingVelocity(self):
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                smp[LINEAR_VELOCITY_Y] =  0.5 * self.LoadingVelocity
+            if smp[IDENTIFIER] == 'BOTTOM':
+                smp[LINEAR_VELOCITY_Y] = -0.5 * self.LoadingVelocity
+
+    def ApplyDecompression(self):
+
+        print("\n************************************ Applying Decompression...\n", flush=True)
+        while not self.decompression_stage_completed:
+            self.time = self._GetSolver().AdvanceInTime(self.time)
+            self.InitializeSolutionStep()
+            self._GetSolver().Predict()
+            self.ResetLoadingVelocity()
+            self._GetSolver().SolveSolutionStep()
+            self.FinalizeSolutionStepDecompression()
+            self.OutputSolutionStep()
+        print("\n*************************** Finished Applying Decompression!!!\n", flush=True)
+    def RunSolutionLoop(self):
+
+        print("\n************************************ Applying standard triaxial...\n", flush=True)
+        while self.KeepAdvancingSolutionLoop():
+            self.time = self._GetSolver().AdvanceInTime(self.time)
+            self.InitializeSolutionStep()
+            self._GetSolver().Predict()
+            self._GetSolver().SolveSolutionStep()
+            self.FinalizeSolutionStep()
+            self.OutputSolutionStep()
+        print("\n*************************** Finished Applying standard triaxial...\n", flush=True)
+
+    def OutputSolutionStep(self):
+        super().OutputSolutionStep()
+        self.PrintGraph(self.time)
+
+    def FinalizeSolutionStepPrecompression(self):
+        super().FinalizeSolutionStep()
+        self.MeasureForcesAndPressurePrecompression()
+    def FinalizeSolutionStepDecompression(self):
+        super().FinalizeSolutionStep()
+        self.MeasureForcesAndPressureDecompression()
+    def FinalizeSolutionStep(self):
+        super().FinalizeSolutionStep()
+        self.MeasureForcesAndPressure()
+
+    def Finalize(self):
+        super().Finalize()
+        # TODO: After self.CleanUpOperations() in base class!!
+        self.FinalizeGraphs()
+        self.PrintMachineLearningData()
+    
+    def PrintMachineLearningData(self):
+        import numpy as np
+        from scipy import interpolate
+
+        filename1 = self.absolute_path_to_file1
+        filename2 = os.path.join(os.getcwd(), 'triaxial_experiment_' + str(simulation_number) + '.grf')
+        filename3 = os.path.join(os.getcwd(), 'triaxial_DEM_' + str(simulation_number) + '.grf')
+        X, Y = [], []
+        f1 = open(filename1, 'r')
+        for line in f1:
+            values = [float(s) for s in line.split()]
+            X.append(values[0])
+            q = 145.0 * values[1]
+            Y.append(q)
+        f1.close()
+        minimum = min(Y)
+        min_index = Y.index(minimum)
+        X1 = X[:min_index]
+        X2 = X[min_index:]
+        Y1 = Y[:min_index]
+        Y2 = Y[min_index:]
+        Y2 = [x - 0.000145 * self.ConfinementPressure * 1e6 for x in Y2]
+        index_zero = min(range(len(Y2)), key=lambda i: abs(Y2[i] - 0.0))
+        close_zero = X2[index_zero]
+        X2 = [x - close_zero for x in X2]
+        X2 = X2[index_zero:]
+        Y2 = Y2[index_zero:]
+        f3 = open(filename3, 'w')
+        for i in range(len(X2)):
+            f3.write(str(X2[i]) + "  " + str(Y2[i]) + "\n")
+        f3.close()
+        X3, Y3 = [], []
+        f2 = open(filename2, 'r')
+        for line in f2:
+            values = [float(s) for s in line.split()]
+            X3.append(values[0])
+            q = values[1]
+            Y3.append(q)
+        f2.close()
+        X_0 = max(min(X2), min(X3))
+        X_N = min(max(X2), max(X3))
+        X4 = np.linspace(X_0, X_N, num_of_discretization_points)
+        F2 = interpolate.interp1d(X2, Y2, kind = 'linear')
+        F3 = interpolate.interp1d(X3, Y3, kind = 'linear')
+        minimumX = 1.2 * min(min(X2), min(X3))
+        maximumX = 1.2 * max(max(X2), max(X3))
+        minimumY = 1.2 * min(min(Y2), min(Y3))
+        maximumY = 1.2 * max(max(Y2), max(Y3))
+        
+        if print_images:
+            import matplotlib.pyplot as plt
+            plt.axis([minimumX, maximumX, minimumY, maximumY])
+            plt.xlabel("vertical strain (%)")
+            plt.ylabel("q' (psi)")
+            plt.plot(X2, Y2, color='blue', linewidth=1, linestyle='solid', marker='None', label="DEM")
+            plt.plot(X4, F2(X4), color='blue', markersize=2, linewidth=1, linestyle='dashed', marker='o', label="DEM interpolation")
+            plt.plot(X3, Y3, color='red',  linewidth=1, linestyle='solid', marker='None', label="experiment")
+            plt.plot(X4, F3(X4), color='red',  markersize=2, linewidth=1, linestyle='dashed', marker='o', label="experiment interpolation")
+            plt.title('Triaxial deviatoric effective stress. Precompressed results vs experiments', fontdict = {'fontsize':8})
+            plt.legend(loc='lower right')
+            plt.grid()
+            printfilename = 'dem_triaxial_vs_experiments_' + str(simulation_number) + '.png'
+            plt.savefig(printfilename, dpi=300)
+            plt.close()
+
+        error = []
+        length = len(F2(X4))
+        for i in range(length):
+            error.append(100 * (F2(X4[i]) - F3(X4[i]))/F3(X4[i]))
+        if simulation_number == simulation_number_list[0]:
+            machine_learning_data.write(str("%.8g"%self.loose_young).rjust(13) + '\n')
+            machine_learning_data.write(str("%.8g"%self.bonded_young).rjust(13) + '\n')
+            machine_learning_data.write(str("%.8g"%self.friction).rjust(13) + '\n')
+            machine_learning_data.write(str("%.8g"%self.contact_tau).rjust(13) + '\n')
+        for i in error:
+            machine_learning_data.write(str("%.8g"%i).rjust(13) + '\n')
+        machine_learning_data.flush()
+
+    def InitializeMaterialTest(self):
+
+        self.top_mesh_nodes = []; self.bot_mesh_nodes = []; self.top_mesh_fem_nodes = []; self.bot_mesh_fem_nodes = []
+        self.xtop_area = 0.0
+        self.xbot_area = 0.0
+        self.xlat_area = 0.0
+        self.xtopcorner_area = 0.0
+        self.xbotcorner_area = 0.0
+        self.SKIN = list()
+        self.LAT = list()
+        self.BOT = list()
+        self.TOP = list()
+        self.XLAT = list()  # only lat, not the corner ones
+        self.XTOP = list()  # only top, not corner ones...
+        self.XBOT = list()
+        self.XTOPCORNER = list()
+        self.XBOTCORNER = list()
+        self.bond_00_05 = list(); self.bond_05_10 = list(); self.bond_10_15 = list(); self.bond_15_20 = list(); self.bond_20_25 = list(); self.bond_25_30 = list(); self.bond_30_35 = list()
+        self.bond_35_40 = list(); self.bond_40_45 = list(); self.bond_45_50 = list(); self.bond_50_55 = list(); self.bond_55_60 = list(); self.bond_60_65 = list(); self.bond_65_70 = list()
+        self.bond_70_75 = list(); self.bond_75_80 = list(); self.bond_80_85 = list(); self.bond_85_90 = list()
+        self.sizes = []
+        self.sigma_mean_table = []; self.tau_mean_table = []; self.sigma_rel_std_dev_table = []; self.tau_rel_std_dev_table = []; self.sigma_ratio_table = [];
+
+        for i in range(0,18):
+            self.sizes.append(0.0)
+            self.sigma_mean_table.append(0.0)
+            self.tau_mean_table.append(0.0)
+            self.sigma_rel_std_dev_table.append(0.0)
+            self.tau_rel_std_dev_table.append(0.0)
+            self.sigma_ratio_table.append(0.0)
+
+        self.graph_counter = 0; self.renew_pressure = 0; self.Pressure = 0.0; self.pressure_to_apply = 0.0; self.CN_graph_counter = 0
+        self.length_correction_factor = 1.0
+        self.graph_frequency        = int(self.parameters["GraphExportFreq"].GetDouble()/self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME))
+        self.strain = 0.0; self.strain_bts = 0.0; self.volumetric_strain = 0.0; self.radial_strain = 0.0; self.first_time_entry = 1; self.first_time_entry_2 = 1
+        self.total_stress_top = 0.0; self.total_stress_bot = 0.0; self.total_stress_mean = 0.0
+        self.LoadingVelocity = 0.0
+        self.MeasuringSurface = 0.0
+
+        if "material_test_settings" in self.parameters.keys():
+            self.height = self.parameters["material_test_settings"]["SpecimenLength"].GetDouble()
+            self.diameter = self.parameters["material_test_settings"]["SpecimenDiameter"].GetDouble()
+            self.ConfinementPressure = self.parameters["material_test_settings"]["ConfinementPressure"].GetDouble()
+            self.y_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["YCoordinateOfCylinderBottomBase"].GetDouble()
+            self.z_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["ZCoordinateOfCylinderBottomBase"].GetDouble()
+        else:
+            self.height = self.parameters["SpecimenLength"].GetDouble()
+            self.diameter = self.parameters["SpecimenDiameter"].GetDouble()
+            self.ConfinementPressure = self.parameters["ConfinementPressure"].GetDouble()
+            self.y_coordinate_of_cylinder_bottom_base = self.parameters["YCoordinateOfCylinderBottomBase"].GetDouble()
+            self.z_coordinate_of_cylinder_bottom_base = self.parameters["ZCoordinateOfCylinderBottomBase"].GetDouble()
+        
+        self.ConfinementPressure = ConfinementPressure
+
+        self.ComputeLoadingVelocity()
+        self.ComputeMeasuringSurface()
+        self.problem_name = self.parameters["problem_name"].GetString()
+        self.initial_time = datetime.datetime.now()
+        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_Parameter_chart.grf")
+        self.chart = open(absolute_path_to_file, 'w')
+        self.aux = AuxiliaryUtilities()
+        self.PreUtilities = PreUtilities()
+        self.PrepareTests()
+        self.PrepareTestTriaxialHydro()
+        domain_volume = math.pi * 0.5 * 0.5 * self.diameter * self.diameter * self.height
+        DEM_procedures.GranulometryUtils(domain_volume, self.spheres_model_part)
+
+    def MeasureForcesAndPressurePrecompression(self):
+
+        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
+        self.strain += -100 * self.length_correction_factor * self.LoadingVelocity * dt / self.height
+
+        total_force_top = 0.0
+        for node in self.top_mesh_nodes:
+            force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+            total_force_top += force_node_y
+        self.total_stress_top = total_force_top / self.MeasuringSurface
+
+        total_force_bot = 0.0
+        for node in self.bot_mesh_nodes:
+            force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+            total_force_bot += force_node_y
+        self.total_stress_bot = total_force_bot / self.MeasuringSurface
+        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
+
+        if self.SigmaHorizontal:
+            self.Pressure = min(self.total_stress_mean, self.SigmaHorizontal)
+            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
+        if self.total_stress_mean > self.SigmaVertical:
+            self.compression_stage_completed = True
+    def MeasureForcesAndPressureDecompression(self):
+
+        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
+        self.strain += -100 * self.length_correction_factor * self.PlatesDecompressionVelocity * dt / self.height
+
+        total_force_top = 0.0
+        for node in self.top_mesh_nodes:
+            force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+            total_force_top += force_node_y
+        self.total_stress_top = total_force_top / self.MeasuringSurface
+
+        total_force_bot = 0.0
+        for node in self.bot_mesh_nodes:
+            force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+            total_force_bot += force_node_y
+        self.total_stress_bot = total_force_bot / self.MeasuringSurface
+        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
+
+        if self.SigmaHorizontal:
+            self.Pressure = min(self.total_stress_mean, self.SigmaHorizontal)
+            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
+        if self.total_stress_mean < self.SigmaVerticalAlmostZero:
+            self.decompression_stage_completed = True
+    def MeasureForcesAndPressure(self):
+
+        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
+        self.strain += -100 * self.length_correction_factor * self.LoadingVelocity * dt / self.height
+
+        total_force_top = 0.0
+        for node in self.top_mesh_nodes:
+            force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+            total_force_top += force_node_y
+        self.total_stress_top = total_force_top / self.MeasuringSurface
+
+        total_force_bot = 0.0
+        for node in self.bot_mesh_nodes:
+            force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+            total_force_bot += force_node_y
+        self.total_stress_bot = total_force_bot / self.MeasuringSurface
+        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
+
+        if self.ConfinementPressure:
+            self.Pressure = min(self.total_stress_mean, self.ConfinementPressure * 1e6)
+            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
+
+    def ComputeLoadingVelocity(self):
+        top_vel = bot_vel = 0.0
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                top_vel = smp[LINEAR_VELOCITY_Y]
+            if smp[IDENTIFIER] == 'BOTTOM':
+                bot_vel = smp[LINEAR_VELOCITY_Y]
+        self.LoadingVelocity = top_vel - bot_vel
+
+    def ComputeMeasuringSurface(self):
+        self.MeasuringSurface = 0.25 * math.pi * self.diameter * self.diameter
+
+    def PrepareTestTriaxialHydro(self):
+
+        ####### Correction Coefs  TODO 0.25* for cylinder section EXXON
+        self.alpha_top = math.pi*self.diameter*self.diameter*0.25/(self.xtop_area + 0.70710678*self.xtopcorner_area)
+        self.alpha_bot = math.pi*self.diameter*self.diameter*0.25/(self.xbot_area + 0.70710678*self.xbotcorner_area)
+        self.alpha_lat = math.pi*self.diameter*self.height/(self.xlat_area + 0.70710678*self.xtopcorner_area + 0.70710678*self.xbotcorner_area)
+
+    def PrepareTests(self):
+
+        absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
+        absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_graph_top.grf")
+        absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_bot.grf")
+        absolute_path_to_file4 = os.path.join(self.graphs_path, self.problem_name + "_graph_strain_vs_q_in_psi.grf")
+        self.graph_export_1 = open(absolute_path_to_file1, 'w')
+        self.graph_export_2 = open(absolute_path_to_file2, 'w')
+        self.graph_export_3 = open(absolute_path_to_file3, 'w')
+        self.graph_export_4 = open(absolute_path_to_file4, 'w')
+
+        (self.xtop_area,self.xbot_area,self.xlat_area,self.xtopcorner_area,self.xbotcorner_area,y_top_total,weight_top, y_bot_total, weight_bot) = self.CylinderSkinDetermination()
+
+        initial_height_top = y_top_total/weight_top
+        initial_height_bot = y_bot_total/weight_bot
+
+        inner_initial_height = initial_height_top - initial_height_bot
+        extended_length = self.height + (self.height - inner_initial_height)
+
+        self.length_correction_factor = self.height/extended_length
+
+        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_CN.grf")
+        self.CN_export = open(absolute_path_to_file, 'w')
+
+    def CylinderSkinDetermination(self):
+
+        # Cylinder dimensions
+        h = self.height
+        d = self.diameter
+        y_min = self.y_coordinate_of_cylinder_bottom_base
+
+        eps = 3.0 #2.0
+        xlat_area = 0.0
+        xbot_area = 0.0
+        xtop_area = 0.0
+        xbotcorner_area = 0.0
+        xtopcorner_area = 0.0
+        y_top_total = 0.0
+        y_bot_total = 0.0
+        weight_top = 0.0
+        weight_bot = 0.0
+
+        for element in self.spheres_model_part.Elements:
+
+            element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 0)
+
+            node = element.GetNode(0)
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            cross_section = math.pi * r * r
+
+            if (x * x + z * z) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
+
+                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
+                self.LAT.append(node)
+
+                if (y > y_min + eps * r) and (y < y_min + (h - eps * r)):
+
+                    self.SKIN.append(element)
+                    self.XLAT.append(node)
+
+                    xlat_area = xlat_area + cross_section
+
+            if (y <= y_min + eps * r) or (y >= y_min + (h - eps * r)):
+
+                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
+                self.SKIN.append(element)
+
+                if y <= y_min + eps * r:
+
+                    self.BOT.append(node)
+                    y_bot_total += y*r
+                    weight_bot += r
+
+                elif y >= y_min + (h - eps * r):
+
+                    self.TOP.append(node)
+
+                    y_top_total += y*r
+                    weight_top += r
+
+                if (x * x + z * z) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
+
+                    if y > y_min + h / 2:
+
+                        self.XTOPCORNER.append(node)
+                        xtopcorner_area = xtopcorner_area + cross_section
+
+                    else:
+
+                        self.XBOTCORNER.append(node)
+                        xbotcorner_area = xbotcorner_area + cross_section
+                else:
+
+                    if y <= y_min + eps * r:
+
+                        self.XBOT.append(node)
+                        xbot_area = xbot_area + cross_section
+
+                    elif y >= y_min + (h - eps * r):
+
+                        self.XTOP.append(node)
+                        xtop_area = xtop_area + cross_section
+        #checks:
+        if len(self.XLAT)==0:
+            self.procedures.KratosPrintWarning("ERROR! in Cylinder Skin Determination - NO LATERAL PARTICLES" + "\n")
+        else:
+            self.procedures.KratosPrintInfo(str(h) + " * " + str(d) + " cylinder skin determination" + "\n")
+
+        return (xtop_area, xbot_area, xlat_area, xtopcorner_area, xbotcorner_area, y_top_total, weight_top, y_bot_total, weight_bot)
+
+    def ApplyLateralPressure(self, Pressure, XLAT, XBOT, XTOP, XBOTCORNER, XTOPCORNER, alpha_top, alpha_bot, alpha_lat):
+
+        for node in XLAT:
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            values = Array3()
+            vect = Array3()
+
+            cross_section = math.pi * r * r
+
+            # normal vector to the center:
+            vect_moduli = math.sqrt(x * x + z * z)
+
+            if vect_moduli > 0.0:
+                vect[0] = -x / vect_moduli
+                vect[1] = 0
+                vect[2] = -z / vect_moduli
+
+            values[0] = cross_section * alpha_lat * Pressure * vect[0]
+            values[1] = 0.0
+            values[2] = cross_section * alpha_lat * Pressure * vect[2]
+
+            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
+
+        for node in XTOPCORNER:
+
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            values = Array3()
+            vect = Array3()
+
+            cross_section = math.pi * r * r
+
+            # normal vector to the center:
+            vect_moduli = math.sqrt(x * x + z * z)
+
+            if vect_moduli > 0.0:
+                vect[0] = -x / vect_moduli
+                vect[1] = 0
+                vect[2] = -z / vect_moduli
+
+            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
+            values[1] = 0.0
+            values[2] = cross_section * alpha_lat * Pressure * vect[2] * 0.70710678
+
+            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
+
+        for node in XBOTCORNER:
+
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            values = Array3()
+            vect = Array3()
+
+            cross_section = math.pi * r * r
+
+            # vector normal al centre:
+            vect_moduli = math.sqrt(x * x + z * z)
+
+            if vect_moduli > 0.0:
+                vect[0] = -x / vect_moduli
+                vect[1] = 0
+                vect[2] = -z / vect_moduli
+
+            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
+            values[1] = 0.0
+            values[2] = cross_section * alpha_lat * Pressure * vect[2] * 0.70710678
+
+            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
+
+    def PrepareDataForGraph(self):
+
+        prepare_check = [0,0,0,0]
+        self.total_check = 0
+
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                self.top_mesh_nodes = smp.Nodes
+                prepare_check[0] = 1
+            if smp[IDENTIFIER] == 'BOTTOM':
+                self.bot_mesh_nodes = smp.Nodes
+                prepare_check[1] = 1
+
+        for smp in self.spheres_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                self.top_mesh_nodes = smp.Nodes
+                prepare_check[2] = -1
+
+            if smp[IDENTIFIER] == 'BOTTOM':
+                self.bot_mesh_nodes = smp.Nodes
+                prepare_check[3] = -1
+
+        for it in range(len(prepare_check)):
+            self.total_check += prepare_check[it]
+
+        if math.fabs(self.total_check) != 2:
+            self.Procedures.KratosPrintWarning(" ERROR in the definition of TOP BOT groups. Both groups are required to be defined, they have to be either on FEM groups or in DEM groups")
+
+    def PrintGraph(self, time):
+
+        if self.graph_counter == self.graph_frequency:
+            self.graph_counter = 0
+            self.graph_export_1.write(str("%.6g"%self.strain).rjust(13) + "  " + str("%.6g"%(self.total_stress_mean * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
+            self.graph_export_2.write(str("%.8g"%self.strain).rjust(13) + "  " + str("%.6g"%(self.total_stress_top  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
+            self.graph_export_3.write(str("%.8g"%self.strain).rjust(13) + "  " + str("%.6g"%(self.total_stress_bot  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
+            self.graph_export_1.flush()
+            self.graph_export_2.flush()
+            self.graph_export_3.flush()
+            self.graph_export_4.write(str("%.8g"%self.strain).rjust(15) + "  " + str("%.6g"%(self.total_stress_mean * 145 * 1e-6 - 145 * self.ConfinementPressure)).rjust(13) +  "  " + str("%.8g"%time).rjust(12) + '\n')
+            self.graph_export_4.flush()
+        self.graph_counter += 1
+
+    def FinalizeGraphs(self):
+        # Create a copy and renaming
+        self.absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
+        absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_bts.grf")
+        absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_VOL.grf")
+        for filename in os.listdir("."):
+            if filename.startswith(self.absolute_path_to_file1):
+                shutil.copy(filename, filename + "COPY")
+                os.rename(filename+"COPY", self.absolute_path_to_file1 + str(self.initial_time).replace(":", "") + ".grf")
+            if filename.startswith(absolute_path_to_file2):
+                shutil.copy(filename, filename + "COPY")
+                os.rename(filename+"COPY", absolute_path_to_file2 + str(self.initial_time).replace(":", "") + ".grf")
+            if filename.startswith(absolute_path_to_file3):
+                shutil.copy(filename, filename + "COPY")
+                os.rename(filename+"COPY", absolute_path_to_file3 + str(self.initial_time).replace(":", "") + ".grf")
+        self.graph_export_1.close()
+        self.graph_export_2.close()
+        self.graph_export_3.close()
+        self.graph_export_4.close()
+        
+class DecompressedMaterialBTSTest(DEMAnalysisStage):
+
+    def __init__(self, model, parameters):
+        super().__init__(model, parameters)
+
+        self.parameters = parameters
+        self.compression_stage_completed = False
+        self.decompression_stage_completed = False
+        self.time_to_print_bts_graph = False
+
+        # Units in Pa and m/s respectively
+        self.SigmaHorizontal = self.parameters["material_test_settings"]["SigmaHorizontal"].GetDouble()
+        self.SigmaVertical = self.parameters["material_test_settings"]["SigmaVertical"].GetDouble()
+        self.SigmaVerticalAlmostZero = self.parameters["material_test_settings"]["SigmaVerticalAlmostZero"].GetDouble()
+        self.PlatesDecompressionVelocity = self.parameters["material_test_settings"]["PlatesDecompressionVelocity"].GetDouble()
+
+    def Initialize(self):
+        super().Initialize()
+        self.InitializeMaterialTest()
+        self.PrepareDataForGraph()
+        self.ApplyPrecompression()
+        self.ApplyDecompression()
+        self.PrepareBTSTest()
+        self.ApplyLoadingVelocityToBTSPlates()
+    
+    def ApplyLoadingVelocityToBTSPlates(self):
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP_BTS':
+                smp[LINEAR_VELOCITY_Y] = 0.5 * self.LoadingVelocity
+            if smp[IDENTIFIER] == 'BOTTOM_BTS':
+                smp[LINEAR_VELOCITY_Y] = -0.5 * self.LoadingVelocity
+
+    def ApplyPrecompression(self):
+
+        self._GetSolver().cplusplus_strategy.BreakAllBonds()
+        
+        print("\n************************************ Applying Precompression...\n", flush=True)
+        while not self.compression_stage_completed:
+            self.time = self._GetSolver().AdvanceInTime(self.time)
+            self.InitializeSolutionStep()
+            self._GetSolver().Predict()
+            self._GetSolver().SolveSolutionStep()
+            self.FinalizeSolutionStepPreCompression()
+            self.OutputSolutionStep()
+        print("\n*************************** Finished Applying Precompression!!!\n", flush=True)        
+
+        self._GetSolver().cplusplus_strategy.HealAllBonds()
+        ParallelBondUtilities().SetCurrentIndentationAsAReferenceInParallelBonds(self.spheres_model_part)
+        PreUtilities().ResetSkinParticles(self.spheres_model_part)
+        self._GetSolver().cplusplus_strategy.ComputeSkin(self.spheres_model_part, 1.5)
+        
+    def ResetLoadingVelocity(self):
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                smp[LINEAR_VELOCITY_Z] = 0.5 * self.PlatesDecompressionVelocity
+            if smp[IDENTIFIER] == 'BOTTOM':
+                smp[LINEAR_VELOCITY_Z] = -0.5 * self.PlatesDecompressionVelocity
+
+    def ApplyDecompression(self):
+
+        print("\n************************************ Applying Decompression...\n", flush=True)
+        while not self.decompression_stage_completed:
+            self.time = self._GetSolver().AdvanceInTime(self.time)
+            self.InitializeSolutionStep()
+            self._GetSolver().Predict()
+            self.ResetLoadingVelocity()
+            self._GetSolver().SolveSolutionStep()
+            self.FinalizeSolutionStepDeCompression()
+            self.OutputSolutionStep()
+        print("\n*************************** Finished Applying Decompression!!!\n", flush=True)
+        
+        self.IncreaseLateralPlatesVelocitySoTheyWillNotInterfere()
+    
+    def IncreaseLateralPlatesVelocitySoTheyWillNotInterfere(self):
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                smp[LINEAR_VELOCITY_Z] = 2.5 * self.PlatesDecompressionVelocity
+            if smp[IDENTIFIER] == 'BOTTOM':
+                smp[LINEAR_VELOCITY_Z] = -2.5 * self.PlatesDecompressionVelocity
+        
+    def RunSolutionLoop(self):
+
+        print("\n************************************ Applying standard BTS...\n", flush=True)
+        while self.KeepAdvancingSolutionLoop():
+            self.time = self._GetSolver().AdvanceInTime(self.time)
+            self.InitializeSolutionStep()
+            self._GetSolver().Predict()
+            self._GetSolver().SolveSolutionStep()
+            self.FinalizeSolutionStep()
+            self.OutputSolutionStep()
+        print("\n*************************** Finished Applying standard BTS...\n", flush=True)
+
+    def OutputSolutionStep(self):
+        super().OutputSolutionStep()
+        self.PrintGraph(self.time)
+
+    def FinalizeSolutionStepPreCompression(self):
+        super().FinalizeSolutionStep()
+        self.MeasureForcesAndPressurePreCompression()
+        
+    def FinalizeSolutionStepDeCompression(self):
+        super().FinalizeSolutionStep()
+        self.MeasureForcesAndPressureDeCompression()
+    
+    def FinalizeSolutionStep(self):
+        super().FinalizeSolutionStep()
+        self.MeasureForcesAndPressure()
+
+    def Finalize(self):
+        super().Finalize()
+
+        # TODO: After self.CleanUpOperations() in base class!!
+        self.FinalizeGraphs()
+        self.PrintMachineLearningData()
+    
+    def PrintMachineLearningData(self):
+        import numpy as np
+        from scipy import interpolate
+
+        filename1 = self.absolute_path_to_file5
+        filename2 = os.path.join(os.getcwd(), 'bts_experiment.grf')
+        filename3 = os.path.join(os.getcwd(), 'bts_DEM.grf')
+        X1, Y1 = [], []
+        f1 = open(filename1, 'r')
+        for line in f1:
+            values = [float(s) for s in line.split()]
+            X1.append(values[0])
+            Y1.append(values[1])
+        f1.close()
+        f3 = open(filename3, 'w')
+        for i in range(len(X1)):
+            f3.write(str(X1[i]) + "  " + str(Y1[i]) + "\n")
+        f3.close()
+        X2, Y2 = [], []
+        f2 = open(filename2, 'r')
+        for line in f2:
+            values = [float(s) for s in line.split()]
+            X2.append(values[0])
+            q = values[1]
+            Y2.append(q)
+        f2.close()
+        X_0 = max(min(X1), min(X2))
+        X_N = min(max(X1), max(X2))
+        X3 = np.linspace(X_0, X_N, num_of_discretization_points)
+        F1 = interpolate.interp1d(X1, Y1, kind = 'linear')
+        F2 = interpolate.interp1d(X2, Y2, kind = 'linear')
+        minimumX = 1.2 * min(min(X1), min(X2))
+        maximumX = 1.2 * max(max(X1), max(X2))
+        minimumY = 1.2 * min(min(Y1), min(Y2))
+        maximumY = 1.2 * max(max(Y1), max(Y2))
+        
+        if print_images:
+            import matplotlib.pyplot as plt
+            plt.axis([minimumX, maximumX, minimumY, maximumY])
+            plt.xlabel("vertical strain (%)")
+            plt.ylabel("sigma vertical (psi)")
+            plt.plot(X1, Y1, color='blue', linewidth=1, linestyle='solid', marker='None', label="DEM")
+            plt.plot(X3, F1(X3), color='blue', markersize=2, linewidth=1, linestyle='dashed', marker='o', label="DEM interpolation")
+            plt.plot(X2, Y2, color='red',  linewidth=1, linestyle='solid', marker='None', label="experiment")
+            plt.plot(X3, F2(X3), color='red',  markersize=2, linewidth=1, linestyle='dashed', marker='o', label="experiment interpolation")
+            plt.title('BTS vertical stress. Precompressed results vs experiments', fontdict = {'fontsize':8})
+            plt.legend(loc='lower right')
+            plt.grid()
+            printfilename = 'dem_bts_vs_experiments.png'
+            plt.savefig(printfilename, dpi=300)
+            plt.close()
+
+        error = []
+        length = len(F1(X3))
+        for i in range(length):
+            error.append(100 * (F1(X3[i]) - F2(X3[i]))/F2(X3[i]))
+        for i in error:
+            machine_learning_data.write(str("%.8g"%i).rjust(13) + '\n')
+        machine_learning_data.flush()
+        machine_learning_data.close()
+
+    def InitializeMaterialTest(self):
+
+        self.top_mesh_nodes = []; self.bot_mesh_nodes = []; self.top_mesh_nodes_bts = []; self.bot_mesh_nodes_bts = []
+        self.xtop_area = 0.0
+        self.xbot_area = 0.0
+        self.xlat_area = 0.0
+        self.xtopcorner_area = 0.0
+        self.xbotcorner_area = 0.0
+        self.SKIN = list()
+        self.LAT = list()
+        self.BOT = list()
+        self.TOP = list()
+        self.XLAT = list()  # only lat, not the corner ones
+        self.XTOP = list()  # only top, not corner ones...
+        self.XBOT = list()
+        self.XTOPCORNER = list()
+        self.XBOTCORNER = list()
+        self.bond_00_05 = list(); self.bond_05_10 = list(); self.bond_10_15 = list(); self.bond_15_20 = list(); self.bond_20_25 = list(); self.bond_25_30 = list(); self.bond_30_35 = list()
+        self.bond_35_40 = list(); self.bond_40_45 = list(); self.bond_45_50 = list(); self.bond_50_55 = list(); self.bond_55_60 = list(); self.bond_60_65 = list(); self.bond_65_70 = list()
+        self.bond_70_75 = list(); self.bond_75_80 = list(); self.bond_80_85 = list(); self.bond_85_90 = list()
+        self.sizes = []
+        self.sigma_mean_table = []; self.tau_mean_table = []; self.sigma_rel_std_dev_table = []; self.tau_rel_std_dev_table = []; self.sigma_ratio_table = [];
+
+        for i in range(0,18):
+            self.sizes.append(0.0)
+            self.sigma_mean_table.append(0.0)
+            self.tau_mean_table.append(0.0)
+            self.sigma_rel_std_dev_table.append(0.0)
+            self.tau_rel_std_dev_table.append(0.0)
+            self.sigma_ratio_table.append(0.0)
+
+        self.graph_counter = 0; self.renew_pressure = 0; self.Pressure = 0.0; self.pressure_to_apply = 0.0; self.CN_graph_counter = 0
+        self.length_correction_factor = 1.0
+        self.graph_frequency        = int(self.parameters["GraphExportFreq"].GetDouble()/self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME))
+        self.strain = 0.0; self.strain_bts = 0.0; self.volumetric_strain = 0.0; self.radial_strain = 0.0; self.first_time_entry = 1; self.first_time_entry_2 = 1
+        self.total_stress_top = 0.0; self.total_stress_bot = 0.0; self.total_stress_mean = 0.0
+        self.LoadingVelocity = 0.0
+        self.MeasuringSurface = 0.0
+
+        if "material_test_settings" in self.parameters.keys():
+            self.height = self.parameters["material_test_settings"]["SpecimenLength"].GetDouble()
+            self.diameter = self.parameters["material_test_settings"]["SpecimenDiameter"].GetDouble()
+            self.ConfinementPressure = self.parameters["material_test_settings"]["ConfinementPressure"].GetDouble()
+            self.y_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["YCoordinateOfCylinderBottomBase"].GetDouble()
+            self.z_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["ZCoordinateOfCylinderBottomBase"].GetDouble()
+        else:
+            self.height = self.parameters["SpecimenLength"].GetDouble()
+            self.diameter = self.parameters["SpecimenDiameter"].GetDouble()
+            self.ConfinementPressure = self.parameters["ConfinementPressure"].GetDouble()
+            self.y_coordinate_of_cylinder_bottom_base = self.parameters["YCoordinateOfCylinderBottomBase"].GetDouble()
+            self.z_coordinate_of_cylinder_bottom_base = self.parameters["ZCoordinateOfCylinderBottomBase"].GetDouble()
+
+        self.ComputeLoadingVelocity()
+        self.ComputeMeasuringSurface()
+        self.problem_name = self.parameters["problem_name"].GetString()
+        self.initial_time = datetime.datetime.now()
+        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_Parameter_chart.grf")
+        self.chart = open(absolute_path_to_file, 'w')
+        self.aux = AuxiliaryUtilities()
+        self.PreUtilities = PreUtilities()
+        self.PrepareTests()
+        self.PrepareTestTriaxialHydro()
+        domain_volume = math.pi * 0.5 * 0.5 * self.diameter * self.diameter * self.height
+        DEM_procedures.GranulometryUtils(domain_volume, self.spheres_model_part)
+
+    def MeasureForcesAndPressurePreCompression(self):
+
+        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
+        self.strain += -100 * self.length_correction_factor * self.LoadingVelocity * dt / self.height
+
+        total_force_top = 0.0
+        for node in self.top_mesh_nodes:
+            force_node_z = node.GetSolutionStepValue(ELASTIC_FORCES)[2]
+            total_force_top += force_node_z
+        self.total_stress_top = total_force_top / self.MeasuringSurface
+
+        total_force_bot = 0.0
+        for node in self.bot_mesh_nodes:
+            force_node_z = -node.GetSolutionStepValue(ELASTIC_FORCES)[2]
+            total_force_bot += force_node_z
+        self.total_stress_bot = total_force_bot / self.MeasuringSurface
+        
+        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
+
+        if self.SigmaHorizontal:
+            self.Pressure = min(self.total_stress_mean, self.SigmaHorizontal)
+            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
+        
+        if self.total_stress_mean > self.SigmaVertical:
+            self.compression_stage_completed = True
+    
+    def MeasureForcesAndPressureDeCompression(self):
+
+        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
+        self.strain += -100 * self.length_correction_factor * self.PlatesDecompressionVelocity * dt / self.height
+
+        total_force_top = 0.0
+        for node in self.top_mesh_nodes:
+            force_node_z = node.GetSolutionStepValue(ELASTIC_FORCES)[2]
+            total_force_top += force_node_z
+        self.total_stress_top = total_force_top / self.MeasuringSurface
+
+        total_force_bot = 0.0
+        for node in self.bot_mesh_nodes:
+            force_node_z = -node.GetSolutionStepValue(ELASTIC_FORCES)[2]
+            total_force_bot += force_node_z
+        self.total_stress_bot = total_force_bot / self.MeasuringSurface
+        
+        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
+
+        if self.SigmaHorizontal:
+            self.Pressure = min(self.total_stress_mean, self.SigmaHorizontal)
+            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
+        
+        if self.total_stress_mean < self.SigmaVerticalAlmostZero:
+            self.decompression_stage_completed = True
+            
+    def MeasureForcesAndPressure(self):
+
+        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
+        
+        total_force_top = 0.0
+        for node in self.top_mesh_nodes_bts:
+            force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+            total_force_top += force_node_y
+
+        total_force_bot = 0.0
+        for node in self.bot_mesh_nodes_bts:
+            force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+            total_force_bot += force_node_y
+        
+        total_force_bts = 0.5 * (total_force_bot + total_force_top)
+        self.total_stress_bts = 2.0 * total_force_bts / (math.pi * self.height * self.diameter)
+        self.strain_bts += -100 * self.LoadingVelocity * dt / self.diameter
+
+    def ComputeLoadingVelocity(self):
+        top_vel = bot_vel = 0.0
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                top_vel = smp[LINEAR_VELOCITY_Z]
+            if smp[IDENTIFIER] == 'BOTTOM':
+                bot_vel = smp[LINEAR_VELOCITY_Z]
+        self.LoadingVelocity = top_vel - bot_vel
+
+    def ComputeMeasuringSurface(self):
+        self.MeasuringSurface = 0.25 * math.pi * self.diameter * self.diameter
+
+    def PrepareTestTriaxialHydro(self):
+
+        ####### Correction Coefs  TODO 0.25* for cylinder section EXXON
+        self.alpha_top = math.pi*self.diameter*self.diameter*0.25/(self.xtop_area + 0.70710678*self.xtopcorner_area)
+        self.alpha_bot = math.pi*self.diameter*self.diameter*0.25/(self.xbot_area + 0.70710678*self.xbotcorner_area)
+        self.alpha_lat = math.pi*self.diameter*self.height/(self.xlat_area + 0.70710678*self.xtopcorner_area + 0.70710678*self.xbotcorner_area)
+
+    def PrepareBTSTest(self):
+        self.absolute_path_to_file5 = os.path.join(self.graphs_path, self.problem_name + "_graph_bts_in_psi.grf")
+        self.graph_export_5 = open(self.absolute_path_to_file5, 'w')
+        self.time_to_print_bts_graph = True
+
+    def PrepareTests(self):
+
+        absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
+        absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_graph_top.grf")
+        absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_bot.grf")
+        absolute_path_to_file4 = os.path.join(self.graphs_path, self.problem_name + "_graph_strain_vs_q.grf")
+        self.graph_export_1 = open(absolute_path_to_file1, 'w')
+        self.graph_export_2 = open(absolute_path_to_file2, 'w')
+        self.graph_export_3 = open(absolute_path_to_file3, 'w')
+        self.graph_export_4 = open(absolute_path_to_file4, 'w')
+
+        (self.xtop_area,self.xbot_area,self.xlat_area,self.xtopcorner_area,self.xbotcorner_area,y_top_total,weight_top, y_bot_total, weight_bot) = self.CylinderSkinDetermination()
+
+        initial_height_top = y_top_total/weight_top
+        initial_height_bot = y_bot_total/weight_bot
+
+        inner_initial_height = initial_height_top - initial_height_bot
+        extended_length = self.height + (self.height - inner_initial_height)
+
+        self.length_correction_factor = self.height/extended_length
+
+        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_CN.grf")
+        self.CN_export = open(absolute_path_to_file, 'w')
+
+    def CylinderSkinDetermination(self):
+
+        # SKIN DETERMINATION
+        total_cross_section = 0.0
+
+        # Cylinder dimensions
+        h = self.height
+        d = self.diameter
+        z_min = self.z_coordinate_of_cylinder_bottom_base
+
+        eps = 3.0 #2.0
+        xlat_area = 0.0
+        xbot_area = 0.0
+        xtop_area = 0.0
+        xbotcorner_area = 0.0
+        xtopcorner_area = 0.0
+        z_top_total = 0.0
+        z_bot_total = 0.0
+        weight_top = 0.0
+        weight_bot = 0.0
+
+        for element in self.spheres_model_part.Elements:
+
+            element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 0)
+
+            node = element.GetNode(0)
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            cross_section = math.pi * r * r
+
+            if (x * x + y * y) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
+
+                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
+                self.LAT.append(node)
+
+                if (z > z_min + eps * r) and (z < z_min + (h - eps * r)):
+
+                    self.SKIN.append(element)
+                    self.XLAT.append(node)
+
+                    xlat_area = xlat_area + cross_section
+
+            if (z <= z_min + eps * r) or (z >= z_min + (h - eps * r)):
+
+                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
+                self.SKIN.append(element)
+
+                if z <= z_min + eps * r:
+
+                    self.BOT.append(node)
+                    z_bot_total += z*r
+                    weight_bot += r
+
+                elif z >= z_min + (h - eps * r):
+
+                    self.TOP.append(node)
+
+                    z_top_total += z*r
+                    weight_top += r
+
+                if (x * x + y * y) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
+
+                    if z > z_min + h / 2:
+
+                        self.XTOPCORNER.append(node)
+                        xtopcorner_area = xtopcorner_area + cross_section
+
+                    else:
+
+                        self.XBOTCORNER.append(node)
+                        xbotcorner_area = xbotcorner_area + cross_section
+                else:
+
+                    if z <= z_min + eps * r:
+
+                        self.XBOT.append(node)
+                        xbot_area = xbot_area + cross_section
+
+                    elif z >= z_min + (h - eps * r):
+
+                        self.XTOP.append(node)
+                        xtop_area = xtop_area + cross_section
+        #checks:
+        if len(self.XLAT)==0:
+            self.procedures.KratosPrintWarning("ERROR! in Cylinder Skin Determination - NO LATERAL PARTICLES" + "\n")
+        else:
+            self.procedures.KratosPrintInfo(str(h) + " * " + str(d) + " cylinder skin determination" + "\n")
+
+        return (xtop_area, xbot_area, xlat_area, xtopcorner_area, xbotcorner_area, z_top_total, weight_top, z_bot_total, weight_bot)
+
+    def ApplyLateralPressure(self, Pressure, XLAT, XBOT, XTOP, XBOTCORNER, XTOPCORNER, alpha_top, alpha_bot, alpha_lat):
+
+        for node in XLAT:
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            values = Array3()
+            vect = Array3()
+
+            cross_section = math.pi * r * r
+
+            # normal vector to the center:
+            vect_moduli = math.sqrt(x * x + y * y)
+
+            if vect_moduli > 0.0:
+                vect[0] = -x / vect_moduli
+                vect[1] = -y / vect_moduli
+                vect[2] = 0.0
+
+            values[0] = cross_section * alpha_lat * Pressure * vect[0]
+            values[1] = cross_section * alpha_lat * Pressure * vect[1]
+            values[2] = 0.0
+
+            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
+
+        for node in XTOPCORNER:
+
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            values = Array3()
+            vect = Array3()
+
+            cross_section = math.pi * r * r
+
+            # normal vector to the center:
+            vect_moduli = math.sqrt(x * x + y * y)
+
+            if vect_moduli > 0.0:
+                vect[0] = -x / vect_moduli
+                vect[1] = -y / vect_moduli
+                vect[2] = 0.0
+
+            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
+            values[1] = cross_section * alpha_lat * Pressure * vect[1] * 0.70710678
+            values[2] = 0.0
+
+            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
+
+        for node in XBOTCORNER:
+
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            values = Array3()
+            vect = Array3()
+
+            cross_section = math.pi * r * r
+
+            # vector normal al centre:
+            vect_moduli = math.sqrt(x * x + z * z)
+
+            if vect_moduli > 0.0:
+                vect[0] = -x / vect_moduli
+                vect[1] = -y / vect_moduli
+                vect[2] = 0.0
+
+            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
+            values[1] = cross_section * alpha_lat * Pressure * vect[1] * 0.70710678
+            values[2] = 0.0
+
+            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
+
+    def PrepareDataForGraph(self):
+
+        prepare_check = [0,0,0,0]
+        self.total_check = 0
+
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                self.top_mesh_nodes = smp.Nodes
+                prepare_check[0] = 1
+            if smp[IDENTIFIER] == 'BOTTOM':
+                self.bot_mesh_nodes = smp.Nodes
+                prepare_check[1] = 1
+
+        for smp in self.spheres_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                self.top_mesh_nodes = smp.Nodes
+                prepare_check[2] = -1
+
+            if smp[IDENTIFIER] == 'BOTTOM':
+                self.bot_mesh_nodes = smp.Nodes
+                prepare_check[3] = -1
+
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP_BTS':
+                self.top_mesh_nodes_bts = smp.Nodes
+            if smp[IDENTIFIER] == 'BOTTOM_BTS':
+                self.bot_mesh_nodes_bts = smp.Nodes
+
+        for it in range(len(prepare_check)):
+            self.total_check += prepare_check[it]
+
+        if math.fabs(self.total_check) != 2:
+            self.Procedures.KratosPrintWarning(" ERROR in the definition of TOP BOT groups. Both groups are required to be defined, they have to be either on FEM groups or in DEM groups")
+
+    def PrintGraph(self, time):
+
+        if self.graph_counter == self.graph_frequency:
+            self.graph_counter = 0
+            total_stress_q = self.total_stress_mean * 1e-6 - self.ConfinementPressure
+            self.graph_export_1.write(str("%.6g"%self.strain).rjust(13)     + "  " + str("%.6g"%(self.total_stress_mean * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
+            self.graph_export_2.write(str("%.8g"%self.strain).rjust(13)     + "  " + str("%.6g"%(self.total_stress_top  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
+            self.graph_export_3.write(str("%.8g"%self.strain).rjust(13)     + "  " + str("%.6g"%(self.total_stress_bot  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
+            self.graph_export_4.write(str("%.8g"%self.strain).rjust(13)     + "  " + str("%.6g"%(total_stress_q)).rjust(13)                + "  " + str("%.8g"%time).rjust(12) + '\n')
+            self.graph_export_1.flush()
+            self.graph_export_2.flush()
+            self.graph_export_3.flush()
+            self.graph_export_4.flush()
+            if self.time_to_print_bts_graph:
+                self.graph_export_5.write(str("%.8g"%self.strain_bts).rjust(13) + "  " + str("%.6g"%(self.total_stress_bts  * 1e-6 * 145)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
+                self.graph_export_5.flush()
+        self.graph_counter += 1
+    
+    def FinalizeGraphs(self):
+        # Create a copy and renaming
+        absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
+        absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_bts.grf")
+        absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_VOL.grf")
+        for filename in os.listdir("."):
+            if filename.startswith(absolute_path_to_file1):
+                shutil.copy(filename, filename + "COPY")
+                os.rename(filename+"COPY", absolute_path_to_file1 + str(self.initial_time).replace(":", "") + ".grf")
+            if filename.startswith(absolute_path_to_file2):
+                shutil.copy(filename, filename + "COPY")
+                os.rename(filename+"COPY", absolute_path_to_file2 + str(self.initial_time).replace(":", "") + ".grf")
+            if filename.startswith(absolute_path_to_file3):
+                shutil.copy(filename, filename + "COPY")
+                os.rename(filename+"COPY", absolute_path_to_file3 + str(self.initial_time).replace(":", "") + ".grf")
+        self.graph_export_1.close()
+        self.graph_export_2.close()
+        self.graph_export_3.close()
+        self.graph_export_4.close()
+        self.graph_export_5.close()
+
+if __name__ == "__main__":
+
+    with open("ProjectParametersDEM_triaxials.json", 'r') as parameter_file:
+        parameters = KratosMultiphysics.Parameters(parameter_file.read())
+
+    machine_learning_file = "machine_learning_data.grf"
+    machine_learning_data = open(machine_learning_file, 'w')
+
+    # TEST DATA
+    confinement_pressure_list = [0.34, 6.9, 13.8] # For the triaxials, in MPa
+    num_of_discretization_points = 10 # To compute relative errors
+    run_also_bts = True
+    print_images = False
+    
+    number_of_triaxials = len(confinement_pressure_list)
+    simulation_number_list = [i for i in range(1, number_of_triaxials + 1)]
+
+    for simulation_number, ConfinementPressure in zip(simulation_number_list, confinement_pressure_list):
+        model = KratosMultiphysics.Model()
+        DecompressedMaterialTriaxialTest(model, parameters).Run()
+
+    if run_also_bts:
+        with open("ProjectParametersDEM_bts.json", 'r') as parameter_file:
+            parameters = KratosMultiphysics.Parameters(parameter_file.read())
+
+        model = KratosMultiphysics.Model()
+        DecompressedMaterialBTSTest(model, parameters).Run()
+    else:
+        machine_learning_data.close()
```

## KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_bts_test.py

 * *Ordering differences only*

```diff
@@ -1,546 +1,546 @@
-import KratosMultiphysics
-from KratosMultiphysics import *
-from KratosMultiphysics.DEMApplication import *
-from KratosMultiphysics.DEMApplication.DEM_analysis_stage import DEMAnalysisStage
-from KratosMultiphysics.DEMApplication import DEM_procedures as DEM_procedures
-import math
-import datetime
-
-class DecompressedMaterialBTSTest(DEMAnalysisStage):
-
-    def __init__(self, model, parameters):
-        super().__init__(model, parameters)
-
-        self.parameters = parameters
-        self.compression_stage_completed = False
-        self.decompression_stage_completed = False
-        self.time_to_print_bts_graph = False
-
-        # Units in Pa and m/s respectively
-        self.SigmaHorizontal = self.parameters["material_test_settings"]["SigmaHorizontal"].GetDouble()
-        self.SigmaVertical = self.parameters["material_test_settings"]["SigmaVertical"].GetDouble()
-        self.SigmaVerticalAlmostZero = self.parameters["material_test_settings"]["SigmaVerticalAlmostZero"].GetDouble()
-        self.PlatesDecompressionVelocity = self.parameters["material_test_settings"]["PlatesDecompressionVelocity"].GetDouble()
-
-    def Initialize(self):
-        super().Initialize()
-        self.InitializeMaterialTest()
-        self.PrepareDataForGraph()
-        self.ApplyPreCompression()
-        self.ApplyDeCompression()
-        self.PrepareBTSTest()
-        self.ApplyLoadingVelocityToBTSPlates()
-
-    def ApplyLoadingVelocityToBTSPlates(self):
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP_BTS':
-                smp[LINEAR_VELOCITY_Y] = 0.5 * self.LoadingVelocity
-            if smp[IDENTIFIER] == 'BOTTOM_BTS':
-                smp[LINEAR_VELOCITY_Y] = -0.5 * self.LoadingVelocity
-
-    def ApplyPreCompression(self):
-
-        self._GetSolver().cplusplus_strategy.BreakAllBonds()
-
-        print("\n************************************ Applying PreCompression...\n", flush=True)
-        while not self.compression_stage_completed:
-            self.time = self._GetSolver().AdvanceInTime(self.time)
-            self.InitializeSolutionStep()
-            self._GetSolver().Predict()
-            self._GetSolver().SolveSolutionStep()
-            self.FinalizeSolutionStepPreCompression()
-            self.OutputSolutionStep()
-        print("\n*************************** Finished Applying PreCompression!!!\n", flush=True)
-
-        self._GetSolver().cplusplus_strategy.HealAllBonds()
-        ParallelBondUtilities().SetCurrentIndentationAsAReferenceInParallelBonds(self.spheres_model_part)
-        PreUtilities().ResetSkinParticles(self.spheres_model_part)
-        self._GetSolver().cplusplus_strategy.ComputeSkin(self.spheres_model_part, 1.5)
-
-    def ResetLoadingVelocity(self):
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                smp[LINEAR_VELOCITY_Z] = 0.5 * self.PlatesDecompressionVelocity
-            if smp[IDENTIFIER] == 'BOTTOM':
-                smp[LINEAR_VELOCITY_Z] = -0.5 * self.PlatesDecompressionVelocity
-
-    def ApplyDeCompression(self):
-
-        print("\n************************************ Applying DeCompression...\n", flush=True)
-        while not self.decompression_stage_completed:
-            self.time = self._GetSolver().AdvanceInTime(self.time)
-            self.InitializeSolutionStep()
-            self._GetSolver().Predict()
-            self.ResetLoadingVelocity()
-            self._GetSolver().SolveSolutionStep()
-            self.FinalizeSolutionStepDeCompression()
-            self.OutputSolutionStep()
-        print("\n*************************** Finished Applying DeCompression!!!\n", flush=True)
-
-    def RunSolutionLoop(self):
-
-        print("\n************************************ Applying standard BTS...\n", flush=True)
-        while self.KeepAdvancingSolutionLoop():
-            self.time = self._GetSolver().AdvanceInTime(self.time)
-            self.InitializeSolutionStep()
-            self._GetSolver().Predict()
-            self._GetSolver().SolveSolutionStep()
-            self.FinalizeSolutionStep()
-            self.OutputSolutionStep()
-        print("\n*************************** Finished Applying standard BTS...\n", flush=True)
-
-    def OutputSolutionStep(self):
-        super().OutputSolutionStep()
-        self.PrintGraph(self.time)
-
-    def FinalizeSolutionStepPreCompression(self):
-        super().FinalizeSolutionStep()
-        self.MeasureForcesAndPressurePreCompression()
-
-    def FinalizeSolutionStepDeCompression(self):
-        super().FinalizeSolutionStep()
-        self.MeasureForcesAndPressureDeCompression()
-
-    def FinalizeSolutionStep(self):
-        super().FinalizeSolutionStep()
-        self.MeasureForcesAndPressure()
-
-    def Finalize(self):
-        super().Finalize()
-
-        # TODO: After self.CleanUpOperations() in base class!!
-        self.FinalizeGraphs()
-
-    def InitializeMaterialTest(self):
-
-        self.top_mesh_nodes = []; self.bot_mesh_nodes = []; self.top_mesh_nodes_bts = []; self.bot_mesh_nodes_bts = []
-        self.xtop_area = 0.0
-        self.xbot_area = 0.0
-        self.xlat_area = 0.0
-        self.xtopcorner_area = 0.0
-        self.xbotcorner_area = 0.0
-        self.SKIN = list()
-        self.LAT = list()
-        self.BOT = list()
-        self.TOP = list()
-        self.XLAT = list()  # only lat, not the corner ones
-        self.XTOP = list()  # only top, not corner ones...
-        self.XBOT = list()
-        self.XTOPCORNER = list()
-        self.XBOTCORNER = list()
-        self.bond_00_05 = list(); self.bond_05_10 = list(); self.bond_10_15 = list(); self.bond_15_20 = list(); self.bond_20_25 = list(); self.bond_25_30 = list(); self.bond_30_35 = list()
-        self.bond_35_40 = list(); self.bond_40_45 = list(); self.bond_45_50 = list(); self.bond_50_55 = list(); self.bond_55_60 = list(); self.bond_60_65 = list(); self.bond_65_70 = list()
-        self.bond_70_75 = list(); self.bond_75_80 = list(); self.bond_80_85 = list(); self.bond_85_90 = list()
-        self.sizes = []
-        self.sigma_mean_table = []; self.tau_mean_table = []; self.sigma_rel_std_dev_table = []; self.tau_rel_std_dev_table = []; self.sigma_ratio_table = [];
-
-        for i in range(0,18):
-            self.sizes.append(0.0)
-            self.sigma_mean_table.append(0.0)
-            self.tau_mean_table.append(0.0)
-            self.sigma_rel_std_dev_table.append(0.0)
-            self.tau_rel_std_dev_table.append(0.0)
-            self.sigma_ratio_table.append(0.0)
-
-        self.graph_counter = 0; self.renew_pressure = 0; self.Pressure = 0.0; self.pressure_to_apply = 0.0; self.CN_graph_counter = 0
-        self.length_correction_factor = 1.0
-        self.graph_frequency        = int(self.parameters["GraphExportFreq"].GetDouble()/self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME))
-        self.strain = 0.0; self.strain_bts = 0.0; self.volumetric_strain = 0.0; self.radial_strain = 0.0; self.first_time_entry = 1; self.first_time_entry_2 = 1
-        self.total_stress_top = 0.0; self.total_stress_bot = 0.0; self.total_stress_mean = 0.0
-        self.LoadingVelocity = 0.0
-        self.MeasuringSurface = 0.0
-
-        if "material_test_settings" in self.parameters.keys():
-            self.height = self.parameters["material_test_settings"]["SpecimenLength"].GetDouble()
-            self.diameter = self.parameters["material_test_settings"]["SpecimenDiameter"].GetDouble()
-            self.ConfinementPressure = self.parameters["material_test_settings"]["ConfinementPressure"].GetDouble()
-            self.y_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["YCoordinateOfCylinderBottomBase"].GetDouble()
-            self.z_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["ZCoordinateOfCylinderBottomBase"].GetDouble()
-        else:
-            self.height = self.parameters["SpecimenLength"].GetDouble()
-            self.diameter = self.parameters["SpecimenDiameter"].GetDouble()
-            self.ConfinementPressure = self.parameters["ConfinementPressure"].GetDouble()
-            self.y_coordinate_of_cylinder_bottom_base = self.parameters["YCoordinateOfCylinderBottomBase"].GetDouble()
-            self.z_coordinate_of_cylinder_bottom_base = self.parameters["ZCoordinateOfCylinderBottomBase"].GetDouble()
-
-        self.ComputeLoadingVelocity()
-        self.ComputeMeasuringSurface()
-        self.problem_name = self.parameters["problem_name"].GetString()
-        self.initial_time = datetime.datetime.now()
-        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_Parameter_chart.grf")
-        self.chart = open(absolute_path_to_file, 'w')
-        self.aux = AuxiliaryUtilities()
-        self.PreUtilities = PreUtilities()
-        self.PrepareTests()
-        self.PrepareTestTriaxialHydro()
-        domain_volume = math.pi * 0.5 * 0.5 * self.diameter * self.diameter * self.height
-        DEM_procedures.GranulometryUtils(domain_volume, self.spheres_model_part)
-
-    def MeasureForcesAndPressurePreCompression(self):
-
-        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
-        self.strain += -100 * self.length_correction_factor * self.LoadingVelocity * dt / self.height
-
-        total_force_top = 0.0
-        for node in self.top_mesh_nodes:
-            force_node_z = node.GetSolutionStepValue(ELASTIC_FORCES)[2]
-            total_force_top += force_node_z
-        self.total_stress_top = total_force_top / self.MeasuringSurface
-
-        total_force_bot = 0.0
-        for node in self.bot_mesh_nodes:
-            force_node_z = -node.GetSolutionStepValue(ELASTIC_FORCES)[2]
-            total_force_bot += force_node_z
-        self.total_stress_bot = total_force_bot / self.MeasuringSurface
-
-        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
-
-        if self.SigmaHorizontal:
-            self.Pressure = min(self.total_stress_mean, self.SigmaHorizontal)
-            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
-
-        if self.total_stress_mean > self.SigmaVertical:
-            self.compression_stage_completed = True
-
-    def MeasureForcesAndPressureDeCompression(self):
-
-        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
-        self.strain += -100 * self.length_correction_factor * self.PlatesDecompressionVelocity * dt / self.height
-
-        total_force_top = 0.0
-        for node in self.top_mesh_nodes:
-            force_node_z = node.GetSolutionStepValue(ELASTIC_FORCES)[2]
-            total_force_top += force_node_z
-        self.total_stress_top = total_force_top / self.MeasuringSurface
-
-        total_force_bot = 0.0
-        for node in self.bot_mesh_nodes:
-            force_node_z = -node.GetSolutionStepValue(ELASTIC_FORCES)[2]
-            total_force_bot += force_node_z
-        self.total_stress_bot = total_force_bot / self.MeasuringSurface
-
-        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
-
-        if self.SigmaHorizontal:
-            self.Pressure = min(self.total_stress_mean, self.SigmaHorizontal)
-            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
-
-        if self.total_stress_mean < self.SigmaVerticalAlmostZero:
-            self.decompression_stage_completed = True
-
-    def MeasureForcesAndPressure(self):
-
-        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
-
-        total_force_top = 0.0
-        for node in self.top_mesh_nodes_bts:
-            force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-            total_force_top += force_node_y
-
-        total_force_bot = 0.0
-        for node in self.bot_mesh_nodes_bts:
-            force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-            total_force_bot += force_node_y
-
-        total_force_bts = 0.5 * (total_force_bot + total_force_top)
-
-        self.total_stress_bts = 2.0 * total_force_bts / (math.pi * self.height * self.diameter)
-        self.strain_bts += -100 * self.LoadingVelocity * dt / self.diameter
-
-    def ComputeLoadingVelocity(self):
-        top_vel = bot_vel = 0.0
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                top_vel = smp[LINEAR_VELOCITY_Z]
-            if smp[IDENTIFIER] == 'BOTTOM':
-                bot_vel = smp[LINEAR_VELOCITY_Z]
-        self.LoadingVelocity = top_vel - bot_vel
-
-    def ComputeMeasuringSurface(self):
-        self.MeasuringSurface = 0.25 * math.pi * self.diameter * self.diameter
-
-    def PrepareTestTriaxialHydro(self):
-
-        ####### Correction Coefs  TODO 0.25* for cylinder section EXXON
-        self.alpha_top = math.pi*self.diameter*self.diameter*0.25/(self.xtop_area + 0.70710678*self.xtopcorner_area)
-        self.alpha_bot = math.pi*self.diameter*self.diameter*0.25/(self.xbot_area + 0.70710678*self.xbotcorner_area)
-        self.alpha_lat = math.pi*self.diameter*self.height/(self.xlat_area + 0.70710678*self.xtopcorner_area + 0.70710678*self.xbotcorner_area)
-
-    def PrepareBTSTest(self):
-        absolute_path_to_file5 = os.path.join(self.graphs_path, self.problem_name + "_graph_bts.grf")
-        self.graph_export_5 = open(absolute_path_to_file5, 'w')
-        self.time_to_print_bts_graph = True
-
-    def PrepareTests(self):
-
-        absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
-        absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_graph_top.grf")
-        absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_bot.grf")
-        absolute_path_to_file4 = os.path.join(self.graphs_path, self.problem_name + "_graph_strain_vs_q.grf")
-        self.graph_export_1 = open(absolute_path_to_file1, 'w')
-        self.graph_export_2 = open(absolute_path_to_file2, 'w')
-        self.graph_export_3 = open(absolute_path_to_file3, 'w')
-        self.graph_export_4 = open(absolute_path_to_file4, 'w')
-
-        (self.xtop_area,self.xbot_area,self.xlat_area,self.xtopcorner_area,self.xbotcorner_area,y_top_total,weight_top, y_bot_total, weight_bot) = self.CylinderSkinDetermination()
-
-        initial_height_top = y_top_total/weight_top
-        initial_height_bot = y_bot_total/weight_bot
-
-        inner_initial_height = initial_height_top - initial_height_bot
-        extended_length = self.height + (self.height - inner_initial_height)
-
-        self.length_correction_factor = self.height/extended_length
-
-        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_CN.grf")
-        self.CN_export = open(absolute_path_to_file, 'w')
-
-    def CylinderSkinDetermination(self):
-
-        # Cylinder dimensions
-        h = self.height
-        d = self.diameter
-        z_min = self.z_coordinate_of_cylinder_bottom_base
-
-        eps = 3.0 #2.0
-        xlat_area = 0.0
-        xbot_area = 0.0
-        xtop_area = 0.0
-        xbotcorner_area = 0.0
-        xtopcorner_area = 0.0
-        z_top_total = 0.0
-        z_bot_total = 0.0
-        weight_top = 0.0
-        weight_bot = 0.0
-
-        for element in self.spheres_model_part.Elements:
-
-            element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 0)
-
-            node = element.GetNode(0)
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            cross_section = math.pi * r * r
-
-            if (x * x + y * y) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
-
-                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
-                self.LAT.append(node)
-
-                if (z > z_min + eps * r) and (z < z_min + (h - eps * r)):
-
-                    self.SKIN.append(element)
-                    self.XLAT.append(node)
-
-                    xlat_area = xlat_area + cross_section
-
-            if (z <= z_min + eps * r) or (z >= z_min + (h - eps * r)):
-
-                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
-                self.SKIN.append(element)
-
-                if z <= z_min + eps * r:
-
-                    self.BOT.append(node)
-                    z_bot_total += z*r
-                    weight_bot += r
-
-                elif z >= z_min + (h - eps * r):
-
-                    self.TOP.append(node)
-
-                    z_top_total += z*r
-                    weight_top += r
-
-                if (x * x + y * y) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
-
-                    if z > z_min + h / 2:
-
-                        self.XTOPCORNER.append(node)
-                        xtopcorner_area = xtopcorner_area + cross_section
-
-                    else:
-
-                        self.XBOTCORNER.append(node)
-                        xbotcorner_area = xbotcorner_area + cross_section
-                else:
-
-                    if z <= z_min + eps * r:
-
-                        self.XBOT.append(node)
-                        xbot_area = xbot_area + cross_section
-
-                    elif z >= z_min + (h - eps * r):
-
-                        self.XTOP.append(node)
-                        xtop_area = xtop_area + cross_section
-        #checks:
-        if len(self.XLAT)==0:
-            self.procedures.KratosPrintWarning("ERROR! in Cylinder Skin Determination - NO LATERAL PARTICLES" + "\n")
-        else:
-            self.procedures.KratosPrintInfo(str(h) + " * " + str(d) + " cylinder skin determination" + "\n")
-
-        return (xtop_area, xbot_area, xlat_area, xtopcorner_area, xbotcorner_area, z_top_total, weight_top, z_bot_total, weight_bot)
-
-    def ApplyLateralPressure(self, Pressure, XLAT, XBOT, XTOP, XBOTCORNER, XTOPCORNER, alpha_top, alpha_bot, alpha_lat):
-
-        for node in XLAT:
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            values = Array3()
-            vect = Array3()
-
-            cross_section = math.pi * r * r
-
-            # normal vector to the center:
-            vect_moduli = math.sqrt(x * x + y * y)
-
-            if vect_moduli > 0.0:
-                vect[0] = -x / vect_moduli
-                vect[1] = -y / vect_moduli
-                vect[2] = 0.0
-
-            values[0] = cross_section * alpha_lat * Pressure * vect[0]
-            values[1] = cross_section * alpha_lat * Pressure * vect[1]
-            values[2] = 0.0
-
-            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
-
-        for node in XTOPCORNER:
-
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            values = Array3()
-            vect = Array3()
-
-            cross_section = math.pi * r * r
-
-            # normal vector to the center:
-            vect_moduli = math.sqrt(x * x + y * y)
-
-            if vect_moduli > 0.0:
-                vect[0] = -x / vect_moduli
-                vect[1] = -y / vect_moduli
-                vect[2] = 0.0
-
-            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
-            values[1] = cross_section * alpha_lat * Pressure * vect[1] * 0.70710678
-            values[2] = 0.0
-
-            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
-
-        for node in XBOTCORNER:
-
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            values = Array3()
-            vect = Array3()
-
-            cross_section = math.pi * r * r
-
-            # vector normal al centre:
-            vect_moduli = math.sqrt(x * x + z * z)
-
-            if vect_moduli > 0.0:
-                vect[0] = -x / vect_moduli
-                vect[1] = -y / vect_moduli
-                vect[2] = 0.0
-
-            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
-            values[1] = cross_section * alpha_lat * Pressure * vect[1] * 0.70710678
-            values[2] = 0.0
-
-            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
-
-    def PrepareDataForGraph(self):
-
-        prepare_check = [0,0,0,0]
-        self.total_check = 0
-
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                self.top_mesh_nodes = smp.Nodes
-                prepare_check[0] = 1
-            if smp[IDENTIFIER] == 'BOTTOM':
-                self.bot_mesh_nodes = smp.Nodes
-                prepare_check[1] = 1
-
-        for smp in self.spheres_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                self.top_mesh_nodes = smp.Nodes
-                prepare_check[2] = -1
-
-            if smp[IDENTIFIER] == 'BOTTOM':
-                self.bot_mesh_nodes = smp.Nodes
-                prepare_check[3] = -1
-
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP_BTS':
-                self.top_mesh_nodes_bts = smp.Nodes
-            if smp[IDENTIFIER] == 'BOTTOM_BTS':
-                self.bot_mesh_nodes_bts = smp.Nodes
-
-        for it in range(len(prepare_check)):
-            self.total_check += prepare_check[it]
-
-        if math.fabs(self.total_check) != 2:
-            self.Procedures.KratosPrintWarning(" ERROR in the definition of TOP BOT groups. Both groups are required to be defined, they have to be either on FEM groups or in DEM groups")
-
-    def PrintGraph(self, time):
-
-        if self.graph_counter == self.graph_frequency:
-            self.graph_counter = 0
-            total_stress_q = self.total_stress_mean * 1e-6 - self.ConfinementPressure
-            self.graph_export_1.write(str("%.6g"%self.strain).rjust(13)     + "  " + str("%.6g"%(self.total_stress_mean * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
-            self.graph_export_2.write(str("%.8g"%self.strain).rjust(13)     + "  " + str("%.6g"%(self.total_stress_top  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
-            self.graph_export_3.write(str("%.8g"%self.strain).rjust(13)     + "  " + str("%.6g"%(self.total_stress_bot  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
-            self.graph_export_4.write(str("%.8g"%self.strain).rjust(13)     + "  " + str("%.6g"%(total_stress_q)).rjust(13)                + "  " + str("%.8g"%time).rjust(12) + '\n')
-            self.graph_export_1.flush()
-            self.graph_export_2.flush()
-            self.graph_export_3.flush()
-            self.graph_export_4.flush()
-            if self.time_to_print_bts_graph:
-                self.graph_export_5.write(str("%.8g"%self.strain_bts).rjust(13) + "  " + str("%.6g"%(self.total_stress_bts  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
-                self.graph_export_5.flush()
-        self.graph_counter += 1
-
-    def FinalizeGraphs(self):
-        # Create a copy and renaming
-        absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
-        absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_bts.grf")
-        absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_VOL.grf")
-        for filename in os.listdir("."):
-            if filename.startswith(absolute_path_to_file1):
-                shutil.copy(filename, filename + "COPY")
-                os.rename(filename+"COPY", absolute_path_to_file1 + str(self.initial_time).replace(":", "") + ".grf")
-            if filename.startswith(absolute_path_to_file2):
-                shutil.copy(filename, filename + "COPY")
-                os.rename(filename+"COPY", absolute_path_to_file2 + str(self.initial_time).replace(":", "") + ".grf")
-            if filename.startswith(absolute_path_to_file3):
-                shutil.copy(filename, filename + "COPY")
-                os.rename(filename+"COPY", absolute_path_to_file3 + str(self.initial_time).replace(":", "") + ".grf")
-        self.graph_export_1.close()
-        self.graph_export_2.close()
-        self.graph_export_3.close()
-        self.graph_export_4.close()
-        self.graph_export_5.close()
-
-if __name__ == "__main__":
-
-    with open("ProjectParametersDEM.json", 'r') as parameter_file:
-        parameters = KratosMultiphysics.Parameters(parameter_file.read())
-
-    model = KratosMultiphysics.Model()
-    DecompressedMaterialBTSTest(model, parameters).Run()
+import KratosMultiphysics
+from KratosMultiphysics import *
+from KratosMultiphysics.DEMApplication import *
+from KratosMultiphysics.DEMApplication.DEM_analysis_stage import DEMAnalysisStage
+from KratosMultiphysics.DEMApplication import DEM_procedures as DEM_procedures
+import math
+import datetime
+
+class DecompressedMaterialBTSTest(DEMAnalysisStage):
+
+    def __init__(self, model, parameters):
+        super().__init__(model, parameters)
+
+        self.parameters = parameters
+        self.compression_stage_completed = False
+        self.decompression_stage_completed = False
+        self.time_to_print_bts_graph = False
+
+        # Units in Pa and m/s respectively
+        self.SigmaHorizontal = self.parameters["material_test_settings"]["SigmaHorizontal"].GetDouble()
+        self.SigmaVertical = self.parameters["material_test_settings"]["SigmaVertical"].GetDouble()
+        self.SigmaVerticalAlmostZero = self.parameters["material_test_settings"]["SigmaVerticalAlmostZero"].GetDouble()
+        self.PlatesDecompressionVelocity = self.parameters["material_test_settings"]["PlatesDecompressionVelocity"].GetDouble()
+
+    def Initialize(self):
+        super().Initialize()
+        self.InitializeMaterialTest()
+        self.PrepareDataForGraph()
+        self.ApplyPreCompression()
+        self.ApplyDeCompression()
+        self.PrepareBTSTest()
+        self.ApplyLoadingVelocityToBTSPlates()
+
+    def ApplyLoadingVelocityToBTSPlates(self):
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP_BTS':
+                smp[LINEAR_VELOCITY_Y] = 0.5 * self.LoadingVelocity
+            if smp[IDENTIFIER] == 'BOTTOM_BTS':
+                smp[LINEAR_VELOCITY_Y] = -0.5 * self.LoadingVelocity
+
+    def ApplyPreCompression(self):
+
+        self._GetSolver().cplusplus_strategy.BreakAllBonds()
+
+        print("\n************************************ Applying PreCompression...\n", flush=True)
+        while not self.compression_stage_completed:
+            self.time = self._GetSolver().AdvanceInTime(self.time)
+            self.InitializeSolutionStep()
+            self._GetSolver().Predict()
+            self._GetSolver().SolveSolutionStep()
+            self.FinalizeSolutionStepPreCompression()
+            self.OutputSolutionStep()
+        print("\n*************************** Finished Applying PreCompression!!!\n", flush=True)
+
+        self._GetSolver().cplusplus_strategy.HealAllBonds()
+        ParallelBondUtilities().SetCurrentIndentationAsAReferenceInParallelBonds(self.spheres_model_part)
+        PreUtilities().ResetSkinParticles(self.spheres_model_part)
+        self._GetSolver().cplusplus_strategy.ComputeSkin(self.spheres_model_part, 1.5)
+
+    def ResetLoadingVelocity(self):
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                smp[LINEAR_VELOCITY_Z] = 0.5 * self.PlatesDecompressionVelocity
+            if smp[IDENTIFIER] == 'BOTTOM':
+                smp[LINEAR_VELOCITY_Z] = -0.5 * self.PlatesDecompressionVelocity
+
+    def ApplyDeCompression(self):
+
+        print("\n************************************ Applying DeCompression...\n", flush=True)
+        while not self.decompression_stage_completed:
+            self.time = self._GetSolver().AdvanceInTime(self.time)
+            self.InitializeSolutionStep()
+            self._GetSolver().Predict()
+            self.ResetLoadingVelocity()
+            self._GetSolver().SolveSolutionStep()
+            self.FinalizeSolutionStepDeCompression()
+            self.OutputSolutionStep()
+        print("\n*************************** Finished Applying DeCompression!!!\n", flush=True)
+
+    def RunSolutionLoop(self):
+
+        print("\n************************************ Applying standard BTS...\n", flush=True)
+        while self.KeepAdvancingSolutionLoop():
+            self.time = self._GetSolver().AdvanceInTime(self.time)
+            self.InitializeSolutionStep()
+            self._GetSolver().Predict()
+            self._GetSolver().SolveSolutionStep()
+            self.FinalizeSolutionStep()
+            self.OutputSolutionStep()
+        print("\n*************************** Finished Applying standard BTS...\n", flush=True)
+
+    def OutputSolutionStep(self):
+        super().OutputSolutionStep()
+        self.PrintGraph(self.time)
+
+    def FinalizeSolutionStepPreCompression(self):
+        super().FinalizeSolutionStep()
+        self.MeasureForcesAndPressurePreCompression()
+
+    def FinalizeSolutionStepDeCompression(self):
+        super().FinalizeSolutionStep()
+        self.MeasureForcesAndPressureDeCompression()
+
+    def FinalizeSolutionStep(self):
+        super().FinalizeSolutionStep()
+        self.MeasureForcesAndPressure()
+
+    def Finalize(self):
+        super().Finalize()
+
+        # TODO: After self.CleanUpOperations() in base class!!
+        self.FinalizeGraphs()
+
+    def InitializeMaterialTest(self):
+
+        self.top_mesh_nodes = []; self.bot_mesh_nodes = []; self.top_mesh_nodes_bts = []; self.bot_mesh_nodes_bts = []
+        self.xtop_area = 0.0
+        self.xbot_area = 0.0
+        self.xlat_area = 0.0
+        self.xtopcorner_area = 0.0
+        self.xbotcorner_area = 0.0
+        self.SKIN = list()
+        self.LAT = list()
+        self.BOT = list()
+        self.TOP = list()
+        self.XLAT = list()  # only lat, not the corner ones
+        self.XTOP = list()  # only top, not corner ones...
+        self.XBOT = list()
+        self.XTOPCORNER = list()
+        self.XBOTCORNER = list()
+        self.bond_00_05 = list(); self.bond_05_10 = list(); self.bond_10_15 = list(); self.bond_15_20 = list(); self.bond_20_25 = list(); self.bond_25_30 = list(); self.bond_30_35 = list()
+        self.bond_35_40 = list(); self.bond_40_45 = list(); self.bond_45_50 = list(); self.bond_50_55 = list(); self.bond_55_60 = list(); self.bond_60_65 = list(); self.bond_65_70 = list()
+        self.bond_70_75 = list(); self.bond_75_80 = list(); self.bond_80_85 = list(); self.bond_85_90 = list()
+        self.sizes = []
+        self.sigma_mean_table = []; self.tau_mean_table = []; self.sigma_rel_std_dev_table = []; self.tau_rel_std_dev_table = []; self.sigma_ratio_table = [];
+
+        for i in range(0,18):
+            self.sizes.append(0.0)
+            self.sigma_mean_table.append(0.0)
+            self.tau_mean_table.append(0.0)
+            self.sigma_rel_std_dev_table.append(0.0)
+            self.tau_rel_std_dev_table.append(0.0)
+            self.sigma_ratio_table.append(0.0)
+
+        self.graph_counter = 0; self.renew_pressure = 0; self.Pressure = 0.0; self.pressure_to_apply = 0.0; self.CN_graph_counter = 0
+        self.length_correction_factor = 1.0
+        self.graph_frequency        = int(self.parameters["GraphExportFreq"].GetDouble()/self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME))
+        self.strain = 0.0; self.strain_bts = 0.0; self.volumetric_strain = 0.0; self.radial_strain = 0.0; self.first_time_entry = 1; self.first_time_entry_2 = 1
+        self.total_stress_top = 0.0; self.total_stress_bot = 0.0; self.total_stress_mean = 0.0
+        self.LoadingVelocity = 0.0
+        self.MeasuringSurface = 0.0
+
+        if "material_test_settings" in self.parameters.keys():
+            self.height = self.parameters["material_test_settings"]["SpecimenLength"].GetDouble()
+            self.diameter = self.parameters["material_test_settings"]["SpecimenDiameter"].GetDouble()
+            self.ConfinementPressure = self.parameters["material_test_settings"]["ConfinementPressure"].GetDouble()
+            self.y_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["YCoordinateOfCylinderBottomBase"].GetDouble()
+            self.z_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["ZCoordinateOfCylinderBottomBase"].GetDouble()
+        else:
+            self.height = self.parameters["SpecimenLength"].GetDouble()
+            self.diameter = self.parameters["SpecimenDiameter"].GetDouble()
+            self.ConfinementPressure = self.parameters["ConfinementPressure"].GetDouble()
+            self.y_coordinate_of_cylinder_bottom_base = self.parameters["YCoordinateOfCylinderBottomBase"].GetDouble()
+            self.z_coordinate_of_cylinder_bottom_base = self.parameters["ZCoordinateOfCylinderBottomBase"].GetDouble()
+
+        self.ComputeLoadingVelocity()
+        self.ComputeMeasuringSurface()
+        self.problem_name = self.parameters["problem_name"].GetString()
+        self.initial_time = datetime.datetime.now()
+        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_Parameter_chart.grf")
+        self.chart = open(absolute_path_to_file, 'w')
+        self.aux = AuxiliaryUtilities()
+        self.PreUtilities = PreUtilities()
+        self.PrepareTests()
+        self.PrepareTestTriaxialHydro()
+        domain_volume = math.pi * 0.5 * 0.5 * self.diameter * self.diameter * self.height
+        DEM_procedures.GranulometryUtils(domain_volume, self.spheres_model_part)
+
+    def MeasureForcesAndPressurePreCompression(self):
+
+        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
+        self.strain += -100 * self.length_correction_factor * self.LoadingVelocity * dt / self.height
+
+        total_force_top = 0.0
+        for node in self.top_mesh_nodes:
+            force_node_z = node.GetSolutionStepValue(ELASTIC_FORCES)[2]
+            total_force_top += force_node_z
+        self.total_stress_top = total_force_top / self.MeasuringSurface
+
+        total_force_bot = 0.0
+        for node in self.bot_mesh_nodes:
+            force_node_z = -node.GetSolutionStepValue(ELASTIC_FORCES)[2]
+            total_force_bot += force_node_z
+        self.total_stress_bot = total_force_bot / self.MeasuringSurface
+
+        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
+
+        if self.SigmaHorizontal:
+            self.Pressure = min(self.total_stress_mean, self.SigmaHorizontal)
+            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
+
+        if self.total_stress_mean > self.SigmaVertical:
+            self.compression_stage_completed = True
+
+    def MeasureForcesAndPressureDeCompression(self):
+
+        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
+        self.strain += -100 * self.length_correction_factor * self.PlatesDecompressionVelocity * dt / self.height
+
+        total_force_top = 0.0
+        for node in self.top_mesh_nodes:
+            force_node_z = node.GetSolutionStepValue(ELASTIC_FORCES)[2]
+            total_force_top += force_node_z
+        self.total_stress_top = total_force_top / self.MeasuringSurface
+
+        total_force_bot = 0.0
+        for node in self.bot_mesh_nodes:
+            force_node_z = -node.GetSolutionStepValue(ELASTIC_FORCES)[2]
+            total_force_bot += force_node_z
+        self.total_stress_bot = total_force_bot / self.MeasuringSurface
+
+        self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
+
+        if self.SigmaHorizontal:
+            self.Pressure = min(self.total_stress_mean, self.SigmaHorizontal)
+            self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
+
+        if self.total_stress_mean < self.SigmaVerticalAlmostZero:
+            self.decompression_stage_completed = True
+
+    def MeasureForcesAndPressure(self):
+
+        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
+
+        total_force_top = 0.0
+        for node in self.top_mesh_nodes_bts:
+            force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+            total_force_top += force_node_y
+
+        total_force_bot = 0.0
+        for node in self.bot_mesh_nodes_bts:
+            force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+            total_force_bot += force_node_y
+
+        total_force_bts = 0.5 * (total_force_bot + total_force_top)
+
+        self.total_stress_bts = 2.0 * total_force_bts / (math.pi * self.height * self.diameter)
+        self.strain_bts += -100 * self.LoadingVelocity * dt / self.diameter
+
+    def ComputeLoadingVelocity(self):
+        top_vel = bot_vel = 0.0
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                top_vel = smp[LINEAR_VELOCITY_Z]
+            if smp[IDENTIFIER] == 'BOTTOM':
+                bot_vel = smp[LINEAR_VELOCITY_Z]
+        self.LoadingVelocity = top_vel - bot_vel
+
+    def ComputeMeasuringSurface(self):
+        self.MeasuringSurface = 0.25 * math.pi * self.diameter * self.diameter
+
+    def PrepareTestTriaxialHydro(self):
+
+        ####### Correction Coefs  TODO 0.25* for cylinder section EXXON
+        self.alpha_top = math.pi*self.diameter*self.diameter*0.25/(self.xtop_area + 0.70710678*self.xtopcorner_area)
+        self.alpha_bot = math.pi*self.diameter*self.diameter*0.25/(self.xbot_area + 0.70710678*self.xbotcorner_area)
+        self.alpha_lat = math.pi*self.diameter*self.height/(self.xlat_area + 0.70710678*self.xtopcorner_area + 0.70710678*self.xbotcorner_area)
+
+    def PrepareBTSTest(self):
+        absolute_path_to_file5 = os.path.join(self.graphs_path, self.problem_name + "_graph_bts.grf")
+        self.graph_export_5 = open(absolute_path_to_file5, 'w')
+        self.time_to_print_bts_graph = True
+
+    def PrepareTests(self):
+
+        absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
+        absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_graph_top.grf")
+        absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_bot.grf")
+        absolute_path_to_file4 = os.path.join(self.graphs_path, self.problem_name + "_graph_strain_vs_q.grf")
+        self.graph_export_1 = open(absolute_path_to_file1, 'w')
+        self.graph_export_2 = open(absolute_path_to_file2, 'w')
+        self.graph_export_3 = open(absolute_path_to_file3, 'w')
+        self.graph_export_4 = open(absolute_path_to_file4, 'w')
+
+        (self.xtop_area,self.xbot_area,self.xlat_area,self.xtopcorner_area,self.xbotcorner_area,y_top_total,weight_top, y_bot_total, weight_bot) = self.CylinderSkinDetermination()
+
+        initial_height_top = y_top_total/weight_top
+        initial_height_bot = y_bot_total/weight_bot
+
+        inner_initial_height = initial_height_top - initial_height_bot
+        extended_length = self.height + (self.height - inner_initial_height)
+
+        self.length_correction_factor = self.height/extended_length
+
+        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_CN.grf")
+        self.CN_export = open(absolute_path_to_file, 'w')
+
+    def CylinderSkinDetermination(self):
+
+        # Cylinder dimensions
+        h = self.height
+        d = self.diameter
+        z_min = self.z_coordinate_of_cylinder_bottom_base
+
+        eps = 3.0 #2.0
+        xlat_area = 0.0
+        xbot_area = 0.0
+        xtop_area = 0.0
+        xbotcorner_area = 0.0
+        xtopcorner_area = 0.0
+        z_top_total = 0.0
+        z_bot_total = 0.0
+        weight_top = 0.0
+        weight_bot = 0.0
+
+        for element in self.spheres_model_part.Elements:
+
+            element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 0)
+
+            node = element.GetNode(0)
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            cross_section = math.pi * r * r
+
+            if (x * x + y * y) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
+
+                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
+                self.LAT.append(node)
+
+                if (z > z_min + eps * r) and (z < z_min + (h - eps * r)):
+
+                    self.SKIN.append(element)
+                    self.XLAT.append(node)
+
+                    xlat_area = xlat_area + cross_section
+
+            if (z <= z_min + eps * r) or (z >= z_min + (h - eps * r)):
+
+                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
+                self.SKIN.append(element)
+
+                if z <= z_min + eps * r:
+
+                    self.BOT.append(node)
+                    z_bot_total += z*r
+                    weight_bot += r
+
+                elif z >= z_min + (h - eps * r):
+
+                    self.TOP.append(node)
+
+                    z_top_total += z*r
+                    weight_top += r
+
+                if (x * x + y * y) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
+
+                    if z > z_min + h / 2:
+
+                        self.XTOPCORNER.append(node)
+                        xtopcorner_area = xtopcorner_area + cross_section
+
+                    else:
+
+                        self.XBOTCORNER.append(node)
+                        xbotcorner_area = xbotcorner_area + cross_section
+                else:
+
+                    if z <= z_min + eps * r:
+
+                        self.XBOT.append(node)
+                        xbot_area = xbot_area + cross_section
+
+                    elif z >= z_min + (h - eps * r):
+
+                        self.XTOP.append(node)
+                        xtop_area = xtop_area + cross_section
+        #checks:
+        if len(self.XLAT)==0:
+            self.procedures.KratosPrintWarning("ERROR! in Cylinder Skin Determination - NO LATERAL PARTICLES" + "\n")
+        else:
+            self.procedures.KratosPrintInfo(str(h) + " * " + str(d) + " cylinder skin determination" + "\n")
+
+        return (xtop_area, xbot_area, xlat_area, xtopcorner_area, xbotcorner_area, z_top_total, weight_top, z_bot_total, weight_bot)
+
+    def ApplyLateralPressure(self, Pressure, XLAT, XBOT, XTOP, XBOTCORNER, XTOPCORNER, alpha_top, alpha_bot, alpha_lat):
+
+        for node in XLAT:
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            values = Array3()
+            vect = Array3()
+
+            cross_section = math.pi * r * r
+
+            # normal vector to the center:
+            vect_moduli = math.sqrt(x * x + y * y)
+
+            if vect_moduli > 0.0:
+                vect[0] = -x / vect_moduli
+                vect[1] = -y / vect_moduli
+                vect[2] = 0.0
+
+            values[0] = cross_section * alpha_lat * Pressure * vect[0]
+            values[1] = cross_section * alpha_lat * Pressure * vect[1]
+            values[2] = 0.0
+
+            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
+
+        for node in XTOPCORNER:
+
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            values = Array3()
+            vect = Array3()
+
+            cross_section = math.pi * r * r
+
+            # normal vector to the center:
+            vect_moduli = math.sqrt(x * x + y * y)
+
+            if vect_moduli > 0.0:
+                vect[0] = -x / vect_moduli
+                vect[1] = -y / vect_moduli
+                vect[2] = 0.0
+
+            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
+            values[1] = cross_section * alpha_lat * Pressure * vect[1] * 0.70710678
+            values[2] = 0.0
+
+            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
+
+        for node in XBOTCORNER:
+
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            values = Array3()
+            vect = Array3()
+
+            cross_section = math.pi * r * r
+
+            # vector normal al centre:
+            vect_moduli = math.sqrt(x * x + z * z)
+
+            if vect_moduli > 0.0:
+                vect[0] = -x / vect_moduli
+                vect[1] = -y / vect_moduli
+                vect[2] = 0.0
+
+            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
+            values[1] = cross_section * alpha_lat * Pressure * vect[1] * 0.70710678
+            values[2] = 0.0
+
+            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
+
+    def PrepareDataForGraph(self):
+
+        prepare_check = [0,0,0,0]
+        self.total_check = 0
+
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                self.top_mesh_nodes = smp.Nodes
+                prepare_check[0] = 1
+            if smp[IDENTIFIER] == 'BOTTOM':
+                self.bot_mesh_nodes = smp.Nodes
+                prepare_check[1] = 1
+
+        for smp in self.spheres_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                self.top_mesh_nodes = smp.Nodes
+                prepare_check[2] = -1
+
+            if smp[IDENTIFIER] == 'BOTTOM':
+                self.bot_mesh_nodes = smp.Nodes
+                prepare_check[3] = -1
+
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP_BTS':
+                self.top_mesh_nodes_bts = smp.Nodes
+            if smp[IDENTIFIER] == 'BOTTOM_BTS':
+                self.bot_mesh_nodes_bts = smp.Nodes
+
+        for it in range(len(prepare_check)):
+            self.total_check += prepare_check[it]
+
+        if math.fabs(self.total_check) != 2:
+            self.Procedures.KratosPrintWarning(" ERROR in the definition of TOP BOT groups. Both groups are required to be defined, they have to be either on FEM groups or in DEM groups")
+
+    def PrintGraph(self, time):
+
+        if self.graph_counter == self.graph_frequency:
+            self.graph_counter = 0
+            total_stress_q = self.total_stress_mean * 1e-6 - self.ConfinementPressure
+            self.graph_export_1.write(str("%.6g"%self.strain).rjust(13)     + "  " + str("%.6g"%(self.total_stress_mean * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
+            self.graph_export_2.write(str("%.8g"%self.strain).rjust(13)     + "  " + str("%.6g"%(self.total_stress_top  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
+            self.graph_export_3.write(str("%.8g"%self.strain).rjust(13)     + "  " + str("%.6g"%(self.total_stress_bot  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
+            self.graph_export_4.write(str("%.8g"%self.strain).rjust(13)     + "  " + str("%.6g"%(total_stress_q)).rjust(13)                + "  " + str("%.8g"%time).rjust(12) + '\n')
+            self.graph_export_1.flush()
+            self.graph_export_2.flush()
+            self.graph_export_3.flush()
+            self.graph_export_4.flush()
+            if self.time_to_print_bts_graph:
+                self.graph_export_5.write(str("%.8g"%self.strain_bts).rjust(13) + "  " + str("%.6g"%(self.total_stress_bts  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
+                self.graph_export_5.flush()
+        self.graph_counter += 1
+
+    def FinalizeGraphs(self):
+        # Create a copy and renaming
+        absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
+        absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_bts.grf")
+        absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_VOL.grf")
+        for filename in os.listdir("."):
+            if filename.startswith(absolute_path_to_file1):
+                shutil.copy(filename, filename + "COPY")
+                os.rename(filename+"COPY", absolute_path_to_file1 + str(self.initial_time).replace(":", "") + ".grf")
+            if filename.startswith(absolute_path_to_file2):
+                shutil.copy(filename, filename + "COPY")
+                os.rename(filename+"COPY", absolute_path_to_file2 + str(self.initial_time).replace(":", "") + ".grf")
+            if filename.startswith(absolute_path_to_file3):
+                shutil.copy(filename, filename + "COPY")
+                os.rename(filename+"COPY", absolute_path_to_file3 + str(self.initial_time).replace(":", "") + ".grf")
+        self.graph_export_1.close()
+        self.graph_export_2.close()
+        self.graph_export_3.close()
+        self.graph_export_4.close()
+        self.graph_export_5.close()
+
+if __name__ == "__main__":
+
+    with open("ProjectParametersDEM.json", 'r') as parameter_file:
+        parameters = KratosMultiphysics.Parameters(parameter_file.read())
+
+    model = KratosMultiphysics.Model()
+    DecompressedMaterialBTSTest(model, parameters).Run()
```

## KratosMultiphysics/DEMApplication/DEM_material_test_script.py

 * *Ordering differences only*

```diff
@@ -1,879 +1,879 @@
-import math
-import datetime
-import shutil
-import weakref
-import os
-
-from KratosMultiphysics import *
-from KratosMultiphysics.DEMApplication import *
-from KratosMultiphysics.DEMApplication import DEM_procedures as DEM_procedures
-
-class MaterialTest():
-
-    def __init__(self, DEM_parameters, procedures, solver, graphs_path, post_path, spheres_model_part, rigid_face_model_part):
-
-        self.parameters = DEM_parameters
-        self.graphs_path = graphs_path
-        self.post_path = post_path
-        self.spheres_model_part = spheres_model_part
-        self.rigid_face_model_part = rigid_face_model_part
-        self.Procedures = weakref.proxy(procedures)
-        self.solver = weakref.proxy(solver)
-
-        self.top_mesh_nodes = []; self.bot_mesh_nodes = []; self.top_mesh_fem_nodes = []; self.bot_mesh_fem_nodes = []
-
-        self.xtop_area = 0.0
-        self.xbot_area = 0.0
-        self.xlat_area = 0.0
-        self.xtopcorner_area = 0.0
-        self.xbotcorner_area = 0.0
-
-        self.SKIN = list()
-        self.LAT = list()
-        self.BOT = list()
-        self.TOP = list()
-        self.XLAT = list()  # only lat, not the corner ones
-        self.XTOP = list()  # only top, not corner ones...
-        self.XBOT = list()
-        self.XTOPCORNER = list()
-        self.XBOTCORNER = list()
-
-        self.bond_00_05 = list(); self.bond_05_10 = list(); self.bond_10_15 = list(); self.bond_15_20 = list(); self.bond_20_25 = list(); self.bond_25_30 = list(); self.bond_30_35 = list()
-        self.bond_35_40 = list(); self.bond_40_45 = list(); self.bond_45_50 = list(); self.bond_50_55 = list(); self.bond_55_60 = list(); self.bond_60_65 = list(); self.bond_65_70 = list()
-        self.bond_70_75 = list(); self.bond_75_80 = list(); self.bond_80_85 = list(); self.bond_85_90 = list()
-
-        self.sizes = []
-
-        self.sigma_mean_table = []; self.tau_mean_table = []; self.sigma_rel_std_dev_table = []; self.tau_rel_std_dev_table = []; self.sigma_ratio_table = [];
-
-        for i in range(0,18):
-            self.sizes.append(0.0)
-            self.sigma_mean_table.append(0.0)
-            self.tau_mean_table.append(0.0)
-            self.sigma_rel_std_dev_table.append(0.0)
-            self.tau_rel_std_dev_table.append(0.0)
-            self.sigma_ratio_table.append(0.0)
-
-        self.graph_counter = 0; self.renew_pressure = 0; self.Pressure = 0.0; self.pressure_to_apply = 0.0; self.CN_graph_counter = 0
-
-        self.length_correction_factor = 1.0
-
-        self.graph_frequency        = int(self.parameters["GraphExportFreq"].GetDouble()/spheres_model_part.ProcessInfo.GetValue(DELTA_TIME))
-        self.strain = 0.0; self.strain_bts = 0.0; self.volumetric_strain = 0.0; self.radial_strain = 0.0; self.first_time_entry = 1; self.first_time_entry_2 = 1
-        self.total_stress_top = 0.0; self.total_stress_bot = 0.0; self.total_stress_mean = 0.0
-
-        self.LoadingVelocity = 0.0
-        self.MeasuringSurface = 0.0
-
-        # for the graph plotting
-        if "material_test_settings" in DEM_parameters.keys():
-            self.height = self.parameters["material_test_settings"]["SpecimenLength"].GetDouble()
-            self.diameter = self.parameters["material_test_settings"]["SpecimenDiameter"].GetDouble()
-            self.ConfinementPressure = self.parameters["material_test_settings"]["ConfinementPressure"].GetDouble()
-            self.test_type = self.parameters["material_test_settings"]["TestType"].GetString()
-            self.y_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["YCoordinateOfCylinderBottomBase"].GetDouble()
-            self.z_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["ZCoordinateOfCylinderBottomBase"].GetDouble()
-        else:
-            self.height = self.parameters["SpecimenLength"].GetDouble()
-            self.diameter = self.parameters["SpecimenDiameter"].GetDouble()
-            self.ConfinementPressure = self.parameters["ConfinementPressure"].GetDouble()
-            self.test_type = self.parameters["TestType"].GetString()
-            self.y_coordinate_of_cylinder_bottom_base = self.parameters["YCoordinateOfCylinderBottomBase"].GetDouble()
-            self.z_coordinate_of_cylinder_bottom_base = self.parameters["ZCoordinateOfCylinderBottomBase"].GetDouble()
-
-        self.ComputeLoadingVelocity()
-        self.ComputeMeasuringSurface()
-        self.problem_name = self.parameters["problem_name"].GetString()
-        self.initial_time = datetime.datetime.now()
-
-        # self.energy_plot = open(energy_plot, 'w')
-        absolute_path_to_file = os.path.join(graphs_path, self.problem_name + "_Parameter_chart.grf")
-        self.chart = open(absolute_path_to_file, 'w')
-        self.aux = AuxiliaryUtilities()
-        self.PreUtilities = PreUtilities()
-
-    def Initialize(self):
-        self.PrepareTests()
-        self.PrepareTestTriaxialHydro()
-        self.PrepareTestOedometric()
-
-        domain_volume = math.pi * 0.5 * 0.5 * self.diameter * self.diameter * self.height
-        DEM_procedures.GranulometryUtils(domain_volume, self.spheres_model_part)
-
-    def BreakBondUtility(self, spheres_model_part):
-        self.PreUtilities.BreakBondUtility(self.spheres_model_part)
-
-    def Flush(self,a):
-        a.flush()
-
-    def PrepareTestOedometric(self):
-
-        if self.test_type == "Oedometric":
-
-            for node in self.LAT:
-
-                node.SetSolutionStepValue(VELOCITY_X, 0.0)
-                node.SetSolutionStepValue(VELOCITY_Z, 0.0)
-                node.Fix(VELOCITY_X)
-                node.Fix(VELOCITY_Z)
-
-    def PrepareTestTriaxialHydro(self):
-
-        if self.test_type == "Triaxial" or self.test_type == "Hydrostatic":
-            ####### Correction Coefs  TODO 0.25* for cylinder section EXXON
-            self.alpha_top = math.pi*self.diameter*self.diameter*0.25/(self.xtop_area + 0.70710678*self.xtopcorner_area)
-            self.alpha_bot = math.pi*self.diameter*self.diameter*0.25/(self.xbot_area + 0.70710678*self.xbotcorner_area)
-            self.alpha_lat = math.pi*self.diameter*self.height/(self.xlat_area + 0.70710678*self.xtopcorner_area + 0.70710678*self.xbotcorner_area)
-
-    def PrepareTests(self):
-
-        ##Fixing horizontally top and bot
-        if self.test_type != "BTS":
-            for node in self.TOP:
-                node.SetSolutionStepValue(VELOCITY_X, 0.0)
-                node.SetSolutionStepValue(VELOCITY_Z, 0.0)
-                node.Fix(VELOCITY_X)
-                node.Fix(VELOCITY_Z)
-
-            for node in self.BOT:
-                node.SetSolutionStepValue(VELOCITY_X, 0.0)
-                node.SetSolutionStepValue(VELOCITY_Z, 0.0)
-                node.Fix(VELOCITY_X)
-                node.Fix(VELOCITY_Z)
-
-        if self.test_type == "BTS":
-            absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + ".grf")
-            self.bts_export = open(absolute_path_to_file, 'w')
-            self.BtsSkinDetermination()
-
-        elif self.test_type == "Shear":
-            self.BreakBondUtility(self.spheres_model_part)
-            absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
-            absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_graph_top.grf")
-            absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_bot.grf")
-            self.graph_export_1 = open(absolute_path_to_file1, 'w')
-            self.graph_export_2 = open(absolute_path_to_file2, 'w')
-            self.graph_export_3 = open(absolute_path_to_file3, 'w')
-
-        else:
-            absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
-            absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_graph_top.grf")
-            absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_bot.grf")
-            absolute_path_to_file4 = os.path.join(self.graphs_path, self.problem_name + "_graph_strain_vs_q.grf")
-            self.graph_export_1 = open(absolute_path_to_file1, 'w')
-            self.graph_export_2 = open(absolute_path_to_file2, 'w')
-            self.graph_export_3 = open(absolute_path_to_file3, 'w')
-            self.graph_export_4 = open(absolute_path_to_file4, 'w')
-
-            if self.test_type == "Hydrostatic":
-                absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_graph_VOL.grf")
-                self.graph_export_volumetric   = open(absolute_path_to_file, 'w')
-
-            self.Procedures.KratosPrintInfo('Initial Height of the Model: ' + str(self.height)+'\n')
-
-            (self.xtop_area,self.xbot_area,self.xlat_area,self.xtopcorner_area,self.xbotcorner_area,y_top_total,weight_top, y_bot_total, weight_bot) = self.CylinderSkinDetermination()
-
-            initial_height_top = y_top_total/weight_top
-            initial_height_bot = y_bot_total/weight_bot
-
-            inner_initial_height = initial_height_top - initial_height_bot
-            extended_length = self.height + (self.height - inner_initial_height)
-
-            self.length_correction_factor = self.height/extended_length
-
-        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_CN.grf")
-        self.CN_export = open(absolute_path_to_file, 'w')
-
-    def ComputeLoadingVelocity(self):
-        top_vel = bot_vel = 0.0
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                top_vel = smp[LINEAR_VELOCITY_Y]
-            if smp[IDENTIFIER] == 'BOTTOM':
-                bot_vel = smp[LINEAR_VELOCITY_Y]
-        self.LoadingVelocity = top_vel - bot_vel
-
-    def ComputeMeasuringSurface(self):
-        self.MeasuringSurface = 0.25 * math.pi * self.diameter * self.diameter
-
-    def CylinderSkinDetermination(self):
-
-        # Cylinder dimensions
-        h = self.height
-        d = self.diameter
-        y_min = self.y_coordinate_of_cylinder_bottom_base
-
-        eps = 3.0 #2.0
-
-        xlat_area = 0.0
-        xbot_area = 0.0
-        xtop_area = 0.0
-        xbotcorner_area = 0.0
-        xtopcorner_area = 0.0
-
-        y_top_total = 0.0
-        y_bot_total = 0.0
-
-        weight_top = 0.0
-        weight_bot = 0.0
-
-        for element in self.spheres_model_part.Elements:
-
-            element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 0)
-
-            node = element.GetNode(0)
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            cross_section = math.pi * r * r
-
-            if (x * x + z * z) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
-
-                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
-                self.LAT.append(node)
-
-                if (y > y_min + eps * r) and (y < y_min + (h - eps * r)):
-
-                    self.SKIN.append(element)
-                    self.XLAT.append(node)
-
-                    xlat_area = xlat_area + cross_section
-
-            if (y <= y_min + eps * r) or (y >= y_min + (h - eps * r)):
-
-                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
-                self.SKIN.append(element)
-
-                if y <= y_min + eps * r:
-
-                    self.BOT.append(node)
-                    y_bot_total += y*r
-                    weight_bot += r
-
-                elif y >= y_min + (h - eps * r):
-
-                    self.TOP.append(node)
-
-                    y_top_total += y*r
-                    weight_top += r
-
-                if (x * x + z * z) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
-
-                    if y > y_min + h / 2:
-
-                        self.XTOPCORNER.append(node)
-                        xtopcorner_area = xtopcorner_area + cross_section
-
-                    else:
-
-                        self.XBOTCORNER.append(node)
-                        xbotcorner_area = xbotcorner_area + cross_section
-                else:
-
-                    if y <= y_min + eps * r:
-
-                        self.XBOT.append(node)
-                        xbot_area = xbot_area + cross_section
-
-                    elif y >= y_min + (h - eps * r):
-
-                        self.XTOP.append(node)
-                        xtop_area = xtop_area + cross_section
-        #checks:
-        if len(self.XLAT)==0:
-            self.Procedures.KratosPrintWarning("ERROR! in Cylinder Skin Determination - NO LATERAL PARTICLES" + "\n")
-        else:
-            self.Procedures.KratosPrintInfo(str(h) + " * " + str(d) + " cylinder skin determination" + "\n")
-
-        return (xtop_area, xbot_area, xlat_area, xtopcorner_area, xbotcorner_area, y_top_total, weight_top, y_bot_total, weight_bot)
-
-    def BtsSkinDetermination(self):
-
-        # BTS SKIN DETERMINATION
-        # Cylinder dimensions
-        h = self.height
-        d = self.diameter
-        eps = 3.0 #2.0
-        z_min = self.z_coordinate_of_cylinder_bottom_base
-
-        for element in self.spheres_model_part.Elements:
-
-            element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 0)
-            node = element.GetNode(0)
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            if (x * x + y * y) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
-                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
-
-            if (z <= z_min + eps * r) or (z >= z_min + (h - eps * r)):
-                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
-
-        self.Procedures.KratosPrintInfo("Finished computing the skin of the BTS specimen..." + "\n")
-
-    def PrepareDataForGraph(self):
-
-        prepare_check = [0,0,0,0]
-        self.total_check = 0
-
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                self.top_mesh_nodes = smp.Nodes
-                prepare_check[0] = 1
-            if smp[IDENTIFIER] == 'BOTTOM':
-                self.bot_mesh_nodes = smp.Nodes
-                prepare_check[1] = 1
-
-        for smp in self.spheres_model_part.SubModelParts:
-            if smp[IDENTIFIER] == 'TOP':
-                self.top_mesh_nodes = smp.Nodes
-                prepare_check[2] = -1
-
-            if smp[IDENTIFIER] == 'BOTTOM':
-                self.bot_mesh_nodes = smp.Nodes
-                prepare_check[3] = -1
-
-        for it in range(len(prepare_check)):
-
-            self.total_check += prepare_check[it]
-
-        if math.fabs(self.total_check) != 2:
-
-            self.Procedures.KratosPrintWarning(" ERROR in the definition of TOP BOT groups. Both groups are required to be defined, they have to be either on FEM groups or in DEM groups")
-
-    def MeasureForcesAndPressure(self):
-
-        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
-
-        self.strain += -100 * self.length_correction_factor * self.LoadingVelocity * dt / self.height
-
-        if self.test_type =="BTS":
-
-            total_force_bts = 0.0
-
-            for node in self.top_mesh_nodes:
-
-                force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-                total_force_bts += force_node_y
-
-            self.total_stress_bts = 2.0 * total_force_bts / (math.pi * self.height * self.diameter)
-            self.strain_bts += -100 * self.LoadingVelocity * dt / self.diameter
-
-        else:
-
-            if self.test_type =="Hydrostatic":
-                radial_strain = -100*self.MeasureRadialStrain()
-                self.volumetric_strain = self.strain + 2.0*radial_strain
-
-            total_force_top = 0.0
-            total_force_bot = 0.0
-
-            for node in self.top_mesh_nodes:
-                force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-                total_force_top += force_node_y
-
-            self.total_stress_top = total_force_top / self.MeasuringSurface
-
-            for node in self.bot_mesh_nodes:
-                force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-                total_force_bot += force_node_y
-
-            self.total_stress_bot = total_force_bot / self.MeasuringSurface
-
-            self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
-
-            if self.test_type =="Shear":
-                self.strain += dt
-                self.total_stress_top = total_force_top/1.0 # applied force divided by efective shear cylinder area 2*pi*0.0225*0.08
-                self.total_stress_mean = self.total_stress_top
-
-            if (self.test_type == "Triaxial" or self.test_type == "Hydrostatic") and self.ConfinementPressure:
-
-                self.Pressure = min(self.total_stress_mean, self.ConfinementPressure * 1e6)
-
-                if self.test_type == "Hydrostatic":
-                    self.Pressure = self.total_stress_mean
-
-                self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
-
-    def PrintGraph(self, time):
-
-        if self.graph_counter == self.graph_frequency:
-
-            self.graph_counter = 0
-
-            if self.test_type == "BTS":
-                self.bts_export.write(str("%.8g"%time).rjust(12) + "  " + str("%.6g"%(self.total_stress_bts * 1e-6)).rjust(13) + '\n')
-                self.Flush(self.bts_export)
-            else:
-                self.graph_export_1.write(str("%.6g"%self.strain).rjust(13) + "  " + str("%.6g"%(self.total_stress_mean * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
-                self.graph_export_2.write(str("%.8g"%self.strain).rjust(13) + "  " + str("%.6g"%(self.total_stress_top  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
-                self.graph_export_3.write(str("%.8g"%self.strain).rjust(13) + "  " + str("%.6g"%(self.total_stress_bot  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
-                self.Flush(self.graph_export_1)
-                self.Flush(self.graph_export_2)
-                self.Flush(self.graph_export_3)
-
-                if self.test_type != "Shear":
-                    self.graph_export_4.write(str("%.8g"%self.strain).rjust(15) + "  " + str("%.6g"%(self.total_stress_mean * 1e-6 - self.ConfinementPressure)).rjust(13) + '\n')
-                    self.Flush(self.graph_export_4)
-
-                if self.test_type == "Hydrostatic":
-                    self.graph_export_volumetric.write(str("%.8g"%self.volumetric_strain).rjust(12) + "    " + str("%.6g"%(self.total_stress_mean * 1e-6)).rjust(13) + '\n')
-                    self.Flush(self.graph_export_volumetric)
-
-        self.graph_counter += 1
-
-    def PrintChart(self):
-
-        loading_velocity = self.LoadingVelocity
-
-        print ('************DEM VIRTUAL LAB******************'+'\n')
-        print ('Loading velocity: ' + str(loading_velocity) + '\n')
-        print ('Expected maximum deformation: ' + str(-loading_velocity*self.parameters["FinalTime"].GetDouble() /self.height*100) +'%'+'\n'+'\n'  )
-
-        self.chart.write(("***********PARAMETERS*****************")+'\n')
-        self.chart.write( "                                    " +'\n')
-        self.chart.write( "    DENSI  = " + (str(self.spheres_model_part.GetProperties()[1][PARTICLE_DENSITY]).rjust(3))+" Kg/m3     "+'\n')
-        self.chart.write( "    STAFRC = " + (str(self.spheres_model_part.GetProperties()[1][STATIC_FRICTION]).rjust(3))+"           "+'\n')
-        self.chart.write( "    DYNFRC = " + (str(self.spheres_model_part.GetProperties()[1][DYNAMIC_FRICTION]).rjust(3))+"          " +'\n')
-        self.chart.write( "    FRCDEC = " + (str(self.spheres_model_part.GetProperties()[1][FRICTION_DECAY]).rjust(3))+"          " +'\n')
-        self.chart.write( "    YOUNG  = " + (str(self.spheres_model_part.GetProperties()[1][YOUNG_MODULUS]/1e9).rjust(3))+" GPa"+"     " +'\n')
-        self.chart.write( "    POISS  = " + (str(self.spheres_model_part.GetProperties()[1][POISSON_RATIO]).rjust(3))+"           " +'\n')
-        self.chart.write( "    FTS    = " + (str(self.spheres_model_part.GetProperties()[1][CONTACT_SIGMA_MIN]).rjust(3))+" Pa        " +'\n')
-        self.chart.write( "    LCS1   = " + (str(self.spheres_model_part.GetProperties()[1][SLOPE_LIMIT_COEFF_C1]).rjust(3))+" Pa       " +'\n')
-        self.chart.write( "    LCS2   = " + (str(self.spheres_model_part.GetProperties()[1][SLOPE_LIMIT_COEFF_C2]).rjust(3))+" Pa       " +'\n')
-        self.chart.write( "    LCS3   = " + (str(self.spheres_model_part.GetProperties()[1][SLOPE_LIMIT_COEFF_C3]).rjust(3))+" Pa       " +'\n')
-        self.chart.write( "    YRC1   = " + (str(self.spheres_model_part.GetProperties()[1][SLOPE_FRACTION_N1]).rjust(3))+"           " +'\n')
-        self.chart.write( "    YRC2   = " + (str(self.spheres_model_part.GetProperties()[1][SLOPE_FRACTION_N2]).rjust(3))+"           " +'\n')
-        self.chart.write( "    YRC3   = " + (str(self.spheres_model_part.GetProperties()[1][SLOPE_FRACTION_N3]).rjust(3))+"           " +'\n')
-        self.chart.write( "    FSS    = " + (str(self.spheres_model_part.GetProperties()[1][CONTACT_TAU_ZERO]).rjust(3))+" Pa       " +'\n')
-        self.chart.write( "    YEP    = " + (str(self.spheres_model_part.GetProperties()[1][YOUNG_MODULUS_PLASTIC]/1e9).rjust(3))+" GPa"+"     " +'\n')
-        self.chart.write( "    YIELD  = " + (str(self.spheres_model_part.GetProperties()[1][PLASTIC_YIELD_STRESS]).rjust(3))+" Pa       " +'\n')
-        self.chart.write( "    EDR    = " + (str(self.spheres_model_part.GetProperties()[1][DAMAGE_FACTOR]).rjust(3))+"           " +'\n')
-        self.chart.write( "    SEC    = " + (str(self.spheres_model_part.GetProperties()[1][SHEAR_ENERGY_COEF]).rjust(3))+"           " +'\n')
-        self.chart.write( "                                    " +'\n')
-        self.chart.write( "**************************************" +'\n')
-        self.chart.close()
-
-        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_Parameter_chart.grf")
-        data_extract_for_print = open(absolute_path_to_file,"r")
-
-        for line in data_extract_for_print.readlines():
-            self.Procedures.KratosPrintInfo(line)
-        data_extract_for_print.close()
-
-    def FinalizeGraphs(self):
-
-        #Create a copy and renaming
-        absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
-        absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_bts.grf")
-        absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_VOL.grf")
-        for filename in os.listdir("."):
-            if filename.startswith(absolute_path_to_file1):
-                shutil.copy(filename, filename+"COPY")
-                os.rename(filename+"COPY", absolute_path_to_file1 + str(self.initial_time).replace(":", "") + ".grf")
-            if filename.startswith(absolute_path_to_file2):
-                shutil.copy(filename, filename+"COPY")
-                os.rename(filename+"COPY", absolute_path_to_file2 + str(self.initial_time).replace(":", "") + ".grf")
-            if filename.startswith(absolute_path_to_file3):
-                shutil.copy(filename, filename+"COPY")
-                os.rename(filename+"COPY", absolute_path_to_file3 + str(self.initial_time).replace(":", "") + ".grf")
-
-        if self.test_type == "BTS":
-            self.bts_export.close()
-        else:
-            self.graph_export_1.close()
-            self.graph_export_2.close()
-            self.graph_export_3.close()
-
-            if self.test_type != "Shear":
-                self.graph_export_4.close()
-
-            if self.test_type == "Hydrostatic":
-                self.graph_export_volumetric.close()
-
-    def OrientationStudy(self,contact_model_part,step):
-
-        absolute_path_to_file = os.path.join(self.graphs_path, "OrientationChart_"+str(step))
-        OrientationChart = open(absolute_path_to_file, 'w')
-        counter = 1
-
-        for element in contact_model_part.Elements:
-            u1 = element.GetNode(1).X - element.GetNode(0).X
-            u2 = element.GetNode(1).Y - element.GetNode(0).Y
-            u3 = element.GetNode(1).Z - element.GetNode(0).Z
-
-            alpha = abs(math.asin(abs(u2)/math.sqrt((u1*u1)+(u2*u2)+(u3*u3))))
-
-            alpha_deg = alpha/math.pi*180
-
-            element.SetValue(CONTACT_ORIENTATION,alpha_deg)
-
-            sigma = element.GetValue(CONTACT_SIGMA)
-
-            OrientationChart.write(str(counter)+"    "+str(sigma/(self.total_stress_mean))+'\n')
-            counter += 1
-
-            if alpha_deg >= 0.0 and alpha_deg < 5.0:
-                self.bond_00_05.append(element)
-
-            if alpha_deg >= 5.0 and alpha_deg < 10.0:
-                self.bond_05_10.append(element)
-
-            if alpha_deg >= 10.0 and alpha_deg < 15.0:
-                self.bond_10_15.append(element)
-
-            if alpha_deg >= 15.0 and alpha_deg < 20.0:
-                self.bond_15_20.append(element)
-
-            if alpha_deg >= 20.0 and alpha_deg < 25.0:
-                self.bond_20_25.append(element)
-
-            if alpha_deg >= 25.0 and alpha_deg < 30.0:
-                self.bond_25_30.append(element)
-
-            if alpha_deg >= 30.0 and alpha_deg < 35.0:
-                self.bond_30_35.append(element)
-
-            if alpha_deg >= 35.0 and alpha_deg < 40.0:
-                self.bond_35_40.append(element)
-
-            if alpha_deg >= 40.0 and alpha_deg < 45.0:
-                self.bond_40_45.append(element)
-
-            if alpha_deg >= 45.0 and alpha_deg < 50.0:
-                self.bond_45_50.append(element)
-
-            if alpha_deg >= 50.0 and alpha_deg < 55.0:
-                self.bond_50_55.append(element)
-
-            if alpha_deg >= 55.0 and alpha_deg < 60.0:
-                self.bond_55_60.append(element)
-
-            if alpha_deg >= 60.0 and alpha_deg < 65.0:
-                self.bond_60_65.append(element)
-
-            if alpha_deg >= 65.0 and alpha_deg < 70.0:
-                self.bond_65_70.append(element)
-
-            if alpha_deg >= 70.0 and alpha_deg < 75.0:
-                self.bond_70_75.append(element)
-
-            if alpha_deg >= 75.0 and alpha_deg < 80.0:
-                self.bond_75_80.append(element)
-
-            if alpha_deg >= 80.0 and alpha_deg < 85.0:
-                self.bond_80_85.append(element)
-
-            if alpha_deg >= 85.0 and alpha_deg < 90.0:
-                self.bond_85_90.append(element)
-
-        ii=0
-        for item in [self.bond_00_05, self.bond_05_10, self.bond_10_15, self.bond_15_20, self.bond_20_25, self.bond_25_30, self.bond_30_35, self.bond_35_40, self.bond_40_45,  self.bond_45_50, self.bond_50_55, self.bond_55_60, self.bond_60_65, self.bond_65_70, self.bond_70_75, self.bond_75_80, self.bond_80_85, self.bond_85_90]:
-
-            self.sizes[ii] = len(item)
-
-            i = 0.0
-            sigma_sum =0.0
-            tau_sum = 0.0
-
-            sigma_total_sum_squared = 0
-            tau_total_sum_squared = 0.0
-
-            volume = 0.0
-            area = 0.0
-
-            for element in item:
-                sigma_normal = element.GetValue(CONTACT_SIGMA)
-                sigma_tau = element.GetValue(CONTACT_TAU)
-
-                sigma_sum += sigma_normal
-                tau_sum += sigma_tau
-
-                sigma_partial_sum_squared = sigma_normal ** 2.0
-                sigma_total_sum_squared += sigma_partial_sum_squared
-
-                tau_partial_sum_squared = sigma_tau ** 2.0
-                tau_total_sum_squared += tau_partial_sum_squared
-
-                i += 1.0
-
-            sigma_mean = sigma_sum / len(item)
-            sigma_var = sigma_total_sum_squared / len(item) - sigma_mean ** 2.0
-
-            sigma_std_dev = 0.0
-
-            if abs(sigma_var) > 1e-9:
-                std_dev = sigma_var ** 0.5
-
-            sigma_rel_std_dev = sigma_std_dev / sigma_mean
-
-            tau_mean = tau_sum/ len(item)
-            tau_var = tau_total_sum_squared / len(item) - tau_mean ** 2.0
-
-            tau_std_dev = 0.0
-
-            if abs(tau_var) > 1e-9:
-                tau_std_dev = tau_var ** 0.5
-
-            tau_rel_std_dev = tau_std_dev / tau_mean
-
-            self.sigma_mean_table[ii] = sigma_mean
-            self.sigma_rel_std_dev_table[ii] = sigma_rel_std_dev
-            self.tau_mean_table[ii] = tau_mean
-            self.tau_rel_std_dev_table[ii] = tau_rel_std_dev
-            self.sigma_ratio_table[ii]=sigma_mean/(self.total_stress_mean)
-            ii+=1
-
-        self.Procedures.KratosPrintInfo(self.sigma_ratio_table)
-        OrientationChart.close()
-
-    def ApplyLateralPressure(self, Pressure, XLAT, XBOT, XTOP, XBOTCORNER, XTOPCORNER, alpha_top, alpha_bot, alpha_lat):
-
-        for node in XLAT:
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            values = Array3()
-            vect = Array3()
-
-            cross_section = math.pi * r * r
-
-            # normal vector to the center:
-            vect_moduli = math.sqrt(x * x + z * z)
-
-            if vect_moduli > 0.0:
-                vect[0] = -x / vect_moduli
-                vect[1] = 0
-                vect[2] = -z / vect_moduli
-
-            values[0] = cross_section * alpha_lat * Pressure * vect[0]
-            values[1] = 0.0
-            values[2] = cross_section * alpha_lat * Pressure * vect[2]
-
-            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
-
-        for node in XTOPCORNER:
-
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            values = Array3()
-            vect = Array3()
-
-            cross_section = math.pi * r * r
-
-            # normal vector to the center:
-            vect_moduli = math.sqrt(x * x + z * z)
-
-            if vect_moduli > 0.0:
-                vect[0] = -x / vect_moduli
-                vect[1] = 0
-                vect[2] = -z / vect_moduli
-
-            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
-            values[1] = 0.0
-            values[2] = cross_section * alpha_lat * Pressure * vect[2] * 0.70710678
-
-            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
-
-        for node in XBOTCORNER:
-
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            y = node.Y
-            z = node.Z
-
-            values = Array3()
-            vect = Array3()
-
-            cross_section = math.pi * r * r
-
-            # vector normal al centre:
-            vect_moduli = math.sqrt(x * x + z * z)
-
-            if vect_moduli > 0.0:
-                vect[0] = -x / vect_moduli
-                vect[1] = 0
-                vect[2] = -z / vect_moduli
-
-            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
-            values[1] = 0.0
-            values[2] = cross_section * alpha_lat * Pressure * vect[2] * 0.70710678
-
-            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
-
-    def MeasureRadialStrain(self):
-
-        mean_radial_strain = 0.0
-        radial_strain = 0.0
-        weight = 0.0
-
-        for node in self.XLAT:
-
-            r = node.GetSolutionStepValue(RADIUS)
-            x = node.X
-            z = node.Z
-
-            x0 = node.X0
-            z0 = node.Z0
-
-            dist_initial = math.sqrt(x0 * x0 + z0 * z0)
-            dist_now = math.sqrt(x * x + z * z)
-            node_radial_strain = (dist_now - dist_initial) / dist_initial
-            mean_radial_strain += node_radial_strain
-
-            weight += 1.0
-
-        radial_strain = mean_radial_strain/weight
-
-        return radial_strain
-
-    def PoissonMeasure(self):
-
-        self.Procedures.KratosPrintWarning("Not Working now")
-
-        #left_nodes = list()
-        #right_nodes = list()
-
-        #xleft_weight  = 0.0
-        #xright_weight  = 0.0
-
-        #left_counter = 0.0
-        #right_counter = 0.0
-
-        #if(self.parameters.PoissonMeasure == "ON"):
-
-            #for node in spheres_model_part.Nodes:
-
-                #if (node.GetSolutionStepValue(GROUP_ID)==4):
-
-                #left_nodes.append(node)
-                #xleft_weight = +(node.X0 - node.GetSolutionStepValue(RADIUS))*node.GetSolutionStepValue(RADIUS)
-                #left_counter = +node.GetSolutionStepValue(RADIUS)
-
-                #elif(node.GetSolutionStepValue(GROUP_ID)==8):
-
-                #right_nodes.append(node)
-                #xright_weight = +(node.X + node.GetSolutionStepValue(RADIUS))*node.GetSolutionStepValue(RADIUS)
-                #right_counter = +node.GetSolutionStepValue(RADIUS)
-
-            #width_ini = xright_weight/right_counter - xleft_weight/left_counter
-
-    ##################################POISSON##################################
-
-        #if(self.parameters.PoissonMeasure == "ON"):
-
-        #xleft_weight  = 0.0
-        #xright_weight  = 0.0
-
-        #left_counter = 0.0
-        #right_counter = 0.0
-
-        #for node in left_nodes:
-
-            #xleft_weight = +(node.X - node.GetSolutionStepValue(RADIUS))*node.GetSolutionStepValue(RADIUS)
-            #left_counter = +node.GetSolutionStepValue(RADIUS)
-
-        #for node in right_nodes:
-
-            #xright_weight = +(node.X + node.GetSolutionStepValue(RADIUS))*node.GetSolutionStepValue(RADIUS)
-            #right_counter = +node.GetSolutionStepValue(RADIUS)
-
-        #width_now = xright_weight/right_counter - xleft_weight/left_counter
-        #measured_poisson =  ((width_now-width_ini)/width_ini)/strain
-
-        #graph_export_poisson.write(str(strain)+"  "+str(measured_poisson)+'\n')
-
-    #-------------------------------------------------------------------------------------#
-
-    def GenerateGraphics(self):
-
-        ## PROBLEM DATA
-        area = 0.000001 ### 1mm2
-        grad_p = 1 ## Pa/m
-
-        ## Read Data
-        data_file_name0 = "test.grf"
-        data0 = loadtxt(data_file_name0)
-        strain = array(data0[:,0])
-        stress = array(data0[:,1])
-
-        data_file_name1 = "test.grf"
-        data1 = loadtxt(data_file_name1)
-        strain1 = array(data1[:,0])
-        stress1 = array(data1[:,1])
-
-        data_file_name2 = "test.grf"
-        data2 = loadtxt(data_file_name2)
-        strain2 = array(data2[:,0])
-        stress2 = array(data2[:,1])
-
-        # setting to be changed#############################3
-        set_mode = 'extralarge'  # large; publishable; medium
-        legend_position = 'lower left'
-
-        ##graph_name = ""
-        x_name = 'Axial Strain (%)'
-        y_name = 'Stress (MPa) - Load-axis'
-        ####################################################################
-        ####################################################################
-
-        clf()
-        plot_settings.set_mode(set_mode)
-        #plt.semilogx()
-        plot(strain, stress, 'k:s', strain1, stress1, 'r--v', strain2, stress2, 'b-.o',linewidth=1 )
-        legend(('test', 'test'), legend_position, numpoints=1,)
-        ##       bbox_to_anchor=(0., 1.02, 1., .102), loc=3, ncol=2, mode="expand", borderaxespad=0.)
-        grid(True)
-        #insert name ######################################################
-        savedname = "stress_graph"
-        ####################################################################
-        ##graphtitle = graph_name
-        ##title(graphtitle)
-        xlabel(x_name)
-        ylabel(y_name)
-        ##xlim(0.0, 1.0)
-        ##ylim(0.0, 1.0)
-        ##savefig(savedname + '.eps')
-        savefig(savedname + '.png')
-
-        ####################################################################
-        ####################################################################
-
-        clf()
-        plot_settings.set_mode(set_mode)
-        #plt.semilogx()
-        plot(strain, stress, 'k:s', strain1, stress1, 'r--v',linewidth=2 )
-        legend(( 'IFT variation', 'Viscosity variation'), legend_position, numpoints=1,)
-        ##       bbox_to_anchor=(0., 1.02, 1., .102), loc=3, ncol=2, mode="expand", borderaxespad=0.)
-        grid(True)
-        #insert name ######################################################
-        savedname = "stress_graph2"
-        ####################################################################
-        ##graphtitle = graph_name
-        ##title(graphtitle)
-        xlabel(x_name)
-        ylabel(y_name)
-        ##xlim(0.0, 1.0)
-        ##ylim(0.0, 1.0)
-        ##savefig(savedname + '.eps')
-        savefig(savedname + '.png')
-
-class PreUtils():
-
-    def __init__(self, spheres_model_part):
-
-        self.spheres_model_part = spheres_model_part
-        self.PreUtilities = PreUtilities()
-
-    def BreakBondUtility(self, spheres_model_part):
-        self.PreUtilities.BreakBondUtility(self.spheres_model_part)
+import math
+import datetime
+import shutil
+import weakref
+import os
+
+from KratosMultiphysics import *
+from KratosMultiphysics.DEMApplication import *
+from KratosMultiphysics.DEMApplication import DEM_procedures as DEM_procedures
+
+class MaterialTest():
+
+    def __init__(self, DEM_parameters, procedures, solver, graphs_path, post_path, spheres_model_part, rigid_face_model_part):
+
+        self.parameters = DEM_parameters
+        self.graphs_path = graphs_path
+        self.post_path = post_path
+        self.spheres_model_part = spheres_model_part
+        self.rigid_face_model_part = rigid_face_model_part
+        self.Procedures = weakref.proxy(procedures)
+        self.solver = weakref.proxy(solver)
+
+        self.top_mesh_nodes = []; self.bot_mesh_nodes = []; self.top_mesh_fem_nodes = []; self.bot_mesh_fem_nodes = []
+
+        self.xtop_area = 0.0
+        self.xbot_area = 0.0
+        self.xlat_area = 0.0
+        self.xtopcorner_area = 0.0
+        self.xbotcorner_area = 0.0
+
+        self.SKIN = list()
+        self.LAT = list()
+        self.BOT = list()
+        self.TOP = list()
+        self.XLAT = list()  # only lat, not the corner ones
+        self.XTOP = list()  # only top, not corner ones...
+        self.XBOT = list()
+        self.XTOPCORNER = list()
+        self.XBOTCORNER = list()
+
+        self.bond_00_05 = list(); self.bond_05_10 = list(); self.bond_10_15 = list(); self.bond_15_20 = list(); self.bond_20_25 = list(); self.bond_25_30 = list(); self.bond_30_35 = list()
+        self.bond_35_40 = list(); self.bond_40_45 = list(); self.bond_45_50 = list(); self.bond_50_55 = list(); self.bond_55_60 = list(); self.bond_60_65 = list(); self.bond_65_70 = list()
+        self.bond_70_75 = list(); self.bond_75_80 = list(); self.bond_80_85 = list(); self.bond_85_90 = list()
+
+        self.sizes = []
+
+        self.sigma_mean_table = []; self.tau_mean_table = []; self.sigma_rel_std_dev_table = []; self.tau_rel_std_dev_table = []; self.sigma_ratio_table = [];
+
+        for i in range(0,18):
+            self.sizes.append(0.0)
+            self.sigma_mean_table.append(0.0)
+            self.tau_mean_table.append(0.0)
+            self.sigma_rel_std_dev_table.append(0.0)
+            self.tau_rel_std_dev_table.append(0.0)
+            self.sigma_ratio_table.append(0.0)
+
+        self.graph_counter = 0; self.renew_pressure = 0; self.Pressure = 0.0; self.pressure_to_apply = 0.0; self.CN_graph_counter = 0
+
+        self.length_correction_factor = 1.0
+
+        self.graph_frequency        = int(self.parameters["GraphExportFreq"].GetDouble()/spheres_model_part.ProcessInfo.GetValue(DELTA_TIME))
+        self.strain = 0.0; self.strain_bts = 0.0; self.volumetric_strain = 0.0; self.radial_strain = 0.0; self.first_time_entry = 1; self.first_time_entry_2 = 1
+        self.total_stress_top = 0.0; self.total_stress_bot = 0.0; self.total_stress_mean = 0.0
+
+        self.LoadingVelocity = 0.0
+        self.MeasuringSurface = 0.0
+
+        # for the graph plotting
+        if "material_test_settings" in DEM_parameters.keys():
+            self.height = self.parameters["material_test_settings"]["SpecimenLength"].GetDouble()
+            self.diameter = self.parameters["material_test_settings"]["SpecimenDiameter"].GetDouble()
+            self.ConfinementPressure = self.parameters["material_test_settings"]["ConfinementPressure"].GetDouble()
+            self.test_type = self.parameters["material_test_settings"]["TestType"].GetString()
+            self.y_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["YCoordinateOfCylinderBottomBase"].GetDouble()
+            self.z_coordinate_of_cylinder_bottom_base = self.parameters["material_test_settings"]["ZCoordinateOfCylinderBottomBase"].GetDouble()
+        else:
+            self.height = self.parameters["SpecimenLength"].GetDouble()
+            self.diameter = self.parameters["SpecimenDiameter"].GetDouble()
+            self.ConfinementPressure = self.parameters["ConfinementPressure"].GetDouble()
+            self.test_type = self.parameters["TestType"].GetString()
+            self.y_coordinate_of_cylinder_bottom_base = self.parameters["YCoordinateOfCylinderBottomBase"].GetDouble()
+            self.z_coordinate_of_cylinder_bottom_base = self.parameters["ZCoordinateOfCylinderBottomBase"].GetDouble()
+
+        self.ComputeLoadingVelocity()
+        self.ComputeMeasuringSurface()
+        self.problem_name = self.parameters["problem_name"].GetString()
+        self.initial_time = datetime.datetime.now()
+
+        # self.energy_plot = open(energy_plot, 'w')
+        absolute_path_to_file = os.path.join(graphs_path, self.problem_name + "_Parameter_chart.grf")
+        self.chart = open(absolute_path_to_file, 'w')
+        self.aux = AuxiliaryUtilities()
+        self.PreUtilities = PreUtilities()
+
+    def Initialize(self):
+        self.PrepareTests()
+        self.PrepareTestTriaxialHydro()
+        self.PrepareTestOedometric()
+
+        domain_volume = math.pi * 0.5 * 0.5 * self.diameter * self.diameter * self.height
+        DEM_procedures.GranulometryUtils(domain_volume, self.spheres_model_part)
+
+    def BreakBondUtility(self, spheres_model_part):
+        self.PreUtilities.BreakBondUtility(self.spheres_model_part)
+
+    def Flush(self,a):
+        a.flush()
+
+    def PrepareTestOedometric(self):
+
+        if self.test_type == "Oedometric":
+
+            for node in self.LAT:
+
+                node.SetSolutionStepValue(VELOCITY_X, 0.0)
+                node.SetSolutionStepValue(VELOCITY_Z, 0.0)
+                node.Fix(VELOCITY_X)
+                node.Fix(VELOCITY_Z)
+
+    def PrepareTestTriaxialHydro(self):
+
+        if self.test_type == "Triaxial" or self.test_type == "Hydrostatic":
+            ####### Correction Coefs  TODO 0.25* for cylinder section EXXON
+            self.alpha_top = math.pi*self.diameter*self.diameter*0.25/(self.xtop_area + 0.70710678*self.xtopcorner_area)
+            self.alpha_bot = math.pi*self.diameter*self.diameter*0.25/(self.xbot_area + 0.70710678*self.xbotcorner_area)
+            self.alpha_lat = math.pi*self.diameter*self.height/(self.xlat_area + 0.70710678*self.xtopcorner_area + 0.70710678*self.xbotcorner_area)
+
+    def PrepareTests(self):
+
+        ##Fixing horizontally top and bot
+        if self.test_type != "BTS":
+            for node in self.TOP:
+                node.SetSolutionStepValue(VELOCITY_X, 0.0)
+                node.SetSolutionStepValue(VELOCITY_Z, 0.0)
+                node.Fix(VELOCITY_X)
+                node.Fix(VELOCITY_Z)
+
+            for node in self.BOT:
+                node.SetSolutionStepValue(VELOCITY_X, 0.0)
+                node.SetSolutionStepValue(VELOCITY_Z, 0.0)
+                node.Fix(VELOCITY_X)
+                node.Fix(VELOCITY_Z)
+
+        if self.test_type == "BTS":
+            absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + ".grf")
+            self.bts_export = open(absolute_path_to_file, 'w')
+            self.BtsSkinDetermination()
+
+        elif self.test_type == "Shear":
+            self.BreakBondUtility(self.spheres_model_part)
+            absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
+            absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_graph_top.grf")
+            absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_bot.grf")
+            self.graph_export_1 = open(absolute_path_to_file1, 'w')
+            self.graph_export_2 = open(absolute_path_to_file2, 'w')
+            self.graph_export_3 = open(absolute_path_to_file3, 'w')
+
+        else:
+            absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
+            absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_graph_top.grf")
+            absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_bot.grf")
+            absolute_path_to_file4 = os.path.join(self.graphs_path, self.problem_name + "_graph_strain_vs_q.grf")
+            self.graph_export_1 = open(absolute_path_to_file1, 'w')
+            self.graph_export_2 = open(absolute_path_to_file2, 'w')
+            self.graph_export_3 = open(absolute_path_to_file3, 'w')
+            self.graph_export_4 = open(absolute_path_to_file4, 'w')
+
+            if self.test_type == "Hydrostatic":
+                absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_graph_VOL.grf")
+                self.graph_export_volumetric   = open(absolute_path_to_file, 'w')
+
+            self.Procedures.KratosPrintInfo('Initial Height of the Model: ' + str(self.height)+'\n')
+
+            (self.xtop_area,self.xbot_area,self.xlat_area,self.xtopcorner_area,self.xbotcorner_area,y_top_total,weight_top, y_bot_total, weight_bot) = self.CylinderSkinDetermination()
+
+            initial_height_top = y_top_total/weight_top
+            initial_height_bot = y_bot_total/weight_bot
+
+            inner_initial_height = initial_height_top - initial_height_bot
+            extended_length = self.height + (self.height - inner_initial_height)
+
+            self.length_correction_factor = self.height/extended_length
+
+        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_CN.grf")
+        self.CN_export = open(absolute_path_to_file, 'w')
+
+    def ComputeLoadingVelocity(self):
+        top_vel = bot_vel = 0.0
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                top_vel = smp[LINEAR_VELOCITY_Y]
+            if smp[IDENTIFIER] == 'BOTTOM':
+                bot_vel = smp[LINEAR_VELOCITY_Y]
+        self.LoadingVelocity = top_vel - bot_vel
+
+    def ComputeMeasuringSurface(self):
+        self.MeasuringSurface = 0.25 * math.pi * self.diameter * self.diameter
+
+    def CylinderSkinDetermination(self):
+
+        # Cylinder dimensions
+        h = self.height
+        d = self.diameter
+        y_min = self.y_coordinate_of_cylinder_bottom_base
+
+        eps = 3.0 #2.0
+
+        xlat_area = 0.0
+        xbot_area = 0.0
+        xtop_area = 0.0
+        xbotcorner_area = 0.0
+        xtopcorner_area = 0.0
+
+        y_top_total = 0.0
+        y_bot_total = 0.0
+
+        weight_top = 0.0
+        weight_bot = 0.0
+
+        for element in self.spheres_model_part.Elements:
+
+            element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 0)
+
+            node = element.GetNode(0)
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            cross_section = math.pi * r * r
+
+            if (x * x + z * z) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
+
+                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
+                self.LAT.append(node)
+
+                if (y > y_min + eps * r) and (y < y_min + (h - eps * r)):
+
+                    self.SKIN.append(element)
+                    self.XLAT.append(node)
+
+                    xlat_area = xlat_area + cross_section
+
+            if (y <= y_min + eps * r) or (y >= y_min + (h - eps * r)):
+
+                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
+                self.SKIN.append(element)
+
+                if y <= y_min + eps * r:
+
+                    self.BOT.append(node)
+                    y_bot_total += y*r
+                    weight_bot += r
+
+                elif y >= y_min + (h - eps * r):
+
+                    self.TOP.append(node)
+
+                    y_top_total += y*r
+                    weight_top += r
+
+                if (x * x + z * z) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
+
+                    if y > y_min + h / 2:
+
+                        self.XTOPCORNER.append(node)
+                        xtopcorner_area = xtopcorner_area + cross_section
+
+                    else:
+
+                        self.XBOTCORNER.append(node)
+                        xbotcorner_area = xbotcorner_area + cross_section
+                else:
+
+                    if y <= y_min + eps * r:
+
+                        self.XBOT.append(node)
+                        xbot_area = xbot_area + cross_section
+
+                    elif y >= y_min + (h - eps * r):
+
+                        self.XTOP.append(node)
+                        xtop_area = xtop_area + cross_section
+        #checks:
+        if len(self.XLAT)==0:
+            self.Procedures.KratosPrintWarning("ERROR! in Cylinder Skin Determination - NO LATERAL PARTICLES" + "\n")
+        else:
+            self.Procedures.KratosPrintInfo(str(h) + " * " + str(d) + " cylinder skin determination" + "\n")
+
+        return (xtop_area, xbot_area, xlat_area, xtopcorner_area, xbotcorner_area, y_top_total, weight_top, y_bot_total, weight_bot)
+
+    def BtsSkinDetermination(self):
+
+        # BTS SKIN DETERMINATION
+        # Cylinder dimensions
+        h = self.height
+        d = self.diameter
+        eps = 3.0 #2.0
+        z_min = self.z_coordinate_of_cylinder_bottom_base
+
+        for element in self.spheres_model_part.Elements:
+
+            element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 0)
+            node = element.GetNode(0)
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            if (x * x + y * y) >= ((0.5 * d - eps * r) * (0.5 * d - eps * r)):
+                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
+
+            if (z <= z_min + eps * r) or (z >= z_min + (h - eps * r)):
+                element.GetNode(0).SetSolutionStepValue(SKIN_SPHERE, 1)
+
+        self.Procedures.KratosPrintInfo("Finished computing the skin of the BTS specimen..." + "\n")
+
+    def PrepareDataForGraph(self):
+
+        prepare_check = [0,0,0,0]
+        self.total_check = 0
+
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                self.top_mesh_nodes = smp.Nodes
+                prepare_check[0] = 1
+            if smp[IDENTIFIER] == 'BOTTOM':
+                self.bot_mesh_nodes = smp.Nodes
+                prepare_check[1] = 1
+
+        for smp in self.spheres_model_part.SubModelParts:
+            if smp[IDENTIFIER] == 'TOP':
+                self.top_mesh_nodes = smp.Nodes
+                prepare_check[2] = -1
+
+            if smp[IDENTIFIER] == 'BOTTOM':
+                self.bot_mesh_nodes = smp.Nodes
+                prepare_check[3] = -1
+
+        for it in range(len(prepare_check)):
+
+            self.total_check += prepare_check[it]
+
+        if math.fabs(self.total_check) != 2:
+
+            self.Procedures.KratosPrintWarning(" ERROR in the definition of TOP BOT groups. Both groups are required to be defined, they have to be either on FEM groups or in DEM groups")
+
+    def MeasureForcesAndPressure(self):
+
+        dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
+
+        self.strain += -100 * self.length_correction_factor * self.LoadingVelocity * dt / self.height
+
+        if self.test_type =="BTS":
+
+            total_force_bts = 0.0
+
+            for node in self.top_mesh_nodes:
+
+                force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+                total_force_bts += force_node_y
+
+            self.total_stress_bts = 2.0 * total_force_bts / (math.pi * self.height * self.diameter)
+            self.strain_bts += -100 * self.LoadingVelocity * dt / self.diameter
+
+        else:
+
+            if self.test_type =="Hydrostatic":
+                radial_strain = -100*self.MeasureRadialStrain()
+                self.volumetric_strain = self.strain + 2.0*radial_strain
+
+            total_force_top = 0.0
+            total_force_bot = 0.0
+
+            for node in self.top_mesh_nodes:
+                force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+                total_force_top += force_node_y
+
+            self.total_stress_top = total_force_top / self.MeasuringSurface
+
+            for node in self.bot_mesh_nodes:
+                force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+                total_force_bot += force_node_y
+
+            self.total_stress_bot = total_force_bot / self.MeasuringSurface
+
+            self.total_stress_mean = 0.5 * (self.total_stress_bot + self.total_stress_top)
+
+            if self.test_type =="Shear":
+                self.strain += dt
+                self.total_stress_top = total_force_top/1.0 # applied force divided by efective shear cylinder area 2*pi*0.0225*0.08
+                self.total_stress_mean = self.total_stress_top
+
+            if (self.test_type == "Triaxial" or self.test_type == "Hydrostatic") and self.ConfinementPressure:
+
+                self.Pressure = min(self.total_stress_mean, self.ConfinementPressure * 1e6)
+
+                if self.test_type == "Hydrostatic":
+                    self.Pressure = self.total_stress_mean
+
+                self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
+
+    def PrintGraph(self, time):
+
+        if self.graph_counter == self.graph_frequency:
+
+            self.graph_counter = 0
+
+            if self.test_type == "BTS":
+                self.bts_export.write(str("%.8g"%time).rjust(12) + "  " + str("%.6g"%(self.total_stress_bts * 1e-6)).rjust(13) + '\n')
+                self.Flush(self.bts_export)
+            else:
+                self.graph_export_1.write(str("%.6g"%self.strain).rjust(13) + "  " + str("%.6g"%(self.total_stress_mean * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
+                self.graph_export_2.write(str("%.8g"%self.strain).rjust(13) + "  " + str("%.6g"%(self.total_stress_top  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
+                self.graph_export_3.write(str("%.8g"%self.strain).rjust(13) + "  " + str("%.6g"%(self.total_stress_bot  * 1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12) + '\n')
+                self.Flush(self.graph_export_1)
+                self.Flush(self.graph_export_2)
+                self.Flush(self.graph_export_3)
+
+                if self.test_type != "Shear":
+                    self.graph_export_4.write(str("%.8g"%self.strain).rjust(15) + "  " + str("%.6g"%(self.total_stress_mean * 1e-6 - self.ConfinementPressure)).rjust(13) + '\n')
+                    self.Flush(self.graph_export_4)
+
+                if self.test_type == "Hydrostatic":
+                    self.graph_export_volumetric.write(str("%.8g"%self.volumetric_strain).rjust(12) + "    " + str("%.6g"%(self.total_stress_mean * 1e-6)).rjust(13) + '\n')
+                    self.Flush(self.graph_export_volumetric)
+
+        self.graph_counter += 1
+
+    def PrintChart(self):
+
+        loading_velocity = self.LoadingVelocity
+
+        print ('************DEM VIRTUAL LAB******************'+'\n')
+        print ('Loading velocity: ' + str(loading_velocity) + '\n')
+        print ('Expected maximum deformation: ' + str(-loading_velocity*self.parameters["FinalTime"].GetDouble() /self.height*100) +'%'+'\n'+'\n'  )
+
+        self.chart.write(("***********PARAMETERS*****************")+'\n')
+        self.chart.write( "                                    " +'\n')
+        self.chart.write( "    DENSI  = " + (str(self.spheres_model_part.GetProperties()[1][PARTICLE_DENSITY]).rjust(3))+" Kg/m3     "+'\n')
+        self.chart.write( "    STAFRC = " + (str(self.spheres_model_part.GetProperties()[1][STATIC_FRICTION]).rjust(3))+"           "+'\n')
+        self.chart.write( "    DYNFRC = " + (str(self.spheres_model_part.GetProperties()[1][DYNAMIC_FRICTION]).rjust(3))+"          " +'\n')
+        self.chart.write( "    FRCDEC = " + (str(self.spheres_model_part.GetProperties()[1][FRICTION_DECAY]).rjust(3))+"          " +'\n')
+        self.chart.write( "    YOUNG  = " + (str(self.spheres_model_part.GetProperties()[1][YOUNG_MODULUS]/1e9).rjust(3))+" GPa"+"     " +'\n')
+        self.chart.write( "    POISS  = " + (str(self.spheres_model_part.GetProperties()[1][POISSON_RATIO]).rjust(3))+"           " +'\n')
+        self.chart.write( "    FTS    = " + (str(self.spheres_model_part.GetProperties()[1][CONTACT_SIGMA_MIN]).rjust(3))+" Pa        " +'\n')
+        self.chart.write( "    LCS1   = " + (str(self.spheres_model_part.GetProperties()[1][SLOPE_LIMIT_COEFF_C1]).rjust(3))+" Pa       " +'\n')
+        self.chart.write( "    LCS2   = " + (str(self.spheres_model_part.GetProperties()[1][SLOPE_LIMIT_COEFF_C2]).rjust(3))+" Pa       " +'\n')
+        self.chart.write( "    LCS3   = " + (str(self.spheres_model_part.GetProperties()[1][SLOPE_LIMIT_COEFF_C3]).rjust(3))+" Pa       " +'\n')
+        self.chart.write( "    YRC1   = " + (str(self.spheres_model_part.GetProperties()[1][SLOPE_FRACTION_N1]).rjust(3))+"           " +'\n')
+        self.chart.write( "    YRC2   = " + (str(self.spheres_model_part.GetProperties()[1][SLOPE_FRACTION_N2]).rjust(3))+"           " +'\n')
+        self.chart.write( "    YRC3   = " + (str(self.spheres_model_part.GetProperties()[1][SLOPE_FRACTION_N3]).rjust(3))+"           " +'\n')
+        self.chart.write( "    FSS    = " + (str(self.spheres_model_part.GetProperties()[1][CONTACT_TAU_ZERO]).rjust(3))+" Pa       " +'\n')
+        self.chart.write( "    YEP    = " + (str(self.spheres_model_part.GetProperties()[1][YOUNG_MODULUS_PLASTIC]/1e9).rjust(3))+" GPa"+"     " +'\n')
+        self.chart.write( "    YIELD  = " + (str(self.spheres_model_part.GetProperties()[1][PLASTIC_YIELD_STRESS]).rjust(3))+" Pa       " +'\n')
+        self.chart.write( "    EDR    = " + (str(self.spheres_model_part.GetProperties()[1][DAMAGE_FACTOR]).rjust(3))+"           " +'\n')
+        self.chart.write( "    SEC    = " + (str(self.spheres_model_part.GetProperties()[1][SHEAR_ENERGY_COEF]).rjust(3))+"           " +'\n')
+        self.chart.write( "                                    " +'\n')
+        self.chart.write( "**************************************" +'\n')
+        self.chart.close()
+
+        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_Parameter_chart.grf")
+        data_extract_for_print = open(absolute_path_to_file,"r")
+
+        for line in data_extract_for_print.readlines():
+            self.Procedures.KratosPrintInfo(line)
+        data_extract_for_print.close()
+
+    def FinalizeGraphs(self):
+
+        #Create a copy and renaming
+        absolute_path_to_file1 = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
+        absolute_path_to_file2 = os.path.join(self.graphs_path, self.problem_name + "_bts.grf")
+        absolute_path_to_file3 = os.path.join(self.graphs_path, self.problem_name + "_graph_VOL.grf")
+        for filename in os.listdir("."):
+            if filename.startswith(absolute_path_to_file1):
+                shutil.copy(filename, filename+"COPY")
+                os.rename(filename+"COPY", absolute_path_to_file1 + str(self.initial_time).replace(":", "") + ".grf")
+            if filename.startswith(absolute_path_to_file2):
+                shutil.copy(filename, filename+"COPY")
+                os.rename(filename+"COPY", absolute_path_to_file2 + str(self.initial_time).replace(":", "") + ".grf")
+            if filename.startswith(absolute_path_to_file3):
+                shutil.copy(filename, filename+"COPY")
+                os.rename(filename+"COPY", absolute_path_to_file3 + str(self.initial_time).replace(":", "") + ".grf")
+
+        if self.test_type == "BTS":
+            self.bts_export.close()
+        else:
+            self.graph_export_1.close()
+            self.graph_export_2.close()
+            self.graph_export_3.close()
+
+            if self.test_type != "Shear":
+                self.graph_export_4.close()
+
+            if self.test_type == "Hydrostatic":
+                self.graph_export_volumetric.close()
+
+    def OrientationStudy(self,contact_model_part,step):
+
+        absolute_path_to_file = os.path.join(self.graphs_path, "OrientationChart_"+str(step))
+        OrientationChart = open(absolute_path_to_file, 'w')
+        counter = 1
+
+        for element in contact_model_part.Elements:
+            u1 = element.GetNode(1).X - element.GetNode(0).X
+            u2 = element.GetNode(1).Y - element.GetNode(0).Y
+            u3 = element.GetNode(1).Z - element.GetNode(0).Z
+
+            alpha = abs(math.asin(abs(u2)/math.sqrt((u1*u1)+(u2*u2)+(u3*u3))))
+
+            alpha_deg = alpha/math.pi*180
+
+            element.SetValue(CONTACT_ORIENTATION,alpha_deg)
+
+            sigma = element.GetValue(CONTACT_SIGMA)
+
+            OrientationChart.write(str(counter)+"    "+str(sigma/(self.total_stress_mean))+'\n')
+            counter += 1
+
+            if alpha_deg >= 0.0 and alpha_deg < 5.0:
+                self.bond_00_05.append(element)
+
+            if alpha_deg >= 5.0 and alpha_deg < 10.0:
+                self.bond_05_10.append(element)
+
+            if alpha_deg >= 10.0 and alpha_deg < 15.0:
+                self.bond_10_15.append(element)
+
+            if alpha_deg >= 15.0 and alpha_deg < 20.0:
+                self.bond_15_20.append(element)
+
+            if alpha_deg >= 20.0 and alpha_deg < 25.0:
+                self.bond_20_25.append(element)
+
+            if alpha_deg >= 25.0 and alpha_deg < 30.0:
+                self.bond_25_30.append(element)
+
+            if alpha_deg >= 30.0 and alpha_deg < 35.0:
+                self.bond_30_35.append(element)
+
+            if alpha_deg >= 35.0 and alpha_deg < 40.0:
+                self.bond_35_40.append(element)
+
+            if alpha_deg >= 40.0 and alpha_deg < 45.0:
+                self.bond_40_45.append(element)
+
+            if alpha_deg >= 45.0 and alpha_deg < 50.0:
+                self.bond_45_50.append(element)
+
+            if alpha_deg >= 50.0 and alpha_deg < 55.0:
+                self.bond_50_55.append(element)
+
+            if alpha_deg >= 55.0 and alpha_deg < 60.0:
+                self.bond_55_60.append(element)
+
+            if alpha_deg >= 60.0 and alpha_deg < 65.0:
+                self.bond_60_65.append(element)
+
+            if alpha_deg >= 65.0 and alpha_deg < 70.0:
+                self.bond_65_70.append(element)
+
+            if alpha_deg >= 70.0 and alpha_deg < 75.0:
+                self.bond_70_75.append(element)
+
+            if alpha_deg >= 75.0 and alpha_deg < 80.0:
+                self.bond_75_80.append(element)
+
+            if alpha_deg >= 80.0 and alpha_deg < 85.0:
+                self.bond_80_85.append(element)
+
+            if alpha_deg >= 85.0 and alpha_deg < 90.0:
+                self.bond_85_90.append(element)
+
+        ii=0
+        for item in [self.bond_00_05, self.bond_05_10, self.bond_10_15, self.bond_15_20, self.bond_20_25, self.bond_25_30, self.bond_30_35, self.bond_35_40, self.bond_40_45,  self.bond_45_50, self.bond_50_55, self.bond_55_60, self.bond_60_65, self.bond_65_70, self.bond_70_75, self.bond_75_80, self.bond_80_85, self.bond_85_90]:
+
+            self.sizes[ii] = len(item)
+
+            i = 0.0
+            sigma_sum =0.0
+            tau_sum = 0.0
+
+            sigma_total_sum_squared = 0
+            tau_total_sum_squared = 0.0
+
+            volume = 0.0
+            area = 0.0
+
+            for element in item:
+                sigma_normal = element.GetValue(CONTACT_SIGMA)
+                sigma_tau = element.GetValue(CONTACT_TAU)
+
+                sigma_sum += sigma_normal
+                tau_sum += sigma_tau
+
+                sigma_partial_sum_squared = sigma_normal ** 2.0
+                sigma_total_sum_squared += sigma_partial_sum_squared
+
+                tau_partial_sum_squared = sigma_tau ** 2.0
+                tau_total_sum_squared += tau_partial_sum_squared
+
+                i += 1.0
+
+            sigma_mean = sigma_sum / len(item)
+            sigma_var = sigma_total_sum_squared / len(item) - sigma_mean ** 2.0
+
+            sigma_std_dev = 0.0
+
+            if abs(sigma_var) > 1e-9:
+                std_dev = sigma_var ** 0.5
+
+            sigma_rel_std_dev = sigma_std_dev / sigma_mean
+
+            tau_mean = tau_sum/ len(item)
+            tau_var = tau_total_sum_squared / len(item) - tau_mean ** 2.0
+
+            tau_std_dev = 0.0
+
+            if abs(tau_var) > 1e-9:
+                tau_std_dev = tau_var ** 0.5
+
+            tau_rel_std_dev = tau_std_dev / tau_mean
+
+            self.sigma_mean_table[ii] = sigma_mean
+            self.sigma_rel_std_dev_table[ii] = sigma_rel_std_dev
+            self.tau_mean_table[ii] = tau_mean
+            self.tau_rel_std_dev_table[ii] = tau_rel_std_dev
+            self.sigma_ratio_table[ii]=sigma_mean/(self.total_stress_mean)
+            ii+=1
+
+        self.Procedures.KratosPrintInfo(self.sigma_ratio_table)
+        OrientationChart.close()
+
+    def ApplyLateralPressure(self, Pressure, XLAT, XBOT, XTOP, XBOTCORNER, XTOPCORNER, alpha_top, alpha_bot, alpha_lat):
+
+        for node in XLAT:
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            values = Array3()
+            vect = Array3()
+
+            cross_section = math.pi * r * r
+
+            # normal vector to the center:
+            vect_moduli = math.sqrt(x * x + z * z)
+
+            if vect_moduli > 0.0:
+                vect[0] = -x / vect_moduli
+                vect[1] = 0
+                vect[2] = -z / vect_moduli
+
+            values[0] = cross_section * alpha_lat * Pressure * vect[0]
+            values[1] = 0.0
+            values[2] = cross_section * alpha_lat * Pressure * vect[2]
+
+            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
+
+        for node in XTOPCORNER:
+
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            values = Array3()
+            vect = Array3()
+
+            cross_section = math.pi * r * r
+
+            # normal vector to the center:
+            vect_moduli = math.sqrt(x * x + z * z)
+
+            if vect_moduli > 0.0:
+                vect[0] = -x / vect_moduli
+                vect[1] = 0
+                vect[2] = -z / vect_moduli
+
+            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
+            values[1] = 0.0
+            values[2] = cross_section * alpha_lat * Pressure * vect[2] * 0.70710678
+
+            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
+
+        for node in XBOTCORNER:
+
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            y = node.Y
+            z = node.Z
+
+            values = Array3()
+            vect = Array3()
+
+            cross_section = math.pi * r * r
+
+            # vector normal al centre:
+            vect_moduli = math.sqrt(x * x + z * z)
+
+            if vect_moduli > 0.0:
+                vect[0] = -x / vect_moduli
+                vect[1] = 0
+                vect[2] = -z / vect_moduli
+
+            values[0] = cross_section * alpha_lat * Pressure * vect[0] * 0.70710678
+            values[1] = 0.0
+            values[2] = cross_section * alpha_lat * Pressure * vect[2] * 0.70710678
+
+            node.SetSolutionStepValue(EXTERNAL_APPLIED_FORCE, values)
+
+    def MeasureRadialStrain(self):
+
+        mean_radial_strain = 0.0
+        radial_strain = 0.0
+        weight = 0.0
+
+        for node in self.XLAT:
+
+            r = node.GetSolutionStepValue(RADIUS)
+            x = node.X
+            z = node.Z
+
+            x0 = node.X0
+            z0 = node.Z0
+
+            dist_initial = math.sqrt(x0 * x0 + z0 * z0)
+            dist_now = math.sqrt(x * x + z * z)
+            node_radial_strain = (dist_now - dist_initial) / dist_initial
+            mean_radial_strain += node_radial_strain
+
+            weight += 1.0
+
+        radial_strain = mean_radial_strain/weight
+
+        return radial_strain
+
+    def PoissonMeasure(self):
+
+        self.Procedures.KratosPrintWarning("Not Working now")
+
+        #left_nodes = list()
+        #right_nodes = list()
+
+        #xleft_weight  = 0.0
+        #xright_weight  = 0.0
+
+        #left_counter = 0.0
+        #right_counter = 0.0
+
+        #if(self.parameters.PoissonMeasure == "ON"):
+
+            #for node in spheres_model_part.Nodes:
+
+                #if (node.GetSolutionStepValue(GROUP_ID)==4):
+
+                #left_nodes.append(node)
+                #xleft_weight = +(node.X0 - node.GetSolutionStepValue(RADIUS))*node.GetSolutionStepValue(RADIUS)
+                #left_counter = +node.GetSolutionStepValue(RADIUS)
+
+                #elif(node.GetSolutionStepValue(GROUP_ID)==8):
+
+                #right_nodes.append(node)
+                #xright_weight = +(node.X + node.GetSolutionStepValue(RADIUS))*node.GetSolutionStepValue(RADIUS)
+                #right_counter = +node.GetSolutionStepValue(RADIUS)
+
+            #width_ini = xright_weight/right_counter - xleft_weight/left_counter
+
+    ##################################POISSON##################################
+
+        #if(self.parameters.PoissonMeasure == "ON"):
+
+        #xleft_weight  = 0.0
+        #xright_weight  = 0.0
+
+        #left_counter = 0.0
+        #right_counter = 0.0
+
+        #for node in left_nodes:
+
+            #xleft_weight = +(node.X - node.GetSolutionStepValue(RADIUS))*node.GetSolutionStepValue(RADIUS)
+            #left_counter = +node.GetSolutionStepValue(RADIUS)
+
+        #for node in right_nodes:
+
+            #xright_weight = +(node.X + node.GetSolutionStepValue(RADIUS))*node.GetSolutionStepValue(RADIUS)
+            #right_counter = +node.GetSolutionStepValue(RADIUS)
+
+        #width_now = xright_weight/right_counter - xleft_weight/left_counter
+        #measured_poisson =  ((width_now-width_ini)/width_ini)/strain
+
+        #graph_export_poisson.write(str(strain)+"  "+str(measured_poisson)+'\n')
+
+    #-------------------------------------------------------------------------------------#
+
+    def GenerateGraphics(self):
+
+        ## PROBLEM DATA
+        area = 0.000001 ### 1mm2
+        grad_p = 1 ## Pa/m
+
+        ## Read Data
+        data_file_name0 = "test.grf"
+        data0 = loadtxt(data_file_name0)
+        strain = array(data0[:,0])
+        stress = array(data0[:,1])
+
+        data_file_name1 = "test.grf"
+        data1 = loadtxt(data_file_name1)
+        strain1 = array(data1[:,0])
+        stress1 = array(data1[:,1])
+
+        data_file_name2 = "test.grf"
+        data2 = loadtxt(data_file_name2)
+        strain2 = array(data2[:,0])
+        stress2 = array(data2[:,1])
+
+        # setting to be changed#############################3
+        set_mode = 'extralarge'  # large; publishable; medium
+        legend_position = 'lower left'
+
+        ##graph_name = ""
+        x_name = 'Axial Strain (%)'
+        y_name = 'Stress (MPa) - Load-axis'
+        ####################################################################
+        ####################################################################
+
+        clf()
+        plot_settings.set_mode(set_mode)
+        #plt.semilogx()
+        plot(strain, stress, 'k:s', strain1, stress1, 'r--v', strain2, stress2, 'b-.o',linewidth=1 )
+        legend(('test', 'test'), legend_position, numpoints=1,)
+        ##       bbox_to_anchor=(0., 1.02, 1., .102), loc=3, ncol=2, mode="expand", borderaxespad=0.)
+        grid(True)
+        #insert name ######################################################
+        savedname = "stress_graph"
+        ####################################################################
+        ##graphtitle = graph_name
+        ##title(graphtitle)
+        xlabel(x_name)
+        ylabel(y_name)
+        ##xlim(0.0, 1.0)
+        ##ylim(0.0, 1.0)
+        ##savefig(savedname + '.eps')
+        savefig(savedname + '.png')
+
+        ####################################################################
+        ####################################################################
+
+        clf()
+        plot_settings.set_mode(set_mode)
+        #plt.semilogx()
+        plot(strain, stress, 'k:s', strain1, stress1, 'r--v',linewidth=2 )
+        legend(( 'IFT variation', 'Viscosity variation'), legend_position, numpoints=1,)
+        ##       bbox_to_anchor=(0., 1.02, 1., .102), loc=3, ncol=2, mode="expand", borderaxespad=0.)
+        grid(True)
+        #insert name ######################################################
+        savedname = "stress_graph2"
+        ####################################################################
+        ##graphtitle = graph_name
+        ##title(graphtitle)
+        xlabel(x_name)
+        ylabel(y_name)
+        ##xlim(0.0, 1.0)
+        ##ylim(0.0, 1.0)
+        ##savefig(savedname + '.eps')
+        savefig(savedname + '.png')
+
+class PreUtils():
+
+    def __init__(self, spheres_model_part):
+
+        self.spheres_model_part = spheres_model_part
+        self.PreUtilities = PreUtilities()
+
+    def BreakBondUtility(self, spheres_model_part):
+        self.PreUtilities.BreakBondUtility(self.spheres_model_part)
```

## KratosMultiphysics/DEMApplication/DEM_benchmarks_class.py

 * *Ordering differences only*

```diff
@@ -1,4938 +1,4938 @@
-from KratosMultiphysics import *                                  # importing the Kratos Library
-from KratosMultiphysics.DEMApplication import *
-import shutil
-from glob import glob
-from math import pi, sin, cos, tan, atan, sqrt
-
-from os import system
-import os, sys
-files_to_delete_list = []
-
-def initialize_time_parameters(benchmark_number):
-
-    number_of_coeffs_of_restitution = 1
-
-    if benchmark_number==1:
-
-        end_time                      = 0.0005
-        dt                              = 6.4e-8 # Complies Rayleigh's condition
-        graph_print_interval            = 0.000005
-        number_of_points_in_the_graphic = 6
-
-    elif benchmark_number==2:
-
-        end_time                      = 0.007
-        dt                              = 3e-7 # Complies Rayleigh's condition????????????????
-        graph_print_interval            = 0.0001
-        number_of_points_in_the_graphic = 6
-
-    elif benchmark_number==3:
-
-        end_time                      = 0.00031
-        dt                              = 8.1e-9 #1.1e-9 # Complies Rayleigh's condition
-        graph_print_interval            = 0.000001
-        number_of_points_in_the_graphic = 6
-
-    elif benchmark_number==4:
-
-        end_time                      = 0.0002  #0.00003
-        dt                              = 2e-8 #1.9e-9 # Complies Rayleigh's condition
-        graph_print_interval            = 0.000001
-        number_of_points_in_the_graphic = 17
-
-    elif benchmark_number==5:
-
-        end_time                      = 0.0000005
-        dt                              = 3.6e-11  #3.6e-12 # Complies Rayleigh's condition
-        graph_print_interval            = 0.00000005
-        number_of_points_in_the_graphic = 17
-
-    elif benchmark_number==6:
-
-        end_time                      = 0.01
-        dt                              = 1.0e-6  #1.0e-7 # Complies Rayleigh's condition ????????????????
-        graph_print_interval            = 0.00025
-        number_of_points_in_the_graphic = 17
-
-    elif benchmark_number==7:
-
-        end_time                      = 0.0005
-        dt                              = 4.4614e-7 #4.4614e-8 # Complies Rayleigh's condition ????????????????
-        graph_print_interval            = 0.000005
-        number_of_points_in_the_graphic = 17
-
-    elif benchmark_number==8:
-
-        end_time                      = 0.02
-        dt                              = 2.0e-6 #5.0e-7 # Complies Rayleigh's condition
-        graph_print_interval            = 0.0001
-        number_of_points_in_the_graphic = 17
-
-    elif benchmark_number==9:
-
-        end_time                      = 0.001 #0.0005
-        dt                              = 5.0e-8 # 3.4e-8 # Complies Rayleigh's condition
-        graph_print_interval            = 0.000005
-        number_of_points_in_the_graphic = 6
-
-    elif benchmark_number==10:
-
-        end_time                      = 0.00015 #0.0005
-        dt                              = 2.0e-8  #3.6e-12 # Complies Rayleigh's condition
-        graph_print_interval            = 0.00001
-        number_of_points_in_the_graphic = 10
-        number_of_coeffs_of_restitution = 4
-
-    elif benchmark_number==11:
-
-        end_time                      = 0.00015 #0.0005
-        dt                              = 1.0e-7 #3.6e-12 # Complies Rayleigh's condition
-        graph_print_interval            = 0.00001
-        number_of_points_in_the_graphic = 10
-        number_of_coeffs_of_restitution = 4
-
-    elif benchmark_number==12:
-
-        end_time                      = 0.1
-        dt                              = 5.0e-7
-        graph_print_interval            = 1e-4
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==13:
-
-        end_time                      = 2.0
-        dt                              = 1.0e-4
-        graph_print_interval            = 1e-2
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==14:
-
-        end_time                      = 2.0
-        dt                              = 1.0e-4
-        graph_print_interval            = 1e-2
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==15:
-
-        end_time                      = 2.0
-        dt                              = 1.0e-4
-        graph_print_interval            = 1e-2
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==16:
-
-        end_time                      = 1.0
-        dt                              = 0.50e-4
-        graph_print_interval            = 1e-2
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==17:
-
-        end_time                      = 1.0
-        dt                              = 1.0e-6
-        graph_print_interval            = 1e-2
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==20:          # Normal compression
-
-        end_time                      = 0.01
-        dt                              = 1e-5
-        graph_print_interval            = 1e-5   # utilitzo com a output freq del grafic de punts
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==21:          # Normal compression with indentation
-
-        end_time                      = 0.01
-        dt                              = 1e-5
-        graph_print_interval            = 1e-5
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==22:          # Tensile
-
-        end_time                      = 0.05
-        dt                              = 1e-5
-        graph_print_interval            = 1e-5
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==23:          # Tensile with indentation
-
-        end_time                      = 0.05
-        dt                              = 1e-5
-        graph_print_interval            = 1e-5
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==24:          # Shear
-
-        end_time                      = 8e-5
-        dt                              = 1e-7
-        graph_print_interval            = 1e-7
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==25:          # Shear + radius expansion
-
-        end_time                      = 8e-5
-        dt                              = 1e-7
-        graph_print_interval            = 1e-7
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==26:          #
-
-        end_time                      = 0.1
-        dt                              = 1e-5
-        graph_print_interval            = 1e-4
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==27:          #UCS TEST
-
-        end_time                      = 0.05
-        dt                              = 5e-7
-        graph_print_interval            = 5e-4
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==28:          #PENDULO3D . not ready
-
-        end_time                      = 100
-        dt                              = 1e-4
-        graph_print_interval            = 1e-2
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==30:
-
-        end_time                      = 0.5
-        dt                              = 1.0e-3
-        graph_print_interval            = 1e-2
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==31:
-
-        end_time                      = 0.5
-        dt                              = 1.0e-3
-        graph_print_interval            = 1e-2
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==32:
-
-        end_time                      = 0.5
-        dt                              = 1.0e-6
-        graph_print_interval            = 1e-2
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==33:
-
-        end_time                      = 0.5
-        dt                              = 1.0e-6
-        graph_print_interval            = 1e-2
-        number_of_points_in_the_graphic = 1
-
-    elif benchmark_number==40:
-
-        end_time                      = 1
-        dt                              = 5e-5
-        graph_print_interval            = 1e-2
-        number_of_points_in_the_graphic = 1
-
-    else: #benchmark_number==68:        #
-
-        end_time                      = 1e-3
-        dt                              = 1e-6
-        graph_print_interval            = 1e-7
-        number_of_points_in_the_graphic = 1
-
-    return end_time, dt, graph_print_interval, number_of_points_in_the_graphic, number_of_coeffs_of_restitution
-
-
-def extend_datafile_list(arg):
-    files_to_delete_list.extend(arg)
-
-def delete_current_benchmark_data():
-    for to_erase_file in files_to_delete_list:
-        try:
-            os.remove(to_erase_file)
-        except OSError:
-            pass
-
-def PrintResultsMessage(test_number, it_is_success, error, elapsed_time, error_filename = 'errors.err'):
-    with open(error_filename, 'a') as error_file:
-        name = str(test_number)
-        error_file.write('DEM Benchmark ' + name + ':')
-
-        if it_is_success:
-            error_file.write(' OK!........ Test ' + name + ' SUCCESSFUL (error: '
-                             + str(round(error, 2)) + ', time: '
-                             + str(round(elapsed_time, 2)) + 's.'')\n')
-        else:
-            error_file.write(' KO!........ Test ' + name + ' FAILED (error: ' + str(error) + ')\n')
-
-def GetDisplacement(node):
-    displacement = [0]*3
-    displacement[0] = node.X-node.X0
-    displacement[1] = node.Y-node.Y0
-    displacement[2] = node.Z-node.Z0
-    return displacement
-
-def GetVectorNorm(node, variable):
-    return sqrt(sum([node.GetSolutionStepValue(variable)[i]**2 for i in range(3)]))
-
-def GetNodeDisplacement(node):
-    return sqrt(sum([GetDisplacement(node)[i]**2 for i in range(3)]))
-
-def ApplyErrorTolerance(error1=0.0, error2=0.0, error3=0.0, error4=0.0, error5=0.0):
-    tol = 5.0  # in %
-    if error1<tol: error1=0.0
-    if error2<tol: error2=0.0
-    if error3<tol: error3=0.0
-    if error4<tol: error4=0.0
-    if error5<tol: error5=0.0
-    return error1, error2, error3, error4, error5
-
-
-class Benchmark1:
-
-    def __init__(self):
-        self.number = 1
-        self.initial_normal_vel = 10.0
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        for node in modelpart.Nodes:
-            if node.Id == 1:
-                node.SetSolutionStepValue(VELOCITY_X, -self.initial_normal_vel)
-            else:
-                node.SetSolutionStepValue(VELOCITY_X,  self.initial_normal_vel)
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
-        pass
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
-        pass
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-
-        normal_contact_force_outfile_name = 'variables_for_node_1.txt'
-        gnuplot_script_name = 'benchmark1_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name, 'w')
-        self.gnuplot_outfile.write("set grid; plot '" + normal_contact_force_outfile_name + "' every 20 u 1:8 w lp lt -1 lw 1.5 ps 1 pt 4")
-        self.gnuplot_outfile.close()
-        #print_gnuplot_files_on_screen(gnuplot_script_name)
-
-        error1, error2, error3 = self.compute_errors(normal_contact_force_outfile_name)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-        it_is_success = error1 < 1.0 and error2 < 1.0 and error3 < 1.0
-        error_measure = error1 + error2 + error3
-
-        PrintResultsMessage(self.number, it_is_success, error_measure, elapsed_time)
-
-    def compute_errors(self, output_filename):
-
-        Chung_data = []; DEM_data = []
-
-        with open('paper_data/benchmark1_graph1.dat') as inf:
-            for line in inf:
-                Chung_data.append(float(line))
-
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                parts = line.split()
-                if parts[0] == '#Time':
-                    break
-            for line in inf:
-                parts = line.split()
-                DEM_data.append(float(parts[7]))
-
-        error = abs(max(DEM_data) - float(Chung_data[0]))/float(Chung_data[0])
-
-        Logger.PrintInfo("Error in restitution numbers =", 100*error,"%")
-
-        error1 = 100*error
-
-        error2 = error3 = 0
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-class Benchmark2:
-
-    def __init__(self):
-        self.number = 2
-        self.initial_normal_vel = -0.2
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        for node in modelpart.Nodes:
-            node.SetSolutionStepValue(VELOCITY_Z, self.initial_normal_vel)
-
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
-        pass
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
-        pass
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-
-        normal_contact_force_outfile_name = 'variables_for_node_2.txt'
-        gnuplot_script_name = 'benchmark2_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name, 'w')
-        self.gnuplot_outfile.write("set grid; plot '" + normal_contact_force_outfile_name + "' every 10 u 1:10 w lp lt 3 lw 1.5 ps 1 pt 6")
-        self.gnuplot_outfile.close()
-        #print_gnuplot_files_on_screen(gnuplot_script_name)
-
-        error1, error2, error3 = self.compute_errors(normal_contact_force_outfile_name)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-        it_is_success = error1 < 1.0 and error2 < 1.0 and error3 < 1.0
-        error_measure = error1 + error2 + error3
-
-        PrintResultsMessage(self.number, it_is_success, error_measure, elapsed_time)
-
-    def compute_errors(self, output_filename):
-
-        Chung_data = []; DEM_data = []
-
-        with open('paper_data/benchmark2_graph1.dat') as inf:
-            for line in inf:
-                Chung_data.append(float(line))
-
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                parts = line.split()
-                if parts[0] == '#Time':
-                    break
-            for line in inf:
-                parts = line.split()
-                DEM_data.append(float(parts[9]))
-
-        error = abs(max(DEM_data) - float(Chung_data[0]))/float(Chung_data[0])
-
-        Logger.PrintInfo("Error in restitution numbers =", 100*error,"%")
-
-        error1 = 100*error
-
-        error2 = error3 = 0
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-class Benchmark3:
-
-    def __init__(self):
-        self.number = 3
-        self.restitution_numbers_list = []
-        self.initial_normal_vel = 0
-        self.generated_data = None
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        #number = 1.0/(number_of_points_in_the_graphic-1) * (iteration - 1)
-
-        if number_of_points_in_the_graphic == 1:
-            number = 0
-        else:
-            number = 1.0/(number_of_points_in_the_graphic-1) * (iteration - 1)
-
-        for node in modelpart.Nodes:
-            self.initial_normal_vel = node.GetSolutionStepValue(VELOCITY_Z)
-            modelpart.GetProperties()[1][COEFFICIENT_OF_RESTITUTION] = number
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
-        pass
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
-
-        for node in modelpart.Nodes:
-            final_vel = node.GetSolutionStepValue(VELOCITY_Z)
-
-        restitution_coefficient = -final_vel / self.initial_normal_vel
-        self.restitution_numbers_list.append(restitution_coefficient)
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-
-        self.output_filename = "benchmark3_dt_" + str(dt) + '_restitution_numbers_vector_list_data.dat'
-        self.generated_data = open(self.output_filename, 'w')
-
-        for i in range(0, number_of_points_in_the_graphic):
-            first_col = 1/(number_of_points_in_the_graphic-1) * i
-            self.generated_data.write("%6.4f %11.8f" % (first_col, self.restitution_numbers_list[i]) + '\n')
-        self.generated_data.close()
-
-        gnuplot_script_name = 'benchmark3_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name, 'w')
-        self.gnuplot_outfile.write("set grid; plot '" + self.output_filename + "' u 1:2 w lp lt 3 lw 1.5 ps 2 pt 4, '"\
-                                                      + self.output_filename + "' u 1:3 w lp lt 2 lw 1.5 ps 2 pt 6")
-        self.gnuplot_outfile.close()
-
-        self.create_gnuplot_scripts(self.output_filename, dt)
-
-        error1, error2, error3 = self.compute_errors(self.output_filename)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-        it_is_success = error1 < 1.0 and error2 < 1.0 and error3 < 1.0
-        error_measure = error1 + error2 + error3
-
-        PrintResultsMessage(self.number, it_is_success, error_measure, elapsed_time)
-
-    def create_gnuplot_scripts(self, output_filename, dt):
-
-        gnuplot_script_name_1 = 'benchmark3_comparison_1_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Coefficient of restitution'\nset ylabel 'Damping ratio'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt  3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:1][0:1] '" + output_filename + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark3_graph1.dat' w lp ls 1 t 'Al. oxide',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark3_graph1.dat' w lp ls 2 t 'Cast iron'\n")
-        self.gnuplot_outfile.close()
-
-        #print_gnuplot_files_on_screen(gnuplot_script_name_1)
-
-    def compute_errors(self, output_filename):
-
-        lines_Chung = lines_DEM = list(range(0, 6))
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark3_graph1.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split()
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        generated_data_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-        for i, j in zip(DEM_data, Chung_data):
-            generated_data_error+=abs(i-j)
-        generated_data_error/=summation_of_Chung_data
-
-        Logger.PrintInfo("Error in restitution numbers =", 100*generated_data_error,"%")
-
-        error1 = 100*generated_data_error
-
-        error2 = error3 = 0
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-
-class Benchmark4:
-
-    def __init__(self):
-        self.number = 4
-        self.initial_module_vel = 3.9
-        self.initial_tangential_vel = 0
-        self.radius = 0.0025
-        self.degrees = 0
-        self.angles_list = []
-        self.tangential_restitution_coefficient_list = []
-        self.final_angular_vel_list = []
-        self.rebound_angle_list = []
-        self.final_angular_vel_list_outfile = None
-        self.rebound_angle_list_outfile = None
-        self.tangential_restitution_coefficient_list_outfile = None
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        self.degrees = 90 / (number_of_points_in_the_graphic + 1) * iteration
-        self.initial_tangential_vel =  self.initial_module_vel * sin(self.degrees * pi / 180.0)
-        initial_normal_vel = -self.initial_module_vel * cos(self.degrees * pi / 180.0)
-
-        for node in modelpart.Nodes:
-            node.SetSolutionStepValue(VELOCITY_Y, self.initial_tangential_vel)
-            node.SetSolutionStepValue(VELOCITY_Z, initial_normal_vel)
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
-        pass
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
-
-        for node in modelpart.Nodes:
-
-            final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_X)
-            final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_Y)
-            final_normal_center_velocity = node.GetSolutionStepValue(VELOCITY_Z)
-            final_tangential_contact_velocity = final_tangential_center_velocity + final_angular_vel * self.radius
-            rebound_angle = 180 / pi * atan(final_tangential_contact_velocity / final_normal_center_velocity)
-            tangential_restitution_coefficient = final_tangential_center_velocity / self.initial_tangential_vel
-
-        self.final_angular_vel_list.append(final_angular_vel)
-        self.rebound_angle_list.append(rebound_angle)
-        self.tangential_restitution_coefficient_list.append(tangential_restitution_coefficient)
-        self.angles_list.append(self.degrees)
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-
-        self.tangential_restitution_coefficient_list_outfile_name = "benchmark4_dt_" + str(dt) + '_tangential_restitution_coefficient_list_data.dat'
-        self.final_angular_vel_list_outfile_name = "benchmark4_dt_" + str(dt) + '_final_angular_vel_list_data.dat'
-        self.rebound_angle_list_outfile_name = "benchmark4_dt_" + str(dt) + '_rebound_angle_list_data.dat'
-        self.tangential_restitution_coefficient_list_outfile = open(self.tangential_restitution_coefficient_list_outfile_name, 'w')
-        self.final_angular_vel_list_outfile = open(self.final_angular_vel_list_outfile_name, 'w')
-        self.rebound_angle_list_outfile = open(self.rebound_angle_list_outfile_name, 'w')
-
-        for i in range(0, number_of_points_in_the_graphic):
-            self.tangential_restitution_coefficient_list_outfile.write("%14.8f %14.8f" % (self.angles_list[i], self.tangential_restitution_coefficient_list[i]) + '\n')
-            self.final_angular_vel_list_outfile.write("%14.8f %14.8f" % (self.angles_list[i], self.final_angular_vel_list[i]) + '\n')
-            self.rebound_angle_list_outfile.write("%14.8f %14.8f" % (self.angles_list[i], self.rebound_angle_list[i]) + '\n')
-        self.tangential_restitution_coefficient_list_outfile.close()
-        self.final_angular_vel_list_outfile.close()
-        self.rebound_angle_list_outfile.close()
-
-        self.create_gnuplot_scripts(self.tangential_restitution_coefficient_list_outfile_name, self.final_angular_vel_list_outfile_name,\
-                                    self.rebound_angle_list_outfile_name, dt)
-
-        error1, error2, error3 = self.compute_errors(self.tangential_restitution_coefficient_list_outfile_name, self.final_angular_vel_list_outfile_name,\
-                                    self.rebound_angle_list_outfile_name)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-        it_is_success = error1 < 2.0 and error2 < 2.0 and error3 < 2.0
-        error_measure = error1 + error2 + error3
-
-        PrintResultsMessage(self.number, it_is_success, error_measure, elapsed_time)
-
-    def create_gnuplot_scripts(self, tangential_restitution_coefficient_list_outfile_name, final_angular_vel_list_outfile_name,\
-                               rebound_angle_list_outfile_name, dt):
-
-        gnuplot_script_name_1 = 'benchmark4_comparison_1_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt  3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:90][.4:1] '" + tangential_restitution_coefficient_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark4_graph1.dat' index 0 w lp ls 1 t 'Al. oxide',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark4_graph1.dat' index 1 w lp ls 2 t 'Al. alloy',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark4_graph1.dat' index 2 w p pt 7 ps 2 lt -1 t 'Experimental'\n")
-        self.gnuplot_outfile.close()
-
-        gnuplot_script_name_2 = 'benchmark4_comparison_2_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Incident angle (deg)'\nset ylabel 'Final angular velocity (rad/s)'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt  3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:90][-750:0] '" + final_angular_vel_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark4_graph2.dat' index 0 w lp ls 1 t 'Al. oxide',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark4_graph2.dat' index 1 w lp ls 2 t 'Al. alloy',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark4_graph2.dat' index 2 w p pt 7 ps 2 lt -1 t 'Experimental'\n")
-        self.gnuplot_outfile.close()
-
-        gnuplot_script_name_3 = 'benchmark4_comparison_3_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_3, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Incident angle (deg)'\nset ylabel 'Rebound angle (deg)'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt  3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:90][-30:90] '" + rebound_angle_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark4_graph3.dat' index 0 w lp ls 1 t 'Al. oxide',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark4_graph3.dat' index 1 w lp ls 2 t 'Al. alloy',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark4_graph3.dat' index 2 w p pt 7 ps 2 lt -1 t 'Experimental'\n")
-        self.gnuplot_outfile.close()
-        '''
-        print_gnuplot_files_on_screen(gnuplot_script_name_1)
-        print_gnuplot_files_on_screen(gnuplot_script_name_2)
-        print_gnuplot_files_on_screen(gnuplot_script_name_3)'''
-
-    def compute_errors(self, tangential_restitution_coefficient_list_outfile_name, final_angular_vel_list_outfile_name, rebound_angle_list_outfile_name):
-
-        lines_Chung = list(range(17, 30)); lines_DEM = list(range(0, 8)) + list(range(9, 16, 2)) + [16]
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark4_graph1.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split(',')
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(tangential_restitution_coefficient_list_outfile_name) as inf:
-            extend_datafile_list(glob(tangential_restitution_coefficient_list_outfile_name))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_tangential_restitution_coefficient_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-        for i, j in zip(DEM_data, Chung_data):
-            final_tangential_restitution_coefficient_error+=abs(i-j)
-        final_tangential_restitution_coefficient_error/=summation_of_Chung_data
-        Logger.PrintInfo("Error in tangential restitution coefficient =", 100*final_tangential_restitution_coefficient_error,"%")
-
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark4_graph2.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split(',')
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(final_angular_vel_list_outfile_name) as inf:
-            extend_datafile_list(glob(final_angular_vel_list_outfile_name))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_angular_vel_total_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-        for i, j in zip(DEM_data, Chung_data):
-            final_angular_vel_total_error+=abs(i-j)
-        final_angular_vel_total_error/=summation_of_Chung_data
-        Logger.PrintInfo("Error in final angular vel =", 100*final_angular_vel_total_error,"%")
-
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark4_graph3.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split(',')
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(rebound_angle_list_outfile_name) as inf:
-            extend_datafile_list(glob(rebound_angle_list_outfile_name))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_rebound_angle_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-        for i, j in zip(DEM_data, Chung_data):
-            final_rebound_angle_error+=abs(i-j)
-        final_rebound_angle_error/=summation_of_Chung_data
-        Logger.PrintInfo("Error in final rebound angle =", 100*final_rebound_angle_error,"%")
-
-        error1 = 100*final_tangential_restitution_coefficient_error
-        error2 = 100*final_angular_vel_total_error
-        error3 = 100*final_rebound_angle_error
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-
-class Benchmark5:
-
-    def __init__(self):
-        self.number = 5
-        self.initial_normal_vel = -5.0
-        self.initial_tangential_vel = 0
-        self.radius = 0.00001
-        self.Vst_div_mu_per_Vcn_list = []
-        self.Vst_prima_div_mu_per_Vcn_prima_list = []
-        self.r_w1_prima_div_mu_per_Vcn_list = []
-        self.Vst_prima_div_mu_per_Vcn_prima_list_outfile = None
-        self.r_w1_prima_div_mu_per_Vcn_list_outfile = None
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        degrees = 90 / (number_of_points_in_the_graphic + 1) * iteration
-        self.initial_tangential_vel =  -self.initial_normal_vel * tan(degrees * pi / 180.0)
-
-        for node in modelpart.Nodes:
-            node.SetSolutionStepValue(VELOCITY_Y, self.initial_tangential_vel)
-            node.SetSolutionStepValue(VELOCITY_Z, self.initial_normal_vel)
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
-        pass
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
-
-        mu = 0.3
-
-        for node in modelpart.Nodes:
-            final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_X)
-            final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_Y)
-            final_normal_center_velocity = node.GetSolutionStepValue(VELOCITY_Z)
-            Vst_div_mu_per_Vcn = -self.initial_tangential_vel / (mu * self.initial_normal_vel)
-            Vst_prima_div_mu_per_Vcn_prima = (final_tangential_center_velocity + final_angular_vel * self.radius) / (mu * final_normal_center_velocity)
-            r_w1_prima_div_mu_per_Vcn = -self.radius * final_angular_vel / (mu * self.initial_normal_vel)
-
-        self.Vst_div_mu_per_Vcn_list.append(Vst_div_mu_per_Vcn)
-        self.Vst_prima_div_mu_per_Vcn_prima_list.append(Vst_prima_div_mu_per_Vcn_prima)
-        self.r_w1_prima_div_mu_per_Vcn_list.append(r_w1_prima_div_mu_per_Vcn)
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-
-        self.Vst_prima_div_mu_per_Vcn_prima_list_outfile_name = "benchmark5_dt_" + str(dt) + '_Vst_prima_div_mu_per_Vcn_prima_list_data.dat'
-        self.r_w1_prima_div_mu_per_Vcn_list_outfile_name = "benchmark5_dt_" + str(dt) + '_r_w1_prima_div_mu_per_Vcn_list_data.dat'
-        self.Vst_prima_div_mu_per_Vcn_prima_list_outfile = open(self.Vst_prima_div_mu_per_Vcn_prima_list_outfile_name, 'w')
-        self.r_w1_prima_div_mu_per_Vcn_list_outfile = open(self.r_w1_prima_div_mu_per_Vcn_list_outfile_name, 'w')
-
-        for i in range(0, number_of_points_in_the_graphic):
-            self.Vst_prima_div_mu_per_Vcn_prima_list_outfile.write("%14.8f %14.8f" % (self.Vst_div_mu_per_Vcn_list[i], self.Vst_prima_div_mu_per_Vcn_prima_list[i]) + '\n')
-            self.r_w1_prima_div_mu_per_Vcn_list_outfile.write("%14.8f %14.8f" % (self.Vst_div_mu_per_Vcn_list[i], self.r_w1_prima_div_mu_per_Vcn_list[i]) + '\n')
-        self.Vst_prima_div_mu_per_Vcn_prima_list_outfile.close()
-        self.r_w1_prima_div_mu_per_Vcn_list_outfile.close()
-
-        self.create_gnuplot_scripts(self.Vst_prima_div_mu_per_Vcn_prima_list_outfile_name, self.r_w1_prima_div_mu_per_Vcn_list_outfile_name, dt)
-
-        error1, error2, error3 = self.compute_errors(self.Vst_prima_div_mu_per_Vcn_prima_list_outfile_name, self.r_w1_prima_div_mu_per_Vcn_list_outfile_name)
-        it_is_success = error1 < 2.0 and error2 < 2.0 and error3 < 2.0
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-        error_measure = error1 + error2 + error3
-        PrintResultsMessage(self.number, it_is_success, error_measure, elapsed_time)
-
-    def create_gnuplot_scripts(self, Vst_prima_div_mu_per_Vcn_prima_list_outfile_name, r_w1_prima_div_mu_per_Vcn_list_outfile_name, dt):
-
-        gnuplot_script_name_1 = 'benchmark5_comparison_1_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:14][-4:6] '" + Vst_prima_div_mu_per_Vcn_prima_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark5_graph1.dat' index 0 w lp ls 1 t 'Steel',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark5_graph1.dat' index 1 w lp ls 2 t 'Polyethylene',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark5_graph1.dat' index 2 w p pt 7 ps 2 lt -1 t 'FEM'\n")
-        self.gnuplot_outfile.close()
-
-        gnuplot_script_name_2 = 'benchmark5_comparison_2_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Normalized incident angle'\nset ylabel 'Normalized final angular velocity'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:20][-6:0] '" + r_w1_prima_div_mu_per_Vcn_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark5_graph2.dat' index 0 w lp ls 1 t 'Steel',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark5_graph2.dat' index 1 w lp ls 2 t 'Polyethylene',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark5_graph2.dat' index 2 w p pt 7 ps 2 lt -1 t 'FEM'\n")
-        self.gnuplot_outfile.close()
-        '''
-        print_gnuplot_files_on_screen(gnuplot_script_name_1)
-        print_gnuplot_files_on_screen(gnuplot_script_name_2)'''
-
-    def compute_errors(self, Vst_prima_div_mu_per_Vcn_prima_list_outfile_name, r_w1_prima_div_mu_per_Vcn_list_outfile_name):
-
-        lines_Chung = list(range(49, 53)); lines_DEM = list(range(11, 15)) # Sliding regime for the time being
-        #lines_Chung = list(range(38, 53)); lines_DEM = list(range(0, 15)) # Whole diagram
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark5_graph1.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split(',')
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(Vst_prima_div_mu_per_Vcn_prima_list_outfile_name) as inf:
-            extend_datafile_list(glob(Vst_prima_div_mu_per_Vcn_prima_list_outfile_name))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_Vst_prima_div_mu_per_Vcn_prima_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-        for i, j in zip(DEM_data, Chung_data):
-            final_Vst_prima_div_mu_per_Vcn_prima_error+=abs(i-j)
-
-        final_Vst_prima_div_mu_per_Vcn_prima_error/=summation_of_Chung_data
-
-        Logger.PrintInfo("Error in final Vst prima div mu per Vcn prima =", 100*final_Vst_prima_div_mu_per_Vcn_prima_error,"%")
-
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark5_graph2.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split(',')
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(r_w1_prima_div_mu_per_Vcn_list_outfile_name) as inf:
-            extend_datafile_list(glob(r_w1_prima_div_mu_per_Vcn_list_outfile_name))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_r_w1_prima_div_mu_per_Vcn_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-        for i, j in zip(DEM_data, Chung_data):
-            final_r_w1_prima_div_mu_per_Vcn_error+=abs(i-j)
-
-        final_r_w1_prima_div_mu_per_Vcn_error/=summation_of_Chung_data
-        Logger.PrintInfo("Error in final r w1 prima div mu per Vcn =", 100*final_r_w1_prima_div_mu_per_Vcn_error,"%")
-
-        error1 = 100*final_Vst_prima_div_mu_per_Vcn_prima_error
-        error2 = 100*final_r_w1_prima_div_mu_per_Vcn_error
-        error3 = 0
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-
-class Benchmark6:
-
-    def __init__(self):
-        self.number = 6
-        self.initial_normal_vel = -0.2
-        self.initial_tangential_vel = 0
-        self.radius = 0.1
-        self.special_quantity_list = []
-        self.beta_list = []
-        self.Vst_div_Vcn_list = []
-        self.Vst_prima_div_Vcn_prima_list = []
-        self.beta_list_outfile = None
-        self.Vst_prima_div_Vcn_prima_list_outfile = None
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        degrees = 90 / (number_of_points_in_the_graphic + 1) * iteration
-        self.initial_tangential_vel = -self.initial_normal_vel * tan(degrees * pi / 180.0) # Here is tangential of the contact point, only. In X axis
-        initial_angular_vel = -self.initial_tangential_vel / self.radius # In Y axis
-
-        for node in modelpart.Nodes:
-            node.SetSolutionStepValue(VELOCITY_Z, self.initial_normal_vel)
-            node.SetSolutionStepValue(ANGULAR_VELOCITY_Y, initial_angular_vel)
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
-        pass
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
-
-        mu = 0.4
-        restitution_coeff = 0.5
-
-        for node in modelpart.Nodes:
-            special_quantity = -3.5 * mu * (1.0 + restitution_coeff) * self.initial_normal_vel / self.initial_tangential_vel
-            final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)
-            final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_X)
-            final_normal_center_velocity = node.GetSolutionStepValue(VELOCITY_Z)
-            beta = -(final_tangential_center_velocity - final_angular_vel * self.radius)/ self.initial_tangential_vel
-            Vst_div_Vcn = -self.initial_tangential_vel / self.initial_normal_vel
-            Vst_prima_div_Vcn_prima = (final_tangential_center_velocity - final_angular_vel * self.radius) / final_normal_center_velocity
-
-        self.special_quantity_list.append(special_quantity)
-        self.beta_list.append(beta)
-        self.Vst_div_Vcn_list.append(Vst_div_Vcn)
-        self.Vst_prima_div_Vcn_prima_list.append(Vst_prima_div_Vcn_prima)
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-
-        self.beta_list_outfile_name = "benchmark6_dt_" + str(dt) + '_beta_list_data.dat'
-        self.Vst_prima_div_Vcn_prima_list_outfile_name = "benchmark6_dt_" + str(dt) + '_Vst_prima_div_Vcn_prima_data.dat'
-        self.beta_list_outfile = open(self.beta_list_outfile_name, 'w')
-        self.Vst_prima_div_Vcn_prima_list_outfile = open(self.Vst_prima_div_Vcn_prima_list_outfile_name, 'w')
-
-        for i in range(0, number_of_points_in_the_graphic):
-            self.beta_list_outfile.write("%14.8f %14.8f" % (self.special_quantity_list[i], self.beta_list[i]) + '\n')
-            self.Vst_prima_div_Vcn_prima_list_outfile.write("%14.8f %14.8f" % (self.Vst_div_Vcn_list[i], self.Vst_prima_div_Vcn_prima_list[i]) + '\n')
-        self.beta_list_outfile.close()
-        self.Vst_prima_div_Vcn_prima_list_outfile.close()
-
-        self.create_gnuplot_scripts(self.beta_list_outfile_name, self.Vst_prima_div_Vcn_prima_list_outfile_name, dt)
-
-        error1, error2, error3 = self.compute_errors(self.beta_list_outfile_name, self.Vst_prima_div_Vcn_prima_list_outfile_name)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-        it_is_success = error1 < 3.0 and error2 < 3.0 and error3 < 3.0
-        error_measure = error1 + error2 + error3
-
-        PrintResultsMessage(self.number, it_is_success, error_measure, elapsed_time)
-
-    def create_gnuplot_scripts(self, beta_list_outfile_name, Vst_prima_div_Vcn_prima_list_outfile_name, dt):
-
-        gnuplot_script_name_1 = 'benchmark6_comparison_1_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:25][-1:.6] '" + beta_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark6_graph1.dat' index 0 w lp ls 1 t 'Al. alloy',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark6_graph1.dat' index 1 w lp ls 2 t 'Nylon'\n")
-        self.gnuplot_outfile.close()
-
-        gnuplot_script_name_2 = 'benchmark6_comparison_2_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Tangent of incident angle'\nset ylabel 'Tangent of recoil angle'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:7][-2:8] '" + Vst_prima_div_Vcn_prima_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark6_graph2.dat' index 0 w lp ls 1 t 'Al. alloy',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark6_graph2.dat' index 1 w lp ls 2 t 'Nylon'\n")
-        self.gnuplot_outfile.close()
-        '''
-        print_gnuplot_files_on_screen(gnuplot_script_name_1)
-        print_gnuplot_files_on_screen(gnuplot_script_name_2)'''
-
-    def compute_errors(self, beta_list_outfile_name, Vst_prima_div_Vcn_prima_list_outfile_name):
-
-        lines_Chung = list(range(1, 7)); lines_DEM = list(range(16, 10, -1)) # Sliding regime for the time being
-        #lines_Chung = list(range(1, 17)); lines_DEM = list(range(0, 16)) # Whole diagram
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark6_graph1.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split(',')
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-
-        with open(beta_list_outfile_name) as inf:
-            extend_datafile_list(glob(beta_list_outfile_name))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_beta_list_outfile_name_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-        DEM_data.reverse()
-        for i, j in zip(DEM_data, Chung_data):
-            final_beta_list_outfile_name_error+=abs(i-j)
-
-        final_beta_list_outfile_name_error/=summation_of_Chung_data
-        Logger.PrintInfo("Error in final beta =", 100*final_beta_list_outfile_name_error,"%")
-
-        lines_Chung = list(range(13, 17)); lines_DEM = list(range(12, 16)) # Sliding regime for the time being
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark6_graph2.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split(',')
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(Vst_prima_div_Vcn_prima_list_outfile_name) as inf:
-            extend_datafile_list(glob(Vst_prima_div_Vcn_prima_list_outfile_name))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_Vst_prima_div_Vcn_prima_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-
-        for i, j in zip(DEM_data, Chung_data):
-            final_Vst_prima_div_Vcn_prima_error+=abs(i-j)
-
-        final_Vst_prima_div_Vcn_prima_error/=summation_of_Chung_data
-        Logger.PrintInfo("Error in final Vst prima div Vcn =", 100*final_Vst_prima_div_Vcn_prima_error,"%")
-
-        error1 = 100*final_beta_list_outfile_name_error
-        error2 = 100*final_Vst_prima_div_Vcn_prima_error
-        error3 = 0
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-class Benchmark7:
-
-    def __init__(self):
-        self.number = 7
-        self.initial_angular_vel = 0
-        self.final_tangential_center_vel_list_outfile = None
-        self.final_angular_vel_list_outfile = None
-        self.initial_angular_vel_list = []
-        self.final_tangential_center_vel_list = []
-        self.final_angular_vel_list = []
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        initial_normal_vel = 0.2
-        radius = 0.1
-        degrees = 90 / (number_of_points_in_the_graphic + 1) * iteration
-        self.initial_angular_vel =  initial_normal_vel / radius * tan(degrees * pi / 180.0) # Here is tangential of the contact point, only
-
-        for node in modelpart.Nodes:
-            if node.Id == 1:
-                node.SetSolutionStepValue(VELOCITY_X,  initial_normal_vel)
-                node.SetSolutionStepValue(ANGULAR_VELOCITY_Y,  self.initial_angular_vel)
-            else:
-                node.SetSolutionStepValue(VELOCITY_X, -initial_normal_vel)
-                node.SetSolutionStepValue(ANGULAR_VELOCITY_Y, -self.initial_angular_vel)
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
-        pass
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
-
-        for node in modelpart.Nodes:
-            if node.Id == 1:
-                final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_Z)
-                final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)
-
-        self.initial_angular_vel_list.append(self.initial_angular_vel)
-        self.final_tangential_center_vel_list.append(final_tangential_center_velocity)
-        self.final_angular_vel_list.append(final_angular_vel)
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-
-        self.final_tangential_center_vel_list_outfile_name = "benchmark7_dt_" + str(dt) + '_final_tangential_center_vel_list_data.dat'
-        self.final_angular_vel_list_outfile_name = "benchmark7_dt_" + str(dt) + '_final_angular_vel_list_data.dat'
-        self.final_tangential_center_vel_list_outfile = open(self.final_tangential_center_vel_list_outfile_name, 'w')
-        self.final_angular_vel_list_outfile = open(self.final_angular_vel_list_outfile_name, 'w')
-
-        for i in range(0, number_of_points_in_the_graphic):
-            self.final_tangential_center_vel_list_outfile.write("%14.8f %14.8f" % (self.initial_angular_vel_list[i], self.final_tangential_center_vel_list[i]) + '\n')
-            self.final_angular_vel_list_outfile.write("%14.8f %14.8f" % (self.initial_angular_vel_list[i], self.final_angular_vel_list[i]) + '\n')
-        self.final_tangential_center_vel_list_outfile.close()
-        self.final_angular_vel_list_outfile.close()
-
-        gnuplot_script_name = 'benchmark7_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name, 'w')
-        self.gnuplot_outfile.write("set multiplot layout 2, 1; set grid; set bmargin 0; set format x \"\"; set ytics -5, 5; set key bottom;\
-                                    plot [0:25][-10:10] '" + self.final_tangential_center_vel_list_outfile_name + "' w lp lw 1.5 ps 2 pt 4;\
-                                    set bmargin; set tmargin 0; set format x \"%g\"; set ytics 0, 5, 20; set key top;\
-                                    plot [0:25][0:25] '" + self.final_angular_vel_list_outfile_name + "' w lp lw 1.5 lt 3 ps 2 pt 6; unset multiplot")
-        self.gnuplot_outfile.close()
-
-        self.create_gnuplot_scripts(self.final_tangential_center_vel_list_outfile_name, self.final_angular_vel_list_outfile_name, dt)
-
-        error1, error2, error3 = self.compute_errors(self.final_tangential_center_vel_list_outfile_name, self.final_angular_vel_list_outfile_name)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-        it_is_success = error1 < 1.0 and error2 < 1.0 and error3 < 1.0
-        error_measure = error1 + error2 + error3
-
-        PrintResultsMessage(self.number, it_is_success, error_measure, elapsed_time)
-
-    def create_gnuplot_scripts(self, final_tangential_center_vel_list_outfile_name, final_angular_vel_list_outfile_name, dt):
-
-        gnuplot_script_name_1 = 'benchmark7_comparison_1_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:25][-10:10] '" + final_tangential_center_vel_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark7_graph1.dat' w lp ls 1 t 'Al. alloy',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark7_graph1.dat' w lp ls 2 t 'Copper'\n")
-        self.gnuplot_outfile.close()
-
-        gnuplot_script_name_2 = 'benchmark7_comparison_2_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Initial angular velocity (rad/s)'\nset ylabel 'Final angular velocity (rad/s)'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:25][0:25] '" + final_angular_vel_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark7_graph2.dat' w lp ls 1 t 'Al. alloy',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark7_graph2.dat' w lp ls 2 t 'Copper'\n")
-        self.gnuplot_outfile.close()
-        '''
-        print_gnuplot_files_on_screen(gnuplot_script_name_1)
-        print_gnuplot_files_on_screen(gnuplot_script_name_2)'''
-
-    def compute_errors(self, final_tangential_center_vel_list_outfile_name, final_angular_vel_list_outfile_name):
-
-        lines_Chung = []; lines_DEM = []; lines_Chung = list(range(0, 17)); lines_DEM = list(range(0, 17))
-        Chung_data = []; DEM_data = []
-        i = 0
-        with open('paper_data/benchmark7_graph1.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split()
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(final_tangential_center_vel_list_outfile_name) as inf:
-            extend_datafile_list(glob(final_tangential_center_vel_list_outfile_name))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_tangential_center_vel_error = 0
-
-        for i, j in zip(DEM_data, Chung_data):
-            final_tangential_center_vel_error+=abs(i-j)
-        Logger.PrintInfo("Error in final tangential center vel =", final_tangential_center_vel_error)
-
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark7_graph2.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split()
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(final_angular_vel_list_outfile_name) as inf:
-            extend_datafile_list(glob(final_angular_vel_list_outfile_name))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_angular_vel_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-        for i, j in zip(DEM_data, Chung_data):
-            final_angular_vel_error+=abs(i-j)
-
-        final_angular_vel_error/=summation_of_Chung_data
-        Logger.PrintInfo("Error in final angular vel =", 100*final_angular_vel_error,"%")
-
-        error1 = 100*final_tangential_center_vel_error
-        error2 = 100*final_angular_vel_error
-        error3 = 0
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-
-class Benchmark8:
-
-    def __init__(self):
-        self.number = 8
-        self.initial_normal_vel = 0.2
-        self.initial_tangential_vel = 0
-        self.radius = 0.1
-        self.special_quantity_list = []
-        self.beta_list = []
-        self.Vst_div_Vcn_list = []
-        self.Vst_prima_div_Vcn_prima_list = []
-        self.beta_list_outfile = None
-        self.Vst_prima_div_Vcn_prima_list_outfile = None
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        degrees = 90 - 90 / (number_of_points_in_the_graphic + 1) * iteration
-        self.initial_tangential_vel =  self.initial_normal_vel * tan(degrees * pi / 180.0) # Here is tangential of the contact point, only
-        initial_angular_vel    =  -self.initial_tangential_vel / self.radius
-
-        for node in modelpart.Nodes:
-            if node.Id == 1:
-                node.SetSolutionStepValue(VELOCITY_X, self.initial_normal_vel)
-                node.SetSolutionStepValue(ANGULAR_VELOCITY_Y, initial_angular_vel)
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
-        pass
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
-
-        mu = 0.4
-        restitution_coeff = 0.5
-
-        for node in modelpart.Nodes:
-            if node.Id == 1:
-                special_quantity = 3.5 * mu * (1.0 + restitution_coeff) * self.initial_normal_vel / self.initial_tangential_vel
-                final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)
-                final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_Z)
-                final_normal_center_velocity = node.GetSolutionStepValue(VELOCITY_X)
-                beta = -(final_tangential_center_velocity - final_angular_vel * self.radius)/ self.initial_tangential_vel
-                Vst_div_Vcn = self.initial_tangential_vel / self.initial_normal_vel
-                Vst_prima_div_Vcn_prima = -(final_tangential_center_velocity - final_angular_vel * self.radius) / final_normal_center_velocity
-
-        self.special_quantity_list.append(special_quantity)
-        self.beta_list.append(beta)
-        self.Vst_div_Vcn_list.append(Vst_div_Vcn)
-        self.Vst_prima_div_Vcn_prima_list.append(Vst_prima_div_Vcn_prima)
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-
-        self.beta_list_outfile_name = 'benchmark8_dt_' + str(dt) + 's_beta_list_data.dat'
-        self.Vst_prima_div_Vcn_prima_list_outfile_name = 'benchmark8_dt_' + str(dt) + 's_Vst_prima_div_Vcn_prima_list_data.dat'
-        self.beta_list_outfile = open(self.beta_list_outfile_name, 'w')
-        self.Vst_prima_div_Vcn_prima_list_outfile = open(self.Vst_prima_div_Vcn_prima_list_outfile_name, 'w')
-
-        for i in range(0, number_of_points_in_the_graphic):
-            self.beta_list_outfile.write("%14.8f %14.8f" % (self.special_quantity_list[i], self.beta_list[i]) + '\n')
-            self.Vst_prima_div_Vcn_prima_list_outfile.write("%14.8f %14.8f" % (self.Vst_div_Vcn_list[i], self.Vst_prima_div_Vcn_prima_list[i]) + '\n')
-
-        self.beta_list_outfile.close()
-        self.Vst_prima_div_Vcn_prima_list_outfile.close()
-
-        self.create_gnuplot_scripts(self.beta_list_outfile_name, self.Vst_prima_div_Vcn_prima_list_outfile_name, dt)
-
-        error1, error2, error3 = self.compute_errors(self.beta_list_outfile_name, self.Vst_prima_div_Vcn_prima_list_outfile_name)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-        it_is_success = error1 < 3.0 and error2 < 3.0 and error3 < 3.0
-        error_measure = error1 + error2 + error3
-
-        PrintResultsMessage(self.number, it_is_success, error_measure, elapsed_time)
-
-    def create_gnuplot_scripts(self, beta_list_outfile_name, Vst_prima_div_Vcn_prima_list_outfile_name, dt):
-
-        gnuplot_script_name_1 = 'benchmark8_comparison_1_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:25][-1:.6] '" + beta_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark8_graph1.dat' index 0 w lp ls 1 t 'Al. alloy',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark8_graph1.dat' index 1 w lp ls 2 t 'Nylon'\n")
-        self.gnuplot_outfile.close()
-
-        gnuplot_script_name_2 = 'benchmark8_comparison_2_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Tangent of incident angle'\nset ylabel 'Tangent of recoil angle'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:8][-2:8] '" + Vst_prima_div_Vcn_prima_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark8_graph2.dat' index 0 w lp ls 1 t 'Al. alloy',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark8_graph2.dat' index 1 w lp ls 2 t 'Nylon'\n")
-        self.gnuplot_outfile.close()
-        '''
-        print_gnuplot_files_on_screen(gnuplot_script_name_1)
-        print_gnuplot_files_on_screen(gnuplot_script_name_2)'''
-
-    def compute_errors(self, beta_list_outfile_name, Vst_prima_div_Vcn_prima_list_outfile_name):
-
-        lines_Chung = []; lines_DEM = []; lines_Chung = list(range(1, 7)); lines_DEM = list(range(0, 6)) # Sliding regime for the time being
-        #lines_Chung = []; lines_DEM = []; lines_Chung = list(range(1, 18)); lines_DEM = list(range(0, 17)) # Whole diagram
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark8_graph1.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split(',')
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(beta_list_outfile_name) as inf:
-            extend_datafile_list(glob(beta_list_outfile_name))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_beta_list_outfile_name_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-        for i, j in zip(DEM_data, Chung_data):
-            final_beta_list_outfile_name_error+=abs(i-j)
-
-        final_beta_list_outfile_name_error/=summation_of_Chung_data
-        Logger.PrintInfo("Error in final beta =", 100*final_beta_list_outfile_name_error,"%")
-
-        lines_Chung = []; lines_DEM = []; lines_DEM = list(range(4, 0, -1)); lines_Chung = list(range(13, 17)) # Sliding regime for the time being
-        #lines_Chung = list(range(1, 17)); lines_DEM = list(range(0, 16)) # Whole diagram
-
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark8_graph2.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split(',')
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(Vst_prima_div_Vcn_prima_list_outfile_name) as inf:
-            extend_datafile_list(glob(Vst_prima_div_Vcn_prima_list_outfile_name))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_Vst_prima_div_Vcn_prima_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-        DEM_data.reverse()
-        for i, j in zip(DEM_data, Chung_data):
-            final_Vst_prima_div_Vcn_prima_error+=abs(i-j)
-
-        final_Vst_prima_div_Vcn_prima_error/=summation_of_Chung_data
-        Logger.PrintInfo("Error in final Vst prima div Vcn =", 100*final_Vst_prima_div_Vcn_prima_error,"%")
-
-        error1 = 100*final_beta_list_outfile_name_error
-        error2 = 100*final_Vst_prima_div_Vcn_prima_error
-        error3 = 0
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-class Benchmark9:
-
-    def __init__(self):
-        self.number = 9
-        self.initial_normal_vel = 200.0
-        self.restitution_numbers_list = []
-        self.generated_data = None
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        if number_of_points_in_the_graphic == 1:
-            number = 0
-        else:
-            number = 1.0/(number_of_points_in_the_graphic-1) * (iteration - 1)
-
-        for node in modelpart.Nodes:
-
-            if node.Id == 1:
-                node.SetSolutionStepValue(VELOCITY_X,  self.initial_normal_vel)
-                node.SetSolutionStepValue(VELOCITY_Z, 0.0)
-                modelpart.GetProperties()[1][COEFFICIENT_OF_RESTITUTION] = number
-            else:
-                node.SetSolutionStepValue(VELOCITY_X, -self.initial_normal_vel)
-                node.SetSolutionStepValue(VELOCITY_Z, 0.0)
-                modelpart.GetProperties()[1][COEFFICIENT_OF_RESTITUTION] = number
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
-        pass
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
-
-        for node in modelpart.Nodes:
-            if node.Id == 1:
-                final_vel = node.GetSolutionStepValue(VELOCITY_X)
-
-        restitution_coefficient = -final_vel / self.initial_normal_vel
-        self.restitution_numbers_list.append(restitution_coefficient)
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-
-        self.output_filename = "benchmark9_dt_" + str(dt) + '_restitution_numbers_vector_list_data.dat'
-        self.generated_data = open(self.output_filename, 'w')
-
-        for i in range(0, number_of_points_in_the_graphic):
-            if number_of_points_in_the_graphic == 1:
-                first_col = 0
-            else:
-                first_col = 1/(number_of_points_in_the_graphic-1) * i
-            self.generated_data.write("%6.4f %11.8f" % (first_col, self.restitution_numbers_list[i]) + '\n')
-        self.generated_data.close()
-
-        gnuplot_script_name = 'benchmark9_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name, 'w')
-        self.gnuplot_outfile.write("set grid; plot '" + self.output_filename + "' u 1:2 w lp lt 3 lw 1.5 ps 2 pt 4, '"\
-                                                      + self.output_filename + "' u 1:3 w lp lt 2 lw 1.5 ps 2 pt 6")
-        self.gnuplot_outfile.close()
-
-        self.create_gnuplot_scripts(self.output_filename, dt)
-
-        error1, error2, error3 = self.compute_errors(self.output_filename)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-        it_is_success = error1 < 1.0 and error2 < 1.0 and error3 < 1.0
-        error_measure = error1 + error2 + error3
-
-        PrintResultsMessage(self.number, it_is_success, error_measure, elapsed_time)
-
-    def create_gnuplot_scripts(self, output_filename, dt):
-
-        gnuplot_script_name_1 = 'benchmark9_comparison_1_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Coefficient of restitution'\nset ylabel 'Damping ratio'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt  3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:1][0:1] '" + output_filename + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark9_graph1.dat' w lp ls 1 t 'Al. oxide',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark9_graph1.dat' w lp ls 2 t 'Cast iron'\n")
-        self.gnuplot_outfile.close()
-
-        #print_gnuplot_files_on_screen(gnuplot_script_name_1)
-
-    def compute_errors(self, output_filename):
-
-        lines_Chung = lines_DEM = list(range(0, 6));
-        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
-        i = 0
-        with open('paper_data/benchmark9_graph1.dat') as inf:
-            for line in inf:
-                if i in lines_Chung:
-                    parts = line.split()
-                    Chung_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        generated_data_error = 0
-
-        for j in Chung_data:
-            summation_of_Chung_data+=abs(j)
-
-        for i, j in zip(DEM_data, Chung_data):
-            generated_data_error+=abs(i-j)
-        generated_data_error/=summation_of_Chung_data
-
-        Logger.PrintInfo("Error in restitution numbers =", 100*generated_data_error,"%")
-
-        error1 = 100*generated_data_error
-
-        error2 = error3 = 0
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-
-class Benchmark10: ########## LINEAR THORNTON
-
-    def __init__(self):
-        self.number = 10
-        self.initial_normal_vel = -5.0
-        self.initial_tangential_vel = 0
-        self.radius = 0.025
-        self.normalized_impact_angle_list = []
-        self.normalized_rebound_tangential_surface_vel_list = []
-        self.normalized_rebound_angular_velocity_list = []
-        self.tangential_coefficient_of_restitution_list = []
-        self.normalized_rebound_tangential_surface_vel_list_outfile = None
-        self.normalized_rebound_angular_velocity_list_outfile = None
-        self.tangential_coefficient_of_restitution_list_outfile = None
-        self.coeff_of_restitution = -1.0
-        self.coeff_of_rest_string = None
-        self.lines_Thornton = []
-        self.lines_DEM = []
-        self.degrees = 0
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):   # Change this function name from 'set_initial_data' to 'set_initial_data'
-
-        if iteration == 1:
-            self.degrees = 1
-        else:
-            self.degrees = 50 * (iteration - 1)/number_of_points_in_the_graphic
-
-        if coeff_of_restitution_iteration==1:
-            self.coeff_of_restitution=0.25
-            self.coeff_of_rest_string='025'
-            self.lines_Thornton = [12, 13, 15, 16, 18, 19]
-            self.lines_DEM = [0, 1, 3, 4, 5, 6]
-        elif coeff_of_restitution_iteration==2:
-            self.coeff_of_restitution=0.50
-            self.coeff_of_rest_string='050'
-            self.lines_Thornton = [14, 15, 17, 18, 20, 22, 23]
-            self.lines_DEM = [0, 1, 3, 4, 5, 6, 7]
-        elif coeff_of_restitution_iteration==3:
-            self.coeff_of_restitution=0.75
-            self.coeff_of_rest_string='075'
-            self.lines_Thornton = [14, 15, 17, 18, 19, 22, 23, 24]
-            self.lines_DEM = [0, 1, 3, 4, 5, 6, 7, 8]
-        else:
-            self.coeff_of_restitution=0.90
-            self.coeff_of_rest_string='090'
-            self.lines_Thornton = [13, 14, 16, 17, 18, 21, 22, 23]
-            self.lines_DEM = [0, 1, 3, 4, 5, 6, 7, 8]
-
-        self.initial_tangential_vel = -self.initial_normal_vel * tan(self.degrees * pi / 180.0)
-
-        for node in modelpart.Nodes:
-            node.SetSolutionStepValue(VELOCITY_Y, self.initial_tangential_vel)
-            node.SetSolutionStepValue(VELOCITY_Z, self.initial_normal_vel)
-            modelpart.GetProperties()[1][COEFFICIENT_OF_RESTITUTION] = self.coeff_of_restitution
-
-        Logger.PrintInfo(self.coeff_of_restitution)
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
-
-        mu = 0.1
-
-        for node in modelpart.Nodes:
-            final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_X)
-            final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_Y)
-            normalized_impact_angle = 2.0 * tan(self.degrees * pi / 180.0) / (mu * (1 + self.coeff_of_restitution))
-            normalized_rebound_tangential_surface_vel = -2.0 * (final_tangential_center_velocity + final_angular_vel * self.radius) / (self.initial_normal_vel * mu * (1 + self.coeff_of_restitution))
-            normalized_rebound_angular_velocity = -2.0 * self.radius * final_angular_vel / (self.initial_normal_vel * mu * (1 + self.coeff_of_restitution))
-            tangential_coefficient_of_restitution = 5.0/7.0 + 2.0 * normalized_rebound_tangential_surface_vel / (7.0 * normalized_impact_angle)
-
-        self.normalized_impact_angle_list.append(normalized_impact_angle)
-        self.normalized_rebound_tangential_surface_vel_list.append(normalized_rebound_tangential_surface_vel)
-        self.normalized_rebound_angular_velocity_list.append(normalized_rebound_angular_velocity)
-        self.tangential_coefficient_of_restitution_list.append(tangential_coefficient_of_restitution)
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-
-        self.normalized_rebound_tangential_surface_vel_list_outfile_name = "benchmark10_dt_" + str(dt) + '_normalized_rebound_tangential_surface_vel_list_data.dat'
-        self.normalized_rebound_angular_velocity_list_outfile_name = "benchmark10_dt_" + str(dt) + '_normalized_rebound_angular_velocity_list_data.dat'
-        self.tangential_coefficient_of_restitution_list_outfile_name = "benchmark10_dt_" + str(dt) + '_tangential_coefficient_of_restitution_list_data.dat'
-
-        self.normalized_rebound_tangential_surface_vel_list_outfile = open(self.normalized_rebound_tangential_surface_vel_list_outfile_name, 'w')
-        self.normalized_rebound_angular_velocity_list_outfile = open(self.normalized_rebound_angular_velocity_list_outfile_name, 'w')
-        self.tangential_coefficient_of_restitution_list_outfile = open(self.tangential_coefficient_of_restitution_list_outfile_name, 'w')
-
-        for i in range(0, number_of_points_in_the_graphic):
-            self.normalized_rebound_tangential_surface_vel_list_outfile.write("%14.8f %14.8f" % (self.normalized_impact_angle_list[i], self.normalized_rebound_tangential_surface_vel_list[i]) + '\n')
-            self.normalized_rebound_angular_velocity_list_outfile.write("%14.8f %14.8f" % (self.normalized_impact_angle_list[i], self.normalized_rebound_angular_velocity_list[i]) + '\n')
-            self.tangential_coefficient_of_restitution_list_outfile.write("%14.8f %14.8f" % (self.normalized_impact_angle_list[i], self.tangential_coefficient_of_restitution_list[i]) + '\n')
-        self.normalized_rebound_tangential_surface_vel_list_outfile.close()
-        self.normalized_rebound_angular_velocity_list_outfile.close()
-        self.tangential_coefficient_of_restitution_list_outfile.close()
-
-        self.create_gnuplot_scripts(self.normalized_rebound_tangential_surface_vel_list_outfile_name,
-                                    self.normalized_rebound_angular_velocity_list_outfile_name,
-                                    self.tangential_coefficient_of_restitution_list_outfile_name,
-                                    self.coeff_of_rest_string, dt)
-
-        error1, error2, error3 = self.compute_errors(self.normalized_rebound_tangential_surface_vel_list_outfile_name,
-                                                     self.normalized_rebound_angular_velocity_list_outfile_name,
-                                                     self.tangential_coefficient_of_restitution_list_outfile_name)
-
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-
-        coeff_of_rest = '%.2f' % self.coeff_of_restitution
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-
-        if (coeff_of_rest=='0.25'):
-            error_file.write("\n===== THORNTON PAPER TESTS. FULL REGIME. LINEAR LAW =====\n\n")
-
-        error_file.write("DEM Benchmark 10:")
-
-        if (error1 < 5.0 and error2 < 5.0 and error3 < 5.0):
-            error_file.write(" OK!........ Test 10 (e=" + coeff_of_rest + ") SUCCESSFUL\n")
-        else:
-            error_file.write(" KO!........ Test 10 (e=" + coeff_of_rest + ") FAILED\n")
-        error_file.close()
-
-        self.normalized_impact_angle_list = []
-        self.normalized_rebound_tangential_surface_vel_list = []
-        self.normalized_rebound_angular_velocity_list = []
-        self.tangential_coefficient_of_restitution_list = []
-
-    def create_gnuplot_scripts(self, normalized_rebound_tangential_surface_vel_list_outfile_name,
-                                     normalized_rebound_angular_velocity_list_outfile_name,
-                                     tangential_coefficient_of_restitution_list_outfile_name,
-                                     coeff_of_rest_string, dt):
-
-        gnuplot_script_name_1 = 'benchmark10_comparison_1_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Normalized incident angle'\nset ylabel 'Normalized rebound tangential surface velocity'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:10][-2:3] '" + normalized_rebound_tangential_surface_vel_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/bench_10_norm_reb_tang_e_" + coeff_of_rest_string + ".dat' index 1 w lp ls 1 t 'Paper data'\n")
-        self.gnuplot_outfile.close()
-
-        gnuplot_script_name_2 = 'benchmark10_comparison_2_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Normalized incident angle'\nset ylabel 'Normalized final angular velocity'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:14][-6:0] '" + normalized_rebound_angular_velocity_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/bench_10_norm_reb_ang_vel_e_" + coeff_of_rest_string + ".dat' index 1 w lp ls 1 t 'Paper data'\n")
-        self.gnuplot_outfile.close()
-
-        gnuplot_script_name_3 = 'benchmark10_comparison_3_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_3, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Normalized incident angle'\nset ylabel 'Tangential coefficient of restitution'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:10][0.5:1.0] '" + tangential_coefficient_of_restitution_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/bench_10_tang_coeff_rest_e_" + coeff_of_rest_string + ".dat' index 1 w lp ls 1 t 'Paper data'\n")
-        self.gnuplot_outfile.close()
-
-        '''
-        print_gnuplot_files_on_screen(gnuplot_script_name_1)
-        print_gnuplot_files_on_screen(gnuplot_script_name_2)
-        print_gnuplot_files_on_screen(gnuplot_script_name_3)
-
-        '''
-
-    def compute_errors(self, normalized_rebound_tangential_surface_vel_list_outfile_name,
-                             normalized_rebound_angular_velocity_list_outfile_name,
-                             tangential_coefficient_of_restitution_list_outfile_name):
-        #
-        Thornton_data = []; DEM_data = []; summation_of_Thornton_data = 0
-        i = 0
-        path = "paper_data/bench_10_norm_reb_tang_e_" + self.coeff_of_rest_string + ".dat"
-        with open(path) as inf:
-            for line in inf:
-                if i in self.lines_Thornton:
-                    parts = line.split(',')
-                    Thornton_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(normalized_rebound_tangential_surface_vel_list_outfile_name) as inf:
-            extend_datafile_list(glob(normalized_rebound_tangential_surface_vel_list_outfile_name))
-            for line in inf:
-                if i in self.lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_normalized_rebound_tangential_surface_vel_error = 0
-
-        for j in Thornton_data:
-            summation_of_Thornton_data+=abs(j)
-
-        for i, j in zip(DEM_data, Thornton_data):
-            final_normalized_rebound_tangential_surface_vel_error+=abs(i-j)
-
-        final_normalized_rebound_tangential_surface_vel_error/=summation_of_Thornton_data
-
-        Logger.PrintInfo("Error in normalized rebound tangential surface velocity =", 100*final_normalized_rebound_tangential_surface_vel_error,"%")
-
-        #
-        Thornton_data = []; DEM_data = []; summation_of_Thornton_data = 0
-        i = 0
-        path = "paper_data/bench_10_norm_reb_ang_vel_e_" + self.coeff_of_rest_string + ".dat"
-        with open(path) as inf:
-            for line in inf:
-                if i in self.lines_Thornton:
-                    parts = line.split(',')
-                    Thornton_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(normalized_rebound_angular_velocity_list_outfile_name) as inf:
-            extend_datafile_list(glob(normalized_rebound_angular_velocity_list_outfile_name))
-            for line in inf:
-                if i in self.lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_normalized_rebound_angular_velocity_error = 0
-
-        for j in Thornton_data:
-            summation_of_Thornton_data+=abs(j)
-
-        for i, j in zip(DEM_data, Thornton_data):
-            final_normalized_rebound_angular_velocity_error+=abs(i-j)
-
-        final_normalized_rebound_angular_velocity_error/=summation_of_Thornton_data
-        Logger.PrintInfo("Error in normalized rebound angular velocity =", 100*final_normalized_rebound_angular_velocity_error,"%")
-
-        #
-        Thornton_data = []; DEM_data = []; summation_of_Thornton_data = 0
-        i = 0
-        path = "paper_data/bench_10_tang_coeff_rest_e_" + self.coeff_of_rest_string + ".dat"
-        with open(path) as inf:
-            for line in inf:
-                if i in self.lines_Thornton:
-                    parts = line.split(',')
-                    Thornton_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(tangential_coefficient_of_restitution_list_outfile_name) as inf:
-            extend_datafile_list(glob(tangential_coefficient_of_restitution_list_outfile_name))
-            for line in inf:
-                if i in self.lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_tangential_coefficient_of_restitution_error = 0
-
-        for j in Thornton_data:
-            summation_of_Thornton_data+=abs(j)
-
-        for i, j in zip(DEM_data, Thornton_data):
-            final_tangential_coefficient_of_restitution_error+=abs(i-j)
-
-        final_tangential_coefficient_of_restitution_error/=summation_of_Thornton_data
-        Logger.PrintInfo("Error in final tangential coefficient of restitution =", 100*final_tangential_coefficient_of_restitution_error,"%")
-        #
-        error1 = 100*final_normalized_rebound_tangential_surface_vel_error
-        error2 = 100*final_normalized_rebound_angular_velocity_error
-        error3 = 100*final_tangential_coefficient_of_restitution_error
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
-        pass
-
-
-class Benchmark11: ########## HERTZIAN THORNTON
-
-    def __init__(self):
-        self.number = 11
-        self.initial_normal_vel = -5.0
-        self.initial_tangential_vel = 0
-        self.radius = 0.025
-        self.normalized_impact_angle_list = []
-        self.normalized_rebound_tangential_surface_vel_list = []
-        self.normalized_rebound_angular_velocity_list = []
-        self.tangential_coefficient_of_restitution_list = []
-        self.normalized_rebound_tangential_surface_vel_list_outfile = None
-        self.normalized_rebound_angular_velocity_list_outfile = None
-        self.tangential_coefficient_of_restitution_list_outfile = None
-        self.coeff_of_restitution = -1.0
-        self.coeff_of_rest_string = None
-        self.lines_Thornton = []
-        self.lines_DEM = []
-        self.degrees = 0
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):   # Change this function name from 'set_initial_data' to 'set_initial_data'
-
-        if iteration == 1:
-            self.degrees = 1
-        else:
-            self.degrees = 50 * (iteration - 1)/number_of_points_in_the_graphic
-
-        if coeff_of_restitution_iteration==1:
-            self.coeff_of_restitution=0.25
-            self.coeff_of_rest_string='025'
-            self.lines_Thornton = [1, 2, 4, 5, 7, 8]
-            self.lines_DEM = [0, 1, 3, 4, 5, 6]
-        elif coeff_of_restitution_iteration==2:
-            self.coeff_of_restitution=0.50
-            self.coeff_of_rest_string='050'
-            self.lines_Thornton = [1, 2, 4, 5, 7, 9, 10]
-            self.lines_DEM = [0, 1, 3, 4, 5, 6, 7]
-        elif coeff_of_restitution_iteration==3:
-            self.coeff_of_restitution=0.75
-            self.coeff_of_rest_string='075'
-            self.lines_Thornton = [1, 2, 4, 5, 6, 8, 9, 10]
-            self.lines_DEM = [0, 1, 3, 4, 5, 6, 7, 8]
-        else:
-            self.coeff_of_restitution=0.90
-            self.coeff_of_rest_string='090'
-            #self.lines_Thornton = [1, 2, 4, 5, 6, 8, 9]
-            #self.lines_DEM = [0, 1, 3, 4, 5, 7, 8]
-            self.lines_Thornton = [1, 2, 4, 5, 6, 7, 8, 9]
-            self.lines_DEM = [0, 1, 3, 4, 5, 6, 7, 8]
-
-        self.initial_tangential_vel = -self.initial_normal_vel * tan(self.degrees * pi / 180.0)
-
-        for node in modelpart.Nodes:
-            node.SetSolutionStepValue(VELOCITY_Y, self.initial_tangential_vel)
-            node.SetSolutionStepValue(VELOCITY_Z, self.initial_normal_vel)
-            modelpart.GetProperties()[1][COEFFICIENT_OF_RESTITUTION] = self.coeff_of_restitution
-
-        Logger.PrintInfo(self.coeff_of_restitution)
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
-
-        mu = 0.1
-
-        for node in modelpart.Nodes:
-            final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_X)
-            final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_Y)
-            normalized_impact_angle = 2.0 * tan(self.degrees * pi / 180.0) / (mu * (1 + self.coeff_of_restitution))
-            normalized_rebound_tangential_surface_vel = -2.0 * (final_tangential_center_velocity + final_angular_vel * self.radius) / (self.initial_normal_vel * mu * (1 + self.coeff_of_restitution))
-            normalized_rebound_angular_velocity = -2.0 * self.radius * final_angular_vel / (self.initial_normal_vel * mu * (1 + self.coeff_of_restitution))
-            tangential_coefficient_of_restitution = 5.0/7.0 + 2.0 * normalized_rebound_tangential_surface_vel / (7.0 * normalized_impact_angle)
-
-        self.normalized_impact_angle_list.append(normalized_impact_angle)
-        self.normalized_rebound_tangential_surface_vel_list.append(normalized_rebound_tangential_surface_vel)
-        self.normalized_rebound_angular_velocity_list.append(normalized_rebound_angular_velocity)
-        self.tangential_coefficient_of_restitution_list.append(tangential_coefficient_of_restitution)
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-
-        self.normalized_rebound_tangential_surface_vel_list_outfile_name = "benchmark11_dt_" + str(dt) + '_normalized_rebound_tangential_surface_vel_list_data.dat'
-        self.normalized_rebound_angular_velocity_list_outfile_name = "benchmark11_dt_" + str(dt) + '_normalized_rebound_angular_velocity_list_data.dat'
-        self.tangential_coefficient_of_restitution_list_outfile_name = "benchmark11_dt_" + str(dt) + '_tangential_coefficient_of_restitution_list_data.dat'
-
-        self.normalized_rebound_tangential_surface_vel_list_outfile = open(self.normalized_rebound_tangential_surface_vel_list_outfile_name, 'w')
-        self.normalized_rebound_angular_velocity_list_outfile = open(self.normalized_rebound_angular_velocity_list_outfile_name, 'w')
-        self.tangential_coefficient_of_restitution_list_outfile = open(self.tangential_coefficient_of_restitution_list_outfile_name, 'w')
-
-        for i in range(0, number_of_points_in_the_graphic):
-            self.normalized_rebound_tangential_surface_vel_list_outfile.write("%14.8f %14.8f" % (self.normalized_impact_angle_list[i], self.normalized_rebound_tangential_surface_vel_list[i]) + '\n')
-            self.normalized_rebound_angular_velocity_list_outfile.write("%14.8f %14.8f" % (self.normalized_impact_angle_list[i], self.normalized_rebound_angular_velocity_list[i]) + '\n')
-            self.tangential_coefficient_of_restitution_list_outfile.write("%14.8f %14.8f" % (self.normalized_impact_angle_list[i], self.tangential_coefficient_of_restitution_list[i]) + '\n')
-        self.normalized_rebound_tangential_surface_vel_list_outfile.close()
-        self.normalized_rebound_angular_velocity_list_outfile.close()
-        self.tangential_coefficient_of_restitution_list_outfile.close()
-
-        self.create_gnuplot_scripts(self.normalized_rebound_tangential_surface_vel_list_outfile_name,
-                                    self.normalized_rebound_angular_velocity_list_outfile_name,
-                                    self.tangential_coefficient_of_restitution_list_outfile_name,
-                                    self.coeff_of_rest_string, dt)
-
-        error1, error2, error3 = self.compute_errors(self.normalized_rebound_tangential_surface_vel_list_outfile_name,
-                                                     self.normalized_rebound_angular_velocity_list_outfile_name,
-                                                     self.tangential_coefficient_of_restitution_list_outfile_name)
-
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-
-        coeff_of_rest = '%.2f' % self.coeff_of_restitution
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-
-        if (coeff_of_rest=='0.25'):
-            error_file.write("\n==== THORNTON PAPER TESTS. FULL REGIME. HERTZIAN LAW ====\n\n")
-
-        error_file.write("DEM Benchmark 11:")
-
-        if (error1 < 6.0 and error2 < 6.0 and error3 < 6.0):
-            error_file.write(" OK!........ Test 11 (e=" + coeff_of_rest + ") SUCCESSFUL\n")
-        else:
-            error_file.write(" KO!........ Test 11 (e=" + coeff_of_rest + ") FAILED\n")
-        error_file.close()
-
-        self.normalized_impact_angle_list = []
-        self.normalized_rebound_tangential_surface_vel_list = []
-        self.normalized_rebound_angular_velocity_list = []
-        self.tangential_coefficient_of_restitution_list = []
-
-    def create_gnuplot_scripts(self, normalized_rebound_tangential_surface_vel_list_outfile_name,
-                                     normalized_rebound_angular_velocity_list_outfile_name,
-                                     tangential_coefficient_of_restitution_list_outfile_name,
-                                     coeff_of_rest_string, dt):
-
-        gnuplot_script_name_1 = 'benchmark11_comparison_1_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Normalized incident angle'\nset ylabel 'Normalized rebound tangential surface velocity'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:10][-2:3] '" + normalized_rebound_tangential_surface_vel_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/bench_10_norm_reb_tang_e_" + coeff_of_rest_string + ".dat' index 0 w lp ls 1 t 'Paper data'\n")
-        self.gnuplot_outfile.close()
-
-        gnuplot_script_name_2 = 'benchmark11_comparison_2_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Normalized incident angle'\nset ylabel 'Normalized final angular velocity'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:14][-6:0] '" + normalized_rebound_angular_velocity_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/bench_10_norm_reb_ang_vel_e_" + coeff_of_rest_string + ".dat' index 0 w lp ls 1 t 'Paper data'\n")
-        self.gnuplot_outfile.close()
-
-        gnuplot_script_name_3 = 'benchmark11_comparison_3_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_3, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Normalized incident angle'\nset ylabel 'Tangential coefficient of restitution'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:10][0.5:1.0] '" + tangential_coefficient_of_restitution_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/bench_10_tang_coeff_rest_e_" + coeff_of_rest_string + ".dat' index 0 w lp ls 1 t 'Paper data'\n")
-        self.gnuplot_outfile.close()
-
-        '''
-        print_gnuplot_files_on_screen(gnuplot_script_name_1)
-        print_gnuplot_files_on_screen(gnuplot_script_name_2)
-        print_gnuplot_files_on_screen(gnuplot_script_name_3)
-        '''
-
-    def compute_errors(self, normalized_rebound_tangential_surface_vel_list_outfile_name,
-                             normalized_rebound_angular_velocity_list_outfile_name,
-                             tangential_coefficient_of_restitution_list_outfile_name):
-        #
-        Thornton_data = []; DEM_data = []; summation_of_Thornton_data = 0
-        i = 0
-        path = "paper_data/bench_10_norm_reb_tang_e_" + self.coeff_of_rest_string + ".dat"
-        with open(path) as inf:
-            for line in inf:
-                if i in self.lines_Thornton:
-                    parts = line.split(',')
-                    Thornton_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(normalized_rebound_tangential_surface_vel_list_outfile_name) as inf:
-            extend_datafile_list(glob(normalized_rebound_tangential_surface_vel_list_outfile_name))
-            for line in inf:
-                if i in self.lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_normalized_rebound_tangential_surface_vel_error = 0
-
-        for j in Thornton_data:
-            summation_of_Thornton_data+=abs(j)
-
-        for i, j in zip(DEM_data, Thornton_data):
-            final_normalized_rebound_tangential_surface_vel_error+=abs(i-j)
-
-        final_normalized_rebound_tangential_surface_vel_error/=summation_of_Thornton_data
-
-        Logger.PrintInfo("Error in normalized rebound tangential surface velocity =", 100*final_normalized_rebound_tangential_surface_vel_error,"%")
-
-        #
-        Thornton_data = []; DEM_data = []; summation_of_Thornton_data = 0
-        i = 0
-        path = "paper_data/bench_10_norm_reb_ang_vel_e_" + self.coeff_of_rest_string + ".dat"
-        with open(path) as inf:
-            for line in inf:
-                if i in self.lines_Thornton:
-                    parts = line.split(',')
-                    Thornton_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(normalized_rebound_angular_velocity_list_outfile_name) as inf:
-            extend_datafile_list(glob(normalized_rebound_angular_velocity_list_outfile_name))
-            for line in inf:
-                if i in self.lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_normalized_rebound_angular_velocity_error = 0
-
-        for j in Thornton_data:
-            summation_of_Thornton_data+=abs(j)
-
-        for i, j in zip(DEM_data, Thornton_data):
-            final_normalized_rebound_angular_velocity_error+=abs(i-j)
-
-        final_normalized_rebound_angular_velocity_error/=summation_of_Thornton_data
-        Logger.PrintInfo("Error in normalized rebound angular velocity =", 100*final_normalized_rebound_angular_velocity_error,"%")
-
-        #
-        Thornton_data = []; DEM_data = []; summation_of_Thornton_data = 0
-        i = 0
-        path = "paper_data/bench_10_tang_coeff_rest_e_" + self.coeff_of_rest_string + ".dat"
-        with open(path) as inf:
-            for line in inf:
-                if i in self.lines_Thornton:
-                    parts = line.split(',')
-                    Thornton_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(tangential_coefficient_of_restitution_list_outfile_name) as inf:
-            extend_datafile_list(glob(tangential_coefficient_of_restitution_list_outfile_name))
-            for line in inf:
-                if i in self.lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        final_tangential_coefficient_of_restitution_error = 0
-
-        for j in Thornton_data:
-            summation_of_Thornton_data+=abs(j)
-
-        for i, j in zip(DEM_data, Thornton_data):
-            final_tangential_coefficient_of_restitution_error+=abs(i-j)
-
-        final_tangential_coefficient_of_restitution_error/=summation_of_Thornton_data
-        Logger.PrintInfo("Error in final tangential coefficient of restitution =", 100*final_tangential_coefficient_of_restitution_error,"%")
-
-        #
-        error1 = 100*final_normalized_rebound_tangential_surface_vel_error
-        error2 = 100*final_normalized_rebound_angular_velocity_error
-        error3 = 100*final_tangential_coefficient_of_restitution_error
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
-        pass
-
-
-class Benchmark12: ########## ROLLING FRICTION
-
-    def __init__(self):
-        self.number = 12
-
-        self.balls_graph_counter = 1
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.simulation_graph = open(self.output_filename, 'w')
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
-
-        self.simulation_graph.close()
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
-
-        self.graph_frequency        = int(graph_print_interval/dt)
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
-
-        if(self.balls_graph_counter == self.graph_frequency):
-            self.balls_graph_counter = 0
-            total_angular_velocity_z = 0.0
-
-            for node in modelpart.Nodes:
-                if node.Id == 1:
-                   angular_velocity_z = node.GetSolutionStepValue(ANGULAR_VELOCITY_Z)
-                   total_angular_velocity_z += angular_velocity_z
-
-                del node
-
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_angular_velocity_z).rjust(13)+"\n")
-        self.balls_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
-
-        error1, error2, error3 = self.compute_errors(self.output_filename)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-        error_file.write("\n\n")
-        error_file.write("==== WENSRICH PAPER TEST. ROLLING FRICTION ====\n\n")
-        error_file.write("DEM Benchmark 12:")
-
-        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
-            error_file.write(" OK!........ Test 12 SUCCESSFUL\n")
-        else:
-            error_file.write(" KO!........ Test 12 FAILED\n")
-        error_file.close()
-
-    def compute_errors(self, output_filename):
-
-        lines_analytics = lines_DEM = list(range(0, 1000));
-        analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
-        i = 0
-        with open('paper_data/benchmark' + str(sys.argv[1]) + '_graph.dat') as inf:
-            for line in inf:
-                if i in lines_analytics:
-                    parts = line.split()
-                    analytics_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))
-                i+=1
-        generated_data_error = 0
-
-        for j in analytics_data:
-            summation_of_analytics_data+=abs(j)
-
-        for i, j in zip(DEM_data, analytics_data):
-            generated_data_error+=abs(i-j)
-        generated_data_error/=summation_of_analytics_data
-
-        Logger.PrintInfo("Error in simulation =", 100*generated_data_error,"%")
-
-        error1 = 100*generated_data_error
-
-        error2 = error3 = 0
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-    def create_gnuplot_scripts(self, output_filename, dt):
-        pass
-
-
-class Benchmark13: ########## DEM-FEM Facet
-
-    def __init__(self):
-        self.number = 13
-
-        self.balls_graph_counter = 1   # deberia ser self.balls_graph_counter = self.graph_frequency
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        self.velocity_list_outfile_name = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.simulation_graph = open(self.velocity_list_outfile_name, 'w')
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
-
-        self.simulation_graph.close()
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
-
-        self.graph_frequency        = int(graph_print_interval/dt)
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
-
-        if(self.balls_graph_counter == self.graph_frequency):     #if(self.balls_graph_counter == self.graph_frequency):
-            self.balls_graph_counter = 0
-            total_velocity_x = 0.0
-            total_velocity_z = 0.0
-
-            for node in modelpart.Nodes:
-                if node.Id == 1:
-                   velocity_x = node.GetSolutionStepValue(VELOCITY_X)
-                   velocity_z = node.GetSolutionStepValue(VELOCITY_Z)
-                   total_velocity_x += velocity_x
-                   total_velocity_z += velocity_z
-
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_velocity_x).rjust(13)+" "+str("%.6g"%total_velocity_z).rjust(13)+"\n")
-        self.balls_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
-
-        error1, error2, error3 = self.compute_errors(self.velocity_list_outfile_name)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-        error_file.write("\n\n")
-        error_file.write("======== DE/FE CONTACT BENCHMARKS ==========\n\n")
-        error_file.write("DEM Benchmark 13:")
-
-        if (error1 < 0.01 and error2 < 0.01 and error3 <0.01):
-            error_file.write(" OK!........ Test 13 SUCCESSFUL\n")
-        else:
-            error_file.write(" KO!........ Test 13 FAILED\n")
-        error_file.close()
-
-    def compute_errors(self, output_filename):  #FINALIZATION STEP
-
-        lines_DEM = list(range(0, 200));
-        total_velocity_x = 0.0; total_velocity_z = 0.0
-        i = 0
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    total_velocity_x += float(parts[1])
-                    total_velocity_z += float(parts[2])
-                i+=1
-
-        if total_velocity_x > 0.0:  #VELOCITY_X should be 0 always
-            error1 = 100
-        else:
-            error1 = 0
-
-        if total_velocity_z > 0.0:  #VELOCITY_Z should be 0 always
-            error2 = 100
-        else:
-            error2 = 0
-
-        error3 = 0
-
-        Logger.PrintInfo("Error in velocity X =", error1,"%")
-
-        Logger.PrintInfo("Error in velocity Z =", error2,"%")
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-class Benchmark14: ########## DEM-FEM Edge
-
-    def __init__(self):
-        self.number = 14
-
-        self.balls_graph_counter = 1   # deberia ser self.balls_graph_counter = self.graph_frequency
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        self.velocity_list_outfile_name = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.simulation_graph = open(self.velocity_list_outfile_name, 'w')
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
-
-        self.simulation_graph.close()
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
-
-        self.graph_frequency        = int(graph_print_interval/dt)
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
-
-        if(self.balls_graph_counter == self.graph_frequency):     #if(self.balls_graph_counter == self.graph_frequency):
-            self.balls_graph_counter = 0
-            total_velocity_x = 0.0
-            total_velocity_z = 0.0
-
-            for node in modelpart.Nodes:
-                if node.Id == 1:
-                   velocity_x = node.GetSolutionStepValue(VELOCITY_X)
-                   velocity_z = node.GetSolutionStepValue(VELOCITY_Z)
-                   total_velocity_x += velocity_x
-                   total_velocity_z += velocity_z
-
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_velocity_x).rjust(13)+" "+str("%.6g"%total_velocity_z).rjust(13)+"\n")
-        self.balls_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
-
-        error1, error2, error3 = self.compute_errors(self.velocity_list_outfile_name)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-        error_file.write("DEM Benchmark 14:")
-
-        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
-            error_file.write(" OK!........ Test 14 SUCCESSFUL\n")
-        else:
-            error_file.write(" KO!........ Test 14 FAILED\n")
-        error_file.close()
-
-    def compute_errors(self, output_filename):  #FINALIZATION STEP
-
-        lines_DEM = list(range(0, 200));
-        total_velocity_x = 0.0; total_velocity_z = 0.0
-        i = 0
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    total_velocity_x += float(parts[1])
-                    total_velocity_z += float(parts[2])
-                i+=1
-
-        if total_velocity_x > 0.0:  #VELOCITY_X should be 0 always
-            error1 = 100
-        else:
-            error1 = 0
-
-        if total_velocity_z > 0.0:  #VELOCITY_Z should be 0 always
-            error2 = 100
-        else:
-            error2 = 0
-
-        error3 = 0
-
-        Logger.PrintInfo("Error in velocity X =", error1,"%")
-
-        Logger.PrintInfo("Error in velocity Z =", error2,"%")
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-class Benchmark15: ########## DEM-FEM Vertex
-
-    def __init__(self):
-        self.number = 15
-
-        self.balls_graph_counter = 1   # deberia ser self.balls_graph_counter = self.graph_frequency
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        self.velocity_list_outfile_name = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.simulation_graph = open(self.velocity_list_outfile_name, 'w')
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
-
-        self.simulation_graph.close()
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
-
-        self.graph_frequency        = int(graph_print_interval/dt)
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
-
-        if(self.balls_graph_counter == self.graph_frequency):     #if(self.balls_graph_counter == self.graph_frequency):
-            self.balls_graph_counter = 0
-            total_velocity_x = 0.0
-            total_velocity_z = 0.0
-
-            for node in modelpart.Nodes:
-                if node.Id == 1:
-                   velocity_x = node.GetSolutionStepValue(VELOCITY_X)
-                   velocity_z = node.GetSolutionStepValue(VELOCITY_Z)
-                   total_velocity_x += velocity_x
-                   total_velocity_z += velocity_z
-
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_velocity_x).rjust(13)+" "+str("%.6g"%total_velocity_z).rjust(13)+"\n")
-        self.balls_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
-
-        error1, error2, error3 = self.compute_errors(self.velocity_list_outfile_name)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-        error_file.write("DEM Benchmark 15:")
-
-        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
-            error_file.write(" OK!........ Test 15 SUCCESSFUL\n")
-        else:
-            error_file.write(" KO!........ Test 15 FAILED\n")
-        error_file.close()
-
-    def compute_errors(self, output_filename):  #FINALIZATION STEP
-
-        lines_DEM = list(range(0, 200));
-        total_velocity_x = 0.0; total_velocity_z = 0.0
-        i = 0
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    total_velocity_x += float(parts[1])
-                    total_velocity_z += float(parts[2])
-                i+=1
-
-        if total_velocity_x > 0.0:  #VELOCITY_X should be 0 always
-            error1 = 100
-        else:
-            error1 = 0
-
-        if total_velocity_z > 0.0:  #VELOCITY_Z should be 0 always
-            error2 = 100
-        else:
-            error2 = 0
-
-        error3 = 0
-
-        Logger.PrintInfo("Error in velocity X =", error1,"%")
-
-        Logger.PrintInfo("Error in velocity Z =", error2,"%")
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-
-class Benchmark16: ########## DEM-FEM Grid
-
-    def __init__(self):
-        self.number = 16
-
-        self.balls_graph_counter = 1   # deberia ser self.balls_graph_counter = self.graph_frequency
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        self.velocity_list_outfile_name = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.simulation_graph = open(self.velocity_list_outfile_name, 'w')
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
-
-        self.simulation_graph.close()
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
-
-        self.graph_frequency        = int(graph_print_interval/dt)
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
-
-        if(self.balls_graph_counter == self.graph_frequency):     #if(self.balls_graph_counter == self.graph_frequency):
-            self.balls_graph_counter = 0
-            total_velocity_1 = 0.0
-            total_velocity_2 = 0.0
-            total_velocity_3 = 0.0
-
-            for node in modelpart.Nodes:
-                if node.Id == 1:
-                   velocity_1 = node.GetSolutionStepValue(VELOCITY_Y)
-                   total_velocity_1 += velocity_1
-                if node.Id == 2:
-                   velocity_2 = node.GetSolutionStepValue(VELOCITY_Y)
-                   total_velocity_2 += velocity_2
-                if node.Id == 3:
-                   velocity_3 = node.GetSolutionStepValue(VELOCITY_Y)
-                   total_velocity_3 += velocity_3
-
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_velocity_1).rjust(13)+" "+str("%.6g"%total_velocity_2).rjust(13)+" "+str("%.6g"%total_velocity_3).rjust(13)+"\n")
-        self.balls_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
-
-        error1, error2, error3 = self.compute_errors(self.velocity_list_outfile_name)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-        error_file.write("DEM Benchmark 16:")
-
-        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
-            error_file.write(" OK!........ Test 16 SUCCESSFUL\n")
-        else:
-            error_file.write(" KO!........ Test 16 FAILED\n")
-        error_file.close()
-
-    def compute_errors(self, output_filename):  #FINALIZATION STEP
-
-        lines_analytics = lines_DEM = list(range(0, 250));
-        ref_data1 = []; ref_data2 = []; DEM_data1 = []; ref_data3 = []; DEM_data1 = []; DEM_data2 = []; DEM_data3 = []; summation_of_ref_data1 = 0; summation_of_ref_data2 = 0; summation_of_ref_data3 = 0
-        times = []
-        i = 0
-        with open('paper_data/benchmark' + str(sys.argv[1]) + '_graph.dat') as inf:  #with open('paper_data/reference_graph_benchmark12.dat') as inf:
-            for line in inf:
-                if i in lines_analytics:
-                    parts = line.split()
-                    times.append(float(parts[0]))
-                    ref_data1.append(float(parts[1]))
-                    ref_data2.append(float(parts[2]))
-                    ref_data3.append(float(parts[3]))
-                i+=1
-        i = 0
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data1.append(float(parts[1]))
-                    DEM_data2.append(float(parts[2]))
-                    DEM_data3.append(float(parts[3]))
-                i+=1
-        final_velocity_1_error = 0
-        final_velocity_2_error = 0
-        final_velocity_3_error = 0
-
-        for j in ref_data1:
-            summation_of_ref_data1+=abs(j)
-        for k in ref_data2:
-            summation_of_ref_data2+=abs(k)
-        for l in ref_data3:
-            summation_of_ref_data3+=abs(l)
-
-        for i, j in zip(DEM_data1, ref_data1):
-            final_velocity_1_error+=abs(i-j)
-        final_velocity_1_error/=summation_of_ref_data1
-
-        for k, l in zip(DEM_data2, ref_data2):
-            final_velocity_2_error+=abs(k-l)
-        final_velocity_2_error/=summation_of_ref_data2
-
-        for m, n in zip(DEM_data3, ref_data3):
-            final_velocity_3_error+=abs(m-n)
-        final_velocity_3_error/=summation_of_ref_data3
-
-        #for t, v1,v2,v3 in zip(times, DEM_data1, DEM_data2, DEM_data3):
-        #    Logger.PrintInfo(t, v1, v2, v3)
-
-        Logger.PrintInfo("Error in velocity sphere 1 =", 100*final_velocity_1_error,"%")
-
-        Logger.PrintInfo("Error in velocity sphere 2 =", 100*final_velocity_2_error,"%")
-
-        Logger.PrintInfo("Error in velocity sphere 3 =", 100*final_velocity_3_error,"%")
-
-        error1 = 100*final_velocity_1_error
-
-        error2 = 100*final_velocity_2_error
-
-        error3 = 100*final_velocity_3_error
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-
-class Benchmark17: ########## DEM-FEM Rolling
-
-    def __init__(self):
-        self.number = 17
-
-        self.balls_graph_counter = 1   # deberia ser self.balls_graph_counter = self.graph_frequency
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        self.error_list_outfile_name = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.simulation_graph = open(self.error_list_outfile_name, 'w')
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
-
-        self.simulation_graph.close()
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
-
-        self.graph_frequency        = int(graph_print_interval/dt)
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
-
-        if(self.balls_graph_counter == self.graph_frequency):     #if(self.balls_graph_counter == self.graph_frequency):
-            self.balls_graph_counter = 0
-            total_velocity_err         = 0.0
-            total_angular_velocity_err = 0.0
-
-            for node in modelpart.Nodes:
-                if node.Id == 1:
-                   velocity_1         = node.GetSolutionStepValue(VELOCITY_X)
-                   angular_velocity_1 = node.GetSolutionStepValue(ANGULAR_VELOCITY_Z)
-                if node.Id == 2:
-                   velocity_2         = node.GetSolutionStepValue(VELOCITY_X)
-                   angular_velocity_2 = node.GetSolutionStepValue(ANGULAR_VELOCITY_Z)
-
-            total_velocity_err         = (abs(velocity_1 - velocity_2))/(abs(velocity_2))
-            total_angular_velocity_err = (abs(angular_velocity_1 - angular_velocity_2))/(abs(velocity_2))
-
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_velocity_err).rjust(13)+" "+str("%.6g"%total_angular_velocity_err).rjust(13)+"\n")
-        self.balls_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
-
-        error1, error2, error3 = self.compute_errors(self.error_list_outfile_name)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-        error_file.write("DEM Benchmark 17:")
-
-        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
-            error_file.write(" OK!........ Test 17 SUCCESSFUL\n")
-        else:
-            error_file.write(" KO!........ Test 17 FAILED\n")
-        error_file.close()
-
-    def compute_errors(self, output_filename):  #FINALIZATION STEP
-
-        lines_DEM = list(range(0, 100));
-        total_velocity_err = 0.0; total_angular_velocity_err = 0.0
-        i = 0
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    total_velocity_err += float(parts[1])
-                    total_angular_velocity_err += float(parts[2])
-                i+=1
-
-        if total_velocity_err > 1e-2:  #VELOCITY_X should be 0 always
-            error1 = 100*total_velocity_err
-        else:
-            error1 = 0
-
-        if total_angular_velocity_err > 1e-2:  #VELOCITY_Z should be 0 always
-            error2 = 100*total_angular_velocity_err
-        else:
-            error2 = 0
-
-        error3 = 0
-
-        Logger.PrintInfo("Error in velocity between meshes =", 100*total_velocity_err,"%")
-
-        Logger.PrintInfo("Error in angular velocity between meshes =", 100*total_angular_velocity_err,"%")
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-
-class Benchmark20:
-
-    def __init__(self):
-        self.number = 20
-        self.generated_data = None
-        #self.graph_frequency = int(graph_print_interval/dt)  # def __init__(self, graph_print_interval, dt):
-        self.balls_graph_counter = 1   # deberia ser self.balls_graph_counter = self.graph_frequency
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):  #INITIALIZATION STEP
-        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.simulation_graph = open(self.output_filename, 'w')
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
-        self.simulation_graph.close()
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
-        self.graph_frequency        = int(graph_print_interval/dt)
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
-
-        if(self.balls_graph_counter == self.graph_frequency):     #if(self.balls_graph_counter == self.graph_frequency):
-            self.balls_graph_counter = 0
-            self.total_force_x = 0.0
-            self.total_force_y = 0.0
-
-            for node in modelpart.Nodes:
-                if node.Id == 141:
-                   force_node_x = node.GetSolutionStepValue(ELASTIC_FORCES)[0]
-                   force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-                   self.total_force_x += force_node_x
-                   self.total_force_y += force_node_y
-
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_x).rjust(13)+" "+str("%.6g"%self.total_force_y).rjust(13)+"\n")
-        self.balls_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-
-        '''
-        gnuplot_script_name = 'benchmark3_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name, 'w')
-        self.gnuplot_outfile.write("set grid; plot '" + self.output_filename + "' u 1:2 w lp lt 3 lw 1.5 ps 2 pt 4, '"\
-                                                      + self.output_filename + "' u 1:3 w lp lt 2 lw 1.5 ps 2 pt 6")
-        self.gnuplot_outfile.close()
-        self.create_gnuplot_scripts(self.output_filename, dt)
-        '''
-
-        error1, error2, error3 = self.compute_errors(self.output_filename)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-        error_file.write("\n\n")
-        error_file.write("== BASIC CONTINUUM TESTS ==\n\n")
-        error_file.write("DEM Benchmark 20:")
-
-        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
-            error_file.write(" OK!........ Test 20 SUCCESSFUL\n")
-            shutil.rmtree('benchmark20_Post_Files', ignore_errors = True)
-        else:
-            error_file.write(" KO!........ Test 20 FAILED\n")
-        error_file.close()
-
-    def compute_errors(self, output_filename):  #FINALIZATION STEP
-        lines_analytics = lines_DEM = list(range(0, 1000));
-        analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
-        i = 0
-        with open('paper_data/reference_graph_benchmark' + str(sys.argv[1]) + '.dat') as inf:
-            for line in inf:
-                if i in lines_analytics:
-                    parts = line.split()
-                    analytics_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))   #segona component del vector ()
-                i+=1
-        generated_data_error = 0
-
-        for j in analytics_data:
-            summation_of_analytics_data+=abs(j)
-
-        for i, j in zip(DEM_data, analytics_data):
-            generated_data_error+=abs(i-j)
-        generated_data_error/=summation_of_analytics_data
-
-        Logger.PrintInfo("Error in simulation =", 100*generated_data_error,"%")
-
-        error1 = 100*generated_data_error
-
-        error2 = error3 = 0
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-    def create_gnuplot_scripts(self, output_filename, dt):
-        pass
-        '''
-        gnuplot_script_name_1 = 'benchmark20_comparison_1_dt_' + str(dt) + 's.gp'
-        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
-        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Data'\nset ylabel 'Damping ratio'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt  3 ps 3\n")
-        self.gnuplot_outfile.write("plot [0:1][0:1] '" + output_filename + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark20_graph1.dat' w lp ls 1 t 'Al. oxide',\\\n")
-        self.gnuplot_outfile.write("'paper_data/benchmark20_graph1.dat' w lp ls 2 t 'Cast iron'\n")
-        self.gnuplot_outfile.close()
-        print_gnuplot_files_on_screen(gnuplot_script_name_1)
-        '''
-
-class Benchmark21:
-
-    def __init__(self):
-        self.number = 21
-        self.generated_data = None
-        #self.graph_frequency = int(graph_print_interval/dt)  # def __init__(self, graph_print_interval, dt):
-        self.balls_graph_counter = 1   # deberia ser self.balls_graph_counter = self.graph_frequency
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):  #INITIALIZATION STEP
-        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.simulation_graph = open(self.output_filename, 'w')
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):        #FINALIZATION STEP
-        self.simulation_graph.close()
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
-        self.graph_frequency        = int(graph_print_interval/dt)
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
-
-        if(self.balls_graph_counter == self.graph_frequency):     #if(self.balls_graph_counter == self.graph_frequency):
-            self.balls_graph_counter = 0
-            self.total_force_x = 0.0
-            self.total_force_y = 0.0
-
-            for node in modelpart.Nodes:
-                if node.Id == 141:
-                   force_node_x = node.GetSolutionStepValue(ELASTIC_FORCES)[0]
-                   force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-                   self.total_force_x += force_node_x
-                   self.total_force_y += force_node_y
-
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_x).rjust(13)+" "+str("%.6g"%self.total_force_y).rjust(13)+"\n")
-        self.balls_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-        error1, error2, error3 = self.compute_errors(self.output_filename)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-        error_file.write("DEM Benchmark 21:")
-
-        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
-            error_file.write(" OK!........ Test 21 SUCCESSFUL\n")
-            shutil.rmtree('benchmark21_Post_Files', ignore_errors = True)
-        else:
-            error_file.write(" KO!........ Test 21 FAILED\n")
-        error_file.close()
-
-
-    def compute_errors(self, output_filename):  #FINALIZATION STEP
-        lines_analytics = lines_DEM = list(range(0, 1000));
-        analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
-        i = 0
-        with open('paper_data/reference_graph_benchmark' + str(sys.argv[1]) + '.dat') as inf:
-            for line in inf:
-                if i in lines_analytics:
-                    parts = line.split()
-                    analytics_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))   #segona component del vector ()
-                i+=1
-        generated_data_error = 0
-
-        for j in analytics_data:
-            summation_of_analytics_data+=abs(j)
-
-        for i, j in zip(DEM_data, analytics_data):
-            generated_data_error+=abs(i-j)
-        generated_data_error/=summation_of_analytics_data
-
-        Logger.PrintInfo("Error in simulation =", 100*generated_data_error,"%")
-        error1 = 100*generated_data_error
-        error2 = error3 = 0
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-    def create_gnuplot_scripts(self, output_filename, dt):
-        pass
-
-
-class Benchmark22:
-
-    def __init__(self):
-        self.number = 22
-        self.generated_data = None
-        #self.graph_frequency = int(graph_print_interval/dt)  # def __init__(self, graph_print_interval, dt):
-        self.balls_graph_counter = 1   # deberia ser self.balls_graph_counter = self.graph_frequency
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):  #INITIALIZATION STEP
-        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.simulation_graph = open(self.output_filename, 'w')
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):        #FINALIZATION STEP
-        self.simulation_graph.close()
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
-        self.graph_frequency        = int(graph_print_interval/dt)
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
-
-        if(self.balls_graph_counter == self.graph_frequency):     #if(self.balls_graph_counter == self.graph_frequency):
-            self.balls_graph_counter = 0
-            self.total_force_x = 0.0
-            self.total_force_y = 0.0
-
-            for node in modelpart.Nodes:
-                if node.Id == 141:
-                   force_node_x = node.GetSolutionStepValue(ELASTIC_FORCES)[0]
-                   force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-                   self.total_force_x += force_node_x
-                   self.total_force_y += force_node_y
-
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_x).rjust(13)+" "+str("%.6g"%self.total_force_y).rjust(13)+"\n")
-        self.balls_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-        error1, error2, error3 = self.compute_errors(self.output_filename)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-        error_file.write("DEM Benchmark 22:")
-
-        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
-            error_file.write(" OK!........ Test 22 SUCCESSFUL\n")
-            shutil.rmtree('benchmark22_Post_Files', ignore_errors = True)
-        else:
-            error_file.write(" KO!........ Test 22 FAILED\n")
-        error_file.close()
-
-    def compute_errors(self, output_filename):
-        lines_analytics = lines_DEM = list(range(0, 1000));
-        analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
-        i = 0
-        with open('paper_data/reference_graph_benchmark' + str(sys.argv[1]) + '.dat') as inf:
-            for line in inf:
-                if i in lines_analytics:
-                    parts = line.split()
-                    analytics_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))   #segona component del vector ()
-                i+=1
-        generated_data_error = 0
-
-        for j in analytics_data:
-            summation_of_analytics_data+=abs(j)
-
-        for i, j in zip(DEM_data, analytics_data):
-            generated_data_error+=abs(i-j)
-        generated_data_error/=summation_of_analytics_data
-
-        Logger.PrintInfo("Error in simulation =", 100*generated_data_error,"%")
-        error1 = 100*generated_data_error
-        error2 = error3 = 0
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-    def create_gnuplot_scripts(self, output_filename, dt):
-        pass
-
-class Benchmark23:
-
-    def __init__(self):
-        self.number = 23
-        self.generated_data = None
-        #self.graph_frequency = int(graph_print_interval/dt)  # def __init__(self, graph_print_interval, dt):
-        self.balls_graph_counter = 1   # deberia ser self.balls_graph_counter = self.graph_frequency
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):  #INITIALIZATION STEP
-        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.simulation_graph = open(self.output_filename, 'w')
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):        #FINALIZATION STEP
-        self.simulation_graph.close()
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
-        #Logger.PrintInfo("generate_graph_points bench23, graph_print_interval, dt - ", graph_print_interval, dt )
-        self.graph_frequency        = int(graph_print_interval/dt)
-
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
-
-        if(self.balls_graph_counter == self.graph_frequency):     #if(self.balls_graph_counter == self.graph_frequency):
-            self.balls_graph_counter = 0
-            self.total_force_x = 0.0
-            self.total_force_y = 0.0
-
-            for node in modelpart.Nodes:
-                if node.Id == 141:
-                   force_node_x = node.GetSolutionStepValue(ELASTIC_FORCES)[0]
-                   force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-                   self.total_force_x += force_node_x
-                   self.total_force_y += force_node_y
-
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_x).rjust(13)+" "+str("%.6g"%self.total_force_y).rjust(13)+"\n")
-        self.balls_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
-        error1, error2, error3 = self.compute_errors(self.output_filename)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-        error_file.write("DEM Benchmark 23:")
-
-        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
-            error_file.write(" OK!........ Test 23 SUCCESSFUL\n")
-            shutil.rmtree('benchmark23_Post_Files', ignore_errors = True)
-        else:
-            error_file.write(" KO!........ Test 23 FAILED\n")
-        error_file.close()
-
-    def compute_errors(self, output_filename):  #FINALIZATION STEP
-        lines_analytics = lines_DEM = list(range(0, 1000));
-        analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
-        i = 0
-        with open('paper_data/reference_graph_benchmark' + '23' + '.dat') as inf:
-            for line in inf:
-                if i in lines_analytics:
-                    parts = line.split()
-                    analytics_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))   #segona component del vector ()
-                i+=1
-        generated_data_error = 0
-
-        for j in analytics_data:
-            summation_of_analytics_data+=abs(j)
-
-        for i, j in zip(DEM_data, analytics_data):
-            generated_data_error+=abs(i-j)
-        generated_data_error/=summation_of_analytics_data
-
-        Logger.PrintInfo("Error in simulation =", 100*generated_data_error,"%")
-        error1 = 100*generated_data_error
-        error2 = error3 = 0
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-    def create_gnuplot_scripts(self, output_filename, dt):
-        pass
-
-
-class Benchmark24:
-
-    def __init__(self):
-        self.number = 24
-        self.generated_data = None
-        self.balls_graph_counter = 1
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):
-        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.simulation_graph = open(self.output_filename, 'w')
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
-        self.simulation_graph.close()
-
-    def cross_product(self, a, b):
-        c = [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]
-        return c
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        ang_vel = 20 * pi
-        angular_velocity = [0, 0, ang_vel]
-        rotation_matrix = [[cos(ang_vel * time), -1.0 * sin(ang_vel * time), 0], [sin(ang_vel * time), cos(ang_vel * time), 0], [0,0,1]]
-        time_dt = time - dt
-        rotation_matrix_minus_dt = [[cos(ang_vel * time_dt), -1.0 * sin(ang_vel * time_dt), 0], [sin(ang_vel * time_dt), cos(ang_vel * time_dt), 0], [0,0,1]] #
-        centroid = [-1.0, 0.0, 0.0]
-        relative_initial_node_coords, relative_node_coords, relative_node_coords_dt = [0]*3, [0]*3, [0]*3
-        sum, sum_dt = 0, 0
-
-        for node in modelpart.Nodes:
-            if node.Id == 141:
-                for j in range(3):
-                    rot_mat = rotation_matrix[j]
-                    rot_mat_dt = rotation_matrix_minus_dt[j]
-                    relative_initial_node_coords[0] = node.X0 - centroid[0]
-                    relative_initial_node_coords[1] = node.Y0 - centroid[1]
-                    relative_initial_node_coords[2] = node.Z0 - centroid[2]
-                    for i in range(3):
-                        sum += rot_mat[i] * relative_initial_node_coords[i]
-                        sum_dt += rot_mat_dt[i] * relative_initial_node_coords[i]
-                    relative_node_coords[j], sum, relative_node_coords_dt[j], sum_dt = sum, 0, sum_dt, 0
-                node.X = relative_node_coords[0] + centroid[0]
-                node.Y = relative_node_coords[1] + centroid[1]
-                node.Z = relative_node_coords[2] + centroid[2]
-
-                displacement = GetDisplacement(node)
-                node.SetSolutionStepValue(DISPLACEMENT, displacement)
-
-                velocity = [0]*3
-                velocity = self.cross_product(angular_velocity, relative_node_coords)
-                node.SetSolutionStepValue(VELOCITY, velocity)
-
-                angular_velocity = [0]*3
-                node.SetSolutionStepValue(ANGULAR_VELOCITY, angular_velocity)
-
-                delta_displacement = [0]*3
-                delta_displacement[0] = relative_node_coords[0] - relative_node_coords_dt[0]
-                delta_displacement[1] = relative_node_coords[1] - relative_node_coords_dt[1]
-                delta_displacement[2] = relative_node_coords[2] - relative_node_coords_dt[2]
-                node.SetSolutionStepValue(DELTA_DISPLACEMENT, delta_displacement)
-
-                particle_rotation_angle = [0]*3
-                particle_rotation_angle[0] = angular_velocity[0] * time
-                particle_rotation_angle[1] = angular_velocity[1] * time
-                particle_rotation_angle[2] = angular_velocity[2] * time
-                node.SetSolutionStepValue(PARTICLE_ROTATION_ANGLE, particle_rotation_angle)
-
-                delta_rotation = [0]*3
-                delta_rotation[0] = angular_velocity[0] * dt
-                delta_rotation[1] = angular_velocity[1] * dt
-                delta_rotation[2] = angular_velocity[2] * dt
-                node.SetSolutionStepValue(DELTA_ROTATION, delta_rotation)
-
-            if node.Id == 140:
-                angular_velocity = [0]*3
-                node.SetSolutionStepValue(ANGULAR_VELOCITY, angular_velocity)
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
-        #Logger.PrintInfo("generate_graph_points bench24, graph_print_interval, dt - ", graph_print_interval, dt )
-        self.graph_frequency = int(graph_print_interval/dt)
-
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1
-
-        if (self.balls_graph_counter == self.graph_frequency):
-            self.balls_graph_counter = 0
-            self.total_force_x = 0.0
-            self.total_force_y = 0.0
-
-            for node in modelpart.Nodes:
-                if node.Id == 141:
-                   force_node_x = node.GetSolutionStepValue(ELASTIC_FORCES)[0]
-                   force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-                   self.total_force_x += force_node_x
-                   self.total_force_y += force_node_y
-
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_x).rjust(13)+" "+str("%.6g"%self.total_force_y).rjust(13)+"\n")
-        self.balls_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-        error1, error2, error3 = self.compute_errors(self.output_filename)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-        error_file.write("DEM Benchmark 24:")
-
-        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
-            error_file.write(" OK!........ Test 24 SUCCESSFUL\n")
-            shutil.rmtree('benchmark24_Post_Files', ignore_errors = True)
-        else:
-            error_file.write(" KO!........ Test 24 FAILED\n")
-        error_file.close()
-
-    def compute_errors(self, output_filename):
-        lines_analytics = lines_DEM = list(range(0, 1000));
-        analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
-        i = 0
-        with open('paper_data/reference_graph_benchmark' + '24' + '.dat') as inf:
-            for line in inf:
-                if i in lines_analytics:
-                    parts = line.split()
-                    analytics_data.append(float(parts[2]))
-                i+=1
-        i = 0
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[2]))   #segona component del vector ()
-                i+=1
-        generated_data_error = 0
-
-        for j in analytics_data:
-            summation_of_analytics_data+=abs(j)
-
-        for i, j in zip(DEM_data, analytics_data):
-            generated_data_error+=abs(i-j)
-        generated_data_error/=summation_of_analytics_data
-
-        Logger.PrintInfo("Error in simulation =", 100*generated_data_error,"%")
-        error1 = 100*generated_data_error
-        error2 = error3 = 0
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-    def create_gnuplot_scripts(self, output_filename, dt):
-        pass
-
-
-class Benchmark25:
-
-    def __init__(self):
-        self.number = 25
-        self.generated_data = None
-        self.balls_graph_counter = 1
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):
-        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.simulation_graph = open(self.output_filename, 'w')
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
-        self.simulation_graph.close()
-
-    def cross_product(self, a, b):
-        c = [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]
-        return c
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        ang_vel = 20 * pi
-        angular_velocity = [0, 0, ang_vel]
-        rotation_matrix = [[cos(ang_vel * time), -1.0 * sin(ang_vel * time), 0], [sin(ang_vel * time), cos(ang_vel * time), 0], [0,0,1]]
-        time_dt = time - dt
-        rotation_matrix_minus_dt = [[cos(ang_vel * time_dt), -1.0 * sin(ang_vel * time_dt), 0], [sin(ang_vel * time_dt), cos(ang_vel * time_dt), 0], [0,0,1]] #
-        centroid = [-1.0, 0.0, 0.0]
-        relative_initial_node_coords, relative_node_coords, relative_node_coords_dt = [0]*3, [0]*3, [0]*3
-        sum, sum_dt = 0, 0
-
-        for node in modelpart.Nodes:
-            if node.Id == 141:
-                for j in range(3):
-                    rot_mat = rotation_matrix[j]
-                    rot_mat_dt = rotation_matrix_minus_dt[j]
-                    relative_initial_node_coords[0] = node.X0 - centroid[0]
-                    relative_initial_node_coords[1] = node.Y0 - centroid[1]
-                    relative_initial_node_coords[2] = node.Z0 - centroid[2]
-                    for i in range(3):
-                        sum += rot_mat[i] * relative_initial_node_coords[i]
-                        sum_dt += rot_mat_dt[i] * relative_initial_node_coords[i]
-                    relative_node_coords[j], sum, relative_node_coords_dt[j], sum_dt = sum, 0, sum_dt, 0
-                node.X = relative_node_coords[0] + centroid[0]
-                node.Y = relative_node_coords[1] + centroid[1]
-                node.Z = relative_node_coords[2] + centroid[2]
-
-                displacement = GetDisplacement(node)
-                node.SetSolutionStepValue(DISPLACEMENT, displacement)
-
-                velocity = [0]*3
-                velocity = self.cross_product(angular_velocity, relative_node_coords)
-                node.SetSolutionStepValue(VELOCITY, velocity)
-
-                angular_velocity = [0]*3
-                node.SetSolutionStepValue(ANGULAR_VELOCITY, angular_velocity)
-
-                delta_displacement = [0]*3
-                delta_displacement[0] = relative_node_coords[0] - relative_node_coords_dt[0]
-                delta_displacement[1] = relative_node_coords[1] - relative_node_coords_dt[1]
-                delta_displacement[2] = relative_node_coords[2] - relative_node_coords_dt[2]
-                node.SetSolutionStepValue(DELTA_DISPLACEMENT, delta_displacement)
-
-                particle_rotation_angle = [0]*3
-                particle_rotation_angle[0] = angular_velocity[0] * time
-                particle_rotation_angle[1] = angular_velocity[1] * time
-                particle_rotation_angle[2] = angular_velocity[2] * time
-                node.SetSolutionStepValue(PARTICLE_ROTATION_ANGLE, particle_rotation_angle)
-
-                delta_rotation = [0]*3
-                delta_rotation[0] = angular_velocity[0] * dt
-                delta_rotation[1] = angular_velocity[1] * dt
-                delta_rotation[2] = angular_velocity[2] * dt
-                node.SetSolutionStepValue(DELTA_ROTATION, delta_rotation)
-
-                if time > 3.8e-5:
-                    radius = 1.0001
-                    node.SetSolutionStepValue(RADIUS, radius)
-            if node.Id == 140:
-                angular_velocity = [0]*3
-                node.SetSolutionStepValue(ANGULAR_VELOCITY, angular_velocity)
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
-        self.graph_frequency = int(graph_print_interval/dt)
-
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1
-
-        if (self.balls_graph_counter == self.graph_frequency):
-            self.balls_graph_counter = 0
-            self.total_force_x = 0.0
-            self.total_force_y = 0.0
-
-            for node in modelpart.Nodes:
-                if node.Id == 141:
-                   force_node_x = node.GetSolutionStepValue(ELASTIC_FORCES)[0]
-                   force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-                   self.total_force_x += force_node_x
-                   self.total_force_y += force_node_y
-
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_x).rjust(13)+" "+str("%.6g"%self.total_force_y).rjust(13)+"\n")
-        self.balls_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-        error1, error2, error3 = self.compute_errors(self.output_filename)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-        error_file.write("DEM Benchmark 25:")
-
-        if (error1 < 10.0 and error2 < 10.0 and error3 < 10.0):
-            error_file.write(" OK!........ Test 25 SUCCESSFUL\n")
-            shutil.rmtree('benchmark25_Post_Files', ignore_errors = True)
-        else:
-            error_file.write(" KO!........ Test 25 FAILED\n")
-        error_file.close()
-
-    def compute_errors(self, output_filename):
-        lines_analytics = lines_DEM = list(range(0, 1000));
-        analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
-        i = 0
-        with open('paper_data/reference_graph_benchmark' + '25' + '.dat') as inf:
-            for line in inf:
-                if i in lines_analytics:
-                    parts = line.split()
-                    analytics_data.append(float(parts[2]))
-                i+=1
-        i = 0
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[2]))   #segona component del vector ()
-                i+=1
-        generated_data_error = 0
-
-        for j in analytics_data:
-            summation_of_analytics_data+=abs(j)
-
-        for i, j in zip(DEM_data, analytics_data):
-            generated_data_error+=abs(i-j)
-        generated_data_error/=summation_of_analytics_data
-
-        Logger.PrintInfo("Error in simulation =", 100*generated_data_error,"%")
-        error1 = 100*generated_data_error
-        error2 = error3 = 0
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-    def create_gnuplot_scripts(self, output_filename, dt):
-        pass
-
-
-class Benchmark26:
-
-    def __init__(self):
-        self.number = 26
-
-        self.generated_data = None
-        self.balls_graph_counter = 1
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):
-
-        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.simulation_graph = open(self.output_filename, 'w')
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
-        self.simulation_graph.close()
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
-
-        self.graph_frequency = int(graph_print_interval/dt)
-
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1
-
-        if (self.balls_graph_counter == self.graph_frequency):
-            self.balls_graph_counter = 0
-            self.total_force_x = 0.0
-            self.total_force_y = 0.0
-
-            for node in modelpart.Nodes:
-                if node.Id == 141:
-                    force_node_x = node.GetSolutionStepValue(ELASTIC_FORCES)[0]
-                    force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-                    self.total_force_x += force_node_x
-                    self.total_force_y += force_node_y
-
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_x).rjust(13)+" "+str("%.6g"%self.total_force_y).rjust(13)+"\n")
-        self.balls_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt = 0):
-        pass
-
-    def compute_errors(self, output_filename):
-        pass
-
-    def create_gnuplot_scripts(self, output_filename, dt):
-        pass
-
-
-class Benchmark27:
-
-    def __init__(self):
-        self.number = 27
-        self.generated_data = None
-        self.balls_graph_counter = 1
-        self.rigid_graph_counter = 1
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):
-
-        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.rigid_face_file = "benchmark" + str(sys.argv[1]) + '_rigid_graph.dat'
-        self.simulation_graph = open(self.output_filename, 'w')
-        self.rigid_graph = open(self.rigid_face_file, 'w')
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
-        self.simulation_graph.close()
-        self.rigid_graph.close()
-
-    def cross_product(self, a, b):
-        c = [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]
-        return c
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-
-        ang_vel = 20 * pi
-        angular_velocity = [0, 0, ang_vel]
-        rotation_matrix = [[cos(ang_vel * time), -1.0 * sin(ang_vel * time), 0], [sin(ang_vel * time), cos(ang_vel * time), 0], [0,0,1]]
-        time_dt = time - dt
-        rotation_matrix_minus_dt = [[cos(ang_vel * time_dt), -1.0 * sin(ang_vel * time_dt), 0], [sin(ang_vel * time_dt), cos(ang_vel * time_dt), 0], [0,0,1]] #
-        centroid = [-1.0, 0.0, 0.0]
-        relative_initial_node_coords, relative_node_coords, relative_node_coords_dt = [0]*3, [0]*3, [0]*3
-        sum, sum_dt = 0, 0
-
-        for node in modelpart.Nodes:
-            if node.Id == 999999:
-                for j in range(3):
-                    rot_mat = rotation_matrix[j]
-                    rot_mat_dt = rotation_matrix_minus_dt[j]
-                    relative_initial_node_coords[0] = node.X0 - centroid[0]
-                    relative_initial_node_coords[1] = node.Y0 - centroid[1]
-                    relative_initial_node_coords[2] = node.Z0 - centroid[2]
-                    for i in range(3):
-                        sum += rot_mat[i] * relative_initial_node_coords[i]
-                        sum_dt += rot_mat_dt[i] * relative_initial_node_coords[i]
-                    relative_node_coords[j], sum, relative_node_coords_dt[j], sum_dt = sum, 0, sum_dt, 0
-                node.X = relative_node_coords[0] + centroid[0]
-                node.Y = relative_node_coords[1] + centroid[1]
-                node.Z = relative_node_coords[2] + centroid[2]
-
-                displacement = GetDisplacement(node)
-                node.SetSolutionStepValue(DISPLACEMENT, displacement)
-
-                velocity = [0]*3
-                velocity = self.cross_product(angular_velocity, relative_node_coords)
-                node.SetSolutionStepValue(VELOCITY, velocity)
-
-                angular_velocity = [0]*3
-                node.SetSolutionStepValue(ANGULAR_VELOCITY, angular_velocity)
-
-                delta_displacement = [0]*3
-                delta_displacement[0] = relative_node_coords[0] - relative_node_coords_dt[0]
-                delta_displacement[1] = relative_node_coords[1] - relative_node_coords_dt[1]
-                delta_displacement[2] = relative_node_coords[2] - relative_node_coords_dt[2]
-                node.SetSolutionStepValue(DELTA_DISPLACEMENT, delta_displacement)
-
-                particle_rotation_angle = [0]*3
-                particle_rotation_angle[0] = angular_velocity[0] * time
-                particle_rotation_angle[1] = angular_velocity[1] * time
-                particle_rotation_angle[2] = angular_velocity[2] * time
-                node.SetSolutionStepValue(PARTICLE_ROTATION_ANGLE, particle_rotation_angle)
-
-                delta_rotation = [0]*3
-                delta_rotation[0] = angular_velocity[0] * dt
-                delta_rotation[1] = angular_velocity[1] * dt
-                delta_rotation[2] = angular_velocity[2] * dt
-                node.SetSolutionStepValue(DELTA_ROTATION, delta_rotation)
-
-                if time > 3.8e-5:
-                    radius = 1.0001
-                    node.SetSolutionStepValue(RADIUS, radius)
-            if node.Id == 99999:
-                angular_velocity = [0]*3
-                node.SetSolutionStepValue(ANGULAR_VELOCITY, angular_velocity)
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
-
-        #self.graph_frequency = int(5e-7/dt)   #graph_print_interval/dt
-        self.graph_frequency = int(graph_print_interval/1/dt)   #1 veces mas grf que bin
-        #print (self.graph_frequency)
-        #print (self.balls_graph_counter)
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1
-
-        if (self.balls_graph_counter == self.graph_frequency):
-            #print (self.balls_graph_counter)
-            self.balls_graph_counter = 0
-            self.total_force_x = 0.0
-            self.total_force_y = 0.0
-            self.total_force_z = 0.0
-            self.total_force_sum = 0.0
-
-            self.total_angular_x = 0.0
-            self.total_angular_y = 0.0
-            self.total_angular_z = 0.0
-            self.total_angular_sum = 0.0
-
-            self.total_delta_x = 0.0
-            self.total_delta_y = 0.0
-            self.total_delta_z = 0.0
-            self.total_delta_sum = 0.0
-
-            for node in modelpart.Nodes:
-                if node.Id == 29:
-                   force_node_x = node.GetSolutionStepValue(ELASTIC_FORCES)[0]
-                   force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-                   force_node_z = node.GetSolutionStepValue(ELASTIC_FORCES)[2]
-                   self.total_force_x += force_node_x
-                   self.total_force_y += force_node_y
-                   self.total_force_z += force_node_z
-
-                   angular_node_x = node.GetSolutionStepValue(ANGULAR_VELOCITY)[0]
-                   angular_node_y = node.GetSolutionStepValue(ANGULAR_VELOCITY)[1]
-                   angular_node_z = node.GetSolutionStepValue(ANGULAR_VELOCITY)[2]
-                   self.total_angular_x += angular_node_x
-                   self.total_angular_y += angular_node_y
-                   self.total_angular_z += angular_node_z
-
-                   delta_node_x = node.GetSolutionStepValue(DELTA_DISPLACEMENT)[0]
-                   delta_node_y = node.GetSolutionStepValue(DELTA_DISPLACEMENT)[1]
-                   delta_node_z = node.GetSolutionStepValue(DELTA_DISPLACEMENT)[2]
-                   self.total_delta_x += delta_node_x
-                   self.total_delta_y += delta_node_y
-                   self.total_delta_z += delta_node_z
-
-            self.total_force_sum = self.total_force_x + self.total_force_y + self.total_force_z
-            self.total_angular_sum = self.total_angular_x + self.total_angular_y + self.total_angular_z
-            self.total_delta_sum = self.total_delta_x + self.total_delta_y + self.total_delta_z
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_sum).rjust(13)+" "+str("%.6g"%self.total_angular_sum).rjust(13)+" "+str("%.6g"%self.total_delta_sum).rjust(13)+"\n")
-            self.simulation_graph.flush()
-        self.balls_graph_counter += 1
-
-        for mesh_number in range(1, rigid_face_model_part.NumberOfMeshes()):
-            if(rigid_face_model_part.GetMesh(mesh_number)[TOP]):
-
-              self.top_mesh_nodes = rigid_face_model_part.GetMesh(mesh_number).Nodes
-
-            if (self.rigid_graph_counter == self.graph_frequency):
-                self.rigid_graph_counter = 0
-                self.total_force_top = 0.0
-
-                for node in self.top_mesh_nodes:
-
-                  force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-                  self.total_force_top += force_node_y
-
-                self.rigid_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_top).rjust(13)+"\n")
-                self.rigid_graph.flush()
-        self.rigid_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-        error1, error2, error3 = self.compute_errors(self.output_filename)
-        error4, error5, error6 = self.compute_rigid_errors(self.rigid_face_file)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3, error4, error5)
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-        error_file.write("DEM Benchmark 27:")
-
-        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
-            error_file.write(" OK!........ Test 27 SUCCESSFUL (spheres)\n")
-            shutil.rmtree('benchmark27_Post_Files', ignore_errors = True)
-        else:
-            error_file.write(" KO!........ Test 27 FAILED (spheres)\n")
-        error_file.write("DEM Benchmark 27:")
-        if (error4 < 0.01 and error5 < 0.01 and error6 < 0.01):
-            error_file.write(" OK!........ Test 27 SUCCESSFUL (finite elements)\n")
-        else:
-            error_file.write(" KO!........ Test 27 FAILED (finite elements)\n")
-        error_file.close()
-
-    def compute_errors(self, output_filename):
-        reference_data = lines_DEM = list(range(0, 1000));
-        analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
-        i = 0
-        with open('paper_data/reference_graph_benchmark' + '27' + '.dat') as reference:
-            for line in reference:
-                if i in reference_data:
-                    parts = line.split()
-                    analytics_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(output_filename) as current_data:
-            extend_datafile_list(glob(output_filename))
-            for line in current_data:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))   #segona component del vector ()
-                i+=1
-        dem_error1 = 0
-
-        for j in analytics_data:
-            summation_of_analytics_data+=abs(j)
-
-        for i, j in zip(DEM_data, analytics_data):
-            dem_error1+=abs(i-j)
-        dem_error1/=summation_of_analytics_data
-        if dem_error1 < 0.001:
-           dem_error1 = 0.0
-
-        Logger.PrintInfo("Error in total force at the reference particle =", 100*dem_error1,"%")
-
-        i = 0
-        with open('paper_data/reference_graph_benchmark' + '27' + '.dat') as reference:
-            for line in reference:
-                if i in reference_data:
-                    parts = line.split()
-                    analytics_data.append(float(parts[2]))
-                i+=1
-        i = 0
-        with open(output_filename) as current_data:
-            extend_datafile_list(glob(output_filename))
-            for line in current_data:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[2]))   #segona component del vector ()
-                i+=1
-        dem_error2 = 0
-
-        for j in analytics_data:
-            summation_of_analytics_data+=abs(j)
-
-        for i, j in zip(DEM_data, analytics_data):
-            dem_error2+=abs(i-j)
-        dem_error2/=summation_of_analytics_data
-        if dem_error2 < 0.001:
-           dem_error2 = 0.0
-
-        Logger.PrintInfo("Error in angular velocity at the reference particle =", 100*dem_error2,"%")
-
-
-        i = 0
-        with open('paper_data/reference_graph_benchmark' + '27' + '.dat') as reference:
-            for line in reference:
-                if i in reference_data:
-                    parts = line.split()
-                    analytics_data.append(float(parts[3]))
-                i+=1
-        i = 0
-        with open(output_filename) as current_data:
-            for line in current_data:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[3]))   #segona component del vector ()
-                i+=1
-        dem_error3 = 0
-
-        for j in analytics_data:
-            summation_of_analytics_data+=abs(j)
-
-        for i, j in zip(DEM_data, analytics_data):
-            dem_error3+=abs(i-j)
-        dem_error3/=summation_of_analytics_data
-        if dem_error3 < 0.001:
-           dem_error3 = 0.0
-
-        Logger.PrintInfo("Error in delta displacement at the reference particle =", 100*dem_error3,"%")
-
-        error1 = 100*dem_error1
-        error2 = 100*dem_error2
-        error3 = 100*dem_error3
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-    def compute_rigid_errors(self, rigid_face_file):
-        reference_data = lines_FEM = list(range(0, 1000));
-        analytics_data = []; FEM_data = []; summation_of_analytics_data = 0
-        i = 0
-        with open('paper_data/reference_rigid_graph_benchmark' + '27' + '.dat') as reference:
-
-            for line in reference:
-                if i in reference_data:
-                    parts = line.split()
-                    analytics_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(rigid_face_file) as current_data:
-            extend_datafile_list(glob(rigid_face_file))
-            for line in current_data:
-                if i in lines_FEM:
-                    parts = line.split()
-                    FEM_data.append(float(parts[1]))   #segona component del vector ()
-                i+=1
-        final_error = 0
-
-        for j in analytics_data:
-            summation_of_analytics_data+=abs(j)
-
-        for i, j in zip(FEM_data, analytics_data):
-            final_error+=abs(i-j)
-        final_error/=summation_of_analytics_data
-        if final_error < 0.001:
-           final_error = 0.0
-
-        Logger.PrintInfo("Error in FEM axial force =", 100*final_error,"%")
-
-        error4 = 100*final_error
-
-        error5 = error6 = 0
-
-        delete_current_benchmark_data()
-
-        return error4, error5, error6
-
-    def create_gnuplot_scripts(self, output_filename, dt):
-        pass
-
-
-
-class Benchmark28:   #pendulo3D
-
-    def __init__(self):
-        self.number = 28
-        self.generated_data = None
-        self.balls_graph_counter = 1
-        self.rigid_graph_counter = 1
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):
-
-        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.rigid_face_file = "benchmark" + str(sys.argv[1]) + '_rigid_graph.dat'
-        self.simulation_graph = open(self.output_filename, 'w')
-        self.rigid_graph = open(self.rigid_face_file, 'w')
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
-        self.simulation_graph.close()
-        self.rigid_graph.close()
-
-    def cross_product(self, a, b):
-        c = [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]
-        return c
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-        ang_vel = 20 * pi
-        angular_velocity = [0, 0, ang_vel]
-        rotation_matrix = [[cos(ang_vel * time), -1.0 * sin(ang_vel * time), 0], [sin(ang_vel * time), cos(ang_vel * time), 0], [0,0,1]]
-        time_dt = time - dt
-        rotation_matrix_minus_dt = [[cos(ang_vel * time_dt), -1.0 * sin(ang_vel * time_dt), 0], [sin(ang_vel * time_dt), cos(ang_vel * time_dt), 0], [0,0,1]] #
-        centroid = [-1.0, 0.0, 0.0]
-        relative_initial_node_coords, relative_node_coords, relative_node_coords_dt = [0]*3, [0]*3, [0]*3
-        sum, sum_dt = 0, 0
-
-        for node in modelpart.Nodes:
-            if node.Id == 999999:
-                for j in range(3):
-                    rot_mat = rotation_matrix[j]
-                    rot_mat_dt = rotation_matrix_minus_dt[j]
-                    relative_initial_node_coords[0] = node.X0 - centroid[0]
-                    relative_initial_node_coords[1] = node.Y0 - centroid[1]
-                    relative_initial_node_coords[2] = node.Z0 - centroid[2]
-                    for i in range(3):
-                        sum += rot_mat[i] * relative_initial_node_coords[i]
-                        sum_dt += rot_mat_dt[i] * relative_initial_node_coords[i]
-                    relative_node_coords[j], sum, relative_node_coords_dt[j], sum_dt = sum, 0, sum_dt, 0
-                node.X = relative_node_coords[0] + centroid[0]
-                node.Y = relative_node_coords[1] + centroid[1]
-                node.Z = relative_node_coords[2] + centroid[2]
-
-                displacement = GetDisplacement(node)
-                node.SetSolutionStepValue(DISPLACEMENT, displacement)
-
-                velocity = [0]*3
-                velocity = self.cross_product(angular_velocity, relative_node_coords)
-                node.SetSolutionStepValue(VELOCITY, velocity)
-
-                angular_velocity = [0]*3
-                node.SetSolutionStepValue(ANGULAR_VELOCITY, angular_velocity)
-
-                delta_displacement = [0]*3
-                delta_displacement[0] = relative_node_coords[0] - relative_node_coords_dt[0]
-                delta_displacement[1] = relative_node_coords[1] - relative_node_coords_dt[1]
-                delta_displacement[2] = relative_node_coords[2] - relative_node_coords_dt[2]
-                node.SetSolutionStepValue(DELTA_DISPLACEMENT, delta_displacement)
-
-                particle_rotation_angle = [0]*3
-                particle_rotation_angle[0] = angular_velocity[0] * time
-                particle_rotation_angle[1] = angular_velocity[1] * time
-                particle_rotation_angle[2] = angular_velocity[2] * time
-                node.SetSolutionStepValue(PARTICLE_ROTATION_ANGLE, particle_rotation_angle)
-
-                delta_rotation = [0]*3
-                delta_rotation[0] = angular_velocity[0] * dt
-                delta_rotation[1] = angular_velocity[1] * dt
-                delta_rotation[2] = angular_velocity[2] * dt
-                node.SetSolutionStepValue(DELTA_ROTATION, delta_rotation)
-
-                if time > 3.8e-5:
-                    radius = 1.0001
-                    node.SetSolutionStepValue(RADIUS, radius)
-            if node.Id == 99999:
-                angular_velocity = [0]*3
-                node.SetSolutionStepValue(ANGULAR_VELOCITY, angular_velocity)
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
-
-        #self.graph_frequency = int(5e-7/dt)   #graph_print_interval/dt
-        self.graph_frequency = int(graph_print_interval/1/dt)   #1 veces mas grf que bin
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1
-
-        if (self.balls_graph_counter == self.graph_frequency):
-            self.balls_graph_counter = 0
-            self.total_force_x = 0.0
-            self.total_force_y = 0.0
-            self.total_force_z = 0.0
-            self.total_force_sum = 0.0
-
-            self.total_angular_x = 0.0
-            self.total_angular_y = 0.0
-            self.total_angular_z = 0.0
-            self.total_angular_sum = 0.0
-
-            self.total_delta_x = 0.0
-            self.total_delta_y = 0.0
-            self.total_delta_z = 0.0
-            self.total_delta_sum = 0.0
-
-            for node in modelpart.Nodes:
-                if node.Id == 107:
-                   force_node_x = node.GetSolutionStepValue(LOCAL_CONTACT_FORCE)[0]
-                   force_node_y = node.GetSolutionStepValue(LOCAL_CONTACT_FORCE)[1]
-                   force_node_z = node.GetSolutionStepValue(LOCAL_CONTACT_FORCE)[2]
-                   self.total_force_x += force_node_x
-                   self.total_force_y += force_node_y
-                   self.total_force_z += force_node_z
-
-                   angular_node_x = node.GetSolutionStepValue(ANGULAR_VELOCITY)[0]
-                   angular_node_y = node.GetSolutionStepValue(ANGULAR_VELOCITY)[1]
-                   angular_node_z = node.GetSolutionStepValue(ANGULAR_VELOCITY)[2]
-                   self.total_angular_x += angular_node_x
-                   self.total_angular_y += angular_node_y
-                   self.total_angular_z += angular_node_z
-
-                   delta_node_x = node.GetSolutionStepValue(DELTA_DISPLACEMENT)[0]
-                   delta_node_y = node.GetSolutionStepValue(DELTA_DISPLACEMENT)[1]
-                   delta_node_z = node.GetSolutionStepValue(DELTA_DISPLACEMENT)[2]
-                   self.total_delta_x += delta_node_x
-                   self.total_delta_y += delta_node_y
-                   self.total_delta_z += delta_node_z
-
-            self.total_force_sum = self.total_force_x + self.total_force_y + self.total_force_z
-            self.total_angular_sum = self.total_angular_x + self.total_angular_y + self.total_angular_z
-            self.total_delta_sum = self.total_delta_x + self.total_delta_y + self.total_delta_z
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_sum).rjust(13)+" "+str("%.6g"%self.total_angular_sum).rjust(13)+" "+str("%.6g"%self.total_delta_sum).rjust(13)+"\n")
-            self.simulation_graph.flush()
-        self.balls_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-        error1, error2, error3 = self.compute_errors(self.output_filename)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-        error_file.write("DEM Benchmark 28:")
-
-        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
-            error_file.write(" OK!........ Test 28 SUCCESSFUL (spheres)\n")
-            shutil.rmtree('benchmark28_Post_Files', ignore_errors = True)
-        else:
-            error_file.write(" KO!........ Test 28 FAILED (spheres)\n")
-        error_file.write("DEM Benchmark 28:")
-
-
-    def compute_errors(self, output_filename):
-        reference_data = lines_DEM = list(range(0, 1000));
-        analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
-        i = 0
-        with open('paper_data/reference_graph_benchmark' + '28' + '.dat') as reference:
-            for line in reference:
-                if i in reference_data:
-                    parts = line.split()
-                    analytics_data.append(float(parts[1]))
-                i+=1
-        i = 0
-        with open(output_filename) as current_data:
-            extend_datafile_list(glob(output_filename))
-            for line in current_data:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[1]))   #1 component del vector ()
-                i+=1
-        dem_error1 = 0
-
-        for j in analytics_data:
-            summation_of_analytics_data+=abs(j)
-
-        for i, j in zip(DEM_data, analytics_data):
-            dem_error1+=abs(i-j)
-        dem_error1/=summation_of_analytics_data
-
-        Logger.PrintInfo("Error in total force at the reference particle =", 100*dem_error1,"%")
-
-        i = 0
-        with open('paper_data/reference_graph_benchmark' + '28' + '.dat') as reference:
-            for line in reference:
-                if i in reference_data:
-                    parts = line.split()
-                    analytics_data.append(float(parts[2]))
-                i+=1
-        i = 0
-        with open(output_filename) as current_data:
-            for line in current_data:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[2]))   #segona component del vector ()
-                i+=1
-        dem_error2 = 0
-
-        for j in analytics_data:
-            summation_of_analytics_data+=abs(j)
-
-        for i, j in zip(DEM_data, analytics_data):
-            dem_error2+=abs(i-j)
-        dem_error2/=summation_of_analytics_data
-
-        Logger.PrintInfo("Error in angular velocity at the reference particle =", 100*dem_error2,"%")
-
-
-        i = 0
-        with open('paper_data/reference_graph_benchmark' + '28' + '.dat') as reference:
-            for line in reference:
-                if i in reference_data:
-                    parts = line.split()
-                    analytics_data.append(float(parts[3]))
-                i+=1
-        i = 0
-        with open(output_filename) as current_data:
-            for line in current_data:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data.append(float(parts[3]))   #3 component del vector ()
-                i+=1
-        dem_error3 = 0
-
-        for j in analytics_data:
-            summation_of_analytics_data+=abs(j)
-
-        for i, j in zip(DEM_data, analytics_data):
-            dem_error3+=abs(i-j)
-        dem_error3/=summation_of_analytics_data
-
-        Logger.PrintInfo("Error in delta displacement at the reference particle =", 100*dem_error3,"%")
-
-        error1 = 100*dem_error1
-        error2 = 100*dem_error2
-        error3 = 100*dem_error3
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-    def compute_rigid_errors(self, rigid_face_file):
-        pass
-
-    def create_gnuplot_scripts(self, output_filename, dt):
-        pass
-
-
-
-class Benchmark30: ########## Cylinder with imposed angular velocity (Velocity Verlet + Zhao)
-
-    def __init__(self):
-        self.number = 30
-
-        self.cluster_graph_counter = 1   # deberia ser self.cluster_graph_counter = self.graph_frequency
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        self.local_angular_velocity_list_outfile_name = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.simulation_graph = open(self.local_angular_velocity_list_outfile_name, 'w')
-
-    def get_final_data(self, spheres_model_part, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
-
-        self.simulation_graph.close()
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def generate_graph_points(self, spheres_model_part, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
-
-        self.graph_frequency        = int(graph_print_interval/dt)
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
-
-        if(self.cluster_graph_counter == self.graph_frequency):     #if(self.cluster_graph_counter == self.graph_frequency):
-            self.cluster_graph_counter = 0
-            total_local_angular_velocity_x = 0.0
-            total_local_angular_velocity_y = 0.0
-            total_local_angular_velocity_z = 0.0
-
-            for node in cluster_model_part.Nodes:
-                current_local_angular_velocity_x = node.GetSolutionStepValue(LOCAL_ANGULAR_VELOCITY_X)
-                total_local_angular_velocity_x += current_local_angular_velocity_x
-                current_local_angular_velocity_y = node.GetSolutionStepValue(LOCAL_ANGULAR_VELOCITY_Y)
-                total_local_angular_velocity_y += current_local_angular_velocity_y
-                current_local_angular_velocity_z = node.GetSolutionStepValue(LOCAL_ANGULAR_VELOCITY_Z)
-                total_local_angular_velocity_z += current_local_angular_velocity_z
-
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_local_angular_velocity_x).rjust(13)+" "+str("%.6g"%total_local_angular_velocity_y).rjust(13)+" "+str("%.6g"%total_local_angular_velocity_z).rjust(13)+"\n")
-        self.cluster_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
-
-        error1, error2, error3 = self.compute_errors(self.local_angular_velocity_list_outfile_name)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-        error_file.write("\n\n")
-        error_file.write("===== DISCONTINUUM CLUSTERS TESTS =====\n\n")
-        error_file.write("DEM Benchmark 30:")
-
-        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
-            error_file.write(" OK!........ Test 30 SUCCESSFUL\n")
-        else:
-            error_file.write(" KO!........ Test 30 FAILED\n")
-        error_file.close()
-
-    def compute_errors(self, output_filename):  #FINALIZATION STEP
-
-        lines_analytics = lines_DEM = list(range(0, 50));
-        ref_data1 = []; ref_data2 = []; DEM_data1 = []; ref_data3 = []; DEM_data1 = []; DEM_data2 = []; DEM_data3 = []; summation_of_ref_data1 = 0; summation_of_ref_data2 = 0; summation_of_ref_data3 = 0
-        i = 0
-        with open('paper_data/benchmark' + str(sys.argv[1]) + '_graph.dat') as inf:  #with open('paper_data/reference_graph_benchmark30.dat') as inf:
-            for line in inf:
-                if i in lines_analytics:
-                    parts = line.split()
-                    ref_data1.append(float(parts[1]))
-                    ref_data2.append(float(parts[2]))
-                    ref_data3.append(float(parts[3]))
-                i+=1
-        i = 0
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data1.append(float(parts[1]))
-                    DEM_data2.append(float(parts[2]))
-                    DEM_data3.append(float(parts[3]))
-                i+=1
-        final_local_angular_velocity_x_error = 0
-        final_local_angular_velocity_y_error = 0
-        final_local_angular_velocity_z_error = 0
-
-        for j in ref_data1:
-            summation_of_ref_data1+=abs(j)
-        for k in ref_data2:
-            summation_of_ref_data2+=abs(k)
-        for l in ref_data3:
-            summation_of_ref_data3+=abs(l)
-
-        for i, j in zip(DEM_data1, ref_data1):
-            final_local_angular_velocity_x_error+=abs(i-j)
-        final_local_angular_velocity_x_error/=summation_of_ref_data1
-
-        for k, l in zip(DEM_data2, ref_data2):
-            final_local_angular_velocity_y_error+=abs(k-l)
-        final_local_angular_velocity_y_error/=summation_of_ref_data2
-
-        for m, n in zip(DEM_data3, ref_data3):
-            final_local_angular_velocity_z_error+=abs(m-n)
-        final_local_angular_velocity_z_error/=summation_of_ref_data3
-
-        Logger.PrintInfo("Error in local angular velocity X =", 100*final_local_angular_velocity_x_error,"%")
-
-        Logger.PrintInfo("Error in local angular velocity Y =", 100*final_local_angular_velocity_y_error,"%")
-
-        Logger.PrintInfo("Error in local angular velocity Z =", 100*final_local_angular_velocity_z_error,"%")
-
-        error1 = 100*final_local_angular_velocity_x_error
-
-        error2 = 100*final_local_angular_velocity_y_error
-
-        error3 = 100*final_local_angular_velocity_z_error
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-class Benchmark31: ########## Cylinder with imposed angular velocity (Symplectic Euler + Runge-Kutta)
-
-    def __init__(self):
-        self.number = 31
-
-        self.cluster_graph_counter = 1   # deberia ser self.cluster_graph_counter = self.graph_frequency
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        self.local_angular_velocity_list_outfile_name = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.simulation_graph = open(self.local_angular_velocity_list_outfile_name, 'w')
-
-    def get_final_data(self, spheres_model_part, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
-
-        self.simulation_graph.close()
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def generate_graph_points(self, spheres_model_part, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
-
-        self.graph_frequency        = int(graph_print_interval/dt)
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
-
-        if(self.cluster_graph_counter == self.graph_frequency):     #if(self.cluster_graph_counter == self.graph_frequency):
-            self.cluster_graph_counter = 0
-            total_local_angular_velocity_x = 0.0
-            total_local_angular_velocity_y = 0.0
-            total_local_angular_velocity_z = 0.0
-
-            for node in cluster_model_part.Nodes:
-                current_local_angular_velocity_x = node.GetSolutionStepValue(LOCAL_ANGULAR_VELOCITY_X)
-                total_local_angular_velocity_x += current_local_angular_velocity_x
-                current_local_angular_velocity_y = node.GetSolutionStepValue(LOCAL_ANGULAR_VELOCITY_Y)
-                total_local_angular_velocity_y += current_local_angular_velocity_y
-                current_local_angular_velocity_z = node.GetSolutionStepValue(LOCAL_ANGULAR_VELOCITY_Z)
-                total_local_angular_velocity_z += current_local_angular_velocity_z
-
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_local_angular_velocity_x).rjust(13)+" "+str("%.6g"%total_local_angular_velocity_y).rjust(13)+" "+str("%.6g"%total_local_angular_velocity_z).rjust(13)+"\n")
-        self.cluster_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
-
-        error1, error2, error3 = self.compute_errors(self.local_angular_velocity_list_outfile_name)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-        error_file.write("DEM Benchmark 31:")
-
-        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
-            error_file.write(" OK!........ Test 31 SUCCESSFUL\n")
-        else:
-            error_file.write(" KO!........ Test 31 FAILED\n")
-        error_file.close()
-
-    def compute_errors(self, output_filename):  #FINALIZATION STEP
-
-        lines_analytics = lines_DEM = list(range(0, 50));
-        ref_data1 = []; ref_data2 = []; DEM_data1 = []; ref_data3 = []; DEM_data1 = []; DEM_data2 = []; DEM_data3 = []; summation_of_ref_data1 = 0; summation_of_ref_data2 = 0; summation_of_ref_data3 = 0
-        i = 0
-        with open('paper_data/benchmark' + str(sys.argv[1]) + '_graph.dat') as inf:  #with open('paper_data/reference_graph_benchmark31.dat') as inf:
-            for line in inf:
-                if i in lines_analytics:
-                    parts = line.split()
-                    ref_data1.append(float(parts[1]))
-                    ref_data2.append(float(parts[2]))
-                    ref_data3.append(float(parts[3]))
-                i+=1
-        i = 0
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data1.append(float(parts[1]))
-                    DEM_data2.append(float(parts[2]))
-                    DEM_data3.append(float(parts[3]))
-                i+=1
-        final_local_angular_velocity_x_error = 0
-        final_local_angular_velocity_y_error = 0
-        final_local_angular_velocity_z_error = 0
-
-        for j in ref_data1:
-            summation_of_ref_data1+=abs(j)
-        for k in ref_data2:
-            summation_of_ref_data2+=abs(k)
-        for l in ref_data3:
-            summation_of_ref_data3+=abs(l)
-
-        for i, j in zip(DEM_data1, ref_data1):
-            final_local_angular_velocity_x_error+=abs(i-j)
-        final_local_angular_velocity_x_error/=summation_of_ref_data1
-
-        for k, l in zip(DEM_data2, ref_data2):
-            final_local_angular_velocity_y_error+=abs(k-l)
-        final_local_angular_velocity_y_error/=summation_of_ref_data2
-
-        for m, n in zip(DEM_data3, ref_data3):
-            final_local_angular_velocity_z_error+=abs(m-n)
-        final_local_angular_velocity_z_error/=summation_of_ref_data3
-
-        Logger.PrintInfo("Error in local angular velocity X =", 100*final_local_angular_velocity_x_error,"%")
-
-        Logger.PrintInfo("Error in local angular velocity Y =", 100*final_local_angular_velocity_y_error,"%")
-
-        Logger.PrintInfo("Error in local angular velocity Z =", 100*final_local_angular_velocity_z_error,"%")
-
-        error1 = 100*final_local_angular_velocity_x_error
-
-        error2 = 100*final_local_angular_velocity_y_error
-
-        error3 = 100*final_local_angular_velocity_z_error
-
-        delete_current_benchmark_data()
-
-        return error1, error2, error3
-
-class Benchmark32: ########## Fiber cluster bouncing without any damping (Velocity Verlet + Zhao scheme)
-
-    def __init__(self):
-        self.number = 32
-
-        self.cluster_graph_counter = 1   # deberia ser self.cluster_graph_counter = self.graph_frequency
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        self.velocity_list_outfile_name = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.simulation_graph = open(self.velocity_list_outfile_name, 'w')
-
-    def get_final_data(self, spheres_model_part, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
-
-        self.simulation_graph.close()
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def generate_graph_points(self, spheres_model_part, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
-
-        self.graph_frequency        = int(graph_print_interval/dt)
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
-
-        if(self.cluster_graph_counter == self.graph_frequency):     #if(self.cluster_graph_counter == self.graph_frequency):
-            self.cluster_graph_counter = 0
-            total_velocity_z         = 0.0
-            total_angular_velocity_y = 0.0
-
-            for node in cluster_model_part.Nodes:
-                current_velocity_z = node.GetSolutionStepValue(VELOCITY_Z)
-                total_velocity_z += current_velocity_z
-                current_angular_velocity_y = node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)
-                total_angular_velocity_y += current_angular_velocity_y
-
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_velocity_z).rjust(13)+" "+str("%.6g"%total_angular_velocity_y).rjust(13)+"\n")
-        self.cluster_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
-
-        error1, error2 = self.compute_errors(self.velocity_list_outfile_name)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2)
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-        error_file.write("DEM Benchmark 32:")
-
-        if (error1 < 0.01 and error2 < 0.01):
-            error_file.write(" OK!........ Test 32 SUCCESSFUL\n")
-        else:
-            error_file.write(" KO!........ Test 32 FAILED\n")
-        error_file.close()
-
-    def compute_errors(self, output_filename):  #FINALIZATION STEP
-
-        lines_analytics = lines_DEM = list(range(0, 100))
-        ref_data1 = []; ref_data2 = []; DEM_data1 = []; DEM_data1 = []; DEM_data2 = []; summation_of_ref_data1 = 0; summation_of_ref_data2 = 0
-        i = 0
-        with open('paper_data/benchmark' + str(sys.argv[1]) + '_graph.dat') as inf:  #with open('paper_data/reference_graph_benchmark32.dat') as inf:
-            for line in inf:
-                if i in lines_analytics:
-                    parts = line.split()
-                    ref_data1.append(float(parts[1]))
-                    ref_data2.append(float(parts[2]))
-                i+=1
-        i = 0
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data1.append(float(parts[1]))
-                    DEM_data2.append(float(parts[2]))
-                i+=1
-        final_velocity_z_error         = 0
-        final_angular_velocity_y_error = 0
-
-        for j in ref_data1:
-            summation_of_ref_data1+=abs(j)
-        for k in ref_data2:
-            summation_of_ref_data2+=abs(k)
-
-        for i, j in zip(DEM_data1, ref_data1):
-            final_velocity_z_error+=abs(i-j)
-        final_velocity_z_error/=summation_of_ref_data1
-
-        for k, l in zip(DEM_data2, ref_data2):
-            final_angular_velocity_y_error+=abs(k-l)
-        final_angular_velocity_y_error/=summation_of_ref_data2
-
-        Logger.PrintInfo("Error in velocity Z =", 100*final_velocity_z_error,"%")
-
-        Logger.PrintInfo("Error in angular velocity Y =", 100*final_angular_velocity_y_error,"%")
-
-        error1 = 100*final_velocity_z_error
-
-        error2 = 100*final_angular_velocity_y_error
-
-        delete_current_benchmark_data()
-
-        return error1, error2
-
-class Benchmark33: ########## Fiber cluster bouncing without any damping (Velocity Verlet + Runge-Kutta scheme)
-
-    def __init__(self):
-        self.number = 33
-
-        self.cluster_graph_counter = 1   # deberia ser self.cluster_graph_counter = self.graph_frequency
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
-
-        self.velocity_list_outfile_name = "benchmark" + str(sys.argv[1]) + '_graph.dat'
-        self.simulation_graph = open(self.velocity_list_outfile_name, 'w')
-
-    def get_final_data(self, spheres_model_part, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
-
-        self.simulation_graph.close()
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def generate_graph_points(self, spheres_model_part, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
-
-        self.graph_frequency        = int(graph_print_interval/dt)
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
-
-        if(self.cluster_graph_counter == self.graph_frequency):     #if(self.cluster_graph_counter == self.graph_frequency):
-            self.cluster_graph_counter = 0
-            total_velocity_z         = 0.0
-            total_angular_velocity_y = 0.0
-
-            for node in cluster_model_part.Nodes:
-                current_velocity_z = node.GetSolutionStepValue(VELOCITY_Z)
-                total_velocity_z += current_velocity_z
-                current_angular_velocity_y = node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)
-                total_angular_velocity_y += current_angular_velocity_y
-
-            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_velocity_z).rjust(13)+" "+str("%.6g"%total_angular_velocity_y).rjust(13)+"\n")
-        self.cluster_graph_counter += 1
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
-
-        error1, error2 = self.compute_errors(self.velocity_list_outfile_name)
-        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2)
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-        error_file.write("DEM Benchmark 33:")
-
-        if (error1 < 0.01 and error2 < 0.01):
-            error_file.write(" OK!........ Test 33 SUCCESSFUL\n")
-        else:
-            error_file.write(" KO!........ Test 33 FAILED\n")
-        error_file.close()
-
-    def compute_errors(self, output_filename):  #FINALIZATION STEP
-
-        lines_analytics = lines_DEM = list(range(0, 100));
-        ref_data1 = []; ref_data2 = []; DEM_data1 = []; DEM_data1 = []; DEM_data2 = []; summation_of_ref_data1 = 0; summation_of_ref_data2 = 0
-        i = 0
-        with open('paper_data/benchmark' + str(sys.argv[1]) + '_graph.dat') as inf:  #with open('paper_data/reference_graph_benchmark33.dat') as inf:
-            for line in inf:
-                if i in lines_analytics:
-                    parts = line.split()
-                    ref_data1.append(float(parts[1]))
-                    ref_data2.append(float(parts[2]))
-                i+=1
-        i = 0
-        with open(output_filename) as inf:
-            extend_datafile_list(glob(output_filename))
-            for line in inf:
-                if i in lines_DEM:
-                    parts = line.split()
-                    DEM_data1.append(float(parts[1]))
-                    DEM_data2.append(float(parts[2]))
-                i+=1
-        final_velocity_z_error         = 0
-        final_angular_velocity_y_error = 0
-
-        for j in ref_data1:
-            summation_of_ref_data1+=abs(j)
-        for k in ref_data2:
-            summation_of_ref_data2+=abs(k)
-
-        for i, j in zip(DEM_data1, ref_data1):
-            final_velocity_z_error+=abs(i-j)
-        final_velocity_z_error/=summation_of_ref_data1
-
-        for k, l in zip(DEM_data2, ref_data2):
-            final_angular_velocity_y_error+=abs(k-l)
-        final_angular_velocity_y_error/=summation_of_ref_data2
-
-        Logger.PrintInfo("Error in velocity Z =", 100*final_velocity_z_error,"%")
-
-        Logger.PrintInfo("Error in angular velocity Y =", 100*final_angular_velocity_y_error,"%")
-
-        error1 = 100*final_velocity_z_error
-
-        error2 = 100*final_angular_velocity_y_error
-
-        delete_current_benchmark_data()
-
-        return error1, error2
-
-
-
-class Benchmark40: # multiple benchmarks for general code verification.
-
-    def __init__(self):
-        self.generated_data = None
-        self.balls_graph_counter = 1
-        self.rigid_graph_counter = 1
-
-        self.number_of_DEM_benchmarks = 15
-        self.number_of_FEM_benchmarks = 8
-
-    def ApplyNodalRotation(self, time, dt, modelpart):
-        pass
-
-    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):
-        pass
-
-
-    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
-        pass
-
-
-    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
-
-        #self.graph_frequency = int(5e-7/dt)   #graph_print_interval/dt
-        self.graph_frequency = int(graph_print_interval/dt)   #1 veces mas grf que bin
-        if self.graph_frequency < 1:
-           self.graph_frequency = 1
-
-        if (self.balls_graph_counter == self.graph_frequency):
-            self.balls_graph_counter = 0
-
-            for node in modelpart.Nodes:
-                if node.Id == 10:           ### stage 0 - simple dem
-
-                    force_node = GetVectorNorm(node, TOTAL_FORCES)
-                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
-                    displacement_node = GetNodeDisplacement(node)
-
-                    i=0
-                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-            for node in modelpart.Nodes:
-                if node.Id == 42:           ### stage 1
-
-                    force_node = GetVectorNorm(node, TOTAL_FORCES)
-                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
-                    displacement_node = GetNodeDisplacement(node)
-
-                    i=1
-                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-            for node in modelpart.Nodes:
-                if node.Id == 71:           ### stage 2
-
-                    force_node = GetVectorNorm(node, TOTAL_FORCES)
-                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
-                    displacement_node = GetNodeDisplacement(node)
-
-                    i=2
-                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-            for node in modelpart.Nodes:
-                if node.Id == 1354:           ### stage 3
-
-                    force_node = GetVectorNorm(node, TOTAL_FORCES)
-                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
-                    displacement_node = GetNodeDisplacement(node)
-
-                    i=3
-                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-
-            for node in modelpart.Nodes:
-                if node.Id == 1534:           ### stage 4 - particle injected by inlet
-
-                    force_node = GetVectorNorm(node, TOTAL_FORCES)
-                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
-                    displacement_node = GetNodeDisplacement(node)
-
-                    i=4
-                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-
-            for node in modelpart.Nodes:
-                if node.Id == 1416:           ### stage 5 - inlet movement
-
-                    force_node = GetVectorNorm(node, TOTAL_FORCES)
-                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
-                    displacement_node = GetNodeDisplacement(node)
-
-                    i=5
-                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-            for node in modelpart.Nodes:
-                if node.Id == 1337:           ### stage 6 - dem with initial velocity
-
-                    force_node = GetVectorNorm(node, TOTAL_FORCES)
-                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
-                    displacement_node = GetNodeDisplacement(node)
-
-                    i=6
-                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-
-            for node in modelpart.Nodes:
-                if node.Id == 663:           ### stage 7 - gravity on sphere of spheres
-
-                    force_node = GetVectorNorm(node, TOTAL_FORCES)
-                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
-                    displacement_node = GetNodeDisplacement(node)
-
-                    i=7
-                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-            for node in modelpart.Nodes:
-                if node.Id == 758:           ### stage 8 - dem with reduced degrees of freedom
-
-                    force_node = GetVectorNorm(node, TOTAL_FORCES)
-                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
-                    displacement_node = GetNodeDisplacement(node)
-
-                    i=8
-                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-            for node in modelpart.Nodes:
-                if node.Id == 789:           ### stage 9 - dem falling pink
-
-                    force_node = GetVectorNorm(node, TOTAL_FORCES)
-                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
-                    displacement_node = GetNodeDisplacement(node)
-
-                    i=9
-                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-            for node in modelpart.Nodes:
-                if node.Id == 913:           ### stage 10 - dem falling green fem
-
-                    force_node = GetVectorNorm(node, TOTAL_FORCES)
-                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
-                    displacement_node = GetNodeDisplacement(node)
-
-                    i=10
-                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-
-            for node in modelpart.Nodes:
-                if node.Id == 974:           ### stage 11 - dem falling  orange
-
-                    force_node = GetVectorNorm(node, TOTAL_FORCES)
-                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
-                    displacement_node = GetNodeDisplacement(node)
-
-                    i=11
-                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-            for node in modelpart.Nodes:
-                if node.Id == 1061:           ### stage 12 - dem imposed period
-
-                    force_node = GetVectorNorm(node, TOTAL_FORCES)
-                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
-                    displacement_node = GetNodeDisplacement(node)
-
-                    i=12
-                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-
-
-            for node in modelpart.Nodes:
-                if node.Id == 1180:           ### stage 13 - dem initial
-
-                    force_node = GetVectorNorm(node, TOTAL_FORCES)
-                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
-                    displacement_node = GetNodeDisplacement(node)
-
-                    i=13
-                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-
-            for node in modelpart.Nodes:
-                if node.Id == 1290:           ### stage 14 - dem contra fem rotatori force
-
-                    force_node = GetVectorNorm(node, TOTAL_FORCES)
-                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
-                    displacement_node = GetNodeDisplacement(node)
-
-                    i=14
-                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-        self.balls_graph_counter += 1
-
-
-        if (self.rigid_graph_counter == self.graph_frequency):
-            self.rigid_graph_counter = 0
-            for sub_part in rigid_face_model_part.SubModelParts:
-
-                if sub_part.Name == '0':
-
-                    name = int(sub_part.Name)
-                    mesh_nodes = sub_part.GetMesh(0).Nodes
-                    force_node = 0.0
-
-                    for node in mesh_nodes:
-                        force_node += GetVectorNorm(node, ELASTIC_FORCES)
-                        displacement_node += GetNodeDisplacement(node)
-
-                    i=name  # beware
-                    data  = open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-                if sub_part.Name == '1':
-
-                    name = int(sub_part.Name)
-                    mesh_nodes = sub_part.GetMesh(0).Nodes
-                    force_node = 0.0
-
-                    for node in mesh_nodes:
-
-                        force_node += GetVectorNorm(node, ELASTIC_FORCES)
-                        displacement_node += GetNodeDisplacement(node)
-
-                    i=name
-                    data  = open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-
-                if sub_part.Name == '2':
-
-                    name = int(sub_part.Name)
-                    mesh_nodes = sub_part.GetMesh(0).Nodes
-                    force_node = 0.0
-
-                    for node in mesh_nodes:
-                        force_node += GetVectorNorm(node, ELASTIC_FORCES)
-                        displacement_node += GetNodeDisplacement(node)
-
-                    i=name
-                    data  = open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-
-                if sub_part.Name == '3':
-
-                    name = int(sub_part.Name)
-                    mesh_nodes = sub_part.GetMesh(0).Nodes
-                    force_node = 0.0
-
-                    for node in mesh_nodes:
-                        force_node += GetVectorNorm(node, ELASTIC_FORCES)
-                        displacement_node += GetNodeDisplacement(node)
-
-                    i=name
-                    data  = open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-
-                if sub_part.Name == '4':
-
-                    name = int(sub_part.Name)
-                    mesh_nodes = sub_part.GetMesh(0).Nodes
-                    force_node = 0.0
-
-                    for node in mesh_nodes:
-                        force_node += GetVectorNorm(node, ELASTIC_FORCES)
-                        displacement_node += GetNodeDisplacement(node)
-
-                    i=name
-                    data  = open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-
-                if sub_part.Name == '5':
-
-                    name = int(sub_part.Name)
-                    mesh_nodes = sub_part.GetMesh(0).Nodes
-                    force_node = 0.0
-
-                    for node in mesh_nodes:
-                        force_node += GetVectorNorm(node, ELASTIC_FORCES)
-                        displacement_node += GetNodeDisplacement(node)
-
-                    i=name
-                    data  = open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-
-                if sub_part.Name == '6':
-
-                    name = int(sub_part.Name)
-                    mesh_nodes = sub_part.GetMesh(0).Nodes
-                    force_node = 0.0
-
-                    for node in mesh_nodes:
-                        force_node += GetVectorNorm(node, ELASTIC_FORCES)
-                        displacement_node += GetNodeDisplacement(node)
-
-                    i=name
-                    data  = open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-
-                if sub_part.Name == '7':
-
-                    name = int(sub_part.Name)
-                    mesh_nodes = sub_part.GetMesh(0).Nodes
-                    force_node = 0.0
-
-                    for node in mesh_nodes:
-                        force_node += GetVectorNorm(node, ELASTIC_FORCES)
-                        displacement_node += GetNodeDisplacement(node)
-
-                    i=name
-                    data  = open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % i, 'a')
-                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
-                    data.flush()
-
-        self.rigid_graph_counter += 1
-
-
-
-    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
-
-        error1, error2, error3 = self.compute_errors()     # TOTAL_FORCES, ANGULAR_VELOCITY, NODE DISPLACEMENT FROM INITIAL POS
-        error4, error5 = self.compute_rigid_errors()       # TOTAL_FORCES, AVG DISPLACEMENT FROM INITIAL POS
-
-        error_filename = 'errors.err'
-        error_file = open(error_filename, 'a')
-
-        for index in range(self.number_of_DEM_benchmarks):
-            error_file.write("DEM Benchmark 40:")
-            if (error1[index] < 0.05 and error2[index] < 0.05 and error3[index] < 0.05):
-                error_file.write(" OK!........ Test 40_%s SUCCESSFUL (spheres)\n" % index)
-                #shutil.rmtree('benchmark40_Post_Files', ignore_errors = True)
-            else:
-                error_file.write(" KO!........ Test 40_%s FAILED (spheres)\n" % index)
-
-
-        for index in range(self.number_of_FEM_benchmarks):
-            error_file.write("DEM Benchmark 40:")
-            if (error4[index] < 0.05 and error5[index] < 0.05):
-                error_file.write(" OK!........ Test 40_%s SUCCESSFUL (finite elements)\n" % index)
-            else:
-                error_file.write(" KO!........ Test 40_%s FAILED (finite elements)\n" % index)
-
-        error_file.close()
-
-    def compute_errors(self):
-        error1 = []
-        error2 = []
-        error3 = []
-
-        for index in range(self.number_of_DEM_benchmarks):
-            reference_data = lines_DEM = list(range(0, 1000))
-            analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
-            i = 0
-            with open('paper_data/reference_graph_benchmark' + '40_%s' % index + '.dat') as reference:
-                for line in reference:
-                    if i in reference_data:
-                        parts = line.split()
-                        analytics_data.append(float(parts[1]))      # ref TOTAL_FORCES
-                    i+=1
-            i = 0
-            with open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % index) as current_data:
-                extend_datafile_list(glob("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % index))
-
-                for line in current_data:
-                    if i in lines_DEM:
-                        parts = line.split()
-                        DEM_data.append(float(parts[1]))            # TOTAL_FORCES
-                    i+=1
-            dem_error1 = 0.0
-
-            for j in analytics_data:
-                summation_of_analytics_data+=abs(j)
-
-            for i, j in zip(DEM_data, analytics_data):
-                dem_error1+=abs(i-j)                               # (test_data[0]-reference_data[0]) + ...
-            dem_error1/=summation_of_analytics_data                 # relative error of the above against sum of reference data
-
-            if dem_error1>0.05:
-                Logger.PrintInfo("Error in total force at the reference particle =", 100*dem_error1,"%"+" at index: ",index)
-
-            i = 0
-            with open('paper_data/reference_graph_benchmark' +  '40_%s' % index + '.dat') as reference:
-                for line in reference:
-                    if i in reference_data:
-                        parts = line.split()
-                        analytics_data.append(float(parts[2]))      # ref ANGULAR_VELOCITY
-                    i+=1
-            i = 0
-            with open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % index) as current_data:
-                for line in current_data:
-                    if i in lines_DEM:
-                        parts = line.split()
-                        DEM_data.append(float(parts[2]))            # ANGULAR_VELOCITY
-                    i+=1
-            dem_error2 = 0.0
-
-            for j in analytics_data:
-                summation_of_analytics_data+=abs(j)
-
-            for i, j in zip(DEM_data, analytics_data):
-                dem_error2+=abs(i-j)                               # (test_data[0]-reference_data[0]) + ...
-            dem_error2/=summation_of_analytics_data                 # relative error of the above against sum of reference data
-
-            if dem_error2>0.05:
-              Logger.PrintInfo("Error in angular velocity at the reference particle =", 100*dem_error2,"%"+" at index: ",index)
-
-
-            i = 0
-            with open('paper_data/reference_graph_benchmark' + '40_%s' % index + '.dat') as reference:
-                for line in reference:
-                    if i in reference_data:
-                        parts = line.split()
-                        analytics_data.append(float(parts[3]))      # ref displacement from initial pos
-                    i+=1
-            i = 0
-            with open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % index) as current_data:
-                for line in current_data:
-                    if i in lines_DEM:
-                        parts = line.split()
-                        DEM_data.append(float(parts[3]))            # displacement from initial pos
-                    i+=1
-            dem_error3 = 0.0
-
-            for j in analytics_data:
-                summation_of_analytics_data+=abs(j)
-
-            for i, j in zip(DEM_data, analytics_data):
-                dem_error3+=abs(i-j)
-            dem_error3/=summation_of_analytics_data
-
-            if dem_error3>0.05:
-                Logger.PrintInfo("Error in delta displacement at the reference particle =", 100*dem_error3,"%"+" at index: ",index)
-
-            error1.append(dem_error1)
-            error2.append(dem_error2)
-            error3.append(dem_error3)
-
-        delete_current_benchmark_data()
-        return error1, error2, error3
-
-
-    def compute_rigid_errors(self):
-        error4 = []
-        error5 = []
-
-        for index in range(self.number_of_FEM_benchmarks):
-            reference_data = lines_DEM = list(range(0, 1000))
-            analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
-            i = 0
-            with open('paper_data/reference_rigid_graph_benchmark' + '40_%s' % index + '.dat') as reference:
-                for line in reference:
-                    if i in reference_data:
-                        parts = line.split()
-                        analytics_data.append(float(parts[1]))      # REFERENCE TOTAL_FORCES
-                    i+=1
-            i = 0
-            with open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % index) as current_data:
-                extend_datafile_list(glob("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % index))
-                for line in current_data:
-                    if i in lines_DEM:
-                        parts = line.split()
-                        DEM_data.append(float(parts[1]))            # TOTAL_FORCES
-                    i+=1
-            fem_error1 = 0.0
-
-            for j in analytics_data:
-                summation_of_analytics_data+=abs(j)
-
-            for i, j in zip(DEM_data, analytics_data):
-                fem_error1+=abs(i-j)
-            if summation_of_analytics_data!=0.0:                     # (test_data[0]-reference_data[0]) + ...
-                fem_error1/=summation_of_analytics_data              # relative error of the above against sum of reference data
-
-            if fem_error1>0.05:
-                Logger.PrintInfo("Error in total force at the reference FEM subpart =", 100*fem_error1,"%"+" at stage: ",index)
-
-
-
-            i = 0
-            with open('paper_data/reference_rigid_graph_benchmark' + '40_%s' % index + '.dat') as reference:
-                for line in reference:
-                    if i in reference_data:
-                        parts = line.split()
-                        analytics_data.append(float(parts[2]))      # displacement from initial pos
-                    i+=1
-            i = 0
-            with open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % index) as current_data:
-                for line in current_data:
-                    if i in lines_DEM:
-                        parts = line.split()
-                        DEM_data.append(float(parts[2]))            # ref displacement from initial pos
-                    i+=1
-            fem_error2 = 0.0
-
-            for j in analytics_data:
-                summation_of_analytics_data+=abs(j)
-
-            for i, j in zip(DEM_data, analytics_data):
-                fem_error2+=abs(i-j)
-            fem_error2/=summation_of_analytics_data
-
-            if fem_error2>0.05:
-                Logger.PrintInfo("Error in delta displacement at the reference FEM subpart =", 100*fem_error2,"%"+" at stage: ",index)
-
-            error4.append(fem_error1)
-            error5.append(fem_error2)
-
-        delete_current_benchmark_data()
-        return error4, error5
-
-    def create_gnuplot_scripts(self, output_filename, dt):
-        pass
-
-def print_gnuplot_files_on_screen(gnuplot_script_name):
-    system('gnuplot -persist ' + gnuplot_script_name)
-
-def create_pdf_document(pdf_script_name):
-    system('gnuplot -persist ' + pdf_script_name)
+from KratosMultiphysics import *                                  # importing the Kratos Library
+from KratosMultiphysics.DEMApplication import *
+import shutil
+from glob import glob
+from math import pi, sin, cos, tan, atan, sqrt
+
+from os import system
+import os, sys
+files_to_delete_list = []
+
+def initialize_time_parameters(benchmark_number):
+
+    number_of_coeffs_of_restitution = 1
+
+    if benchmark_number==1:
+
+        end_time                      = 0.0005
+        dt                              = 6.4e-8 # Complies Rayleigh's condition
+        graph_print_interval            = 0.000005
+        number_of_points_in_the_graphic = 6
+
+    elif benchmark_number==2:
+
+        end_time                      = 0.007
+        dt                              = 3e-7 # Complies Rayleigh's condition????????????????
+        graph_print_interval            = 0.0001
+        number_of_points_in_the_graphic = 6
+
+    elif benchmark_number==3:
+
+        end_time                      = 0.00031
+        dt                              = 8.1e-9 #1.1e-9 # Complies Rayleigh's condition
+        graph_print_interval            = 0.000001
+        number_of_points_in_the_graphic = 6
+
+    elif benchmark_number==4:
+
+        end_time                      = 0.0002  #0.00003
+        dt                              = 2e-8 #1.9e-9 # Complies Rayleigh's condition
+        graph_print_interval            = 0.000001
+        number_of_points_in_the_graphic = 17
+
+    elif benchmark_number==5:
+
+        end_time                      = 0.0000005
+        dt                              = 3.6e-11  #3.6e-12 # Complies Rayleigh's condition
+        graph_print_interval            = 0.00000005
+        number_of_points_in_the_graphic = 17
+
+    elif benchmark_number==6:
+
+        end_time                      = 0.01
+        dt                              = 1.0e-6  #1.0e-7 # Complies Rayleigh's condition ????????????????
+        graph_print_interval            = 0.00025
+        number_of_points_in_the_graphic = 17
+
+    elif benchmark_number==7:
+
+        end_time                      = 0.0005
+        dt                              = 4.4614e-7 #4.4614e-8 # Complies Rayleigh's condition ????????????????
+        graph_print_interval            = 0.000005
+        number_of_points_in_the_graphic = 17
+
+    elif benchmark_number==8:
+
+        end_time                      = 0.02
+        dt                              = 2.0e-6 #5.0e-7 # Complies Rayleigh's condition
+        graph_print_interval            = 0.0001
+        number_of_points_in_the_graphic = 17
+
+    elif benchmark_number==9:
+
+        end_time                      = 0.001 #0.0005
+        dt                              = 5.0e-8 # 3.4e-8 # Complies Rayleigh's condition
+        graph_print_interval            = 0.000005
+        number_of_points_in_the_graphic = 6
+
+    elif benchmark_number==10:
+
+        end_time                      = 0.00015 #0.0005
+        dt                              = 2.0e-8  #3.6e-12 # Complies Rayleigh's condition
+        graph_print_interval            = 0.00001
+        number_of_points_in_the_graphic = 10
+        number_of_coeffs_of_restitution = 4
+
+    elif benchmark_number==11:
+
+        end_time                      = 0.00015 #0.0005
+        dt                              = 1.0e-7 #3.6e-12 # Complies Rayleigh's condition
+        graph_print_interval            = 0.00001
+        number_of_points_in_the_graphic = 10
+        number_of_coeffs_of_restitution = 4
+
+    elif benchmark_number==12:
+
+        end_time                      = 0.1
+        dt                              = 5.0e-7
+        graph_print_interval            = 1e-4
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==13:
+
+        end_time                      = 2.0
+        dt                              = 1.0e-4
+        graph_print_interval            = 1e-2
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==14:
+
+        end_time                      = 2.0
+        dt                              = 1.0e-4
+        graph_print_interval            = 1e-2
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==15:
+
+        end_time                      = 2.0
+        dt                              = 1.0e-4
+        graph_print_interval            = 1e-2
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==16:
+
+        end_time                      = 1.0
+        dt                              = 0.50e-4
+        graph_print_interval            = 1e-2
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==17:
+
+        end_time                      = 1.0
+        dt                              = 1.0e-6
+        graph_print_interval            = 1e-2
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==20:          # Normal compression
+
+        end_time                      = 0.01
+        dt                              = 1e-5
+        graph_print_interval            = 1e-5   # utilitzo com a output freq del grafic de punts
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==21:          # Normal compression with indentation
+
+        end_time                      = 0.01
+        dt                              = 1e-5
+        graph_print_interval            = 1e-5
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==22:          # Tensile
+
+        end_time                      = 0.05
+        dt                              = 1e-5
+        graph_print_interval            = 1e-5
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==23:          # Tensile with indentation
+
+        end_time                      = 0.05
+        dt                              = 1e-5
+        graph_print_interval            = 1e-5
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==24:          # Shear
+
+        end_time                      = 8e-5
+        dt                              = 1e-7
+        graph_print_interval            = 1e-7
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==25:          # Shear + radius expansion
+
+        end_time                      = 8e-5
+        dt                              = 1e-7
+        graph_print_interval            = 1e-7
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==26:          #
+
+        end_time                      = 0.1
+        dt                              = 1e-5
+        graph_print_interval            = 1e-4
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==27:          #UCS TEST
+
+        end_time                      = 0.05
+        dt                              = 5e-7
+        graph_print_interval            = 5e-4
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==28:          #PENDULO3D . not ready
+
+        end_time                      = 100
+        dt                              = 1e-4
+        graph_print_interval            = 1e-2
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==30:
+
+        end_time                      = 0.5
+        dt                              = 1.0e-3
+        graph_print_interval            = 1e-2
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==31:
+
+        end_time                      = 0.5
+        dt                              = 1.0e-3
+        graph_print_interval            = 1e-2
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==32:
+
+        end_time                      = 0.5
+        dt                              = 1.0e-6
+        graph_print_interval            = 1e-2
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==33:
+
+        end_time                      = 0.5
+        dt                              = 1.0e-6
+        graph_print_interval            = 1e-2
+        number_of_points_in_the_graphic = 1
+
+    elif benchmark_number==40:
+
+        end_time                      = 1
+        dt                              = 5e-5
+        graph_print_interval            = 1e-2
+        number_of_points_in_the_graphic = 1
+
+    else: #benchmark_number==68:        #
+
+        end_time                      = 1e-3
+        dt                              = 1e-6
+        graph_print_interval            = 1e-7
+        number_of_points_in_the_graphic = 1
+
+    return end_time, dt, graph_print_interval, number_of_points_in_the_graphic, number_of_coeffs_of_restitution
+
+
+def extend_datafile_list(arg):
+    files_to_delete_list.extend(arg)
+
+def delete_current_benchmark_data():
+    for to_erase_file in files_to_delete_list:
+        try:
+            os.remove(to_erase_file)
+        except OSError:
+            pass
+
+def PrintResultsMessage(test_number, it_is_success, error, elapsed_time, error_filename = 'errors.err'):
+    with open(error_filename, 'a') as error_file:
+        name = str(test_number)
+        error_file.write('DEM Benchmark ' + name + ':')
+
+        if it_is_success:
+            error_file.write(' OK!........ Test ' + name + ' SUCCESSFUL (error: '
+                             + str(round(error, 2)) + ', time: '
+                             + str(round(elapsed_time, 2)) + 's.'')\n')
+        else:
+            error_file.write(' KO!........ Test ' + name + ' FAILED (error: ' + str(error) + ')\n')
+
+def GetDisplacement(node):
+    displacement = [0]*3
+    displacement[0] = node.X-node.X0
+    displacement[1] = node.Y-node.Y0
+    displacement[2] = node.Z-node.Z0
+    return displacement
+
+def GetVectorNorm(node, variable):
+    return sqrt(sum([node.GetSolutionStepValue(variable)[i]**2 for i in range(3)]))
+
+def GetNodeDisplacement(node):
+    return sqrt(sum([GetDisplacement(node)[i]**2 for i in range(3)]))
+
+def ApplyErrorTolerance(error1=0.0, error2=0.0, error3=0.0, error4=0.0, error5=0.0):
+    tol = 5.0  # in %
+    if error1<tol: error1=0.0
+    if error2<tol: error2=0.0
+    if error3<tol: error3=0.0
+    if error4<tol: error4=0.0
+    if error5<tol: error5=0.0
+    return error1, error2, error3, error4, error5
+
+
+class Benchmark1:
+
+    def __init__(self):
+        self.number = 1
+        self.initial_normal_vel = 10.0
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        for node in modelpart.Nodes:
+            if node.Id == 1:
+                node.SetSolutionStepValue(VELOCITY_X, -self.initial_normal_vel)
+            else:
+                node.SetSolutionStepValue(VELOCITY_X,  self.initial_normal_vel)
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
+        pass
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
+        pass
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+
+        normal_contact_force_outfile_name = 'variables_for_node_1.txt'
+        gnuplot_script_name = 'benchmark1_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name, 'w')
+        self.gnuplot_outfile.write("set grid; plot '" + normal_contact_force_outfile_name + "' every 20 u 1:8 w lp lt -1 lw 1.5 ps 1 pt 4")
+        self.gnuplot_outfile.close()
+        #print_gnuplot_files_on_screen(gnuplot_script_name)
+
+        error1, error2, error3 = self.compute_errors(normal_contact_force_outfile_name)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+        it_is_success = error1 < 1.0 and error2 < 1.0 and error3 < 1.0
+        error_measure = error1 + error2 + error3
+
+        PrintResultsMessage(self.number, it_is_success, error_measure, elapsed_time)
+
+    def compute_errors(self, output_filename):
+
+        Chung_data = []; DEM_data = []
+
+        with open('paper_data/benchmark1_graph1.dat') as inf:
+            for line in inf:
+                Chung_data.append(float(line))
+
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                parts = line.split()
+                if parts[0] == '#Time':
+                    break
+            for line in inf:
+                parts = line.split()
+                DEM_data.append(float(parts[7]))
+
+        error = abs(max(DEM_data) - float(Chung_data[0]))/float(Chung_data[0])
+
+        Logger.PrintInfo("Error in restitution numbers =", 100*error,"%")
+
+        error1 = 100*error
+
+        error2 = error3 = 0
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+class Benchmark2:
+
+    def __init__(self):
+        self.number = 2
+        self.initial_normal_vel = -0.2
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        for node in modelpart.Nodes:
+            node.SetSolutionStepValue(VELOCITY_Z, self.initial_normal_vel)
+
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
+        pass
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
+        pass
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+
+        normal_contact_force_outfile_name = 'variables_for_node_2.txt'
+        gnuplot_script_name = 'benchmark2_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name, 'w')
+        self.gnuplot_outfile.write("set grid; plot '" + normal_contact_force_outfile_name + "' every 10 u 1:10 w lp lt 3 lw 1.5 ps 1 pt 6")
+        self.gnuplot_outfile.close()
+        #print_gnuplot_files_on_screen(gnuplot_script_name)
+
+        error1, error2, error3 = self.compute_errors(normal_contact_force_outfile_name)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+        it_is_success = error1 < 1.0 and error2 < 1.0 and error3 < 1.0
+        error_measure = error1 + error2 + error3
+
+        PrintResultsMessage(self.number, it_is_success, error_measure, elapsed_time)
+
+    def compute_errors(self, output_filename):
+
+        Chung_data = []; DEM_data = []
+
+        with open('paper_data/benchmark2_graph1.dat') as inf:
+            for line in inf:
+                Chung_data.append(float(line))
+
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                parts = line.split()
+                if parts[0] == '#Time':
+                    break
+            for line in inf:
+                parts = line.split()
+                DEM_data.append(float(parts[9]))
+
+        error = abs(max(DEM_data) - float(Chung_data[0]))/float(Chung_data[0])
+
+        Logger.PrintInfo("Error in restitution numbers =", 100*error,"%")
+
+        error1 = 100*error
+
+        error2 = error3 = 0
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+class Benchmark3:
+
+    def __init__(self):
+        self.number = 3
+        self.restitution_numbers_list = []
+        self.initial_normal_vel = 0
+        self.generated_data = None
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        #number = 1.0/(number_of_points_in_the_graphic-1) * (iteration - 1)
+
+        if number_of_points_in_the_graphic == 1:
+            number = 0
+        else:
+            number = 1.0/(number_of_points_in_the_graphic-1) * (iteration - 1)
+
+        for node in modelpart.Nodes:
+            self.initial_normal_vel = node.GetSolutionStepValue(VELOCITY_Z)
+            modelpart.GetProperties()[1][COEFFICIENT_OF_RESTITUTION] = number
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
+        pass
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
+
+        for node in modelpart.Nodes:
+            final_vel = node.GetSolutionStepValue(VELOCITY_Z)
+
+        restitution_coefficient = -final_vel / self.initial_normal_vel
+        self.restitution_numbers_list.append(restitution_coefficient)
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+
+        self.output_filename = "benchmark3_dt_" + str(dt) + '_restitution_numbers_vector_list_data.dat'
+        self.generated_data = open(self.output_filename, 'w')
+
+        for i in range(0, number_of_points_in_the_graphic):
+            first_col = 1/(number_of_points_in_the_graphic-1) * i
+            self.generated_data.write("%6.4f %11.8f" % (first_col, self.restitution_numbers_list[i]) + '\n')
+        self.generated_data.close()
+
+        gnuplot_script_name = 'benchmark3_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name, 'w')
+        self.gnuplot_outfile.write("set grid; plot '" + self.output_filename + "' u 1:2 w lp lt 3 lw 1.5 ps 2 pt 4, '"\
+                                                      + self.output_filename + "' u 1:3 w lp lt 2 lw 1.5 ps 2 pt 6")
+        self.gnuplot_outfile.close()
+
+        self.create_gnuplot_scripts(self.output_filename, dt)
+
+        error1, error2, error3 = self.compute_errors(self.output_filename)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+        it_is_success = error1 < 1.0 and error2 < 1.0 and error3 < 1.0
+        error_measure = error1 + error2 + error3
+
+        PrintResultsMessage(self.number, it_is_success, error_measure, elapsed_time)
+
+    def create_gnuplot_scripts(self, output_filename, dt):
+
+        gnuplot_script_name_1 = 'benchmark3_comparison_1_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Coefficient of restitution'\nset ylabel 'Damping ratio'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt  3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:1][0:1] '" + output_filename + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark3_graph1.dat' w lp ls 1 t 'Al. oxide',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark3_graph1.dat' w lp ls 2 t 'Cast iron'\n")
+        self.gnuplot_outfile.close()
+
+        #print_gnuplot_files_on_screen(gnuplot_script_name_1)
+
+    def compute_errors(self, output_filename):
+
+        lines_Chung = lines_DEM = list(range(0, 6))
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark3_graph1.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split()
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        generated_data_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+        for i, j in zip(DEM_data, Chung_data):
+            generated_data_error+=abs(i-j)
+        generated_data_error/=summation_of_Chung_data
+
+        Logger.PrintInfo("Error in restitution numbers =", 100*generated_data_error,"%")
+
+        error1 = 100*generated_data_error
+
+        error2 = error3 = 0
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+
+class Benchmark4:
+
+    def __init__(self):
+        self.number = 4
+        self.initial_module_vel = 3.9
+        self.initial_tangential_vel = 0
+        self.radius = 0.0025
+        self.degrees = 0
+        self.angles_list = []
+        self.tangential_restitution_coefficient_list = []
+        self.final_angular_vel_list = []
+        self.rebound_angle_list = []
+        self.final_angular_vel_list_outfile = None
+        self.rebound_angle_list_outfile = None
+        self.tangential_restitution_coefficient_list_outfile = None
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        self.degrees = 90 / (number_of_points_in_the_graphic + 1) * iteration
+        self.initial_tangential_vel =  self.initial_module_vel * sin(self.degrees * pi / 180.0)
+        initial_normal_vel = -self.initial_module_vel * cos(self.degrees * pi / 180.0)
+
+        for node in modelpart.Nodes:
+            node.SetSolutionStepValue(VELOCITY_Y, self.initial_tangential_vel)
+            node.SetSolutionStepValue(VELOCITY_Z, initial_normal_vel)
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
+        pass
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
+
+        for node in modelpart.Nodes:
+
+            final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_X)
+            final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_Y)
+            final_normal_center_velocity = node.GetSolutionStepValue(VELOCITY_Z)
+            final_tangential_contact_velocity = final_tangential_center_velocity + final_angular_vel * self.radius
+            rebound_angle = 180 / pi * atan(final_tangential_contact_velocity / final_normal_center_velocity)
+            tangential_restitution_coefficient = final_tangential_center_velocity / self.initial_tangential_vel
+
+        self.final_angular_vel_list.append(final_angular_vel)
+        self.rebound_angle_list.append(rebound_angle)
+        self.tangential_restitution_coefficient_list.append(tangential_restitution_coefficient)
+        self.angles_list.append(self.degrees)
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+
+        self.tangential_restitution_coefficient_list_outfile_name = "benchmark4_dt_" + str(dt) + '_tangential_restitution_coefficient_list_data.dat'
+        self.final_angular_vel_list_outfile_name = "benchmark4_dt_" + str(dt) + '_final_angular_vel_list_data.dat'
+        self.rebound_angle_list_outfile_name = "benchmark4_dt_" + str(dt) + '_rebound_angle_list_data.dat'
+        self.tangential_restitution_coefficient_list_outfile = open(self.tangential_restitution_coefficient_list_outfile_name, 'w')
+        self.final_angular_vel_list_outfile = open(self.final_angular_vel_list_outfile_name, 'w')
+        self.rebound_angle_list_outfile = open(self.rebound_angle_list_outfile_name, 'w')
+
+        for i in range(0, number_of_points_in_the_graphic):
+            self.tangential_restitution_coefficient_list_outfile.write("%14.8f %14.8f" % (self.angles_list[i], self.tangential_restitution_coefficient_list[i]) + '\n')
+            self.final_angular_vel_list_outfile.write("%14.8f %14.8f" % (self.angles_list[i], self.final_angular_vel_list[i]) + '\n')
+            self.rebound_angle_list_outfile.write("%14.8f %14.8f" % (self.angles_list[i], self.rebound_angle_list[i]) + '\n')
+        self.tangential_restitution_coefficient_list_outfile.close()
+        self.final_angular_vel_list_outfile.close()
+        self.rebound_angle_list_outfile.close()
+
+        self.create_gnuplot_scripts(self.tangential_restitution_coefficient_list_outfile_name, self.final_angular_vel_list_outfile_name,\
+                                    self.rebound_angle_list_outfile_name, dt)
+
+        error1, error2, error3 = self.compute_errors(self.tangential_restitution_coefficient_list_outfile_name, self.final_angular_vel_list_outfile_name,\
+                                    self.rebound_angle_list_outfile_name)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+        it_is_success = error1 < 2.0 and error2 < 2.0 and error3 < 2.0
+        error_measure = error1 + error2 + error3
+
+        PrintResultsMessage(self.number, it_is_success, error_measure, elapsed_time)
+
+    def create_gnuplot_scripts(self, tangential_restitution_coefficient_list_outfile_name, final_angular_vel_list_outfile_name,\
+                               rebound_angle_list_outfile_name, dt):
+
+        gnuplot_script_name_1 = 'benchmark4_comparison_1_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt  3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:90][.4:1] '" + tangential_restitution_coefficient_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark4_graph1.dat' index 0 w lp ls 1 t 'Al. oxide',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark4_graph1.dat' index 1 w lp ls 2 t 'Al. alloy',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark4_graph1.dat' index 2 w p pt 7 ps 2 lt -1 t 'Experimental'\n")
+        self.gnuplot_outfile.close()
+
+        gnuplot_script_name_2 = 'benchmark4_comparison_2_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Incident angle (deg)'\nset ylabel 'Final angular velocity (rad/s)'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt  3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:90][-750:0] '" + final_angular_vel_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark4_graph2.dat' index 0 w lp ls 1 t 'Al. oxide',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark4_graph2.dat' index 1 w lp ls 2 t 'Al. alloy',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark4_graph2.dat' index 2 w p pt 7 ps 2 lt -1 t 'Experimental'\n")
+        self.gnuplot_outfile.close()
+
+        gnuplot_script_name_3 = 'benchmark4_comparison_3_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_3, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Incident angle (deg)'\nset ylabel 'Rebound angle (deg)'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt  3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:90][-30:90] '" + rebound_angle_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark4_graph3.dat' index 0 w lp ls 1 t 'Al. oxide',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark4_graph3.dat' index 1 w lp ls 2 t 'Al. alloy',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark4_graph3.dat' index 2 w p pt 7 ps 2 lt -1 t 'Experimental'\n")
+        self.gnuplot_outfile.close()
+        '''
+        print_gnuplot_files_on_screen(gnuplot_script_name_1)
+        print_gnuplot_files_on_screen(gnuplot_script_name_2)
+        print_gnuplot_files_on_screen(gnuplot_script_name_3)'''
+
+    def compute_errors(self, tangential_restitution_coefficient_list_outfile_name, final_angular_vel_list_outfile_name, rebound_angle_list_outfile_name):
+
+        lines_Chung = list(range(17, 30)); lines_DEM = list(range(0, 8)) + list(range(9, 16, 2)) + [16]
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark4_graph1.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split(',')
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(tangential_restitution_coefficient_list_outfile_name) as inf:
+            extend_datafile_list(glob(tangential_restitution_coefficient_list_outfile_name))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_tangential_restitution_coefficient_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+        for i, j in zip(DEM_data, Chung_data):
+            final_tangential_restitution_coefficient_error+=abs(i-j)
+        final_tangential_restitution_coefficient_error/=summation_of_Chung_data
+        Logger.PrintInfo("Error in tangential restitution coefficient =", 100*final_tangential_restitution_coefficient_error,"%")
+
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark4_graph2.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split(',')
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(final_angular_vel_list_outfile_name) as inf:
+            extend_datafile_list(glob(final_angular_vel_list_outfile_name))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_angular_vel_total_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+        for i, j in zip(DEM_data, Chung_data):
+            final_angular_vel_total_error+=abs(i-j)
+        final_angular_vel_total_error/=summation_of_Chung_data
+        Logger.PrintInfo("Error in final angular vel =", 100*final_angular_vel_total_error,"%")
+
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark4_graph3.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split(',')
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(rebound_angle_list_outfile_name) as inf:
+            extend_datafile_list(glob(rebound_angle_list_outfile_name))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_rebound_angle_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+        for i, j in zip(DEM_data, Chung_data):
+            final_rebound_angle_error+=abs(i-j)
+        final_rebound_angle_error/=summation_of_Chung_data
+        Logger.PrintInfo("Error in final rebound angle =", 100*final_rebound_angle_error,"%")
+
+        error1 = 100*final_tangential_restitution_coefficient_error
+        error2 = 100*final_angular_vel_total_error
+        error3 = 100*final_rebound_angle_error
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+
+class Benchmark5:
+
+    def __init__(self):
+        self.number = 5
+        self.initial_normal_vel = -5.0
+        self.initial_tangential_vel = 0
+        self.radius = 0.00001
+        self.Vst_div_mu_per_Vcn_list = []
+        self.Vst_prima_div_mu_per_Vcn_prima_list = []
+        self.r_w1_prima_div_mu_per_Vcn_list = []
+        self.Vst_prima_div_mu_per_Vcn_prima_list_outfile = None
+        self.r_w1_prima_div_mu_per_Vcn_list_outfile = None
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        degrees = 90 / (number_of_points_in_the_graphic + 1) * iteration
+        self.initial_tangential_vel =  -self.initial_normal_vel * tan(degrees * pi / 180.0)
+
+        for node in modelpart.Nodes:
+            node.SetSolutionStepValue(VELOCITY_Y, self.initial_tangential_vel)
+            node.SetSolutionStepValue(VELOCITY_Z, self.initial_normal_vel)
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
+        pass
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
+
+        mu = 0.3
+
+        for node in modelpart.Nodes:
+            final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_X)
+            final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_Y)
+            final_normal_center_velocity = node.GetSolutionStepValue(VELOCITY_Z)
+            Vst_div_mu_per_Vcn = -self.initial_tangential_vel / (mu * self.initial_normal_vel)
+            Vst_prima_div_mu_per_Vcn_prima = (final_tangential_center_velocity + final_angular_vel * self.radius) / (mu * final_normal_center_velocity)
+            r_w1_prima_div_mu_per_Vcn = -self.radius * final_angular_vel / (mu * self.initial_normal_vel)
+
+        self.Vst_div_mu_per_Vcn_list.append(Vst_div_mu_per_Vcn)
+        self.Vst_prima_div_mu_per_Vcn_prima_list.append(Vst_prima_div_mu_per_Vcn_prima)
+        self.r_w1_prima_div_mu_per_Vcn_list.append(r_w1_prima_div_mu_per_Vcn)
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+
+        self.Vst_prima_div_mu_per_Vcn_prima_list_outfile_name = "benchmark5_dt_" + str(dt) + '_Vst_prima_div_mu_per_Vcn_prima_list_data.dat'
+        self.r_w1_prima_div_mu_per_Vcn_list_outfile_name = "benchmark5_dt_" + str(dt) + '_r_w1_prima_div_mu_per_Vcn_list_data.dat'
+        self.Vst_prima_div_mu_per_Vcn_prima_list_outfile = open(self.Vst_prima_div_mu_per_Vcn_prima_list_outfile_name, 'w')
+        self.r_w1_prima_div_mu_per_Vcn_list_outfile = open(self.r_w1_prima_div_mu_per_Vcn_list_outfile_name, 'w')
+
+        for i in range(0, number_of_points_in_the_graphic):
+            self.Vst_prima_div_mu_per_Vcn_prima_list_outfile.write("%14.8f %14.8f" % (self.Vst_div_mu_per_Vcn_list[i], self.Vst_prima_div_mu_per_Vcn_prima_list[i]) + '\n')
+            self.r_w1_prima_div_mu_per_Vcn_list_outfile.write("%14.8f %14.8f" % (self.Vst_div_mu_per_Vcn_list[i], self.r_w1_prima_div_mu_per_Vcn_list[i]) + '\n')
+        self.Vst_prima_div_mu_per_Vcn_prima_list_outfile.close()
+        self.r_w1_prima_div_mu_per_Vcn_list_outfile.close()
+
+        self.create_gnuplot_scripts(self.Vst_prima_div_mu_per_Vcn_prima_list_outfile_name, self.r_w1_prima_div_mu_per_Vcn_list_outfile_name, dt)
+
+        error1, error2, error3 = self.compute_errors(self.Vst_prima_div_mu_per_Vcn_prima_list_outfile_name, self.r_w1_prima_div_mu_per_Vcn_list_outfile_name)
+        it_is_success = error1 < 2.0 and error2 < 2.0 and error3 < 2.0
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+        error_measure = error1 + error2 + error3
+        PrintResultsMessage(self.number, it_is_success, error_measure, elapsed_time)
+
+    def create_gnuplot_scripts(self, Vst_prima_div_mu_per_Vcn_prima_list_outfile_name, r_w1_prima_div_mu_per_Vcn_list_outfile_name, dt):
+
+        gnuplot_script_name_1 = 'benchmark5_comparison_1_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:14][-4:6] '" + Vst_prima_div_mu_per_Vcn_prima_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark5_graph1.dat' index 0 w lp ls 1 t 'Steel',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark5_graph1.dat' index 1 w lp ls 2 t 'Polyethylene',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark5_graph1.dat' index 2 w p pt 7 ps 2 lt -1 t 'FEM'\n")
+        self.gnuplot_outfile.close()
+
+        gnuplot_script_name_2 = 'benchmark5_comparison_2_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Normalized incident angle'\nset ylabel 'Normalized final angular velocity'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:20][-6:0] '" + r_w1_prima_div_mu_per_Vcn_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark5_graph2.dat' index 0 w lp ls 1 t 'Steel',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark5_graph2.dat' index 1 w lp ls 2 t 'Polyethylene',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark5_graph2.dat' index 2 w p pt 7 ps 2 lt -1 t 'FEM'\n")
+        self.gnuplot_outfile.close()
+        '''
+        print_gnuplot_files_on_screen(gnuplot_script_name_1)
+        print_gnuplot_files_on_screen(gnuplot_script_name_2)'''
+
+    def compute_errors(self, Vst_prima_div_mu_per_Vcn_prima_list_outfile_name, r_w1_prima_div_mu_per_Vcn_list_outfile_name):
+
+        lines_Chung = list(range(49, 53)); lines_DEM = list(range(11, 15)) # Sliding regime for the time being
+        #lines_Chung = list(range(38, 53)); lines_DEM = list(range(0, 15)) # Whole diagram
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark5_graph1.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split(',')
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(Vst_prima_div_mu_per_Vcn_prima_list_outfile_name) as inf:
+            extend_datafile_list(glob(Vst_prima_div_mu_per_Vcn_prima_list_outfile_name))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_Vst_prima_div_mu_per_Vcn_prima_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+        for i, j in zip(DEM_data, Chung_data):
+            final_Vst_prima_div_mu_per_Vcn_prima_error+=abs(i-j)
+
+        final_Vst_prima_div_mu_per_Vcn_prima_error/=summation_of_Chung_data
+
+        Logger.PrintInfo("Error in final Vst prima div mu per Vcn prima =", 100*final_Vst_prima_div_mu_per_Vcn_prima_error,"%")
+
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark5_graph2.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split(',')
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(r_w1_prima_div_mu_per_Vcn_list_outfile_name) as inf:
+            extend_datafile_list(glob(r_w1_prima_div_mu_per_Vcn_list_outfile_name))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_r_w1_prima_div_mu_per_Vcn_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+        for i, j in zip(DEM_data, Chung_data):
+            final_r_w1_prima_div_mu_per_Vcn_error+=abs(i-j)
+
+        final_r_w1_prima_div_mu_per_Vcn_error/=summation_of_Chung_data
+        Logger.PrintInfo("Error in final r w1 prima div mu per Vcn =", 100*final_r_w1_prima_div_mu_per_Vcn_error,"%")
+
+        error1 = 100*final_Vst_prima_div_mu_per_Vcn_prima_error
+        error2 = 100*final_r_w1_prima_div_mu_per_Vcn_error
+        error3 = 0
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+
+class Benchmark6:
+
+    def __init__(self):
+        self.number = 6
+        self.initial_normal_vel = -0.2
+        self.initial_tangential_vel = 0
+        self.radius = 0.1
+        self.special_quantity_list = []
+        self.beta_list = []
+        self.Vst_div_Vcn_list = []
+        self.Vst_prima_div_Vcn_prima_list = []
+        self.beta_list_outfile = None
+        self.Vst_prima_div_Vcn_prima_list_outfile = None
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        degrees = 90 / (number_of_points_in_the_graphic + 1) * iteration
+        self.initial_tangential_vel = -self.initial_normal_vel * tan(degrees * pi / 180.0) # Here is tangential of the contact point, only. In X axis
+        initial_angular_vel = -self.initial_tangential_vel / self.radius # In Y axis
+
+        for node in modelpart.Nodes:
+            node.SetSolutionStepValue(VELOCITY_Z, self.initial_normal_vel)
+            node.SetSolutionStepValue(ANGULAR_VELOCITY_Y, initial_angular_vel)
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
+        pass
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
+
+        mu = 0.4
+        restitution_coeff = 0.5
+
+        for node in modelpart.Nodes:
+            special_quantity = -3.5 * mu * (1.0 + restitution_coeff) * self.initial_normal_vel / self.initial_tangential_vel
+            final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)
+            final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_X)
+            final_normal_center_velocity = node.GetSolutionStepValue(VELOCITY_Z)
+            beta = -(final_tangential_center_velocity - final_angular_vel * self.radius)/ self.initial_tangential_vel
+            Vst_div_Vcn = -self.initial_tangential_vel / self.initial_normal_vel
+            Vst_prima_div_Vcn_prima = (final_tangential_center_velocity - final_angular_vel * self.radius) / final_normal_center_velocity
+
+        self.special_quantity_list.append(special_quantity)
+        self.beta_list.append(beta)
+        self.Vst_div_Vcn_list.append(Vst_div_Vcn)
+        self.Vst_prima_div_Vcn_prima_list.append(Vst_prima_div_Vcn_prima)
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+
+        self.beta_list_outfile_name = "benchmark6_dt_" + str(dt) + '_beta_list_data.dat'
+        self.Vst_prima_div_Vcn_prima_list_outfile_name = "benchmark6_dt_" + str(dt) + '_Vst_prima_div_Vcn_prima_data.dat'
+        self.beta_list_outfile = open(self.beta_list_outfile_name, 'w')
+        self.Vst_prima_div_Vcn_prima_list_outfile = open(self.Vst_prima_div_Vcn_prima_list_outfile_name, 'w')
+
+        for i in range(0, number_of_points_in_the_graphic):
+            self.beta_list_outfile.write("%14.8f %14.8f" % (self.special_quantity_list[i], self.beta_list[i]) + '\n')
+            self.Vst_prima_div_Vcn_prima_list_outfile.write("%14.8f %14.8f" % (self.Vst_div_Vcn_list[i], self.Vst_prima_div_Vcn_prima_list[i]) + '\n')
+        self.beta_list_outfile.close()
+        self.Vst_prima_div_Vcn_prima_list_outfile.close()
+
+        self.create_gnuplot_scripts(self.beta_list_outfile_name, self.Vst_prima_div_Vcn_prima_list_outfile_name, dt)
+
+        error1, error2, error3 = self.compute_errors(self.beta_list_outfile_name, self.Vst_prima_div_Vcn_prima_list_outfile_name)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+        it_is_success = error1 < 3.0 and error2 < 3.0 and error3 < 3.0
+        error_measure = error1 + error2 + error3
+
+        PrintResultsMessage(self.number, it_is_success, error_measure, elapsed_time)
+
+    def create_gnuplot_scripts(self, beta_list_outfile_name, Vst_prima_div_Vcn_prima_list_outfile_name, dt):
+
+        gnuplot_script_name_1 = 'benchmark6_comparison_1_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:25][-1:.6] '" + beta_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark6_graph1.dat' index 0 w lp ls 1 t 'Al. alloy',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark6_graph1.dat' index 1 w lp ls 2 t 'Nylon'\n")
+        self.gnuplot_outfile.close()
+
+        gnuplot_script_name_2 = 'benchmark6_comparison_2_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Tangent of incident angle'\nset ylabel 'Tangent of recoil angle'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:7][-2:8] '" + Vst_prima_div_Vcn_prima_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark6_graph2.dat' index 0 w lp ls 1 t 'Al. alloy',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark6_graph2.dat' index 1 w lp ls 2 t 'Nylon'\n")
+        self.gnuplot_outfile.close()
+        '''
+        print_gnuplot_files_on_screen(gnuplot_script_name_1)
+        print_gnuplot_files_on_screen(gnuplot_script_name_2)'''
+
+    def compute_errors(self, beta_list_outfile_name, Vst_prima_div_Vcn_prima_list_outfile_name):
+
+        lines_Chung = list(range(1, 7)); lines_DEM = list(range(16, 10, -1)) # Sliding regime for the time being
+        #lines_Chung = list(range(1, 17)); lines_DEM = list(range(0, 16)) # Whole diagram
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark6_graph1.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split(',')
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+
+        with open(beta_list_outfile_name) as inf:
+            extend_datafile_list(glob(beta_list_outfile_name))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_beta_list_outfile_name_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+        DEM_data.reverse()
+        for i, j in zip(DEM_data, Chung_data):
+            final_beta_list_outfile_name_error+=abs(i-j)
+
+        final_beta_list_outfile_name_error/=summation_of_Chung_data
+        Logger.PrintInfo("Error in final beta =", 100*final_beta_list_outfile_name_error,"%")
+
+        lines_Chung = list(range(13, 17)); lines_DEM = list(range(12, 16)) # Sliding regime for the time being
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark6_graph2.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split(',')
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(Vst_prima_div_Vcn_prima_list_outfile_name) as inf:
+            extend_datafile_list(glob(Vst_prima_div_Vcn_prima_list_outfile_name))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_Vst_prima_div_Vcn_prima_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+
+        for i, j in zip(DEM_data, Chung_data):
+            final_Vst_prima_div_Vcn_prima_error+=abs(i-j)
+
+        final_Vst_prima_div_Vcn_prima_error/=summation_of_Chung_data
+        Logger.PrintInfo("Error in final Vst prima div Vcn =", 100*final_Vst_prima_div_Vcn_prima_error,"%")
+
+        error1 = 100*final_beta_list_outfile_name_error
+        error2 = 100*final_Vst_prima_div_Vcn_prima_error
+        error3 = 0
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+class Benchmark7:
+
+    def __init__(self):
+        self.number = 7
+        self.initial_angular_vel = 0
+        self.final_tangential_center_vel_list_outfile = None
+        self.final_angular_vel_list_outfile = None
+        self.initial_angular_vel_list = []
+        self.final_tangential_center_vel_list = []
+        self.final_angular_vel_list = []
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        initial_normal_vel = 0.2
+        radius = 0.1
+        degrees = 90 / (number_of_points_in_the_graphic + 1) * iteration
+        self.initial_angular_vel =  initial_normal_vel / radius * tan(degrees * pi / 180.0) # Here is tangential of the contact point, only
+
+        for node in modelpart.Nodes:
+            if node.Id == 1:
+                node.SetSolutionStepValue(VELOCITY_X,  initial_normal_vel)
+                node.SetSolutionStepValue(ANGULAR_VELOCITY_Y,  self.initial_angular_vel)
+            else:
+                node.SetSolutionStepValue(VELOCITY_X, -initial_normal_vel)
+                node.SetSolutionStepValue(ANGULAR_VELOCITY_Y, -self.initial_angular_vel)
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
+        pass
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
+
+        for node in modelpart.Nodes:
+            if node.Id == 1:
+                final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_Z)
+                final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)
+
+        self.initial_angular_vel_list.append(self.initial_angular_vel)
+        self.final_tangential_center_vel_list.append(final_tangential_center_velocity)
+        self.final_angular_vel_list.append(final_angular_vel)
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+
+        self.final_tangential_center_vel_list_outfile_name = "benchmark7_dt_" + str(dt) + '_final_tangential_center_vel_list_data.dat'
+        self.final_angular_vel_list_outfile_name = "benchmark7_dt_" + str(dt) + '_final_angular_vel_list_data.dat'
+        self.final_tangential_center_vel_list_outfile = open(self.final_tangential_center_vel_list_outfile_name, 'w')
+        self.final_angular_vel_list_outfile = open(self.final_angular_vel_list_outfile_name, 'w')
+
+        for i in range(0, number_of_points_in_the_graphic):
+            self.final_tangential_center_vel_list_outfile.write("%14.8f %14.8f" % (self.initial_angular_vel_list[i], self.final_tangential_center_vel_list[i]) + '\n')
+            self.final_angular_vel_list_outfile.write("%14.8f %14.8f" % (self.initial_angular_vel_list[i], self.final_angular_vel_list[i]) + '\n')
+        self.final_tangential_center_vel_list_outfile.close()
+        self.final_angular_vel_list_outfile.close()
+
+        gnuplot_script_name = 'benchmark7_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name, 'w')
+        self.gnuplot_outfile.write("set multiplot layout 2, 1; set grid; set bmargin 0; set format x \"\"; set ytics -5, 5; set key bottom;\
+                                    plot [0:25][-10:10] '" + self.final_tangential_center_vel_list_outfile_name + "' w lp lw 1.5 ps 2 pt 4;\
+                                    set bmargin; set tmargin 0; set format x \"%g\"; set ytics 0, 5, 20; set key top;\
+                                    plot [0:25][0:25] '" + self.final_angular_vel_list_outfile_name + "' w lp lw 1.5 lt 3 ps 2 pt 6; unset multiplot")
+        self.gnuplot_outfile.close()
+
+        self.create_gnuplot_scripts(self.final_tangential_center_vel_list_outfile_name, self.final_angular_vel_list_outfile_name, dt)
+
+        error1, error2, error3 = self.compute_errors(self.final_tangential_center_vel_list_outfile_name, self.final_angular_vel_list_outfile_name)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+        it_is_success = error1 < 1.0 and error2 < 1.0 and error3 < 1.0
+        error_measure = error1 + error2 + error3
+
+        PrintResultsMessage(self.number, it_is_success, error_measure, elapsed_time)
+
+    def create_gnuplot_scripts(self, final_tangential_center_vel_list_outfile_name, final_angular_vel_list_outfile_name, dt):
+
+        gnuplot_script_name_1 = 'benchmark7_comparison_1_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:25][-10:10] '" + final_tangential_center_vel_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark7_graph1.dat' w lp ls 1 t 'Al. alloy',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark7_graph1.dat' w lp ls 2 t 'Copper'\n")
+        self.gnuplot_outfile.close()
+
+        gnuplot_script_name_2 = 'benchmark7_comparison_2_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Initial angular velocity (rad/s)'\nset ylabel 'Final angular velocity (rad/s)'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:25][0:25] '" + final_angular_vel_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark7_graph2.dat' w lp ls 1 t 'Al. alloy',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark7_graph2.dat' w lp ls 2 t 'Copper'\n")
+        self.gnuplot_outfile.close()
+        '''
+        print_gnuplot_files_on_screen(gnuplot_script_name_1)
+        print_gnuplot_files_on_screen(gnuplot_script_name_2)'''
+
+    def compute_errors(self, final_tangential_center_vel_list_outfile_name, final_angular_vel_list_outfile_name):
+
+        lines_Chung = []; lines_DEM = []; lines_Chung = list(range(0, 17)); lines_DEM = list(range(0, 17))
+        Chung_data = []; DEM_data = []
+        i = 0
+        with open('paper_data/benchmark7_graph1.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split()
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(final_tangential_center_vel_list_outfile_name) as inf:
+            extend_datafile_list(glob(final_tangential_center_vel_list_outfile_name))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_tangential_center_vel_error = 0
+
+        for i, j in zip(DEM_data, Chung_data):
+            final_tangential_center_vel_error+=abs(i-j)
+        Logger.PrintInfo("Error in final tangential center vel =", final_tangential_center_vel_error)
+
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark7_graph2.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split()
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(final_angular_vel_list_outfile_name) as inf:
+            extend_datafile_list(glob(final_angular_vel_list_outfile_name))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_angular_vel_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+        for i, j in zip(DEM_data, Chung_data):
+            final_angular_vel_error+=abs(i-j)
+
+        final_angular_vel_error/=summation_of_Chung_data
+        Logger.PrintInfo("Error in final angular vel =", 100*final_angular_vel_error,"%")
+
+        error1 = 100*final_tangential_center_vel_error
+        error2 = 100*final_angular_vel_error
+        error3 = 0
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+
+class Benchmark8:
+
+    def __init__(self):
+        self.number = 8
+        self.initial_normal_vel = 0.2
+        self.initial_tangential_vel = 0
+        self.radius = 0.1
+        self.special_quantity_list = []
+        self.beta_list = []
+        self.Vst_div_Vcn_list = []
+        self.Vst_prima_div_Vcn_prima_list = []
+        self.beta_list_outfile = None
+        self.Vst_prima_div_Vcn_prima_list_outfile = None
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        degrees = 90 - 90 / (number_of_points_in_the_graphic + 1) * iteration
+        self.initial_tangential_vel =  self.initial_normal_vel * tan(degrees * pi / 180.0) # Here is tangential of the contact point, only
+        initial_angular_vel    =  -self.initial_tangential_vel / self.radius
+
+        for node in modelpart.Nodes:
+            if node.Id == 1:
+                node.SetSolutionStepValue(VELOCITY_X, self.initial_normal_vel)
+                node.SetSolutionStepValue(ANGULAR_VELOCITY_Y, initial_angular_vel)
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
+        pass
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
+
+        mu = 0.4
+        restitution_coeff = 0.5
+
+        for node in modelpart.Nodes:
+            if node.Id == 1:
+                special_quantity = 3.5 * mu * (1.0 + restitution_coeff) * self.initial_normal_vel / self.initial_tangential_vel
+                final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)
+                final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_Z)
+                final_normal_center_velocity = node.GetSolutionStepValue(VELOCITY_X)
+                beta = -(final_tangential_center_velocity - final_angular_vel * self.radius)/ self.initial_tangential_vel
+                Vst_div_Vcn = self.initial_tangential_vel / self.initial_normal_vel
+                Vst_prima_div_Vcn_prima = -(final_tangential_center_velocity - final_angular_vel * self.radius) / final_normal_center_velocity
+
+        self.special_quantity_list.append(special_quantity)
+        self.beta_list.append(beta)
+        self.Vst_div_Vcn_list.append(Vst_div_Vcn)
+        self.Vst_prima_div_Vcn_prima_list.append(Vst_prima_div_Vcn_prima)
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+
+        self.beta_list_outfile_name = 'benchmark8_dt_' + str(dt) + 's_beta_list_data.dat'
+        self.Vst_prima_div_Vcn_prima_list_outfile_name = 'benchmark8_dt_' + str(dt) + 's_Vst_prima_div_Vcn_prima_list_data.dat'
+        self.beta_list_outfile = open(self.beta_list_outfile_name, 'w')
+        self.Vst_prima_div_Vcn_prima_list_outfile = open(self.Vst_prima_div_Vcn_prima_list_outfile_name, 'w')
+
+        for i in range(0, number_of_points_in_the_graphic):
+            self.beta_list_outfile.write("%14.8f %14.8f" % (self.special_quantity_list[i], self.beta_list[i]) + '\n')
+            self.Vst_prima_div_Vcn_prima_list_outfile.write("%14.8f %14.8f" % (self.Vst_div_Vcn_list[i], self.Vst_prima_div_Vcn_prima_list[i]) + '\n')
+
+        self.beta_list_outfile.close()
+        self.Vst_prima_div_Vcn_prima_list_outfile.close()
+
+        self.create_gnuplot_scripts(self.beta_list_outfile_name, self.Vst_prima_div_Vcn_prima_list_outfile_name, dt)
+
+        error1, error2, error3 = self.compute_errors(self.beta_list_outfile_name, self.Vst_prima_div_Vcn_prima_list_outfile_name)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+        it_is_success = error1 < 3.0 and error2 < 3.0 and error3 < 3.0
+        error_measure = error1 + error2 + error3
+
+        PrintResultsMessage(self.number, it_is_success, error_measure, elapsed_time)
+
+    def create_gnuplot_scripts(self, beta_list_outfile_name, Vst_prima_div_Vcn_prima_list_outfile_name, dt):
+
+        gnuplot_script_name_1 = 'benchmark8_comparison_1_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:25][-1:.6] '" + beta_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark8_graph1.dat' index 0 w lp ls 1 t 'Al. alloy',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark8_graph1.dat' index 1 w lp ls 2 t 'Nylon'\n")
+        self.gnuplot_outfile.close()
+
+        gnuplot_script_name_2 = 'benchmark8_comparison_2_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Tangent of incident angle'\nset ylabel 'Tangent of recoil angle'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:8][-2:8] '" + Vst_prima_div_Vcn_prima_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark8_graph2.dat' index 0 w lp ls 1 t 'Al. alloy',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark8_graph2.dat' index 1 w lp ls 2 t 'Nylon'\n")
+        self.gnuplot_outfile.close()
+        '''
+        print_gnuplot_files_on_screen(gnuplot_script_name_1)
+        print_gnuplot_files_on_screen(gnuplot_script_name_2)'''
+
+    def compute_errors(self, beta_list_outfile_name, Vst_prima_div_Vcn_prima_list_outfile_name):
+
+        lines_Chung = []; lines_DEM = []; lines_Chung = list(range(1, 7)); lines_DEM = list(range(0, 6)) # Sliding regime for the time being
+        #lines_Chung = []; lines_DEM = []; lines_Chung = list(range(1, 18)); lines_DEM = list(range(0, 17)) # Whole diagram
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark8_graph1.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split(',')
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(beta_list_outfile_name) as inf:
+            extend_datafile_list(glob(beta_list_outfile_name))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_beta_list_outfile_name_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+        for i, j in zip(DEM_data, Chung_data):
+            final_beta_list_outfile_name_error+=abs(i-j)
+
+        final_beta_list_outfile_name_error/=summation_of_Chung_data
+        Logger.PrintInfo("Error in final beta =", 100*final_beta_list_outfile_name_error,"%")
+
+        lines_Chung = []; lines_DEM = []; lines_DEM = list(range(4, 0, -1)); lines_Chung = list(range(13, 17)) # Sliding regime for the time being
+        #lines_Chung = list(range(1, 17)); lines_DEM = list(range(0, 16)) # Whole diagram
+
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark8_graph2.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split(',')
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(Vst_prima_div_Vcn_prima_list_outfile_name) as inf:
+            extend_datafile_list(glob(Vst_prima_div_Vcn_prima_list_outfile_name))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_Vst_prima_div_Vcn_prima_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+        DEM_data.reverse()
+        for i, j in zip(DEM_data, Chung_data):
+            final_Vst_prima_div_Vcn_prima_error+=abs(i-j)
+
+        final_Vst_prima_div_Vcn_prima_error/=summation_of_Chung_data
+        Logger.PrintInfo("Error in final Vst prima div Vcn =", 100*final_Vst_prima_div_Vcn_prima_error,"%")
+
+        error1 = 100*final_beta_list_outfile_name_error
+        error2 = 100*final_Vst_prima_div_Vcn_prima_error
+        error3 = 0
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+class Benchmark9:
+
+    def __init__(self):
+        self.number = 9
+        self.initial_normal_vel = 200.0
+        self.restitution_numbers_list = []
+        self.generated_data = None
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        if number_of_points_in_the_graphic == 1:
+            number = 0
+        else:
+            number = 1.0/(number_of_points_in_the_graphic-1) * (iteration - 1)
+
+        for node in modelpart.Nodes:
+
+            if node.Id == 1:
+                node.SetSolutionStepValue(VELOCITY_X,  self.initial_normal_vel)
+                node.SetSolutionStepValue(VELOCITY_Z, 0.0)
+                modelpart.GetProperties()[1][COEFFICIENT_OF_RESTITUTION] = number
+            else:
+                node.SetSolutionStepValue(VELOCITY_X, -self.initial_normal_vel)
+                node.SetSolutionStepValue(VELOCITY_Z, 0.0)
+                modelpart.GetProperties()[1][COEFFICIENT_OF_RESTITUTION] = number
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
+        pass
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
+
+        for node in modelpart.Nodes:
+            if node.Id == 1:
+                final_vel = node.GetSolutionStepValue(VELOCITY_X)
+
+        restitution_coefficient = -final_vel / self.initial_normal_vel
+        self.restitution_numbers_list.append(restitution_coefficient)
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+
+        self.output_filename = "benchmark9_dt_" + str(dt) + '_restitution_numbers_vector_list_data.dat'
+        self.generated_data = open(self.output_filename, 'w')
+
+        for i in range(0, number_of_points_in_the_graphic):
+            if number_of_points_in_the_graphic == 1:
+                first_col = 0
+            else:
+                first_col = 1/(number_of_points_in_the_graphic-1) * i
+            self.generated_data.write("%6.4f %11.8f" % (first_col, self.restitution_numbers_list[i]) + '\n')
+        self.generated_data.close()
+
+        gnuplot_script_name = 'benchmark9_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name, 'w')
+        self.gnuplot_outfile.write("set grid; plot '" + self.output_filename + "' u 1:2 w lp lt 3 lw 1.5 ps 2 pt 4, '"\
+                                                      + self.output_filename + "' u 1:3 w lp lt 2 lw 1.5 ps 2 pt 6")
+        self.gnuplot_outfile.close()
+
+        self.create_gnuplot_scripts(self.output_filename, dt)
+
+        error1, error2, error3 = self.compute_errors(self.output_filename)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+        it_is_success = error1 < 1.0 and error2 < 1.0 and error3 < 1.0
+        error_measure = error1 + error2 + error3
+
+        PrintResultsMessage(self.number, it_is_success, error_measure, elapsed_time)
+
+    def create_gnuplot_scripts(self, output_filename, dt):
+
+        gnuplot_script_name_1 = 'benchmark9_comparison_1_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Coefficient of restitution'\nset ylabel 'Damping ratio'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt  3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:1][0:1] '" + output_filename + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark9_graph1.dat' w lp ls 1 t 'Al. oxide',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark9_graph1.dat' w lp ls 2 t 'Cast iron'\n")
+        self.gnuplot_outfile.close()
+
+        #print_gnuplot_files_on_screen(gnuplot_script_name_1)
+
+    def compute_errors(self, output_filename):
+
+        lines_Chung = lines_DEM = list(range(0, 6));
+        Chung_data = []; DEM_data = []; summation_of_Chung_data = 0
+        i = 0
+        with open('paper_data/benchmark9_graph1.dat') as inf:
+            for line in inf:
+                if i in lines_Chung:
+                    parts = line.split()
+                    Chung_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        generated_data_error = 0
+
+        for j in Chung_data:
+            summation_of_Chung_data+=abs(j)
+
+        for i, j in zip(DEM_data, Chung_data):
+            generated_data_error+=abs(i-j)
+        generated_data_error/=summation_of_Chung_data
+
+        Logger.PrintInfo("Error in restitution numbers =", 100*generated_data_error,"%")
+
+        error1 = 100*generated_data_error
+
+        error2 = error3 = 0
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+
+class Benchmark10: ########## LINEAR THORNTON
+
+    def __init__(self):
+        self.number = 10
+        self.initial_normal_vel = -5.0
+        self.initial_tangential_vel = 0
+        self.radius = 0.025
+        self.normalized_impact_angle_list = []
+        self.normalized_rebound_tangential_surface_vel_list = []
+        self.normalized_rebound_angular_velocity_list = []
+        self.tangential_coefficient_of_restitution_list = []
+        self.normalized_rebound_tangential_surface_vel_list_outfile = None
+        self.normalized_rebound_angular_velocity_list_outfile = None
+        self.tangential_coefficient_of_restitution_list_outfile = None
+        self.coeff_of_restitution = -1.0
+        self.coeff_of_rest_string = None
+        self.lines_Thornton = []
+        self.lines_DEM = []
+        self.degrees = 0
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):   # Change this function name from 'set_initial_data' to 'set_initial_data'
+
+        if iteration == 1:
+            self.degrees = 1
+        else:
+            self.degrees = 50 * (iteration - 1)/number_of_points_in_the_graphic
+
+        if coeff_of_restitution_iteration==1:
+            self.coeff_of_restitution=0.25
+            self.coeff_of_rest_string='025'
+            self.lines_Thornton = [12, 13, 15, 16, 18, 19]
+            self.lines_DEM = [0, 1, 3, 4, 5, 6]
+        elif coeff_of_restitution_iteration==2:
+            self.coeff_of_restitution=0.50
+            self.coeff_of_rest_string='050'
+            self.lines_Thornton = [14, 15, 17, 18, 20, 22, 23]
+            self.lines_DEM = [0, 1, 3, 4, 5, 6, 7]
+        elif coeff_of_restitution_iteration==3:
+            self.coeff_of_restitution=0.75
+            self.coeff_of_rest_string='075'
+            self.lines_Thornton = [14, 15, 17, 18, 19, 22, 23, 24]
+            self.lines_DEM = [0, 1, 3, 4, 5, 6, 7, 8]
+        else:
+            self.coeff_of_restitution=0.90
+            self.coeff_of_rest_string='090'
+            self.lines_Thornton = [13, 14, 16, 17, 18, 21, 22, 23]
+            self.lines_DEM = [0, 1, 3, 4, 5, 6, 7, 8]
+
+        self.initial_tangential_vel = -self.initial_normal_vel * tan(self.degrees * pi / 180.0)
+
+        for node in modelpart.Nodes:
+            node.SetSolutionStepValue(VELOCITY_Y, self.initial_tangential_vel)
+            node.SetSolutionStepValue(VELOCITY_Z, self.initial_normal_vel)
+            modelpart.GetProperties()[1][COEFFICIENT_OF_RESTITUTION] = self.coeff_of_restitution
+
+        Logger.PrintInfo(self.coeff_of_restitution)
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
+
+        mu = 0.1
+
+        for node in modelpart.Nodes:
+            final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_X)
+            final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_Y)
+            normalized_impact_angle = 2.0 * tan(self.degrees * pi / 180.0) / (mu * (1 + self.coeff_of_restitution))
+            normalized_rebound_tangential_surface_vel = -2.0 * (final_tangential_center_velocity + final_angular_vel * self.radius) / (self.initial_normal_vel * mu * (1 + self.coeff_of_restitution))
+            normalized_rebound_angular_velocity = -2.0 * self.radius * final_angular_vel / (self.initial_normal_vel * mu * (1 + self.coeff_of_restitution))
+            tangential_coefficient_of_restitution = 5.0/7.0 + 2.0 * normalized_rebound_tangential_surface_vel / (7.0 * normalized_impact_angle)
+
+        self.normalized_impact_angle_list.append(normalized_impact_angle)
+        self.normalized_rebound_tangential_surface_vel_list.append(normalized_rebound_tangential_surface_vel)
+        self.normalized_rebound_angular_velocity_list.append(normalized_rebound_angular_velocity)
+        self.tangential_coefficient_of_restitution_list.append(tangential_coefficient_of_restitution)
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+
+        self.normalized_rebound_tangential_surface_vel_list_outfile_name = "benchmark10_dt_" + str(dt) + '_normalized_rebound_tangential_surface_vel_list_data.dat'
+        self.normalized_rebound_angular_velocity_list_outfile_name = "benchmark10_dt_" + str(dt) + '_normalized_rebound_angular_velocity_list_data.dat'
+        self.tangential_coefficient_of_restitution_list_outfile_name = "benchmark10_dt_" + str(dt) + '_tangential_coefficient_of_restitution_list_data.dat'
+
+        self.normalized_rebound_tangential_surface_vel_list_outfile = open(self.normalized_rebound_tangential_surface_vel_list_outfile_name, 'w')
+        self.normalized_rebound_angular_velocity_list_outfile = open(self.normalized_rebound_angular_velocity_list_outfile_name, 'w')
+        self.tangential_coefficient_of_restitution_list_outfile = open(self.tangential_coefficient_of_restitution_list_outfile_name, 'w')
+
+        for i in range(0, number_of_points_in_the_graphic):
+            self.normalized_rebound_tangential_surface_vel_list_outfile.write("%14.8f %14.8f" % (self.normalized_impact_angle_list[i], self.normalized_rebound_tangential_surface_vel_list[i]) + '\n')
+            self.normalized_rebound_angular_velocity_list_outfile.write("%14.8f %14.8f" % (self.normalized_impact_angle_list[i], self.normalized_rebound_angular_velocity_list[i]) + '\n')
+            self.tangential_coefficient_of_restitution_list_outfile.write("%14.8f %14.8f" % (self.normalized_impact_angle_list[i], self.tangential_coefficient_of_restitution_list[i]) + '\n')
+        self.normalized_rebound_tangential_surface_vel_list_outfile.close()
+        self.normalized_rebound_angular_velocity_list_outfile.close()
+        self.tangential_coefficient_of_restitution_list_outfile.close()
+
+        self.create_gnuplot_scripts(self.normalized_rebound_tangential_surface_vel_list_outfile_name,
+                                    self.normalized_rebound_angular_velocity_list_outfile_name,
+                                    self.tangential_coefficient_of_restitution_list_outfile_name,
+                                    self.coeff_of_rest_string, dt)
+
+        error1, error2, error3 = self.compute_errors(self.normalized_rebound_tangential_surface_vel_list_outfile_name,
+                                                     self.normalized_rebound_angular_velocity_list_outfile_name,
+                                                     self.tangential_coefficient_of_restitution_list_outfile_name)
+
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+
+        coeff_of_rest = '%.2f' % self.coeff_of_restitution
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+
+        if (coeff_of_rest=='0.25'):
+            error_file.write("\n===== THORNTON PAPER TESTS. FULL REGIME. LINEAR LAW =====\n\n")
+
+        error_file.write("DEM Benchmark 10:")
+
+        if (error1 < 5.0 and error2 < 5.0 and error3 < 5.0):
+            error_file.write(" OK!........ Test 10 (e=" + coeff_of_rest + ") SUCCESSFUL\n")
+        else:
+            error_file.write(" KO!........ Test 10 (e=" + coeff_of_rest + ") FAILED\n")
+        error_file.close()
+
+        self.normalized_impact_angle_list = []
+        self.normalized_rebound_tangential_surface_vel_list = []
+        self.normalized_rebound_angular_velocity_list = []
+        self.tangential_coefficient_of_restitution_list = []
+
+    def create_gnuplot_scripts(self, normalized_rebound_tangential_surface_vel_list_outfile_name,
+                                     normalized_rebound_angular_velocity_list_outfile_name,
+                                     tangential_coefficient_of_restitution_list_outfile_name,
+                                     coeff_of_rest_string, dt):
+
+        gnuplot_script_name_1 = 'benchmark10_comparison_1_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Normalized incident angle'\nset ylabel 'Normalized rebound tangential surface velocity'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:10][-2:3] '" + normalized_rebound_tangential_surface_vel_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/bench_10_norm_reb_tang_e_" + coeff_of_rest_string + ".dat' index 1 w lp ls 1 t 'Paper data'\n")
+        self.gnuplot_outfile.close()
+
+        gnuplot_script_name_2 = 'benchmark10_comparison_2_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Normalized incident angle'\nset ylabel 'Normalized final angular velocity'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:14][-6:0] '" + normalized_rebound_angular_velocity_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/bench_10_norm_reb_ang_vel_e_" + coeff_of_rest_string + ".dat' index 1 w lp ls 1 t 'Paper data'\n")
+        self.gnuplot_outfile.close()
+
+        gnuplot_script_name_3 = 'benchmark10_comparison_3_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_3, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Normalized incident angle'\nset ylabel 'Tangential coefficient of restitution'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:10][0.5:1.0] '" + tangential_coefficient_of_restitution_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/bench_10_tang_coeff_rest_e_" + coeff_of_rest_string + ".dat' index 1 w lp ls 1 t 'Paper data'\n")
+        self.gnuplot_outfile.close()
+
+        '''
+        print_gnuplot_files_on_screen(gnuplot_script_name_1)
+        print_gnuplot_files_on_screen(gnuplot_script_name_2)
+        print_gnuplot_files_on_screen(gnuplot_script_name_3)
+
+        '''
+
+    def compute_errors(self, normalized_rebound_tangential_surface_vel_list_outfile_name,
+                             normalized_rebound_angular_velocity_list_outfile_name,
+                             tangential_coefficient_of_restitution_list_outfile_name):
+        #
+        Thornton_data = []; DEM_data = []; summation_of_Thornton_data = 0
+        i = 0
+        path = "paper_data/bench_10_norm_reb_tang_e_" + self.coeff_of_rest_string + ".dat"
+        with open(path) as inf:
+            for line in inf:
+                if i in self.lines_Thornton:
+                    parts = line.split(',')
+                    Thornton_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(normalized_rebound_tangential_surface_vel_list_outfile_name) as inf:
+            extend_datafile_list(glob(normalized_rebound_tangential_surface_vel_list_outfile_name))
+            for line in inf:
+                if i in self.lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_normalized_rebound_tangential_surface_vel_error = 0
+
+        for j in Thornton_data:
+            summation_of_Thornton_data+=abs(j)
+
+        for i, j in zip(DEM_data, Thornton_data):
+            final_normalized_rebound_tangential_surface_vel_error+=abs(i-j)
+
+        final_normalized_rebound_tangential_surface_vel_error/=summation_of_Thornton_data
+
+        Logger.PrintInfo("Error in normalized rebound tangential surface velocity =", 100*final_normalized_rebound_tangential_surface_vel_error,"%")
+
+        #
+        Thornton_data = []; DEM_data = []; summation_of_Thornton_data = 0
+        i = 0
+        path = "paper_data/bench_10_norm_reb_ang_vel_e_" + self.coeff_of_rest_string + ".dat"
+        with open(path) as inf:
+            for line in inf:
+                if i in self.lines_Thornton:
+                    parts = line.split(',')
+                    Thornton_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(normalized_rebound_angular_velocity_list_outfile_name) as inf:
+            extend_datafile_list(glob(normalized_rebound_angular_velocity_list_outfile_name))
+            for line in inf:
+                if i in self.lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_normalized_rebound_angular_velocity_error = 0
+
+        for j in Thornton_data:
+            summation_of_Thornton_data+=abs(j)
+
+        for i, j in zip(DEM_data, Thornton_data):
+            final_normalized_rebound_angular_velocity_error+=abs(i-j)
+
+        final_normalized_rebound_angular_velocity_error/=summation_of_Thornton_data
+        Logger.PrintInfo("Error in normalized rebound angular velocity =", 100*final_normalized_rebound_angular_velocity_error,"%")
+
+        #
+        Thornton_data = []; DEM_data = []; summation_of_Thornton_data = 0
+        i = 0
+        path = "paper_data/bench_10_tang_coeff_rest_e_" + self.coeff_of_rest_string + ".dat"
+        with open(path) as inf:
+            for line in inf:
+                if i in self.lines_Thornton:
+                    parts = line.split(',')
+                    Thornton_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(tangential_coefficient_of_restitution_list_outfile_name) as inf:
+            extend_datafile_list(glob(tangential_coefficient_of_restitution_list_outfile_name))
+            for line in inf:
+                if i in self.lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_tangential_coefficient_of_restitution_error = 0
+
+        for j in Thornton_data:
+            summation_of_Thornton_data+=abs(j)
+
+        for i, j in zip(DEM_data, Thornton_data):
+            final_tangential_coefficient_of_restitution_error+=abs(i-j)
+
+        final_tangential_coefficient_of_restitution_error/=summation_of_Thornton_data
+        Logger.PrintInfo("Error in final tangential coefficient of restitution =", 100*final_tangential_coefficient_of_restitution_error,"%")
+        #
+        error1 = 100*final_normalized_rebound_tangential_surface_vel_error
+        error2 = 100*final_normalized_rebound_angular_velocity_error
+        error3 = 100*final_tangential_coefficient_of_restitution_error
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
+        pass
+
+
+class Benchmark11: ########## HERTZIAN THORNTON
+
+    def __init__(self):
+        self.number = 11
+        self.initial_normal_vel = -5.0
+        self.initial_tangential_vel = 0
+        self.radius = 0.025
+        self.normalized_impact_angle_list = []
+        self.normalized_rebound_tangential_surface_vel_list = []
+        self.normalized_rebound_angular_velocity_list = []
+        self.tangential_coefficient_of_restitution_list = []
+        self.normalized_rebound_tangential_surface_vel_list_outfile = None
+        self.normalized_rebound_angular_velocity_list_outfile = None
+        self.tangential_coefficient_of_restitution_list_outfile = None
+        self.coeff_of_restitution = -1.0
+        self.coeff_of_rest_string = None
+        self.lines_Thornton = []
+        self.lines_DEM = []
+        self.degrees = 0
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):   # Change this function name from 'set_initial_data' to 'set_initial_data'
+
+        if iteration == 1:
+            self.degrees = 1
+        else:
+            self.degrees = 50 * (iteration - 1)/number_of_points_in_the_graphic
+
+        if coeff_of_restitution_iteration==1:
+            self.coeff_of_restitution=0.25
+            self.coeff_of_rest_string='025'
+            self.lines_Thornton = [1, 2, 4, 5, 7, 8]
+            self.lines_DEM = [0, 1, 3, 4, 5, 6]
+        elif coeff_of_restitution_iteration==2:
+            self.coeff_of_restitution=0.50
+            self.coeff_of_rest_string='050'
+            self.lines_Thornton = [1, 2, 4, 5, 7, 9, 10]
+            self.lines_DEM = [0, 1, 3, 4, 5, 6, 7]
+        elif coeff_of_restitution_iteration==3:
+            self.coeff_of_restitution=0.75
+            self.coeff_of_rest_string='075'
+            self.lines_Thornton = [1, 2, 4, 5, 6, 8, 9, 10]
+            self.lines_DEM = [0, 1, 3, 4, 5, 6, 7, 8]
+        else:
+            self.coeff_of_restitution=0.90
+            self.coeff_of_rest_string='090'
+            #self.lines_Thornton = [1, 2, 4, 5, 6, 8, 9]
+            #self.lines_DEM = [0, 1, 3, 4, 5, 7, 8]
+            self.lines_Thornton = [1, 2, 4, 5, 6, 7, 8, 9]
+            self.lines_DEM = [0, 1, 3, 4, 5, 6, 7, 8]
+
+        self.initial_tangential_vel = -self.initial_normal_vel * tan(self.degrees * pi / 180.0)
+
+        for node in modelpart.Nodes:
+            node.SetSolutionStepValue(VELOCITY_Y, self.initial_tangential_vel)
+            node.SetSolutionStepValue(VELOCITY_Z, self.initial_normal_vel)
+            modelpart.GetProperties()[1][COEFFICIENT_OF_RESTITUTION] = self.coeff_of_restitution
+
+        Logger.PrintInfo(self.coeff_of_restitution)
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
+
+        mu = 0.1
+
+        for node in modelpart.Nodes:
+            final_angular_vel = node.GetSolutionStepValue(ANGULAR_VELOCITY_X)
+            final_tangential_center_velocity = node.GetSolutionStepValue(VELOCITY_Y)
+            normalized_impact_angle = 2.0 * tan(self.degrees * pi / 180.0) / (mu * (1 + self.coeff_of_restitution))
+            normalized_rebound_tangential_surface_vel = -2.0 * (final_tangential_center_velocity + final_angular_vel * self.radius) / (self.initial_normal_vel * mu * (1 + self.coeff_of_restitution))
+            normalized_rebound_angular_velocity = -2.0 * self.radius * final_angular_vel / (self.initial_normal_vel * mu * (1 + self.coeff_of_restitution))
+            tangential_coefficient_of_restitution = 5.0/7.0 + 2.0 * normalized_rebound_tangential_surface_vel / (7.0 * normalized_impact_angle)
+
+        self.normalized_impact_angle_list.append(normalized_impact_angle)
+        self.normalized_rebound_tangential_surface_vel_list.append(normalized_rebound_tangential_surface_vel)
+        self.normalized_rebound_angular_velocity_list.append(normalized_rebound_angular_velocity)
+        self.tangential_coefficient_of_restitution_list.append(tangential_coefficient_of_restitution)
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+
+        self.normalized_rebound_tangential_surface_vel_list_outfile_name = "benchmark11_dt_" + str(dt) + '_normalized_rebound_tangential_surface_vel_list_data.dat'
+        self.normalized_rebound_angular_velocity_list_outfile_name = "benchmark11_dt_" + str(dt) + '_normalized_rebound_angular_velocity_list_data.dat'
+        self.tangential_coefficient_of_restitution_list_outfile_name = "benchmark11_dt_" + str(dt) + '_tangential_coefficient_of_restitution_list_data.dat'
+
+        self.normalized_rebound_tangential_surface_vel_list_outfile = open(self.normalized_rebound_tangential_surface_vel_list_outfile_name, 'w')
+        self.normalized_rebound_angular_velocity_list_outfile = open(self.normalized_rebound_angular_velocity_list_outfile_name, 'w')
+        self.tangential_coefficient_of_restitution_list_outfile = open(self.tangential_coefficient_of_restitution_list_outfile_name, 'w')
+
+        for i in range(0, number_of_points_in_the_graphic):
+            self.normalized_rebound_tangential_surface_vel_list_outfile.write("%14.8f %14.8f" % (self.normalized_impact_angle_list[i], self.normalized_rebound_tangential_surface_vel_list[i]) + '\n')
+            self.normalized_rebound_angular_velocity_list_outfile.write("%14.8f %14.8f" % (self.normalized_impact_angle_list[i], self.normalized_rebound_angular_velocity_list[i]) + '\n')
+            self.tangential_coefficient_of_restitution_list_outfile.write("%14.8f %14.8f" % (self.normalized_impact_angle_list[i], self.tangential_coefficient_of_restitution_list[i]) + '\n')
+        self.normalized_rebound_tangential_surface_vel_list_outfile.close()
+        self.normalized_rebound_angular_velocity_list_outfile.close()
+        self.tangential_coefficient_of_restitution_list_outfile.close()
+
+        self.create_gnuplot_scripts(self.normalized_rebound_tangential_surface_vel_list_outfile_name,
+                                    self.normalized_rebound_angular_velocity_list_outfile_name,
+                                    self.tangential_coefficient_of_restitution_list_outfile_name,
+                                    self.coeff_of_rest_string, dt)
+
+        error1, error2, error3 = self.compute_errors(self.normalized_rebound_tangential_surface_vel_list_outfile_name,
+                                                     self.normalized_rebound_angular_velocity_list_outfile_name,
+                                                     self.tangential_coefficient_of_restitution_list_outfile_name)
+
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+
+        coeff_of_rest = '%.2f' % self.coeff_of_restitution
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+
+        if (coeff_of_rest=='0.25'):
+            error_file.write("\n==== THORNTON PAPER TESTS. FULL REGIME. HERTZIAN LAW ====\n\n")
+
+        error_file.write("DEM Benchmark 11:")
+
+        if (error1 < 6.0 and error2 < 6.0 and error3 < 6.0):
+            error_file.write(" OK!........ Test 11 (e=" + coeff_of_rest + ") SUCCESSFUL\n")
+        else:
+            error_file.write(" KO!........ Test 11 (e=" + coeff_of_rest + ") FAILED\n")
+        error_file.close()
+
+        self.normalized_impact_angle_list = []
+        self.normalized_rebound_tangential_surface_vel_list = []
+        self.normalized_rebound_angular_velocity_list = []
+        self.tangential_coefficient_of_restitution_list = []
+
+    def create_gnuplot_scripts(self, normalized_rebound_tangential_surface_vel_list_outfile_name,
+                                     normalized_rebound_angular_velocity_list_outfile_name,
+                                     tangential_coefficient_of_restitution_list_outfile_name,
+                                     coeff_of_rest_string, dt):
+
+        gnuplot_script_name_1 = 'benchmark11_comparison_1_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Normalized incident angle'\nset ylabel 'Normalized rebound tangential surface velocity'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:10][-2:3] '" + normalized_rebound_tangential_surface_vel_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/bench_10_norm_reb_tang_e_" + coeff_of_rest_string + ".dat' index 0 w lp ls 1 t 'Paper data'\n")
+        self.gnuplot_outfile.close()
+
+        gnuplot_script_name_2 = 'benchmark11_comparison_2_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_2, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Normalized incident angle'\nset ylabel 'Normalized final angular velocity'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:14][-6:0] '" + normalized_rebound_angular_velocity_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/bench_10_norm_reb_ang_vel_e_" + coeff_of_rest_string + ".dat' index 0 w lp ls 1 t 'Paper data'\n")
+        self.gnuplot_outfile.close()
+
+        gnuplot_script_name_3 = 'benchmark11_comparison_3_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_3, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Normalized incident angle'\nset ylabel 'Tangential coefficient of restitution'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt 3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:10][0.5:1.0] '" + tangential_coefficient_of_restitution_list_outfile_name + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/bench_10_tang_coeff_rest_e_" + coeff_of_rest_string + ".dat' index 0 w lp ls 1 t 'Paper data'\n")
+        self.gnuplot_outfile.close()
+
+        '''
+        print_gnuplot_files_on_screen(gnuplot_script_name_1)
+        print_gnuplot_files_on_screen(gnuplot_script_name_2)
+        print_gnuplot_files_on_screen(gnuplot_script_name_3)
+        '''
+
+    def compute_errors(self, normalized_rebound_tangential_surface_vel_list_outfile_name,
+                             normalized_rebound_angular_velocity_list_outfile_name,
+                             tangential_coefficient_of_restitution_list_outfile_name):
+        #
+        Thornton_data = []; DEM_data = []; summation_of_Thornton_data = 0
+        i = 0
+        path = "paper_data/bench_10_norm_reb_tang_e_" + self.coeff_of_rest_string + ".dat"
+        with open(path) as inf:
+            for line in inf:
+                if i in self.lines_Thornton:
+                    parts = line.split(',')
+                    Thornton_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(normalized_rebound_tangential_surface_vel_list_outfile_name) as inf:
+            extend_datafile_list(glob(normalized_rebound_tangential_surface_vel_list_outfile_name))
+            for line in inf:
+                if i in self.lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_normalized_rebound_tangential_surface_vel_error = 0
+
+        for j in Thornton_data:
+            summation_of_Thornton_data+=abs(j)
+
+        for i, j in zip(DEM_data, Thornton_data):
+            final_normalized_rebound_tangential_surface_vel_error+=abs(i-j)
+
+        final_normalized_rebound_tangential_surface_vel_error/=summation_of_Thornton_data
+
+        Logger.PrintInfo("Error in normalized rebound tangential surface velocity =", 100*final_normalized_rebound_tangential_surface_vel_error,"%")
+
+        #
+        Thornton_data = []; DEM_data = []; summation_of_Thornton_data = 0
+        i = 0
+        path = "paper_data/bench_10_norm_reb_ang_vel_e_" + self.coeff_of_rest_string + ".dat"
+        with open(path) as inf:
+            for line in inf:
+                if i in self.lines_Thornton:
+                    parts = line.split(',')
+                    Thornton_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(normalized_rebound_angular_velocity_list_outfile_name) as inf:
+            extend_datafile_list(glob(normalized_rebound_angular_velocity_list_outfile_name))
+            for line in inf:
+                if i in self.lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_normalized_rebound_angular_velocity_error = 0
+
+        for j in Thornton_data:
+            summation_of_Thornton_data+=abs(j)
+
+        for i, j in zip(DEM_data, Thornton_data):
+            final_normalized_rebound_angular_velocity_error+=abs(i-j)
+
+        final_normalized_rebound_angular_velocity_error/=summation_of_Thornton_data
+        Logger.PrintInfo("Error in normalized rebound angular velocity =", 100*final_normalized_rebound_angular_velocity_error,"%")
+
+        #
+        Thornton_data = []; DEM_data = []; summation_of_Thornton_data = 0
+        i = 0
+        path = "paper_data/bench_10_tang_coeff_rest_e_" + self.coeff_of_rest_string + ".dat"
+        with open(path) as inf:
+            for line in inf:
+                if i in self.lines_Thornton:
+                    parts = line.split(',')
+                    Thornton_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(tangential_coefficient_of_restitution_list_outfile_name) as inf:
+            extend_datafile_list(glob(tangential_coefficient_of_restitution_list_outfile_name))
+            for line in inf:
+                if i in self.lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        final_tangential_coefficient_of_restitution_error = 0
+
+        for j in Thornton_data:
+            summation_of_Thornton_data+=abs(j)
+
+        for i, j in zip(DEM_data, Thornton_data):
+            final_tangential_coefficient_of_restitution_error+=abs(i-j)
+
+        final_tangential_coefficient_of_restitution_error/=summation_of_Thornton_data
+        Logger.PrintInfo("Error in final tangential coefficient of restitution =", 100*final_tangential_coefficient_of_restitution_error,"%")
+
+        #
+        error1 = 100*final_normalized_rebound_tangential_surface_vel_error
+        error2 = 100*final_normalized_rebound_angular_velocity_error
+        error3 = 100*final_tangential_coefficient_of_restitution_error
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
+        pass
+
+
+class Benchmark12: ########## ROLLING FRICTION
+
+    def __init__(self):
+        self.number = 12
+
+        self.balls_graph_counter = 1
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.simulation_graph = open(self.output_filename, 'w')
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
+
+        self.simulation_graph.close()
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
+
+        self.graph_frequency        = int(graph_print_interval/dt)
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
+
+        if(self.balls_graph_counter == self.graph_frequency):
+            self.balls_graph_counter = 0
+            total_angular_velocity_z = 0.0
+
+            for node in modelpart.Nodes:
+                if node.Id == 1:
+                   angular_velocity_z = node.GetSolutionStepValue(ANGULAR_VELOCITY_Z)
+                   total_angular_velocity_z += angular_velocity_z
+
+                del node
+
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_angular_velocity_z).rjust(13)+"\n")
+        self.balls_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
+
+        error1, error2, error3 = self.compute_errors(self.output_filename)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+        error_file.write("\n\n")
+        error_file.write("==== WENSRICH PAPER TEST. ROLLING FRICTION ====\n\n")
+        error_file.write("DEM Benchmark 12:")
+
+        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
+            error_file.write(" OK!........ Test 12 SUCCESSFUL\n")
+        else:
+            error_file.write(" KO!........ Test 12 FAILED\n")
+        error_file.close()
+
+    def compute_errors(self, output_filename):
+
+        lines_analytics = lines_DEM = list(range(0, 1000));
+        analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
+        i = 0
+        with open('paper_data/benchmark' + str(sys.argv[1]) + '_graph.dat') as inf:
+            for line in inf:
+                if i in lines_analytics:
+                    parts = line.split()
+                    analytics_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))
+                i+=1
+        generated_data_error = 0
+
+        for j in analytics_data:
+            summation_of_analytics_data+=abs(j)
+
+        for i, j in zip(DEM_data, analytics_data):
+            generated_data_error+=abs(i-j)
+        generated_data_error/=summation_of_analytics_data
+
+        Logger.PrintInfo("Error in simulation =", 100*generated_data_error,"%")
+
+        error1 = 100*generated_data_error
+
+        error2 = error3 = 0
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+    def create_gnuplot_scripts(self, output_filename, dt):
+        pass
+
+
+class Benchmark13: ########## DEM-FEM Facet
+
+    def __init__(self):
+        self.number = 13
+
+        self.balls_graph_counter = 1   # deberia ser self.balls_graph_counter = self.graph_frequency
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        self.velocity_list_outfile_name = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.simulation_graph = open(self.velocity_list_outfile_name, 'w')
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
+
+        self.simulation_graph.close()
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
+
+        self.graph_frequency        = int(graph_print_interval/dt)
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
+
+        if(self.balls_graph_counter == self.graph_frequency):     #if(self.balls_graph_counter == self.graph_frequency):
+            self.balls_graph_counter = 0
+            total_velocity_x = 0.0
+            total_velocity_z = 0.0
+
+            for node in modelpart.Nodes:
+                if node.Id == 1:
+                   velocity_x = node.GetSolutionStepValue(VELOCITY_X)
+                   velocity_z = node.GetSolutionStepValue(VELOCITY_Z)
+                   total_velocity_x += velocity_x
+                   total_velocity_z += velocity_z
+
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_velocity_x).rjust(13)+" "+str("%.6g"%total_velocity_z).rjust(13)+"\n")
+        self.balls_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
+
+        error1, error2, error3 = self.compute_errors(self.velocity_list_outfile_name)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+        error_file.write("\n\n")
+        error_file.write("======== DE/FE CONTACT BENCHMARKS ==========\n\n")
+        error_file.write("DEM Benchmark 13:")
+
+        if (error1 < 0.01 and error2 < 0.01 and error3 <0.01):
+            error_file.write(" OK!........ Test 13 SUCCESSFUL\n")
+        else:
+            error_file.write(" KO!........ Test 13 FAILED\n")
+        error_file.close()
+
+    def compute_errors(self, output_filename):  #FINALIZATION STEP
+
+        lines_DEM = list(range(0, 200));
+        total_velocity_x = 0.0; total_velocity_z = 0.0
+        i = 0
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    total_velocity_x += float(parts[1])
+                    total_velocity_z += float(parts[2])
+                i+=1
+
+        if total_velocity_x > 0.0:  #VELOCITY_X should be 0 always
+            error1 = 100
+        else:
+            error1 = 0
+
+        if total_velocity_z > 0.0:  #VELOCITY_Z should be 0 always
+            error2 = 100
+        else:
+            error2 = 0
+
+        error3 = 0
+
+        Logger.PrintInfo("Error in velocity X =", error1,"%")
+
+        Logger.PrintInfo("Error in velocity Z =", error2,"%")
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+class Benchmark14: ########## DEM-FEM Edge
+
+    def __init__(self):
+        self.number = 14
+
+        self.balls_graph_counter = 1   # deberia ser self.balls_graph_counter = self.graph_frequency
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        self.velocity_list_outfile_name = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.simulation_graph = open(self.velocity_list_outfile_name, 'w')
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
+
+        self.simulation_graph.close()
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
+
+        self.graph_frequency        = int(graph_print_interval/dt)
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
+
+        if(self.balls_graph_counter == self.graph_frequency):     #if(self.balls_graph_counter == self.graph_frequency):
+            self.balls_graph_counter = 0
+            total_velocity_x = 0.0
+            total_velocity_z = 0.0
+
+            for node in modelpart.Nodes:
+                if node.Id == 1:
+                   velocity_x = node.GetSolutionStepValue(VELOCITY_X)
+                   velocity_z = node.GetSolutionStepValue(VELOCITY_Z)
+                   total_velocity_x += velocity_x
+                   total_velocity_z += velocity_z
+
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_velocity_x).rjust(13)+" "+str("%.6g"%total_velocity_z).rjust(13)+"\n")
+        self.balls_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
+
+        error1, error2, error3 = self.compute_errors(self.velocity_list_outfile_name)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+        error_file.write("DEM Benchmark 14:")
+
+        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
+            error_file.write(" OK!........ Test 14 SUCCESSFUL\n")
+        else:
+            error_file.write(" KO!........ Test 14 FAILED\n")
+        error_file.close()
+
+    def compute_errors(self, output_filename):  #FINALIZATION STEP
+
+        lines_DEM = list(range(0, 200));
+        total_velocity_x = 0.0; total_velocity_z = 0.0
+        i = 0
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    total_velocity_x += float(parts[1])
+                    total_velocity_z += float(parts[2])
+                i+=1
+
+        if total_velocity_x > 0.0:  #VELOCITY_X should be 0 always
+            error1 = 100
+        else:
+            error1 = 0
+
+        if total_velocity_z > 0.0:  #VELOCITY_Z should be 0 always
+            error2 = 100
+        else:
+            error2 = 0
+
+        error3 = 0
+
+        Logger.PrintInfo("Error in velocity X =", error1,"%")
+
+        Logger.PrintInfo("Error in velocity Z =", error2,"%")
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+class Benchmark15: ########## DEM-FEM Vertex
+
+    def __init__(self):
+        self.number = 15
+
+        self.balls_graph_counter = 1   # deberia ser self.balls_graph_counter = self.graph_frequency
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        self.velocity_list_outfile_name = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.simulation_graph = open(self.velocity_list_outfile_name, 'w')
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
+
+        self.simulation_graph.close()
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
+
+        self.graph_frequency        = int(graph_print_interval/dt)
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
+
+        if(self.balls_graph_counter == self.graph_frequency):     #if(self.balls_graph_counter == self.graph_frequency):
+            self.balls_graph_counter = 0
+            total_velocity_x = 0.0
+            total_velocity_z = 0.0
+
+            for node in modelpart.Nodes:
+                if node.Id == 1:
+                   velocity_x = node.GetSolutionStepValue(VELOCITY_X)
+                   velocity_z = node.GetSolutionStepValue(VELOCITY_Z)
+                   total_velocity_x += velocity_x
+                   total_velocity_z += velocity_z
+
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_velocity_x).rjust(13)+" "+str("%.6g"%total_velocity_z).rjust(13)+"\n")
+        self.balls_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
+
+        error1, error2, error3 = self.compute_errors(self.velocity_list_outfile_name)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+        error_file.write("DEM Benchmark 15:")
+
+        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
+            error_file.write(" OK!........ Test 15 SUCCESSFUL\n")
+        else:
+            error_file.write(" KO!........ Test 15 FAILED\n")
+        error_file.close()
+
+    def compute_errors(self, output_filename):  #FINALIZATION STEP
+
+        lines_DEM = list(range(0, 200));
+        total_velocity_x = 0.0; total_velocity_z = 0.0
+        i = 0
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    total_velocity_x += float(parts[1])
+                    total_velocity_z += float(parts[2])
+                i+=1
+
+        if total_velocity_x > 0.0:  #VELOCITY_X should be 0 always
+            error1 = 100
+        else:
+            error1 = 0
+
+        if total_velocity_z > 0.0:  #VELOCITY_Z should be 0 always
+            error2 = 100
+        else:
+            error2 = 0
+
+        error3 = 0
+
+        Logger.PrintInfo("Error in velocity X =", error1,"%")
+
+        Logger.PrintInfo("Error in velocity Z =", error2,"%")
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+
+class Benchmark16: ########## DEM-FEM Grid
+
+    def __init__(self):
+        self.number = 16
+
+        self.balls_graph_counter = 1   # deberia ser self.balls_graph_counter = self.graph_frequency
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        self.velocity_list_outfile_name = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.simulation_graph = open(self.velocity_list_outfile_name, 'w')
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
+
+        self.simulation_graph.close()
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
+
+        self.graph_frequency        = int(graph_print_interval/dt)
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
+
+        if(self.balls_graph_counter == self.graph_frequency):     #if(self.balls_graph_counter == self.graph_frequency):
+            self.balls_graph_counter = 0
+            total_velocity_1 = 0.0
+            total_velocity_2 = 0.0
+            total_velocity_3 = 0.0
+
+            for node in modelpart.Nodes:
+                if node.Id == 1:
+                   velocity_1 = node.GetSolutionStepValue(VELOCITY_Y)
+                   total_velocity_1 += velocity_1
+                if node.Id == 2:
+                   velocity_2 = node.GetSolutionStepValue(VELOCITY_Y)
+                   total_velocity_2 += velocity_2
+                if node.Id == 3:
+                   velocity_3 = node.GetSolutionStepValue(VELOCITY_Y)
+                   total_velocity_3 += velocity_3
+
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_velocity_1).rjust(13)+" "+str("%.6g"%total_velocity_2).rjust(13)+" "+str("%.6g"%total_velocity_3).rjust(13)+"\n")
+        self.balls_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
+
+        error1, error2, error3 = self.compute_errors(self.velocity_list_outfile_name)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+        error_file.write("DEM Benchmark 16:")
+
+        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
+            error_file.write(" OK!........ Test 16 SUCCESSFUL\n")
+        else:
+            error_file.write(" KO!........ Test 16 FAILED\n")
+        error_file.close()
+
+    def compute_errors(self, output_filename):  #FINALIZATION STEP
+
+        lines_analytics = lines_DEM = list(range(0, 250));
+        ref_data1 = []; ref_data2 = []; DEM_data1 = []; ref_data3 = []; DEM_data1 = []; DEM_data2 = []; DEM_data3 = []; summation_of_ref_data1 = 0; summation_of_ref_data2 = 0; summation_of_ref_data3 = 0
+        times = []
+        i = 0
+        with open('paper_data/benchmark' + str(sys.argv[1]) + '_graph.dat') as inf:  #with open('paper_data/reference_graph_benchmark12.dat') as inf:
+            for line in inf:
+                if i in lines_analytics:
+                    parts = line.split()
+                    times.append(float(parts[0]))
+                    ref_data1.append(float(parts[1]))
+                    ref_data2.append(float(parts[2]))
+                    ref_data3.append(float(parts[3]))
+                i+=1
+        i = 0
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data1.append(float(parts[1]))
+                    DEM_data2.append(float(parts[2]))
+                    DEM_data3.append(float(parts[3]))
+                i+=1
+        final_velocity_1_error = 0
+        final_velocity_2_error = 0
+        final_velocity_3_error = 0
+
+        for j in ref_data1:
+            summation_of_ref_data1+=abs(j)
+        for k in ref_data2:
+            summation_of_ref_data2+=abs(k)
+        for l in ref_data3:
+            summation_of_ref_data3+=abs(l)
+
+        for i, j in zip(DEM_data1, ref_data1):
+            final_velocity_1_error+=abs(i-j)
+        final_velocity_1_error/=summation_of_ref_data1
+
+        for k, l in zip(DEM_data2, ref_data2):
+            final_velocity_2_error+=abs(k-l)
+        final_velocity_2_error/=summation_of_ref_data2
+
+        for m, n in zip(DEM_data3, ref_data3):
+            final_velocity_3_error+=abs(m-n)
+        final_velocity_3_error/=summation_of_ref_data3
+
+        #for t, v1,v2,v3 in zip(times, DEM_data1, DEM_data2, DEM_data3):
+        #    Logger.PrintInfo(t, v1, v2, v3)
+
+        Logger.PrintInfo("Error in velocity sphere 1 =", 100*final_velocity_1_error,"%")
+
+        Logger.PrintInfo("Error in velocity sphere 2 =", 100*final_velocity_2_error,"%")
+
+        Logger.PrintInfo("Error in velocity sphere 3 =", 100*final_velocity_3_error,"%")
+
+        error1 = 100*final_velocity_1_error
+
+        error2 = 100*final_velocity_2_error
+
+        error3 = 100*final_velocity_3_error
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+
+class Benchmark17: ########## DEM-FEM Rolling
+
+    def __init__(self):
+        self.number = 17
+
+        self.balls_graph_counter = 1   # deberia ser self.balls_graph_counter = self.graph_frequency
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        self.error_list_outfile_name = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.simulation_graph = open(self.error_list_outfile_name, 'w')
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
+
+        self.simulation_graph.close()
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
+
+        self.graph_frequency        = int(graph_print_interval/dt)
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
+
+        if(self.balls_graph_counter == self.graph_frequency):     #if(self.balls_graph_counter == self.graph_frequency):
+            self.balls_graph_counter = 0
+            total_velocity_err         = 0.0
+            total_angular_velocity_err = 0.0
+
+            for node in modelpart.Nodes:
+                if node.Id == 1:
+                   velocity_1         = node.GetSolutionStepValue(VELOCITY_X)
+                   angular_velocity_1 = node.GetSolutionStepValue(ANGULAR_VELOCITY_Z)
+                if node.Id == 2:
+                   velocity_2         = node.GetSolutionStepValue(VELOCITY_X)
+                   angular_velocity_2 = node.GetSolutionStepValue(ANGULAR_VELOCITY_Z)
+
+            total_velocity_err         = (abs(velocity_1 - velocity_2))/(abs(velocity_2))
+            total_angular_velocity_err = (abs(angular_velocity_1 - angular_velocity_2))/(abs(velocity_2))
+
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_velocity_err).rjust(13)+" "+str("%.6g"%total_angular_velocity_err).rjust(13)+"\n")
+        self.balls_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
+
+        error1, error2, error3 = self.compute_errors(self.error_list_outfile_name)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+        error_file.write("DEM Benchmark 17:")
+
+        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
+            error_file.write(" OK!........ Test 17 SUCCESSFUL\n")
+        else:
+            error_file.write(" KO!........ Test 17 FAILED\n")
+        error_file.close()
+
+    def compute_errors(self, output_filename):  #FINALIZATION STEP
+
+        lines_DEM = list(range(0, 100));
+        total_velocity_err = 0.0; total_angular_velocity_err = 0.0
+        i = 0
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    total_velocity_err += float(parts[1])
+                    total_angular_velocity_err += float(parts[2])
+                i+=1
+
+        if total_velocity_err > 1e-2:  #VELOCITY_X should be 0 always
+            error1 = 100*total_velocity_err
+        else:
+            error1 = 0
+
+        if total_angular_velocity_err > 1e-2:  #VELOCITY_Z should be 0 always
+            error2 = 100*total_angular_velocity_err
+        else:
+            error2 = 0
+
+        error3 = 0
+
+        Logger.PrintInfo("Error in velocity between meshes =", 100*total_velocity_err,"%")
+
+        Logger.PrintInfo("Error in angular velocity between meshes =", 100*total_angular_velocity_err,"%")
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+
+class Benchmark20:
+
+    def __init__(self):
+        self.number = 20
+        self.generated_data = None
+        #self.graph_frequency = int(graph_print_interval/dt)  # def __init__(self, graph_print_interval, dt):
+        self.balls_graph_counter = 1   # deberia ser self.balls_graph_counter = self.graph_frequency
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):  #INITIALIZATION STEP
+        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.simulation_graph = open(self.output_filename, 'w')
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
+        self.simulation_graph.close()
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
+        self.graph_frequency        = int(graph_print_interval/dt)
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
+
+        if(self.balls_graph_counter == self.graph_frequency):     #if(self.balls_graph_counter == self.graph_frequency):
+            self.balls_graph_counter = 0
+            self.total_force_x = 0.0
+            self.total_force_y = 0.0
+
+            for node in modelpart.Nodes:
+                if node.Id == 141:
+                   force_node_x = node.GetSolutionStepValue(ELASTIC_FORCES)[0]
+                   force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+                   self.total_force_x += force_node_x
+                   self.total_force_y += force_node_y
+
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_x).rjust(13)+" "+str("%.6g"%self.total_force_y).rjust(13)+"\n")
+        self.balls_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+
+        '''
+        gnuplot_script_name = 'benchmark3_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name, 'w')
+        self.gnuplot_outfile.write("set grid; plot '" + self.output_filename + "' u 1:2 w lp lt 3 lw 1.5 ps 2 pt 4, '"\
+                                                      + self.output_filename + "' u 1:3 w lp lt 2 lw 1.5 ps 2 pt 6")
+        self.gnuplot_outfile.close()
+        self.create_gnuplot_scripts(self.output_filename, dt)
+        '''
+
+        error1, error2, error3 = self.compute_errors(self.output_filename)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+        error_file.write("\n\n")
+        error_file.write("== BASIC CONTINUUM TESTS ==\n\n")
+        error_file.write("DEM Benchmark 20:")
+
+        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
+            error_file.write(" OK!........ Test 20 SUCCESSFUL\n")
+            shutil.rmtree('benchmark20_Post_Files', ignore_errors = True)
+        else:
+            error_file.write(" KO!........ Test 20 FAILED\n")
+        error_file.close()
+
+    def compute_errors(self, output_filename):  #FINALIZATION STEP
+        lines_analytics = lines_DEM = list(range(0, 1000));
+        analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
+        i = 0
+        with open('paper_data/reference_graph_benchmark' + str(sys.argv[1]) + '.dat') as inf:
+            for line in inf:
+                if i in lines_analytics:
+                    parts = line.split()
+                    analytics_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))   #segona component del vector ()
+                i+=1
+        generated_data_error = 0
+
+        for j in analytics_data:
+            summation_of_analytics_data+=abs(j)
+
+        for i, j in zip(DEM_data, analytics_data):
+            generated_data_error+=abs(i-j)
+        generated_data_error/=summation_of_analytics_data
+
+        Logger.PrintInfo("Error in simulation =", 100*generated_data_error,"%")
+
+        error1 = 100*generated_data_error
+
+        error2 = error3 = 0
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+    def create_gnuplot_scripts(self, output_filename, dt):
+        pass
+        '''
+        gnuplot_script_name_1 = 'benchmark20_comparison_1_dt_' + str(dt) + 's.gp'
+        self.gnuplot_outfile = open(gnuplot_script_name_1, 'w')
+        self.gnuplot_outfile.write("set grid\nset key left bottom\nset xlabel 'Data'\nset ylabel 'Damping ratio'\nset style line 1 pt 8 lt -1 ps 3\nset style line 2 pt 9 lt  3 ps 3\n")
+        self.gnuplot_outfile.write("plot [0:1][0:1] '" + output_filename + "' w lp lt 1 lw 1.5 ps 2 pt 5,\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark20_graph1.dat' w lp ls 1 t 'Al. oxide',\\\n")
+        self.gnuplot_outfile.write("'paper_data/benchmark20_graph1.dat' w lp ls 2 t 'Cast iron'\n")
+        self.gnuplot_outfile.close()
+        print_gnuplot_files_on_screen(gnuplot_script_name_1)
+        '''
+
+class Benchmark21:
+
+    def __init__(self):
+        self.number = 21
+        self.generated_data = None
+        #self.graph_frequency = int(graph_print_interval/dt)  # def __init__(self, graph_print_interval, dt):
+        self.balls_graph_counter = 1   # deberia ser self.balls_graph_counter = self.graph_frequency
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):  #INITIALIZATION STEP
+        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.simulation_graph = open(self.output_filename, 'w')
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):        #FINALIZATION STEP
+        self.simulation_graph.close()
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
+        self.graph_frequency        = int(graph_print_interval/dt)
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
+
+        if(self.balls_graph_counter == self.graph_frequency):     #if(self.balls_graph_counter == self.graph_frequency):
+            self.balls_graph_counter = 0
+            self.total_force_x = 0.0
+            self.total_force_y = 0.0
+
+            for node in modelpart.Nodes:
+                if node.Id == 141:
+                   force_node_x = node.GetSolutionStepValue(ELASTIC_FORCES)[0]
+                   force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+                   self.total_force_x += force_node_x
+                   self.total_force_y += force_node_y
+
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_x).rjust(13)+" "+str("%.6g"%self.total_force_y).rjust(13)+"\n")
+        self.balls_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+        error1, error2, error3 = self.compute_errors(self.output_filename)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+        error_file.write("DEM Benchmark 21:")
+
+        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
+            error_file.write(" OK!........ Test 21 SUCCESSFUL\n")
+            shutil.rmtree('benchmark21_Post_Files', ignore_errors = True)
+        else:
+            error_file.write(" KO!........ Test 21 FAILED\n")
+        error_file.close()
+
+
+    def compute_errors(self, output_filename):  #FINALIZATION STEP
+        lines_analytics = lines_DEM = list(range(0, 1000));
+        analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
+        i = 0
+        with open('paper_data/reference_graph_benchmark' + str(sys.argv[1]) + '.dat') as inf:
+            for line in inf:
+                if i in lines_analytics:
+                    parts = line.split()
+                    analytics_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))   #segona component del vector ()
+                i+=1
+        generated_data_error = 0
+
+        for j in analytics_data:
+            summation_of_analytics_data+=abs(j)
+
+        for i, j in zip(DEM_data, analytics_data):
+            generated_data_error+=abs(i-j)
+        generated_data_error/=summation_of_analytics_data
+
+        Logger.PrintInfo("Error in simulation =", 100*generated_data_error,"%")
+        error1 = 100*generated_data_error
+        error2 = error3 = 0
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+    def create_gnuplot_scripts(self, output_filename, dt):
+        pass
+
+
+class Benchmark22:
+
+    def __init__(self):
+        self.number = 22
+        self.generated_data = None
+        #self.graph_frequency = int(graph_print_interval/dt)  # def __init__(self, graph_print_interval, dt):
+        self.balls_graph_counter = 1   # deberia ser self.balls_graph_counter = self.graph_frequency
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):  #INITIALIZATION STEP
+        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.simulation_graph = open(self.output_filename, 'w')
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):        #FINALIZATION STEP
+        self.simulation_graph.close()
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
+        self.graph_frequency        = int(graph_print_interval/dt)
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
+
+        if(self.balls_graph_counter == self.graph_frequency):     #if(self.balls_graph_counter == self.graph_frequency):
+            self.balls_graph_counter = 0
+            self.total_force_x = 0.0
+            self.total_force_y = 0.0
+
+            for node in modelpart.Nodes:
+                if node.Id == 141:
+                   force_node_x = node.GetSolutionStepValue(ELASTIC_FORCES)[0]
+                   force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+                   self.total_force_x += force_node_x
+                   self.total_force_y += force_node_y
+
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_x).rjust(13)+" "+str("%.6g"%self.total_force_y).rjust(13)+"\n")
+        self.balls_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+        error1, error2, error3 = self.compute_errors(self.output_filename)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+        error_file.write("DEM Benchmark 22:")
+
+        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
+            error_file.write(" OK!........ Test 22 SUCCESSFUL\n")
+            shutil.rmtree('benchmark22_Post_Files', ignore_errors = True)
+        else:
+            error_file.write(" KO!........ Test 22 FAILED\n")
+        error_file.close()
+
+    def compute_errors(self, output_filename):
+        lines_analytics = lines_DEM = list(range(0, 1000));
+        analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
+        i = 0
+        with open('paper_data/reference_graph_benchmark' + str(sys.argv[1]) + '.dat') as inf:
+            for line in inf:
+                if i in lines_analytics:
+                    parts = line.split()
+                    analytics_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))   #segona component del vector ()
+                i+=1
+        generated_data_error = 0
+
+        for j in analytics_data:
+            summation_of_analytics_data+=abs(j)
+
+        for i, j in zip(DEM_data, analytics_data):
+            generated_data_error+=abs(i-j)
+        generated_data_error/=summation_of_analytics_data
+
+        Logger.PrintInfo("Error in simulation =", 100*generated_data_error,"%")
+        error1 = 100*generated_data_error
+        error2 = error3 = 0
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+    def create_gnuplot_scripts(self, output_filename, dt):
+        pass
+
+class Benchmark23:
+
+    def __init__(self):
+        self.number = 23
+        self.generated_data = None
+        #self.graph_frequency = int(graph_print_interval/dt)  # def __init__(self, graph_print_interval, dt):
+        self.balls_graph_counter = 1   # deberia ser self.balls_graph_counter = self.graph_frequency
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):  #INITIALIZATION STEP
+        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.simulation_graph = open(self.output_filename, 'w')
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):        #FINALIZATION STEP
+        self.simulation_graph.close()
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
+        #Logger.PrintInfo("generate_graph_points bench23, graph_print_interval, dt - ", graph_print_interval, dt )
+        self.graph_frequency        = int(graph_print_interval/dt)
+
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
+
+        if(self.balls_graph_counter == self.graph_frequency):     #if(self.balls_graph_counter == self.graph_frequency):
+            self.balls_graph_counter = 0
+            self.total_force_x = 0.0
+            self.total_force_y = 0.0
+
+            for node in modelpart.Nodes:
+                if node.Id == 141:
+                   force_node_x = node.GetSolutionStepValue(ELASTIC_FORCES)[0]
+                   force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+                   self.total_force_x += force_node_x
+                   self.total_force_y += force_node_y
+
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_x).rjust(13)+" "+str("%.6g"%self.total_force_y).rjust(13)+"\n")
+        self.balls_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
+        error1, error2, error3 = self.compute_errors(self.output_filename)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+        error_file.write("DEM Benchmark 23:")
+
+        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
+            error_file.write(" OK!........ Test 23 SUCCESSFUL\n")
+            shutil.rmtree('benchmark23_Post_Files', ignore_errors = True)
+        else:
+            error_file.write(" KO!........ Test 23 FAILED\n")
+        error_file.close()
+
+    def compute_errors(self, output_filename):  #FINALIZATION STEP
+        lines_analytics = lines_DEM = list(range(0, 1000));
+        analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
+        i = 0
+        with open('paper_data/reference_graph_benchmark' + '23' + '.dat') as inf:
+            for line in inf:
+                if i in lines_analytics:
+                    parts = line.split()
+                    analytics_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))   #segona component del vector ()
+                i+=1
+        generated_data_error = 0
+
+        for j in analytics_data:
+            summation_of_analytics_data+=abs(j)
+
+        for i, j in zip(DEM_data, analytics_data):
+            generated_data_error+=abs(i-j)
+        generated_data_error/=summation_of_analytics_data
+
+        Logger.PrintInfo("Error in simulation =", 100*generated_data_error,"%")
+        error1 = 100*generated_data_error
+        error2 = error3 = 0
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+    def create_gnuplot_scripts(self, output_filename, dt):
+        pass
+
+
+class Benchmark24:
+
+    def __init__(self):
+        self.number = 24
+        self.generated_data = None
+        self.balls_graph_counter = 1
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):
+        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.simulation_graph = open(self.output_filename, 'w')
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
+        self.simulation_graph.close()
+
+    def cross_product(self, a, b):
+        c = [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]
+        return c
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        ang_vel = 20 * pi
+        angular_velocity = [0, 0, ang_vel]
+        rotation_matrix = [[cos(ang_vel * time), -1.0 * sin(ang_vel * time), 0], [sin(ang_vel * time), cos(ang_vel * time), 0], [0,0,1]]
+        time_dt = time - dt
+        rotation_matrix_minus_dt = [[cos(ang_vel * time_dt), -1.0 * sin(ang_vel * time_dt), 0], [sin(ang_vel * time_dt), cos(ang_vel * time_dt), 0], [0,0,1]] #
+        centroid = [-1.0, 0.0, 0.0]
+        relative_initial_node_coords, relative_node_coords, relative_node_coords_dt = [0]*3, [0]*3, [0]*3
+        sum, sum_dt = 0, 0
+
+        for node in modelpart.Nodes:
+            if node.Id == 141:
+                for j in range(3):
+                    rot_mat = rotation_matrix[j]
+                    rot_mat_dt = rotation_matrix_minus_dt[j]
+                    relative_initial_node_coords[0] = node.X0 - centroid[0]
+                    relative_initial_node_coords[1] = node.Y0 - centroid[1]
+                    relative_initial_node_coords[2] = node.Z0 - centroid[2]
+                    for i in range(3):
+                        sum += rot_mat[i] * relative_initial_node_coords[i]
+                        sum_dt += rot_mat_dt[i] * relative_initial_node_coords[i]
+                    relative_node_coords[j], sum, relative_node_coords_dt[j], sum_dt = sum, 0, sum_dt, 0
+                node.X = relative_node_coords[0] + centroid[0]
+                node.Y = relative_node_coords[1] + centroid[1]
+                node.Z = relative_node_coords[2] + centroid[2]
+
+                displacement = GetDisplacement(node)
+                node.SetSolutionStepValue(DISPLACEMENT, displacement)
+
+                velocity = [0]*3
+                velocity = self.cross_product(angular_velocity, relative_node_coords)
+                node.SetSolutionStepValue(VELOCITY, velocity)
+
+                angular_velocity = [0]*3
+                node.SetSolutionStepValue(ANGULAR_VELOCITY, angular_velocity)
+
+                delta_displacement = [0]*3
+                delta_displacement[0] = relative_node_coords[0] - relative_node_coords_dt[0]
+                delta_displacement[1] = relative_node_coords[1] - relative_node_coords_dt[1]
+                delta_displacement[2] = relative_node_coords[2] - relative_node_coords_dt[2]
+                node.SetSolutionStepValue(DELTA_DISPLACEMENT, delta_displacement)
+
+                particle_rotation_angle = [0]*3
+                particle_rotation_angle[0] = angular_velocity[0] * time
+                particle_rotation_angle[1] = angular_velocity[1] * time
+                particle_rotation_angle[2] = angular_velocity[2] * time
+                node.SetSolutionStepValue(PARTICLE_ROTATION_ANGLE, particle_rotation_angle)
+
+                delta_rotation = [0]*3
+                delta_rotation[0] = angular_velocity[0] * dt
+                delta_rotation[1] = angular_velocity[1] * dt
+                delta_rotation[2] = angular_velocity[2] * dt
+                node.SetSolutionStepValue(DELTA_ROTATION, delta_rotation)
+
+            if node.Id == 140:
+                angular_velocity = [0]*3
+                node.SetSolutionStepValue(ANGULAR_VELOCITY, angular_velocity)
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
+        #Logger.PrintInfo("generate_graph_points bench24, graph_print_interval, dt - ", graph_print_interval, dt )
+        self.graph_frequency = int(graph_print_interval/dt)
+
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1
+
+        if (self.balls_graph_counter == self.graph_frequency):
+            self.balls_graph_counter = 0
+            self.total_force_x = 0.0
+            self.total_force_y = 0.0
+
+            for node in modelpart.Nodes:
+                if node.Id == 141:
+                   force_node_x = node.GetSolutionStepValue(ELASTIC_FORCES)[0]
+                   force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+                   self.total_force_x += force_node_x
+                   self.total_force_y += force_node_y
+
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_x).rjust(13)+" "+str("%.6g"%self.total_force_y).rjust(13)+"\n")
+        self.balls_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+        error1, error2, error3 = self.compute_errors(self.output_filename)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+        error_file.write("DEM Benchmark 24:")
+
+        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
+            error_file.write(" OK!........ Test 24 SUCCESSFUL\n")
+            shutil.rmtree('benchmark24_Post_Files', ignore_errors = True)
+        else:
+            error_file.write(" KO!........ Test 24 FAILED\n")
+        error_file.close()
+
+    def compute_errors(self, output_filename):
+        lines_analytics = lines_DEM = list(range(0, 1000));
+        analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
+        i = 0
+        with open('paper_data/reference_graph_benchmark' + '24' + '.dat') as inf:
+            for line in inf:
+                if i in lines_analytics:
+                    parts = line.split()
+                    analytics_data.append(float(parts[2]))
+                i+=1
+        i = 0
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[2]))   #segona component del vector ()
+                i+=1
+        generated_data_error = 0
+
+        for j in analytics_data:
+            summation_of_analytics_data+=abs(j)
+
+        for i, j in zip(DEM_data, analytics_data):
+            generated_data_error+=abs(i-j)
+        generated_data_error/=summation_of_analytics_data
+
+        Logger.PrintInfo("Error in simulation =", 100*generated_data_error,"%")
+        error1 = 100*generated_data_error
+        error2 = error3 = 0
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+    def create_gnuplot_scripts(self, output_filename, dt):
+        pass
+
+
+class Benchmark25:
+
+    def __init__(self):
+        self.number = 25
+        self.generated_data = None
+        self.balls_graph_counter = 1
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):
+        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.simulation_graph = open(self.output_filename, 'w')
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
+        self.simulation_graph.close()
+
+    def cross_product(self, a, b):
+        c = [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]
+        return c
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        ang_vel = 20 * pi
+        angular_velocity = [0, 0, ang_vel]
+        rotation_matrix = [[cos(ang_vel * time), -1.0 * sin(ang_vel * time), 0], [sin(ang_vel * time), cos(ang_vel * time), 0], [0,0,1]]
+        time_dt = time - dt
+        rotation_matrix_minus_dt = [[cos(ang_vel * time_dt), -1.0 * sin(ang_vel * time_dt), 0], [sin(ang_vel * time_dt), cos(ang_vel * time_dt), 0], [0,0,1]] #
+        centroid = [-1.0, 0.0, 0.0]
+        relative_initial_node_coords, relative_node_coords, relative_node_coords_dt = [0]*3, [0]*3, [0]*3
+        sum, sum_dt = 0, 0
+
+        for node in modelpart.Nodes:
+            if node.Id == 141:
+                for j in range(3):
+                    rot_mat = rotation_matrix[j]
+                    rot_mat_dt = rotation_matrix_minus_dt[j]
+                    relative_initial_node_coords[0] = node.X0 - centroid[0]
+                    relative_initial_node_coords[1] = node.Y0 - centroid[1]
+                    relative_initial_node_coords[2] = node.Z0 - centroid[2]
+                    for i in range(3):
+                        sum += rot_mat[i] * relative_initial_node_coords[i]
+                        sum_dt += rot_mat_dt[i] * relative_initial_node_coords[i]
+                    relative_node_coords[j], sum, relative_node_coords_dt[j], sum_dt = sum, 0, sum_dt, 0
+                node.X = relative_node_coords[0] + centroid[0]
+                node.Y = relative_node_coords[1] + centroid[1]
+                node.Z = relative_node_coords[2] + centroid[2]
+
+                displacement = GetDisplacement(node)
+                node.SetSolutionStepValue(DISPLACEMENT, displacement)
+
+                velocity = [0]*3
+                velocity = self.cross_product(angular_velocity, relative_node_coords)
+                node.SetSolutionStepValue(VELOCITY, velocity)
+
+                angular_velocity = [0]*3
+                node.SetSolutionStepValue(ANGULAR_VELOCITY, angular_velocity)
+
+                delta_displacement = [0]*3
+                delta_displacement[0] = relative_node_coords[0] - relative_node_coords_dt[0]
+                delta_displacement[1] = relative_node_coords[1] - relative_node_coords_dt[1]
+                delta_displacement[2] = relative_node_coords[2] - relative_node_coords_dt[2]
+                node.SetSolutionStepValue(DELTA_DISPLACEMENT, delta_displacement)
+
+                particle_rotation_angle = [0]*3
+                particle_rotation_angle[0] = angular_velocity[0] * time
+                particle_rotation_angle[1] = angular_velocity[1] * time
+                particle_rotation_angle[2] = angular_velocity[2] * time
+                node.SetSolutionStepValue(PARTICLE_ROTATION_ANGLE, particle_rotation_angle)
+
+                delta_rotation = [0]*3
+                delta_rotation[0] = angular_velocity[0] * dt
+                delta_rotation[1] = angular_velocity[1] * dt
+                delta_rotation[2] = angular_velocity[2] * dt
+                node.SetSolutionStepValue(DELTA_ROTATION, delta_rotation)
+
+                if time > 3.8e-5:
+                    radius = 1.0001
+                    node.SetSolutionStepValue(RADIUS, radius)
+            if node.Id == 140:
+                angular_velocity = [0]*3
+                node.SetSolutionStepValue(ANGULAR_VELOCITY, angular_velocity)
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
+        self.graph_frequency = int(graph_print_interval/dt)
+
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1
+
+        if (self.balls_graph_counter == self.graph_frequency):
+            self.balls_graph_counter = 0
+            self.total_force_x = 0.0
+            self.total_force_y = 0.0
+
+            for node in modelpart.Nodes:
+                if node.Id == 141:
+                   force_node_x = node.GetSolutionStepValue(ELASTIC_FORCES)[0]
+                   force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+                   self.total_force_x += force_node_x
+                   self.total_force_y += force_node_y
+
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_x).rjust(13)+" "+str("%.6g"%self.total_force_y).rjust(13)+"\n")
+        self.balls_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+        error1, error2, error3 = self.compute_errors(self.output_filename)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+        error_file.write("DEM Benchmark 25:")
+
+        if (error1 < 10.0 and error2 < 10.0 and error3 < 10.0):
+            error_file.write(" OK!........ Test 25 SUCCESSFUL\n")
+            shutil.rmtree('benchmark25_Post_Files', ignore_errors = True)
+        else:
+            error_file.write(" KO!........ Test 25 FAILED\n")
+        error_file.close()
+
+    def compute_errors(self, output_filename):
+        lines_analytics = lines_DEM = list(range(0, 1000));
+        analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
+        i = 0
+        with open('paper_data/reference_graph_benchmark' + '25' + '.dat') as inf:
+            for line in inf:
+                if i in lines_analytics:
+                    parts = line.split()
+                    analytics_data.append(float(parts[2]))
+                i+=1
+        i = 0
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[2]))   #segona component del vector ()
+                i+=1
+        generated_data_error = 0
+
+        for j in analytics_data:
+            summation_of_analytics_data+=abs(j)
+
+        for i, j in zip(DEM_data, analytics_data):
+            generated_data_error+=abs(i-j)
+        generated_data_error/=summation_of_analytics_data
+
+        Logger.PrintInfo("Error in simulation =", 100*generated_data_error,"%")
+        error1 = 100*generated_data_error
+        error2 = error3 = 0
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+    def create_gnuplot_scripts(self, output_filename, dt):
+        pass
+
+
+class Benchmark26:
+
+    def __init__(self):
+        self.number = 26
+
+        self.generated_data = None
+        self.balls_graph_counter = 1
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):
+
+        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.simulation_graph = open(self.output_filename, 'w')
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
+        self.simulation_graph.close()
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
+
+        self.graph_frequency = int(graph_print_interval/dt)
+
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1
+
+        if (self.balls_graph_counter == self.graph_frequency):
+            self.balls_graph_counter = 0
+            self.total_force_x = 0.0
+            self.total_force_y = 0.0
+
+            for node in modelpart.Nodes:
+                if node.Id == 141:
+                    force_node_x = node.GetSolutionStepValue(ELASTIC_FORCES)[0]
+                    force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+                    self.total_force_x += force_node_x
+                    self.total_force_y += force_node_y
+
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_x).rjust(13)+" "+str("%.6g"%self.total_force_y).rjust(13)+"\n")
+        self.balls_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt = 0):
+        pass
+
+    def compute_errors(self, output_filename):
+        pass
+
+    def create_gnuplot_scripts(self, output_filename, dt):
+        pass
+
+
+class Benchmark27:
+
+    def __init__(self):
+        self.number = 27
+        self.generated_data = None
+        self.balls_graph_counter = 1
+        self.rigid_graph_counter = 1
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):
+
+        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.rigid_face_file = "benchmark" + str(sys.argv[1]) + '_rigid_graph.dat'
+        self.simulation_graph = open(self.output_filename, 'w')
+        self.rigid_graph = open(self.rigid_face_file, 'w')
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
+        self.simulation_graph.close()
+        self.rigid_graph.close()
+
+    def cross_product(self, a, b):
+        c = [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]
+        return c
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+
+        ang_vel = 20 * pi
+        angular_velocity = [0, 0, ang_vel]
+        rotation_matrix = [[cos(ang_vel * time), -1.0 * sin(ang_vel * time), 0], [sin(ang_vel * time), cos(ang_vel * time), 0], [0,0,1]]
+        time_dt = time - dt
+        rotation_matrix_minus_dt = [[cos(ang_vel * time_dt), -1.0 * sin(ang_vel * time_dt), 0], [sin(ang_vel * time_dt), cos(ang_vel * time_dt), 0], [0,0,1]] #
+        centroid = [-1.0, 0.0, 0.0]
+        relative_initial_node_coords, relative_node_coords, relative_node_coords_dt = [0]*3, [0]*3, [0]*3
+        sum, sum_dt = 0, 0
+
+        for node in modelpart.Nodes:
+            if node.Id == 999999:
+                for j in range(3):
+                    rot_mat = rotation_matrix[j]
+                    rot_mat_dt = rotation_matrix_minus_dt[j]
+                    relative_initial_node_coords[0] = node.X0 - centroid[0]
+                    relative_initial_node_coords[1] = node.Y0 - centroid[1]
+                    relative_initial_node_coords[2] = node.Z0 - centroid[2]
+                    for i in range(3):
+                        sum += rot_mat[i] * relative_initial_node_coords[i]
+                        sum_dt += rot_mat_dt[i] * relative_initial_node_coords[i]
+                    relative_node_coords[j], sum, relative_node_coords_dt[j], sum_dt = sum, 0, sum_dt, 0
+                node.X = relative_node_coords[0] + centroid[0]
+                node.Y = relative_node_coords[1] + centroid[1]
+                node.Z = relative_node_coords[2] + centroid[2]
+
+                displacement = GetDisplacement(node)
+                node.SetSolutionStepValue(DISPLACEMENT, displacement)
+
+                velocity = [0]*3
+                velocity = self.cross_product(angular_velocity, relative_node_coords)
+                node.SetSolutionStepValue(VELOCITY, velocity)
+
+                angular_velocity = [0]*3
+                node.SetSolutionStepValue(ANGULAR_VELOCITY, angular_velocity)
+
+                delta_displacement = [0]*3
+                delta_displacement[0] = relative_node_coords[0] - relative_node_coords_dt[0]
+                delta_displacement[1] = relative_node_coords[1] - relative_node_coords_dt[1]
+                delta_displacement[2] = relative_node_coords[2] - relative_node_coords_dt[2]
+                node.SetSolutionStepValue(DELTA_DISPLACEMENT, delta_displacement)
+
+                particle_rotation_angle = [0]*3
+                particle_rotation_angle[0] = angular_velocity[0] * time
+                particle_rotation_angle[1] = angular_velocity[1] * time
+                particle_rotation_angle[2] = angular_velocity[2] * time
+                node.SetSolutionStepValue(PARTICLE_ROTATION_ANGLE, particle_rotation_angle)
+
+                delta_rotation = [0]*3
+                delta_rotation[0] = angular_velocity[0] * dt
+                delta_rotation[1] = angular_velocity[1] * dt
+                delta_rotation[2] = angular_velocity[2] * dt
+                node.SetSolutionStepValue(DELTA_ROTATION, delta_rotation)
+
+                if time > 3.8e-5:
+                    radius = 1.0001
+                    node.SetSolutionStepValue(RADIUS, radius)
+            if node.Id == 99999:
+                angular_velocity = [0]*3
+                node.SetSolutionStepValue(ANGULAR_VELOCITY, angular_velocity)
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
+
+        #self.graph_frequency = int(5e-7/dt)   #graph_print_interval/dt
+        self.graph_frequency = int(graph_print_interval/1/dt)   #1 veces mas grf que bin
+        #print (self.graph_frequency)
+        #print (self.balls_graph_counter)
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1
+
+        if (self.balls_graph_counter == self.graph_frequency):
+            #print (self.balls_graph_counter)
+            self.balls_graph_counter = 0
+            self.total_force_x = 0.0
+            self.total_force_y = 0.0
+            self.total_force_z = 0.0
+            self.total_force_sum = 0.0
+
+            self.total_angular_x = 0.0
+            self.total_angular_y = 0.0
+            self.total_angular_z = 0.0
+            self.total_angular_sum = 0.0
+
+            self.total_delta_x = 0.0
+            self.total_delta_y = 0.0
+            self.total_delta_z = 0.0
+            self.total_delta_sum = 0.0
+
+            for node in modelpart.Nodes:
+                if node.Id == 29:
+                   force_node_x = node.GetSolutionStepValue(ELASTIC_FORCES)[0]
+                   force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+                   force_node_z = node.GetSolutionStepValue(ELASTIC_FORCES)[2]
+                   self.total_force_x += force_node_x
+                   self.total_force_y += force_node_y
+                   self.total_force_z += force_node_z
+
+                   angular_node_x = node.GetSolutionStepValue(ANGULAR_VELOCITY)[0]
+                   angular_node_y = node.GetSolutionStepValue(ANGULAR_VELOCITY)[1]
+                   angular_node_z = node.GetSolutionStepValue(ANGULAR_VELOCITY)[2]
+                   self.total_angular_x += angular_node_x
+                   self.total_angular_y += angular_node_y
+                   self.total_angular_z += angular_node_z
+
+                   delta_node_x = node.GetSolutionStepValue(DELTA_DISPLACEMENT)[0]
+                   delta_node_y = node.GetSolutionStepValue(DELTA_DISPLACEMENT)[1]
+                   delta_node_z = node.GetSolutionStepValue(DELTA_DISPLACEMENT)[2]
+                   self.total_delta_x += delta_node_x
+                   self.total_delta_y += delta_node_y
+                   self.total_delta_z += delta_node_z
+
+            self.total_force_sum = self.total_force_x + self.total_force_y + self.total_force_z
+            self.total_angular_sum = self.total_angular_x + self.total_angular_y + self.total_angular_z
+            self.total_delta_sum = self.total_delta_x + self.total_delta_y + self.total_delta_z
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_sum).rjust(13)+" "+str("%.6g"%self.total_angular_sum).rjust(13)+" "+str("%.6g"%self.total_delta_sum).rjust(13)+"\n")
+            self.simulation_graph.flush()
+        self.balls_graph_counter += 1
+
+        for mesh_number in range(1, rigid_face_model_part.NumberOfMeshes()):
+            if(rigid_face_model_part.GetMesh(mesh_number)[TOP]):
+
+              self.top_mesh_nodes = rigid_face_model_part.GetMesh(mesh_number).Nodes
+
+            if (self.rigid_graph_counter == self.graph_frequency):
+                self.rigid_graph_counter = 0
+                self.total_force_top = 0.0
+
+                for node in self.top_mesh_nodes:
+
+                  force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+                  self.total_force_top += force_node_y
+
+                self.rigid_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_top).rjust(13)+"\n")
+                self.rigid_graph.flush()
+        self.rigid_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+        error1, error2, error3 = self.compute_errors(self.output_filename)
+        error4, error5, error6 = self.compute_rigid_errors(self.rigid_face_file)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3, error4, error5)
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+        error_file.write("DEM Benchmark 27:")
+
+        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
+            error_file.write(" OK!........ Test 27 SUCCESSFUL (spheres)\n")
+            shutil.rmtree('benchmark27_Post_Files', ignore_errors = True)
+        else:
+            error_file.write(" KO!........ Test 27 FAILED (spheres)\n")
+        error_file.write("DEM Benchmark 27:")
+        if (error4 < 0.01 and error5 < 0.01 and error6 < 0.01):
+            error_file.write(" OK!........ Test 27 SUCCESSFUL (finite elements)\n")
+        else:
+            error_file.write(" KO!........ Test 27 FAILED (finite elements)\n")
+        error_file.close()
+
+    def compute_errors(self, output_filename):
+        reference_data = lines_DEM = list(range(0, 1000));
+        analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
+        i = 0
+        with open('paper_data/reference_graph_benchmark' + '27' + '.dat') as reference:
+            for line in reference:
+                if i in reference_data:
+                    parts = line.split()
+                    analytics_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(output_filename) as current_data:
+            extend_datafile_list(glob(output_filename))
+            for line in current_data:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))   #segona component del vector ()
+                i+=1
+        dem_error1 = 0
+
+        for j in analytics_data:
+            summation_of_analytics_data+=abs(j)
+
+        for i, j in zip(DEM_data, analytics_data):
+            dem_error1+=abs(i-j)
+        dem_error1/=summation_of_analytics_data
+        if dem_error1 < 0.001:
+           dem_error1 = 0.0
+
+        Logger.PrintInfo("Error in total force at the reference particle =", 100*dem_error1,"%")
+
+        i = 0
+        with open('paper_data/reference_graph_benchmark' + '27' + '.dat') as reference:
+            for line in reference:
+                if i in reference_data:
+                    parts = line.split()
+                    analytics_data.append(float(parts[2]))
+                i+=1
+        i = 0
+        with open(output_filename) as current_data:
+            extend_datafile_list(glob(output_filename))
+            for line in current_data:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[2]))   #segona component del vector ()
+                i+=1
+        dem_error2 = 0
+
+        for j in analytics_data:
+            summation_of_analytics_data+=abs(j)
+
+        for i, j in zip(DEM_data, analytics_data):
+            dem_error2+=abs(i-j)
+        dem_error2/=summation_of_analytics_data
+        if dem_error2 < 0.001:
+           dem_error2 = 0.0
+
+        Logger.PrintInfo("Error in angular velocity at the reference particle =", 100*dem_error2,"%")
+
+
+        i = 0
+        with open('paper_data/reference_graph_benchmark' + '27' + '.dat') as reference:
+            for line in reference:
+                if i in reference_data:
+                    parts = line.split()
+                    analytics_data.append(float(parts[3]))
+                i+=1
+        i = 0
+        with open(output_filename) as current_data:
+            for line in current_data:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[3]))   #segona component del vector ()
+                i+=1
+        dem_error3 = 0
+
+        for j in analytics_data:
+            summation_of_analytics_data+=abs(j)
+
+        for i, j in zip(DEM_data, analytics_data):
+            dem_error3+=abs(i-j)
+        dem_error3/=summation_of_analytics_data
+        if dem_error3 < 0.001:
+           dem_error3 = 0.0
+
+        Logger.PrintInfo("Error in delta displacement at the reference particle =", 100*dem_error3,"%")
+
+        error1 = 100*dem_error1
+        error2 = 100*dem_error2
+        error3 = 100*dem_error3
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+    def compute_rigid_errors(self, rigid_face_file):
+        reference_data = lines_FEM = list(range(0, 1000));
+        analytics_data = []; FEM_data = []; summation_of_analytics_data = 0
+        i = 0
+        with open('paper_data/reference_rigid_graph_benchmark' + '27' + '.dat') as reference:
+
+            for line in reference:
+                if i in reference_data:
+                    parts = line.split()
+                    analytics_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(rigid_face_file) as current_data:
+            extend_datafile_list(glob(rigid_face_file))
+            for line in current_data:
+                if i in lines_FEM:
+                    parts = line.split()
+                    FEM_data.append(float(parts[1]))   #segona component del vector ()
+                i+=1
+        final_error = 0
+
+        for j in analytics_data:
+            summation_of_analytics_data+=abs(j)
+
+        for i, j in zip(FEM_data, analytics_data):
+            final_error+=abs(i-j)
+        final_error/=summation_of_analytics_data
+        if final_error < 0.001:
+           final_error = 0.0
+
+        Logger.PrintInfo("Error in FEM axial force =", 100*final_error,"%")
+
+        error4 = 100*final_error
+
+        error5 = error6 = 0
+
+        delete_current_benchmark_data()
+
+        return error4, error5, error6
+
+    def create_gnuplot_scripts(self, output_filename, dt):
+        pass
+
+
+
+class Benchmark28:   #pendulo3D
+
+    def __init__(self):
+        self.number = 28
+        self.generated_data = None
+        self.balls_graph_counter = 1
+        self.rigid_graph_counter = 1
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):
+
+        self.output_filename = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.rigid_face_file = "benchmark" + str(sys.argv[1]) + '_rigid_graph.dat'
+        self.simulation_graph = open(self.output_filename, 'w')
+        self.rigid_graph = open(self.rigid_face_file, 'w')
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
+        self.simulation_graph.close()
+        self.rigid_graph.close()
+
+    def cross_product(self, a, b):
+        c = [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]
+        return c
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+        ang_vel = 20 * pi
+        angular_velocity = [0, 0, ang_vel]
+        rotation_matrix = [[cos(ang_vel * time), -1.0 * sin(ang_vel * time), 0], [sin(ang_vel * time), cos(ang_vel * time), 0], [0,0,1]]
+        time_dt = time - dt
+        rotation_matrix_minus_dt = [[cos(ang_vel * time_dt), -1.0 * sin(ang_vel * time_dt), 0], [sin(ang_vel * time_dt), cos(ang_vel * time_dt), 0], [0,0,1]] #
+        centroid = [-1.0, 0.0, 0.0]
+        relative_initial_node_coords, relative_node_coords, relative_node_coords_dt = [0]*3, [0]*3, [0]*3
+        sum, sum_dt = 0, 0
+
+        for node in modelpart.Nodes:
+            if node.Id == 999999:
+                for j in range(3):
+                    rot_mat = rotation_matrix[j]
+                    rot_mat_dt = rotation_matrix_minus_dt[j]
+                    relative_initial_node_coords[0] = node.X0 - centroid[0]
+                    relative_initial_node_coords[1] = node.Y0 - centroid[1]
+                    relative_initial_node_coords[2] = node.Z0 - centroid[2]
+                    for i in range(3):
+                        sum += rot_mat[i] * relative_initial_node_coords[i]
+                        sum_dt += rot_mat_dt[i] * relative_initial_node_coords[i]
+                    relative_node_coords[j], sum, relative_node_coords_dt[j], sum_dt = sum, 0, sum_dt, 0
+                node.X = relative_node_coords[0] + centroid[0]
+                node.Y = relative_node_coords[1] + centroid[1]
+                node.Z = relative_node_coords[2] + centroid[2]
+
+                displacement = GetDisplacement(node)
+                node.SetSolutionStepValue(DISPLACEMENT, displacement)
+
+                velocity = [0]*3
+                velocity = self.cross_product(angular_velocity, relative_node_coords)
+                node.SetSolutionStepValue(VELOCITY, velocity)
+
+                angular_velocity = [0]*3
+                node.SetSolutionStepValue(ANGULAR_VELOCITY, angular_velocity)
+
+                delta_displacement = [0]*3
+                delta_displacement[0] = relative_node_coords[0] - relative_node_coords_dt[0]
+                delta_displacement[1] = relative_node_coords[1] - relative_node_coords_dt[1]
+                delta_displacement[2] = relative_node_coords[2] - relative_node_coords_dt[2]
+                node.SetSolutionStepValue(DELTA_DISPLACEMENT, delta_displacement)
+
+                particle_rotation_angle = [0]*3
+                particle_rotation_angle[0] = angular_velocity[0] * time
+                particle_rotation_angle[1] = angular_velocity[1] * time
+                particle_rotation_angle[2] = angular_velocity[2] * time
+                node.SetSolutionStepValue(PARTICLE_ROTATION_ANGLE, particle_rotation_angle)
+
+                delta_rotation = [0]*3
+                delta_rotation[0] = angular_velocity[0] * dt
+                delta_rotation[1] = angular_velocity[1] * dt
+                delta_rotation[2] = angular_velocity[2] * dt
+                node.SetSolutionStepValue(DELTA_ROTATION, delta_rotation)
+
+                if time > 3.8e-5:
+                    radius = 1.0001
+                    node.SetSolutionStepValue(RADIUS, radius)
+            if node.Id == 99999:
+                angular_velocity = [0]*3
+                node.SetSolutionStepValue(ANGULAR_VELOCITY, angular_velocity)
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
+
+        #self.graph_frequency = int(5e-7/dt)   #graph_print_interval/dt
+        self.graph_frequency = int(graph_print_interval/1/dt)   #1 veces mas grf que bin
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1
+
+        if (self.balls_graph_counter == self.graph_frequency):
+            self.balls_graph_counter = 0
+            self.total_force_x = 0.0
+            self.total_force_y = 0.0
+            self.total_force_z = 0.0
+            self.total_force_sum = 0.0
+
+            self.total_angular_x = 0.0
+            self.total_angular_y = 0.0
+            self.total_angular_z = 0.0
+            self.total_angular_sum = 0.0
+
+            self.total_delta_x = 0.0
+            self.total_delta_y = 0.0
+            self.total_delta_z = 0.0
+            self.total_delta_sum = 0.0
+
+            for node in modelpart.Nodes:
+                if node.Id == 107:
+                   force_node_x = node.GetSolutionStepValue(LOCAL_CONTACT_FORCE)[0]
+                   force_node_y = node.GetSolutionStepValue(LOCAL_CONTACT_FORCE)[1]
+                   force_node_z = node.GetSolutionStepValue(LOCAL_CONTACT_FORCE)[2]
+                   self.total_force_x += force_node_x
+                   self.total_force_y += force_node_y
+                   self.total_force_z += force_node_z
+
+                   angular_node_x = node.GetSolutionStepValue(ANGULAR_VELOCITY)[0]
+                   angular_node_y = node.GetSolutionStepValue(ANGULAR_VELOCITY)[1]
+                   angular_node_z = node.GetSolutionStepValue(ANGULAR_VELOCITY)[2]
+                   self.total_angular_x += angular_node_x
+                   self.total_angular_y += angular_node_y
+                   self.total_angular_z += angular_node_z
+
+                   delta_node_x = node.GetSolutionStepValue(DELTA_DISPLACEMENT)[0]
+                   delta_node_y = node.GetSolutionStepValue(DELTA_DISPLACEMENT)[1]
+                   delta_node_z = node.GetSolutionStepValue(DELTA_DISPLACEMENT)[2]
+                   self.total_delta_x += delta_node_x
+                   self.total_delta_y += delta_node_y
+                   self.total_delta_z += delta_node_z
+
+            self.total_force_sum = self.total_force_x + self.total_force_y + self.total_force_z
+            self.total_angular_sum = self.total_angular_x + self.total_angular_y + self.total_angular_z
+            self.total_delta_sum = self.total_delta_x + self.total_delta_y + self.total_delta_z
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%self.total_force_sum).rjust(13)+" "+str("%.6g"%self.total_angular_sum).rjust(13)+" "+str("%.6g"%self.total_delta_sum).rjust(13)+"\n")
+            self.simulation_graph.flush()
+        self.balls_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+        error1, error2, error3 = self.compute_errors(self.output_filename)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+        error_file.write("DEM Benchmark 28:")
+
+        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
+            error_file.write(" OK!........ Test 28 SUCCESSFUL (spheres)\n")
+            shutil.rmtree('benchmark28_Post_Files', ignore_errors = True)
+        else:
+            error_file.write(" KO!........ Test 28 FAILED (spheres)\n")
+        error_file.write("DEM Benchmark 28:")
+
+
+    def compute_errors(self, output_filename):
+        reference_data = lines_DEM = list(range(0, 1000));
+        analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
+        i = 0
+        with open('paper_data/reference_graph_benchmark' + '28' + '.dat') as reference:
+            for line in reference:
+                if i in reference_data:
+                    parts = line.split()
+                    analytics_data.append(float(parts[1]))
+                i+=1
+        i = 0
+        with open(output_filename) as current_data:
+            extend_datafile_list(glob(output_filename))
+            for line in current_data:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[1]))   #1 component del vector ()
+                i+=1
+        dem_error1 = 0
+
+        for j in analytics_data:
+            summation_of_analytics_data+=abs(j)
+
+        for i, j in zip(DEM_data, analytics_data):
+            dem_error1+=abs(i-j)
+        dem_error1/=summation_of_analytics_data
+
+        Logger.PrintInfo("Error in total force at the reference particle =", 100*dem_error1,"%")
+
+        i = 0
+        with open('paper_data/reference_graph_benchmark' + '28' + '.dat') as reference:
+            for line in reference:
+                if i in reference_data:
+                    parts = line.split()
+                    analytics_data.append(float(parts[2]))
+                i+=1
+        i = 0
+        with open(output_filename) as current_data:
+            for line in current_data:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[2]))   #segona component del vector ()
+                i+=1
+        dem_error2 = 0
+
+        for j in analytics_data:
+            summation_of_analytics_data+=abs(j)
+
+        for i, j in zip(DEM_data, analytics_data):
+            dem_error2+=abs(i-j)
+        dem_error2/=summation_of_analytics_data
+
+        Logger.PrintInfo("Error in angular velocity at the reference particle =", 100*dem_error2,"%")
+
+
+        i = 0
+        with open('paper_data/reference_graph_benchmark' + '28' + '.dat') as reference:
+            for line in reference:
+                if i in reference_data:
+                    parts = line.split()
+                    analytics_data.append(float(parts[3]))
+                i+=1
+        i = 0
+        with open(output_filename) as current_data:
+            for line in current_data:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data.append(float(parts[3]))   #3 component del vector ()
+                i+=1
+        dem_error3 = 0
+
+        for j in analytics_data:
+            summation_of_analytics_data+=abs(j)
+
+        for i, j in zip(DEM_data, analytics_data):
+            dem_error3+=abs(i-j)
+        dem_error3/=summation_of_analytics_data
+
+        Logger.PrintInfo("Error in delta displacement at the reference particle =", 100*dem_error3,"%")
+
+        error1 = 100*dem_error1
+        error2 = 100*dem_error2
+        error3 = 100*dem_error3
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+    def compute_rigid_errors(self, rigid_face_file):
+        pass
+
+    def create_gnuplot_scripts(self, output_filename, dt):
+        pass
+
+
+
+class Benchmark30: ########## Cylinder with imposed angular velocity (Velocity Verlet + Zhao)
+
+    def __init__(self):
+        self.number = 30
+
+        self.cluster_graph_counter = 1   # deberia ser self.cluster_graph_counter = self.graph_frequency
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        self.local_angular_velocity_list_outfile_name = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.simulation_graph = open(self.local_angular_velocity_list_outfile_name, 'w')
+
+    def get_final_data(self, spheres_model_part, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
+
+        self.simulation_graph.close()
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def generate_graph_points(self, spheres_model_part, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
+
+        self.graph_frequency        = int(graph_print_interval/dt)
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
+
+        if(self.cluster_graph_counter == self.graph_frequency):     #if(self.cluster_graph_counter == self.graph_frequency):
+            self.cluster_graph_counter = 0
+            total_local_angular_velocity_x = 0.0
+            total_local_angular_velocity_y = 0.0
+            total_local_angular_velocity_z = 0.0
+
+            for node in cluster_model_part.Nodes:
+                current_local_angular_velocity_x = node.GetSolutionStepValue(LOCAL_ANGULAR_VELOCITY_X)
+                total_local_angular_velocity_x += current_local_angular_velocity_x
+                current_local_angular_velocity_y = node.GetSolutionStepValue(LOCAL_ANGULAR_VELOCITY_Y)
+                total_local_angular_velocity_y += current_local_angular_velocity_y
+                current_local_angular_velocity_z = node.GetSolutionStepValue(LOCAL_ANGULAR_VELOCITY_Z)
+                total_local_angular_velocity_z += current_local_angular_velocity_z
+
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_local_angular_velocity_x).rjust(13)+" "+str("%.6g"%total_local_angular_velocity_y).rjust(13)+" "+str("%.6g"%total_local_angular_velocity_z).rjust(13)+"\n")
+        self.cluster_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
+
+        error1, error2, error3 = self.compute_errors(self.local_angular_velocity_list_outfile_name)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+        error_file.write("\n\n")
+        error_file.write("===== DISCONTINUUM CLUSTERS TESTS =====\n\n")
+        error_file.write("DEM Benchmark 30:")
+
+        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
+            error_file.write(" OK!........ Test 30 SUCCESSFUL\n")
+        else:
+            error_file.write(" KO!........ Test 30 FAILED\n")
+        error_file.close()
+
+    def compute_errors(self, output_filename):  #FINALIZATION STEP
+
+        lines_analytics = lines_DEM = list(range(0, 50));
+        ref_data1 = []; ref_data2 = []; DEM_data1 = []; ref_data3 = []; DEM_data1 = []; DEM_data2 = []; DEM_data3 = []; summation_of_ref_data1 = 0; summation_of_ref_data2 = 0; summation_of_ref_data3 = 0
+        i = 0
+        with open('paper_data/benchmark' + str(sys.argv[1]) + '_graph.dat') as inf:  #with open('paper_data/reference_graph_benchmark30.dat') as inf:
+            for line in inf:
+                if i in lines_analytics:
+                    parts = line.split()
+                    ref_data1.append(float(parts[1]))
+                    ref_data2.append(float(parts[2]))
+                    ref_data3.append(float(parts[3]))
+                i+=1
+        i = 0
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data1.append(float(parts[1]))
+                    DEM_data2.append(float(parts[2]))
+                    DEM_data3.append(float(parts[3]))
+                i+=1
+        final_local_angular_velocity_x_error = 0
+        final_local_angular_velocity_y_error = 0
+        final_local_angular_velocity_z_error = 0
+
+        for j in ref_data1:
+            summation_of_ref_data1+=abs(j)
+        for k in ref_data2:
+            summation_of_ref_data2+=abs(k)
+        for l in ref_data3:
+            summation_of_ref_data3+=abs(l)
+
+        for i, j in zip(DEM_data1, ref_data1):
+            final_local_angular_velocity_x_error+=abs(i-j)
+        final_local_angular_velocity_x_error/=summation_of_ref_data1
+
+        for k, l in zip(DEM_data2, ref_data2):
+            final_local_angular_velocity_y_error+=abs(k-l)
+        final_local_angular_velocity_y_error/=summation_of_ref_data2
+
+        for m, n in zip(DEM_data3, ref_data3):
+            final_local_angular_velocity_z_error+=abs(m-n)
+        final_local_angular_velocity_z_error/=summation_of_ref_data3
+
+        Logger.PrintInfo("Error in local angular velocity X =", 100*final_local_angular_velocity_x_error,"%")
+
+        Logger.PrintInfo("Error in local angular velocity Y =", 100*final_local_angular_velocity_y_error,"%")
+
+        Logger.PrintInfo("Error in local angular velocity Z =", 100*final_local_angular_velocity_z_error,"%")
+
+        error1 = 100*final_local_angular_velocity_x_error
+
+        error2 = 100*final_local_angular_velocity_y_error
+
+        error3 = 100*final_local_angular_velocity_z_error
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+class Benchmark31: ########## Cylinder with imposed angular velocity (Symplectic Euler + Runge-Kutta)
+
+    def __init__(self):
+        self.number = 31
+
+        self.cluster_graph_counter = 1   # deberia ser self.cluster_graph_counter = self.graph_frequency
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        self.local_angular_velocity_list_outfile_name = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.simulation_graph = open(self.local_angular_velocity_list_outfile_name, 'w')
+
+    def get_final_data(self, spheres_model_part, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
+
+        self.simulation_graph.close()
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def generate_graph_points(self, spheres_model_part, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
+
+        self.graph_frequency        = int(graph_print_interval/dt)
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
+
+        if(self.cluster_graph_counter == self.graph_frequency):     #if(self.cluster_graph_counter == self.graph_frequency):
+            self.cluster_graph_counter = 0
+            total_local_angular_velocity_x = 0.0
+            total_local_angular_velocity_y = 0.0
+            total_local_angular_velocity_z = 0.0
+
+            for node in cluster_model_part.Nodes:
+                current_local_angular_velocity_x = node.GetSolutionStepValue(LOCAL_ANGULAR_VELOCITY_X)
+                total_local_angular_velocity_x += current_local_angular_velocity_x
+                current_local_angular_velocity_y = node.GetSolutionStepValue(LOCAL_ANGULAR_VELOCITY_Y)
+                total_local_angular_velocity_y += current_local_angular_velocity_y
+                current_local_angular_velocity_z = node.GetSolutionStepValue(LOCAL_ANGULAR_VELOCITY_Z)
+                total_local_angular_velocity_z += current_local_angular_velocity_z
+
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_local_angular_velocity_x).rjust(13)+" "+str("%.6g"%total_local_angular_velocity_y).rjust(13)+" "+str("%.6g"%total_local_angular_velocity_z).rjust(13)+"\n")
+        self.cluster_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
+
+        error1, error2, error3 = self.compute_errors(self.local_angular_velocity_list_outfile_name)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2, error3)
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+        error_file.write("DEM Benchmark 31:")
+
+        if (error1 < 0.01 and error2 < 0.01 and error3 < 0.01):
+            error_file.write(" OK!........ Test 31 SUCCESSFUL\n")
+        else:
+            error_file.write(" KO!........ Test 31 FAILED\n")
+        error_file.close()
+
+    def compute_errors(self, output_filename):  #FINALIZATION STEP
+
+        lines_analytics = lines_DEM = list(range(0, 50));
+        ref_data1 = []; ref_data2 = []; DEM_data1 = []; ref_data3 = []; DEM_data1 = []; DEM_data2 = []; DEM_data3 = []; summation_of_ref_data1 = 0; summation_of_ref_data2 = 0; summation_of_ref_data3 = 0
+        i = 0
+        with open('paper_data/benchmark' + str(sys.argv[1]) + '_graph.dat') as inf:  #with open('paper_data/reference_graph_benchmark31.dat') as inf:
+            for line in inf:
+                if i in lines_analytics:
+                    parts = line.split()
+                    ref_data1.append(float(parts[1]))
+                    ref_data2.append(float(parts[2]))
+                    ref_data3.append(float(parts[3]))
+                i+=1
+        i = 0
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data1.append(float(parts[1]))
+                    DEM_data2.append(float(parts[2]))
+                    DEM_data3.append(float(parts[3]))
+                i+=1
+        final_local_angular_velocity_x_error = 0
+        final_local_angular_velocity_y_error = 0
+        final_local_angular_velocity_z_error = 0
+
+        for j in ref_data1:
+            summation_of_ref_data1+=abs(j)
+        for k in ref_data2:
+            summation_of_ref_data2+=abs(k)
+        for l in ref_data3:
+            summation_of_ref_data3+=abs(l)
+
+        for i, j in zip(DEM_data1, ref_data1):
+            final_local_angular_velocity_x_error+=abs(i-j)
+        final_local_angular_velocity_x_error/=summation_of_ref_data1
+
+        for k, l in zip(DEM_data2, ref_data2):
+            final_local_angular_velocity_y_error+=abs(k-l)
+        final_local_angular_velocity_y_error/=summation_of_ref_data2
+
+        for m, n in zip(DEM_data3, ref_data3):
+            final_local_angular_velocity_z_error+=abs(m-n)
+        final_local_angular_velocity_z_error/=summation_of_ref_data3
+
+        Logger.PrintInfo("Error in local angular velocity X =", 100*final_local_angular_velocity_x_error,"%")
+
+        Logger.PrintInfo("Error in local angular velocity Y =", 100*final_local_angular_velocity_y_error,"%")
+
+        Logger.PrintInfo("Error in local angular velocity Z =", 100*final_local_angular_velocity_z_error,"%")
+
+        error1 = 100*final_local_angular_velocity_x_error
+
+        error2 = 100*final_local_angular_velocity_y_error
+
+        error3 = 100*final_local_angular_velocity_z_error
+
+        delete_current_benchmark_data()
+
+        return error1, error2, error3
+
+class Benchmark32: ########## Fiber cluster bouncing without any damping (Velocity Verlet + Zhao scheme)
+
+    def __init__(self):
+        self.number = 32
+
+        self.cluster_graph_counter = 1   # deberia ser self.cluster_graph_counter = self.graph_frequency
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        self.velocity_list_outfile_name = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.simulation_graph = open(self.velocity_list_outfile_name, 'w')
+
+    def get_final_data(self, spheres_model_part, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
+
+        self.simulation_graph.close()
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def generate_graph_points(self, spheres_model_part, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
+
+        self.graph_frequency        = int(graph_print_interval/dt)
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
+
+        if(self.cluster_graph_counter == self.graph_frequency):     #if(self.cluster_graph_counter == self.graph_frequency):
+            self.cluster_graph_counter = 0
+            total_velocity_z         = 0.0
+            total_angular_velocity_y = 0.0
+
+            for node in cluster_model_part.Nodes:
+                current_velocity_z = node.GetSolutionStepValue(VELOCITY_Z)
+                total_velocity_z += current_velocity_z
+                current_angular_velocity_y = node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)
+                total_angular_velocity_y += current_angular_velocity_y
+
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_velocity_z).rjust(13)+" "+str("%.6g"%total_angular_velocity_y).rjust(13)+"\n")
+        self.cluster_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
+
+        error1, error2 = self.compute_errors(self.velocity_list_outfile_name)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2)
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+        error_file.write("DEM Benchmark 32:")
+
+        if (error1 < 0.01 and error2 < 0.01):
+            error_file.write(" OK!........ Test 32 SUCCESSFUL\n")
+        else:
+            error_file.write(" KO!........ Test 32 FAILED\n")
+        error_file.close()
+
+    def compute_errors(self, output_filename):  #FINALIZATION STEP
+
+        lines_analytics = lines_DEM = list(range(0, 100))
+        ref_data1 = []; ref_data2 = []; DEM_data1 = []; DEM_data1 = []; DEM_data2 = []; summation_of_ref_data1 = 0; summation_of_ref_data2 = 0
+        i = 0
+        with open('paper_data/benchmark' + str(sys.argv[1]) + '_graph.dat') as inf:  #with open('paper_data/reference_graph_benchmark32.dat') as inf:
+            for line in inf:
+                if i in lines_analytics:
+                    parts = line.split()
+                    ref_data1.append(float(parts[1]))
+                    ref_data2.append(float(parts[2]))
+                i+=1
+        i = 0
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data1.append(float(parts[1]))
+                    DEM_data2.append(float(parts[2]))
+                i+=1
+        final_velocity_z_error         = 0
+        final_angular_velocity_y_error = 0
+
+        for j in ref_data1:
+            summation_of_ref_data1+=abs(j)
+        for k in ref_data2:
+            summation_of_ref_data2+=abs(k)
+
+        for i, j in zip(DEM_data1, ref_data1):
+            final_velocity_z_error+=abs(i-j)
+        final_velocity_z_error/=summation_of_ref_data1
+
+        for k, l in zip(DEM_data2, ref_data2):
+            final_angular_velocity_y_error+=abs(k-l)
+        final_angular_velocity_y_error/=summation_of_ref_data2
+
+        Logger.PrintInfo("Error in velocity Z =", 100*final_velocity_z_error,"%")
+
+        Logger.PrintInfo("Error in angular velocity Y =", 100*final_angular_velocity_y_error,"%")
+
+        error1 = 100*final_velocity_z_error
+
+        error2 = 100*final_angular_velocity_y_error
+
+        delete_current_benchmark_data()
+
+        return error1, error2
+
+class Benchmark33: ########## Fiber cluster bouncing without any damping (Velocity Verlet + Runge-Kutta scheme)
+
+    def __init__(self):
+        self.number = 33
+
+        self.cluster_graph_counter = 1   # deberia ser self.cluster_graph_counter = self.graph_frequency
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration=0):
+
+        self.velocity_list_outfile_name = "benchmark" + str(sys.argv[1]) + '_graph.dat'
+        self.simulation_graph = open(self.velocity_list_outfile_name, 'w')
+
+    def get_final_data(self, spheres_model_part, rigid_face_model_part, cluster_model_part):                 #FINALIZATION STEP
+
+        self.simulation_graph.close()
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def generate_graph_points(self, spheres_model_part, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):     #MAIN LOOP STEP
+
+        self.graph_frequency        = int(graph_print_interval/dt)
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1 #that means it is not possible to print results with a higher frequency than the computations delta time
+
+        if(self.cluster_graph_counter == self.graph_frequency):     #if(self.cluster_graph_counter == self.graph_frequency):
+            self.cluster_graph_counter = 0
+            total_velocity_z         = 0.0
+            total_angular_velocity_y = 0.0
+
+            for node in cluster_model_part.Nodes:
+                current_velocity_z = node.GetSolutionStepValue(VELOCITY_Z)
+                total_velocity_z += current_velocity_z
+                current_angular_velocity_y = node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)
+                total_angular_velocity_y += current_angular_velocity_y
+
+            self.simulation_graph.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%total_velocity_z).rjust(13)+" "+str("%.6g"%total_angular_velocity_y).rjust(13)+"\n")
+        self.cluster_graph_counter += 1
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):      #FINALIZATION STEP
+
+        error1, error2 = self.compute_errors(self.velocity_list_outfile_name)
+        error1, error2, error3, error4, error5 = ApplyErrorTolerance(error1, error2)
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+        error_file.write("DEM Benchmark 33:")
+
+        if (error1 < 0.01 and error2 < 0.01):
+            error_file.write(" OK!........ Test 33 SUCCESSFUL\n")
+        else:
+            error_file.write(" KO!........ Test 33 FAILED\n")
+        error_file.close()
+
+    def compute_errors(self, output_filename):  #FINALIZATION STEP
+
+        lines_analytics = lines_DEM = list(range(0, 100));
+        ref_data1 = []; ref_data2 = []; DEM_data1 = []; DEM_data1 = []; DEM_data2 = []; summation_of_ref_data1 = 0; summation_of_ref_data2 = 0
+        i = 0
+        with open('paper_data/benchmark' + str(sys.argv[1]) + '_graph.dat') as inf:  #with open('paper_data/reference_graph_benchmark33.dat') as inf:
+            for line in inf:
+                if i in lines_analytics:
+                    parts = line.split()
+                    ref_data1.append(float(parts[1]))
+                    ref_data2.append(float(parts[2]))
+                i+=1
+        i = 0
+        with open(output_filename) as inf:
+            extend_datafile_list(glob(output_filename))
+            for line in inf:
+                if i in lines_DEM:
+                    parts = line.split()
+                    DEM_data1.append(float(parts[1]))
+                    DEM_data2.append(float(parts[2]))
+                i+=1
+        final_velocity_z_error         = 0
+        final_angular_velocity_y_error = 0
+
+        for j in ref_data1:
+            summation_of_ref_data1+=abs(j)
+        for k in ref_data2:
+            summation_of_ref_data2+=abs(k)
+
+        for i, j in zip(DEM_data1, ref_data1):
+            final_velocity_z_error+=abs(i-j)
+        final_velocity_z_error/=summation_of_ref_data1
+
+        for k, l in zip(DEM_data2, ref_data2):
+            final_angular_velocity_y_error+=abs(k-l)
+        final_angular_velocity_y_error/=summation_of_ref_data2
+
+        Logger.PrintInfo("Error in velocity Z =", 100*final_velocity_z_error,"%")
+
+        Logger.PrintInfo("Error in angular velocity Y =", 100*final_angular_velocity_y_error,"%")
+
+        error1 = 100*final_velocity_z_error
+
+        error2 = 100*final_angular_velocity_y_error
+
+        delete_current_benchmark_data()
+
+        return error1, error2
+
+
+
+class Benchmark40: # multiple benchmarks for general code verification.
+
+    def __init__(self):
+        self.generated_data = None
+        self.balls_graph_counter = 1
+        self.rigid_graph_counter = 1
+
+        self.number_of_DEM_benchmarks = 15
+        self.number_of_FEM_benchmarks = 8
+
+    def ApplyNodalRotation(self, time, dt, modelpart):
+        pass
+
+    def set_initial_data(self, modelpart, rigid_face_model_part, iteration, number_of_points_in_the_graphic, coeff_of_restitution_iteration):
+        pass
+
+
+    def get_final_data(self, modelpart, rigid_face_model_part, cluster_model_part):
+        pass
+
+
+    def generate_graph_points(self, modelpart, rigid_face_model_part, cluster_model_part, time, graph_print_interval, dt):
+
+        #self.graph_frequency = int(5e-7/dt)   #graph_print_interval/dt
+        self.graph_frequency = int(graph_print_interval/dt)   #1 veces mas grf que bin
+        if self.graph_frequency < 1:
+           self.graph_frequency = 1
+
+        if (self.balls_graph_counter == self.graph_frequency):
+            self.balls_graph_counter = 0
+
+            for node in modelpart.Nodes:
+                if node.Id == 10:           ### stage 0 - simple dem
+
+                    force_node = GetVectorNorm(node, TOTAL_FORCES)
+                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
+                    displacement_node = GetNodeDisplacement(node)
+
+                    i=0
+                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+            for node in modelpart.Nodes:
+                if node.Id == 42:           ### stage 1
+
+                    force_node = GetVectorNorm(node, TOTAL_FORCES)
+                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
+                    displacement_node = GetNodeDisplacement(node)
+
+                    i=1
+                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+            for node in modelpart.Nodes:
+                if node.Id == 71:           ### stage 2
+
+                    force_node = GetVectorNorm(node, TOTAL_FORCES)
+                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
+                    displacement_node = GetNodeDisplacement(node)
+
+                    i=2
+                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+            for node in modelpart.Nodes:
+                if node.Id == 1354:           ### stage 3
+
+                    force_node = GetVectorNorm(node, TOTAL_FORCES)
+                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
+                    displacement_node = GetNodeDisplacement(node)
+
+                    i=3
+                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+
+            for node in modelpart.Nodes:
+                if node.Id == 1534:           ### stage 4 - particle injected by inlet
+
+                    force_node = GetVectorNorm(node, TOTAL_FORCES)
+                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
+                    displacement_node = GetNodeDisplacement(node)
+
+                    i=4
+                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+
+            for node in modelpart.Nodes:
+                if node.Id == 1416:           ### stage 5 - inlet movement
+
+                    force_node = GetVectorNorm(node, TOTAL_FORCES)
+                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
+                    displacement_node = GetNodeDisplacement(node)
+
+                    i=5
+                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+            for node in modelpart.Nodes:
+                if node.Id == 1337:           ### stage 6 - dem with initial velocity
+
+                    force_node = GetVectorNorm(node, TOTAL_FORCES)
+                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
+                    displacement_node = GetNodeDisplacement(node)
+
+                    i=6
+                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+
+            for node in modelpart.Nodes:
+                if node.Id == 663:           ### stage 7 - gravity on sphere of spheres
+
+                    force_node = GetVectorNorm(node, TOTAL_FORCES)
+                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
+                    displacement_node = GetNodeDisplacement(node)
+
+                    i=7
+                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+            for node in modelpart.Nodes:
+                if node.Id == 758:           ### stage 8 - dem with reduced degrees of freedom
+
+                    force_node = GetVectorNorm(node, TOTAL_FORCES)
+                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
+                    displacement_node = GetNodeDisplacement(node)
+
+                    i=8
+                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+            for node in modelpart.Nodes:
+                if node.Id == 789:           ### stage 9 - dem falling pink
+
+                    force_node = GetVectorNorm(node, TOTAL_FORCES)
+                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
+                    displacement_node = GetNodeDisplacement(node)
+
+                    i=9
+                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+            for node in modelpart.Nodes:
+                if node.Id == 913:           ### stage 10 - dem falling green fem
+
+                    force_node = GetVectorNorm(node, TOTAL_FORCES)
+                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
+                    displacement_node = GetNodeDisplacement(node)
+
+                    i=10
+                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+
+            for node in modelpart.Nodes:
+                if node.Id == 974:           ### stage 11 - dem falling  orange
+
+                    force_node = GetVectorNorm(node, TOTAL_FORCES)
+                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
+                    displacement_node = GetNodeDisplacement(node)
+
+                    i=11
+                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+            for node in modelpart.Nodes:
+                if node.Id == 1061:           ### stage 12 - dem imposed period
+
+                    force_node = GetVectorNorm(node, TOTAL_FORCES)
+                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
+                    displacement_node = GetNodeDisplacement(node)
+
+                    i=12
+                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+
+
+            for node in modelpart.Nodes:
+                if node.Id == 1180:           ### stage 13 - dem initial
+
+                    force_node = GetVectorNorm(node, TOTAL_FORCES)
+                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
+                    displacement_node = GetNodeDisplacement(node)
+
+                    i=13
+                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+
+            for node in modelpart.Nodes:
+                if node.Id == 1290:           ### stage 14 - dem contra fem rotatori force
+
+                    force_node = GetVectorNorm(node, TOTAL_FORCES)
+                    angular_node = GetVectorNorm(node, ANGULAR_VELOCITY)
+                    displacement_node = GetNodeDisplacement(node)
+
+                    i=14
+                    data  = open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%angular_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+        self.balls_graph_counter += 1
+
+
+        if (self.rigid_graph_counter == self.graph_frequency):
+            self.rigid_graph_counter = 0
+            for sub_part in rigid_face_model_part.SubModelParts:
+
+                if sub_part.Name == '0':
+
+                    name = int(sub_part.Name)
+                    mesh_nodes = sub_part.GetMesh(0).Nodes
+                    force_node = 0.0
+
+                    for node in mesh_nodes:
+                        force_node += GetVectorNorm(node, ELASTIC_FORCES)
+                        displacement_node += GetNodeDisplacement(node)
+
+                    i=name  # beware
+                    data  = open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+                if sub_part.Name == '1':
+
+                    name = int(sub_part.Name)
+                    mesh_nodes = sub_part.GetMesh(0).Nodes
+                    force_node = 0.0
+
+                    for node in mesh_nodes:
+
+                        force_node += GetVectorNorm(node, ELASTIC_FORCES)
+                        displacement_node += GetNodeDisplacement(node)
+
+                    i=name
+                    data  = open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+
+                if sub_part.Name == '2':
+
+                    name = int(sub_part.Name)
+                    mesh_nodes = sub_part.GetMesh(0).Nodes
+                    force_node = 0.0
+
+                    for node in mesh_nodes:
+                        force_node += GetVectorNorm(node, ELASTIC_FORCES)
+                        displacement_node += GetNodeDisplacement(node)
+
+                    i=name
+                    data  = open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+
+                if sub_part.Name == '3':
+
+                    name = int(sub_part.Name)
+                    mesh_nodes = sub_part.GetMesh(0).Nodes
+                    force_node = 0.0
+
+                    for node in mesh_nodes:
+                        force_node += GetVectorNorm(node, ELASTIC_FORCES)
+                        displacement_node += GetNodeDisplacement(node)
+
+                    i=name
+                    data  = open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+
+                if sub_part.Name == '4':
+
+                    name = int(sub_part.Name)
+                    mesh_nodes = sub_part.GetMesh(0).Nodes
+                    force_node = 0.0
+
+                    for node in mesh_nodes:
+                        force_node += GetVectorNorm(node, ELASTIC_FORCES)
+                        displacement_node += GetNodeDisplacement(node)
+
+                    i=name
+                    data  = open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+
+                if sub_part.Name == '5':
+
+                    name = int(sub_part.Name)
+                    mesh_nodes = sub_part.GetMesh(0).Nodes
+                    force_node = 0.0
+
+                    for node in mesh_nodes:
+                        force_node += GetVectorNorm(node, ELASTIC_FORCES)
+                        displacement_node += GetNodeDisplacement(node)
+
+                    i=name
+                    data  = open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+
+                if sub_part.Name == '6':
+
+                    name = int(sub_part.Name)
+                    mesh_nodes = sub_part.GetMesh(0).Nodes
+                    force_node = 0.0
+
+                    for node in mesh_nodes:
+                        force_node += GetVectorNorm(node, ELASTIC_FORCES)
+                        displacement_node += GetNodeDisplacement(node)
+
+                    i=name
+                    data  = open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+
+                if sub_part.Name == '7':
+
+                    name = int(sub_part.Name)
+                    mesh_nodes = sub_part.GetMesh(0).Nodes
+                    force_node = 0.0
+
+                    for node in mesh_nodes:
+                        force_node += GetVectorNorm(node, ELASTIC_FORCES)
+                        displacement_node += GetNodeDisplacement(node)
+
+                    i=name
+                    data  = open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % i, 'a')
+                    data.write(str("%.8g"%time).rjust(12)+" "+str("%.6g"%force_node).rjust(13)+" "+str("%.6g"%displacement_node).rjust(13)+"\n")
+                    data.flush()
+
+        self.rigid_graph_counter += 1
+
+
+
+    def print_results(self, number_of_points_in_the_graphic, dt=0, elapsed_time=0.0):
+
+        error1, error2, error3 = self.compute_errors()     # TOTAL_FORCES, ANGULAR_VELOCITY, NODE DISPLACEMENT FROM INITIAL POS
+        error4, error5 = self.compute_rigid_errors()       # TOTAL_FORCES, AVG DISPLACEMENT FROM INITIAL POS
+
+        error_filename = 'errors.err'
+        error_file = open(error_filename, 'a')
+
+        for index in range(self.number_of_DEM_benchmarks):
+            error_file.write("DEM Benchmark 40:")
+            if (error1[index] < 0.05 and error2[index] < 0.05 and error3[index] < 0.05):
+                error_file.write(" OK!........ Test 40_%s SUCCESSFUL (spheres)\n" % index)
+                #shutil.rmtree('benchmark40_Post_Files', ignore_errors = True)
+            else:
+                error_file.write(" KO!........ Test 40_%s FAILED (spheres)\n" % index)
+
+
+        for index in range(self.number_of_FEM_benchmarks):
+            error_file.write("DEM Benchmark 40:")
+            if (error4[index] < 0.05 and error5[index] < 0.05):
+                error_file.write(" OK!........ Test 40_%s SUCCESSFUL (finite elements)\n" % index)
+            else:
+                error_file.write(" KO!........ Test 40_%s FAILED (finite elements)\n" % index)
+
+        error_file.close()
+
+    def compute_errors(self):
+        error1 = []
+        error2 = []
+        error3 = []
+
+        for index in range(self.number_of_DEM_benchmarks):
+            reference_data = lines_DEM = list(range(0, 1000))
+            analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
+            i = 0
+            with open('paper_data/reference_graph_benchmark' + '40_%s' % index + '.dat') as reference:
+                for line in reference:
+                    if i in reference_data:
+                        parts = line.split()
+                        analytics_data.append(float(parts[1]))      # ref TOTAL_FORCES
+                    i+=1
+            i = 0
+            with open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % index) as current_data:
+                extend_datafile_list(glob("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % index))
+
+                for line in current_data:
+                    if i in lines_DEM:
+                        parts = line.split()
+                        DEM_data.append(float(parts[1]))            # TOTAL_FORCES
+                    i+=1
+            dem_error1 = 0.0
+
+            for j in analytics_data:
+                summation_of_analytics_data+=abs(j)
+
+            for i, j in zip(DEM_data, analytics_data):
+                dem_error1+=abs(i-j)                               # (test_data[0]-reference_data[0]) + ...
+            dem_error1/=summation_of_analytics_data                 # relative error of the above against sum of reference data
+
+            if dem_error1>0.05:
+                Logger.PrintInfo("Error in total force at the reference particle =", 100*dem_error1,"%"+" at index: ",index)
+
+            i = 0
+            with open('paper_data/reference_graph_benchmark' +  '40_%s' % index + '.dat') as reference:
+                for line in reference:
+                    if i in reference_data:
+                        parts = line.split()
+                        analytics_data.append(float(parts[2]))      # ref ANGULAR_VELOCITY
+                    i+=1
+            i = 0
+            with open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % index) as current_data:
+                for line in current_data:
+                    if i in lines_DEM:
+                        parts = line.split()
+                        DEM_data.append(float(parts[2]))            # ANGULAR_VELOCITY
+                    i+=1
+            dem_error2 = 0.0
+
+            for j in analytics_data:
+                summation_of_analytics_data+=abs(j)
+
+            for i, j in zip(DEM_data, analytics_data):
+                dem_error2+=abs(i-j)                               # (test_data[0]-reference_data[0]) + ...
+            dem_error2/=summation_of_analytics_data                 # relative error of the above against sum of reference data
+
+            if dem_error2>0.05:
+              Logger.PrintInfo("Error in angular velocity at the reference particle =", 100*dem_error2,"%"+" at index: ",index)
+
+
+            i = 0
+            with open('paper_data/reference_graph_benchmark' + '40_%s' % index + '.dat') as reference:
+                for line in reference:
+                    if i in reference_data:
+                        parts = line.split()
+                        analytics_data.append(float(parts[3]))      # ref displacement from initial pos
+                    i+=1
+            i = 0
+            with open("benchmark" + str(sys.argv[1]) + "_graph%s.dat" % index) as current_data:
+                for line in current_data:
+                    if i in lines_DEM:
+                        parts = line.split()
+                        DEM_data.append(float(parts[3]))            # displacement from initial pos
+                    i+=1
+            dem_error3 = 0.0
+
+            for j in analytics_data:
+                summation_of_analytics_data+=abs(j)
+
+            for i, j in zip(DEM_data, analytics_data):
+                dem_error3+=abs(i-j)
+            dem_error3/=summation_of_analytics_data
+
+            if dem_error3>0.05:
+                Logger.PrintInfo("Error in delta displacement at the reference particle =", 100*dem_error3,"%"+" at index: ",index)
+
+            error1.append(dem_error1)
+            error2.append(dem_error2)
+            error3.append(dem_error3)
+
+        delete_current_benchmark_data()
+        return error1, error2, error3
+
+
+    def compute_rigid_errors(self):
+        error4 = []
+        error5 = []
+
+        for index in range(self.number_of_FEM_benchmarks):
+            reference_data = lines_DEM = list(range(0, 1000))
+            analytics_data = []; DEM_data = []; summation_of_analytics_data = 0
+            i = 0
+            with open('paper_data/reference_rigid_graph_benchmark' + '40_%s' % index + '.dat') as reference:
+                for line in reference:
+                    if i in reference_data:
+                        parts = line.split()
+                        analytics_data.append(float(parts[1]))      # REFERENCE TOTAL_FORCES
+                    i+=1
+            i = 0
+            with open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % index) as current_data:
+                extend_datafile_list(glob("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % index))
+                for line in current_data:
+                    if i in lines_DEM:
+                        parts = line.split()
+                        DEM_data.append(float(parts[1]))            # TOTAL_FORCES
+                    i+=1
+            fem_error1 = 0.0
+
+            for j in analytics_data:
+                summation_of_analytics_data+=abs(j)
+
+            for i, j in zip(DEM_data, analytics_data):
+                fem_error1+=abs(i-j)
+            if summation_of_analytics_data!=0.0:                     # (test_data[0]-reference_data[0]) + ...
+                fem_error1/=summation_of_analytics_data              # relative error of the above against sum of reference data
+
+            if fem_error1>0.05:
+                Logger.PrintInfo("Error in total force at the reference FEM subpart =", 100*fem_error1,"%"+" at stage: ",index)
+
+
+
+            i = 0
+            with open('paper_data/reference_rigid_graph_benchmark' + '40_%s' % index + '.dat') as reference:
+                for line in reference:
+                    if i in reference_data:
+                        parts = line.split()
+                        analytics_data.append(float(parts[2]))      # displacement from initial pos
+                    i+=1
+            i = 0
+            with open("benchmark" + str(sys.argv[1]) + "_rigid_graph%s.dat" % index) as current_data:
+                for line in current_data:
+                    if i in lines_DEM:
+                        parts = line.split()
+                        DEM_data.append(float(parts[2]))            # ref displacement from initial pos
+                    i+=1
+            fem_error2 = 0.0
+
+            for j in analytics_data:
+                summation_of_analytics_data+=abs(j)
+
+            for i, j in zip(DEM_data, analytics_data):
+                fem_error2+=abs(i-j)
+            fem_error2/=summation_of_analytics_data
+
+            if fem_error2>0.05:
+                Logger.PrintInfo("Error in delta displacement at the reference FEM subpart =", 100*fem_error2,"%"+" at stage: ",index)
+
+            error4.append(fem_error1)
+            error5.append(fem_error2)
+
+        delete_current_benchmark_data()
+        return error4, error5
+
+    def create_gnuplot_scripts(self, output_filename, dt):
+        pass
+
+def print_gnuplot_files_on_screen(gnuplot_script_name):
+    system('gnuplot -persist ' + gnuplot_script_name)
+
+def create_pdf_document(pdf_script_name):
+    system('gnuplot -persist ' + pdf_script_name)
```

## KratosMultiphysics/DEMApplication/ice_continuum_sphere_strategy.py

 * *Ordering differences only*

```diff
@@ -1,25 +1,25 @@
-from KratosMultiphysics import *
-from KratosMultiphysics.DEMApplication import *
-
-# Ice Continuum Strategy
-
-import KratosMultiphysics.DEMApplication.continuum_sphere_strategy as SolverStrategy
-
-BaseExplicitStrategy = SolverStrategy.ExplicitStrategy
-
-class ExplicitStrategy(BaseExplicitStrategy):
-
-    def __init__(self, all_model_parts, creator_destructor, dem_fem_search, DEM_parameters, procedures):
-
-        BaseExplicitStrategy.__init__(self, all_model_parts, creator_destructor, dem_fem_search, DEM_parameters, procedures)
-
-    def AddAdditionalVariables(self, spheres_model_part, DEM_parameters):
-
-        BaseExplicitStrategy.AddAdditionalVariables(self, spheres_model_part, DEM_parameters)
-
-        # Add the necessary variables for the ice_strategy here:
-        # spheres_model_part.AddNodalSolutionStepVariable(VARIABLE1)
-        # ...
-
-
-
+from KratosMultiphysics import *
+from KratosMultiphysics.DEMApplication import *
+
+# Ice Continuum Strategy
+
+import KratosMultiphysics.DEMApplication.continuum_sphere_strategy as SolverStrategy
+
+BaseExplicitStrategy = SolverStrategy.ExplicitStrategy
+
+class ExplicitStrategy(BaseExplicitStrategy):
+
+    def __init__(self, all_model_parts, creator_destructor, dem_fem_search, DEM_parameters, procedures):
+
+        BaseExplicitStrategy.__init__(self, all_model_parts, creator_destructor, dem_fem_search, DEM_parameters, procedures)
+
+    def AddAdditionalVariables(self, spheres_model_part, DEM_parameters):
+
+        BaseExplicitStrategy.AddAdditionalVariables(self, spheres_model_part, DEM_parameters)
+
+        # Add the necessary variables for the ice_strategy here:
+        # spheres_model_part.AddNodalSolutionStepVariable(VARIABLE1)
+        # ...
+
+
+
```

## KratosMultiphysics/DEMApplication/plot_variables.py

 * *Ordering differences only*

```diff
@@ -1,129 +1,129 @@
-# importing the Kratos Library
-from KratosMultiphysics import *
-from KratosMultiphysics.DEMApplication import *
-from glob import glob
-import os, shutil
-
-class variable_plotter:
-
-    def __init__(self, model_part, list_of_nodes_ids):
-
-        self.list_of_nodes = []
-        self.files = []
-        self.model_part = model_part
-        for node in model_part.Nodes:
-            for id in list_of_nodes_ids:
-                if node.Id == id:
-                    self.list_of_nodes.append(node)
-                    file_writer = open("variables_for_node_" + str(id) + ".dat", 'w');
-                    file_writer.write("#Time  DISPLACEMENT_X  DISPLACEMENT_Y  DISPLACEMENT_Z  ")
-                    file_writer.write("ELASTIC_FORCES_X  ELASTIC_FORCES_Y  ELASTIC_FORCES_Z  ")
-                    file_writer.write("TOTAL_FORCES_X  TOTAL_FORCES_Y  TOTAL_FORCES_Z  ")
-                    file_writer.write("VELOCITY_X  VELOCITY_Y  VELOCITY_Z  ")
-                    file_writer.write("ANGULAR_VELOCITY_X  ANGULAR_VELOCITY_Y  ANGULAR_VELOCITY_Z  ")
-                    file_writer.write("PARTICLE_MOMENT_X  PARTICLE_MOMENT_Y  PARTICLE_MOMENT_Z\n")
-                    self.files.append(file_writer)
-                    break
-
-        if len(self.list_of_nodes) != len(list_of_nodes_ids):
-            print("Some nodal ids could not be found in the model part! Stopping")
-
-        self.plot_variables(0.0)
-
-    def plot_variables(self, time):
-
-        i = 0
-
-        for file_writer in self.files:
-            node = self.list_of_nodes[i]
-            string = str(time) \
-            + "  " + str(node.GetSolutionStepValue(DISPLACEMENT_X)) \
-            + "  " + str(node.GetSolutionStepValue(DISPLACEMENT_Y)) \
-            + "  " + str(node.GetSolutionStepValue(DISPLACEMENT_Z)) \
-            + "  " + str(node.GetSolutionStepValue(ELASTIC_FORCES_X)) \
-            + "  " + str(node.GetSolutionStepValue(ELASTIC_FORCES_Y)) \
-            + "  " + str(node.GetSolutionStepValue(ELASTIC_FORCES_Z)) \
-            + "  " + str(node.GetSolutionStepValue(TOTAL_FORCES_X)) \
-            + "  " + str(node.GetSolutionStepValue(TOTAL_FORCES_Y)) \
-            + "  " + str(node.GetSolutionStepValue(TOTAL_FORCES_Z)) \
-            + "  " + str(node.GetSolutionStepValue(VELOCITY_X)) \
-            + "  " + str(node.GetSolutionStepValue(VELOCITY_Y)) \
-            + "  " + str(node.GetSolutionStepValue(VELOCITY_Z)) \
-            + "  " + str(node.GetSolutionStepValue(ANGULAR_VELOCITY_X)) \
-            + "  " + str(node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)) \
-            + "  " + str(node.GetSolutionStepValue(ANGULAR_VELOCITY_Z)) \
-            + "  " + str(node.GetSolutionStepValue(PARTICLE_MOMENT)[0]) \
-            + "  " + str(node.GetSolutionStepValue(PARTICLE_MOMENT)[1]) \
-            + "  " + str(node.GetSolutionStepValue(PARTICLE_MOMENT)[2]) \
-            + '\n'
-            file_writer.write(string)
-            i = i + 1
-
-    def close_files(self):
-
-        for file_writer in self.files:
-            file_writer.close()
-
-class tangential_force_plotter:
-
-    def __init__(self, model_part, list_of_nodes_ids, iteration = 0):
-
-        self.list_of_nodes = []
-        self.files = []
-        self.model_part = model_part
-
-        for node in model_part.Nodes:
-            for id in list_of_nodes_ids:
-                if node.Id == id:
-                    self.list_of_nodes.append(node)
-                    file_writer = open("variables_for_node_" + str(id) + "_iter_" + str(iteration) + ".dat", 'w');
-                    file_writer.write("#Time  TOTAL_FORCES_Y  TOTAL_FORCES_Z  ANGULAR_VELOCITY_X\n")
-                    self.files.append(file_writer)
-                    print("The Id " + str(id) + " was found in the model part")
-                    break
-
-        if len(self.list_of_nodes) != len(list_of_nodes_ids):
-            print("Some nodal ids could not be found in the model part! Stopping")
-
-        self.plot_tangential_force(0.0)
-
-    def plot_tangential_force(self, time):
-
-        i = 0
-
-        for file_writer in self.files:
-            node = self.list_of_nodes[i]
-            string = str(time) \
-            + "  " + str(node.GetSolutionStepValue(TOTAL_FORCES_Y)) \
-            + "  " + str(node.GetSolutionStepValue(TOTAL_FORCES_Z)) \
-            + "  " + str(node.GetSolutionStepValue(ANGULAR_VELOCITY_X)) \
-            + '\n'
-            file_writer.write(string)
-            i = i + 1
-
-    def close_files(self):
-
-        for file_writer in self.files:
-            file_writer.close()
-
-def delete_archives():
-
-    #.......................Removing results' files
-    files_to_delete_list = glob('*.time')
-    files_to_delete_list.extend(glob('*.lst'))
-    files_to_delete_list.extend(glob('*.txt'))
-    files_to_delete_list.extend(glob('*.gp'))
-    #files_to_delete_list.extend(glob('*.dat'))
-
-    for to_erase_file in files_to_delete_list:
-        os.remove(to_erase_file)
-
-    #............Getting rid of folders
-    folders_to_delete_list      = glob('*and_Data')
-    folders_to_delete_list.extend(glob('*ists'))
-    folders_to_delete_list.extend(glob('*ults'))
-    folders_to_delete_list.extend(glob('*aphs'))
-    folders_to_delete_list.extend(glob('*iles'))
-
-    for to_erase_folder in folders_to_delete_list:
-        shutil.rmtree(to_erase_folder)
+# importing the Kratos Library
+from KratosMultiphysics import *
+from KratosMultiphysics.DEMApplication import *
+from glob import glob
+import os, shutil
+
+class variable_plotter:
+
+    def __init__(self, model_part, list_of_nodes_ids):
+
+        self.list_of_nodes = []
+        self.files = []
+        self.model_part = model_part
+        for node in model_part.Nodes:
+            for id in list_of_nodes_ids:
+                if node.Id == id:
+                    self.list_of_nodes.append(node)
+                    file_writer = open("variables_for_node_" + str(id) + ".dat", 'w');
+                    file_writer.write("#Time  DISPLACEMENT_X  DISPLACEMENT_Y  DISPLACEMENT_Z  ")
+                    file_writer.write("ELASTIC_FORCES_X  ELASTIC_FORCES_Y  ELASTIC_FORCES_Z  ")
+                    file_writer.write("TOTAL_FORCES_X  TOTAL_FORCES_Y  TOTAL_FORCES_Z  ")
+                    file_writer.write("VELOCITY_X  VELOCITY_Y  VELOCITY_Z  ")
+                    file_writer.write("ANGULAR_VELOCITY_X  ANGULAR_VELOCITY_Y  ANGULAR_VELOCITY_Z  ")
+                    file_writer.write("PARTICLE_MOMENT_X  PARTICLE_MOMENT_Y  PARTICLE_MOMENT_Z\n")
+                    self.files.append(file_writer)
+                    break
+
+        if len(self.list_of_nodes) != len(list_of_nodes_ids):
+            print("Some nodal ids could not be found in the model part! Stopping")
+
+        self.plot_variables(0.0)
+
+    def plot_variables(self, time):
+
+        i = 0
+
+        for file_writer in self.files:
+            node = self.list_of_nodes[i]
+            string = str(time) \
+            + "  " + str(node.GetSolutionStepValue(DISPLACEMENT_X)) \
+            + "  " + str(node.GetSolutionStepValue(DISPLACEMENT_Y)) \
+            + "  " + str(node.GetSolutionStepValue(DISPLACEMENT_Z)) \
+            + "  " + str(node.GetSolutionStepValue(ELASTIC_FORCES_X)) \
+            + "  " + str(node.GetSolutionStepValue(ELASTIC_FORCES_Y)) \
+            + "  " + str(node.GetSolutionStepValue(ELASTIC_FORCES_Z)) \
+            + "  " + str(node.GetSolutionStepValue(TOTAL_FORCES_X)) \
+            + "  " + str(node.GetSolutionStepValue(TOTAL_FORCES_Y)) \
+            + "  " + str(node.GetSolutionStepValue(TOTAL_FORCES_Z)) \
+            + "  " + str(node.GetSolutionStepValue(VELOCITY_X)) \
+            + "  " + str(node.GetSolutionStepValue(VELOCITY_Y)) \
+            + "  " + str(node.GetSolutionStepValue(VELOCITY_Z)) \
+            + "  " + str(node.GetSolutionStepValue(ANGULAR_VELOCITY_X)) \
+            + "  " + str(node.GetSolutionStepValue(ANGULAR_VELOCITY_Y)) \
+            + "  " + str(node.GetSolutionStepValue(ANGULAR_VELOCITY_Z)) \
+            + "  " + str(node.GetSolutionStepValue(PARTICLE_MOMENT)[0]) \
+            + "  " + str(node.GetSolutionStepValue(PARTICLE_MOMENT)[1]) \
+            + "  " + str(node.GetSolutionStepValue(PARTICLE_MOMENT)[2]) \
+            + '\n'
+            file_writer.write(string)
+            i = i + 1
+
+    def close_files(self):
+
+        for file_writer in self.files:
+            file_writer.close()
+
+class tangential_force_plotter:
+
+    def __init__(self, model_part, list_of_nodes_ids, iteration = 0):
+
+        self.list_of_nodes = []
+        self.files = []
+        self.model_part = model_part
+
+        for node in model_part.Nodes:
+            for id in list_of_nodes_ids:
+                if node.Id == id:
+                    self.list_of_nodes.append(node)
+                    file_writer = open("variables_for_node_" + str(id) + "_iter_" + str(iteration) + ".dat", 'w');
+                    file_writer.write("#Time  TOTAL_FORCES_Y  TOTAL_FORCES_Z  ANGULAR_VELOCITY_X\n")
+                    self.files.append(file_writer)
+                    print("The Id " + str(id) + " was found in the model part")
+                    break
+
+        if len(self.list_of_nodes) != len(list_of_nodes_ids):
+            print("Some nodal ids could not be found in the model part! Stopping")
+
+        self.plot_tangential_force(0.0)
+
+    def plot_tangential_force(self, time):
+
+        i = 0
+
+        for file_writer in self.files:
+            node = self.list_of_nodes[i]
+            string = str(time) \
+            + "  " + str(node.GetSolutionStepValue(TOTAL_FORCES_Y)) \
+            + "  " + str(node.GetSolutionStepValue(TOTAL_FORCES_Z)) \
+            + "  " + str(node.GetSolutionStepValue(ANGULAR_VELOCITY_X)) \
+            + '\n'
+            file_writer.write(string)
+            i = i + 1
+
+    def close_files(self):
+
+        for file_writer in self.files:
+            file_writer.close()
+
+def delete_archives():
+
+    #.......................Removing results' files
+    files_to_delete_list = glob('*.time')
+    files_to_delete_list.extend(glob('*.lst'))
+    files_to_delete_list.extend(glob('*.txt'))
+    files_to_delete_list.extend(glob('*.gp'))
+    #files_to_delete_list.extend(glob('*.dat'))
+
+    for to_erase_file in files_to_delete_list:
+        os.remove(to_erase_file)
+
+    #............Getting rid of folders
+    folders_to_delete_list      = glob('*and_Data')
+    folders_to_delete_list.extend(glob('*ists'))
+    folders_to_delete_list.extend(glob('*ults'))
+    folders_to_delete_list.extend(glob('*aphs'))
+    folders_to_delete_list.extend(glob('*iles'))
+
+    for to_erase_folder in folders_to_delete_list:
+        shutil.rmtree(to_erase_folder)
```

## KratosMultiphysics/DEMApplication/time_step_testing_stage.py

 * *Ordering differences only*

```diff
@@ -1,283 +1,283 @@
-import KratosMultiphysics
-from KratosMultiphysics.DEMApplication import *
-import KratosMultiphysics.DEMApplication.DEM_analysis_stage as DEM_analysis_stage
-
-
-class TimeStepTester():
-    def __init__(self):
-        #self.schemes_list = ["Forward_Euler", "Taylor_Scheme", "Symplectic_Euler", "Velocity_Verlet"]
-        self.schemes_list = ["Symplectic_Euler", "Velocity_Verlet"]
-        self.stable_time_steps_list = []
-
-    def Run(self):
-
-        for scheme in self.schemes_list:
-            self.RunForACertainScheme(scheme)
-
-        self.Finalize()
-
-    def RunForACertainScheme(self, scheme):
-        print("Computing stable time step for scheme: "+ scheme)
-        tolerance = 1e-7
-        dt = 1e-2
-        previous_dt = 0.0
-        while dt > previous_dt + tolerance:
-            try:
-                self.RunTestCaseWithCustomizedDtAndScheme(dt, scheme)
-            except SystemExit:
-                factor = min(0.5, 0.5*(dt-previous_dt))
-                dt = factor * dt
-                print("decreasing dt by " + str(factor))
-                continue
-
-            previous_dt = dt
-            dt = dt * 1.5
-            print("increasing dt by 1.5")
-
-        self.stable_time_steps_list.append(previous_dt)
-
-    def RunTestCaseWithCustomizedDtAndScheme(self, dt, scheme):
-        model = KratosMultiphysics.Model()
-        CustomizedSolutionForTimeStepTesting(model, dt, scheme).Run()
-
-    def Finalize(self):
-
-        print("\n")
-        print("#############################")
-        print("List of tested schemes:")
-        print(self.schemes_list)
-        print("List of stable time steps:")
-        print(self.stable_time_steps_list)
-        print("#############################")
-        print("\n")
-
-
-class CustomizedSolutionForTimeStepTesting(DEM_analysis_stage.DEMAnalysisStage):
-
-    def __init__(self, model, dt, scheme):
-        self.customized_time_step = dt
-        self.customized_scheme = scheme
-        self.LoadParametersFile()
-        # with open("ProjectParametersDEM.json",'r') as parameter_file:
-        #     project_parameters = KratosMultiphysics.Parameters(parameter_file.read())
-        super().__init__(model, self.project_parameters)
-
-    def LoadParametersFile(self):
-        self.project_parameters = KratosMultiphysics.Parameters(
-            """
-            {
-                "Dimension"                        : 3,
-                "BoundingBoxOption"                : true,
-                "BoundingBoxEnlargementFactor"     : 1.1,
-                "AutomaticBoundingBoxOption"       : false,
-                "BoundingBoxEnlargementFactor"     : 1.0,
-                "BoundingBoxMaxX"                  : 1e3,
-                "BoundingBoxMaxY"                  : 1e3,
-                "BoundingBoxMaxZ"                  : 1e3,
-                "BoundingBoxMinX"                  : -1e3,
-                "BoundingBoxMinY"                  : -1e3,
-                "BoundingBoxMinZ"                  : -1e3,
-                "dem_inlet_option"                 : false,
-                "GravityX"                         : 0.0,
-                "GravityY"                         : 0.0,
-                "GravityZ"                         : 0.0,
-                "VelocityTrapOption"               : false,
-                "RotationOption"                   : true,
-                "CleanIndentationsOption"          : true,
-                "RemoveBallsInEmbeddedOption"      : false,
-                "solver_settings" :{
-                    "strategy"                 : "sphere_strategy",
-                    "RemoveBallsInitiallyTouchingWalls": false,
-                    "material_import_settings"           : {
-                        "materials_filename" : "MaterialsDEM.json"
-                    }
-                },
-
-                "DeltaOption"                      : "Absolute",
-                "SearchTolerance"                  : 0.0,
-                "CoordinationNumber"               : 10,
-                "AmplifiedSearchRadiusExtension"   : 1.10000e+00,
-                "ModelDataInfo"                    : false,
-                "VirtualMassCoefficient"           : 1.0,
-                "RollingFrictionOption"            : false,
-                "DontSearchUntilFailure"           : false,
-                "ContactMeshOption"                : false,
-                "OutputFileType"                   : "Binary",
-                "Multifile"                        : "multiple_files",
-                "TranslationalIntegrationScheme"   : "Forward_Euler",
-                "RotationalIntegrationScheme"      : "Direct_Integration",
-                "AutomaticTimestep"                : false,
-                "DeltaTimeSafetyFactor"            : 1.0,
-                "MaxTimeStep"                      : 1e-4,
-                "FinalTime"                        : 4.0,
-                "ControlTime"                      : 100,
-                "NeighbourSearchFrequency"         : 1,
-                "PeriodicDomainOption"             : false,
-                "ElementType"                      : "SphericPartDEMElement3D",
-
-                "GraphExportFreq"                  : 1e-5,
-                "VelTrapGraphExportFreq"           : 1e-3,
-                "OutputTimeStep"                   : 1e-5,
-                "PostDisplacement"                 : false,
-                "PostVelocity"                     : false,
-                "PostElasticForces"                : false,
-                "PostContactForces"                : false,
-                "PostRigidElementForces"           : false,
-                "PostTangentialElasticForces"      : false,
-                "PostPressure"                     : false,
-                "PostTotalForces"                  : false,
-                "PostShearStress"                  : false,
-                "PostNonDimensionalVolumeWear"     : false,
-                "PostNodalArea"                    : false,
-                "PostRHS"                          : false,
-                "PostDampForces"                   : false,
-                "PostAppliedForces"                : false,
-                "PostRadius"                       : false,
-                "PostGroupId"                      : false,
-                "PostExportId"                     : false,
-                "PostAngularVelocity"              : false,
-                "PostParticleMoment"               : false,
-                "PostEulerAngles"                  : false,
-                "PostContactSigma"                 : false,
-                "PostContactTau"                   : false,
-                "PostLocalContactForce"            : false,
-                "PostFailureCriterionState"        : false,
-                "PostContactFailureId"             : false,
-                "PostMeanContactArea"              : false,
-                "PostStressStrainOption"           : false,
-                "PostRollingResistanceMoment"      : false,
-                "post_vtk_option"                  : false,
-                "problem_name"                     : "TimeStepTests"
-                }
-
-            """
-            )
-
-
-
-    def SetDt(self):
-        self.DEM_parameters["TranslationalIntegrationScheme"].SetString(self.customized_scheme)
-        self.DEM_parameters["MaxTimeStep"].SetDouble(self.customized_time_step)
-        default_input_parameters = self.GetDefaultInputParameters()
-        self.DEM_parameters.ValidateAndAssignDefaults(default_input_parameters)
-
-        self._GetSolver().dt = self.DEM_parameters["MaxTimeStep"].GetDouble()
-
-
-    def ReadModelParts(self, max_node_Id=0, max_elem_Id=0, max_cond_Id=0):   # exists in DEM_analysis_stage
-        properties = KratosMultiphysics.Properties(0)
-        properties_walls = KratosMultiphysics.Properties(0)
-        self.SetHardcodedProperties(properties, properties_walls)
-        self.spheres_model_part.AddProperties(properties)
-        self.rigid_face_model_part.AddProperties(properties_walls)
-
-        DiscontinuumConstitutiveLawString = properties[DEM_DISCONTINUUM_CONSTITUTIVE_LAW_NAME]
-        DiscontinuumConstitutiveLaw = globals().get(DiscontinuumConstitutiveLawString)()
-        DiscontinuumConstitutiveLaw.SetConstitutiveLawInProperties(properties, False)
-
-        translational_scheme = ForwardEulerScheme()
-        translational_scheme.SetTranslationalIntegrationSchemeInProperties(properties, True)
-        rotational_scheme = ForwardEulerScheme()
-        rotational_scheme.SetRotationalIntegrationSchemeInProperties(properties, True)
-
-        element_name = "SphericParticle3D"
-        PropertiesProxiesManager().CreatePropertiesProxies(self.spheres_model_part)
-
-        coordinates = KratosMultiphysics.Array3()
-        coordinates[0] = 0.0
-        coordinates[1] = -0.1
-        coordinates[2] = 0.0
-        radius = 0.1
-        self.creator_destructor.CreateSphericParticle(self.spheres_model_part, coordinates, properties, radius, element_name)
-
-        coordinates[0] = 0.0
-        coordinates[1] = 0.2
-        coordinates[2] = 0.0
-        radius = 0.1
-        self.creator_destructor.CreateSphericParticle(self.spheres_model_part, coordinates, properties, radius, element_name)
-
-
-        for node in self.spheres_model_part.Nodes:
-            node.SetSolutionStepValue(KratosMultiphysics.VELOCITY_X, 10.0)
-            node.SetSolutionStepValue(KratosMultiphysics.VELOCITY_Y, 5.0)
-            node.SetSolutionStepValue(KratosMultiphysics.VELOCITY_Z, 0.0)
-
-        self.initial_test_energy = self.ComputeEnergy()
-        self.rigid_face_model_part.CreateNewNode(11, -0.5, -0.5, -0.5)
-        self.rigid_face_model_part.CreateNewNode(12, -0.5, -0.5, 0.5)
-
-        self.rigid_face_model_part.CreateNewNode(13, 0.5, -0.5, -0.5)
-        self.rigid_face_model_part.CreateNewNode(14, 0.5, -0.5, 0.5)
-
-
-        self.rigid_face_model_part.CreateNewNode(15, 0.5, 0.5, -0.5)
-        self.rigid_face_model_part.CreateNewNode(16, 0.5, 0.5, 0.5)
-
-        self.rigid_face_model_part.CreateNewNode(17, -0.5, 0.5, -0.5)
-        self.rigid_face_model_part.CreateNewNode(18, -0.5, 0.5, 0.5)
-
-        condition_name = "RigidFace3D3N"
-        self.rigid_face_model_part.CreateNewCondition(condition_name, 1, [11, 12, 13], self.rigid_face_model_part.GetProperties()[0])
-        self.rigid_face_model_part.CreateNewCondition(condition_name, 2, [12, 13, 14], self.rigid_face_model_part.GetProperties()[0])
-
-        self.rigid_face_model_part.CreateNewCondition(condition_name, 3, [13, 14, 15], self.rigid_face_model_part.GetProperties()[0])
-        self.rigid_face_model_part.CreateNewCondition(condition_name, 4, [14, 15, 16], self.rigid_face_model_part.GetProperties()[0])
-
-        self.rigid_face_model_part.CreateNewCondition(condition_name, 5, [15, 16, 17], self.rigid_face_model_part.GetProperties()[0])
-        self.rigid_face_model_part.CreateNewCondition(condition_name, 6, [16, 17, 18], self.rigid_face_model_part.GetProperties()[0])
-
-        self.rigid_face_model_part.CreateNewCondition(condition_name, 7, [17, 18, 11], self.rigid_face_model_part.GetProperties()[0])
-        self.rigid_face_model_part.CreateNewCondition(condition_name, 8, [18, 11, 12], self.rigid_face_model_part.GetProperties()[0])
-
-
-    def ComputeEnergy(self):
-        this_test_total_energy = 0.0
-
-        for element in self.spheres_model_part.Elements:
-            this_test_total_energy += element.Calculate(PARTICLE_TRANSLATIONAL_KINEMATIC_ENERGY, self.spheres_model_part.ProcessInfo)
-            this_test_total_energy += element.Calculate(PARTICLE_ROTATIONAL_KINEMATIC_ENERGY, self.spheres_model_part.ProcessInfo)
-            this_test_total_energy += element.Calculate(PARTICLE_ELASTIC_ENERGY, self.spheres_model_part.ProcessInfo)
-
-        return this_test_total_energy
-
-    def SetHardcodedProperties(self, properties, properties_walls):
-        properties[PARTICLE_DENSITY] = 2650.0
-        properties[KratosMultiphysics.YOUNG_MODULUS] = 7.0e6
-        properties[KratosMultiphysics.POISSON_RATIO] = 0.30
-        properties[STATIC_FRICTION] = 0.0
-        properties[DYNAMIC_FRICTION] = 0.0
-        properties[PARTICLE_COHESION] = 0.0
-        properties[COEFFICIENT_OF_RESTITUTION] = 1.0
-        properties[KratosMultiphysics.PARTICLE_MATERIAL] = 1
-        properties[ROLLING_FRICTION] = 0.0
-        properties[DEM_CONTINUUM_CONSTITUTIVE_LAW_NAME] = "DEMContinuumConstitutiveLaw"
-        properties[DEM_DISCONTINUUM_CONSTITUTIVE_LAW_NAME] = "DEM_D_Hertz_viscous_Coulomb"
-
-        properties_walls[STATIC_FRICTION] = 0.0
-        properties_walls[DYNAMIC_FRICTION] = 0.0
-        properties_walls[WALL_COHESION] = 0.0
-        properties_walls[COMPUTE_WEAR] = 0
-        properties_walls[SEVERITY_OF_WEAR] = 0.001
-        properties_walls[IMPACT_WEAR_SEVERITY] = 0.001
-        properties_walls[BRINELL_HARDNESS] = 200.0
-        properties_walls[KratosMultiphysics.YOUNG_MODULUS] = 7.0e10
-        properties_walls[KratosMultiphysics.POISSON_RATIO] = 0.30
-
-
-    def FinalizeSolutionStep(self):
-        super().FinalizeSolutionStep()
-
-        current_test_energy = self.ComputeEnergy()
-
-        if current_test_energy/self.initial_test_energy > 1.5:
-            print("GAINING ENERGY!!")
-            print("time step is:" + str(self.customized_time_step))
-            import sys
-            sys.exit()
-
-    def PrintResultsForGid(self, time):
-        pass
-
-
-if __name__ == '__main__':
-    TimeStepTester().Run()
+import KratosMultiphysics
+from KratosMultiphysics.DEMApplication import *
+import KratosMultiphysics.DEMApplication.DEM_analysis_stage as DEM_analysis_stage
+
+
+class TimeStepTester():
+    def __init__(self):
+        #self.schemes_list = ["Forward_Euler", "Taylor_Scheme", "Symplectic_Euler", "Velocity_Verlet"]
+        self.schemes_list = ["Symplectic_Euler", "Velocity_Verlet"]
+        self.stable_time_steps_list = []
+
+    def Run(self):
+
+        for scheme in self.schemes_list:
+            self.RunForACertainScheme(scheme)
+
+        self.Finalize()
+
+    def RunForACertainScheme(self, scheme):
+        print("Computing stable time step for scheme: "+ scheme)
+        tolerance = 1e-7
+        dt = 1e-2
+        previous_dt = 0.0
+        while dt > previous_dt + tolerance:
+            try:
+                self.RunTestCaseWithCustomizedDtAndScheme(dt, scheme)
+            except SystemExit:
+                factor = min(0.5, 0.5*(dt-previous_dt))
+                dt = factor * dt
+                print("decreasing dt by " + str(factor))
+                continue
+
+            previous_dt = dt
+            dt = dt * 1.5
+            print("increasing dt by 1.5")
+
+        self.stable_time_steps_list.append(previous_dt)
+
+    def RunTestCaseWithCustomizedDtAndScheme(self, dt, scheme):
+        model = KratosMultiphysics.Model()
+        CustomizedSolutionForTimeStepTesting(model, dt, scheme).Run()
+
+    def Finalize(self):
+
+        print("\n")
+        print("#############################")
+        print("List of tested schemes:")
+        print(self.schemes_list)
+        print("List of stable time steps:")
+        print(self.stable_time_steps_list)
+        print("#############################")
+        print("\n")
+
+
+class CustomizedSolutionForTimeStepTesting(DEM_analysis_stage.DEMAnalysisStage):
+
+    def __init__(self, model, dt, scheme):
+        self.customized_time_step = dt
+        self.customized_scheme = scheme
+        self.LoadParametersFile()
+        # with open("ProjectParametersDEM.json",'r') as parameter_file:
+        #     project_parameters = KratosMultiphysics.Parameters(parameter_file.read())
+        super().__init__(model, self.project_parameters)
+
+    def LoadParametersFile(self):
+        self.project_parameters = KratosMultiphysics.Parameters(
+            """
+            {
+                "Dimension"                        : 3,
+                "BoundingBoxOption"                : true,
+                "BoundingBoxEnlargementFactor"     : 1.1,
+                "AutomaticBoundingBoxOption"       : false,
+                "BoundingBoxEnlargementFactor"     : 1.0,
+                "BoundingBoxMaxX"                  : 1e3,
+                "BoundingBoxMaxY"                  : 1e3,
+                "BoundingBoxMaxZ"                  : 1e3,
+                "BoundingBoxMinX"                  : -1e3,
+                "BoundingBoxMinY"                  : -1e3,
+                "BoundingBoxMinZ"                  : -1e3,
+                "dem_inlet_option"                 : false,
+                "GravityX"                         : 0.0,
+                "GravityY"                         : 0.0,
+                "GravityZ"                         : 0.0,
+                "VelocityTrapOption"               : false,
+                "RotationOption"                   : true,
+                "CleanIndentationsOption"          : true,
+                "RemoveBallsInEmbeddedOption"      : false,
+                "solver_settings" :{
+                    "strategy"                 : "sphere_strategy",
+                    "RemoveBallsInitiallyTouchingWalls": false,
+                    "material_import_settings"           : {
+                        "materials_filename" : "MaterialsDEM.json"
+                    }
+                },
+
+                "DeltaOption"                      : "Absolute",
+                "SearchTolerance"                  : 0.0,
+                "CoordinationNumber"               : 10,
+                "AmplifiedSearchRadiusExtension"   : 1.10000e+00,
+                "ModelDataInfo"                    : false,
+                "VirtualMassCoefficient"           : 1.0,
+                "RollingFrictionOption"            : false,
+                "DontSearchUntilFailure"           : false,
+                "ContactMeshOption"                : false,
+                "OutputFileType"                   : "Binary",
+                "Multifile"                        : "multiple_files",
+                "TranslationalIntegrationScheme"   : "Forward_Euler",
+                "RotationalIntegrationScheme"      : "Direct_Integration",
+                "AutomaticTimestep"                : false,
+                "DeltaTimeSafetyFactor"            : 1.0,
+                "MaxTimeStep"                      : 1e-4,
+                "FinalTime"                        : 4.0,
+                "ControlTime"                      : 100,
+                "NeighbourSearchFrequency"         : 1,
+                "PeriodicDomainOption"             : false,
+                "ElementType"                      : "SphericPartDEMElement3D",
+
+                "GraphExportFreq"                  : 1e-5,
+                "VelTrapGraphExportFreq"           : 1e-3,
+                "OutputTimeStep"                   : 1e-5,
+                "PostDisplacement"                 : false,
+                "PostVelocity"                     : false,
+                "PostElasticForces"                : false,
+                "PostContactForces"                : false,
+                "PostRigidElementForces"           : false,
+                "PostTangentialElasticForces"      : false,
+                "PostPressure"                     : false,
+                "PostTotalForces"                  : false,
+                "PostShearStress"                  : false,
+                "PostNonDimensionalVolumeWear"     : false,
+                "PostNodalArea"                    : false,
+                "PostRHS"                          : false,
+                "PostDampForces"                   : false,
+                "PostAppliedForces"                : false,
+                "PostRadius"                       : false,
+                "PostGroupId"                      : false,
+                "PostExportId"                     : false,
+                "PostAngularVelocity"              : false,
+                "PostParticleMoment"               : false,
+                "PostEulerAngles"                  : false,
+                "PostContactSigma"                 : false,
+                "PostContactTau"                   : false,
+                "PostLocalContactForce"            : false,
+                "PostFailureCriterionState"        : false,
+                "PostContactFailureId"             : false,
+                "PostMeanContactArea"              : false,
+                "PostStressStrainOption"           : false,
+                "PostRollingResistanceMoment"      : false,
+                "post_vtk_option"                  : false,
+                "problem_name"                     : "TimeStepTests"
+                }
+
+            """
+            )
+
+
+
+    def SetDt(self):
+        self.DEM_parameters["TranslationalIntegrationScheme"].SetString(self.customized_scheme)
+        self.DEM_parameters["MaxTimeStep"].SetDouble(self.customized_time_step)
+        default_input_parameters = self.GetDefaultInputParameters()
+        self.DEM_parameters.ValidateAndAssignDefaults(default_input_parameters)
+
+        self._GetSolver().dt = self.DEM_parameters["MaxTimeStep"].GetDouble()
+
+
+    def ReadModelParts(self, max_node_Id=0, max_elem_Id=0, max_cond_Id=0):   # exists in DEM_analysis_stage
+        properties = KratosMultiphysics.Properties(0)
+        properties_walls = KratosMultiphysics.Properties(0)
+        self.SetHardcodedProperties(properties, properties_walls)
+        self.spheres_model_part.AddProperties(properties)
+        self.rigid_face_model_part.AddProperties(properties_walls)
+
+        DiscontinuumConstitutiveLawString = properties[DEM_DISCONTINUUM_CONSTITUTIVE_LAW_NAME]
+        DiscontinuumConstitutiveLaw = globals().get(DiscontinuumConstitutiveLawString)()
+        DiscontinuumConstitutiveLaw.SetConstitutiveLawInProperties(properties, False)
+
+        translational_scheme = ForwardEulerScheme()
+        translational_scheme.SetTranslationalIntegrationSchemeInProperties(properties, True)
+        rotational_scheme = ForwardEulerScheme()
+        rotational_scheme.SetRotationalIntegrationSchemeInProperties(properties, True)
+
+        element_name = "SphericParticle3D"
+        PropertiesProxiesManager().CreatePropertiesProxies(self.spheres_model_part)
+
+        coordinates = KratosMultiphysics.Array3()
+        coordinates[0] = 0.0
+        coordinates[1] = -0.1
+        coordinates[2] = 0.0
+        radius = 0.1
+        self.creator_destructor.CreateSphericParticle(self.spheres_model_part, coordinates, properties, radius, element_name)
+
+        coordinates[0] = 0.0
+        coordinates[1] = 0.2
+        coordinates[2] = 0.0
+        radius = 0.1
+        self.creator_destructor.CreateSphericParticle(self.spheres_model_part, coordinates, properties, radius, element_name)
+
+
+        for node in self.spheres_model_part.Nodes:
+            node.SetSolutionStepValue(KratosMultiphysics.VELOCITY_X, 10.0)
+            node.SetSolutionStepValue(KratosMultiphysics.VELOCITY_Y, 5.0)
+            node.SetSolutionStepValue(KratosMultiphysics.VELOCITY_Z, 0.0)
+
+        self.initial_test_energy = self.ComputeEnergy()
+        self.rigid_face_model_part.CreateNewNode(11, -0.5, -0.5, -0.5)
+        self.rigid_face_model_part.CreateNewNode(12, -0.5, -0.5, 0.5)
+
+        self.rigid_face_model_part.CreateNewNode(13, 0.5, -0.5, -0.5)
+        self.rigid_face_model_part.CreateNewNode(14, 0.5, -0.5, 0.5)
+
+
+        self.rigid_face_model_part.CreateNewNode(15, 0.5, 0.5, -0.5)
+        self.rigid_face_model_part.CreateNewNode(16, 0.5, 0.5, 0.5)
+
+        self.rigid_face_model_part.CreateNewNode(17, -0.5, 0.5, -0.5)
+        self.rigid_face_model_part.CreateNewNode(18, -0.5, 0.5, 0.5)
+
+        condition_name = "RigidFace3D3N"
+        self.rigid_face_model_part.CreateNewCondition(condition_name, 1, [11, 12, 13], self.rigid_face_model_part.GetProperties()[0])
+        self.rigid_face_model_part.CreateNewCondition(condition_name, 2, [12, 13, 14], self.rigid_face_model_part.GetProperties()[0])
+
+        self.rigid_face_model_part.CreateNewCondition(condition_name, 3, [13, 14, 15], self.rigid_face_model_part.GetProperties()[0])
+        self.rigid_face_model_part.CreateNewCondition(condition_name, 4, [14, 15, 16], self.rigid_face_model_part.GetProperties()[0])
+
+        self.rigid_face_model_part.CreateNewCondition(condition_name, 5, [15, 16, 17], self.rigid_face_model_part.GetProperties()[0])
+        self.rigid_face_model_part.CreateNewCondition(condition_name, 6, [16, 17, 18], self.rigid_face_model_part.GetProperties()[0])
+
+        self.rigid_face_model_part.CreateNewCondition(condition_name, 7, [17, 18, 11], self.rigid_face_model_part.GetProperties()[0])
+        self.rigid_face_model_part.CreateNewCondition(condition_name, 8, [18, 11, 12], self.rigid_face_model_part.GetProperties()[0])
+
+
+    def ComputeEnergy(self):
+        this_test_total_energy = 0.0
+
+        for element in self.spheres_model_part.Elements:
+            this_test_total_energy += element.Calculate(PARTICLE_TRANSLATIONAL_KINEMATIC_ENERGY, self.spheres_model_part.ProcessInfo)
+            this_test_total_energy += element.Calculate(PARTICLE_ROTATIONAL_KINEMATIC_ENERGY, self.spheres_model_part.ProcessInfo)
+            this_test_total_energy += element.Calculate(PARTICLE_ELASTIC_ENERGY, self.spheres_model_part.ProcessInfo)
+
+        return this_test_total_energy
+
+    def SetHardcodedProperties(self, properties, properties_walls):
+        properties[PARTICLE_DENSITY] = 2650.0
+        properties[KratosMultiphysics.YOUNG_MODULUS] = 7.0e6
+        properties[KratosMultiphysics.POISSON_RATIO] = 0.30
+        properties[STATIC_FRICTION] = 0.0
+        properties[DYNAMIC_FRICTION] = 0.0
+        properties[PARTICLE_COHESION] = 0.0
+        properties[COEFFICIENT_OF_RESTITUTION] = 1.0
+        properties[KratosMultiphysics.PARTICLE_MATERIAL] = 1
+        properties[ROLLING_FRICTION] = 0.0
+        properties[DEM_CONTINUUM_CONSTITUTIVE_LAW_NAME] = "DEMContinuumConstitutiveLaw"
+        properties[DEM_DISCONTINUUM_CONSTITUTIVE_LAW_NAME] = "DEM_D_Hertz_viscous_Coulomb"
+
+        properties_walls[STATIC_FRICTION] = 0.0
+        properties_walls[DYNAMIC_FRICTION] = 0.0
+        properties_walls[WALL_COHESION] = 0.0
+        properties_walls[COMPUTE_WEAR] = 0
+        properties_walls[SEVERITY_OF_WEAR] = 0.001
+        properties_walls[IMPACT_WEAR_SEVERITY] = 0.001
+        properties_walls[BRINELL_HARDNESS] = 200.0
+        properties_walls[KratosMultiphysics.YOUNG_MODULUS] = 7.0e10
+        properties_walls[KratosMultiphysics.POISSON_RATIO] = 0.30
+
+
+    def FinalizeSolutionStep(self):
+        super().FinalizeSolutionStep()
+
+        current_test_energy = self.ComputeEnergy()
+
+        if current_test_energy/self.initial_test_energy > 1.5:
+            print("GAINING ENERGY!!")
+            print("time step is:" + str(self.customized_time_step))
+            import sys
+            sys.exit()
+
+    def PrintResultsForGid(self, time):
+        pass
+
+
+if __name__ == '__main__':
+    TimeStepTester().Run()
```

## KratosMultiphysics/DEMApplication/triaxial2d_test.py

 * *Ordering differences only*

```diff
@@ -1,100 +1,100 @@
-import math
-import os
-
-import KratosMultiphysics as Kratos
-import KratosMultiphysics.DEMApplication as Dem
-
-class Triaxial2D(Dem.DEM_material_test_script.MaterialTest):
-
-    def __init__(self, DEM_parameters, procedures, solver, graphs_path, post_path, spheres_model_part, rigid_face_model_part):
-        super().__init__(DEM_parameters, procedures, solver, graphs_path, post_path, spheres_model_part, rigid_face_model_part)
-
-    def Initialize(self):
-        self.PrepareTests()
-        self.PrepareTestTriaxial2D()
-
-    def PrepareTestTriaxial2D(self):
-        self.alpha_lat = self.perimeter/(self.xlat_area)
-
-    def PrepareTests(self):
-        ##Fixing vertical
-        if self.test_type == "Triaxial2D":
-            for element in self.spheres_model_part.Elements:
-                node = element.GetNode(0)
-                node.SetSolutionStepValue(Kratos.VELOCITY_Z, 0.0)
-                node.Fix(Kratos.VELOCITY_Z)
-
-        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
-        self.graph_export   = open(absolute_path_to_file, 'w')
-        self.xlat_area = self.CircularSkinDetermination()
-
-    def CircularSkinDetermination(self):
-
-        # Cylinder dimensions
-        d = self.diameter
-        eps = 2.0
-
-        self.perimeter = 3.141592 * d
-        self.xlat_area = 0.0
-
-        for element in self.spheres_model_part.Elements:
-            element.GetNode(0).SetSolutionStepValue(Dem.SKIN_SPHERE, 0)
-            node = element.GetNode(0)
-            r = node.GetSolutionStepValue(Kratos.RADIUS)
-            x = node.X
-            y = node.Y
-
-            cross_section = 2.0 * r
-
-            if ((x * x + y * y) >= ((d / 2 - eps * r) * (d / 2 - eps * r))):
-                element.GetNode(0).SetSolutionStepValue(Dem.SKIN_SPHERE, 1)
-                self.LAT.append(node)
-                self.xlat_area = self.xlat_area + cross_section
-
-        if len(self.LAT)==0:
-            self.Procedures.KratosPrintWarning("ERROR! in Circular Skin Determination - NO LATERAL PARTICLES" + "\n")
-
-        return self.xlat_area
-
-    def ApplyLateralStress(self, average_zstress_value, LAT, alpha_lat):
-
-        for node in LAT:
-            r = node.GetSolutionStepValue(Kratos.RADIUS)
-            x = node.X
-            y = node.Y
-
-            values = Kratos.Array3()
-            vect = Kratos.Array3()
-
-            cross_section = 2.0 * r
-
-            vect_moduli = math.sqrt(x * x + y * y)
-
-            if vect_moduli > 0.0:
-                vect[0] = x / vect_moduli
-                vect[1] = y / vect_moduli
-
-            values[0] = cross_section * average_zstress_value * vect[0] * alpha_lat
-            values[1] = cross_section * average_zstress_value * vect[1] * alpha_lat
-            node.SetSolutionStepValue(Kratos.EXTERNAL_APPLIED_FORCE, values)
-
-    def MeasureForcesAndPressure(self):
-        super().MeasureForcesAndPressure()
-        average_zstress_value = 0.0
-
-        if self.test_type == "Triaxial2D":
-            average_zstress_value = self.aux.ComputeAverageZStressFor2D(self.spheres_model_part)
-            self.ApplyLateralStress(average_zstress_value, self.LAT, self.alpha_lat)
-
-    def PrintGraph(self, time):
-        pass
-        #if self.graph_counter == self.graph_frequency:
-        #    self.graph_counter = 0
-        #    self.graph_export.write(str("%.6g"%self.strain).rjust(13) + "  " +
-        #                            str("%.6g"%(self.total_stress_mean*1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12)+'\n')
-        #    self.Flush(self.graph_export)
-
-        #self.graph_counter += 1
-
-    def Flush(self,a):
-        pass
+import math
+import os
+
+import KratosMultiphysics as Kratos
+import KratosMultiphysics.DEMApplication as Dem
+
+class Triaxial2D(Dem.DEM_material_test_script.MaterialTest):
+
+    def __init__(self, DEM_parameters, procedures, solver, graphs_path, post_path, spheres_model_part, rigid_face_model_part):
+        super().__init__(DEM_parameters, procedures, solver, graphs_path, post_path, spheres_model_part, rigid_face_model_part)
+
+    def Initialize(self):
+        self.PrepareTests()
+        self.PrepareTestTriaxial2D()
+
+    def PrepareTestTriaxial2D(self):
+        self.alpha_lat = self.perimeter/(self.xlat_area)
+
+    def PrepareTests(self):
+        ##Fixing vertical
+        if self.test_type == "Triaxial2D":
+            for element in self.spheres_model_part.Elements:
+                node = element.GetNode(0)
+                node.SetSolutionStepValue(Kratos.VELOCITY_Z, 0.0)
+                node.Fix(Kratos.VELOCITY_Z)
+
+        absolute_path_to_file = os.path.join(self.graphs_path, self.problem_name + "_graph.grf")
+        self.graph_export   = open(absolute_path_to_file, 'w')
+        self.xlat_area = self.CircularSkinDetermination()
+
+    def CircularSkinDetermination(self):
+
+        # Cylinder dimensions
+        d = self.diameter
+        eps = 2.0
+
+        self.perimeter = 3.141592 * d
+        self.xlat_area = 0.0
+
+        for element in self.spheres_model_part.Elements:
+            element.GetNode(0).SetSolutionStepValue(Dem.SKIN_SPHERE, 0)
+            node = element.GetNode(0)
+            r = node.GetSolutionStepValue(Kratos.RADIUS)
+            x = node.X
+            y = node.Y
+
+            cross_section = 2.0 * r
+
+            if ((x * x + y * y) >= ((d / 2 - eps * r) * (d / 2 - eps * r))):
+                element.GetNode(0).SetSolutionStepValue(Dem.SKIN_SPHERE, 1)
+                self.LAT.append(node)
+                self.xlat_area = self.xlat_area + cross_section
+
+        if len(self.LAT)==0:
+            self.Procedures.KratosPrintWarning("ERROR! in Circular Skin Determination - NO LATERAL PARTICLES" + "\n")
+
+        return self.xlat_area
+
+    def ApplyLateralStress(self, average_zstress_value, LAT, alpha_lat):
+
+        for node in LAT:
+            r = node.GetSolutionStepValue(Kratos.RADIUS)
+            x = node.X
+            y = node.Y
+
+            values = Kratos.Array3()
+            vect = Kratos.Array3()
+
+            cross_section = 2.0 * r
+
+            vect_moduli = math.sqrt(x * x + y * y)
+
+            if vect_moduli > 0.0:
+                vect[0] = x / vect_moduli
+                vect[1] = y / vect_moduli
+
+            values[0] = cross_section * average_zstress_value * vect[0] * alpha_lat
+            values[1] = cross_section * average_zstress_value * vect[1] * alpha_lat
+            node.SetSolutionStepValue(Kratos.EXTERNAL_APPLIED_FORCE, values)
+
+    def MeasureForcesAndPressure(self):
+        super().MeasureForcesAndPressure()
+        average_zstress_value = 0.0
+
+        if self.test_type == "Triaxial2D":
+            average_zstress_value = self.aux.ComputeAverageZStressFor2D(self.spheres_model_part)
+            self.ApplyLateralStress(average_zstress_value, self.LAT, self.alpha_lat)
+
+    def PrintGraph(self, time):
+        pass
+        #if self.graph_counter == self.graph_frequency:
+        #    self.graph_counter = 0
+        #    self.graph_export.write(str("%.6g"%self.strain).rjust(13) + "  " +
+        #                            str("%.6g"%(self.total_stress_mean*1e-6)).rjust(13) + "  " + str("%.8g"%time).rjust(12)+'\n')
+        #    self.Flush(self.graph_export)
+
+        #self.graph_counter += 1
+
+    def Flush(self,a):
+        pass
```

## KratosMultiphysics/DEMApplication/DEM_procedures.py

 * *Ordering differences only*

```diff
@@ -1,1927 +1,1927 @@
-import math
-import os
-import shutil
-import sys
-import weakref
-from glob import glob
-
-from KratosMultiphysics import *
-from KratosMultiphysics.DEMApplication import *
-import KratosMultiphysics.DEMApplication.DEM_material_test_script as DEM_material_test_script
-import KratosMultiphysics.DEMApplication.triaxial2d_test as triaxial2d_test
-
-def Flush(a):
-    a.flush()
-
-def KratosPrint(*args):
-    Logger.PrintInfo("This method is deprecated since 01/03/2019", label="DEM")
-    Logger.PrintInfo(*args, label="DEM")
-    Logger.Flush()
-
-def KratosPrintInfo(*args):
-    Logger.PrintInfo(*args, label="DEM")
-    Logger.Flush()
-
-def KratosPrintWarning(*args):
-    Logger.PrintWarning(*args, label="DEM")
-    Logger.Flush()
-
-
-def Var_Translator(variable):
-
-    if variable == "OFF" or variable == "0" or variable == 0:
-        variable = 0
-    else:
-        variable = 1
-
-    return variable
-
-
-def GetBoolParameterIfItExists(set_of_parameters, parameter_key):
-    if parameter_key in set_of_parameters.keys():
-        return set_of_parameters[parameter_key].GetBool()
-    return False
-
-
-class MdpaCreator():
-
-    def __init__(self, path, DEM_parameters):
-
-        self.DEM_parameters = DEM_parameters
-        self.current_path = path
-
-        # Creating necessary directories
-        self.post_mdpas = os.path.join(str(self.current_path), str(self.DEM_parameters["problem_name"].GetString()) + '_post_mdpas')
-        if not os.path.isdir(self.post_mdpas):
-            os.makedirs(str(self.post_mdpas))
-
-    def WriteMdpa(self, model_part):
-        time = model_part.ProcessInfo.GetValue(TIME)
-        absolute_path_to_file = os.path.join(self.post_mdpas, str(self.DEM_parameters["problem_name"].GetString()) + '_post_' + str(time) + '.mdpa')
-        mdpa = open(absolute_path_to_file, 'w')
-        mdpa.write('Begin ModelPartData' + '\n')
-        mdpa.write('//  VARIABLE_NAME value')
-        mdpa.write('End ModelPartData' + '\n' + '\n' + '\n' + '\n')
-        mdpa.write('Begin Nodes' + '\n')
-
-        for node in model_part.Nodes:
-            mdpa.write(str(node.Id) + ' ' + str(node.X) + ' ' + str(node.Y) + ' ' + str(node.Z) + '\n')
-        mdpa.write('End Nodes' + '\n' + '\n')
-
-        mdpa.write('Begin Elements SphericParticle3D' + '\n')
-        for element in model_part.Elements:
-            mdpa.write(str(element.Id) + ' ' + '1' + ' ' + str(element.GetNode(0).Id) + '\n')
-        mdpa.write('End Elements' + '\n' + '\n')
-
-        self.WriteVariableData(RADIUS, mdpa, model_part)
-        #self.WriteVariableData(VELOCITY_X, mdpa, model_part)
-        #self.WriteVariableData(VELOCITY_Y, mdpa, model_part)
-        #self.WriteVariableData(VELOCITY_Z, mdpa, model_part)
-
-    def WriteVariableData(self, variable_name, mdpa, model_part):
-
-        mdpa.write('Begin NodalData ' + str(variable_name) + '\n')
-        for node in model_part.Nodes:
-            mdpa.write(str(node.Id) + ' ' + str(0) + ' ' + str(node.GetSolutionStepValue(variable_name)) + '\n')
-        mdpa.write('End NodalData' + '\n' + '\n')
-
-
-class SetOfModelParts():
-    def __init__(self, model_parts_list):
-        self.MaxNodeId = 0
-        self.MaxElemId = 0
-        self.MaxCondId = 0
-
-        self.model_parts = dict()
-        self.mp_list = []
-        for mp in model_parts_list:
-            self.model_parts[mp.Name] = mp
-            self.mp_list.append(mp)
-
-        self.spheres_model_part = self.Get("SpheresPart")
-        self.rigid_face_model_part = self.Get("RigidFacePart")
-        self.cluster_model_part = self.Get("ClusterPart")
-        self.dem_inlet_model_part = self.Get("DEMInletPart")
-        self.mapping_model_part = self.Get("MappingPart")
-        self.contact_model_part = self.Get("ContactPart")
-
-    def ComputeMaxIds(self):
-
-        for mp in self.mp_list:
-            self.GetMaxIds(mp)
-
-    def GetMaxIds(self, model_part):
-
-        for node in model_part.Nodes:
-            self.MaxNodeId = max(self.MaxNodeId, node.Id)
-
-        for elem in model_part.Elements:
-            self.MaxElemId = max(self.MaxElemId, elem.Id)
-
-        for cond in model_part.Conditions:
-            self.MaxCondId = max(self.MaxCondId, cond.Id)
-
-    def Get(self, name):
-        return self.model_parts[name]
-
-    def Add(self, model_part, name=None):
-        if name is not None:
-            self.model_parts[name] = model_part
-        else:
-            self.model_parts[model_part.Name] = model_part
-
-        self.mp_list.append(model_part)
-
-
-class GranulometryUtils():
-
-    def __init__(self, domain_volume, model_part):
-
-        if domain_volume <= 0.0:
-            raise ValueError(
-                "Error: The input domain volume must be strictly positive!")
-
-        self.spheres_model_part = model_part
-        self.UpdateData(domain_volume)
-
-    def UpdateData(self, domain_volume):
-
-        self.physics_calculator = SphericElementGlobalPhysicsCalculator(self.spheres_model_part)
-        self.number_of_spheres = self.spheres_model_part.NumberOfElements(0)
-        self.solid_volume = self.physics_calculator.CalculateTotalVolume(self.spheres_model_part)
-        self.d_50 = self.physics_calculator.CalculateD50(self.spheres_model_part)
-
-        if self.number_of_spheres == 0:
-            self.spheres_per_area = 0.0
-        else:
-            self.spheres_per_area = domain_volume / self.number_of_spheres
-
-        self.voids_volume = domain_volume - self.solid_volume
-        self.global_porosity = self.voids_volume / domain_volume
-
-        self.PrintCurrentData()
-
-    def PrintCurrentData(self):
-
-        Logger.Print("number_of_spheres:", self.number_of_spheres, label="")
-        Logger.Print("solid volume:", self.solid_volume, label="")
-        Logger.Print("voids volume:", self.voids_volume, label="")
-        Logger.Print("global porosity:", self.global_porosity, label="")
-        Logger.Print("D50:", self.d_50, label="")
-        Logger.Print("spheres per area unit:", self.spheres_per_area, label="")
-        Logger.Print("")
-
-        granul_file = open('granulometry_data.txt', 'w')
-        granul_file.write("Number of spheres: " + str(self.number_of_spheres) + '\n')
-        granul_file.write("Solid volume: " + str(self.solid_volume) + '\n')
-        granul_file.write("Voids volume: " + str(self.voids_volume) + '\n')
-        granul_file.write("Global porosity: " + str(self.global_porosity) + '\n')
-        granul_file.write("D50: " + str(self.d_50) + '\n')
-        granul_file.write("Spheres per area unit: " + str(self.spheres_per_area) + '\n')
-        granul_file.close()
-
-class PostUtils():
-
-    def __init__(self, DEM_parameters, spheres_model_part):
-
-        self.DEM_parameters = DEM_parameters
-        self.spheres_model_part = spheres_model_part
-        self.post_utilities = PostUtilities()
-        self.vel_trap_graph_counter = 0
-        # TODO: change the name of VelTrapGraphExportFreq to VelTrapGraphExportTimeInterval
-        self.vel_trap_graph_frequency = int(self.DEM_parameters["VelTrapGraphExportFreq"].GetDouble() / spheres_model_part.ProcessInfo.GetValue(DELTA_TIME))
-        if self.vel_trap_graph_frequency < 1:
-            self.vel_trap_graph_frequency = 1 # that means it is not possible to print results with a higher frequency than the computations delta time
-
-        self.previous_vector_of_inner_nodes = []
-        self.previous_time = 0.0
-
-    def Flush(self, a):
-        a.flush()
-
-    def ComputeMeanVelocitiesInTrap(self, file_name, time_dem, graphs_path):
-
-        if self.DEM_parameters["VelocityTrapOption"].GetBool():
-            compute_flow = "ComputeFlow" in self.DEM_parameters.keys() and self.DEM_parameters["ComputeFlow"].GetBool()
-
-            self.vel_trap_graph_counter += 1
-
-            if self.vel_trap_graph_counter == self.vel_trap_graph_frequency:
-                self.vel_trap_graph_counter = 0
-                average_velocity = Array3()
-                low_point = Array3()
-
-                low_point[0] = self.DEM_parameters["VelocityTrapMinX"].GetDouble()
-                low_point[1] = self.DEM_parameters["VelocityTrapMinY"].GetDouble()
-                low_point[2] = self.DEM_parameters["VelocityTrapMinZ"].GetDouble()
-                high_point = Array3()
-                high_point[0] = self.DEM_parameters["VelocityTrapMaxX"].GetDouble()
-                high_point[1] = self.DEM_parameters["VelocityTrapMaxY"].GetDouble()
-                high_point[2] = self.DEM_parameters["VelocityTrapMaxZ"].GetDouble()
-
-                average_velocity = self.post_utilities.VelocityTrap(self.spheres_model_part, low_point, high_point)
-
-                if compute_flow:
-                    vector_of_inner_nodes = []
-                    for node in self.spheres_model_part.Nodes:
-                        if (node.X > low_point[0]) & (node.Y > low_point[1]) & (node.Z > low_point[2]) & (node.X < high_point[0]) & (node.Y < high_point[1]) & (node.Z < high_point[2]):
-                            vector_of_inner_nodes.append(node)
-
-                    crossing_spheres = 0
-                    crossing_volume = 0.0
-
-                    for node in vector_of_inner_nodes:
-                        id_found = False
-                        for previous_node in self.previous_vector_of_inner_nodes:
-                            if node.Id == previous_node.Id:
-                                id_found = True
-                                break
-                        # This only happens if None of the previous nodes were capable of setting id_found = True.
-                        if id_found is False:
-                            crossing_spheres = crossing_spheres + 1
-                            radius = node.GetSolutionStepValue(RADIUS)
-                            crossing_volume = crossing_volume + 4.0 / 3.0 * math.pi * radius * radius * radius
-
-                    time_between_measures = self.spheres_model_part.ProcessInfo.GetValue(TIME) - self.previous_time
-                    number_of_spheres_flow = float(crossing_spheres) / time_between_measures
-                    net_volume_flow = crossing_volume / time_between_measures
-
-                    self.previous_time = self.spheres_model_part.ProcessInfo.GetValue(TIME)
-                    self.previous_vector_of_inner_nodes = vector_of_inner_nodes
-
-                absolute_path_to_file = os.path.join(graphs_path, file_name)
-                f = open(absolute_path_to_file, 'a')
-                tmp = str(time_dem) + "   " + str(average_velocity[0]) + "   " + str(average_velocity[1]) + "   " + str(average_velocity[2])
-                if compute_flow:
-                    tmp = tmp + "   " + str(net_volume_flow) + "   " + str(number_of_spheres_flow)
-                tmp = tmp + "\n"
-
-                f.write(tmp)
-                self.Flush(f)
-
-    def PrintEulerAngles(self, spheres_model_part, cluster_model_part):
-        PostUtilities().ComputeEulerAngles(spheres_model_part, cluster_model_part)
-
-
-class DEMEnergyCalculator():
-
-    def __init__(self, DEM_parameters, spheres_model_part, cluster_model_part, graphs_path, energy_plot):
-
-        self.calculate_option = False
-
-        if "EnergyCalculationOption" in DEM_parameters.keys():
-            if DEM_parameters["EnergyCalculationOption"].GetBool():
-                self.calculate_option = True
-                self.DEM_parameters = DEM_parameters
-                self.SpheresModelPart = spheres_model_part
-                self.ClusterModelPart = cluster_model_part
-                absolute_path_to_file = os.path.join(graphs_path, energy_plot)
-                self.energy_plot = open(absolute_path_to_file, 'w')
-                self.SpheresEnergyUtil = SphericElementGlobalPhysicsCalculator(spheres_model_part)
-                self.ClusterEnergyUtil = SphericElementGlobalPhysicsCalculator(cluster_model_part)
-                self.PotentialEnergyReferencePoint = Array3()
-                self.PotentialEnergyReferencePoint[0] = self.DEM_parameters["PotentialEnergyReferencePointX"].GetDouble()
-                self.PotentialEnergyReferencePoint[1] = self.DEM_parameters["PotentialEnergyReferencePointY"].GetDouble()
-                self.PotentialEnergyReferencePoint[2] = self.DEM_parameters["PotentialEnergyReferencePointZ"].GetDouble()
-                self.translational_kinematic_energy = 0.0
-                self.rotational_kinematic_energy = 0.0
-                self.kinematic_energy = 0.0
-                self.gravitational_energy = 0.0
-                self.elastic_energy = 0.0
-                self.inelastic_frictional_energy = 0.0
-                self.inelastic_viscodamping_energy = 0.0
-                self.inelastic_rollingresistance_energy = 0.0
-                self.external_energy = 0.0
-                self.total_energy = 0.0
-                self.graph_frequency = int(self.DEM_parameters["GraphExportFreq"].GetDouble() / spheres_model_part.ProcessInfo.GetValue(DELTA_TIME))  # TODO: change the name GraphExportFreq to GraphExportTimeInterval
-                self.energy_graph_counter = 0
-                self.energy_plot.write(str("Time").rjust(9) + "   " + str("Trans kinematic energy").rjust(22) + "   " + str("Rot kinematic energy").rjust(20) + "   " + str("Kinematic energy").rjust(16) + "   " + str("Gravitational energy").rjust(20) + "   " + str("Elastic energy").rjust(14) + "   " + str("Frictional energy").rjust(16) + "   " + str("Viscodamping energy").rjust(19) + "   " + str("Rolling resistance energy").rjust(25) + "   " + str("Total energy").rjust(12) + "\n")
-
-    def CalculateEnergyAndPlot(self, time):
-        if self.calculate_option:
-            if self.energy_graph_counter == self.graph_frequency:
-                self.energy_graph_counter = 0
-                self.CalculateEnergy()
-                self.PlotEnergyGraph(time)
-
-            self.energy_graph_counter += 1
-
-    def CalculateEnergy(self):
-
-        self.translational_kinematic_energy = self.SpheresEnergyUtil.CalculateTranslationalKinematicEnergy(self.SpheresModelPart) + self.ClusterEnergyUtil.CalculateTranslationalKinematicEnergy(self.ClusterModelPart)
-        self.rotational_kinematic_energy = self.SpheresEnergyUtil.CalculateRotationalKinematicEnergy(self.SpheresModelPart) + self.ClusterEnergyUtil.CalculateRotationalKinematicEnergy(self.ClusterModelPart)
-        self.kinematic_energy = self.translational_kinematic_energy + self.rotational_kinematic_energy
-        self.gravitational_energy = self.SpheresEnergyUtil.CalculateGravitationalPotentialEnergy(self.SpheresModelPart, self.PotentialEnergyReferencePoint) + self.ClusterEnergyUtil.CalculateGravitationalPotentialEnergy(self.ClusterModelPart, self.PotentialEnergyReferencePoint)
-        self.elastic_energy = self.SpheresEnergyUtil.CalculateElasticEnergy(self.SpheresModelPart) + self.ClusterEnergyUtil.CalculateElasticEnergy(self.ClusterModelPart)
-        self.inelastic_frictional_energy = self.SpheresEnergyUtil.CalculateInelasticFrictionalEnergy(self.SpheresModelPart) + self.ClusterEnergyUtil.CalculateInelasticFrictionalEnergy(self.ClusterModelPart)
-        self.inelastic_viscodamping_energy = self.SpheresEnergyUtil.CalculateInelasticViscodampingEnergy(self.SpheresModelPart) + self.ClusterEnergyUtil.CalculateInelasticViscodampingEnergy(self.ClusterModelPart)
-        self.inelastic_rollingresistance_energy = self.SpheresEnergyUtil.CalculateInelasticRollingResistanceEnergy(self.SpheresModelPart) + self.ClusterEnergyUtil.CalculateInelasticRollingResistanceEnergy(self.ClusterModelPart)
-        self.total_energy = self.kinematic_energy + self.gravitational_energy + self.elastic_energy + self.inelastic_frictional_energy + self.inelastic_viscodamping_energy + self.inelastic_rollingresistance_energy
-
-    def PlotEnergyGraph(self, time):
-
-        plot_kinematic = self.kinematic_energy
-        plot_translational_kinematic = self.translational_kinematic_energy
-        plot_rotational_kinematic = self.rotational_kinematic_energy
-        plot_gravitational = self.gravitational_energy
-        plot_elastic = self.elastic_energy
-        plot_inelastic_frictional = self.inelastic_frictional_energy
-        plot_inelastic_viscodamping = self.inelastic_viscodamping_energy
-        plot_inelastic_rollingresistance = self.inelastic_rollingresistance_energy
-        plot_total = self.total_energy
-        self.energy_plot.write(str("%.8g" % time).rjust(9) + "   " + str("%.6g" % plot_translational_kinematic).rjust(22) + "   " + str("%.6g" % plot_rotational_kinematic).rjust(20) + "   " + str("%.6g" % plot_kinematic).rjust(16) + "   " + str("%.6g"%plot_gravitational).rjust(20) + "   " + str("%.6g" % plot_elastic).rjust(14) + "   " + str("%.6g" % plot_inelastic_frictional).rjust(16) + "   " + str("%.6g" % plot_inelastic_viscodamping).rjust(19) + "   " + str("%.6g" % plot_inelastic_rollingresistance).rjust(23) + "   " + str("%.6g" % plot_total).rjust(12) + '\n')
-        self.energy_plot.flush()
-
-    def FinalizeEnergyPlot(self):
-        if self.calculate_option:
-            self.energy_plot.close
-
-
-class Procedures():
-
-    def __init__(self, DEM_parameters):
-
-        # GLOBAL VARIABLES OF THE SCRIPT
-        # Defining list of skin particles (For a test tube of height 30 cm and diameter 15 cm)
-
-        # Initialization of member variables
-        self.DEM_parameters = DEM_parameters
-
-        # SIMULATION FLAGS
-        self.rotation_OPTION = self.DEM_parameters["RotationOption"].GetBool()
-        self.bounding_box_OPTION = self.DEM_parameters["BoundingBoxOption"].GetBool()
-        self.automatic_bounding_box_OPTION = self.DEM_parameters["AutomaticBoundingBoxOption"].GetBool()
-
-        self.contact_mesh_OPTION = False
-        if "ContactMeshOption" in self.DEM_parameters.keys():
-            self.contact_mesh_OPTION = self.DEM_parameters["ContactMeshOption"].GetBool()
-
-        # SIMULATION SETTINGS
-        self.b_box_minX = self.DEM_parameters["BoundingBoxMinX"].GetDouble()
-        self.b_box_minY = self.DEM_parameters["BoundingBoxMinY"].GetDouble()
-        self.b_box_minZ = self.DEM_parameters["BoundingBoxMinZ"].GetDouble()
-        self.b_box_maxX = self.DEM_parameters["BoundingBoxMaxX"].GetDouble()
-        self.b_box_maxY = self.DEM_parameters["BoundingBoxMaxY"].GetDouble()
-        self.b_box_maxZ = self.DEM_parameters["BoundingBoxMaxZ"].GetDouble()
-        self.bounding_box_enlargement_factor = self.DEM_parameters["BoundingBoxEnlargementFactor"].GetDouble()
-
-        # MODEL
-        self.domain_size = self.DEM_parameters["Dimension"].GetInt()
-
-    def Barrier(self):
-        pass
-
-    def SetTranslationalScheme(self):
-        if self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Forward_Euler':
-            translational_scheme = ForwardEulerScheme()
-        elif self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Symplectic_Euler':
-            translational_scheme = SymplecticEulerScheme()
-        elif self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Taylor_Scheme':
-            translational_scheme = TaylorScheme()
-        elif self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Velocity_Verlet':
-            translational_scheme = VelocityVerletScheme()
-        else:
-            raise Exception('Error: selected translational integration scheme not defined. Please select a different scheme')
-        return translational_scheme
-
-    def SetRotationalScheme(self):
-        if self.DEM_parameters["RotationalIntegrationScheme"].GetString() == 'Direct_Integration':
-            if self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Forward_Euler':
-                rotational_scheme = ForwardEulerScheme()
-            elif self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Symplectic_Euler':
-                rotational_scheme = SymplecticEulerScheme()
-            elif self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Taylor_Scheme':
-                rotational_scheme = TaylorScheme()
-            elif self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Velocity_Verlet':
-                rotational_scheme = VelocityVerletScheme()
-        elif self.DEM_parameters["RotationalIntegrationScheme"].GetString() == 'Runge_Kutta':
-            rotational_scheme = RungeKuttaScheme()
-        elif self.DEM_parameters["RotationalIntegrationScheme"].GetString() == 'Quaternion_Integration':
-            rotational_scheme = QuaternionIntegrationScheme()
-        else:
-            raise Exception('Error: selected rotational integration scheme not defined. Please select a different scheme')
-        return rotational_scheme
-
-    def AddAllVariablesInAllModelParts(self, solver, translational_scheme, rotational_scheme, all_model_parts, DEM_parameters):
-
-        spheres_model_part = all_model_parts.Get('SpheresPart')
-        cluster_model_part = all_model_parts.Get('ClusterPart')
-        dem_inlet_model_part = all_model_parts.Get('DEMInletPart')
-        rigid_face_model_part = all_model_parts.Get('RigidFacePart')
-
-        self.solver = weakref.proxy(solver)
-        self.translational_scheme = weakref.proxy(translational_scheme)
-        self.rotational_scheme = weakref.proxy(rotational_scheme)
-        self.AddCommonVariables(spheres_model_part, DEM_parameters)
-        self.AddSpheresVariables(spheres_model_part, DEM_parameters)
-        self.AddMpiVariables(spheres_model_part)
-        self.solver.AddAdditionalVariables(spheres_model_part, DEM_parameters)
-        self.AddCommonVariables(cluster_model_part, DEM_parameters)
-        self.AddClusterVariables(cluster_model_part, DEM_parameters)
-        self.AddMpiVariables(cluster_model_part)
-        self.AddCommonVariables(dem_inlet_model_part, DEM_parameters)
-        self.AddSpheresVariables(dem_inlet_model_part, DEM_parameters)
-        self.solver.AddAdditionalVariables(dem_inlet_model_part, DEM_parameters)
-        self.AddCommonVariables(rigid_face_model_part, DEM_parameters)
-        self.AddRigidFaceVariables(rigid_face_model_part, DEM_parameters)
-        self.AddMpiVariables(rigid_face_model_part)
-
-    def AddCommonVariables(self, model_part, DEM_parameters):
-        model_part.AddNodalSolutionStepVariable(VELOCITY)
-        model_part.AddNodalSolutionStepVariable(DISPLACEMENT)
-        model_part.AddNodalSolutionStepVariable(DELTA_DISPLACEMENT)
-        model_part.AddNodalSolutionStepVariable(TOTAL_FORCES)
-        model_part.AddNodalSolutionStepVariable(CONTACT_FORCES)
-
-    def AddSpheresVariables(self, model_part, DEM_parameters):
-
-        # KINEMATIC
-        # TODO: only if self.DEM_parameters-RotationOption! Check that no one accesses them in c++ without checking the rotation option
-        model_part.AddNodalSolutionStepVariable(DELTA_ROTATION)
-        # TODO: only if self.DEM_parameters-RotationOption! Check that no one accesses them in c++ without checking the rotation option
-        model_part.AddNodalSolutionStepVariable(PARTICLE_ROTATION_ANGLE)
-        # TODO: only if self.DEM_parameters-RotationOption! Check that no one accesses them in c++ without checking the rotation option
-        model_part.AddNodalSolutionStepVariable(ANGULAR_VELOCITY)
-        model_part.AddNodalSolutionStepVariable(LOCAL_ANGULAR_VELOCITY)
-        model_part.AddNodalSolutionStepVariable(NORMAL_IMPACT_VELOCITY)
-        model_part.AddNodalSolutionStepVariable(TANGENTIAL_IMPACT_VELOCITY)
-        # TODO: only if self.DEM_parameters-RotationOption! Check that no one accesses them in c++ without checking the rotation option
-        model_part.AddNodalSolutionStepVariable(ORIENTATION)
-        model_part.AddNodalSolutionStepVariable(ANGULAR_MOMENTUM)
-        model_part.AddNodalSolutionStepVariable(FACE_NORMAL_IMPACT_VELOCITY)
-        model_part.AddNodalSolutionStepVariable(FACE_TANGENTIAL_IMPACT_VELOCITY)
-        model_part.AddNodalSolutionStepVariable(LINEAR_IMPULSE)
-        # ****************** Quaternion Integration BEGIN ******************
-        # TODO: only if self.DEM_parameters-RotationOption! Check that no one accesses them in c++ without checking the rotation option
-        model_part.AddNodalSolutionStepVariable(LOCAL_AUX_ANGULAR_VELOCITY)
-        # TODO: only if self.DEM_parameters-RotationOption! Check that no one accesses them in c++ without checking the rotation option
-        model_part.AddNodalSolutionStepVariable(AUX_ORIENTATION)
-        # ******************* Quaternion Integration END *******************
-
-        # FORCES
-        model_part.AddNodalSolutionStepVariable(ELASTIC_FORCES)
-        model_part.AddNodalSolutionStepVariable(LOCAL_CONTACT_FORCE)
-        model_part.AddNodalSolutionStepVariable(RIGID_ELEMENT_FORCE)
-        model_part.AddNodalSolutionStepVariable(DAMP_FORCES)
-        # TODO: only if self.DEM_parameters-RotationOption! Check that no one accesses them in c++ without checking the rotation option
-        model_part.AddNodalSolutionStepVariable(PARTICLE_MOMENT)
-        model_part.AddNodalSolutionStepVariable(EXTERNAL_APPLIED_FORCE)
-        model_part.AddNodalSolutionStepVariable(EXTERNAL_APPLIED_MOMENT)
-        model_part.AddNodalSolutionStepVariable(FORCE_REACTION)
-        model_part.AddNodalSolutionStepVariable(MOMENT_REACTION)
-
-        # BASIC PARTICLE PROPERTIES
-        model_part.AddNodalSolutionStepVariable(RADIUS)
-        model_part.AddNodalSolutionStepVariable(NODAL_MASS)
-        model_part.AddNodalSolutionStepVariable(REPRESENTATIVE_VOLUME)
-        model_part.AddNodalSolutionStepVariable(NEIGHBOUR_SIZE)
-        model_part.AddNodalSolutionStepVariable(DAMAGE_RATIO)
-
-        # ROTATION RELATED PROPERTIES
-        if self.DEM_parameters["RotationOption"].GetBool():
-            # TODO: only if self.DEM_parameters-RotationOption! Check that no one accesses them in c++ without checking the rotation option
-            model_part.AddNodalSolutionStepVariable(PARTICLE_MOMENT_OF_INERTIA)
-            model_part.AddNodalSolutionStepVariable(PRINCIPAL_MOMENTS_OF_INERTIA)
-            # TODO: only if self.DEM_parameters-RotationOption! Check that no one accesses them in c++ without checking the rotation option
-            model_part.AddNodalSolutionStepVariable(PARTICLE_ROTATION_DAMP_RATIO)
-            if self.DEM_parameters["RollingFrictionOption"].GetBool():
-                model_part.AddNodalSolutionStepVariable(ROLLING_RESISTANCE_MOMENT)
-
-        # OTHER PROPERTIES
-        model_part.AddNodalSolutionStepVariable(PARTICLE_MATERIAL)   # Colour defined in GiD
-
-        if "PostSkinSphere" in self.DEM_parameters.keys():
-            if self.DEM_parameters["PostSkinSphere"].GetBool():
-                model_part.AddNodalSolutionStepVariable(SKIN_SPHERE)
-
-        if "PostGluedSphere" in self.DEM_parameters.keys():
-            model_part.AddNodalSolutionStepVariable(IS_STICKY)
-
-        # LOCAL AXIS
-        if DEM_parameters["PostEulerAngles"].GetBool():
-            model_part.AddNodalSolutionStepVariable(EULER_ANGLES)
-
-        if "PostStressStrainOption" in self.DEM_parameters.keys():
-            if self.DEM_parameters["PostStressStrainOption"].GetBool():
-                model_part.AddNodalSolutionStepVariable(DEM_STRESS_TENSOR)
-                model_part.AddNodalSolutionStepVariable(DEM_STRAIN_TENSOR)
-                model_part.AddNodalSolutionStepVariable(DEM_DIFFERENTIAL_STRAIN_TENSOR)
-
-        if self.solver.poisson_ratio_option:
-            model_part.AddNodalSolutionStepVariable(POISSON_VALUE)
-
-        # Nano Particle
-        if self.DEM_parameters["ElementType"].GetString() == "SwimmingNanoParticle":
-            model_part.AddNodalSolutionStepVariable(CATION_CONCENTRATION)
-            model_part.AddNodalSolutionStepVariable(DRAG_COEFFICIENT)
-
-        # ONLY VISUALIZATION
-        if self.DEM_parameters["PostExportId"].GetBool():  # TODO: add suffix Option
-            model_part.AddNodalSolutionStepVariable(EXPORT_ID)
-
-        # ONLY VISUALIZATION
-        if "PostGroupId" in self.DEM_parameters.keys():
-            if self.DEM_parameters["PostGroupId"].GetBool(): 
-                model_part.AddNodalSolutionStepVariable(GROUP_ID)
-
-        #model_part.AddNodalSolutionStepVariable(SPRAYED_MATERIAL)
-
-    def AddRigidFaceVariables(self, model_part, DEM_parameters):
-
-        model_part.AddNodalSolutionStepVariable(ELASTIC_FORCES)
-        model_part.AddNodalSolutionStepVariable(DEM_PRESSURE)
-        model_part.AddNodalSolutionStepVariable(TANGENTIAL_ELASTIC_FORCES)
-        model_part.AddNodalSolutionStepVariable(SHEAR_STRESS)
-        model_part.AddNodalSolutionStepVariable(DEM_NODAL_AREA)
-        model_part.AddNodalSolutionStepVariable(NON_DIMENSIONAL_VOLUME_WEAR)
-        model_part.AddNodalSolutionStepVariable(IMPACT_WEAR)
-        model_part.AddNodalSolutionStepVariable(PARTICLE_ROTATION_ANGLE)
-        model_part.AddNodalSolutionStepVariable(DELTA_ROTATION)
-        model_part.AddNodalSolutionStepVariable(ANGULAR_VELOCITY)
-        model_part.AddNodalSolutionStepVariable(LOCAL_ANGULAR_VELOCITY)
-        model_part.AddNodalSolutionStepVariable(LOCAL_AUX_ANGULAR_VELOCITY)
-        model_part.AddNodalSolutionStepVariable(ORIENTATION)
-        model_part.AddNodalSolutionStepVariable(AUX_ORIENTATION)
-        model_part.AddNodalSolutionStepVariable(ANGULAR_MOMENTUM)
-
-        # FORCES
-        model_part.AddNodalSolutionStepVariable(RIGID_ELEMENT_FORCE)
-        model_part.AddNodalSolutionStepVariable(PARTICLE_MOMENT)
-        model_part.AddNodalSolutionStepVariable(EXTERNAL_APPLIED_FORCE)
-        model_part.AddNodalSolutionStepVariable(EXTERNAL_APPLIED_MOMENT)
-
-        # PHYSICAL PROPERTIES
-        model_part.AddNodalSolutionStepVariable(PRINCIPAL_MOMENTS_OF_INERTIA)
-        model_part.AddNodalSolutionStepVariable(CLUSTER_VOLUME)
-        model_part.AddNodalSolutionStepVariable(NODAL_MASS)
-        model_part.AddNodalSolutionStepVariable(CHARACTERISTIC_LENGTH)
-        model_part.AddNodalSolutionStepVariable(PARTICLE_DENSITY)
-
-    def AddElasticFaceVariables(self, model_part, DEM_parameters): #Only used in CSM coupling
-        self.AddRigidFaceVariables(model_part, self.DEM_parameters)
-        model_part.AddNodalSolutionStepVariable(TOTAL_FORCES)
-
-    def AddClusterVariables(self, model_part, DEM_parameters):
-        # KINEMATIC
-        model_part.AddNodalSolutionStepVariable(PARTICLE_ROTATION_ANGLE)
-        model_part.AddNodalSolutionStepVariable(DELTA_ROTATION)
-        model_part.AddNodalSolutionStepVariable(ANGULAR_VELOCITY)
-        model_part.AddNodalSolutionStepVariable(LOCAL_ANGULAR_VELOCITY)
-        model_part.AddNodalSolutionStepVariable(ORIENTATION)
-        model_part.AddNodalSolutionStepVariable(ANGULAR_MOMENTUM)
-        # ****************** Quaternion Integration BEGIN ******************
-        model_part.AddNodalSolutionStepVariable(LOCAL_AUX_ANGULAR_VELOCITY)
-        model_part.AddNodalSolutionStepVariable(AUX_ORIENTATION)
-        # ******************* Quaternion Integration END *******************
-
-        # FORCES
-        model_part.AddNodalSolutionStepVariable(TOTAL_FORCES)
-        model_part.AddNodalSolutionStepVariable(RIGID_ELEMENT_FORCE)
-        model_part.AddNodalSolutionStepVariable(PARTICLE_MOMENT)
-        model_part.AddNodalSolutionStepVariable(EXTERNAL_APPLIED_FORCE)
-        model_part.AddNodalSolutionStepVariable(EXTERNAL_APPLIED_MOMENT)
-
-        # PHYSICAL PROPERTIES
-        model_part.AddNodalSolutionStepVariable(PRINCIPAL_MOMENTS_OF_INERTIA)
-        model_part.AddNodalSolutionStepVariable(CLUSTER_VOLUME)
-        model_part.AddNodalSolutionStepVariable(NODAL_MASS)
-        model_part.AddNodalSolutionStepVariable(CHARACTERISTIC_LENGTH)
-        model_part.AddNodalSolutionStepVariable(PARTICLE_DENSITY)
-
-        # OTHER PROPERTIES
-        model_part.AddNodalSolutionStepVariable(PARTICLE_MATERIAL)   # Colour defined in GiD
-
-        # LOCAL AXIS
-        if DEM_parameters["PostEulerAngles"].GetBool():
-            model_part.AddNodalSolutionStepVariable(EULER_ANGLES)
-
-    def AddMpiVariables(self, model_part):
-        pass
-
-    def SetInitialNodalValues(self, spheres_model_part, cluster_model_part, dem_inlet_model_part, rigid_face_model_part):
-        pass
-
-    def SetUpBufferSizeInAllModelParts(self, spheres_model_part, spheres_b_size, cluster_model_part, clusters_b_size, dem_inlet_model_part, inlet_b_size, rigid_face_model_part, rigid_b_size):
-        spheres_model_part.SetBufferSize(spheres_b_size)
-        cluster_model_part.SetBufferSize(clusters_b_size)
-        dem_inlet_model_part.SetBufferSize(inlet_b_size)
-        rigid_face_model_part.SetBufferSize(rigid_b_size)
-
-    def FindMaxNodeIdAccrossModelParts(self, creator_destructor, all_model_parts):
-
-        max_candidates = []
-        max_candidates.append(creator_destructor.FindMaxNodeIdInModelPart(all_model_parts.Get("SpheresPart")))
-        max_candidates.append(creator_destructor.FindMaxElementIdInModelPart(all_model_parts.Get("SpheresPart")))
-        max_candidates.append(creator_destructor.FindMaxNodeIdInModelPart(all_model_parts.Get("RigidFacePart")))
-        max_candidates.append(creator_destructor.FindMaxNodeIdInModelPart(all_model_parts.Get("ClusterPart")))
-
-        return max(max_candidates)
-
-    def ModelData(self, spheres_model_part, solver):
-
-        contact_model_part = solver.contact_model_part
-        # Previous Calculations.
-        Model_Data = open('Model_Data.txt', 'w')
-
-        # mean radius, and standard deviation:
-        i = 0.0
-        sum_radi = 0.0
-        partial_sum_squared = 0.0
-        total_sum_squared = 0.0
-        volume = 0.0
-        area = 0.0
-        mean = 0.0
-        var = 0.0
-        rel_std_dev = 0.0
-
-        for node in spheres_model_part.Nodes:
-
-            sum_radi += node.GetSolutionStepValue(RADIUS)
-            partial_sum_squared = node.GetSolutionStepValue(RADIUS) ** 2.0
-            total_sum_squared += partial_sum_squared
-            volume += 4 * math.pi / 3 * node.GetSolutionStepValue(RADIUS) ** 3.0
-            area += math.pi * partial_sum_squared
-            i += 1.0
-
-        if i > 0.0:
-            mean = sum_radi / i
-            var = total_sum_squared / i - mean ** 2.0
-        std_dev = 0.0
-
-        if abs(var) > 1e-9:
-            std_dev = var ** 0.5
-
-        if i > 0.0:
-            rel_std_dev = std_dev / mean
-
-        Model_Data.write("Radius Mean: " + str(mean) + '\n')
-        Model_Data.write("Std Deviation: " + str(std_dev) + '\n')
-        Model_Data.write("Relative Std Deviation: " + str(rel_std_dev) + '\n')
-        Model_Data.write("Total Particle Volume 3D: " + str(volume) + '\n')
-        Model_Data.write("Total Particle Area 2D: " + str(area) + '\n')
-        Model_Data.write('\n')
-
-        Total_Particles = len(spheres_model_part.Nodes)
-
-        if solver.continuum_type:
-            Coordination_Number = 0.0
-
-            if self.contact_mesh_OPTION:
-                Total_Contacts = contact_model_part.NumberOfElements(0)
-
-                if Total_Particles:
-                    Coordination_Number = 2.0 * Total_Contacts / Total_Particles
-
-            Model_Data.write("Total Number of Particles: " + str(Total_Particles) + '\n')
-            Model_Data.write("Total Number of Bonds: " + str(Total_Contacts) + '\n')
-            Model_Data.write("Bonded Coordination Number NC: " + str(Coordination_Number) + '\n')
-            Model_Data.write('\n')
-            Model_Data.write("Volume Elements: " + str(volume) + '\n')
-            self.KratosPrintInfo("Coordination Number: " + str(Coordination_Number) + "\n")
-
-        Model_Data.close()
-
-    def MonitorPhysicalProperties(self, model_part, physics_calculator, properties_list):
-
-        # This function returns a list of arrays (also lists)
-        # Each array contains the values of the physical properties at the current time
-        time = model_part.ProcessInfo.GetValue(TIME)
-        present_prop = []
-
-        if not properties_list:  # The first array in the list only contains the entries names
-            names = []
-            names.append("time")
-            names.append("mass")
-            names.append("gravitational_energy")
-            names.append("kinematic_energy")
-            #names.append("elastic_energy")
-            names.append("momentum")
-            names.append("angular_momentum")
-            names.append("total_energy")
-
-            properties_list.append(names)
-
-        # Calculating current values
-        mass = physics_calculator.CalculateTotalMass(model_part)
-        center = physics_calculator.CalculateCenterOfMass(model_part)
-        initial_center = physics_calculator.GetInitialCenterOfMass()
-        gravity_energy = physics_calculator.CalculateGravitationalPotentialEnergy(model_part, initial_center)
-        kinematic_energy = physics_calculator.CalculateKinematicEnergy(model_part)
-        #elastic_energy = physics_calculator.CalculateElasticEnergy(model_part)
-        momentum = physics_calculator.CalculateTotalMomentum(model_part)
-        angular_momentum = physics_calculator.CalulateTotalAngularMomentum(model_part)
-        total_energy = gravity_energy + kinematic_energy  # + elastic_energy
-
-        # Filling in the entries values corresponding to the entries names above
-        present_prop.append(time)
-        present_prop.append(mass)
-        present_prop.append(gravity_energy)
-        present_prop.append(kinematic_energy)
-        #present_prop.append(elastic_energy)
-        present_prop.append(momentum)
-        present_prop.append(angular_momentum)
-        present_prop.append(total_energy)
-
-        properties_list.append(present_prop)
-
-        return properties_list
-
-    def RemoveFoldersWithResults(self, main_path, problem_name, run_code=''):
-        shutil.rmtree(os.path.join(main_path, problem_name + '_Post_Files' + run_code), ignore_errors=True)
-        shutil.rmtree(os.path.join(main_path, problem_name + '_Graphs'), ignore_errors=True)
-
-        try:
-            file_to_remove = os.path.join(main_path, problem_name)+"DEM.time"
-            os.remove(file_to_remove)
-        except OSError:
-            pass
-        try:
-            file_to_remove = os.path.join(main_path, problem_name)+"DEM_Inlet.time"
-            os.remove(file_to_remove)
-        except OSError:
-            pass
-
-        try:
-            file_to_remove = os.path.join(main_path, problem_name)+"DEM_FEM_boundary.time"
-            os.remove(file_to_remove)
-        except OSError:
-            pass
-
-        try:
-            file_to_remove = os.path.join(main_path, problem_name)+"DEM_Clusters.time"
-            os.remove(file_to_remove)
-        except OSError:
-            pass
-
-        try:
-            file_to_remove = os.path.join(main_path, "TimesPartialRelease")
-            os.remove(file_to_remove)
-        except OSError:
-            pass
-
-        try:
-            file_to_remove = os.path.join(main_path, problem_name)+".post.lst"
-            os.remove(file_to_remove)
-        except OSError:
-            pass
-
-
-    def CreateDirectories(self, main_path, problem_name, run_code='', do_print_results=True):
-
-        root = os.path.join(main_path, problem_name)
-        post_path = root + '_Post_Files' + run_code
-        graphs_path = root + '_Graphs'
-
-        self.RemoveFoldersWithResults(main_path, problem_name, run_code)
-
-        if do_print_results:
-            for directory in [post_path, graphs_path]:
-                if not os.path.isdir(directory):
-                    os.makedirs(str(directory))
-
-        return [post_path, graphs_path]
-
-    def FindMaxNodeIdInModelPart(self, model_part):
-
-        maxid = 0
-
-        for node in model_part.Nodes:
-            if node.Id > maxid:
-                maxid = node.Id
-
-        return maxid
-
-    def SetBoundingBoxLimits(self, all_model_parts, creator_destructor):
-
-        bounding_box_time_limits = []
-        if self.DEM_parameters["BoundingBoxOption"].GetBool():
-            self.SetBoundingBox(all_model_parts.Get("SpheresPart"), all_model_parts.Get("ClusterPart"), all_model_parts.Get("RigidFacePart"), all_model_parts.Get("DEMInletPart"), creator_destructor)
-            bounding_box_time_limits = [self.solver.bounding_box_start_time, self.solver.bounding_box_stop_time]
-
-        return bounding_box_time_limits
-
-    def SetBoundingBox(self, spheres_model_part, clusters_model_part, rigid_faces_model_part, dem_inlet_model_part, creator_destructor):
-
-        b_box_low = Array3()
-        b_box_high = Array3()
-        b_box_low[0] = self.b_box_minX
-        b_box_low[1] = self.b_box_minY
-        b_box_low[2] = self.b_box_minZ
-        b_box_high[0] = self.b_box_maxX
-        b_box_high[1] = self.b_box_maxY
-        b_box_high[2] = self.b_box_maxZ
-        creator_destructor.SetLowNode(b_box_low)
-        creator_destructor.SetHighNode(b_box_high)
-        creator_destructor.CalculateSurroundingBoundingBox(spheres_model_part, clusters_model_part, rigid_faces_model_part, dem_inlet_model_part, self.bounding_box_enlargement_factor, self.automatic_bounding_box_OPTION)
-
-    def UpdateBoundingBox(self, spheres_model_part, creator_destructor):
-
-        time = spheres_model_part.ProcessInfo.GetValue(TIME)
-        move_velocity = self.DEM_parameters["BoundingBoxMoveVelocity"].GetDouble()
-        
-        b_box_low = Array3()
-        b_box_high = Array3()
-        b_box_low[0] = self.b_box_minX + time * move_velocity
-        b_box_low[1] = self.b_box_minY + time * move_velocity
-        b_box_low[2] = self.b_box_minZ + time * move_velocity
-        b_box_high[0] = self.b_box_maxX - time * move_velocity
-        b_box_high[1] = self.b_box_maxY - time * move_velocity
-        b_box_high[2] = self.b_box_maxZ - time * move_velocity
-        creator_destructor.SetLowNode(b_box_low)
-        creator_destructor.SetHighNode(b_box_high)
-        creator_destructor.UpdateSurroundingBoundingBox(spheres_model_part)
-    
-    def DeleteFiles(self):
-        files_to_delete_list = glob('*.time')
-        for to_erase_file in files_to_delete_list:
-            try:
-                os.remove(to_erase_file)
-            except OSError:
-                pass
-
-    def PreProcessModel(self, DEM_parameters):
-        pass
-
-    def CheckVariableType(self, var, expected_type, msg):   # TODO is this actually being used
-        actual_type = type(var)
-        if actual_type is int and expected_type is float:
-            return
-        if actual_type is not expected_type:
-            KratosPrintWarning(
-                "ERROR: Input parameter of wrong type in file 'DEM_explicit_solver_var.py'.")
-            a = str(expected_type)
-            b = str(var)
-            raise Exception("The type expected was " + a + " but " + b + " was read.")
-
-    def Flush(self, a):
-        a.flush()
-
-    def KratosPrintInfo(self, message):
-        Logger.PrintInfo(message, label="DEM")
-        Logger.Flush()
-
-    def KratosPrintWarning(self, message):
-        Logger.PrintWarning(message, label="DEM")
-        Logger.Flush()
-
-
-class DEMFEMProcedures():
-
-    def __init__(self, DEM_parameters, graphs_path, spheres_model_part, rigid_face_model_part):
-
-        # GLOBAL VARIABLES OF THE SCRIPT
-        self.DEM_parameters = DEM_parameters
-
-        if not "material_test_settings" in DEM_parameters.keys():
-            self.TestType = "None"
-        else:
-            self.TestType = self.DEM_parameters["material_test_settings"]["TestType"].GetString()
-
-        # Initialization of member variables
-        # SIMULATION FLAGS
-        # TODO: Why is this in DEM FEM Procs also?
-        self.rotation_OPTION = self.DEM_parameters["RotationOption"].GetBool()
-        self.bounding_box_OPTION = self.DEM_parameters["BoundingBoxOption"].GetBool()
-
-        # TODO: This is already in the Procedures object. why to repeat it?
-        self.contact_mesh_OPTION = False
-        if "ContactMeshOption" in self.DEM_parameters.keys():
-            self.contact_mesh_OPTION = self.DEM_parameters["ContactMeshOption"].GetBool()
-
-        self.graphs_path = graphs_path
-        self.spheres_model_part = spheres_model_part
-        self.rigid_face_model_part = rigid_face_model_part
-
-        self.fem_mesh_nodes = []
-
-        self.graph_counter = 1
-        self.balls_graph_counter = 0
-        self.additional_graphs_counter = 0
-
-        self.graph_frequency = int((self.DEM_parameters["GraphExportFreq"].GetDouble() / spheres_model_part.ProcessInfo.GetValue(DELTA_TIME))+1.0)
-        if self.graph_frequency < 1:
-            # that means it is not possible to print results with a higher frequency than the computations delta time
-            self.graph_frequency = 1
-
-
-        def Flush(self, a):
-            a.flush()
-
-        def open_graph_files(self, rigid_face_model_part):
-            for smp in self.rigid_face_model_part.SubModelParts:
-                if smp[FORCE_INTEGRATION_GROUP]:
-                    identifier = smp[IDENTIFIER]
-                    absolute_path_to_file = os.path.join(self.graphs_path, str(self.DEM_parameters["problem_name"].GetString()) + "_" + str(identifier) + "_force_graph.grf")
-                    self.graph_forces[identifier] = open(absolute_path_to_file, 'w')
-                    self.graph_forces[identifier].write(str("#time").rjust(12) + " " + str("total_force[0]").rjust(13) + " " + str("total_force[1]").rjust(13) + " " + str("total_force[2]").rjust(13) + " " + str("total_moment[0]").rjust(13) + " " + str("total_moment[1]").rjust(13) + " " + str("total_moment[2]").rjust(13) + "\n")
-
-        self.graph_forces = {}
-
-        def open_balls_graph_files(self, spheres_model_part):
-            for smp in self.spheres_model_part.SubModelParts:
-                if smp[FORCE_INTEGRATION_GROUP]:
-                    identifier = smp[IDENTIFIER]
-                    absolute_path_to_file = os.path.join(self.graphs_path, str(self.DEM_parameters["problem_name"].GetString()) + "_" + str(identifier) + "_particle_force_graph.grf")
-                    self.particle_graph_forces[identifier] = open(absolute_path_to_file, 'w')
-                    self.particle_graph_forces[identifier].write(str("#time").rjust(12) + " " + str("total_force_x").rjust(13) + " " + str("total_force_y").rjust(13) + " " + str("total_force_z").rjust(13) + "\n")
-
-        if not "print_CN_graph" in DEM_parameters.keys():
-            self.print_CN_graph = False
-        else:
-            self.print_CN_graph = self.DEM_parameters["print_CN_graph"].GetBool()
-
-        if self.print_CN_graph:
-            absolute_path_to_file = os.path.join(self.graphs_path, str(self.DEM_parameters["problem_name"].GetString()) + "_CN.grf")
-            self.CN_export = open(absolute_path_to_file, 'w')
-
-        def evaluate_computation_of_fem_results():
-
-            self.spheres_model_part.ProcessInfo.SetValue(COMPUTE_FEM_RESULTS_OPTION, 0)
-            elastic_forces = self.DEM_parameters["PostElasticForces"].GetBool()
-            tangential_elastic_forces = self.DEM_parameters["PostTangentialElasticForces"].GetBool()
-            dem_pressure = self.DEM_parameters["PostPressure"].GetBool()
-
-            if not "PostContactForces" in self.DEM_parameters.keys():
-                contact_forces = 0
-            else:
-                contact_forces = self.DEM_parameters["PostContactForces"].GetBool()
-
-            if not "PostShearStress" in self.DEM_parameters.keys():
-                shear_stress = 0
-            else:
-                shear_stress = self.DEM_parameters["PostShearStress"].GetBool()
-
-            if not "PostNodalArea" in self.DEM_parameters.keys():
-                dem_nodal_area = 0
-            else:
-                dem_nodal_area = self.DEM_parameters["PostNodalArea"].GetBool()
-
-            integration_groups = False
-
-            if self.rigid_face_model_part.NumberOfSubModelParts() > 0:
-                for smp in self.rigid_face_model_part.SubModelParts:
-                    if smp[FORCE_INTEGRATION_GROUP]:
-                        integration_groups = True
-                        break
-            if elastic_forces or contact_forces or dem_pressure or tangential_elastic_forces or shear_stress or dem_nodal_area or integration_groups:
-                self.spheres_model_part.ProcessInfo.SetValue(COMPUTE_FEM_RESULTS_OPTION, 1)
-
-        self.particle_graph_forces = {}
-
-        if self.TestType == "None":
-            open_graph_files(self, rigid_face_model_part)
-            open_balls_graph_files(self, spheres_model_part)
-
-        # SIMULATION SETTINGS
-        self.bounding_box_enlargement_factor = self.DEM_parameters["BoundingBoxEnlargementFactor"].GetDouble()
-
-        # MODEL
-        self.domain_size = self.DEM_parameters["Dimension"].GetInt()
-        evaluate_computation_of_fem_results()
-
-    def UpdateTimeInModelParts(self, all_model_parts, time, dt, step, is_time_to_print=False):
-
-        spheres_model_part = all_model_parts.Get("SpheresPart")
-        cluster_model_part = all_model_parts.Get("ClusterPart")
-        dem_inlet_model_part = all_model_parts.Get("DEMInletPart")
-        rigid_face_model_part = all_model_parts.Get("RigidFacePart")
-
-        self.UpdateTimeInOneModelPart(spheres_model_part, time, dt, step, is_time_to_print)
-        self.UpdateTimeInOneModelPart(cluster_model_part, time, dt, step, is_time_to_print)
-        self.UpdateTimeInOneModelPart(dem_inlet_model_part, time, dt, step, is_time_to_print)
-        self.UpdateTimeInOneModelPart(rigid_face_model_part, time, dt, step, is_time_to_print)
-
-    def UpdateTimeInOneModelPart(self, model_part, time, dt, step, is_time_to_print=False):
-        KratosPrintWarning('This method is deprecated, please use the new one from the sphere strategy.')
-        model_part.ProcessInfo[TIME] = time
-        model_part.ProcessInfo[DELTA_TIME] = dt
-        model_part.ProcessInfo[TIME_STEPS] = step
-        model_part.ProcessInfo[IS_TIME_TO_PRINT] = is_time_to_print
-
-    def close_graph_files(self, rigid_face_model_part):
-
-        for smp in self.rigid_face_model_part.SubModelParts:
-            if smp[FORCE_INTEGRATION_GROUP]:
-                identifier = smp[IDENTIFIER]
-                self.graph_forces[identifier].close()
-
-    def close_balls_graph_files(self, spheres_model_part):
-
-        for smp in self.spheres_model_part.SubModelParts:
-            if smp[FORCE_INTEGRATION_GROUP]:
-                identifier = smp[IDENTIFIER]
-                self.particle_graph_forces[identifier].close()
-
-    def PrintPoisson(self, model_part, DEM_parameters, filename, time):
-
-        if DEM_parameters["Dimension"].GetInt() == 3:
-            poisson, dummy, _ = PostUtilities().ComputePoisson(model_part)
-        else:
-            poisson, dummy, _ = PostUtilities().ComputePoisson2D(model_part)
-
-        file_open = open(filename, 'a')
-        data = str(time) + "  " + str(poisson) + "\n"
-        file_open.write(data)
-
-    def PrintGraph(self, time):
-
-        if self.TestType == "None":
-
-            if self.graph_counter == self.graph_frequency:
-                self.graph_counter = 0
-
-                for smp in self.rigid_face_model_part.SubModelParts:
-                    if smp[FORCE_INTEGRATION_GROUP]:
-                        mesh_nodes = smp.Nodes
-
-                        total_force = Array3()
-                        total_force[0] = 0.0
-                        total_force[1] = 0.0
-                        total_force[2] = 0.0
-
-                        total_moment = Array3()
-                        total_moment[0] = 0.0
-                        total_moment[1] = 0.0
-                        total_moment[2] = 0.0
-
-                        rotation_center = smp[ROTATION_CENTER]
-
-                        PostUtilities().IntegrationOfForces(mesh_nodes, total_force, rotation_center, total_moment)
-
-                        identifier = smp[IDENTIFIER]
-
-                        self.graph_forces[identifier].write(str("%.8g" % time).rjust(12) +
-                                                            " " + str("%.6g" % total_force[0]).rjust(13) + " " + str("%.6g" % total_force[1]).rjust(13) +
-                                                            " " + str("%.6g" % total_force[2]).rjust(13) + " " + str("%.6g" % total_moment[0]).rjust(13) +
-                                                            " " + str("%.6g" % total_moment[1]).rjust(13) + " " + str("%.6g" % total_moment[2]).rjust(13) + "\n")
-                        self.graph_forces[identifier].flush()
-
-            self.graph_counter += 1
-
-    def FinalizeGraphs(self, rigid_face_model_part):
-
-        if self.TestType == "None":
-            self.close_graph_files(rigid_face_model_part)
-
-    def PrintAdditionalGraphs(self, time, solver):
-
-        if self.additional_graphs_counter == self.graph_frequency:
-            self.additional_graphs_counter = 0
-            if self.print_CN_graph:
-                dummy = 0
-                CN = solver.cplusplus_strategy.ComputeCoordinationNumber(dummy)
-                self.CN_export.write(str("%.13g"%time).rjust(14) + "  " + str("%.11g"%CN).rjust(12) + '\n')
-                self.CN_export.flush()
-        self.additional_graphs_counter += 1
-
-    def PrintBallsGraph(self, time):
-
-        if self.TestType == "None":
-
-            if self.balls_graph_counter == self.graph_frequency:
-                self.balls_graph_counter = 0
-
-                for smp in self.spheres_model_part.SubModelParts:
-                    if smp[FORCE_INTEGRATION_GROUP]:
-                        mesh_nodes = smp.Nodes
-
-                        total_force = Array3()
-                        total_force[0] = 0.0
-                        total_force[1] = 0.0
-                        total_force[2] = 0.0
-
-                        PostUtilities().IntegrationOfElasticForces(mesh_nodes, total_force)
-
-                        identifier = smp[IDENTIFIER]
-                        self.particle_graph_forces[identifier].write(str("%.8g" % time).rjust(12) + " " + str("%.6g" % total_force[0]).rjust(13) + " " + str("%.6g" % total_force[1]).rjust(13) + " " + str("%.6g" % total_force[2]).rjust(13) + "\n")
-                        self.particle_graph_forces[identifier].flush()
-
-            self.balls_graph_counter += 1
-
-    def FinalizeBallsGraphs(self, spheres_model_part):
-
-        if self.TestType == "None":
-            self.close_balls_graph_files(spheres_model_part)
-
-    def ApplyNodalRotation(self, time):
-
-            #if (time < 0.5e-2 ) :
-        if time < 3.8e-5:
-
-            #while (time < self.DEM_parameters["FinalTime"].GetDouble()):
-            #print("TIME STEP BEGINS.  STEP:"+str(time)+"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
-
-            d0 = 1.694
-            avance = 0.50100
-            distance = (d0 - avance)
-            w = 62.8
-            distance = 2
-
-            vx = -distance * w * math.sin(w * time)
-            #vx = distance * rpm * math.cos(1.0)
-            vy = distance * w * math.cos(w * time)
-            #vz = - distance * rpm * math.sin(1.0)
-
-            for smp in self.spheres_model_part.SubModelParts:
-                if smp[FORCE_INTEGRATION_GROUP]:
-                    self.mesh_nodes = smp.Nodes
-
-                    for node in self.mesh_nodes:
-                        node.SetSolutionStepValue(VELOCITY_X, vx)
-                        node.SetSolutionStepValue(VELOCITY_Y, vy)
-                        node.Fix(VELOCITY_X)
-                        node.Fix(VELOCITY_Y)
-        else:
-
-            d0 = 1.694
-            avance = 0.50100
-            distance = (d0 - avance)
-            w = 62.8
-            distance = 2
-
-            vx = -distance * w * math.sin(w * time)
-            #vx = distance * rpm * math.cos(1.0)
-            vy = distance * w * math.cos(w * time)
-            #vz = - distance * rpm * math.sin(1.0)
-            radius = 1.0001
-
-            for smp in self.spheres_model_part.SubModelParts:
-                if smp[FORCE_INTEGRATION_GROUP]:
-                    self.mesh_nodes = smp.Nodes
-
-                for node in self.mesh_nodes:
-                    node.SetSolutionStepValue(RADIUS, radius)
-
-            for smp in self.spheres_model_part.SubModelParts:
-                if smp[FORCE_INTEGRATION_GROUP]:
-                    self.mesh_nodes = smp.Nodes
-
-                    for node in self.mesh_nodes:
-                        node.SetSolutionStepValue(VELOCITY_X, vx)
-                        node.SetSolutionStepValue(VELOCITY_Y, vy)
-                        node.Fix(VELOCITY_X)
-                        node.Fix(VELOCITY_Y)
-
-
-class Report():
-
-    def __init__(self):
-        pass
-
-    def Prepare(self, timer, control_time):
-        self.initial_pr_time = timer.process_time()
-        self.initial_re_time = timer.time()
-        self.prev_time = 0.0
-        self.total_steps_expected = 0
-        self.control_time = control_time
-        self.first_print = True
-
-    def BeginReport(self, timer):
-        label = "DEM: "
-        report = label + "Total number of time steps expected in the calculation: " + str(self.total_steps_expected) + "\n\n"
-        return report
-
-    def StepiReport(self, timer, time, step):
-
-        incremental_time = (timer.time() - self.initial_re_time) - self.prev_time
-        report = ""
-        label = "DEM: "
-
-        if incremental_time > self.control_time:
-            percentage = 100 * (float(step) / self.total_steps_expected)
-            elapsed_time = timer.time() - self.initial_re_time
-
-            report = report + label + "Elapsed real time: " + str(round(elapsed_time, 5)) + " seconds" + "\n"\
-                            + label + "In minutes: " + str(round(elapsed_time / 60.0, 2)) + " minutes" + "\n"\
-                            + label + "In hours: " + str(round(elapsed_time / 3600.0, 3)) + " hours" + "\n"\
-                            + label + "Simulation time: " + str(time) + " seconds" + "\n"\
-                            + label + "%s %.5f %s" % ("Percentage Completed: ", percentage, "%") + "\n"\
-                            + label + "Computed time steps: " + str(step) + " out of " + str(self.total_steps_expected) + "\n" + label
-
-            self.prev_time = (timer.time() - self.initial_re_time)
-
-        if (timer.time() - self.initial_re_time > 60) and self.first_print and step != 0:
-            self.first_print = False
-            estimated_sim_duration = 60.0 * (self.total_steps_expected / step)  # seconds
-
-            report = report + "\n" + label + "****** The total estimated computation time is " + str(estimated_sim_duration) + " seconds" + "\n"\
-                + label + "****** In minutes: " + str(round(estimated_sim_duration / 60.0, 2)) + " minutes" + "\n"\
-                + label + "****** In hours: " + str(round(estimated_sim_duration / 3600.0, 3)) + " hours" + "\n"\
-                + label + "****** In days: " + str(round(estimated_sim_duration / 86400.0, 3)) + " days" + "\n" + label
-
-        return report
-
-    def FinalReport(self, timer):
-        elapsed_pr_time = timer.process_time() - self.initial_pr_time
-        elapsed_re_time = timer.time() - self.initial_re_time
-        label = "DEM: "
-
-        report = label + "Elapsed processing time (sum across cores): " + str(elapsed_pr_time) + " seconds\n"\
-                + label + "Elapsed real time (wall time): " + str(elapsed_re_time) + " seconds\n" + label
-
-        report = report + "\n" + label + "ANALYSIS COMPLETED"
-
-        return report
-
-
-class PreUtils():
-
-    def __init__(self):
-        pass
-
-class MultifileList():
-
-    def __init__(self, post_path, name, step, which_folder):
-        self.index = 0
-        self.step = step
-        self.name = name
-        self.which_folder = which_folder
-        if which_folder == "inner":
-            absolute_path_to_file = os.path.join(post_path, "_list_" + self.name + "_" + str(step) + ".post.lst")
-        else:
-            absolute_path_to_file = os.path.join(post_path, self.name + ".post.lst")
-
-        self.file = open(absolute_path_to_file, "w")
-
-class DEMIo():
-
-    def __init__(self, model, DEM_parameters, post_path, all_model_parts):
-
-        self.model = model
-
-        self.post_path = post_path
-        self.mixed_model_part = model.CreateModelPart("Mixed_Part")
-        self.mixed_spheres_and_clusters_model_part = model.CreateModelPart("MixedSpheresAndClustersPart")
-        self.mixed_spheres_not_in_cluster_and_clusters_model_part = model.CreateModelPart("MixedSpheresNotInClusterAndClustersPart")
-
-        self.spheres_model_part = all_model_parts.Get("SpheresPart")
-        self.cluster_model_part = all_model_parts.Get("ClusterPart")
-        self.rigid_face_model_part = all_model_parts.Get("RigidFacePart")
-        self.contact_model_part = all_model_parts.Get("ContactPart")
-        self.mapping_model_part = all_model_parts.Get("MappingPart")
-
-        # Printing variables
-        self.DEM_parameters = DEM_parameters
-        self.global_variables = []
-        self.global_nonhistorical_nodal_variables = []
-        self.spheres_and_clusters_variables = []
-        self.spheres_and_clusters_local_axis_variables = []
-        self.spheres_not_in_cluster_and_clusters_variables = []
-        self.spheres_not_in_cluster_and_clusters_local_axis_variables = []
-        self.spheres_variables = []
-        self.spheres_local_axis_variables = []
-        self.fem_boundary_variables = []
-        self.clusters_variables = []
-        self.rigid_body_variables = []
-        self.contact_variables = []
-        self.multifilelists = []
-
-        # Reading Post options from DEM_parameters
-        self.PostDisplacement = self.DEM_parameters["PostDisplacement"].GetBool()
-        self.PostVelocity = self.DEM_parameters["PostVelocity"].GetBool()
-        self.PostTotalForces = self.DEM_parameters["PostTotalForces"].GetBool()
-        self.PostNonDimensionalVolumeWear = self.DEM_parameters["PostNonDimensionalVolumeWear"].GetBool()
-        self.PostAppliedForces = self.DEM_parameters["PostAppliedForces"].GetBool()
-        self.PostDampForces = self.DEM_parameters["PostDampForces"].GetBool()
-        self.PostRadius = self.DEM_parameters["PostRadius"].GetBool()
-        self.PostGroupId = GetBoolParameterIfItExists(self.DEM_parameters, "PostGroupId")
-        self.PostExportId = self.DEM_parameters["PostExportId"].GetBool()
-        self.PostSkinSphere = GetBoolParameterIfItExists(self.DEM_parameters, "PostSkinSphere")
-        self.PostGluedSphere = GetBoolParameterIfItExists(self.DEM_parameters, "PostGluedSphere")
-        self.PostAngularVelocity = self.DEM_parameters["PostAngularVelocity"].GetBool()
-        self.PostParticleMoment = self.DEM_parameters["PostParticleMoment"].GetBool()
-        self.PostEulerAngles = self.DEM_parameters["PostEulerAngles"].GetBool()
-        self.PostRollingResistanceMoment = self.DEM_parameters["PostRollingResistanceMoment"].GetBool()
-        self.PostLocalContactForce = GetBoolParameterIfItExists(self.DEM_parameters, "PostLocalContactForce")
-        self.PostFailureCriterionState = GetBoolParameterIfItExists(self.DEM_parameters, "PostFailureCriterionState")
-        self.PostContactFailureId = GetBoolParameterIfItExists(self.DEM_parameters, "PostContactFailureId")
-        self.PostContactTau = GetBoolParameterIfItExists(self.DEM_parameters, "PostContactTau")
-        self.PostContactSigma = GetBoolParameterIfItExists(self.DEM_parameters, "PostContactSigma")
-        self.PostMeanContactArea = GetBoolParameterIfItExists(self.DEM_parameters, "PostMeanContactArea")
-        self.PostContactRadius = GetBoolParameterIfItExists(self.DEM_parameters, "PostContactRadius")
-        self.PostElasticForces = self.DEM_parameters["PostElasticForces"].GetBool()
-        self.PostContactForces = self.DEM_parameters["PostContactForces"].GetBool()
-        self.PostRigidElementForces = self.DEM_parameters["PostRigidElementForces"].GetBool()
-        self.PostPressure = self.DEM_parameters["PostPressure"].GetBool()
-        self.PostTangentialElasticForces = self.DEM_parameters["PostTangentialElasticForces"].GetBool()
-        self.PostShearStress = self.DEM_parameters["PostShearStress"].GetBool()
-        self.PostNodalArea = self.DEM_parameters["PostNodalArea"].GetBool()
-        self.PostNeighbourSize = GetBoolParameterIfItExists(self.DEM_parameters, "PostNeighbourSize")
-        self.PostDamageRatio = GetBoolParameterIfItExists(self.DEM_parameters, "PostDamageRatio")
-        self.PostNormalImpactVelocity = GetBoolParameterIfItExists(self.DEM_parameters, "PostNormalImpactVelocity")
-        self.PostTangentialImpactVelocity = GetBoolParameterIfItExists(self.DEM_parameters, "PostTangentialImpactVelocity")
-        self.PostControlModule = GetBoolParameterIfItExists(self.DEM_parameters, "PostControlModule")
-        self.VelTrapGraphExportFreq = self.DEM_parameters["VelTrapGraphExportFreq"].GetDouble()
-        if not "PostDeltaDisplacement" in self.DEM_parameters.keys():
-            self.PostDeltaDisplacement = False
-        else:
-            self.PostDeltaDisplacement = self.DEM_parameters["PostDeltaDisplacement"].GetBool()
-        if not "PostCharacteristicLength" in self.DEM_parameters.keys():
-            self.PostCharacteristicLength = 0
-        else:
-            self.PostCharacteristicLength = self.DEM_parameters["PostCharacteristicLength"].GetBool()
-
-        #self.PostFaceNormalImpactVelocity = GetBoolParameterIfItExists(self.DEM_parameters, "PostFaceNormalImpactVelocity", 0)
-        #self.PostFaceTangentialImpactVelocity = GetBoolParameterIfItExists(self.DEM_parameters, "PostFaceTangentialImpactVelocity", 0)
-
-        if not "PostBoundingBox" in self.DEM_parameters.keys():
-            self.PostBoundingBox = 0
-        else:
-            self.PostBoundingBox = self.DEM_parameters["PostBoundingBox"].GetBool()
-
-        #self.automatic_bounding_box_option = Var_Translator(self.DEM_parameters["AutomaticBoundingBoxOption"].GetBool())
-        #self.b_box_minX = self.DEM_parameters["BoundingBoxMinX"].GetDouble()
-        #self.b_box_minY = self.DEM_parameters["BoundingBoxMinY"].GetDouble()
-        #self.b_box_minZ = self.DEM_parameters["BoundingBoxMinZ"].GetDouble()
-        #self.b_box_maxX = self.DEM_parameters["BoundingBoxMaxX"].GetDouble()
-        #self.b_box_maxY = self.DEM_parameters["BoundingBoxMaxY"].GetDouble()
-        #self.b_box_maxZ = self.DEM_parameters["BoundingBoxMaxZ"].GetDouble()
-
-        self.continuum_element_types = ["SphericContPartDEMElement3D", "CylinderContPartDEMElement2D", "IceContPartDEMElement3D"]
-
-        self.OpenMultiFileLists()
-
-        #Analytic
-        if not "PostNormalImpactVelocity" in self.DEM_parameters.keys():
-            self.PostNormalImpactVelocity = 0
-        else:
-            self.PostNormalImpactVelocity = self.DEM_parameters["PostNormalImpactVelocity"].GetBool()
-
-        if not "PostTangentialImpactVelocity" in self.DEM_parameters.keys():
-            self.PostTangentialImpactVelocity = 0
-        else:
-            self.PostTangentialImpactVelocity = self.DEM_parameters["PostTangentialImpactVelocity"].GetBool()
-
-        if not "PostFaceNormalImpactVelocity" in self.DEM_parameters.keys():
-            self.PostFaceNormalImpactVelocity = 0
-        else:
-            self.PostFaceNormalImpactVelocity = self.DEM_parameters["PostFaceNormalImpactVelocity"].GetBool()
-
-        if not "PostFaceTangentialImpactVelocity" in self.DEM_parameters.keys():
-            self.PostFaceTangentialImpactVelocity = 0
-        else:
-            self.PostFaceTangentialImpactVelocity = self.DEM_parameters["PostFaceTangentialImpactVelocity"].GetBool()
-
-        # Ice
-        self.sea_settings = self.DEM_parameters["virtual_sea_surface_settings"]
-
-        if self.sea_settings["print_sea_surface"].GetBool():
-            self.SeaSurfaceX1 = self.sea_settings["PostVirtualSeaSurfaceX1"].GetDouble()
-            self.SeaSurfaceY1 = self.sea_settings["PostVirtualSeaSurfaceY1"].GetDouble()
-            self.SeaSurfaceX2 = self.sea_settings["PostVirtualSeaSurfaceX2"].GetDouble()
-            self.SeaSurfaceY2 = self.sea_settings["PostVirtualSeaSurfaceY2"].GetDouble()
-            self.SeaSurfaceX3 = self.sea_settings["PostVirtualSeaSurfaceX3"].GetDouble()
-            self.SeaSurfaceY3 = self.sea_settings["PostVirtualSeaSurfaceY3"].GetDouble()
-            self.SeaSurfaceX4 = self.sea_settings["PostVirtualSeaSurfaceX4"].GetDouble()
-            self.SeaSurfaceY4 = self.sea_settings["PostVirtualSeaSurfaceY4"].GetDouble()
-
-    def OpenMultiFileLists(self):
-        one_level_up_path = os.path.join(self.post_path, "..")
-        self.multifiles = (
-            MultifileList(one_level_up_path, self.DEM_parameters["problem_name"].GetString(), 1, "outer"),
-            MultifileList(self.post_path, self.DEM_parameters["problem_name"].GetString(), 1, "inner"),
-            MultifileList(self.post_path, self.DEM_parameters["problem_name"].GetString(), 2, "inner"),
-            MultifileList(self.post_path, self.DEM_parameters["problem_name"].GetString(), 5, "inner"),
-            MultifileList(self.post_path, self.DEM_parameters["problem_name"].GetString(), 10, "inner"),
-            MultifileList(self.post_path, self.DEM_parameters["problem_name"].GetString(), 20, "inner"),
-            MultifileList(self.post_path, self.DEM_parameters["problem_name"].GetString(), 50, "inner"),
-        )
-        self.SetMultifileLists(self.multifiles)
-
-    def KratosPrintInfo(self, message):
-        Logger.PrintInfo(message, label="DEM")
-        Logger.Flush()
-
-    def Flush(self, a):
-        a.flush()
-
-    def ShowPrintingResultsOnScreen(self, all_model_parts, format_name):
-        self.KratosPrintInfo("*******************  PRINTING RESULTS FOR {}  ***************************".format(format_name))
-        self.KratosPrintInfo("                        (" + str(all_model_parts.Get("SpheresPart").NumberOfElements(0)) + " elements)")
-        self.KratosPrintInfo("                        (" + str(all_model_parts.Get("SpheresPart").NumberOfNodes(0)) + " nodes)")
-        self.KratosPrintInfo("")
-
-    def Initialize(self, DEM_parameters):
-        self.AddGlobalVariables()
-        self.AddGlobalNonHistoricalNodalVariables()
-        self.AddSpheresVariables()
-        self.AddSpheresAndClustersVariables()
-        self.AddSpheresNotInClusterAndClustersVariables()
-        self.AddFEMBoundaryVariables()
-        self.AddClusterVariables()
-        self.AddRigidBodyVariables()
-        self.AddContactVariables()
-        self.AddMpiVariables()
-        self.Configure(DEM_parameters["problem_name"].GetString(), DEM_parameters["OutputFileType"].GetString(), DEM_parameters["Multifile"].GetString(), DEM_parameters["ContactMeshOption"].GetBool())
-        self.SetOutputName(DEM_parameters["problem_name"].GetString())
-
-    def PushPrintVar(self, variable, name, print_list):
-        if Var_Translator(variable):
-            print_list.append(name)
-
-    def AddGlobalVariables(self):
-        self.PushPrintVar(self.PostDisplacement, DISPLACEMENT, self.global_variables)
-        self.PushPrintVar(self.PostVelocity, VELOCITY, self.global_variables)
-        self.PushPrintVar(self.PostTotalForces, TOTAL_FORCES, self.global_variables)
-        self.PushPrintVar(self.PostContactForces, CONTACT_FORCES, self.global_variables)
-        self.PushPrintVar(self.PostAppliedForces, EXTERNAL_APPLIED_FORCE, self.global_variables)
-        self.PushPrintVar(self.PostAppliedForces, EXTERNAL_APPLIED_MOMENT, self.global_variables)
-        if self.DEM_parameters["PostAngularVelocity"].GetBool():
-            self.PushPrintVar(self.PostAngularVelocity, ANGULAR_VELOCITY, self.global_variables)
-        if self.DEM_parameters["PostParticleMoment"].GetBool():
-            self.PushPrintVar(self.PostParticleMoment, PARTICLE_MOMENT, self.global_variables)
-        self.PushPrintVar(self.PostDeltaDisplacement, DELTA_DISPLACEMENT, self.global_variables)
-
-    def AddGlobalNonHistoricalNodalVariables(self):
-        self.PushPrintVar(self.PostControlModule, TARGET_STRESS, self.global_nonhistorical_nodal_variables)
-        self.PushPrintVar(self.PostControlModule, REACTION_STRESS, self.global_nonhistorical_nodal_variables)
-        self.PushPrintVar(self.PostControlModule, SMOOTHED_REACTION_STRESS, self.global_nonhistorical_nodal_variables)
-        self.PushPrintVar(self.PostControlModule, ELASTIC_REACTION_STRESS, self.global_nonhistorical_nodal_variables)
-        self.PushPrintVar(self.PostControlModule, SMOOTHED_ELASTIC_REACTION_STRESS, self.global_nonhistorical_nodal_variables)
-        self.PushPrintVar(self.PostControlModule, LOADING_VELOCITY, self.global_nonhistorical_nodal_variables)
-
-
-    def AddSpheresAndClustersVariables(self):  # variables common to spheres and clusters
-        self.PushPrintVar(self.PostRigidElementForces, RIGID_ELEMENT_FORCE, self.spheres_and_clusters_variables)
-
-    # variables common to spheres and clusters
-    def AddSpheresNotInClusterAndClustersVariables(self):
-        if self.DEM_parameters["PostEulerAngles"].GetBool():
-            self.PushPrintVar(self.PostEulerAngles, EULER_ANGLES, self.spheres_not_in_cluster_and_clusters_local_axis_variables)
-
-    def AddSpheresVariables(self):
-        self.PushPrintVar(self.PostDampForces, DAMP_FORCES, self.spheres_variables)
-        self.PushPrintVar(self.PostRadius, RADIUS, self.spheres_variables)
-        self.PushPrintVar(self.PostExportId, EXPORT_ID, self.spheres_variables)
-        self.PushPrintVar(self.PostNormalImpactVelocity, NORMAL_IMPACT_VELOCITY, self.spheres_variables)
-        self.PushPrintVar(self.PostTangentialImpactVelocity, TANGENTIAL_IMPACT_VELOCITY, self.spheres_variables)
-        self.PushPrintVar(self.PostFaceNormalImpactVelocity, FACE_NORMAL_IMPACT_VELOCITY, self.spheres_variables)
-        self.PushPrintVar(self.PostFaceTangentialImpactVelocity, FACE_TANGENTIAL_IMPACT_VELOCITY, self.spheres_variables)
-
-        
-        if "PostRollingResistanceMoment" in self.DEM_parameters.keys():
-            if self.DEM_parameters["RotationOption"].GetBool():
-                if self.DEM_parameters["RollingFrictionOption"].GetBool():
-                    self.PushPrintVar(self.PostRollingResistanceMoment, ROLLING_RESISTANCE_MOMENT, self.spheres_variables)
-
-        if "PostSkinSphere" in self.DEM_parameters.keys():
-            if self.DEM_parameters["PostSkinSphere"].GetBool():
-                self.PushPrintVar(self.PostSkinSphere, SKIN_SPHERE, self.spheres_variables)
-
-        if "PostNeighbourSize" in self.DEM_parameters.keys():
-            if self.DEM_parameters["PostNeighbourSize"].GetBool():
-                self.PushPrintVar(self.PostNeighbourSize, NEIGHBOUR_SIZE, self.spheres_variables)
-
-        if "PostDamageRatio" in self.DEM_parameters.keys():
-            if self.DEM_parameters["PostDamageRatio"].GetBool():
-                self.PushPrintVar(self.PostDamageRatio, DAMAGE_RATIO, self.spheres_variables)
-
-        if self.PostGluedSphere:
-            self.PushPrintVar(self.PostGluedSphere, IS_STICKY, self.spheres_variables)
-
-        # NANO (TODO: must be removed from here.)
-        if self.DEM_parameters["ElementType"].GetString() == "SwimmingNanoParticle":
-            self.PushPrintVar(self.PostHeatFlux, CATION_CONCENTRATION, self.spheres_variables)
-
-        if "PostStressStrainOption" in self.DEM_parameters.keys():
-            if self.DEM_parameters["PostStressStrainOption"].GetBool():
-                self.PushPrintVar(1, REPRESENTATIVE_VOLUME, self.spheres_variables)
-                self.PushPrintVar(1, DEM_STRESS_TENSOR, self.spheres_variables)
-                self.PushPrintVar(1, DEM_STRAIN_TENSOR, self.spheres_variables)
-                self.PushPrintVar(1, DEM_DIFFERENTIAL_STRAIN_TENSOR, self.spheres_variables)
-
-        if "PostReactions" in self.DEM_parameters.keys():
-            if self.DEM_parameters["PostReactions"].GetBool():
-                self.PushPrintVar(1, FORCE_REACTION, self.spheres_variables)
-                self.PushPrintVar(1, MOMENT_REACTION, self.spheres_variables)
-
-        if "PostPoissonRatio" in self.DEM_parameters.keys():
-            if self.DEM_parameters["PostPoissonRatio"].GetBool():
-                self.PushPrintVar(1, POISSON_VALUE, self.spheres_variables)
-
-        if "PostGroupId" in self.DEM_parameters.keys():
-            if self.DEM_parameters["PostGroupId"].GetBool():
-                self.PushPrintVar(self.PostGroupId, GROUP_ID, self.spheres_variables)
-
-    def AddFEMBoundaryVariables(self):
-        self.PushPrintVar(self.PostElasticForces, ELASTIC_FORCES, self.fem_boundary_variables)
-        self.PushPrintVar(self.PostPressure, DEM_PRESSURE, self.fem_boundary_variables)
-        self.PushPrintVar(self.PostTangentialElasticForces, TANGENTIAL_ELASTIC_FORCES, self.fem_boundary_variables)
-        self.PushPrintVar(self.PostShearStress, SHEAR_STRESS, self.fem_boundary_variables)
-        self.PushPrintVar(self.PostNodalArea, DEM_NODAL_AREA, self.fem_boundary_variables)
-        if Var_Translator(self.PostNonDimensionalVolumeWear):
-            self.PushPrintVar(1, NON_DIMENSIONAL_VOLUME_WEAR, self.fem_boundary_variables)
-            self.PushPrintVar(1, IMPACT_WEAR, self.fem_boundary_variables)
-
-    def AddClusterVariables(self):
-        if self.PostCharacteristicLength:
-            self.PushPrintVar(self.PostCharacteristicLength, CHARACTERISTIC_LENGTH, self.clusters_variables)
-
-    def AddRigidBodyVariables(self):
-        pass
-
-    def AddContactVariables(self):
-        # Contact Elements Variables
-        if self.DEM_parameters["ContactMeshOption"].GetBool():
-            self.PushPrintVar(self.PostLocalContactForce, LOCAL_CONTACT_FORCE, self.contact_variables)
-            if self.DEM_parameters["ElementType"].GetString() in self.continuum_element_types:
-                self.PushPrintVar(self.PostFailureCriterionState, FAILURE_CRITERION_STATE, self.contact_variables)
-                self.PushPrintVar(self.PostContactFailureId, CONTACT_FAILURE, self.contact_variables)
-                self.PushPrintVar(self.PostContactTau, CONTACT_TAU, self.contact_variables)
-                self.PushPrintVar(self.PostContactSigma, CONTACT_SIGMA, self.contact_variables)
-                self.PushPrintVar(self.PostMeanContactArea, MEAN_CONTACT_AREA, self.contact_variables)
-                self.PushPrintVar(self.PostContactRadius, CONTACT_RADIUS, self.contact_variables)
-
-    def AddMpiVariables(self):
-        pass
-
-    def Configure(self, problem_name, encoding, file_system, contact_mesh_option):
-        self.problem_name = problem_name
-
-        if encoding == "Binary":
-            self.encoding = GiDPostMode.GiD_PostBinary
-        else:
-            self.encoding = GiDPostMode.GiD_PostAscii
-
-        if self.DEM_parameters["Multifile"].GetString() == "multiple_files":
-            self.filesystem = MultiFileFlag.MultipleFiles
-        else:
-            self.filesystem = MultiFileFlag.SingleFile
-
-        self.deformed_mesh_flag = WriteDeformedMeshFlag.WriteDeformed
-        self.write_conditions = WriteConditionsFlag.WriteConditions
-        self.contact_mesh_option = contact_mesh_option
-
-        problem_name = os.path.join(self.post_path, self.problem_name)
-        self.gid_io = GidIO(problem_name,
-                            self.encoding,
-                            self.filesystem,
-                            self.deformed_mesh_flag,
-                            self.write_conditions)
-
-        self.post_utility = PostUtilities()
-
-    def SetOutputName(self, name):
-        problem_name = os.path.join(self.post_path, self.problem_name)
-        self.gid_io.ChangeOutputName(problem_name)
-
-    def SetMultifileLists(self, multifile_list):
-        for mfilelist in multifile_list:
-            self.multifilelists.append(mfilelist)
-
-        for mfilelist in self.multifilelists:
-            mfilelist.file.write("Multiple\n")
-            mfilelist.index = 1
-
-    def PrintMultifileLists(self, time, post_path):
-        for mfilelist in self.multifilelists:
-
-            if mfilelist.index == mfilelist.step:
-
-                if self.encoding == GiDPostMode.GiD_PostBinary:
-                    text_to_print = self.GetMultiFileListName(mfilelist.name) + "_" + "%.12g" % time + ".post.bin\n"
-                    if mfilelist.which_folder == "outer":
-                        path_of_file = os.path.dirname(mfilelist.file.name)
-                        text_to_print = os.path.join(os.path.relpath(
-                            post_path, path_of_file), text_to_print)
-                    mfilelist.file.write(text_to_print)
-                else:
-                    text_to_print1 = self.GetMultiFileListName(mfilelist.name) + "_" + "%.12g" % time + ".post.msh\n"
-                    text_to_print2 = self.GetMultiFileListName(mfilelist.name) + "_" + "%.12g" % time + ".post.res\n"
-                    if mfilelist.which_folder == "outer":
-                        path_of_file = os.path.dirname(mfilelist.file.name)
-                        text_to_print1 = os.path.join(os.path.relpath(post_path, path_of_file), text_to_print1)
-                        text_to_print2 = os.path.join(os.path.relpath(post_path, path_of_file), text_to_print2)
-                    mfilelist.file.write(text_to_print1)
-                    mfilelist.file.write(text_to_print2)
-                self.Flush(mfilelist.file)
-                mfilelist.index = 0
-
-            mfilelist.index += 1
-
-    def GetMultiFileListName(self, name):
-        return name
-
-    def CloseMultifiles(self):
-        for mfilelist in self.multifilelists:
-            mfilelist.file.close()
-
-    def AddModelPartsToMixedModelPart(self):
-        self.post_utility.AddModelPartToModelPart(self.mixed_model_part, self.spheres_model_part)
-        if self.contact_mesh_option:
-            self.post_utility.AddModelPartToModelPart(self.mixed_model_part, self.contact_model_part)
-        self.post_utility.AddModelPartToModelPart(self.mixed_model_part, self.rigid_face_model_part)
-        self.post_utility.AddModelPartToModelPart(self.mixed_model_part, self.cluster_model_part)
-        self.post_utility.AddModelPartToModelPart(self.mixed_spheres_and_clusters_model_part, self.spheres_model_part)
-        self.post_utility.AddModelPartToModelPart(self.mixed_spheres_and_clusters_model_part, self.cluster_model_part)
-
-        self.post_utility.AddSpheresNotBelongingToClustersToMixModelPart(self.mixed_spheres_not_in_cluster_and_clusters_model_part, self.spheres_model_part)
-        self.post_utility.AddModelPartToModelPart(self.mixed_spheres_not_in_cluster_and_clusters_model_part, self.cluster_model_part)
-
-    def InitializeMesh(self, all_model_parts):
-        if self.filesystem == MultiFileFlag.SingleFile:
-            self.AddModelPartsToMixedModelPart()
-            self.gid_io.InitializeMesh(0.0)
-            self.gid_io.WriteMesh(all_model_parts.Get("RigidFacePart").GetCommunicator().LocalMesh())
-            self.gid_io.WriteClusterMesh(all_model_parts.Get("ClusterPart").GetCommunicator().LocalMesh())
-            if self.DEM_parameters["ElementType"].GetString() == "CylinderContPartDEMElement2D" or self.DEM_parameters["ElementType"].GetString() == "CylinderPartDEMElement2D":
-                self.gid_io.WriteCircleMesh(all_model_parts.Get("SpheresPart").GetCommunicator().LocalMesh())
-            else:
-                self.gid_io.WriteSphereMesh(all_model_parts.Get("SpheresPart").GetCommunicator().LocalMesh())
-
-            if self.contact_mesh_option:
-                self.gid_io.WriteMesh(all_model_parts.Get("ContactPart").GetCommunicator().LocalMesh())
-
-            self.gid_io.FinalizeMesh()
-            self.gid_io.InitializeResults(0.0, self.mixed_model_part.GetCommunicator().LocalMesh())
-            #self.gid_io.InitializeResults(0.0, mixed_spheres_and_clusters_model_part.GetCommunicator().LocalMesh())
-
-    def InitializeResults(self, spheres_model_part, rigid_face_model_part, cluster_model_part, contact_model_part, mapping_model_part, creator_destructor, dem_fem_search, time, bounding_box_time_limits):  # MIQUEL MAPPING
-
-        if self.filesystem == MultiFileFlag.MultipleFiles:
-            self.RemoveElementsAndNodes()
-            self.AddModelPartsToMixedModelPart()
-            self.gid_io.InitializeMesh(time)
-            if self.DEM_parameters["ElementType"].GetString() == "CylinderContPartDEMElement2D" or self.DEM_parameters["ElementType"].GetString() == "CylinderPartDEMElement2D":
-                self.gid_io.WriteCircleMesh(spheres_model_part.GetCommunicator().LocalMesh())
-            else:
-                self.gid_io.WriteSphereMesh(spheres_model_part.GetCommunicator().LocalMesh())
-
-            if self.contact_mesh_option:
-                #We overwrite the Id of the properties 0 not to overlap with other entities that use layer 0 for PRINTING
-                if contact_model_part.HasProperties(0):
-                    contact_model_part.GetProperties(0).Id = 9184
-                self.gid_io.WriteMesh(contact_model_part.GetCommunicator().LocalMesh())
-
-            self.gid_io.WriteMesh(rigid_face_model_part.GetCommunicator().LocalMesh())
-            self.gid_io.WriteClusterMesh(cluster_model_part.GetCommunicator().LocalMesh())
-
-            #Compute and print the graphical bounding box if active in time
-            if self.DEM_parameters["BoundingBoxOption"].GetBool() and (time >= bounding_box_time_limits[0] and time <= bounding_box_time_limits[1]):
-                self.ComputeAndPrintBoundingBox(spheres_model_part, rigid_face_model_part, contact_model_part, creator_destructor)
-
-            # Ice. Printing a virtual sea surface
-            if self.sea_settings["print_sea_surface"].GetBool():
-                self.ComputeAndPrintSeaSurface(spheres_model_part, rigid_face_model_part)
-
-            #self.ComputeAndPrintDEMFEMSearchBinBoundingBox(spheres_model_part, rigid_face_model_part, dem_fem_search)#MSIMSI
-
-            self.gid_io.FinalizeMesh()
-            self.gid_io.InitializeResults(time, self.mixed_model_part.GetCommunicator().LocalMesh())
-            #self.gid_io.InitializeResults(time, mixed_spheres_and_clusters_model_part.GetCommunicator().LocalMesh())
-
-    def FinalizeMesh(self):
-        if self.filesystem == MultiFileFlag.SingleFile:
-            self.gid_io.FinalizeResults()
-
-    def FinalizeResults(self):
-        if self.filesystem == MultiFileFlag.MultipleFiles:
-            self.gid_io.FinalizeResults()
-
-    def PrintingGlobalVariables(self, export_model_part, time):
-        for variable in self.global_variables:
-            self.gid_io.WriteNodalResults(variable, export_model_part.Nodes, time, 0)
-
-    def PrintingGlobalNonHistoricalNodalVariables(self, export_model_part, time):
-        for variable in self.global_nonhistorical_nodal_variables:
-            self.gid_io.WriteNodalResultsNonHistorical(variable, export_model_part.Nodes, time)
-
-    def PrintingSpheresAndClustersVariables(self, export_model_part, time):
-        for variable in self.spheres_and_clusters_variables:
-            self.gid_io.WriteNodalResults(variable, export_model_part.Nodes, time, 0)
-        for variable in self.spheres_and_clusters_local_axis_variables:
-            self.gid_io.WriteLocalAxesOnNodes(variable, export_model_part.Nodes, time, 0)
-
-    def PrintingSpheresNotInClusterAndClustersVariables(self, export_model_part, time):
-        for variable in self.spheres_not_in_cluster_and_clusters_variables:
-            self.gid_io.WriteNodalResults(variable, export_model_part.Nodes, time, 0)
-        for variable in self.spheres_not_in_cluster_and_clusters_local_axis_variables:
-            self.gid_io.WriteLocalAxesOnNodes(variable, export_model_part.Nodes, time, 0)
-
-    def PrintingSpheresVariables(self, export_model_part, time):
-        for variable in self.spheres_variables:
-            self.gid_io.WriteNodalResults(variable, export_model_part.Nodes, time, 0)
-        for variable in self.spheres_local_axis_variables:
-            self.gid_io.WriteLocalAxesOnNodes(variable, export_model_part.Nodes, time, 0)
-
-    def PrintingFEMBoundaryVariables(self, export_model_part, time):
-        for variable in self.fem_boundary_variables:
-            self.gid_io.WriteNodalResults(variable, export_model_part.Nodes, time, 0)
-
-    def PrintingClusterVariables(self, export_model_part, time):
-        for variable in self.clusters_variables:
-            self.gid_io.WriteNodalResults(variable, export_model_part.Nodes, time, 0)
-
-    def PrintingRigidBodyVariables(self, export_model_part, time):
-        for variable in self.rigid_body_variables:
-            self.gid_io.WriteNodalResults(variable, export_model_part.Nodes, time, 0)
-
-    def PrintingContactElementsVariables(self, export_model_part, time):
-        if self.contact_mesh_option:
-            for variable in self.contact_variables:
-                self.gid_io.PrintOnGaussPoints(variable, export_model_part, time)
-
-    def PrintResults(self, all_model_parts, creator_destructor, dem_fem_search, time, bounding_box_time_limits):
-
-        if self.filesystem == MultiFileFlag.MultipleFiles:
-            self.InitializeResults(self.spheres_model_part,
-                                   self.rigid_face_model_part,
-                                   self.cluster_model_part,
-                                   self.contact_model_part,
-                                   self.mapping_model_part,
-                                   creator_destructor,
-                                   dem_fem_search,
-                                   time,
-                                   bounding_box_time_limits)
-
-        self.PrintingGlobalVariables(self.mixed_model_part, time)
-        self.PrintingGlobalNonHistoricalNodalVariables(self.mixed_model_part, time)
-        self.PrintingSpheresAndClustersVariables(self.mixed_spheres_and_clusters_model_part, time)
-        self.PrintingSpheresNotInClusterAndClustersVariables(self.mixed_spheres_not_in_cluster_and_clusters_model_part, time)
-        self.PrintingSpheresVariables(self.spheres_model_part, time)
-        self.PrintingFEMBoundaryVariables(self.rigid_face_model_part, time)
-        self.PrintingRigidBodyVariables(self.rigid_face_model_part, time)
-        self.PrintingClusterVariables(self.cluster_model_part, time)
-        self.PrintingContactElementsVariables(self.contact_model_part, time)
-
-        self.RemoveElementsAndNodes()
-
-        if self.filesystem == MultiFileFlag.MultipleFiles:
-            self.FinalizeResults()
-
-    def RemoveElementsAndNodes(self):
-        self.mixed_model_part.Elements.clear()
-        self.mixed_model_part.Nodes.clear()
-        self.mixed_spheres_and_clusters_model_part.Elements.clear()
-        self.mixed_spheres_and_clusters_model_part.Nodes.clear()
-        self.mixed_spheres_not_in_cluster_and_clusters_model_part.Elements.clear()
-        self.mixed_spheres_not_in_cluster_and_clusters_model_part.Nodes.clear()
-
-    def ComputeAndPrintBoundingBox(self, spheres_model_part, rigid_face_model_part, contact_model_part, creator_destructor):
-
-        if self.PostBoundingBox:
-            # Creation of bounding box's model part
-            bounding_box_model_part = self.model.CreateModelPart("BoundingBoxPart")
-
-            max_node_Id = ParticleCreatorDestructor().FindMaxNodeIdInModelPart(spheres_model_part)
-            max_FEM_node_Id = ParticleCreatorDestructor().FindMaxNodeIdInModelPart(rigid_face_model_part)
-            max_element_Id = ParticleCreatorDestructor().FindMaxElementIdInModelPart(spheres_model_part)
-            max_FEM_element_Id = ParticleCreatorDestructor().FindMaxElementIdInModelPart(rigid_face_model_part)
-            max_contact_element_Id = ParticleCreatorDestructor().FindMaxElementIdInModelPart(contact_model_part)
-
-            if max_FEM_node_Id > max_node_Id:
-                max_node_Id = max_FEM_node_Id
-
-            if max_FEM_element_Id > max_element_Id:
-                max_element_Id = max_FEM_element_Id
-
-            if max_contact_element_Id > max_element_Id:
-                max_element_Id = max_contact_element_Id
-
-            BBMaxX = creator_destructor.GetHighNode()[0]
-            BBMaxY = creator_destructor.GetHighNode()[1]
-            BBMaxZ = creator_destructor.GetHighNode()[2]
-            BBMinX = creator_destructor.GetLowNode()[0]
-            BBMinY = creator_destructor.GetLowNode()[1]
-            BBMinZ = creator_destructor.GetLowNode()[2]
-
-            self.BuildGraphicalBoundingBox(bounding_box_model_part, max_node_Id, max_element_Id, BBMinX, BBMinY, BBMinZ, BBMaxX, BBMaxY, BBMaxZ)
-
-            self.gid_io.WriteMesh(bounding_box_model_part.GetCommunicator().LocalMesh())
-
-            self.model.DeleteModelPart("BoundingBoxPart")
-
-    def ComputeAndPrintSeaSurface(self, spheres_model_part, rigid_face_model_part):
-
-        # Creation of sea surface model part
-        sea_surface_model_part = ModelPart("SeaSurfacePart")
-
-        max_node_Id = ParticleCreatorDestructor().FindMaxNodeIdInModelPart(spheres_model_part)
-        max_FEM_node_Id = ParticleCreatorDestructor().FindMaxNodeIdInModelPart(rigid_face_model_part)
-        max_element_Id = ParticleCreatorDestructor().FindMaxElementIdInModelPart(spheres_model_part)
-        max_FEM_element_Id = ParticleCreatorDestructor().FindMaxElementIdInModelPart(rigid_face_model_part)
-
-        if max_FEM_node_Id > max_node_Id:
-            max_node_Id = max_FEM_node_Id
-
-        if max_FEM_element_Id > max_element_Id:
-            max_element_Id = max_FEM_element_Id
-
-        # Z = 0.0 as sea level. We will always assume this value
-        node1 = sea_surface_model_part.CreateNewNode(max_node_Id + 9, self.SeaSurfaceX1, self.SeaSurfaceY1, 0.0)
-        node2 = sea_surface_model_part.CreateNewNode(max_node_Id + 10, self.SeaSurfaceX2, self.SeaSurfaceY2, 0.0)
-        node3 = sea_surface_model_part.CreateNewNode(max_node_Id + 11, self.SeaSurfaceX3, self.SeaSurfaceY3, 0.0)
-        node4 = sea_surface_model_part.CreateNewNode(max_node_Id + 12, self.SeaSurfaceX4, self.SeaSurfaceY4, 0.0)
-
-        ''' Properties colours: 0 -> grey,        1 -> dark blue, 2 -> pink,       3 -> light blue,       4 -> dark red,    5 -> light green
-                                6 -> light brown, 7 -> red-brown, 8 -> dark brown, 9 -> dark green/blue, 10 -> dark purple'''
-
-        # Sea Surface Element, consisting in a quadrilateral. Property 3 corresponds to a light blue for water
-        sea_surface_model_part.CreateNewCondition("RigidFace3D4N", max_element_Id + 1, [node1.Id, node2.Id, node3.Id, node4.Id], Properties(3))
-
-        self.gid_io.WriteMesh(
-            sea_surface_model_part.GetCommunicator().LocalMesh())
-
-    def ComputeAndPrintDEMFEMSearchBinBoundingBox(self, spheres_model_part, rigid_face_model_part, dem_fem_search):
-
-        bounding_box_model_part = self.model.CreateModelPart("BoundingBoxPart")
-
-        max_node_Id = ParticleCreatorDestructor().FindMaxNodeIdInModelPart(spheres_model_part)
-        max_FEM_node_Id = ParticleCreatorDestructor().FindMaxNodeIdInModelPart(rigid_face_model_part)
-        max_element_Id = ParticleCreatorDestructor().FindMaxElementIdInModelPart(spheres_model_part)
-        max_FEM_element_Id = ParticleCreatorDestructor().FindMaxElementIdInModelPart(rigid_face_model_part)
-
-        if max_FEM_node_Id > max_node_Id:
-            max_node_Id = max_FEM_node_Id
-
-        if max_FEM_element_Id > max_element_Id:
-            max_element_Id = max_FEM_element_Id
-
-        BBMaxX = dem_fem_search.GetBBHighPoint()[0]
-        BBMaxY = dem_fem_search.GetBBHighPoint()[1]
-        BBMaxZ = dem_fem_search.GetBBHighPoint()[2]
-        BBMinX = dem_fem_search.GetBBLowPoint()[0]
-        BBMinY = dem_fem_search.GetBBLowPoint()[1]
-        BBMinZ = dem_fem_search.GetBBLowPoint()[2]
-
-        DX = (BBMaxX - BBMinX)
-        DY = (BBMaxY - BBMinY)
-        DZ = (BBMaxZ - BBMinZ)
-
-        #The cases with 0 thickness in one direction, a 10% of the shortest other two is given to the 0-thickness direction.
-        if DX == 0:
-            height = min(DY, DZ)
-            BBMinX = BBMinX - 0.05 * height
-            BBMaxX = BBMaxX + 0.05 * height
-        if DY == 0:
-            height = min(DX, DZ)
-            BBMinY = BBMinY - 0.05 * height
-            BBMaxY = BBMaxY + 0.05 * height
-        if DZ == 0:
-            height = min(DX, DY)
-            BBMinZ = BBMinZ - 0.05 * height
-            BBMaxZ = BBMaxZ + 0.05 * height
-
-        volume = DX * DY * DZ
-
-        if abs(volume) > 1e21:
-            BBMaxX = 0.0
-            BBMaxY = 0.0
-            BBMaxZ = 0.0
-            BBMinX = 0.0
-            BBMinY = 0.0
-            BBMinZ = 0.0
-
-        self.BuildGraphicalBoundingBox(bounding_box_model_part, max_node_Id, max_element_Id, BBMinX, BBMinY, BBMinZ, BBMaxX, BBMaxY, BBMaxZ)
-
-        self.model.DeleteModelPart("BoundingBoxPart")
-
-        #self.gid_io.WriteMesh(bounding_box_model_part.GetCommunicator().LocalMesh()) #BOUNDING BOX IMPLEMENTATION
-
-    def BuildGraphicalBoundingBox(self, bounding_box_model_part, max_node_Id, max_element_Id, BBMinX, BBMinY, BBMinZ, BBMaxX, BBMaxY, BBMaxZ):
-        # BB Nodes:
-        node1 = bounding_box_model_part.CreateNewNode(max_node_Id + 1, BBMinX, BBMinY, BBMinZ)
-        node2 = bounding_box_model_part.CreateNewNode(max_node_Id + 2, BBMaxX, BBMinY, BBMinZ)
-        node3 = bounding_box_model_part.CreateNewNode(max_node_Id + 3, BBMaxX, BBMaxY, BBMinZ)
-        node4 = bounding_box_model_part.CreateNewNode(max_node_Id + 4, BBMinX, BBMaxY, BBMinZ)
-        node5 = bounding_box_model_part.CreateNewNode(max_node_Id + 5, BBMinX, BBMinY, BBMaxZ)
-        node6 = bounding_box_model_part.CreateNewNode(max_node_Id + 6, BBMaxX, BBMinY, BBMaxZ)
-        node7 = bounding_box_model_part.CreateNewNode(max_node_Id + 7, BBMaxX, BBMaxY, BBMaxZ)
-        node8 = bounding_box_model_part.CreateNewNode(max_node_Id + 8, BBMinX, BBMaxY, BBMaxZ)
-
-        # BB Elements:
-        props = Properties(10000)
-        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 1, [node1.Id, node4.Id], props)
-        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 2, [node4.Id, node8.Id], props)
-        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 3, [node8.Id, node5.Id], props)
-        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 4, [node5.Id, node1.Id], props)
-        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 5, [node1.Id, node2.Id], props)
-        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 6, [node3.Id, node4.Id], props)
-        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 7, [node7.Id, node8.Id], props)
-        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 8, [node5.Id, node6.Id], props)
-        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 9, [node6.Id, node2.Id], props)
-        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 10, [node2.Id, node3.Id], props)
-        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 11, [node3.Id, node7.Id], props)
-        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 12, [node7.Id, node6.Id], props)
-
-
-
-class ParallelUtils():
-
-    def __init__(self):
-        pass
-
-    def Repart(self, spheres_model_part):
-        pass
-
-    def CalculateModelNewIds(self, spheres_model_part):
-        pass
-
-    def PerformInitialPartition(self, model_part):
-        pass
-
-    def SetCommunicator(self, spheres_model_part, model_part_io_spheres, spheres_mp_filename):
-        return [model_part_io_spheres, spheres_model_part]
-
-    def GetSearchStrategy(self, solver, model_part):
-        return solver.search_strategy
+import math
+import os
+import shutil
+import sys
+import weakref
+from glob import glob
+
+from KratosMultiphysics import *
+from KratosMultiphysics.DEMApplication import *
+import KratosMultiphysics.DEMApplication.DEM_material_test_script as DEM_material_test_script
+import KratosMultiphysics.DEMApplication.triaxial2d_test as triaxial2d_test
+
+def Flush(a):
+    a.flush()
+
+def KratosPrint(*args):
+    Logger.PrintInfo("This method is deprecated since 01/03/2019", label="DEM")
+    Logger.PrintInfo(*args, label="DEM")
+    Logger.Flush()
+
+def KratosPrintInfo(*args):
+    Logger.PrintInfo(*args, label="DEM")
+    Logger.Flush()
+
+def KratosPrintWarning(*args):
+    Logger.PrintWarning(*args, label="DEM")
+    Logger.Flush()
+
+
+def Var_Translator(variable):
+
+    if variable == "OFF" or variable == "0" or variable == 0:
+        variable = 0
+    else:
+        variable = 1
+
+    return variable
+
+
+def GetBoolParameterIfItExists(set_of_parameters, parameter_key):
+    if parameter_key in set_of_parameters.keys():
+        return set_of_parameters[parameter_key].GetBool()
+    return False
+
+
+class MdpaCreator():
+
+    def __init__(self, path, DEM_parameters):
+
+        self.DEM_parameters = DEM_parameters
+        self.current_path = path
+
+        # Creating necessary directories
+        self.post_mdpas = os.path.join(str(self.current_path), str(self.DEM_parameters["problem_name"].GetString()) + '_post_mdpas')
+        if not os.path.isdir(self.post_mdpas):
+            os.makedirs(str(self.post_mdpas))
+
+    def WriteMdpa(self, model_part):
+        time = model_part.ProcessInfo.GetValue(TIME)
+        absolute_path_to_file = os.path.join(self.post_mdpas, str(self.DEM_parameters["problem_name"].GetString()) + '_post_' + str(time) + '.mdpa')
+        mdpa = open(absolute_path_to_file, 'w')
+        mdpa.write('Begin ModelPartData' + '\n')
+        mdpa.write('//  VARIABLE_NAME value')
+        mdpa.write('End ModelPartData' + '\n' + '\n' + '\n' + '\n')
+        mdpa.write('Begin Nodes' + '\n')
+
+        for node in model_part.Nodes:
+            mdpa.write(str(node.Id) + ' ' + str(node.X) + ' ' + str(node.Y) + ' ' + str(node.Z) + '\n')
+        mdpa.write('End Nodes' + '\n' + '\n')
+
+        mdpa.write('Begin Elements SphericParticle3D' + '\n')
+        for element in model_part.Elements:
+            mdpa.write(str(element.Id) + ' ' + '1' + ' ' + str(element.GetNode(0).Id) + '\n')
+        mdpa.write('End Elements' + '\n' + '\n')
+
+        self.WriteVariableData(RADIUS, mdpa, model_part)
+        #self.WriteVariableData(VELOCITY_X, mdpa, model_part)
+        #self.WriteVariableData(VELOCITY_Y, mdpa, model_part)
+        #self.WriteVariableData(VELOCITY_Z, mdpa, model_part)
+
+    def WriteVariableData(self, variable_name, mdpa, model_part):
+
+        mdpa.write('Begin NodalData ' + str(variable_name) + '\n')
+        for node in model_part.Nodes:
+            mdpa.write(str(node.Id) + ' ' + str(0) + ' ' + str(node.GetSolutionStepValue(variable_name)) + '\n')
+        mdpa.write('End NodalData' + '\n' + '\n')
+
+
+class SetOfModelParts():
+    def __init__(self, model_parts_list):
+        self.MaxNodeId = 0
+        self.MaxElemId = 0
+        self.MaxCondId = 0
+
+        self.model_parts = dict()
+        self.mp_list = []
+        for mp in model_parts_list:
+            self.model_parts[mp.Name] = mp
+            self.mp_list.append(mp)
+
+        self.spheres_model_part = self.Get("SpheresPart")
+        self.rigid_face_model_part = self.Get("RigidFacePart")
+        self.cluster_model_part = self.Get("ClusterPart")
+        self.dem_inlet_model_part = self.Get("DEMInletPart")
+        self.mapping_model_part = self.Get("MappingPart")
+        self.contact_model_part = self.Get("ContactPart")
+
+    def ComputeMaxIds(self):
+
+        for mp in self.mp_list:
+            self.GetMaxIds(mp)
+
+    def GetMaxIds(self, model_part):
+
+        for node in model_part.Nodes:
+            self.MaxNodeId = max(self.MaxNodeId, node.Id)
+
+        for elem in model_part.Elements:
+            self.MaxElemId = max(self.MaxElemId, elem.Id)
+
+        for cond in model_part.Conditions:
+            self.MaxCondId = max(self.MaxCondId, cond.Id)
+
+    def Get(self, name):
+        return self.model_parts[name]
+
+    def Add(self, model_part, name=None):
+        if name is not None:
+            self.model_parts[name] = model_part
+        else:
+            self.model_parts[model_part.Name] = model_part
+
+        self.mp_list.append(model_part)
+
+
+class GranulometryUtils():
+
+    def __init__(self, domain_volume, model_part):
+
+        if domain_volume <= 0.0:
+            raise ValueError(
+                "Error: The input domain volume must be strictly positive!")
+
+        self.spheres_model_part = model_part
+        self.UpdateData(domain_volume)
+
+    def UpdateData(self, domain_volume):
+
+        self.physics_calculator = SphericElementGlobalPhysicsCalculator(self.spheres_model_part)
+        self.number_of_spheres = self.spheres_model_part.NumberOfElements(0)
+        self.solid_volume = self.physics_calculator.CalculateTotalVolume(self.spheres_model_part)
+        self.d_50 = self.physics_calculator.CalculateD50(self.spheres_model_part)
+
+        if self.number_of_spheres == 0:
+            self.spheres_per_area = 0.0
+        else:
+            self.spheres_per_area = domain_volume / self.number_of_spheres
+
+        self.voids_volume = domain_volume - self.solid_volume
+        self.global_porosity = self.voids_volume / domain_volume
+
+        self.PrintCurrentData()
+
+    def PrintCurrentData(self):
+
+        Logger.Print("number_of_spheres:", self.number_of_spheres, label="")
+        Logger.Print("solid volume:", self.solid_volume, label="")
+        Logger.Print("voids volume:", self.voids_volume, label="")
+        Logger.Print("global porosity:", self.global_porosity, label="")
+        Logger.Print("D50:", self.d_50, label="")
+        Logger.Print("spheres per area unit:", self.spheres_per_area, label="")
+        Logger.Print("")
+
+        granul_file = open('granulometry_data.txt', 'w')
+        granul_file.write("Number of spheres: " + str(self.number_of_spheres) + '\n')
+        granul_file.write("Solid volume: " + str(self.solid_volume) + '\n')
+        granul_file.write("Voids volume: " + str(self.voids_volume) + '\n')
+        granul_file.write("Global porosity: " + str(self.global_porosity) + '\n')
+        granul_file.write("D50: " + str(self.d_50) + '\n')
+        granul_file.write("Spheres per area unit: " + str(self.spheres_per_area) + '\n')
+        granul_file.close()
+
+class PostUtils():
+
+    def __init__(self, DEM_parameters, spheres_model_part):
+
+        self.DEM_parameters = DEM_parameters
+        self.spheres_model_part = spheres_model_part
+        self.post_utilities = PostUtilities()
+        self.vel_trap_graph_counter = 0
+        # TODO: change the name of VelTrapGraphExportFreq to VelTrapGraphExportTimeInterval
+        self.vel_trap_graph_frequency = int(self.DEM_parameters["VelTrapGraphExportFreq"].GetDouble() / spheres_model_part.ProcessInfo.GetValue(DELTA_TIME))
+        if self.vel_trap_graph_frequency < 1:
+            self.vel_trap_graph_frequency = 1 # that means it is not possible to print results with a higher frequency than the computations delta time
+
+        self.previous_vector_of_inner_nodes = []
+        self.previous_time = 0.0
+
+    def Flush(self, a):
+        a.flush()
+
+    def ComputeMeanVelocitiesInTrap(self, file_name, time_dem, graphs_path):
+
+        if self.DEM_parameters["VelocityTrapOption"].GetBool():
+            compute_flow = "ComputeFlow" in self.DEM_parameters.keys() and self.DEM_parameters["ComputeFlow"].GetBool()
+
+            self.vel_trap_graph_counter += 1
+
+            if self.vel_trap_graph_counter == self.vel_trap_graph_frequency:
+                self.vel_trap_graph_counter = 0
+                average_velocity = Array3()
+                low_point = Array3()
+
+                low_point[0] = self.DEM_parameters["VelocityTrapMinX"].GetDouble()
+                low_point[1] = self.DEM_parameters["VelocityTrapMinY"].GetDouble()
+                low_point[2] = self.DEM_parameters["VelocityTrapMinZ"].GetDouble()
+                high_point = Array3()
+                high_point[0] = self.DEM_parameters["VelocityTrapMaxX"].GetDouble()
+                high_point[1] = self.DEM_parameters["VelocityTrapMaxY"].GetDouble()
+                high_point[2] = self.DEM_parameters["VelocityTrapMaxZ"].GetDouble()
+
+                average_velocity = self.post_utilities.VelocityTrap(self.spheres_model_part, low_point, high_point)
+
+                if compute_flow:
+                    vector_of_inner_nodes = []
+                    for node in self.spheres_model_part.Nodes:
+                        if (node.X > low_point[0]) & (node.Y > low_point[1]) & (node.Z > low_point[2]) & (node.X < high_point[0]) & (node.Y < high_point[1]) & (node.Z < high_point[2]):
+                            vector_of_inner_nodes.append(node)
+
+                    crossing_spheres = 0
+                    crossing_volume = 0.0
+
+                    for node in vector_of_inner_nodes:
+                        id_found = False
+                        for previous_node in self.previous_vector_of_inner_nodes:
+                            if node.Id == previous_node.Id:
+                                id_found = True
+                                break
+                        # This only happens if None of the previous nodes were capable of setting id_found = True.
+                        if id_found is False:
+                            crossing_spheres = crossing_spheres + 1
+                            radius = node.GetSolutionStepValue(RADIUS)
+                            crossing_volume = crossing_volume + 4.0 / 3.0 * math.pi * radius * radius * radius
+
+                    time_between_measures = self.spheres_model_part.ProcessInfo.GetValue(TIME) - self.previous_time
+                    number_of_spheres_flow = float(crossing_spheres) / time_between_measures
+                    net_volume_flow = crossing_volume / time_between_measures
+
+                    self.previous_time = self.spheres_model_part.ProcessInfo.GetValue(TIME)
+                    self.previous_vector_of_inner_nodes = vector_of_inner_nodes
+
+                absolute_path_to_file = os.path.join(graphs_path, file_name)
+                f = open(absolute_path_to_file, 'a')
+                tmp = str(time_dem) + "   " + str(average_velocity[0]) + "   " + str(average_velocity[1]) + "   " + str(average_velocity[2])
+                if compute_flow:
+                    tmp = tmp + "   " + str(net_volume_flow) + "   " + str(number_of_spheres_flow)
+                tmp = tmp + "\n"
+
+                f.write(tmp)
+                self.Flush(f)
+
+    def PrintEulerAngles(self, spheres_model_part, cluster_model_part):
+        PostUtilities().ComputeEulerAngles(spheres_model_part, cluster_model_part)
+
+
+class DEMEnergyCalculator():
+
+    def __init__(self, DEM_parameters, spheres_model_part, cluster_model_part, graphs_path, energy_plot):
+
+        self.calculate_option = False
+
+        if "EnergyCalculationOption" in DEM_parameters.keys():
+            if DEM_parameters["EnergyCalculationOption"].GetBool():
+                self.calculate_option = True
+                self.DEM_parameters = DEM_parameters
+                self.SpheresModelPart = spheres_model_part
+                self.ClusterModelPart = cluster_model_part
+                absolute_path_to_file = os.path.join(graphs_path, energy_plot)
+                self.energy_plot = open(absolute_path_to_file, 'w')
+                self.SpheresEnergyUtil = SphericElementGlobalPhysicsCalculator(spheres_model_part)
+                self.ClusterEnergyUtil = SphericElementGlobalPhysicsCalculator(cluster_model_part)
+                self.PotentialEnergyReferencePoint = Array3()
+                self.PotentialEnergyReferencePoint[0] = self.DEM_parameters["PotentialEnergyReferencePointX"].GetDouble()
+                self.PotentialEnergyReferencePoint[1] = self.DEM_parameters["PotentialEnergyReferencePointY"].GetDouble()
+                self.PotentialEnergyReferencePoint[2] = self.DEM_parameters["PotentialEnergyReferencePointZ"].GetDouble()
+                self.translational_kinematic_energy = 0.0
+                self.rotational_kinematic_energy = 0.0
+                self.kinematic_energy = 0.0
+                self.gravitational_energy = 0.0
+                self.elastic_energy = 0.0
+                self.inelastic_frictional_energy = 0.0
+                self.inelastic_viscodamping_energy = 0.0
+                self.inelastic_rollingresistance_energy = 0.0
+                self.external_energy = 0.0
+                self.total_energy = 0.0
+                self.graph_frequency = int(self.DEM_parameters["GraphExportFreq"].GetDouble() / spheres_model_part.ProcessInfo.GetValue(DELTA_TIME))  # TODO: change the name GraphExportFreq to GraphExportTimeInterval
+                self.energy_graph_counter = 0
+                self.energy_plot.write(str("Time").rjust(9) + "   " + str("Trans kinematic energy").rjust(22) + "   " + str("Rot kinematic energy").rjust(20) + "   " + str("Kinematic energy").rjust(16) + "   " + str("Gravitational energy").rjust(20) + "   " + str("Elastic energy").rjust(14) + "   " + str("Frictional energy").rjust(16) + "   " + str("Viscodamping energy").rjust(19) + "   " + str("Rolling resistance energy").rjust(25) + "   " + str("Total energy").rjust(12) + "\n")
+
+    def CalculateEnergyAndPlot(self, time):
+        if self.calculate_option:
+            if self.energy_graph_counter == self.graph_frequency:
+                self.energy_graph_counter = 0
+                self.CalculateEnergy()
+                self.PlotEnergyGraph(time)
+
+            self.energy_graph_counter += 1
+
+    def CalculateEnergy(self):
+
+        self.translational_kinematic_energy = self.SpheresEnergyUtil.CalculateTranslationalKinematicEnergy(self.SpheresModelPart) + self.ClusterEnergyUtil.CalculateTranslationalKinematicEnergy(self.ClusterModelPart)
+        self.rotational_kinematic_energy = self.SpheresEnergyUtil.CalculateRotationalKinematicEnergy(self.SpheresModelPart) + self.ClusterEnergyUtil.CalculateRotationalKinematicEnergy(self.ClusterModelPart)
+        self.kinematic_energy = self.translational_kinematic_energy + self.rotational_kinematic_energy
+        self.gravitational_energy = self.SpheresEnergyUtil.CalculateGravitationalPotentialEnergy(self.SpheresModelPart, self.PotentialEnergyReferencePoint) + self.ClusterEnergyUtil.CalculateGravitationalPotentialEnergy(self.ClusterModelPart, self.PotentialEnergyReferencePoint)
+        self.elastic_energy = self.SpheresEnergyUtil.CalculateElasticEnergy(self.SpheresModelPart) + self.ClusterEnergyUtil.CalculateElasticEnergy(self.ClusterModelPart)
+        self.inelastic_frictional_energy = self.SpheresEnergyUtil.CalculateInelasticFrictionalEnergy(self.SpheresModelPart) + self.ClusterEnergyUtil.CalculateInelasticFrictionalEnergy(self.ClusterModelPart)
+        self.inelastic_viscodamping_energy = self.SpheresEnergyUtil.CalculateInelasticViscodampingEnergy(self.SpheresModelPart) + self.ClusterEnergyUtil.CalculateInelasticViscodampingEnergy(self.ClusterModelPart)
+        self.inelastic_rollingresistance_energy = self.SpheresEnergyUtil.CalculateInelasticRollingResistanceEnergy(self.SpheresModelPart) + self.ClusterEnergyUtil.CalculateInelasticRollingResistanceEnergy(self.ClusterModelPart)
+        self.total_energy = self.kinematic_energy + self.gravitational_energy + self.elastic_energy + self.inelastic_frictional_energy + self.inelastic_viscodamping_energy + self.inelastic_rollingresistance_energy
+
+    def PlotEnergyGraph(self, time):
+
+        plot_kinematic = self.kinematic_energy
+        plot_translational_kinematic = self.translational_kinematic_energy
+        plot_rotational_kinematic = self.rotational_kinematic_energy
+        plot_gravitational = self.gravitational_energy
+        plot_elastic = self.elastic_energy
+        plot_inelastic_frictional = self.inelastic_frictional_energy
+        plot_inelastic_viscodamping = self.inelastic_viscodamping_energy
+        plot_inelastic_rollingresistance = self.inelastic_rollingresistance_energy
+        plot_total = self.total_energy
+        self.energy_plot.write(str("%.8g" % time).rjust(9) + "   " + str("%.6g" % plot_translational_kinematic).rjust(22) + "   " + str("%.6g" % plot_rotational_kinematic).rjust(20) + "   " + str("%.6g" % plot_kinematic).rjust(16) + "   " + str("%.6g"%plot_gravitational).rjust(20) + "   " + str("%.6g" % plot_elastic).rjust(14) + "   " + str("%.6g" % plot_inelastic_frictional).rjust(16) + "   " + str("%.6g" % plot_inelastic_viscodamping).rjust(19) + "   " + str("%.6g" % plot_inelastic_rollingresistance).rjust(23) + "   " + str("%.6g" % plot_total).rjust(12) + '\n')
+        self.energy_plot.flush()
+
+    def FinalizeEnergyPlot(self):
+        if self.calculate_option:
+            self.energy_plot.close
+
+
+class Procedures():
+
+    def __init__(self, DEM_parameters):
+
+        # GLOBAL VARIABLES OF THE SCRIPT
+        # Defining list of skin particles (For a test tube of height 30 cm and diameter 15 cm)
+
+        # Initialization of member variables
+        self.DEM_parameters = DEM_parameters
+
+        # SIMULATION FLAGS
+        self.rotation_OPTION = self.DEM_parameters["RotationOption"].GetBool()
+        self.bounding_box_OPTION = self.DEM_parameters["BoundingBoxOption"].GetBool()
+        self.automatic_bounding_box_OPTION = self.DEM_parameters["AutomaticBoundingBoxOption"].GetBool()
+
+        self.contact_mesh_OPTION = False
+        if "ContactMeshOption" in self.DEM_parameters.keys():
+            self.contact_mesh_OPTION = self.DEM_parameters["ContactMeshOption"].GetBool()
+
+        # SIMULATION SETTINGS
+        self.b_box_minX = self.DEM_parameters["BoundingBoxMinX"].GetDouble()
+        self.b_box_minY = self.DEM_parameters["BoundingBoxMinY"].GetDouble()
+        self.b_box_minZ = self.DEM_parameters["BoundingBoxMinZ"].GetDouble()
+        self.b_box_maxX = self.DEM_parameters["BoundingBoxMaxX"].GetDouble()
+        self.b_box_maxY = self.DEM_parameters["BoundingBoxMaxY"].GetDouble()
+        self.b_box_maxZ = self.DEM_parameters["BoundingBoxMaxZ"].GetDouble()
+        self.bounding_box_enlargement_factor = self.DEM_parameters["BoundingBoxEnlargementFactor"].GetDouble()
+
+        # MODEL
+        self.domain_size = self.DEM_parameters["Dimension"].GetInt()
+
+    def Barrier(self):
+        pass
+
+    def SetTranslationalScheme(self):
+        if self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Forward_Euler':
+            translational_scheme = ForwardEulerScheme()
+        elif self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Symplectic_Euler':
+            translational_scheme = SymplecticEulerScheme()
+        elif self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Taylor_Scheme':
+            translational_scheme = TaylorScheme()
+        elif self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Velocity_Verlet':
+            translational_scheme = VelocityVerletScheme()
+        else:
+            raise Exception('Error: selected translational integration scheme not defined. Please select a different scheme')
+        return translational_scheme
+
+    def SetRotationalScheme(self):
+        if self.DEM_parameters["RotationalIntegrationScheme"].GetString() == 'Direct_Integration':
+            if self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Forward_Euler':
+                rotational_scheme = ForwardEulerScheme()
+            elif self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Symplectic_Euler':
+                rotational_scheme = SymplecticEulerScheme()
+            elif self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Taylor_Scheme':
+                rotational_scheme = TaylorScheme()
+            elif self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Velocity_Verlet':
+                rotational_scheme = VelocityVerletScheme()
+        elif self.DEM_parameters["RotationalIntegrationScheme"].GetString() == 'Runge_Kutta':
+            rotational_scheme = RungeKuttaScheme()
+        elif self.DEM_parameters["RotationalIntegrationScheme"].GetString() == 'Quaternion_Integration':
+            rotational_scheme = QuaternionIntegrationScheme()
+        else:
+            raise Exception('Error: selected rotational integration scheme not defined. Please select a different scheme')
+        return rotational_scheme
+
+    def AddAllVariablesInAllModelParts(self, solver, translational_scheme, rotational_scheme, all_model_parts, DEM_parameters):
+
+        spheres_model_part = all_model_parts.Get('SpheresPart')
+        cluster_model_part = all_model_parts.Get('ClusterPart')
+        dem_inlet_model_part = all_model_parts.Get('DEMInletPart')
+        rigid_face_model_part = all_model_parts.Get('RigidFacePart')
+
+        self.solver = weakref.proxy(solver)
+        self.translational_scheme = weakref.proxy(translational_scheme)
+        self.rotational_scheme = weakref.proxy(rotational_scheme)
+        self.AddCommonVariables(spheres_model_part, DEM_parameters)
+        self.AddSpheresVariables(spheres_model_part, DEM_parameters)
+        self.AddMpiVariables(spheres_model_part)
+        self.solver.AddAdditionalVariables(spheres_model_part, DEM_parameters)
+        self.AddCommonVariables(cluster_model_part, DEM_parameters)
+        self.AddClusterVariables(cluster_model_part, DEM_parameters)
+        self.AddMpiVariables(cluster_model_part)
+        self.AddCommonVariables(dem_inlet_model_part, DEM_parameters)
+        self.AddSpheresVariables(dem_inlet_model_part, DEM_parameters)
+        self.solver.AddAdditionalVariables(dem_inlet_model_part, DEM_parameters)
+        self.AddCommonVariables(rigid_face_model_part, DEM_parameters)
+        self.AddRigidFaceVariables(rigid_face_model_part, DEM_parameters)
+        self.AddMpiVariables(rigid_face_model_part)
+
+    def AddCommonVariables(self, model_part, DEM_parameters):
+        model_part.AddNodalSolutionStepVariable(VELOCITY)
+        model_part.AddNodalSolutionStepVariable(DISPLACEMENT)
+        model_part.AddNodalSolutionStepVariable(DELTA_DISPLACEMENT)
+        model_part.AddNodalSolutionStepVariable(TOTAL_FORCES)
+        model_part.AddNodalSolutionStepVariable(CONTACT_FORCES)
+
+    def AddSpheresVariables(self, model_part, DEM_parameters):
+
+        # KINEMATIC
+        # TODO: only if self.DEM_parameters-RotationOption! Check that no one accesses them in c++ without checking the rotation option
+        model_part.AddNodalSolutionStepVariable(DELTA_ROTATION)
+        # TODO: only if self.DEM_parameters-RotationOption! Check that no one accesses them in c++ without checking the rotation option
+        model_part.AddNodalSolutionStepVariable(PARTICLE_ROTATION_ANGLE)
+        # TODO: only if self.DEM_parameters-RotationOption! Check that no one accesses them in c++ without checking the rotation option
+        model_part.AddNodalSolutionStepVariable(ANGULAR_VELOCITY)
+        model_part.AddNodalSolutionStepVariable(LOCAL_ANGULAR_VELOCITY)
+        model_part.AddNodalSolutionStepVariable(NORMAL_IMPACT_VELOCITY)
+        model_part.AddNodalSolutionStepVariable(TANGENTIAL_IMPACT_VELOCITY)
+        # TODO: only if self.DEM_parameters-RotationOption! Check that no one accesses them in c++ without checking the rotation option
+        model_part.AddNodalSolutionStepVariable(ORIENTATION)
+        model_part.AddNodalSolutionStepVariable(ANGULAR_MOMENTUM)
+        model_part.AddNodalSolutionStepVariable(FACE_NORMAL_IMPACT_VELOCITY)
+        model_part.AddNodalSolutionStepVariable(FACE_TANGENTIAL_IMPACT_VELOCITY)
+        model_part.AddNodalSolutionStepVariable(LINEAR_IMPULSE)
+        # ****************** Quaternion Integration BEGIN ******************
+        # TODO: only if self.DEM_parameters-RotationOption! Check that no one accesses them in c++ without checking the rotation option
+        model_part.AddNodalSolutionStepVariable(LOCAL_AUX_ANGULAR_VELOCITY)
+        # TODO: only if self.DEM_parameters-RotationOption! Check that no one accesses them in c++ without checking the rotation option
+        model_part.AddNodalSolutionStepVariable(AUX_ORIENTATION)
+        # ******************* Quaternion Integration END *******************
+
+        # FORCES
+        model_part.AddNodalSolutionStepVariable(ELASTIC_FORCES)
+        model_part.AddNodalSolutionStepVariable(LOCAL_CONTACT_FORCE)
+        model_part.AddNodalSolutionStepVariable(RIGID_ELEMENT_FORCE)
+        model_part.AddNodalSolutionStepVariable(DAMP_FORCES)
+        # TODO: only if self.DEM_parameters-RotationOption! Check that no one accesses them in c++ without checking the rotation option
+        model_part.AddNodalSolutionStepVariable(PARTICLE_MOMENT)
+        model_part.AddNodalSolutionStepVariable(EXTERNAL_APPLIED_FORCE)
+        model_part.AddNodalSolutionStepVariable(EXTERNAL_APPLIED_MOMENT)
+        model_part.AddNodalSolutionStepVariable(FORCE_REACTION)
+        model_part.AddNodalSolutionStepVariable(MOMENT_REACTION)
+
+        # BASIC PARTICLE PROPERTIES
+        model_part.AddNodalSolutionStepVariable(RADIUS)
+        model_part.AddNodalSolutionStepVariable(NODAL_MASS)
+        model_part.AddNodalSolutionStepVariable(REPRESENTATIVE_VOLUME)
+        model_part.AddNodalSolutionStepVariable(NEIGHBOUR_SIZE)
+        model_part.AddNodalSolutionStepVariable(DAMAGE_RATIO)
+
+        # ROTATION RELATED PROPERTIES
+        if self.DEM_parameters["RotationOption"].GetBool():
+            # TODO: only if self.DEM_parameters-RotationOption! Check that no one accesses them in c++ without checking the rotation option
+            model_part.AddNodalSolutionStepVariable(PARTICLE_MOMENT_OF_INERTIA)
+            model_part.AddNodalSolutionStepVariable(PRINCIPAL_MOMENTS_OF_INERTIA)
+            # TODO: only if self.DEM_parameters-RotationOption! Check that no one accesses them in c++ without checking the rotation option
+            model_part.AddNodalSolutionStepVariable(PARTICLE_ROTATION_DAMP_RATIO)
+            if self.DEM_parameters["RollingFrictionOption"].GetBool():
+                model_part.AddNodalSolutionStepVariable(ROLLING_RESISTANCE_MOMENT)
+
+        # OTHER PROPERTIES
+        model_part.AddNodalSolutionStepVariable(PARTICLE_MATERIAL)   # Colour defined in GiD
+
+        if "PostSkinSphere" in self.DEM_parameters.keys():
+            if self.DEM_parameters["PostSkinSphere"].GetBool():
+                model_part.AddNodalSolutionStepVariable(SKIN_SPHERE)
+
+        if "PostGluedSphere" in self.DEM_parameters.keys():
+            model_part.AddNodalSolutionStepVariable(IS_STICKY)
+
+        # LOCAL AXIS
+        if DEM_parameters["PostEulerAngles"].GetBool():
+            model_part.AddNodalSolutionStepVariable(EULER_ANGLES)
+
+        if "PostStressStrainOption" in self.DEM_parameters.keys():
+            if self.DEM_parameters["PostStressStrainOption"].GetBool():
+                model_part.AddNodalSolutionStepVariable(DEM_STRESS_TENSOR)
+                model_part.AddNodalSolutionStepVariable(DEM_STRAIN_TENSOR)
+                model_part.AddNodalSolutionStepVariable(DEM_DIFFERENTIAL_STRAIN_TENSOR)
+
+        if self.solver.poisson_ratio_option:
+            model_part.AddNodalSolutionStepVariable(POISSON_VALUE)
+
+        # Nano Particle
+        if self.DEM_parameters["ElementType"].GetString() == "SwimmingNanoParticle":
+            model_part.AddNodalSolutionStepVariable(CATION_CONCENTRATION)
+            model_part.AddNodalSolutionStepVariable(DRAG_COEFFICIENT)
+
+        # ONLY VISUALIZATION
+        if self.DEM_parameters["PostExportId"].GetBool():  # TODO: add suffix Option
+            model_part.AddNodalSolutionStepVariable(EXPORT_ID)
+
+        # ONLY VISUALIZATION
+        if "PostGroupId" in self.DEM_parameters.keys():
+            if self.DEM_parameters["PostGroupId"].GetBool(): 
+                model_part.AddNodalSolutionStepVariable(GROUP_ID)
+
+        #model_part.AddNodalSolutionStepVariable(SPRAYED_MATERIAL)
+
+    def AddRigidFaceVariables(self, model_part, DEM_parameters):
+
+        model_part.AddNodalSolutionStepVariable(ELASTIC_FORCES)
+        model_part.AddNodalSolutionStepVariable(DEM_PRESSURE)
+        model_part.AddNodalSolutionStepVariable(TANGENTIAL_ELASTIC_FORCES)
+        model_part.AddNodalSolutionStepVariable(SHEAR_STRESS)
+        model_part.AddNodalSolutionStepVariable(DEM_NODAL_AREA)
+        model_part.AddNodalSolutionStepVariable(NON_DIMENSIONAL_VOLUME_WEAR)
+        model_part.AddNodalSolutionStepVariable(IMPACT_WEAR)
+        model_part.AddNodalSolutionStepVariable(PARTICLE_ROTATION_ANGLE)
+        model_part.AddNodalSolutionStepVariable(DELTA_ROTATION)
+        model_part.AddNodalSolutionStepVariable(ANGULAR_VELOCITY)
+        model_part.AddNodalSolutionStepVariable(LOCAL_ANGULAR_VELOCITY)
+        model_part.AddNodalSolutionStepVariable(LOCAL_AUX_ANGULAR_VELOCITY)
+        model_part.AddNodalSolutionStepVariable(ORIENTATION)
+        model_part.AddNodalSolutionStepVariable(AUX_ORIENTATION)
+        model_part.AddNodalSolutionStepVariable(ANGULAR_MOMENTUM)
+
+        # FORCES
+        model_part.AddNodalSolutionStepVariable(RIGID_ELEMENT_FORCE)
+        model_part.AddNodalSolutionStepVariable(PARTICLE_MOMENT)
+        model_part.AddNodalSolutionStepVariable(EXTERNAL_APPLIED_FORCE)
+        model_part.AddNodalSolutionStepVariable(EXTERNAL_APPLIED_MOMENT)
+
+        # PHYSICAL PROPERTIES
+        model_part.AddNodalSolutionStepVariable(PRINCIPAL_MOMENTS_OF_INERTIA)
+        model_part.AddNodalSolutionStepVariable(CLUSTER_VOLUME)
+        model_part.AddNodalSolutionStepVariable(NODAL_MASS)
+        model_part.AddNodalSolutionStepVariable(CHARACTERISTIC_LENGTH)
+        model_part.AddNodalSolutionStepVariable(PARTICLE_DENSITY)
+
+    def AddElasticFaceVariables(self, model_part, DEM_parameters): #Only used in CSM coupling
+        self.AddRigidFaceVariables(model_part, self.DEM_parameters)
+        model_part.AddNodalSolutionStepVariable(TOTAL_FORCES)
+
+    def AddClusterVariables(self, model_part, DEM_parameters):
+        # KINEMATIC
+        model_part.AddNodalSolutionStepVariable(PARTICLE_ROTATION_ANGLE)
+        model_part.AddNodalSolutionStepVariable(DELTA_ROTATION)
+        model_part.AddNodalSolutionStepVariable(ANGULAR_VELOCITY)
+        model_part.AddNodalSolutionStepVariable(LOCAL_ANGULAR_VELOCITY)
+        model_part.AddNodalSolutionStepVariable(ORIENTATION)
+        model_part.AddNodalSolutionStepVariable(ANGULAR_MOMENTUM)
+        # ****************** Quaternion Integration BEGIN ******************
+        model_part.AddNodalSolutionStepVariable(LOCAL_AUX_ANGULAR_VELOCITY)
+        model_part.AddNodalSolutionStepVariable(AUX_ORIENTATION)
+        # ******************* Quaternion Integration END *******************
+
+        # FORCES
+        model_part.AddNodalSolutionStepVariable(TOTAL_FORCES)
+        model_part.AddNodalSolutionStepVariable(RIGID_ELEMENT_FORCE)
+        model_part.AddNodalSolutionStepVariable(PARTICLE_MOMENT)
+        model_part.AddNodalSolutionStepVariable(EXTERNAL_APPLIED_FORCE)
+        model_part.AddNodalSolutionStepVariable(EXTERNAL_APPLIED_MOMENT)
+
+        # PHYSICAL PROPERTIES
+        model_part.AddNodalSolutionStepVariable(PRINCIPAL_MOMENTS_OF_INERTIA)
+        model_part.AddNodalSolutionStepVariable(CLUSTER_VOLUME)
+        model_part.AddNodalSolutionStepVariable(NODAL_MASS)
+        model_part.AddNodalSolutionStepVariable(CHARACTERISTIC_LENGTH)
+        model_part.AddNodalSolutionStepVariable(PARTICLE_DENSITY)
+
+        # OTHER PROPERTIES
+        model_part.AddNodalSolutionStepVariable(PARTICLE_MATERIAL)   # Colour defined in GiD
+
+        # LOCAL AXIS
+        if DEM_parameters["PostEulerAngles"].GetBool():
+            model_part.AddNodalSolutionStepVariable(EULER_ANGLES)
+
+    def AddMpiVariables(self, model_part):
+        pass
+
+    def SetInitialNodalValues(self, spheres_model_part, cluster_model_part, dem_inlet_model_part, rigid_face_model_part):
+        pass
+
+    def SetUpBufferSizeInAllModelParts(self, spheres_model_part, spheres_b_size, cluster_model_part, clusters_b_size, dem_inlet_model_part, inlet_b_size, rigid_face_model_part, rigid_b_size):
+        spheres_model_part.SetBufferSize(spheres_b_size)
+        cluster_model_part.SetBufferSize(clusters_b_size)
+        dem_inlet_model_part.SetBufferSize(inlet_b_size)
+        rigid_face_model_part.SetBufferSize(rigid_b_size)
+
+    def FindMaxNodeIdAccrossModelParts(self, creator_destructor, all_model_parts):
+
+        max_candidates = []
+        max_candidates.append(creator_destructor.FindMaxNodeIdInModelPart(all_model_parts.Get("SpheresPart")))
+        max_candidates.append(creator_destructor.FindMaxElementIdInModelPart(all_model_parts.Get("SpheresPart")))
+        max_candidates.append(creator_destructor.FindMaxNodeIdInModelPart(all_model_parts.Get("RigidFacePart")))
+        max_candidates.append(creator_destructor.FindMaxNodeIdInModelPart(all_model_parts.Get("ClusterPart")))
+
+        return max(max_candidates)
+
+    def ModelData(self, spheres_model_part, solver):
+
+        contact_model_part = solver.contact_model_part
+        # Previous Calculations.
+        Model_Data = open('Model_Data.txt', 'w')
+
+        # mean radius, and standard deviation:
+        i = 0.0
+        sum_radi = 0.0
+        partial_sum_squared = 0.0
+        total_sum_squared = 0.0
+        volume = 0.0
+        area = 0.0
+        mean = 0.0
+        var = 0.0
+        rel_std_dev = 0.0
+
+        for node in spheres_model_part.Nodes:
+
+            sum_radi += node.GetSolutionStepValue(RADIUS)
+            partial_sum_squared = node.GetSolutionStepValue(RADIUS) ** 2.0
+            total_sum_squared += partial_sum_squared
+            volume += 4 * math.pi / 3 * node.GetSolutionStepValue(RADIUS) ** 3.0
+            area += math.pi * partial_sum_squared
+            i += 1.0
+
+        if i > 0.0:
+            mean = sum_radi / i
+            var = total_sum_squared / i - mean ** 2.0
+        std_dev = 0.0
+
+        if abs(var) > 1e-9:
+            std_dev = var ** 0.5
+
+        if i > 0.0:
+            rel_std_dev = std_dev / mean
+
+        Model_Data.write("Radius Mean: " + str(mean) + '\n')
+        Model_Data.write("Std Deviation: " + str(std_dev) + '\n')
+        Model_Data.write("Relative Std Deviation: " + str(rel_std_dev) + '\n')
+        Model_Data.write("Total Particle Volume 3D: " + str(volume) + '\n')
+        Model_Data.write("Total Particle Area 2D: " + str(area) + '\n')
+        Model_Data.write('\n')
+
+        Total_Particles = len(spheres_model_part.Nodes)
+
+        if solver.continuum_type:
+            Coordination_Number = 0.0
+
+            if self.contact_mesh_OPTION:
+                Total_Contacts = contact_model_part.NumberOfElements(0)
+
+                if Total_Particles:
+                    Coordination_Number = 2.0 * Total_Contacts / Total_Particles
+
+            Model_Data.write("Total Number of Particles: " + str(Total_Particles) + '\n')
+            Model_Data.write("Total Number of Bonds: " + str(Total_Contacts) + '\n')
+            Model_Data.write("Bonded Coordination Number NC: " + str(Coordination_Number) + '\n')
+            Model_Data.write('\n')
+            Model_Data.write("Volume Elements: " + str(volume) + '\n')
+            self.KratosPrintInfo("Coordination Number: " + str(Coordination_Number) + "\n")
+
+        Model_Data.close()
+
+    def MonitorPhysicalProperties(self, model_part, physics_calculator, properties_list):
+
+        # This function returns a list of arrays (also lists)
+        # Each array contains the values of the physical properties at the current time
+        time = model_part.ProcessInfo.GetValue(TIME)
+        present_prop = []
+
+        if not properties_list:  # The first array in the list only contains the entries names
+            names = []
+            names.append("time")
+            names.append("mass")
+            names.append("gravitational_energy")
+            names.append("kinematic_energy")
+            #names.append("elastic_energy")
+            names.append("momentum")
+            names.append("angular_momentum")
+            names.append("total_energy")
+
+            properties_list.append(names)
+
+        # Calculating current values
+        mass = physics_calculator.CalculateTotalMass(model_part)
+        center = physics_calculator.CalculateCenterOfMass(model_part)
+        initial_center = physics_calculator.GetInitialCenterOfMass()
+        gravity_energy = physics_calculator.CalculateGravitationalPotentialEnergy(model_part, initial_center)
+        kinematic_energy = physics_calculator.CalculateKinematicEnergy(model_part)
+        #elastic_energy = physics_calculator.CalculateElasticEnergy(model_part)
+        momentum = physics_calculator.CalculateTotalMomentum(model_part)
+        angular_momentum = physics_calculator.CalulateTotalAngularMomentum(model_part)
+        total_energy = gravity_energy + kinematic_energy  # + elastic_energy
+
+        # Filling in the entries values corresponding to the entries names above
+        present_prop.append(time)
+        present_prop.append(mass)
+        present_prop.append(gravity_energy)
+        present_prop.append(kinematic_energy)
+        #present_prop.append(elastic_energy)
+        present_prop.append(momentum)
+        present_prop.append(angular_momentum)
+        present_prop.append(total_energy)
+
+        properties_list.append(present_prop)
+
+        return properties_list
+
+    def RemoveFoldersWithResults(self, main_path, problem_name, run_code=''):
+        shutil.rmtree(os.path.join(main_path, problem_name + '_Post_Files' + run_code), ignore_errors=True)
+        shutil.rmtree(os.path.join(main_path, problem_name + '_Graphs'), ignore_errors=True)
+
+        try:
+            file_to_remove = os.path.join(main_path, problem_name)+"DEM.time"
+            os.remove(file_to_remove)
+        except OSError:
+            pass
+        try:
+            file_to_remove = os.path.join(main_path, problem_name)+"DEM_Inlet.time"
+            os.remove(file_to_remove)
+        except OSError:
+            pass
+
+        try:
+            file_to_remove = os.path.join(main_path, problem_name)+"DEM_FEM_boundary.time"
+            os.remove(file_to_remove)
+        except OSError:
+            pass
+
+        try:
+            file_to_remove = os.path.join(main_path, problem_name)+"DEM_Clusters.time"
+            os.remove(file_to_remove)
+        except OSError:
+            pass
+
+        try:
+            file_to_remove = os.path.join(main_path, "TimesPartialRelease")
+            os.remove(file_to_remove)
+        except OSError:
+            pass
+
+        try:
+            file_to_remove = os.path.join(main_path, problem_name)+".post.lst"
+            os.remove(file_to_remove)
+        except OSError:
+            pass
+
+
+    def CreateDirectories(self, main_path, problem_name, run_code='', do_print_results=True):
+
+        root = os.path.join(main_path, problem_name)
+        post_path = root + '_Post_Files' + run_code
+        graphs_path = root + '_Graphs'
+
+        self.RemoveFoldersWithResults(main_path, problem_name, run_code)
+
+        if do_print_results:
+            for directory in [post_path, graphs_path]:
+                if not os.path.isdir(directory):
+                    os.makedirs(str(directory))
+
+        return [post_path, graphs_path]
+
+    def FindMaxNodeIdInModelPart(self, model_part):
+
+        maxid = 0
+
+        for node in model_part.Nodes:
+            if node.Id > maxid:
+                maxid = node.Id
+
+        return maxid
+
+    def SetBoundingBoxLimits(self, all_model_parts, creator_destructor):
+
+        bounding_box_time_limits = []
+        if self.DEM_parameters["BoundingBoxOption"].GetBool():
+            self.SetBoundingBox(all_model_parts.Get("SpheresPart"), all_model_parts.Get("ClusterPart"), all_model_parts.Get("RigidFacePart"), all_model_parts.Get("DEMInletPart"), creator_destructor)
+            bounding_box_time_limits = [self.solver.bounding_box_start_time, self.solver.bounding_box_stop_time]
+
+        return bounding_box_time_limits
+
+    def SetBoundingBox(self, spheres_model_part, clusters_model_part, rigid_faces_model_part, dem_inlet_model_part, creator_destructor):
+
+        b_box_low = Array3()
+        b_box_high = Array3()
+        b_box_low[0] = self.b_box_minX
+        b_box_low[1] = self.b_box_minY
+        b_box_low[2] = self.b_box_minZ
+        b_box_high[0] = self.b_box_maxX
+        b_box_high[1] = self.b_box_maxY
+        b_box_high[2] = self.b_box_maxZ
+        creator_destructor.SetLowNode(b_box_low)
+        creator_destructor.SetHighNode(b_box_high)
+        creator_destructor.CalculateSurroundingBoundingBox(spheres_model_part, clusters_model_part, rigid_faces_model_part, dem_inlet_model_part, self.bounding_box_enlargement_factor, self.automatic_bounding_box_OPTION)
+
+    def UpdateBoundingBox(self, spheres_model_part, creator_destructor):
+
+        time = spheres_model_part.ProcessInfo.GetValue(TIME)
+        move_velocity = self.DEM_parameters["BoundingBoxMoveVelocity"].GetDouble()
+        
+        b_box_low = Array3()
+        b_box_high = Array3()
+        b_box_low[0] = self.b_box_minX + time * move_velocity
+        b_box_low[1] = self.b_box_minY + time * move_velocity
+        b_box_low[2] = self.b_box_minZ + time * move_velocity
+        b_box_high[0] = self.b_box_maxX - time * move_velocity
+        b_box_high[1] = self.b_box_maxY - time * move_velocity
+        b_box_high[2] = self.b_box_maxZ - time * move_velocity
+        creator_destructor.SetLowNode(b_box_low)
+        creator_destructor.SetHighNode(b_box_high)
+        creator_destructor.UpdateSurroundingBoundingBox(spheres_model_part)
+    
+    def DeleteFiles(self):
+        files_to_delete_list = glob('*.time')
+        for to_erase_file in files_to_delete_list:
+            try:
+                os.remove(to_erase_file)
+            except OSError:
+                pass
+
+    def PreProcessModel(self, DEM_parameters):
+        pass
+
+    def CheckVariableType(self, var, expected_type, msg):   # TODO is this actually being used
+        actual_type = type(var)
+        if actual_type is int and expected_type is float:
+            return
+        if actual_type is not expected_type:
+            KratosPrintWarning(
+                "ERROR: Input parameter of wrong type in file 'DEM_explicit_solver_var.py'.")
+            a = str(expected_type)
+            b = str(var)
+            raise Exception("The type expected was " + a + " but " + b + " was read.")
+
+    def Flush(self, a):
+        a.flush()
+
+    def KratosPrintInfo(self, message):
+        Logger.PrintInfo(message, label="DEM")
+        Logger.Flush()
+
+    def KratosPrintWarning(self, message):
+        Logger.PrintWarning(message, label="DEM")
+        Logger.Flush()
+
+
+class DEMFEMProcedures():
+
+    def __init__(self, DEM_parameters, graphs_path, spheres_model_part, rigid_face_model_part):
+
+        # GLOBAL VARIABLES OF THE SCRIPT
+        self.DEM_parameters = DEM_parameters
+
+        if not "material_test_settings" in DEM_parameters.keys():
+            self.TestType = "None"
+        else:
+            self.TestType = self.DEM_parameters["material_test_settings"]["TestType"].GetString()
+
+        # Initialization of member variables
+        # SIMULATION FLAGS
+        # TODO: Why is this in DEM FEM Procs also?
+        self.rotation_OPTION = self.DEM_parameters["RotationOption"].GetBool()
+        self.bounding_box_OPTION = self.DEM_parameters["BoundingBoxOption"].GetBool()
+
+        # TODO: This is already in the Procedures object. why to repeat it?
+        self.contact_mesh_OPTION = False
+        if "ContactMeshOption" in self.DEM_parameters.keys():
+            self.contact_mesh_OPTION = self.DEM_parameters["ContactMeshOption"].GetBool()
+
+        self.graphs_path = graphs_path
+        self.spheres_model_part = spheres_model_part
+        self.rigid_face_model_part = rigid_face_model_part
+
+        self.fem_mesh_nodes = []
+
+        self.graph_counter = 1
+        self.balls_graph_counter = 0
+        self.additional_graphs_counter = 0
+
+        self.graph_frequency = int((self.DEM_parameters["GraphExportFreq"].GetDouble() / spheres_model_part.ProcessInfo.GetValue(DELTA_TIME))+1.0)
+        if self.graph_frequency < 1:
+            # that means it is not possible to print results with a higher frequency than the computations delta time
+            self.graph_frequency = 1
+
+
+        def Flush(self, a):
+            a.flush()
+
+        def open_graph_files(self, rigid_face_model_part):
+            for smp in self.rigid_face_model_part.SubModelParts:
+                if smp[FORCE_INTEGRATION_GROUP]:
+                    identifier = smp[IDENTIFIER]
+                    absolute_path_to_file = os.path.join(self.graphs_path, str(self.DEM_parameters["problem_name"].GetString()) + "_" + str(identifier) + "_force_graph.grf")
+                    self.graph_forces[identifier] = open(absolute_path_to_file, 'w')
+                    self.graph_forces[identifier].write(str("#time").rjust(12) + " " + str("total_force[0]").rjust(13) + " " + str("total_force[1]").rjust(13) + " " + str("total_force[2]").rjust(13) + " " + str("total_moment[0]").rjust(13) + " " + str("total_moment[1]").rjust(13) + " " + str("total_moment[2]").rjust(13) + "\n")
+
+        self.graph_forces = {}
+
+        def open_balls_graph_files(self, spheres_model_part):
+            for smp in self.spheres_model_part.SubModelParts:
+                if smp[FORCE_INTEGRATION_GROUP]:
+                    identifier = smp[IDENTIFIER]
+                    absolute_path_to_file = os.path.join(self.graphs_path, str(self.DEM_parameters["problem_name"].GetString()) + "_" + str(identifier) + "_particle_force_graph.grf")
+                    self.particle_graph_forces[identifier] = open(absolute_path_to_file, 'w')
+                    self.particle_graph_forces[identifier].write(str("#time").rjust(12) + " " + str("total_force_x").rjust(13) + " " + str("total_force_y").rjust(13) + " " + str("total_force_z").rjust(13) + "\n")
+
+        if not "print_CN_graph" in DEM_parameters.keys():
+            self.print_CN_graph = False
+        else:
+            self.print_CN_graph = self.DEM_parameters["print_CN_graph"].GetBool()
+
+        if self.print_CN_graph:
+            absolute_path_to_file = os.path.join(self.graphs_path, str(self.DEM_parameters["problem_name"].GetString()) + "_CN.grf")
+            self.CN_export = open(absolute_path_to_file, 'w')
+
+        def evaluate_computation_of_fem_results():
+
+            self.spheres_model_part.ProcessInfo.SetValue(COMPUTE_FEM_RESULTS_OPTION, 0)
+            elastic_forces = self.DEM_parameters["PostElasticForces"].GetBool()
+            tangential_elastic_forces = self.DEM_parameters["PostTangentialElasticForces"].GetBool()
+            dem_pressure = self.DEM_parameters["PostPressure"].GetBool()
+
+            if not "PostContactForces" in self.DEM_parameters.keys():
+                contact_forces = 0
+            else:
+                contact_forces = self.DEM_parameters["PostContactForces"].GetBool()
+
+            if not "PostShearStress" in self.DEM_parameters.keys():
+                shear_stress = 0
+            else:
+                shear_stress = self.DEM_parameters["PostShearStress"].GetBool()
+
+            if not "PostNodalArea" in self.DEM_parameters.keys():
+                dem_nodal_area = 0
+            else:
+                dem_nodal_area = self.DEM_parameters["PostNodalArea"].GetBool()
+
+            integration_groups = False
+
+            if self.rigid_face_model_part.NumberOfSubModelParts() > 0:
+                for smp in self.rigid_face_model_part.SubModelParts:
+                    if smp[FORCE_INTEGRATION_GROUP]:
+                        integration_groups = True
+                        break
+            if elastic_forces or contact_forces or dem_pressure or tangential_elastic_forces or shear_stress or dem_nodal_area or integration_groups:
+                self.spheres_model_part.ProcessInfo.SetValue(COMPUTE_FEM_RESULTS_OPTION, 1)
+
+        self.particle_graph_forces = {}
+
+        if self.TestType == "None":
+            open_graph_files(self, rigid_face_model_part)
+            open_balls_graph_files(self, spheres_model_part)
+
+        # SIMULATION SETTINGS
+        self.bounding_box_enlargement_factor = self.DEM_parameters["BoundingBoxEnlargementFactor"].GetDouble()
+
+        # MODEL
+        self.domain_size = self.DEM_parameters["Dimension"].GetInt()
+        evaluate_computation_of_fem_results()
+
+    def UpdateTimeInModelParts(self, all_model_parts, time, dt, step, is_time_to_print=False):
+
+        spheres_model_part = all_model_parts.Get("SpheresPart")
+        cluster_model_part = all_model_parts.Get("ClusterPart")
+        dem_inlet_model_part = all_model_parts.Get("DEMInletPart")
+        rigid_face_model_part = all_model_parts.Get("RigidFacePart")
+
+        self.UpdateTimeInOneModelPart(spheres_model_part, time, dt, step, is_time_to_print)
+        self.UpdateTimeInOneModelPart(cluster_model_part, time, dt, step, is_time_to_print)
+        self.UpdateTimeInOneModelPart(dem_inlet_model_part, time, dt, step, is_time_to_print)
+        self.UpdateTimeInOneModelPart(rigid_face_model_part, time, dt, step, is_time_to_print)
+
+    def UpdateTimeInOneModelPart(self, model_part, time, dt, step, is_time_to_print=False):
+        KratosPrintWarning('This method is deprecated, please use the new one from the sphere strategy.')
+        model_part.ProcessInfo[TIME] = time
+        model_part.ProcessInfo[DELTA_TIME] = dt
+        model_part.ProcessInfo[TIME_STEPS] = step
+        model_part.ProcessInfo[IS_TIME_TO_PRINT] = is_time_to_print
+
+    def close_graph_files(self, rigid_face_model_part):
+
+        for smp in self.rigid_face_model_part.SubModelParts:
+            if smp[FORCE_INTEGRATION_GROUP]:
+                identifier = smp[IDENTIFIER]
+                self.graph_forces[identifier].close()
+
+    def close_balls_graph_files(self, spheres_model_part):
+
+        for smp in self.spheres_model_part.SubModelParts:
+            if smp[FORCE_INTEGRATION_GROUP]:
+                identifier = smp[IDENTIFIER]
+                self.particle_graph_forces[identifier].close()
+
+    def PrintPoisson(self, model_part, DEM_parameters, filename, time):
+
+        if DEM_parameters["Dimension"].GetInt() == 3:
+            poisson, dummy, _ = PostUtilities().ComputePoisson(model_part)
+        else:
+            poisson, dummy, _ = PostUtilities().ComputePoisson2D(model_part)
+
+        file_open = open(filename, 'a')
+        data = str(time) + "  " + str(poisson) + "\n"
+        file_open.write(data)
+
+    def PrintGraph(self, time):
+
+        if self.TestType == "None":
+
+            if self.graph_counter == self.graph_frequency:
+                self.graph_counter = 0
+
+                for smp in self.rigid_face_model_part.SubModelParts:
+                    if smp[FORCE_INTEGRATION_GROUP]:
+                        mesh_nodes = smp.Nodes
+
+                        total_force = Array3()
+                        total_force[0] = 0.0
+                        total_force[1] = 0.0
+                        total_force[2] = 0.0
+
+                        total_moment = Array3()
+                        total_moment[0] = 0.0
+                        total_moment[1] = 0.0
+                        total_moment[2] = 0.0
+
+                        rotation_center = smp[ROTATION_CENTER]
+
+                        PostUtilities().IntegrationOfForces(mesh_nodes, total_force, rotation_center, total_moment)
+
+                        identifier = smp[IDENTIFIER]
+
+                        self.graph_forces[identifier].write(str("%.8g" % time).rjust(12) +
+                                                            " " + str("%.6g" % total_force[0]).rjust(13) + " " + str("%.6g" % total_force[1]).rjust(13) +
+                                                            " " + str("%.6g" % total_force[2]).rjust(13) + " " + str("%.6g" % total_moment[0]).rjust(13) +
+                                                            " " + str("%.6g" % total_moment[1]).rjust(13) + " " + str("%.6g" % total_moment[2]).rjust(13) + "\n")
+                        self.graph_forces[identifier].flush()
+
+            self.graph_counter += 1
+
+    def FinalizeGraphs(self, rigid_face_model_part):
+
+        if self.TestType == "None":
+            self.close_graph_files(rigid_face_model_part)
+
+    def PrintAdditionalGraphs(self, time, solver):
+
+        if self.additional_graphs_counter == self.graph_frequency:
+            self.additional_graphs_counter = 0
+            if self.print_CN_graph:
+                dummy = 0
+                CN = solver.cplusplus_strategy.ComputeCoordinationNumber(dummy)
+                self.CN_export.write(str("%.13g"%time).rjust(14) + "  " + str("%.11g"%CN).rjust(12) + '\n')
+                self.CN_export.flush()
+        self.additional_graphs_counter += 1
+
+    def PrintBallsGraph(self, time):
+
+        if self.TestType == "None":
+
+            if self.balls_graph_counter == self.graph_frequency:
+                self.balls_graph_counter = 0
+
+                for smp in self.spheres_model_part.SubModelParts:
+                    if smp[FORCE_INTEGRATION_GROUP]:
+                        mesh_nodes = smp.Nodes
+
+                        total_force = Array3()
+                        total_force[0] = 0.0
+                        total_force[1] = 0.0
+                        total_force[2] = 0.0
+
+                        PostUtilities().IntegrationOfElasticForces(mesh_nodes, total_force)
+
+                        identifier = smp[IDENTIFIER]
+                        self.particle_graph_forces[identifier].write(str("%.8g" % time).rjust(12) + " " + str("%.6g" % total_force[0]).rjust(13) + " " + str("%.6g" % total_force[1]).rjust(13) + " " + str("%.6g" % total_force[2]).rjust(13) + "\n")
+                        self.particle_graph_forces[identifier].flush()
+
+            self.balls_graph_counter += 1
+
+    def FinalizeBallsGraphs(self, spheres_model_part):
+
+        if self.TestType == "None":
+            self.close_balls_graph_files(spheres_model_part)
+
+    def ApplyNodalRotation(self, time):
+
+            #if (time < 0.5e-2 ) :
+        if time < 3.8e-5:
+
+            #while (time < self.DEM_parameters["FinalTime"].GetDouble()):
+            #print("TIME STEP BEGINS.  STEP:"+str(time)+"++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
+
+            d0 = 1.694
+            avance = 0.50100
+            distance = (d0 - avance)
+            w = 62.8
+            distance = 2
+
+            vx = -distance * w * math.sin(w * time)
+            #vx = distance * rpm * math.cos(1.0)
+            vy = distance * w * math.cos(w * time)
+            #vz = - distance * rpm * math.sin(1.0)
+
+            for smp in self.spheres_model_part.SubModelParts:
+                if smp[FORCE_INTEGRATION_GROUP]:
+                    self.mesh_nodes = smp.Nodes
+
+                    for node in self.mesh_nodes:
+                        node.SetSolutionStepValue(VELOCITY_X, vx)
+                        node.SetSolutionStepValue(VELOCITY_Y, vy)
+                        node.Fix(VELOCITY_X)
+                        node.Fix(VELOCITY_Y)
+        else:
+
+            d0 = 1.694
+            avance = 0.50100
+            distance = (d0 - avance)
+            w = 62.8
+            distance = 2
+
+            vx = -distance * w * math.sin(w * time)
+            #vx = distance * rpm * math.cos(1.0)
+            vy = distance * w * math.cos(w * time)
+            #vz = - distance * rpm * math.sin(1.0)
+            radius = 1.0001
+
+            for smp in self.spheres_model_part.SubModelParts:
+                if smp[FORCE_INTEGRATION_GROUP]:
+                    self.mesh_nodes = smp.Nodes
+
+                for node in self.mesh_nodes:
+                    node.SetSolutionStepValue(RADIUS, radius)
+
+            for smp in self.spheres_model_part.SubModelParts:
+                if smp[FORCE_INTEGRATION_GROUP]:
+                    self.mesh_nodes = smp.Nodes
+
+                    for node in self.mesh_nodes:
+                        node.SetSolutionStepValue(VELOCITY_X, vx)
+                        node.SetSolutionStepValue(VELOCITY_Y, vy)
+                        node.Fix(VELOCITY_X)
+                        node.Fix(VELOCITY_Y)
+
+
+class Report():
+
+    def __init__(self):
+        pass
+
+    def Prepare(self, timer, control_time):
+        self.initial_pr_time = timer.process_time()
+        self.initial_re_time = timer.time()
+        self.prev_time = 0.0
+        self.total_steps_expected = 0
+        self.control_time = control_time
+        self.first_print = True
+
+    def BeginReport(self, timer):
+        label = "DEM: "
+        report = label + "Total number of time steps expected in the calculation: " + str(self.total_steps_expected) + "\n\n"
+        return report
+
+    def StepiReport(self, timer, time, step):
+
+        incremental_time = (timer.time() - self.initial_re_time) - self.prev_time
+        report = ""
+        label = "DEM: "
+
+        if incremental_time > self.control_time:
+            percentage = 100 * (float(step) / self.total_steps_expected)
+            elapsed_time = timer.time() - self.initial_re_time
+
+            report = report + label + "Elapsed real time: " + str(round(elapsed_time, 5)) + " seconds" + "\n"\
+                            + label + "In minutes: " + str(round(elapsed_time / 60.0, 2)) + " minutes" + "\n"\
+                            + label + "In hours: " + str(round(elapsed_time / 3600.0, 3)) + " hours" + "\n"\
+                            + label + "Simulation time: " + str(time) + " seconds" + "\n"\
+                            + label + "%s %.5f %s" % ("Percentage Completed: ", percentage, "%") + "\n"\
+                            + label + "Computed time steps: " + str(step) + " out of " + str(self.total_steps_expected) + "\n" + label
+
+            self.prev_time = (timer.time() - self.initial_re_time)
+
+        if (timer.time() - self.initial_re_time > 60) and self.first_print and step != 0:
+            self.first_print = False
+            estimated_sim_duration = 60.0 * (self.total_steps_expected / step)  # seconds
+
+            report = report + "\n" + label + "****** The total estimated computation time is " + str(estimated_sim_duration) + " seconds" + "\n"\
+                + label + "****** In minutes: " + str(round(estimated_sim_duration / 60.0, 2)) + " minutes" + "\n"\
+                + label + "****** In hours: " + str(round(estimated_sim_duration / 3600.0, 3)) + " hours" + "\n"\
+                + label + "****** In days: " + str(round(estimated_sim_duration / 86400.0, 3)) + " days" + "\n" + label
+
+        return report
+
+    def FinalReport(self, timer):
+        elapsed_pr_time = timer.process_time() - self.initial_pr_time
+        elapsed_re_time = timer.time() - self.initial_re_time
+        label = "DEM: "
+
+        report = label + "Elapsed processing time (sum across cores): " + str(elapsed_pr_time) + " seconds\n"\
+                + label + "Elapsed real time (wall time): " + str(elapsed_re_time) + " seconds\n" + label
+
+        report = report + "\n" + label + "ANALYSIS COMPLETED"
+
+        return report
+
+
+class PreUtils():
+
+    def __init__(self):
+        pass
+
+class MultifileList():
+
+    def __init__(self, post_path, name, step, which_folder):
+        self.index = 0
+        self.step = step
+        self.name = name
+        self.which_folder = which_folder
+        if which_folder == "inner":
+            absolute_path_to_file = os.path.join(post_path, "_list_" + self.name + "_" + str(step) + ".post.lst")
+        else:
+            absolute_path_to_file = os.path.join(post_path, self.name + ".post.lst")
+
+        self.file = open(absolute_path_to_file, "w")
+
+class DEMIo():
+
+    def __init__(self, model, DEM_parameters, post_path, all_model_parts):
+
+        self.model = model
+
+        self.post_path = post_path
+        self.mixed_model_part = model.CreateModelPart("Mixed_Part")
+        self.mixed_spheres_and_clusters_model_part = model.CreateModelPart("MixedSpheresAndClustersPart")
+        self.mixed_spheres_not_in_cluster_and_clusters_model_part = model.CreateModelPart("MixedSpheresNotInClusterAndClustersPart")
+
+        self.spheres_model_part = all_model_parts.Get("SpheresPart")
+        self.cluster_model_part = all_model_parts.Get("ClusterPart")
+        self.rigid_face_model_part = all_model_parts.Get("RigidFacePart")
+        self.contact_model_part = all_model_parts.Get("ContactPart")
+        self.mapping_model_part = all_model_parts.Get("MappingPart")
+
+        # Printing variables
+        self.DEM_parameters = DEM_parameters
+        self.global_variables = []
+        self.global_nonhistorical_nodal_variables = []
+        self.spheres_and_clusters_variables = []
+        self.spheres_and_clusters_local_axis_variables = []
+        self.spheres_not_in_cluster_and_clusters_variables = []
+        self.spheres_not_in_cluster_and_clusters_local_axis_variables = []
+        self.spheres_variables = []
+        self.spheres_local_axis_variables = []
+        self.fem_boundary_variables = []
+        self.clusters_variables = []
+        self.rigid_body_variables = []
+        self.contact_variables = []
+        self.multifilelists = []
+
+        # Reading Post options from DEM_parameters
+        self.PostDisplacement = self.DEM_parameters["PostDisplacement"].GetBool()
+        self.PostVelocity = self.DEM_parameters["PostVelocity"].GetBool()
+        self.PostTotalForces = self.DEM_parameters["PostTotalForces"].GetBool()
+        self.PostNonDimensionalVolumeWear = self.DEM_parameters["PostNonDimensionalVolumeWear"].GetBool()
+        self.PostAppliedForces = self.DEM_parameters["PostAppliedForces"].GetBool()
+        self.PostDampForces = self.DEM_parameters["PostDampForces"].GetBool()
+        self.PostRadius = self.DEM_parameters["PostRadius"].GetBool()
+        self.PostGroupId = GetBoolParameterIfItExists(self.DEM_parameters, "PostGroupId")
+        self.PostExportId = self.DEM_parameters["PostExportId"].GetBool()
+        self.PostSkinSphere = GetBoolParameterIfItExists(self.DEM_parameters, "PostSkinSphere")
+        self.PostGluedSphere = GetBoolParameterIfItExists(self.DEM_parameters, "PostGluedSphere")
+        self.PostAngularVelocity = self.DEM_parameters["PostAngularVelocity"].GetBool()
+        self.PostParticleMoment = self.DEM_parameters["PostParticleMoment"].GetBool()
+        self.PostEulerAngles = self.DEM_parameters["PostEulerAngles"].GetBool()
+        self.PostRollingResistanceMoment = self.DEM_parameters["PostRollingResistanceMoment"].GetBool()
+        self.PostLocalContactForce = GetBoolParameterIfItExists(self.DEM_parameters, "PostLocalContactForce")
+        self.PostFailureCriterionState = GetBoolParameterIfItExists(self.DEM_parameters, "PostFailureCriterionState")
+        self.PostContactFailureId = GetBoolParameterIfItExists(self.DEM_parameters, "PostContactFailureId")
+        self.PostContactTau = GetBoolParameterIfItExists(self.DEM_parameters, "PostContactTau")
+        self.PostContactSigma = GetBoolParameterIfItExists(self.DEM_parameters, "PostContactSigma")
+        self.PostMeanContactArea = GetBoolParameterIfItExists(self.DEM_parameters, "PostMeanContactArea")
+        self.PostContactRadius = GetBoolParameterIfItExists(self.DEM_parameters, "PostContactRadius")
+        self.PostElasticForces = self.DEM_parameters["PostElasticForces"].GetBool()
+        self.PostContactForces = self.DEM_parameters["PostContactForces"].GetBool()
+        self.PostRigidElementForces = self.DEM_parameters["PostRigidElementForces"].GetBool()
+        self.PostPressure = self.DEM_parameters["PostPressure"].GetBool()
+        self.PostTangentialElasticForces = self.DEM_parameters["PostTangentialElasticForces"].GetBool()
+        self.PostShearStress = self.DEM_parameters["PostShearStress"].GetBool()
+        self.PostNodalArea = self.DEM_parameters["PostNodalArea"].GetBool()
+        self.PostNeighbourSize = GetBoolParameterIfItExists(self.DEM_parameters, "PostNeighbourSize")
+        self.PostDamageRatio = GetBoolParameterIfItExists(self.DEM_parameters, "PostDamageRatio")
+        self.PostNormalImpactVelocity = GetBoolParameterIfItExists(self.DEM_parameters, "PostNormalImpactVelocity")
+        self.PostTangentialImpactVelocity = GetBoolParameterIfItExists(self.DEM_parameters, "PostTangentialImpactVelocity")
+        self.PostControlModule = GetBoolParameterIfItExists(self.DEM_parameters, "PostControlModule")
+        self.VelTrapGraphExportFreq = self.DEM_parameters["VelTrapGraphExportFreq"].GetDouble()
+        if not "PostDeltaDisplacement" in self.DEM_parameters.keys():
+            self.PostDeltaDisplacement = False
+        else:
+            self.PostDeltaDisplacement = self.DEM_parameters["PostDeltaDisplacement"].GetBool()
+        if not "PostCharacteristicLength" in self.DEM_parameters.keys():
+            self.PostCharacteristicLength = 0
+        else:
+            self.PostCharacteristicLength = self.DEM_parameters["PostCharacteristicLength"].GetBool()
+
+        #self.PostFaceNormalImpactVelocity = GetBoolParameterIfItExists(self.DEM_parameters, "PostFaceNormalImpactVelocity", 0)
+        #self.PostFaceTangentialImpactVelocity = GetBoolParameterIfItExists(self.DEM_parameters, "PostFaceTangentialImpactVelocity", 0)
+
+        if not "PostBoundingBox" in self.DEM_parameters.keys():
+            self.PostBoundingBox = 0
+        else:
+            self.PostBoundingBox = self.DEM_parameters["PostBoundingBox"].GetBool()
+
+        #self.automatic_bounding_box_option = Var_Translator(self.DEM_parameters["AutomaticBoundingBoxOption"].GetBool())
+        #self.b_box_minX = self.DEM_parameters["BoundingBoxMinX"].GetDouble()
+        #self.b_box_minY = self.DEM_parameters["BoundingBoxMinY"].GetDouble()
+        #self.b_box_minZ = self.DEM_parameters["BoundingBoxMinZ"].GetDouble()
+        #self.b_box_maxX = self.DEM_parameters["BoundingBoxMaxX"].GetDouble()
+        #self.b_box_maxY = self.DEM_parameters["BoundingBoxMaxY"].GetDouble()
+        #self.b_box_maxZ = self.DEM_parameters["BoundingBoxMaxZ"].GetDouble()
+
+        self.continuum_element_types = ["SphericContPartDEMElement3D", "CylinderContPartDEMElement2D", "IceContPartDEMElement3D"]
+
+        self.OpenMultiFileLists()
+
+        #Analytic
+        if not "PostNormalImpactVelocity" in self.DEM_parameters.keys():
+            self.PostNormalImpactVelocity = 0
+        else:
+            self.PostNormalImpactVelocity = self.DEM_parameters["PostNormalImpactVelocity"].GetBool()
+
+        if not "PostTangentialImpactVelocity" in self.DEM_parameters.keys():
+            self.PostTangentialImpactVelocity = 0
+        else:
+            self.PostTangentialImpactVelocity = self.DEM_parameters["PostTangentialImpactVelocity"].GetBool()
+
+        if not "PostFaceNormalImpactVelocity" in self.DEM_parameters.keys():
+            self.PostFaceNormalImpactVelocity = 0
+        else:
+            self.PostFaceNormalImpactVelocity = self.DEM_parameters["PostFaceNormalImpactVelocity"].GetBool()
+
+        if not "PostFaceTangentialImpactVelocity" in self.DEM_parameters.keys():
+            self.PostFaceTangentialImpactVelocity = 0
+        else:
+            self.PostFaceTangentialImpactVelocity = self.DEM_parameters["PostFaceTangentialImpactVelocity"].GetBool()
+
+        # Ice
+        self.sea_settings = self.DEM_parameters["virtual_sea_surface_settings"]
+
+        if self.sea_settings["print_sea_surface"].GetBool():
+            self.SeaSurfaceX1 = self.sea_settings["PostVirtualSeaSurfaceX1"].GetDouble()
+            self.SeaSurfaceY1 = self.sea_settings["PostVirtualSeaSurfaceY1"].GetDouble()
+            self.SeaSurfaceX2 = self.sea_settings["PostVirtualSeaSurfaceX2"].GetDouble()
+            self.SeaSurfaceY2 = self.sea_settings["PostVirtualSeaSurfaceY2"].GetDouble()
+            self.SeaSurfaceX3 = self.sea_settings["PostVirtualSeaSurfaceX3"].GetDouble()
+            self.SeaSurfaceY3 = self.sea_settings["PostVirtualSeaSurfaceY3"].GetDouble()
+            self.SeaSurfaceX4 = self.sea_settings["PostVirtualSeaSurfaceX4"].GetDouble()
+            self.SeaSurfaceY4 = self.sea_settings["PostVirtualSeaSurfaceY4"].GetDouble()
+
+    def OpenMultiFileLists(self):
+        one_level_up_path = os.path.join(self.post_path, "..")
+        self.multifiles = (
+            MultifileList(one_level_up_path, self.DEM_parameters["problem_name"].GetString(), 1, "outer"),
+            MultifileList(self.post_path, self.DEM_parameters["problem_name"].GetString(), 1, "inner"),
+            MultifileList(self.post_path, self.DEM_parameters["problem_name"].GetString(), 2, "inner"),
+            MultifileList(self.post_path, self.DEM_parameters["problem_name"].GetString(), 5, "inner"),
+            MultifileList(self.post_path, self.DEM_parameters["problem_name"].GetString(), 10, "inner"),
+            MultifileList(self.post_path, self.DEM_parameters["problem_name"].GetString(), 20, "inner"),
+            MultifileList(self.post_path, self.DEM_parameters["problem_name"].GetString(), 50, "inner"),
+        )
+        self.SetMultifileLists(self.multifiles)
+
+    def KratosPrintInfo(self, message):
+        Logger.PrintInfo(message, label="DEM")
+        Logger.Flush()
+
+    def Flush(self, a):
+        a.flush()
+
+    def ShowPrintingResultsOnScreen(self, all_model_parts, format_name):
+        self.KratosPrintInfo("*******************  PRINTING RESULTS FOR {}  ***************************".format(format_name))
+        self.KratosPrintInfo("                        (" + str(all_model_parts.Get("SpheresPart").NumberOfElements(0)) + " elements)")
+        self.KratosPrintInfo("                        (" + str(all_model_parts.Get("SpheresPart").NumberOfNodes(0)) + " nodes)")
+        self.KratosPrintInfo("")
+
+    def Initialize(self, DEM_parameters):
+        self.AddGlobalVariables()
+        self.AddGlobalNonHistoricalNodalVariables()
+        self.AddSpheresVariables()
+        self.AddSpheresAndClustersVariables()
+        self.AddSpheresNotInClusterAndClustersVariables()
+        self.AddFEMBoundaryVariables()
+        self.AddClusterVariables()
+        self.AddRigidBodyVariables()
+        self.AddContactVariables()
+        self.AddMpiVariables()
+        self.Configure(DEM_parameters["problem_name"].GetString(), DEM_parameters["OutputFileType"].GetString(), DEM_parameters["Multifile"].GetString(), DEM_parameters["ContactMeshOption"].GetBool())
+        self.SetOutputName(DEM_parameters["problem_name"].GetString())
+
+    def PushPrintVar(self, variable, name, print_list):
+        if Var_Translator(variable):
+            print_list.append(name)
+
+    def AddGlobalVariables(self):
+        self.PushPrintVar(self.PostDisplacement, DISPLACEMENT, self.global_variables)
+        self.PushPrintVar(self.PostVelocity, VELOCITY, self.global_variables)
+        self.PushPrintVar(self.PostTotalForces, TOTAL_FORCES, self.global_variables)
+        self.PushPrintVar(self.PostContactForces, CONTACT_FORCES, self.global_variables)
+        self.PushPrintVar(self.PostAppliedForces, EXTERNAL_APPLIED_FORCE, self.global_variables)
+        self.PushPrintVar(self.PostAppliedForces, EXTERNAL_APPLIED_MOMENT, self.global_variables)
+        if self.DEM_parameters["PostAngularVelocity"].GetBool():
+            self.PushPrintVar(self.PostAngularVelocity, ANGULAR_VELOCITY, self.global_variables)
+        if self.DEM_parameters["PostParticleMoment"].GetBool():
+            self.PushPrintVar(self.PostParticleMoment, PARTICLE_MOMENT, self.global_variables)
+        self.PushPrintVar(self.PostDeltaDisplacement, DELTA_DISPLACEMENT, self.global_variables)
+
+    def AddGlobalNonHistoricalNodalVariables(self):
+        self.PushPrintVar(self.PostControlModule, TARGET_STRESS, self.global_nonhistorical_nodal_variables)
+        self.PushPrintVar(self.PostControlModule, REACTION_STRESS, self.global_nonhistorical_nodal_variables)
+        self.PushPrintVar(self.PostControlModule, SMOOTHED_REACTION_STRESS, self.global_nonhistorical_nodal_variables)
+        self.PushPrintVar(self.PostControlModule, ELASTIC_REACTION_STRESS, self.global_nonhistorical_nodal_variables)
+        self.PushPrintVar(self.PostControlModule, SMOOTHED_ELASTIC_REACTION_STRESS, self.global_nonhistorical_nodal_variables)
+        self.PushPrintVar(self.PostControlModule, LOADING_VELOCITY, self.global_nonhistorical_nodal_variables)
+
+
+    def AddSpheresAndClustersVariables(self):  # variables common to spheres and clusters
+        self.PushPrintVar(self.PostRigidElementForces, RIGID_ELEMENT_FORCE, self.spheres_and_clusters_variables)
+
+    # variables common to spheres and clusters
+    def AddSpheresNotInClusterAndClustersVariables(self):
+        if self.DEM_parameters["PostEulerAngles"].GetBool():
+            self.PushPrintVar(self.PostEulerAngles, EULER_ANGLES, self.spheres_not_in_cluster_and_clusters_local_axis_variables)
+
+    def AddSpheresVariables(self):
+        self.PushPrintVar(self.PostDampForces, DAMP_FORCES, self.spheres_variables)
+        self.PushPrintVar(self.PostRadius, RADIUS, self.spheres_variables)
+        self.PushPrintVar(self.PostExportId, EXPORT_ID, self.spheres_variables)
+        self.PushPrintVar(self.PostNormalImpactVelocity, NORMAL_IMPACT_VELOCITY, self.spheres_variables)
+        self.PushPrintVar(self.PostTangentialImpactVelocity, TANGENTIAL_IMPACT_VELOCITY, self.spheres_variables)
+        self.PushPrintVar(self.PostFaceNormalImpactVelocity, FACE_NORMAL_IMPACT_VELOCITY, self.spheres_variables)
+        self.PushPrintVar(self.PostFaceTangentialImpactVelocity, FACE_TANGENTIAL_IMPACT_VELOCITY, self.spheres_variables)
+
+        
+        if "PostRollingResistanceMoment" in self.DEM_parameters.keys():
+            if self.DEM_parameters["RotationOption"].GetBool():
+                if self.DEM_parameters["RollingFrictionOption"].GetBool():
+                    self.PushPrintVar(self.PostRollingResistanceMoment, ROLLING_RESISTANCE_MOMENT, self.spheres_variables)
+
+        if "PostSkinSphere" in self.DEM_parameters.keys():
+            if self.DEM_parameters["PostSkinSphere"].GetBool():
+                self.PushPrintVar(self.PostSkinSphere, SKIN_SPHERE, self.spheres_variables)
+
+        if "PostNeighbourSize" in self.DEM_parameters.keys():
+            if self.DEM_parameters["PostNeighbourSize"].GetBool():
+                self.PushPrintVar(self.PostNeighbourSize, NEIGHBOUR_SIZE, self.spheres_variables)
+
+        if "PostDamageRatio" in self.DEM_parameters.keys():
+            if self.DEM_parameters["PostDamageRatio"].GetBool():
+                self.PushPrintVar(self.PostDamageRatio, DAMAGE_RATIO, self.spheres_variables)
+
+        if self.PostGluedSphere:
+            self.PushPrintVar(self.PostGluedSphere, IS_STICKY, self.spheres_variables)
+
+        # NANO (TODO: must be removed from here.)
+        if self.DEM_parameters["ElementType"].GetString() == "SwimmingNanoParticle":
+            self.PushPrintVar(self.PostHeatFlux, CATION_CONCENTRATION, self.spheres_variables)
+
+        if "PostStressStrainOption" in self.DEM_parameters.keys():
+            if self.DEM_parameters["PostStressStrainOption"].GetBool():
+                self.PushPrintVar(1, REPRESENTATIVE_VOLUME, self.spheres_variables)
+                self.PushPrintVar(1, DEM_STRESS_TENSOR, self.spheres_variables)
+                self.PushPrintVar(1, DEM_STRAIN_TENSOR, self.spheres_variables)
+                self.PushPrintVar(1, DEM_DIFFERENTIAL_STRAIN_TENSOR, self.spheres_variables)
+
+        if "PostReactions" in self.DEM_parameters.keys():
+            if self.DEM_parameters["PostReactions"].GetBool():
+                self.PushPrintVar(1, FORCE_REACTION, self.spheres_variables)
+                self.PushPrintVar(1, MOMENT_REACTION, self.spheres_variables)
+
+        if "PostPoissonRatio" in self.DEM_parameters.keys():
+            if self.DEM_parameters["PostPoissonRatio"].GetBool():
+                self.PushPrintVar(1, POISSON_VALUE, self.spheres_variables)
+
+        if "PostGroupId" in self.DEM_parameters.keys():
+            if self.DEM_parameters["PostGroupId"].GetBool():
+                self.PushPrintVar(self.PostGroupId, GROUP_ID, self.spheres_variables)
+
+    def AddFEMBoundaryVariables(self):
+        self.PushPrintVar(self.PostElasticForces, ELASTIC_FORCES, self.fem_boundary_variables)
+        self.PushPrintVar(self.PostPressure, DEM_PRESSURE, self.fem_boundary_variables)
+        self.PushPrintVar(self.PostTangentialElasticForces, TANGENTIAL_ELASTIC_FORCES, self.fem_boundary_variables)
+        self.PushPrintVar(self.PostShearStress, SHEAR_STRESS, self.fem_boundary_variables)
+        self.PushPrintVar(self.PostNodalArea, DEM_NODAL_AREA, self.fem_boundary_variables)
+        if Var_Translator(self.PostNonDimensionalVolumeWear):
+            self.PushPrintVar(1, NON_DIMENSIONAL_VOLUME_WEAR, self.fem_boundary_variables)
+            self.PushPrintVar(1, IMPACT_WEAR, self.fem_boundary_variables)
+
+    def AddClusterVariables(self):
+        if self.PostCharacteristicLength:
+            self.PushPrintVar(self.PostCharacteristicLength, CHARACTERISTIC_LENGTH, self.clusters_variables)
+
+    def AddRigidBodyVariables(self):
+        pass
+
+    def AddContactVariables(self):
+        # Contact Elements Variables
+        if self.DEM_parameters["ContactMeshOption"].GetBool():
+            self.PushPrintVar(self.PostLocalContactForce, LOCAL_CONTACT_FORCE, self.contact_variables)
+            if self.DEM_parameters["ElementType"].GetString() in self.continuum_element_types:
+                self.PushPrintVar(self.PostFailureCriterionState, FAILURE_CRITERION_STATE, self.contact_variables)
+                self.PushPrintVar(self.PostContactFailureId, CONTACT_FAILURE, self.contact_variables)
+                self.PushPrintVar(self.PostContactTau, CONTACT_TAU, self.contact_variables)
+                self.PushPrintVar(self.PostContactSigma, CONTACT_SIGMA, self.contact_variables)
+                self.PushPrintVar(self.PostMeanContactArea, MEAN_CONTACT_AREA, self.contact_variables)
+                self.PushPrintVar(self.PostContactRadius, CONTACT_RADIUS, self.contact_variables)
+
+    def AddMpiVariables(self):
+        pass
+
+    def Configure(self, problem_name, encoding, file_system, contact_mesh_option):
+        self.problem_name = problem_name
+
+        if encoding == "Binary":
+            self.encoding = GiDPostMode.GiD_PostBinary
+        else:
+            self.encoding = GiDPostMode.GiD_PostAscii
+
+        if self.DEM_parameters["Multifile"].GetString() == "multiple_files":
+            self.filesystem = MultiFileFlag.MultipleFiles
+        else:
+            self.filesystem = MultiFileFlag.SingleFile
+
+        self.deformed_mesh_flag = WriteDeformedMeshFlag.WriteDeformed
+        self.write_conditions = WriteConditionsFlag.WriteConditions
+        self.contact_mesh_option = contact_mesh_option
+
+        problem_name = os.path.join(self.post_path, self.problem_name)
+        self.gid_io = GidIO(problem_name,
+                            self.encoding,
+                            self.filesystem,
+                            self.deformed_mesh_flag,
+                            self.write_conditions)
+
+        self.post_utility = PostUtilities()
+
+    def SetOutputName(self, name):
+        problem_name = os.path.join(self.post_path, self.problem_name)
+        self.gid_io.ChangeOutputName(problem_name)
+
+    def SetMultifileLists(self, multifile_list):
+        for mfilelist in multifile_list:
+            self.multifilelists.append(mfilelist)
+
+        for mfilelist in self.multifilelists:
+            mfilelist.file.write("Multiple\n")
+            mfilelist.index = 1
+
+    def PrintMultifileLists(self, time, post_path):
+        for mfilelist in self.multifilelists:
+
+            if mfilelist.index == mfilelist.step:
+
+                if self.encoding == GiDPostMode.GiD_PostBinary:
+                    text_to_print = self.GetMultiFileListName(mfilelist.name) + "_" + "%.12g" % time + ".post.bin\n"
+                    if mfilelist.which_folder == "outer":
+                        path_of_file = os.path.dirname(mfilelist.file.name)
+                        text_to_print = os.path.join(os.path.relpath(
+                            post_path, path_of_file), text_to_print)
+                    mfilelist.file.write(text_to_print)
+                else:
+                    text_to_print1 = self.GetMultiFileListName(mfilelist.name) + "_" + "%.12g" % time + ".post.msh\n"
+                    text_to_print2 = self.GetMultiFileListName(mfilelist.name) + "_" + "%.12g" % time + ".post.res\n"
+                    if mfilelist.which_folder == "outer":
+                        path_of_file = os.path.dirname(mfilelist.file.name)
+                        text_to_print1 = os.path.join(os.path.relpath(post_path, path_of_file), text_to_print1)
+                        text_to_print2 = os.path.join(os.path.relpath(post_path, path_of_file), text_to_print2)
+                    mfilelist.file.write(text_to_print1)
+                    mfilelist.file.write(text_to_print2)
+                self.Flush(mfilelist.file)
+                mfilelist.index = 0
+
+            mfilelist.index += 1
+
+    def GetMultiFileListName(self, name):
+        return name
+
+    def CloseMultifiles(self):
+        for mfilelist in self.multifilelists:
+            mfilelist.file.close()
+
+    def AddModelPartsToMixedModelPart(self):
+        self.post_utility.AddModelPartToModelPart(self.mixed_model_part, self.spheres_model_part)
+        if self.contact_mesh_option:
+            self.post_utility.AddModelPartToModelPart(self.mixed_model_part, self.contact_model_part)
+        self.post_utility.AddModelPartToModelPart(self.mixed_model_part, self.rigid_face_model_part)
+        self.post_utility.AddModelPartToModelPart(self.mixed_model_part, self.cluster_model_part)
+        self.post_utility.AddModelPartToModelPart(self.mixed_spheres_and_clusters_model_part, self.spheres_model_part)
+        self.post_utility.AddModelPartToModelPart(self.mixed_spheres_and_clusters_model_part, self.cluster_model_part)
+
+        self.post_utility.AddSpheresNotBelongingToClustersToMixModelPart(self.mixed_spheres_not_in_cluster_and_clusters_model_part, self.spheres_model_part)
+        self.post_utility.AddModelPartToModelPart(self.mixed_spheres_not_in_cluster_and_clusters_model_part, self.cluster_model_part)
+
+    def InitializeMesh(self, all_model_parts):
+        if self.filesystem == MultiFileFlag.SingleFile:
+            self.AddModelPartsToMixedModelPart()
+            self.gid_io.InitializeMesh(0.0)
+            self.gid_io.WriteMesh(all_model_parts.Get("RigidFacePart").GetCommunicator().LocalMesh())
+            self.gid_io.WriteClusterMesh(all_model_parts.Get("ClusterPart").GetCommunicator().LocalMesh())
+            if self.DEM_parameters["ElementType"].GetString() == "CylinderContPartDEMElement2D" or self.DEM_parameters["ElementType"].GetString() == "CylinderPartDEMElement2D":
+                self.gid_io.WriteCircleMesh(all_model_parts.Get("SpheresPart").GetCommunicator().LocalMesh())
+            else:
+                self.gid_io.WriteSphereMesh(all_model_parts.Get("SpheresPart").GetCommunicator().LocalMesh())
+
+            if self.contact_mesh_option:
+                self.gid_io.WriteMesh(all_model_parts.Get("ContactPart").GetCommunicator().LocalMesh())
+
+            self.gid_io.FinalizeMesh()
+            self.gid_io.InitializeResults(0.0, self.mixed_model_part.GetCommunicator().LocalMesh())
+            #self.gid_io.InitializeResults(0.0, mixed_spheres_and_clusters_model_part.GetCommunicator().LocalMesh())
+
+    def InitializeResults(self, spheres_model_part, rigid_face_model_part, cluster_model_part, contact_model_part, mapping_model_part, creator_destructor, dem_fem_search, time, bounding_box_time_limits):  # MIQUEL MAPPING
+
+        if self.filesystem == MultiFileFlag.MultipleFiles:
+            self.RemoveElementsAndNodes()
+            self.AddModelPartsToMixedModelPart()
+            self.gid_io.InitializeMesh(time)
+            if self.DEM_parameters["ElementType"].GetString() == "CylinderContPartDEMElement2D" or self.DEM_parameters["ElementType"].GetString() == "CylinderPartDEMElement2D":
+                self.gid_io.WriteCircleMesh(spheres_model_part.GetCommunicator().LocalMesh())
+            else:
+                self.gid_io.WriteSphereMesh(spheres_model_part.GetCommunicator().LocalMesh())
+
+            if self.contact_mesh_option:
+                #We overwrite the Id of the properties 0 not to overlap with other entities that use layer 0 for PRINTING
+                if contact_model_part.HasProperties(0):
+                    contact_model_part.GetProperties(0).Id = 9184
+                self.gid_io.WriteMesh(contact_model_part.GetCommunicator().LocalMesh())
+
+            self.gid_io.WriteMesh(rigid_face_model_part.GetCommunicator().LocalMesh())
+            self.gid_io.WriteClusterMesh(cluster_model_part.GetCommunicator().LocalMesh())
+
+            #Compute and print the graphical bounding box if active in time
+            if self.DEM_parameters["BoundingBoxOption"].GetBool() and (time >= bounding_box_time_limits[0] and time <= bounding_box_time_limits[1]):
+                self.ComputeAndPrintBoundingBox(spheres_model_part, rigid_face_model_part, contact_model_part, creator_destructor)
+
+            # Ice. Printing a virtual sea surface
+            if self.sea_settings["print_sea_surface"].GetBool():
+                self.ComputeAndPrintSeaSurface(spheres_model_part, rigid_face_model_part)
+
+            #self.ComputeAndPrintDEMFEMSearchBinBoundingBox(spheres_model_part, rigid_face_model_part, dem_fem_search)#MSIMSI
+
+            self.gid_io.FinalizeMesh()
+            self.gid_io.InitializeResults(time, self.mixed_model_part.GetCommunicator().LocalMesh())
+            #self.gid_io.InitializeResults(time, mixed_spheres_and_clusters_model_part.GetCommunicator().LocalMesh())
+
+    def FinalizeMesh(self):
+        if self.filesystem == MultiFileFlag.SingleFile:
+            self.gid_io.FinalizeResults()
+
+    def FinalizeResults(self):
+        if self.filesystem == MultiFileFlag.MultipleFiles:
+            self.gid_io.FinalizeResults()
+
+    def PrintingGlobalVariables(self, export_model_part, time):
+        for variable in self.global_variables:
+            self.gid_io.WriteNodalResults(variable, export_model_part.Nodes, time, 0)
+
+    def PrintingGlobalNonHistoricalNodalVariables(self, export_model_part, time):
+        for variable in self.global_nonhistorical_nodal_variables:
+            self.gid_io.WriteNodalResultsNonHistorical(variable, export_model_part.Nodes, time)
+
+    def PrintingSpheresAndClustersVariables(self, export_model_part, time):
+        for variable in self.spheres_and_clusters_variables:
+            self.gid_io.WriteNodalResults(variable, export_model_part.Nodes, time, 0)
+        for variable in self.spheres_and_clusters_local_axis_variables:
+            self.gid_io.WriteLocalAxesOnNodes(variable, export_model_part.Nodes, time, 0)
+
+    def PrintingSpheresNotInClusterAndClustersVariables(self, export_model_part, time):
+        for variable in self.spheres_not_in_cluster_and_clusters_variables:
+            self.gid_io.WriteNodalResults(variable, export_model_part.Nodes, time, 0)
+        for variable in self.spheres_not_in_cluster_and_clusters_local_axis_variables:
+            self.gid_io.WriteLocalAxesOnNodes(variable, export_model_part.Nodes, time, 0)
+
+    def PrintingSpheresVariables(self, export_model_part, time):
+        for variable in self.spheres_variables:
+            self.gid_io.WriteNodalResults(variable, export_model_part.Nodes, time, 0)
+        for variable in self.spheres_local_axis_variables:
+            self.gid_io.WriteLocalAxesOnNodes(variable, export_model_part.Nodes, time, 0)
+
+    def PrintingFEMBoundaryVariables(self, export_model_part, time):
+        for variable in self.fem_boundary_variables:
+            self.gid_io.WriteNodalResults(variable, export_model_part.Nodes, time, 0)
+
+    def PrintingClusterVariables(self, export_model_part, time):
+        for variable in self.clusters_variables:
+            self.gid_io.WriteNodalResults(variable, export_model_part.Nodes, time, 0)
+
+    def PrintingRigidBodyVariables(self, export_model_part, time):
+        for variable in self.rigid_body_variables:
+            self.gid_io.WriteNodalResults(variable, export_model_part.Nodes, time, 0)
+
+    def PrintingContactElementsVariables(self, export_model_part, time):
+        if self.contact_mesh_option:
+            for variable in self.contact_variables:
+                self.gid_io.PrintOnGaussPoints(variable, export_model_part, time)
+
+    def PrintResults(self, all_model_parts, creator_destructor, dem_fem_search, time, bounding_box_time_limits):
+
+        if self.filesystem == MultiFileFlag.MultipleFiles:
+            self.InitializeResults(self.spheres_model_part,
+                                   self.rigid_face_model_part,
+                                   self.cluster_model_part,
+                                   self.contact_model_part,
+                                   self.mapping_model_part,
+                                   creator_destructor,
+                                   dem_fem_search,
+                                   time,
+                                   bounding_box_time_limits)
+
+        self.PrintingGlobalVariables(self.mixed_model_part, time)
+        self.PrintingGlobalNonHistoricalNodalVariables(self.mixed_model_part, time)
+        self.PrintingSpheresAndClustersVariables(self.mixed_spheres_and_clusters_model_part, time)
+        self.PrintingSpheresNotInClusterAndClustersVariables(self.mixed_spheres_not_in_cluster_and_clusters_model_part, time)
+        self.PrintingSpheresVariables(self.spheres_model_part, time)
+        self.PrintingFEMBoundaryVariables(self.rigid_face_model_part, time)
+        self.PrintingRigidBodyVariables(self.rigid_face_model_part, time)
+        self.PrintingClusterVariables(self.cluster_model_part, time)
+        self.PrintingContactElementsVariables(self.contact_model_part, time)
+
+        self.RemoveElementsAndNodes()
+
+        if self.filesystem == MultiFileFlag.MultipleFiles:
+            self.FinalizeResults()
+
+    def RemoveElementsAndNodes(self):
+        self.mixed_model_part.Elements.clear()
+        self.mixed_model_part.Nodes.clear()
+        self.mixed_spheres_and_clusters_model_part.Elements.clear()
+        self.mixed_spheres_and_clusters_model_part.Nodes.clear()
+        self.mixed_spheres_not_in_cluster_and_clusters_model_part.Elements.clear()
+        self.mixed_spheres_not_in_cluster_and_clusters_model_part.Nodes.clear()
+
+    def ComputeAndPrintBoundingBox(self, spheres_model_part, rigid_face_model_part, contact_model_part, creator_destructor):
+
+        if self.PostBoundingBox:
+            # Creation of bounding box's model part
+            bounding_box_model_part = self.model.CreateModelPart("BoundingBoxPart")
+
+            max_node_Id = ParticleCreatorDestructor().FindMaxNodeIdInModelPart(spheres_model_part)
+            max_FEM_node_Id = ParticleCreatorDestructor().FindMaxNodeIdInModelPart(rigid_face_model_part)
+            max_element_Id = ParticleCreatorDestructor().FindMaxElementIdInModelPart(spheres_model_part)
+            max_FEM_element_Id = ParticleCreatorDestructor().FindMaxElementIdInModelPart(rigid_face_model_part)
+            max_contact_element_Id = ParticleCreatorDestructor().FindMaxElementIdInModelPart(contact_model_part)
+
+            if max_FEM_node_Id > max_node_Id:
+                max_node_Id = max_FEM_node_Id
+
+            if max_FEM_element_Id > max_element_Id:
+                max_element_Id = max_FEM_element_Id
+
+            if max_contact_element_Id > max_element_Id:
+                max_element_Id = max_contact_element_Id
+
+            BBMaxX = creator_destructor.GetHighNode()[0]
+            BBMaxY = creator_destructor.GetHighNode()[1]
+            BBMaxZ = creator_destructor.GetHighNode()[2]
+            BBMinX = creator_destructor.GetLowNode()[0]
+            BBMinY = creator_destructor.GetLowNode()[1]
+            BBMinZ = creator_destructor.GetLowNode()[2]
+
+            self.BuildGraphicalBoundingBox(bounding_box_model_part, max_node_Id, max_element_Id, BBMinX, BBMinY, BBMinZ, BBMaxX, BBMaxY, BBMaxZ)
+
+            self.gid_io.WriteMesh(bounding_box_model_part.GetCommunicator().LocalMesh())
+
+            self.model.DeleteModelPart("BoundingBoxPart")
+
+    def ComputeAndPrintSeaSurface(self, spheres_model_part, rigid_face_model_part):
+
+        # Creation of sea surface model part
+        sea_surface_model_part = ModelPart("SeaSurfacePart")
+
+        max_node_Id = ParticleCreatorDestructor().FindMaxNodeIdInModelPart(spheres_model_part)
+        max_FEM_node_Id = ParticleCreatorDestructor().FindMaxNodeIdInModelPart(rigid_face_model_part)
+        max_element_Id = ParticleCreatorDestructor().FindMaxElementIdInModelPart(spheres_model_part)
+        max_FEM_element_Id = ParticleCreatorDestructor().FindMaxElementIdInModelPart(rigid_face_model_part)
+
+        if max_FEM_node_Id > max_node_Id:
+            max_node_Id = max_FEM_node_Id
+
+        if max_FEM_element_Id > max_element_Id:
+            max_element_Id = max_FEM_element_Id
+
+        # Z = 0.0 as sea level. We will always assume this value
+        node1 = sea_surface_model_part.CreateNewNode(max_node_Id + 9, self.SeaSurfaceX1, self.SeaSurfaceY1, 0.0)
+        node2 = sea_surface_model_part.CreateNewNode(max_node_Id + 10, self.SeaSurfaceX2, self.SeaSurfaceY2, 0.0)
+        node3 = sea_surface_model_part.CreateNewNode(max_node_Id + 11, self.SeaSurfaceX3, self.SeaSurfaceY3, 0.0)
+        node4 = sea_surface_model_part.CreateNewNode(max_node_Id + 12, self.SeaSurfaceX4, self.SeaSurfaceY4, 0.0)
+
+        ''' Properties colours: 0 -> grey,        1 -> dark blue, 2 -> pink,       3 -> light blue,       4 -> dark red,    5 -> light green
+                                6 -> light brown, 7 -> red-brown, 8 -> dark brown, 9 -> dark green/blue, 10 -> dark purple'''
+
+        # Sea Surface Element, consisting in a quadrilateral. Property 3 corresponds to a light blue for water
+        sea_surface_model_part.CreateNewCondition("RigidFace3D4N", max_element_Id + 1, [node1.Id, node2.Id, node3.Id, node4.Id], Properties(3))
+
+        self.gid_io.WriteMesh(
+            sea_surface_model_part.GetCommunicator().LocalMesh())
+
+    def ComputeAndPrintDEMFEMSearchBinBoundingBox(self, spheres_model_part, rigid_face_model_part, dem_fem_search):
+
+        bounding_box_model_part = self.model.CreateModelPart("BoundingBoxPart")
+
+        max_node_Id = ParticleCreatorDestructor().FindMaxNodeIdInModelPart(spheres_model_part)
+        max_FEM_node_Id = ParticleCreatorDestructor().FindMaxNodeIdInModelPart(rigid_face_model_part)
+        max_element_Id = ParticleCreatorDestructor().FindMaxElementIdInModelPart(spheres_model_part)
+        max_FEM_element_Id = ParticleCreatorDestructor().FindMaxElementIdInModelPart(rigid_face_model_part)
+
+        if max_FEM_node_Id > max_node_Id:
+            max_node_Id = max_FEM_node_Id
+
+        if max_FEM_element_Id > max_element_Id:
+            max_element_Id = max_FEM_element_Id
+
+        BBMaxX = dem_fem_search.GetBBHighPoint()[0]
+        BBMaxY = dem_fem_search.GetBBHighPoint()[1]
+        BBMaxZ = dem_fem_search.GetBBHighPoint()[2]
+        BBMinX = dem_fem_search.GetBBLowPoint()[0]
+        BBMinY = dem_fem_search.GetBBLowPoint()[1]
+        BBMinZ = dem_fem_search.GetBBLowPoint()[2]
+
+        DX = (BBMaxX - BBMinX)
+        DY = (BBMaxY - BBMinY)
+        DZ = (BBMaxZ - BBMinZ)
+
+        #The cases with 0 thickness in one direction, a 10% of the shortest other two is given to the 0-thickness direction.
+        if DX == 0:
+            height = min(DY, DZ)
+            BBMinX = BBMinX - 0.05 * height
+            BBMaxX = BBMaxX + 0.05 * height
+        if DY == 0:
+            height = min(DX, DZ)
+            BBMinY = BBMinY - 0.05 * height
+            BBMaxY = BBMaxY + 0.05 * height
+        if DZ == 0:
+            height = min(DX, DY)
+            BBMinZ = BBMinZ - 0.05 * height
+            BBMaxZ = BBMaxZ + 0.05 * height
+
+        volume = DX * DY * DZ
+
+        if abs(volume) > 1e21:
+            BBMaxX = 0.0
+            BBMaxY = 0.0
+            BBMaxZ = 0.0
+            BBMinX = 0.0
+            BBMinY = 0.0
+            BBMinZ = 0.0
+
+        self.BuildGraphicalBoundingBox(bounding_box_model_part, max_node_Id, max_element_Id, BBMinX, BBMinY, BBMinZ, BBMaxX, BBMaxY, BBMaxZ)
+
+        self.model.DeleteModelPart("BoundingBoxPart")
+
+        #self.gid_io.WriteMesh(bounding_box_model_part.GetCommunicator().LocalMesh()) #BOUNDING BOX IMPLEMENTATION
+
+    def BuildGraphicalBoundingBox(self, bounding_box_model_part, max_node_Id, max_element_Id, BBMinX, BBMinY, BBMinZ, BBMaxX, BBMaxY, BBMaxZ):
+        # BB Nodes:
+        node1 = bounding_box_model_part.CreateNewNode(max_node_Id + 1, BBMinX, BBMinY, BBMinZ)
+        node2 = bounding_box_model_part.CreateNewNode(max_node_Id + 2, BBMaxX, BBMinY, BBMinZ)
+        node3 = bounding_box_model_part.CreateNewNode(max_node_Id + 3, BBMaxX, BBMaxY, BBMinZ)
+        node4 = bounding_box_model_part.CreateNewNode(max_node_Id + 4, BBMinX, BBMaxY, BBMinZ)
+        node5 = bounding_box_model_part.CreateNewNode(max_node_Id + 5, BBMinX, BBMinY, BBMaxZ)
+        node6 = bounding_box_model_part.CreateNewNode(max_node_Id + 6, BBMaxX, BBMinY, BBMaxZ)
+        node7 = bounding_box_model_part.CreateNewNode(max_node_Id + 7, BBMaxX, BBMaxY, BBMaxZ)
+        node8 = bounding_box_model_part.CreateNewNode(max_node_Id + 8, BBMinX, BBMaxY, BBMaxZ)
+
+        # BB Elements:
+        props = Properties(10000)
+        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 1, [node1.Id, node4.Id], props)
+        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 2, [node4.Id, node8.Id], props)
+        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 3, [node8.Id, node5.Id], props)
+        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 4, [node5.Id, node1.Id], props)
+        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 5, [node1.Id, node2.Id], props)
+        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 6, [node3.Id, node4.Id], props)
+        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 7, [node7.Id, node8.Id], props)
+        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 8, [node5.Id, node6.Id], props)
+        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 9, [node6.Id, node2.Id], props)
+        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 10, [node2.Id, node3.Id], props)
+        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 11, [node3.Id, node7.Id], props)
+        bounding_box_model_part.CreateNewCondition("RigidFace3D2N", max_element_Id + 12, [node7.Id, node6.Id], props)
+
+
+
+class ParallelUtils():
+
+    def __init__(self):
+        pass
+
+    def Repart(self, spheres_model_part):
+        pass
+
+    def CalculateModelNewIds(self, spheres_model_part):
+        pass
+
+    def PerformInitialPartition(self, model_part):
+        pass
+
+    def SetCommunicator(self, spheres_model_part, model_part_io_spheres, spheres_mp_filename):
+        return [model_part_io_spheres, spheres_model_part]
+
+    def GetSearchStrategy(self, solver, model_part):
+        return solver.search_strategy
```

## KratosMultiphysics/DEMApplication/automatic_dt_process.py

 * *Ordering differences only*

```diff
@@ -1,19 +1,19 @@
-import KratosMultiphysics
-import KratosMultiphysics.DEMApplication as Dem
-
-def Factory(settings, Model):
-    if not isinstance(settings, KratosMultiphysics.Parameters):
-        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
-    return AutomaticDTProcess(Model, settings["Parameters"])
-
-## All the processes python should be derived from "Process"
-
-class AutomaticDTProcess(KratosMultiphysics.Process):
-    def __init__(self, Model, settings ):
-        KratosMultiphysics.Process.__init__(self)
-
-        self.model_part = Model[settings["model_part_name"].GetString()]
-        self.automatic_dt_process = Dem.AutomaticDTProcess(self.model_part, settings)
-
-    def ExecuteBeforeSolutionLoop(self):
+import KratosMultiphysics
+import KratosMultiphysics.DEMApplication as Dem
+
+def Factory(settings, Model):
+    if not isinstance(settings, KratosMultiphysics.Parameters):
+        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
+    return AutomaticDTProcess(Model, settings["Parameters"])
+
+## All the processes python should be derived from "Process"
+
+class AutomaticDTProcess(KratosMultiphysics.Process):
+    def __init__(self, Model, settings ):
+        KratosMultiphysics.Process.__init__(self)
+
+        self.model_part = Model[settings["model_part_name"].GetString()]
+        self.automatic_dt_process = Dem.AutomaticDTProcess(self.model_part, settings)
+
+    def ExecuteBeforeSolutionLoop(self):
         self.automatic_dt_process.ExecuteBeforeSolutionLoop()
```

## KratosMultiphysics/DEMApplication/DEM_inlet_process.py

 * *Ordering differences only*

```diff
@@ -1,64 +1,64 @@
-from KratosMultiphysics.DEMApplication import *
-
-
-class DEM_Inlet_Process:
-
-    # NOTE: this function is designed with the idea that different derived operations are allowed to have different constructors.
-    # nevertheless for ease of usage, we propose a rather wide range of "default parameters" which should be sufficient
-    # to implement most user operations
-    #
-    # model_part -> model_part to which the operation will be applied
-    # group_container -> container of the groups. Can be queried for the nodes that correspond to a given group Id
-    # group_ids -> python array containing the ids of the groups to which the operation should be applied
-    # table_ids --> python array containing the ids of the tables to be applied
-    # echo_level -> level of expected echo for the operation: echo_level=0 implies no echo
-    def __init__(self, solid_model_part, creator, inlet_model_part, parameters, echo_level=0):
-        self.inlet = DEM_Inlet(inlet_model_part)
-        self.inlet_model_part = inlet_model_part
-        self.solid_model_part = solid_model_part
-        self.creator = creator
-        self.parameters = parameters
-        self.echo_level = echo_level
-
-    def PrintInfo(self):
-        print("PrintInfo")
-    # this function is designed for being called at the beginning of the computations
-    # right after reading the model and the groups
-
-    def ExecuteInitialize(self):
-        if(self.echo_level > 0):
-            print("Finished ExecuteInitialize for Class", self.PrintInfo())
-
-    # this function is designed for being execute once before the solution loop but after all of the
-    # solvers where built
-    def ExecuteBeforeSolutionLoop(self):
-        if(self.echo_level > 0):
-            print("Finished ExecuteBeforeSolutionLoop for Class", self.PrintInfo())
-
-    # this function will be executed at every time step BEFORE performing the solve phase
-    def ExecuteInitializeSolutionStep(self):
-        if(self.echo_level > 0):
-            print("Inserting new DEM elements...")
-        self.inlet.CreateElementsFromInletMesh(self.solid_model_part, self.inlet_model_part, self.creator)
-        print("Finished ExecuteInitializeSolutionStep for Class", self.PrintInfo())
-
-    # this function will be executed at every time step AFTER performing the solve phase
-    def ExecuteFinalizeSolutionStep(self):
-        if(self.echo_level > 0):
-            print("Finished ExecuteFinalizeSolutionStep for Class", self.PrintInfo())
-
-    # this function will be executed at every time step BEFORE  writing the output
-    def ExecuteBeforeOutputStep(self):
-        if(self.echo_level > 0):
-            print("Finished ExecuteBeforeOutputStep for Class", self.PrintInfo())
-
-    # this function will be executed at every time step AFTER writing the output
-    def ExecuteAfterOutputStep(self):
-        if(self.echo_level > 0):
-            print("Finished ExecuteAfterOutputStep for Class", self.PrintInfo())
-
-    # this function is designed for being called at the beginning of the computations
-    # right after reading the model and the groups
-    def ExecuteFinalize(self):
-        if(self.echo_level > 0):
-            print("Finished ExecuteFinalize for Class", self.PrintInfo())
+from KratosMultiphysics.DEMApplication import *
+
+
+class DEM_Inlet_Process:
+
+    # NOTE: this function is designed with the idea that different derived operations are allowed to have different constructors.
+    # nevertheless for ease of usage, we propose a rather wide range of "default parameters" which should be sufficient
+    # to implement most user operations
+    #
+    # model_part -> model_part to which the operation will be applied
+    # group_container -> container of the groups. Can be queried for the nodes that correspond to a given group Id
+    # group_ids -> python array containing the ids of the groups to which the operation should be applied
+    # table_ids --> python array containing the ids of the tables to be applied
+    # echo_level -> level of expected echo for the operation: echo_level=0 implies no echo
+    def __init__(self, solid_model_part, creator, inlet_model_part, parameters, echo_level=0):
+        self.inlet = DEM_Inlet(inlet_model_part)
+        self.inlet_model_part = inlet_model_part
+        self.solid_model_part = solid_model_part
+        self.creator = creator
+        self.parameters = parameters
+        self.echo_level = echo_level
+
+    def PrintInfo(self):
+        print("PrintInfo")
+    # this function is designed for being called at the beginning of the computations
+    # right after reading the model and the groups
+
+    def ExecuteInitialize(self):
+        if(self.echo_level > 0):
+            print("Finished ExecuteInitialize for Class", self.PrintInfo())
+
+    # this function is designed for being execute once before the solution loop but after all of the
+    # solvers where built
+    def ExecuteBeforeSolutionLoop(self):
+        if(self.echo_level > 0):
+            print("Finished ExecuteBeforeSolutionLoop for Class", self.PrintInfo())
+
+    # this function will be executed at every time step BEFORE performing the solve phase
+    def ExecuteInitializeSolutionStep(self):
+        if(self.echo_level > 0):
+            print("Inserting new DEM elements...")
+        self.inlet.CreateElementsFromInletMesh(self.solid_model_part, self.inlet_model_part, self.creator)
+        print("Finished ExecuteInitializeSolutionStep for Class", self.PrintInfo())
+
+    # this function will be executed at every time step AFTER performing the solve phase
+    def ExecuteFinalizeSolutionStep(self):
+        if(self.echo_level > 0):
+            print("Finished ExecuteFinalizeSolutionStep for Class", self.PrintInfo())
+
+    # this function will be executed at every time step BEFORE  writing the output
+    def ExecuteBeforeOutputStep(self):
+        if(self.echo_level > 0):
+            print("Finished ExecuteBeforeOutputStep for Class", self.PrintInfo())
+
+    # this function will be executed at every time step AFTER writing the output
+    def ExecuteAfterOutputStep(self):
+        if(self.echo_level > 0):
+            print("Finished ExecuteAfterOutputStep for Class", self.PrintInfo())
+
+    # this function is designed for being called at the beginning of the computations
+    # right after reading the model and the groups
+    def ExecuteFinalize(self):
+        if(self.echo_level > 0):
+            print("Finished ExecuteFinalize for Class", self.PrintInfo())
```

## KratosMultiphysics/DEMApplication/verlet_continuum_sphere_strategy.py

 * *Ordering differences only*

```diff
@@ -1,88 +1,88 @@
-from KratosMultiphysics import *
-from KratosMultiphysics.DEMApplication import *
-
-
-# DEM Application using Velocity Verlet 2-step scheme for continuum
-
-import KratosMultiphysics.DEMApplication.continuum_sphere_strategy as SolverStrategy
-
-BaseExplicitStrategy = SolverStrategy.ExplicitStrategy
-
-class ExplicitStrategy(BaseExplicitStrategy):
-
-    def __init__(self, model_part, fem_model_part, cluster_model_part, inlet_model_part, creator_destructor, dem_fem_search, DEM_parameters, procedures):
-
-        BaseExplicitStrategy.__init__(self, model_part, fem_model_part, cluster_model_part, inlet_model_part, creator_destructor, dem_fem_search, DEM_parameters, procedures)
-
-    def AddAdditionalVariables(self, model_part, DEM_parameters):
-
-        BaseExplicitStrategy.AddAdditionalVariables(self, model_part, DEM_parameters)
-
-    def CreateCPlusPlusStrategy(self):
-
-        #BaseExplicitStrategy.Initialize  (revisar si es pot cridar desde el basetype)
-        #self.cplusplus_strategy = IterativeExplicitSolverStrategy(self.settings, self.max_delta_time, self.n_step_search, self.safety_factor,
-
-        # Setting ProcessInfo variables
-
-        # SIMULATION FLAGS
-        self.model_part.ProcessInfo.SetValue(VIRTUAL_MASS_OPTION, self.virtual_mass_option)
-        self.model_part.ProcessInfo.SetValue(TRIHEDRON_OPTION, self.trihedron_option)
-        self.SetOneOrZeroInProcessInfoAccordingToBoolValue(self.spheres_model_part, ROTATION_OPTION, self.rotation_option)
-        self.SetOneOrZeroInProcessInfoAccordingToBoolValue(self.spheres_model_part, BOUNDING_BOX_OPTION, self.bounding_box_option) #TODO: check that this is finding the function in base classes
-        self.model_part.ProcessInfo.SetValue(SEARCH_CONTROL, self.search_control)
-        self.model_part.ProcessInfo.SetValue(FIX_VELOCITIES_FLAG, self.fix_velocities_flag)
-        self.model_part.ProcessInfo.SetValue(NEIGH_INITIALIZED, 0)
-        self.model_part.ProcessInfo.SetValue(CLEAN_INDENT_OPTION, self.clean_init_indentation_option)
-        self.model_part.ProcessInfo.SetValue(COMPUTE_STRESS_TENSOR_OPTION, self.compute_stress_tensor_option)
-
-        # GLOBAL PHISICAL ASPECTS
-        self.model_part.ProcessInfo.SetValue(GRAVITY, self.gravity)
-
-        # GLOBAL MATERIAL PROPERTIES
-        self.model_part.ProcessInfo.SetValue(NODAL_MASS_COEFF, self.nodal_mass_coeff)
-
-        # PRINTING VARIABLES
-        self.model_part.ProcessInfo.SetValue(PRINT_EXPORT_ID, self.print_export_id)
-        self.SetOneOrZeroInProcessInfoAccordingToBoolValue(self.spheres_model_part, ROLLING_FRICTION_OPTION, self.rolling_friction_option)
-
-        # TIME RELATED PARAMETERS
-        self.model_part.ProcessInfo.SetValue(DELTA_TIME, self.dt)
-
-        for properties in self.model_part.Properties:
-            self.ModifyProperties(properties)
-
-        for properties in self.inlet_model_part.Properties:
-            self.ModifyProperties(properties)
-
-        # CONTINUUM
-        self.search_increment_for_walls = 0.0 # for the moment, until all bugs are removed
-        self.model_part.ProcessInfo.SetValue(SEARCH_RADIUS_INCREMENT, self.search_increment)
-        self.spheres_model_part.ProcessInfo.SetValue(SEARCH_RADIUS_INCREMENT_FOR_WALLS, self.search_increment_for_walls)
-        self.model_part.ProcessInfo.SetValue(CONTINUUM_SEARCH_RADIUS_AMPLIFICATION_FACTOR, self.continuum_search_radius_amplification_factor)
-        self.model_part.ProcessInfo.SetValue(LOCAL_RESOLUTION_METHOD, self.local_resolution_method)
-
-        if self.contact_mesh_option:
-            self.model_part.ProcessInfo.SetValue(CONTACT_MESH_OPTION, 1) #TODO: convert this variable to BOOL in Kratos
-        else:
-            self.model_part.ProcessInfo.SetValue(CONTACT_MESH_OPTION, 0)
-
-        #self.model_part.ProcessInfo.SetValue(FAILURE_CRITERION_OPTION, self.failure_criterion_option)
-
-        if ( (self.test_type == "Triaxial") or (self.test_type == "Hydrostatic")):
-            self.model_part.ProcessInfo.SetValue(TRIAXIAL_TEST_OPTION, 1)
-
-        # RESOLUTION METHODS AND PARAMETERS
-        # Creating the solution strategy
-        self.settings = ExplicitSolverSettings()
-        self.settings.r_model_part = self.model_part
-        self.settings.contact_model_part = self.contact_model_part
-        self.settings.fem_model_part = self.fem_model_part
-        self.settings.inlet_model_part = self.inlet_model_part
-        self.settings.cluster_model_part = self.cluster_model_part
-
-        self.cplusplus_strategy = VelocityVerletSolverStrategy(self.settings, self.max_delta_time, self.n_step_search, self.safety_factor, self.delta_option, self.creator_destructor, self.dem_fem_search, self.search_strategy)
-
-    def Initialize(self):
-
-        self.cplusplus_strategy.Initialize()  # Calls the cplusplus_strategy Initialize function (initializes all elements and performs other necessary tasks before iterating)
+from KratosMultiphysics import *
+from KratosMultiphysics.DEMApplication import *
+
+
+# DEM Application using Velocity Verlet 2-step scheme for continuum
+
+import KratosMultiphysics.DEMApplication.continuum_sphere_strategy as SolverStrategy
+
+BaseExplicitStrategy = SolverStrategy.ExplicitStrategy
+
+class ExplicitStrategy(BaseExplicitStrategy):
+
+    def __init__(self, model_part, fem_model_part, cluster_model_part, inlet_model_part, creator_destructor, dem_fem_search, DEM_parameters, procedures):
+
+        BaseExplicitStrategy.__init__(self, model_part, fem_model_part, cluster_model_part, inlet_model_part, creator_destructor, dem_fem_search, DEM_parameters, procedures)
+
+    def AddAdditionalVariables(self, model_part, DEM_parameters):
+
+        BaseExplicitStrategy.AddAdditionalVariables(self, model_part, DEM_parameters)
+
+    def CreateCPlusPlusStrategy(self):
+
+        #BaseExplicitStrategy.Initialize  (revisar si es pot cridar desde el basetype)
+        #self.cplusplus_strategy = IterativeExplicitSolverStrategy(self.settings, self.max_delta_time, self.n_step_search, self.safety_factor,
+
+        # Setting ProcessInfo variables
+
+        # SIMULATION FLAGS
+        self.model_part.ProcessInfo.SetValue(VIRTUAL_MASS_OPTION, self.virtual_mass_option)
+        self.model_part.ProcessInfo.SetValue(TRIHEDRON_OPTION, self.trihedron_option)
+        self.SetOneOrZeroInProcessInfoAccordingToBoolValue(self.spheres_model_part, ROTATION_OPTION, self.rotation_option)
+        self.SetOneOrZeroInProcessInfoAccordingToBoolValue(self.spheres_model_part, BOUNDING_BOX_OPTION, self.bounding_box_option) #TODO: check that this is finding the function in base classes
+        self.model_part.ProcessInfo.SetValue(SEARCH_CONTROL, self.search_control)
+        self.model_part.ProcessInfo.SetValue(FIX_VELOCITIES_FLAG, self.fix_velocities_flag)
+        self.model_part.ProcessInfo.SetValue(NEIGH_INITIALIZED, 0)
+        self.model_part.ProcessInfo.SetValue(CLEAN_INDENT_OPTION, self.clean_init_indentation_option)
+        self.model_part.ProcessInfo.SetValue(COMPUTE_STRESS_TENSOR_OPTION, self.compute_stress_tensor_option)
+
+        # GLOBAL PHISICAL ASPECTS
+        self.model_part.ProcessInfo.SetValue(GRAVITY, self.gravity)
+
+        # GLOBAL MATERIAL PROPERTIES
+        self.model_part.ProcessInfo.SetValue(NODAL_MASS_COEFF, self.nodal_mass_coeff)
+
+        # PRINTING VARIABLES
+        self.model_part.ProcessInfo.SetValue(PRINT_EXPORT_ID, self.print_export_id)
+        self.SetOneOrZeroInProcessInfoAccordingToBoolValue(self.spheres_model_part, ROLLING_FRICTION_OPTION, self.rolling_friction_option)
+
+        # TIME RELATED PARAMETERS
+        self.model_part.ProcessInfo.SetValue(DELTA_TIME, self.dt)
+
+        for properties in self.model_part.Properties:
+            self.ModifyProperties(properties)
+
+        for properties in self.inlet_model_part.Properties:
+            self.ModifyProperties(properties)
+
+        # CONTINUUM
+        self.search_increment_for_walls = 0.0 # for the moment, until all bugs are removed
+        self.model_part.ProcessInfo.SetValue(SEARCH_RADIUS_INCREMENT, self.search_increment)
+        self.spheres_model_part.ProcessInfo.SetValue(SEARCH_RADIUS_INCREMENT_FOR_WALLS, self.search_increment_for_walls)
+        self.model_part.ProcessInfo.SetValue(CONTINUUM_SEARCH_RADIUS_AMPLIFICATION_FACTOR, self.continuum_search_radius_amplification_factor)
+        self.model_part.ProcessInfo.SetValue(LOCAL_RESOLUTION_METHOD, self.local_resolution_method)
+
+        if self.contact_mesh_option:
+            self.model_part.ProcessInfo.SetValue(CONTACT_MESH_OPTION, 1) #TODO: convert this variable to BOOL in Kratos
+        else:
+            self.model_part.ProcessInfo.SetValue(CONTACT_MESH_OPTION, 0)
+
+        #self.model_part.ProcessInfo.SetValue(FAILURE_CRITERION_OPTION, self.failure_criterion_option)
+
+        if ( (self.test_type == "Triaxial") or (self.test_type == "Hydrostatic")):
+            self.model_part.ProcessInfo.SetValue(TRIAXIAL_TEST_OPTION, 1)
+
+        # RESOLUTION METHODS AND PARAMETERS
+        # Creating the solution strategy
+        self.settings = ExplicitSolverSettings()
+        self.settings.r_model_part = self.model_part
+        self.settings.contact_model_part = self.contact_model_part
+        self.settings.fem_model_part = self.fem_model_part
+        self.settings.inlet_model_part = self.inlet_model_part
+        self.settings.cluster_model_part = self.cluster_model_part
+
+        self.cplusplus_strategy = VelocityVerletSolverStrategy(self.settings, self.max_delta_time, self.n_step_search, self.safety_factor, self.delta_option, self.creator_destructor, self.dem_fem_search, self.search_strategy)
+
+    def Initialize(self):
+
+        self.cplusplus_strategy.Initialize()  # Calls the cplusplus_strategy Initialize function (initializes all elements and performs other necessary tasks before iterating)
```

## KratosMultiphysics/DEMApplication/__init__.py

 * *Ordering differences only*

```diff
@@ -1,7 +1,7 @@
-from KratosDEMApplication import *
-
-from KratosMultiphysics import _ImportApplication
-application = KratosDEMApplication()
-application_name = "KratosDEMApplication"
-
-_ImportApplication(application, application_name)
+from KratosDEMApplication import *
+
+from KratosMultiphysics import _ImportApplication
+application = KratosDEMApplication()
+application_name = "KratosDEMApplication"
+
+_ImportApplication(application, application_name)
```

## KratosMultiphysics/DEMApplication/DEM_material_test_script_mpi.py

 * *Ordering differences only*

```diff
@@ -1,252 +1,252 @@
-from functools import reduce
-
-import math
-import datetime
-import shutil
-
-from KratosMultiphysics import *
-from KratosMultiphysics.DEMApplication import *
-from KratosMultiphysics.mpi import *
-
-import KratosMultiphysics.DEMApplication.DEM_material_test_script as DEM_material_test_script
-
-class MaterialTest(DEM_material_test_script.MaterialTest):
-
-  def __init__(self, DEM_parameters, procedures, solver, graphs_path, post_path, spheres_model_part, rigid_face_model_part):
-      super().__init__(DEM_parameters, procedures, solver, graphs_path, post_path, spheres_model_part, rigid_face_model_part)
-
-  def Initialize(self):
-      super().Initialize()
-
-  def Flush(self,a):
-      pass
-
-  def PrepareTests(self):
-      ##Fixing horizontally top and bot
-      if(self.parameters.TestType != "BTS"):
-
-        for node in self.TOP:
-
-          node.SetSolutionStepValue(VELOCITY_X, 0.0);
-          node.SetSolutionStepValue(VELOCITY_Z, 0.0);
-          node.Fix(VELOCITY_X);
-          node.Fix(VELOCITY_Z);
-
-        for node in self.BOT:
-
-          node.SetSolutionStepValue(VELOCITY_X, 0.0);
-          node.SetSolutionStepValue(VELOCITY_Z, 0.0);
-          node.Fix(VELOCITY_X);
-          node.Fix(VELOCITY_Z);
-
-      if(self.parameters.TestType == "BTS"):
-
-        self.bts_export = open(self.parameters.problem_name + "_bts" + ".grf", 'w');
-        self.BtsSkinDetermination()
-
-      else:
-
-        self.graph_export = open(self.parameters.problem_name +"_graph.grf", 'w')
-        self.graph_export_1 = open(self.parameters.problem_name +"_graph_top.grf", 'w')
-        self.graph_export_2 = open(self.parameters.problem_name +"_graph_bot.grf", 'w')
-
-        if( self.parameters.TestType =="Hydrostatic"):
-          self.graph_export_volumetric = open(self.parameters.problem_name+"_graph_VOL.grf",'w')
-
-        print ('Initial Height of the Model: ' + str(self.height)+'\n')
-
-        #if(self.parameters.PredefinedSkinOption == "ON" ):
-        #  print ("ERROR: in Concrete Test Option the Skin is automatically predefined. Switch the Predefined Skin Option OFF")
-
-        (xtop_area,xbot_area,xlat_area,xtopcorner_area,xbotcorner_area,y_top_total,weight_top, y_bot_total, weight_bot) = self.CylinderSkinDetermination()
-
-        xtop_area_gath        = mpi.allgather_double(mpi.world, xtop_area)
-        xbot_area_gath        = mpi.allgather_double(mpi.world, xbot_area)
-        xlat_area_gath        = mpi.allgather_double(mpi.world, xlat_area)
-        xtopcorner_area_gath  = mpi.allgather_double(mpi.world, xtopcorner_area)
-        xbotcorner_area_gath  = mpi.allgather_double(mpi.world, xbotcorner_area)
-
-        xtop_area = reduce(lambda x, y: x + y, xtop_area_gath)
-        xbot_area = reduce(lambda x, y: x + y, xbot_area_gath)
-        xlat_area = reduce(lambda x, y: x + y, xlat_area_gath)
-        xtopcorner_area = reduce(lambda x, y: x + y, xtopcorner_area_gath)
-        xbotcorner_area = reduce(lambda x, y: x + y, xbotcorner_area_gath)
-
-        weight_top_gath = mpi.allgather_double(mpi.world, weight_top)
-        weight_bot_gath = mpi.allgather_double(mpi.world, weight_bot)
-        y_top_total_gath = mpi.allgather_double(mpi.world, y_top_total)
-        y_bot_total_gath = mpi.allgather_double(mpi.world, y_bot_total)
-
-        weight_top = reduce(lambda x, y: x + y, weight_top_gath)
-        weight_bot = reduce(lambda x, y: x + y, weight_bot_gath)
-        y_top_total = reduce(lambda x, y: x + y, y_top_total_gath)
-        y_bot_total = reduce(lambda x, y: x + y, y_bot_total_gath)
-
-        initial_height_top = y_top_total/weight_top
-        initial_height_bot = y_bot_total/weight_bot
-
-        inner_initial_height = initial_height_top - initial_height_bot
-
-        specimen_length = self.parameters.SpecimenLength
-        extended_length = specimen_length + (specimen_length - inner_initial_height)
-
-        self.length_correction_factor = specimen_length/extended_length
-
-  def PrepareDataForGraph(self):
-
-    prepare_check = [0,0,0,0]
-    prepare_check_gath = [0,0,0,0]
-    self.total_check = 0
-
-    for smp in self.rigid_face_model_part.SubModelParts:
-        if smp[TOP]:
-            self.top_mesh_nodes = smp.Nodes
-            prepare_check[0] = 1
-        if smp[BOTTOM]:
-            self.bot_mesh_nodes = smp.Nodes
-            prepare_check[1] = 1
-
-    for smp in self.spheres_model_part.SubModelParts:
-        if smp[TOP]:
-            self.top_mesh_nodes = smp.Nodes
-            prepare_check[2] = -1
-
-        if smp[BOTTOM]:
-            self.bot_mesh_nodes = smp.Nodes
-            prepare_check[3] = -1
-
-    prepare_check_gath[0] = mpi.gather_int(mpi.world,prepare_check[0],0)
-    prepare_check_gath[1] = mpi.gather_int(mpi.world,prepare_check[1],0)
-    prepare_check_gath[2] = mpi.gather_int(mpi.world,prepare_check[2],0)
-    prepare_check_gath[3] = mpi.gather_int(mpi.world,prepare_check[3],0)
-
-    if(mpi.rank == 0 ):
-      prepare_check[0] = reduce(lambda x,y: max(x,y), prepare_check_gath[0])
-      prepare_check[1] = reduce(lambda x,y: max(x,y), prepare_check_gath[1])
-      prepare_check[2] = reduce(lambda x,y: min(x,y), prepare_check_gath[2])
-      prepare_check[3] = reduce(lambda x,y: min(x,y), prepare_check_gath[3])
-
-      for it in range(len(prepare_check)):
-
-        self.total_check += prepare_check[it]
-
-      if(math.fabs(self.total_check)!=2):
-
-        Logger.PrintWarning(" ERROR in the definition of TOP BOT groups. Both groups are required to be defined, they have to be either on FEM groups or in DEM groups")
-
-  def MeasureForcesAndPressure(self):
-
-    dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
-
-    #if(mpi.rank == 0 ):
-    self.strain += -100.0*self.length_correction_factor*1.0*self.parameters.LoadingVelocityTop*dt/self.parameters.SpecimenLength
-
-    if( self.parameters.TestType =="BTS"):
-
-      total_force_bts = 0.0
-
-      for node in self.top_mesh_nodes:
-
-        force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-        total_force_bts += force_node_y
-
-      if(mpi.rank == 0 ):
-        total_force_bts_gather = mpi.gather_double(mpi.world, total_force_bts, 0)
-        total_force_bts = reduce(lambda x, y: x + y, total_force_bts_gather)
-
-        self.total_stress_bts = 2.0*total_force_bts/(3.14159*self.parameters.SpecimenLength*self.parameters.SpecimenDiameter*1e6)
-        self.strain_bts += -100.0*2*self.parameters.LoadingVelocityTop*dt/self.parameters.SpecimenDiameter
-
-    else:
-
-      if( self.parameters.TestType =="Hydrostatic"):
-
-        radial_strain = -100*self.MeasureRadialStrain()
-        if(mpi.rank == 0):
-          self.volumetric_strain = self.strain + 2.0*radial_strain
-
-      total_force_top = 0.0
-      total_force_bot = 0.0
-
-      for node in self.top_mesh_nodes:
-
-        force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-
-        total_force_top += force_node_y
-
-      total_force_top_gath = mpi.allgather_double(mpi.world, total_force_top)
-      total_force_top = reduce(lambda x, y: x + y, total_force_top_gath)
-
-      self.total_stress_top = total_force_top/(self.MeasuringSurface * 1000000)
-
-      for node in self.bot_mesh_nodes:
-
-        force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
-
-        total_force_bot += force_node_y
-
-      total_force_bot_gath = mpi.allgather_double(mpi.world, total_force_bot)
-      total_force_bot = reduce(lambda x, y: x + y, total_force_bot_gath)
-
-      self.total_stress_bot = total_force_bot/(self.MeasuringSurface * 1000000)
-      self.total_stress_mean = 0.5*(self.total_stress_bot + self.total_stress_top)
-
-      if( ( (self.parameters.TestType == "Triaxial") or (self.parameters.TestType == "Hydrostatic") ) and (self.parameters.ConfinementPressure != 0.0) ):
-
-          self.Pressure = min(self.total_stress_mean*1e6, self.parameters.ConfinementPressure * 1e6)
-
-          if( self.parameters.TestType == "Hydrostatic"):
-
-              self.Pressure = self.total_stress_mean*1e6
-
-          self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
-
-  def PrintGraph(self,step):
-      if(mpi.rank == 0 ):
-          super().PrintGraph(step)
-
-  def PrintChart(self):
-      if(mpi.rank == 0 ):
-          super().PrintChart()
-
-  def FinalizeGraphs(self):
-      if(mpi.rank == 0):
-          super().FinalizeGraphs()
-
-  def MeasureRadialStrain(self):
-
-    mean_radial_strain = 0.0
-    radial_strain = 0.0
-    weight = 0.0
-
-    for node in self.XLAT:
-
-      r = node.GetSolutionStepValue(RADIUS)
-      x = node.X
-      z = node.Z
-
-      x0 = node.X0
-      z0 = node.Z0
-
-      dist_initial = math.sqrt(x0 * x0 + z0 * z0)
-      dist_now = math.sqrt(x * x + z * z)
-
-      node_radial_strain = (dist_now - dist_initial) / dist_initial
-
-      mean_radial_strain += node_radial_strain*r*r
-
-      weight += r*r
-
-    mean_radial_strain_gath = mpi.allgather_double(mpi.world,mean_radial_strain)
-    weight_gath = mpi.allgather_double(mpi.world,weight)
-
-    mean_radial_strain = reduce(lambda x, y: x + y, mean_radial_strain_gath)
-    weight = reduce(lambda x, y: x + y, weight_gath)
-
-    if(mpi.rank == 0 ):
-      if(weight == 0.0):
-        print ("Error in MeasureRadialStrain. Lateral skin particles not well defined")
-
-    radial_strain = mean_radial_strain/weight
-
-    return radial_strain
+from functools import reduce
+
+import math
+import datetime
+import shutil
+
+from KratosMultiphysics import *
+from KratosMultiphysics.DEMApplication import *
+from KratosMultiphysics.mpi import *
+
+import KratosMultiphysics.DEMApplication.DEM_material_test_script as DEM_material_test_script
+
+class MaterialTest(DEM_material_test_script.MaterialTest):
+
+  def __init__(self, DEM_parameters, procedures, solver, graphs_path, post_path, spheres_model_part, rigid_face_model_part):
+      super().__init__(DEM_parameters, procedures, solver, graphs_path, post_path, spheres_model_part, rigid_face_model_part)
+
+  def Initialize(self):
+      super().Initialize()
+
+  def Flush(self,a):
+      pass
+
+  def PrepareTests(self):
+      ##Fixing horizontally top and bot
+      if(self.parameters.TestType != "BTS"):
+
+        for node in self.TOP:
+
+          node.SetSolutionStepValue(VELOCITY_X, 0.0);
+          node.SetSolutionStepValue(VELOCITY_Z, 0.0);
+          node.Fix(VELOCITY_X);
+          node.Fix(VELOCITY_Z);
+
+        for node in self.BOT:
+
+          node.SetSolutionStepValue(VELOCITY_X, 0.0);
+          node.SetSolutionStepValue(VELOCITY_Z, 0.0);
+          node.Fix(VELOCITY_X);
+          node.Fix(VELOCITY_Z);
+
+      if(self.parameters.TestType == "BTS"):
+
+        self.bts_export = open(self.parameters.problem_name + "_bts" + ".grf", 'w');
+        self.BtsSkinDetermination()
+
+      else:
+
+        self.graph_export = open(self.parameters.problem_name +"_graph.grf", 'w')
+        self.graph_export_1 = open(self.parameters.problem_name +"_graph_top.grf", 'w')
+        self.graph_export_2 = open(self.parameters.problem_name +"_graph_bot.grf", 'w')
+
+        if( self.parameters.TestType =="Hydrostatic"):
+          self.graph_export_volumetric = open(self.parameters.problem_name+"_graph_VOL.grf",'w')
+
+        print ('Initial Height of the Model: ' + str(self.height)+'\n')
+
+        #if(self.parameters.PredefinedSkinOption == "ON" ):
+        #  print ("ERROR: in Concrete Test Option the Skin is automatically predefined. Switch the Predefined Skin Option OFF")
+
+        (xtop_area,xbot_area,xlat_area,xtopcorner_area,xbotcorner_area,y_top_total,weight_top, y_bot_total, weight_bot) = self.CylinderSkinDetermination()
+
+        xtop_area_gath        = mpi.allgather_double(mpi.world, xtop_area)
+        xbot_area_gath        = mpi.allgather_double(mpi.world, xbot_area)
+        xlat_area_gath        = mpi.allgather_double(mpi.world, xlat_area)
+        xtopcorner_area_gath  = mpi.allgather_double(mpi.world, xtopcorner_area)
+        xbotcorner_area_gath  = mpi.allgather_double(mpi.world, xbotcorner_area)
+
+        xtop_area = reduce(lambda x, y: x + y, xtop_area_gath)
+        xbot_area = reduce(lambda x, y: x + y, xbot_area_gath)
+        xlat_area = reduce(lambda x, y: x + y, xlat_area_gath)
+        xtopcorner_area = reduce(lambda x, y: x + y, xtopcorner_area_gath)
+        xbotcorner_area = reduce(lambda x, y: x + y, xbotcorner_area_gath)
+
+        weight_top_gath = mpi.allgather_double(mpi.world, weight_top)
+        weight_bot_gath = mpi.allgather_double(mpi.world, weight_bot)
+        y_top_total_gath = mpi.allgather_double(mpi.world, y_top_total)
+        y_bot_total_gath = mpi.allgather_double(mpi.world, y_bot_total)
+
+        weight_top = reduce(lambda x, y: x + y, weight_top_gath)
+        weight_bot = reduce(lambda x, y: x + y, weight_bot_gath)
+        y_top_total = reduce(lambda x, y: x + y, y_top_total_gath)
+        y_bot_total = reduce(lambda x, y: x + y, y_bot_total_gath)
+
+        initial_height_top = y_top_total/weight_top
+        initial_height_bot = y_bot_total/weight_bot
+
+        inner_initial_height = initial_height_top - initial_height_bot
+
+        specimen_length = self.parameters.SpecimenLength
+        extended_length = specimen_length + (specimen_length - inner_initial_height)
+
+        self.length_correction_factor = specimen_length/extended_length
+
+  def PrepareDataForGraph(self):
+
+    prepare_check = [0,0,0,0]
+    prepare_check_gath = [0,0,0,0]
+    self.total_check = 0
+
+    for smp in self.rigid_face_model_part.SubModelParts:
+        if smp[TOP]:
+            self.top_mesh_nodes = smp.Nodes
+            prepare_check[0] = 1
+        if smp[BOTTOM]:
+            self.bot_mesh_nodes = smp.Nodes
+            prepare_check[1] = 1
+
+    for smp in self.spheres_model_part.SubModelParts:
+        if smp[TOP]:
+            self.top_mesh_nodes = smp.Nodes
+            prepare_check[2] = -1
+
+        if smp[BOTTOM]:
+            self.bot_mesh_nodes = smp.Nodes
+            prepare_check[3] = -1
+
+    prepare_check_gath[0] = mpi.gather_int(mpi.world,prepare_check[0],0)
+    prepare_check_gath[1] = mpi.gather_int(mpi.world,prepare_check[1],0)
+    prepare_check_gath[2] = mpi.gather_int(mpi.world,prepare_check[2],0)
+    prepare_check_gath[3] = mpi.gather_int(mpi.world,prepare_check[3],0)
+
+    if(mpi.rank == 0 ):
+      prepare_check[0] = reduce(lambda x,y: max(x,y), prepare_check_gath[0])
+      prepare_check[1] = reduce(lambda x,y: max(x,y), prepare_check_gath[1])
+      prepare_check[2] = reduce(lambda x,y: min(x,y), prepare_check_gath[2])
+      prepare_check[3] = reduce(lambda x,y: min(x,y), prepare_check_gath[3])
+
+      for it in range(len(prepare_check)):
+
+        self.total_check += prepare_check[it]
+
+      if(math.fabs(self.total_check)!=2):
+
+        Logger.PrintWarning(" ERROR in the definition of TOP BOT groups. Both groups are required to be defined, they have to be either on FEM groups or in DEM groups")
+
+  def MeasureForcesAndPressure(self):
+
+    dt = self.spheres_model_part.ProcessInfo.GetValue(DELTA_TIME)
+
+    #if(mpi.rank == 0 ):
+    self.strain += -100.0*self.length_correction_factor*1.0*self.parameters.LoadingVelocityTop*dt/self.parameters.SpecimenLength
+
+    if( self.parameters.TestType =="BTS"):
+
+      total_force_bts = 0.0
+
+      for node in self.top_mesh_nodes:
+
+        force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+        total_force_bts += force_node_y
+
+      if(mpi.rank == 0 ):
+        total_force_bts_gather = mpi.gather_double(mpi.world, total_force_bts, 0)
+        total_force_bts = reduce(lambda x, y: x + y, total_force_bts_gather)
+
+        self.total_stress_bts = 2.0*total_force_bts/(3.14159*self.parameters.SpecimenLength*self.parameters.SpecimenDiameter*1e6)
+        self.strain_bts += -100.0*2*self.parameters.LoadingVelocityTop*dt/self.parameters.SpecimenDiameter
+
+    else:
+
+      if( self.parameters.TestType =="Hydrostatic"):
+
+        radial_strain = -100*self.MeasureRadialStrain()
+        if(mpi.rank == 0):
+          self.volumetric_strain = self.strain + 2.0*radial_strain
+
+      total_force_top = 0.0
+      total_force_bot = 0.0
+
+      for node in self.top_mesh_nodes:
+
+        force_node_y = node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+
+        total_force_top += force_node_y
+
+      total_force_top_gath = mpi.allgather_double(mpi.world, total_force_top)
+      total_force_top = reduce(lambda x, y: x + y, total_force_top_gath)
+
+      self.total_stress_top = total_force_top/(self.MeasuringSurface * 1000000)
+
+      for node in self.bot_mesh_nodes:
+
+        force_node_y = -node.GetSolutionStepValue(ELASTIC_FORCES)[1]
+
+        total_force_bot += force_node_y
+
+      total_force_bot_gath = mpi.allgather_double(mpi.world, total_force_bot)
+      total_force_bot = reduce(lambda x, y: x + y, total_force_bot_gath)
+
+      self.total_stress_bot = total_force_bot/(self.MeasuringSurface * 1000000)
+      self.total_stress_mean = 0.5*(self.total_stress_bot + self.total_stress_top)
+
+      if( ( (self.parameters.TestType == "Triaxial") or (self.parameters.TestType == "Hydrostatic") ) and (self.parameters.ConfinementPressure != 0.0) ):
+
+          self.Pressure = min(self.total_stress_mean*1e6, self.parameters.ConfinementPressure * 1e6)
+
+          if( self.parameters.TestType == "Hydrostatic"):
+
+              self.Pressure = self.total_stress_mean*1e6
+
+          self.ApplyLateralPressure(self.Pressure, self.XLAT, self.XBOT, self.XTOP, self.XBOTCORNER, self.XTOPCORNER,self.alpha_top,self.alpha_bot,self.alpha_lat)
+
+  def PrintGraph(self,step):
+      if(mpi.rank == 0 ):
+          super().PrintGraph(step)
+
+  def PrintChart(self):
+      if(mpi.rank == 0 ):
+          super().PrintChart()
+
+  def FinalizeGraphs(self):
+      if(mpi.rank == 0):
+          super().FinalizeGraphs()
+
+  def MeasureRadialStrain(self):
+
+    mean_radial_strain = 0.0
+    radial_strain = 0.0
+    weight = 0.0
+
+    for node in self.XLAT:
+
+      r = node.GetSolutionStepValue(RADIUS)
+      x = node.X
+      z = node.Z
+
+      x0 = node.X0
+      z0 = node.Z0
+
+      dist_initial = math.sqrt(x0 * x0 + z0 * z0)
+      dist_now = math.sqrt(x * x + z * z)
+
+      node_radial_strain = (dist_now - dist_initial) / dist_initial
+
+      mean_radial_strain += node_radial_strain*r*r
+
+      weight += r*r
+
+    mean_radial_strain_gath = mpi.allgather_double(mpi.world,mean_radial_strain)
+    weight_gath = mpi.allgather_double(mpi.world,weight)
+
+    mean_radial_strain = reduce(lambda x, y: x + y, mean_radial_strain_gath)
+    weight = reduce(lambda x, y: x + y, weight_gath)
+
+    if(mpi.rank == 0 ):
+      if(weight == 0.0):
+        print ("Error in MeasureRadialStrain. Lateral skin particles not well defined")
+
+    radial_strain = mean_radial_strain/weight
+
+    return radial_strain
```

## KratosMultiphysics/DEMApplication/KratosDEM.py

 * *Ordering differences only*

```diff
@@ -1,10 +1,10 @@
-import KratosMultiphysics
-from KratosMultiphysics import Logger
-Logger.GetDefaultOutput().SetSeverity(Logger.Severity.INFO)
-import KratosMultiphysics.DEMApplication
-
-import KratosMultiphysics.DEMApplication.main_script as Main
-
-model = KratosMultiphysics.Model()
-solution = Main.Solution(model)
-solution.Run()
+import KratosMultiphysics
+from KratosMultiphysics import Logger
+Logger.GetDefaultOutput().SetSeverity(Logger.Severity.INFO)
+import KratosMultiphysics.DEMApplication
+
+import KratosMultiphysics.DEMApplication.main_script as Main
+
+model = KratosMultiphysics.Model()
+solution = Main.Solution(model)
+solution.Run()
```

## KratosMultiphysics/DEMApplication/DEM_save_restart_process.py

 * *Ordering differences only*

```diff
@@ -1,45 +1,45 @@
-# Importing the Kratos Library
-import KratosMultiphysics as Kratos
-from KratosMultiphysics.save_restart_process import SaveRestartProcess
-from KratosMultiphysics.DEMApplication import DEM_restart_utility
-import json
-
-def Factory(settings, Model):
-    if not isinstance(settings, Kratos.Parameters):
-        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
-    return DEMSaveRestartProcess(Model, settings["Parameters"])
-
-class DEMSaveRestartProcess(SaveRestartProcess):
-    """This process compares saves restart files
-    It works both in OpenMP and MPI
-    see the "default_settings" for available options
-    """
-    def __init__(self, model, params):
-        Kratos.Process.__init__(self)
-        ## Settings string in json format
-        default_settings = Kratos.Parameters("""{
-            "help"                         : "This process is used in order to save the problem databse with the serializer the current problem",
-            "model_part_names"              : ["SPECIFY_MODEL_PART_NAMES"],
-            "echo_level"                   : 0,
-            "serializer_trace"             : "no_trace",
-            "restart_save_frequency"       : 0.0,
-            "restart_control_type"         : "time",
-            "save_restart_files_in_folder" : true,
-            "remove_restart_folder_after_reading" : false
-        }""")
-
-        ## Overwrite the default settings with user-provided parameters
-        params.ValidateAndAssignDefaults(default_settings)
-        self.remove_files = params["remove_restart_folder_after_reading"].GetBool()
-        params.RemoveValue("help")
-        params.RemoveValue("remove_restart_folder_after_reading")
-        params_dict = json.loads(params.PrettyPrintJsonString())
-        params_dict["input_filenames"] = [mp.GetString() for mp in params["model_part_names"].values()]
-        params = Kratos.Parameters(json.dumps(params_dict))
-
-        params.RemoveValue("model_part_names")
-
-        self.restart_utility = DEM_restart_utility.DEMRestartUtility(model, params)
-
-        # already create the folder now to avoid problems on slow file-systems
-        self.restart_utility.CreateOutputFolder()
+# Importing the Kratos Library
+import KratosMultiphysics as Kratos
+from KratosMultiphysics.save_restart_process import SaveRestartProcess
+from KratosMultiphysics.DEMApplication import DEM_restart_utility
+import json
+
+def Factory(settings, Model):
+    if not isinstance(settings, Kratos.Parameters):
+        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
+    return DEMSaveRestartProcess(Model, settings["Parameters"])
+
+class DEMSaveRestartProcess(SaveRestartProcess):
+    """This process compares saves restart files
+    It works both in OpenMP and MPI
+    see the "default_settings" for available options
+    """
+    def __init__(self, model, params):
+        Kratos.Process.__init__(self)
+        ## Settings string in json format
+        default_settings = Kratos.Parameters("""{
+            "help"                         : "This process is used in order to save the problem databse with the serializer the current problem",
+            "model_part_names"              : ["SPECIFY_MODEL_PART_NAMES"],
+            "echo_level"                   : 0,
+            "serializer_trace"             : "no_trace",
+            "restart_save_frequency"       : 0.0,
+            "restart_control_type"         : "time",
+            "save_restart_files_in_folder" : true,
+            "remove_restart_folder_after_reading" : false
+        }""")
+
+        ## Overwrite the default settings with user-provided parameters
+        params.ValidateAndAssignDefaults(default_settings)
+        self.remove_files = params["remove_restart_folder_after_reading"].GetBool()
+        params.RemoveValue("help")
+        params.RemoveValue("remove_restart_folder_after_reading")
+        params_dict = json.loads(params.PrettyPrintJsonString())
+        params_dict["input_filenames"] = [mp.GetString() for mp in params["model_part_names"].values()]
+        params = Kratos.Parameters(json.dumps(params_dict))
+
+        params.RemoveValue("model_part_names")
+
+        self.restart_utility = DEM_restart_utility.DEMRestartUtility(model, params)
+
+        # already create the folder now to avoid problems on slow file-systems
+        self.restart_utility.CreateOutputFolder()
```

## KratosMultiphysics/DEMApplication/sphere_strategy.py

 * *Ordering differences only*

```diff
@@ -1,801 +1,801 @@
-import sys
-from KratosMultiphysics import *
-from KratosMultiphysics.DEMApplication import *
-import math
-import time
-import KratosMultiphysics.DEMApplication.cluster_file_reader as cluster_file_reader
-
-class ExplicitStrategy():
-
-    #def __init__(self, all_model_parts, creator_destructor, dem_fem_search, scheme, DEM_parameters, procedures):
-    def __init__(self, all_model_parts, creator_destructor, dem_fem_search, DEM_parameters, procedures):
-        self.solver_settings = DEM_parameters["solver_settings"]
-
-        default_settings = Parameters("""
-        {
-            "strategy" : "sphere_strategy",
-            "do_search_dem_neighbours" : true,
-            "do_search_fem_neighbours" : true,
-            "RemoveBallsInitiallyTouchingWalls": false,
-            "model_import_settings": {
-                "input_type": "mdpa",
-                "input_filename": "unknown_name"
-            },
-            "material_import_settings"           : {
-                "materials_filename" : "MaterialsDEM.json"
-            }
-        }""")
-
-        if self.solver_settings.Has("do_search_neighbours"):
-            Logger.PrintWarning("DEM", '\nWARNING!:  do_search_neighbours flag is deprecated. Please use do_search_dem_neighbours instead.\n')
-            self.solver_settings.AddValue("do_search_dem_neighbours", self.solver_settings["do_search_neighbours"])
-            self.solver_settings.RemoveValue("do_search_neighbours")
-
-        self.solver_settings.ValidateAndAssignDefaults(default_settings)
-
-        # Initialization of member variables
-        self.all_model_parts = all_model_parts
-        self.spheres_model_part = all_model_parts.Get("SpheresPart")
-        self.inlet_model_part = all_model_parts.Get("DEMInletPart")
-        self.fem_model_part = all_model_parts.Get("RigidFacePart")
-        self.cluster_model_part = all_model_parts.Get("ClusterPart")
-        self.contact_model_part = all_model_parts.Get("ContactPart")
-
-        self.DEM_parameters = DEM_parameters
-        self.dem_fem_utils = DEMFEMUtilities()
-
-        self.dimension = DEM_parameters["Dimension"].GetInt()
-
-        if not "ComputeStressTensorOption" in DEM_parameters.keys():
-            self.compute_stress_tensor_option = 0
-        else:
-            self.compute_stress_tensor_option = DEM_parameters["ComputeStressTensorOption"].GetBool()
-
-        if "PostStressStrainOption" in DEM_parameters.keys() and DEM_parameters["PostStressStrainOption"].GetBool():
-            self.compute_stress_tensor_option = 1
-            self.print_stress_tensor_option = 1
-        else:
-            self.print_stress_tensor_option = 0
-
-        self.trihedron_option        = DEM_parameters["PostEulerAngles"].GetBool()
-        self.rotation_option         = DEM_parameters["RotationOption"].GetBool()
-        self.bounding_box_option     = DEM_parameters["BoundingBoxOption"].GetBool()
-        self.fix_velocities_flag     = 0
-        self.Procedures              = procedures
-        #self.time_integration_scheme = scheme
-        #self.time_integration_scheme.SetRotationOption(self.rotation_option)
-
-        self.clean_init_indentation_option = DEM_parameters["CleanIndentationsOption"].GetBool()
-
-        if self.clean_init_indentation_option and self._GetInputType() == 'rest':
-            Logger.PrintWarning("DEM", '\nWARNING!: \'clean_indentations_option\' is set to true in a restarted simulation. The particles\' radii could be modified before the first time step.\n' * 50)
-
-        self.contact_mesh_option           = 0
-        if "ContactMeshOption" in DEM_parameters.keys():
-            self.contact_mesh_option      = DEM_parameters["ContactMeshOption"].GetBool()
-        self.automatic_bounding_box_option = DEM_parameters["AutomaticBoundingBoxOption"].GetBool()
-
-        self.delta_option = DEM_parameters["DeltaOption"].GetString() #TODO: this is not an option (bool) let's change the name to something including 'type'
-
-        self.search_increment = 0.0
-        self.search_increment_for_walls = 0.0
-        self.search_increment_for_bonds_creation = 0.0
-        self.coordination_number = 10.0
-
-        if self._GetInputType() == 'rest':
-            self.search_control = 2
-
-        else:
-            self.search_control = 1
-
-        if "LocalResolutionMethod" in DEM_parameters.keys():
-            if (DEM_parameters["LocalResolutionMethod"].GetString() == "hierarchical"):
-                self.local_resolution_method = 1
-            elif (DEM_parameters["LocalResolutionMethod"].GetString() == "area_distribution"):
-                self.local_resolution_method = 2
-            else:
-                self.local_resolution_method = 1
-        else:
-            self.local_resolution_method = 1
-
-        if DEM_parameters["DeltaOption"].GetString() == "None":
-            self.delta_option = 0
-
-        elif DEM_parameters["DeltaOption"].GetString() == "Absolute":
-            self.delta_option = 1
-            self.search_increment = DEM_parameters["SearchTolerance"].GetDouble()
-            if not "SearchToleranceForBondsCreation" in DEM_parameters.keys():
-                self.search_increment_for_bonds_creation  = self.search_increment
-            else:
-                self.search_increment_for_bonds_creation = DEM_parameters["SearchToleranceForBondsCreation"].GetDouble()
-
-        elif DEM_parameters["DeltaOption"].GetString() == "Coordination_Number":
-            self.delta_option = 2
-            self.coordination_number = DEM_parameters["CoordinationNumber"].GetDouble()
-            self.search_increment = 0.01 * 0.0001 #DEM_parameters-MeanRadius
-
-        self.search_increment_for_walls = DEM_parameters["search_tolerance_against_walls"].GetDouble()
-
-        # TIME RELATED PARAMETERS
-        self.dt = DEM_parameters["MaxTimeStep"].GetDouble()
-        self.max_delta_time = DEM_parameters["MaxTimeStep"].GetDouble()
-        self.end_time = DEM_parameters["FinalTime"].GetDouble()
-
-        # BOUNDING_BOX
-        self.enlargement_factor = DEM_parameters["BoundingBoxEnlargementFactor"].GetDouble()
-        self.top_corner = Array3()
-        self.bottom_corner = Array3()
-        self.bottom_corner[0] = DEM_parameters["BoundingBoxMinX"].GetDouble()
-        self.bottom_corner[1] = DEM_parameters["BoundingBoxMinY"].GetDouble()
-        self.bottom_corner[2] = DEM_parameters["BoundingBoxMinZ"].GetDouble()
-        self.top_corner[0] = DEM_parameters["BoundingBoxMaxX"].GetDouble()
-        self.top_corner[1] = DEM_parameters["BoundingBoxMaxY"].GetDouble()
-        self.top_corner[2] = DEM_parameters["BoundingBoxMaxZ"].GetDouble()
-
-        if not "BoundingBoxStartTime" in DEM_parameters.keys():
-            self.bounding_box_start_time  = 0.0
-        else:
-            self.bounding_box_start_time  = DEM_parameters["BoundingBoxStartTime"].GetDouble()
-
-        if not "BoundingBoxStopTime" in DEM_parameters.keys():
-            self.bounding_box_stop_time  = self.end_time
-        else:
-            self.bounding_box_stop_time  = DEM_parameters["BoundingBoxStopTime"].GetDouble()
-
-        # GLOBAL PHYSICAL ASPECTS
-        self.gravity = Vector(3)
-        self.gravity[0] = DEM_parameters["GravityX"].GetDouble()
-        self.gravity[1] = DEM_parameters["GravityY"].GetDouble()
-        self.gravity[2] = DEM_parameters["GravityZ"].GetDouble()
-
-        self.virtual_mass_option = 0
-        self.nodal_mass_coeff = DEM_parameters["VirtualMassCoefficient"].GetDouble()
-
-        if (self.nodal_mass_coeff != 1.0):
-            self.virtual_mass_option = 1
-
-        self.rolling_friction_option = DEM_parameters["RollingFrictionOption"].GetBool()
-
-        if not "GlobalDamping" in DEM_parameters.keys():
-            self.global_damping = 0.0
-            Logger.PrintWarning("DEM", "\nGlobal Damping parameter not found! No damping will be applied...\n")
-        else:
-            self.global_damping = DEM_parameters["GlobalDamping"].GetDouble()
-
-        if not "GlobalViscousDamping" in DEM_parameters.keys():
-            self.global_viscous_damping = 0.0
-            Logger.PrintWarning("DEM", "\nGlobal Viscous Damping parameter not found! No damping will be applied...\n")
-        else:
-            self.global_viscous_damping = DEM_parameters["GlobalViscousDamping"].GetDouble()
-
-        # PRINTING VARIABLES
-        self.print_export_id = DEM_parameters["PostExportId"].GetBool()
-        self.print_export_skin_sphere = 0
-        self.poisson_ratio_option = 0
-
-        # RESOLUTION METHODS AND PARAMETERS
-        self.n_step_search = DEM_parameters["NeighbourSearchFrequency"].GetInt() #TODO: NeighbourSearchFrequency change name to something that includes number of steps
-        self.safety_factor = DEM_parameters["DeltaTimeSafetyFactor"].GetDouble()  # For critical time step @53214
-
-        # CREATOR-DESTRUCTOR
-        self.creator_destructor = creator_destructor
-        self.dem_fem_search = dem_fem_search
-
-        # STRATEGIES
-        self.search_strategy = OMP_DEMSearch()
-        if "PeriodicDomainOption" in DEM_parameters.keys():
-            if DEM_parameters["PeriodicDomainOption"].GetBool():
-                self.search_strategy = OMP_DEMSearch(DEM_parameters["BoundingBoxMinX"].GetDouble(),
-                                                     DEM_parameters["BoundingBoxMinY"].GetDouble(),
-                                                     DEM_parameters["BoundingBoxMinZ"].GetDouble(),
-                                                     DEM_parameters["BoundingBoxMaxX"].GetDouble(),
-                                                     DEM_parameters["BoundingBoxMaxY"].GetDouble(),
-                                                     DEM_parameters["BoundingBoxMaxZ"].GetDouble())
-
-
-        self.SetContinuumType()
-
-    def _GetRestartSettings(self, model_part_import_settings):
-        restart_settings = model_part_import_settings.Clone()
-        restart_settings.RemoveValue("input_type")
-        if not restart_settings.Has("restart_load_file_label"):
-            raise Exception('"restart_load_file_label" must be specified when starting from a restart-file!')
-        if model_part_import_settings.Has("echo_level"):
-            restart_settings.AddValue("echo_level", model_part_import_settings["echo_level"])
-
-        return restart_settings
-
-    def SetContinuumType(self):
-        self.continuum_type = False
-
-    def Var_Translator(self, variable):
-
-        if (variable == "OFF" or variable == "0" or variable == 0 or variable == "No"):
-            variable = 0
-        else:
-            variable = 1
-
-        return variable
-
-    def SetOneOrZeroInProcessInfoAccordingToBoolValue(self, model_part, variable, bool_value): #TODO: to be removed, because the Kratos variables should be bools already
-        if bool_value:
-            model_part.ProcessInfo.SetValue(variable, 1)
-        else:
-            model_part.ProcessInfo.SetValue(variable, 0)
-
-    def SetVariablesAndOptions(self):
-
-        # Setting ProcessInfo variables
-        for name in self.all_model_parts.model_parts.keys():
-            self.all_model_parts.Get(name).ProcessInfo.SetValue(IS_RESTARTED, self._GetInputType() == 'rest')
-
-        # DIMENSION PARAMETERS
-        self.spheres_model_part.ProcessInfo.SetValue(DOMAIN_SIZE, self.dimension)
-
-        # SIMULATION FLAGS
-        self.spheres_model_part.ProcessInfo.SetValue(IS_TIME_TO_PRINT, False)
-        self.spheres_model_part.ProcessInfo.SetValue(VIRTUAL_MASS_OPTION, self.virtual_mass_option)
-        self.spheres_model_part.ProcessInfo.SetValue(TRIHEDRON_OPTION, self.trihedron_option)
-        self.SetOneOrZeroInProcessInfoAccordingToBoolValue(self.spheres_model_part, ROTATION_OPTION, self.rotation_option)
-        self.SetOneOrZeroInProcessInfoAccordingToBoolValue(self.spheres_model_part, BOUNDING_BOX_OPTION, self.bounding_box_option)
-        self.spheres_model_part.ProcessInfo.SetValue(SEARCH_CONTROL, self.search_control)
-        self.spheres_model_part.ProcessInfo.SetValue(FIX_VELOCITIES_FLAG, self.fix_velocities_flag)
-        self.spheres_model_part.ProcessInfo.SetValue(NEIGH_INITIALIZED, 0)
-        self.spheres_model_part.ProcessInfo.SetValue(CLEAN_INDENT_OPTION, self.clean_init_indentation_option)
-        self.spheres_model_part.ProcessInfo.SetValue(BOUNDING_BOX_START_TIME, self.bounding_box_start_time)
-        self.spheres_model_part.ProcessInfo.SetValue(BOUNDING_BOX_STOP_TIME, self.bounding_box_stop_time)
-        self.spheres_model_part.ProcessInfo.SetValue(COMPUTE_STRESS_TENSOR_OPTION, self.compute_stress_tensor_option)
-        self.spheres_model_part.ProcessInfo.SetValue(PRINT_STRESS_TENSOR_OPTION, self.print_stress_tensor_option)
-        self.spheres_model_part.ProcessInfo.SetValue(CONTINUUM_OPTION, self.continuum_type)
-        self.spheres_model_part.ProcessInfo.SetValue(IMPOSED_Z_STRAIN_VALUE, 0.0) # A default value
-
-        self.spheres_model_part.ProcessInfo.SetValue(DOMAIN_IS_PERIODIC, 0) #TODO: DOMAIN_IS_PERIODIC should be a bool, and should have the suffix option
-        if "PeriodicDomainOption" in self.DEM_parameters.keys():
-            if self.DEM_parameters["PeriodicDomainOption"].GetBool():
-                self.spheres_model_part.ProcessInfo.SetValue(DOMAIN_IS_PERIODIC, 1) #TODO: DOMAIN_IS_PERIODIC should be a bool, and should have the suffix option
-
-        self.spheres_model_part.ProcessInfo.SetValue(DOMAIN_MIN_CORNER, self.bottom_corner)
-        self.spheres_model_part.ProcessInfo.SetValue(DOMAIN_MAX_CORNER, self.top_corner)
-        self.spheres_model_part.ProcessInfo.SetValue(GRAVITY, self.gravity)
-
-        # GLOBAL MATERIAL PROPERTIES
-        self.spheres_model_part.ProcessInfo.SetValue(NODAL_MASS_COEFF, self.nodal_mass_coeff)
-        self.SetOneOrZeroInProcessInfoAccordingToBoolValue(self.spheres_model_part, ROLLING_FRICTION_OPTION, self.rolling_friction_option)
-        self.spheres_model_part.ProcessInfo.SetValue(GLOBAL_DAMPING, self.global_damping)
-        self.spheres_model_part.ProcessInfo.SetValue(GLOBAL_VISCOUS_DAMPING, self.global_viscous_damping)
-
-        # SEARCH-RELATED
-        self.spheres_model_part.ProcessInfo.SetValue(SEARCH_RADIUS_INCREMENT, self.search_increment)
-        self.spheres_model_part.ProcessInfo.SetValue(SEARCH_RADIUS_INCREMENT_FOR_WALLS, self.search_increment_for_walls)
-        self.spheres_model_part.ProcessInfo.SetValue(SEARCH_RADIUS_INCREMENT_FOR_BONDS_CREATION, self.search_increment_for_bonds_creation)
-        self.spheres_model_part.ProcessInfo.SetValue(COORDINATION_NUMBER, self.coordination_number)
-        self.spheres_model_part.ProcessInfo.SetValue(LOCAL_RESOLUTION_METHOD, self.local_resolution_method)
-        if self.contact_mesh_option:
-            self.spheres_model_part.ProcessInfo.SetValue(CONTACT_MESH_OPTION, 1)
-        else:
-            self.spheres_model_part.ProcessInfo.SetValue(CONTACT_MESH_OPTION, 0)
-
-        # PRINTING VARIABLES
-
-        self.spheres_model_part.ProcessInfo.SetValue(PRINT_EXPORT_ID, self.print_export_id)
-
-        # TIME RELATED PARAMETERS
-        self.spheres_model_part.ProcessInfo.SetValue(DELTA_TIME, self.dt)
-
-        #-----os.chdir('..')   # check functionality
-
-        for properties in self.spheres_model_part.Properties:
-            self.ModifyProperties(properties)
-            for subproperties in properties.GetSubProperties():
-                self.ModifySubProperties(subproperties, properties.Id)
-
-        for submp in self.inlet_model_part.SubModelParts:
-            if submp.Has(CLUSTER_FILE_NAME):
-                cluster_file_name = submp[CLUSTER_FILE_NAME]
-                [name, list_of_coordinates, list_of_radii, size, volume, inertias] = cluster_file_reader.ReadClusterFile(cluster_file_name)
-                pre_utils = PreUtilities(self.spheres_model_part)
-                if not submp.Has(PROPERTIES_ID):
-                    raise Exception("This ModelPart: " + submp.Name + " should contain PROPERTIES_ID. Make sure it was added in the assignation table of the Materials json file.")
-                props_id = submp[PROPERTIES_ID]
-                for prop in self.inlet_model_part.Properties:
-                    if prop.Id == props_id:
-                        properties = prop
-                        break
-                pre_utils.SetClusterInformationInProperties(name, list_of_coordinates, list_of_radii, size, volume, inertias, properties)
-                if not properties.Has(BREAKABLE_CLUSTER):
-                    properties.SetValue(BREAKABLE_CLUSTER, False)
-
-        # RESOLUTION METHODS AND PARAMETERS
-        # Creating the solution strategy
-        self.settings = ExplicitSolverSettings()
-        self.settings.r_model_part = self.spheres_model_part
-        self.settings.contact_model_part = self.contact_model_part
-        self.settings.fem_model_part = self.fem_model_part
-        self.settings.inlet_model_part = self.inlet_model_part
-        self.settings.cluster_model_part = self.cluster_model_part  
-    
-    def CheckMomentumConservation(self):
-
-        previous_discontinuum_constitutive_law_string = ""
-        current_discontinuum_constitutive_law_string = ""
-        output_message = "\n*********************************************************************************************\n"+\
-                           "*********************************************************************************************\n"+\
-                           "WARNING:                                                                                     \n"+\
-                           "A mix of constitutive laws is being used. The momentum conservation law will not be fulfilled\n"+\
-                           "in the interaction of particles of different constitutive laws. Please, cancel the simulation\n"+\
-                           "if that fact represents a problem. Otherwise, computations will resume in a few seconds.     \n"+\
-                           "*********************************************************************************************\n"+\
-                           "*********************************************************************************************\n"
-        delay = 1  # Inserting the desired delay in seconds
-        counter = 0
-        for properties in self.spheres_model_part.Properties:
-            current_discontinuum_constitutive_law_string = properties[DEM_DISCONTINUUM_CONSTITUTIVE_LAW_NAME]
-            if ((counter > 0) and (previous_discontinuum_constitutive_law_string != current_discontinuum_constitutive_law_string)):
-                self.Procedures.KratosPrintInfo(output_message)
-                time.sleep(delay) # Inserting a delay so the user has ample time to read the message
-                break
-            previous_discontinuum_constitutive_law_string = current_discontinuum_constitutive_law_string
-            counter += 1
-
-
-    def CreateCPlusPlusStrategy(self):
-
-        self.SetVariablesAndOptions()
-
-        if (self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Velocity_Verlet'):
-            self.cplusplus_strategy = IterativeSolverStrategy(self.settings, self.max_delta_time, self.n_step_search, self.safety_factor,
-                                                              self.delta_option, self.creator_destructor, self.dem_fem_search,
-                                                              self.search_strategy, self.solver_settings)
-        else:
-            self.cplusplus_strategy = ExplicitSolverStrategy(self.settings, self.max_delta_time, self.n_step_search, self.safety_factor,
-                                                             self.delta_option, self.creator_destructor, self.dem_fem_search,
-                                                             self.search_strategy, self.solver_settings)
-            
-    def UpdateCPlusPlusStrategy(self):
-
-        if (self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Velocity_Verlet'):
-            self.cplusplus_strategy = IterativeSolverStrategy(self.settings, self.max_delta_time, self.n_step_search, self.safety_factor,
-                                                              self.delta_option, self.creator_destructor, self.dem_fem_search,
-                                                              self.search_strategy, self.solver_settings)
-        else:
-            self.cplusplus_strategy = ExplicitSolverStrategy(self.settings, self.max_delta_time, self.n_step_search, self.safety_factor,
-                                                             self.delta_option, self.creator_destructor, self.dem_fem_search,
-                                                             self.search_strategy, self.solver_settings)
-
-    def _GetInputType(self):
-        return self.solver_settings["model_import_settings"]["input_type"].GetString()
-
-    def AddVariables(self):
-        pass
-
-    def BeforeInitialize(self):
-        self.CreateCPlusPlusStrategy()
-        self.RebuildListOfDiscontinuumSphericParticles()
-        self.SetNormalRadiiOnAllParticles()
-        self.SetSearchRadiiOnAllParticles()
-
-    def Initialize(self):
-        self.CheckMomentumConservation()
-        self.cplusplus_strategy.Initialize()  # Calls the cplusplus_strategy (C++) Initialize function (initializes all elements and performs other necessary tasks before starting the time loop in Python)
-
-    def SetDt(self, dt):
-        self.dt = dt
-
-    def Predict(self):
-        time = self.spheres_model_part.ProcessInfo[TIME]
-        self._MoveAllMeshes(time, self.dt)
-
-    def Check(self):
-        pass
-
-    def Solve(self): # deprecated
-        self.SolveSolutionStep()
-
-    def SolveSolutionStep(self):
-        self.cplusplus_strategy.SolveSolutionStep()
-        return True
-
-    def AdvanceInTime(self, time):
-        """This function updates and return the current simulation time
-        """
-        time += self.dt
-        self._UpdateTimeInModelParts(time)
-
-        return time
-
-    def _MoveAllMeshes(self, time, dt):
-        spheres_model_part = self.all_model_parts.Get("SpheresPart")
-        dem_inlet_model_part = self.all_model_parts.Get("DEMInletPart")
-        rigid_face_model_part = self.all_model_parts.Get("RigidFacePart")
-
-        self.dem_fem_utils.MoveAllMeshes(spheres_model_part, time, dt)
-        self.dem_fem_utils.MoveAllMeshes(dem_inlet_model_part, time, dt)
-        self.dem_fem_utils.MoveAllMeshes(rigid_face_model_part, time, dt)
-
-    def _UpdateTimeInModelParts(self, time, is_time_to_print = False):
-        spheres_model_part = self.all_model_parts.Get("SpheresPart")
-        cluster_model_part = self.all_model_parts.Get("ClusterPart")
-        dem_inlet_model_part = self.all_model_parts.Get("DEMInletPart")
-        rigid_face_model_part = self.all_model_parts.Get("RigidFacePart")
-
-        self._UpdateTimeInOneModelPart(spheres_model_part, time, self.dt, is_time_to_print)
-        self._UpdateTimeInOneModelPart(cluster_model_part, time, self.dt, is_time_to_print)
-        self._UpdateTimeInOneModelPart(dem_inlet_model_part, time, self.dt, is_time_to_print)
-        self._UpdateTimeInOneModelPart(rigid_face_model_part, time, self.dt, is_time_to_print)
-
-    @classmethod
-    def _UpdateTimeInOneModelPart(self, model_part, time, dt, is_time_to_print = False):
-        ''' This method is redirected to its cpp version with improved speed.
-        It also has been updated to classmethod and args so it can be called from external App
-        '''
-
-        AuxiliaryUtilities().UpdateTimeInOneModelPart(model_part, time, dt, is_time_to_print)
-
-
-    def FinalizeSolutionStep(self):
-        self.cplusplus_strategy.FinalizeSolutionStep()
-
-    def Finalize(self):
-        pass
-
-    def InitializeSolutionStep(self):
-        time = self.spheres_model_part.ProcessInfo[TIME]
-        self.FixDOFsManually(time)
-        self.cplusplus_strategy.ResetPrescribedMotionFlagsRespectingImposedDofs()
-        self.FixExternalForcesManually(time)
-
-        self.cplusplus_strategy.InitializeSolutionStep()
-
-    def SetNormalRadiiOnAllParticles(self):
-        self.cplusplus_strategy.SetNormalRadiiOnAllParticles(self.spheres_model_part)
-
-    def SetSearchRadiiOnAllParticles(self):
-
-        self.cplusplus_strategy.SetSearchRadiiOnAllParticles(self.spheres_model_part, self.search_increment, 1.0)
-
-    def RebuildListOfDiscontinuumSphericParticles(self):
-        self.cplusplus_strategy.RebuildListOfDiscontinuumSphericParticles()
-
-    def Compute_RigidFace_Movement(self):
-        self.cplusplus_strategy.Compute_RigidFace_Movement()
-
-
-    def FixDOFsManually(self, time):
-    #if time>1.0:
-        #for node in self.spheres_model_part.Nodes:
-            #node.Fix(VELOCITY_X)
-            #node.SetSolutionStepValue(VELOCITY_X, 0.0)
-        pass
-
-    def FixExternalForcesManually(self,time):
-        pass
-
-    def AddAdditionalVariables(self, balls_model_part, DEM_parameters):
-        pass
-
-    def AddClusterVariables(self, spheres_model_part, DEM_parameters):
-        pass
-
-    def AddDofs(self):
-        # this can safely be called also for restarts, it is internally checked if the dofs exist already
-        spheres_model_part = self.all_model_parts.Get("SpheresPart")
-        dem_inlet_model_part = self.all_model_parts.Get("DEMInletPart")
-        cluster_model_part = self.all_model_parts.Get("ClusterPart")
-
-        model_part_list = [spheres_model_part, cluster_model_part, dem_inlet_model_part]
-        variable_list = [VELOCITY_X, VELOCITY_Y, VELOCITY_Z, ANGULAR_VELOCITY_X, ANGULAR_VELOCITY_Y, ANGULAR_VELOCITY_Z]
-        for model_part in model_part_list:
-            for variable in variable_list:
-                VariableUtils().AddDof(variable, model_part)
-            self.Procedures.KratosPrintInfo("DOFs for the DEM solution added correctly")
-
-    def PrepareElementsForPrinting(self):
-        self.cplusplus_strategy.PrepareElementsForPrinting()
-
-    def PrepareContactElementsForPrinting(self):
-        self.cplusplus_strategy.PrepareContactElementsForPrinting()
-
-    def AttachSpheresToStickyWalls(self):
-        self.cplusplus_strategy.AttachSpheresToStickyWalls()
-
-    def coeff_of_rest_diff(self, gamma, desired_coefficient_of_restit):
-
-        if gamma <= 1.0/math.sqrt(2.0) :
-            return math.exp(-gamma/math.sqrt(1.0-gamma*gamma)*(math.pi-math.atan(2.0*gamma*math.sqrt(1.0-gamma*gamma)/(-2.0*gamma*gamma+1.0))))-desired_coefficient_of_restit
-        elif gamma < 1.0 :
-            return math.exp(-gamma/math.sqrt(1.0-gamma*gamma)*math.atan(2.0*gamma*math.sqrt(1.0-gamma*gamma)/(2.0*gamma*gamma-1.0)))-desired_coefficient_of_restit
-        elif gamma == 1.0 :
-            return 0.135335283 - desired_coefficient_of_restit
-        else:
-            return math.exp(-gamma/math.sqrt(gamma*gamma-1.0)*math.log((gamma/math.sqrt(gamma*gamma-1.0)+1.0)/(gamma/math.sqrt(gamma*gamma-1.0)-1.0)))-desired_coefficient_of_restit
-
-
-    def RootByBisection(self, f, a, b, tol, maxiter, coefficient_of_restitution):
-
-        if coefficient_of_restitution < 0.001 :
-            coefficient_of_restitution = 0.001
-
-        if coefficient_of_restitution > 0.999 :
-            return 0.0
-        k=0
-        gamma = 0.5 * (a + b)
-
-        while b - a > tol and k <= maxiter:
-            coefficient_of_restitution_trial = self.coeff_of_rest_diff(gamma, coefficient_of_restitution)
-
-            if self.coeff_of_rest_diff(a, coefficient_of_restitution) * coefficient_of_restitution_trial < 0:
-                b = gamma
-
-            elif coefficient_of_restitution_trial == 0:
-                return gamma
-
-            else:
-                a = gamma
-
-            gamma = 0.5 * (a + b)
-            k += 1
-
-        return gamma
-
-    def GammaForHertzThornton(self, e):
-        if e < 0.001:
-            e = 0.001
-
-        if e > 0.999:
-            return 0.0
-
-        h1  = -6.918798
-        h2  = -16.41105
-        h3  =  146.8049
-        h4  = -796.4559
-        h5  =  2928.711
-        h6  = -7206.864
-        h7  =  11494.29
-        h8  = -11342.18
-        h9  =  6276.757
-        h10 = -1489.915
-
-        alpha = e*(h1+e*(h2+e*(h3+e*(h4+e*(h5+e*(h6+e*(h7+e*(h8+e*(h9+e*h10)))))))))
-
-        return math.sqrt(1.0/(1.0 - (1.0+e)*(1.0+e) * math.exp(alpha)) - 1.0)
-
-    def GammaCritical(self, e):
-        # Traken from 'Determination of the normal spring stiffness coefficient
-        # in the linear springdashpot contact model of discrete element method'
-        # https://www.sciencedirect.com/science/article/pii/S0032591013004178
-        if e < 0.001:
-            e = 0.001
-
-        if e > 0.999:
-            return 0.0
-
-        aux = math.log(e)
-
-        return -aux / math.sqrt(math.pi ** 2 + aux ** 2)
-
-    def SinAlphaConicalDamage(self, e):
-
-        if e < 0.001:
-            sinAlpha = 0.001
-
-        else:
-            sinAlpha = math.sin(math.radians(e))
-
-        return (1-sinAlpha)/sinAlpha
-
-    def TranslationalIntegrationSchemeTranslator(self, name):
-        class_name = None
-
-        if name == 'Forward_Euler':
-            class_name = 'ForwardEulerScheme'
-        elif name == 'Symplectic_Euler':
-            class_name = 'SymplecticEulerScheme'
-        elif name == 'Taylor_Scheme':
-            class_name = 'TaylorScheme'
-        elif name == 'Velocity_Verlet':
-            class_name = 'VelocityVerletScheme'
-
-        return class_name
-
-    def RotationalIntegrationSchemeTranslator(self, name_translational, name_rotational):
-        class_name = None
-
-        if name_rotational == 'Direct_Integration' or name_rotational == 'same_as_translational':
-            class_name = self.TranslationalIntegrationSchemeTranslator(name_translational)
-        elif name_rotational == 'Forward_Euler':
-            class_name = 'ForwardEulerScheme'
-        elif name_rotational == 'Symplectic_Euler':
-            class_name = 'SymplecticEulerScheme'
-        elif name_rotational == 'Taylor_Scheme':
-            class_name = 'TaylorScheme'
-        elif name_rotational == 'Velocity_Verlet':
-            class_name = 'VelocityVerletScheme'
-        elif name_rotational == 'Runge_Kutta':
-            class_name = 'RungeKuttaScheme'
-        elif name_rotational == 'Quaternion_Integration':
-            class_name = 'QuaternionIntegrationScheme'
-
-        return class_name
-
-    def GetTranslationalSchemeInstance(self, class_name):
-        return eval(class_name)()
-
-    def GetRotationalSchemeInstance(self, class_name):
-        return eval(class_name)()
-
-    def GetTranslationalScheme(self, name):
-        class_name = self.TranslationalIntegrationSchemeTranslator(name)
-        translational_scheme = None
-        error_status = 0
-        summary = ''
-
-        if not class_name == None:
-            try:
-                translational_scheme = self.GetTranslationalSchemeInstance(class_name)
-                return translational_scheme, error_status, summary
-            except:
-                error_status = 1
-                summary = 'The class corresponding to the translational integration scheme named ' + name + ' has not been added to python. Please, select a different name or add the required class.'
-        else:
-            error_status = 2
-            summary = 'The translational integration scheme name ' + name + ' does not designate any available scheme. Please, select a different one'
-
-        return translational_scheme, error_status, summary
-
-    def GetRotationalScheme(self, name_translational, name_rotational):
-        class_name = self.RotationalIntegrationSchemeTranslator(name_translational, name_rotational)
-        rotational_scheme = None
-        error_status = 0
-        summary = ''
-
-        if not class_name == None:
-            try:
-                rotational_scheme = self.GetRotationalSchemeInstance(class_name)
-                return rotational_scheme, error_status, summary
-            except:
-                error_status = 1
-                summary = 'The class corresponding to the rotational integration scheme name ' + name + ' has not been added to python. Please, select a different name or add the required class.'
-        else:
-            error_status = 2
-            summary = 'The rotational integration scheme name ' + name + ' does not designate any available scheme. Please, select a different one'
-
-        return rotational_scheme, error_status, summary
-
-    def ModifyProperties(self, properties, param = 0):
-
-        if param:
-            return
-
-        if not properties.Has(COMPUTE_WEAR):
-            properties.SetValue(COMPUTE_WEAR, False)
-
-        if properties.Has(CLUSTER_FILE_NAME):
-            cluster_file_name = properties[CLUSTER_FILE_NAME]
-            [name, list_of_coordinates, list_of_radii, size, volume, inertias] = cluster_file_reader.ReadClusterFile(cluster_file_name)
-            pre_utils = PreUtilities(self.spheres_model_part)
-            pre_utils.SetClusterInformationInProperties(name, list_of_coordinates, list_of_radii, size, volume, inertias, properties)
-            self.Procedures.KratosPrintInfo(properties)
-            if not properties.Has(BREAKABLE_CLUSTER):
-                properties.SetValue(BREAKABLE_CLUSTER, False)
-
-        if properties.Has(DEM_TRANSLATIONAL_INTEGRATION_SCHEME_NAME):
-            translational_scheme_name = properties[DEM_TRANSLATIONAL_INTEGRATION_SCHEME_NAME]
-        else:
-            translational_scheme_name = self.DEM_parameters["TranslationalIntegrationScheme"].GetString()
-
-        translational_scheme, error_status, summary_mssg = self.GetTranslationalScheme(translational_scheme_name)
-
-        translational_scheme.SetTranslationalIntegrationSchemeInProperties(properties, True)
-
-        if properties.Has(DEM_ROTATIONAL_INTEGRATION_SCHEME_NAME):
-            rotational_scheme_name = properties[DEM_ROTATIONAL_INTEGRATION_SCHEME_NAME]
-        else:
-            rotational_scheme_name = self.DEM_parameters["RotationalIntegrationScheme"].GetString()
-
-        rotational_scheme, error_status, summary_mssg = self.GetRotationalScheme(translational_scheme_name, rotational_scheme_name)
-        rotational_scheme.SetRotationalIntegrationSchemeInProperties(properties, True)
-
-        if self.DEM_parameters["RotationOption"].GetBool() and self.DEM_parameters["RollingFrictionOption"].GetBool():
-            #The function is to transfer the Rolling Friction Model Name from subProperties to Properties or set a default name
-            #Because some rolling friction models depend the particle but not the contact between particles
-            self.TransferRollingFrictionModelNameOrSetDefault(properties)
-
-    def ModifySubProperties(self, properties, parent_id, param = 0):
-
-        DiscontinuumConstitutiveLaw = globals().get(properties[DEM_DISCONTINUUM_CONSTITUTIVE_LAW_NAME])()
-        coefficient_of_restitution = properties[COEFFICIENT_OF_RESTITUTION]
-
-        type_of_law = DiscontinuumConstitutiveLaw.GetTypeOfLaw()
-
-        write_gamma = False
-
-        write_AlphaFunction = False
-
-        if (type_of_law == 'Linear'):
-            gamma = self.RootByBisection(self.coeff_of_rest_diff, 0.0, 16.0, 0.0001, 300, coefficient_of_restitution)
-            write_gamma = True
-
-        elif (type_of_law == 'Hertz'):
-            gamma = self.GammaForHertzThornton(coefficient_of_restitution)
-            write_gamma = True
-
-        elif (type_of_law == 'Stress_dependent'):
-            gamma = self.GammaCritical(coefficient_of_restitution)
-            write_gamma = True
-
-        elif (type_of_law == 'Conical_damage'):
-            gamma = self.GammaForHertzThornton(coefficient_of_restitution)
-            write_gamma = True
-            conical_damage_alpha = properties[CONICAL_DAMAGE_ALPHA]
-            AlphaFunction = self.SinAlphaConicalDamage(conical_damage_alpha)
-            write_AlphaFunction = True
-            if not properties.Has(LEVEL_OF_FOULING):
-                properties[LEVEL_OF_FOULING] = 0.0
-
-        else:
-            pass
-
-        if write_gamma == True:
-            properties[DAMPING_GAMMA] = gamma
-
-        if write_AlphaFunction == True:
-            properties[CONICAL_DAMAGE_ALPHA_FUNCTION] = AlphaFunction
-
-        DiscontinuumConstitutiveLaw.SetConstitutiveLawInProperties(properties, False)
-
-        if properties.Has(FRICTION):
-            self.Procedures.KratosPrintWarning("-------------------------------------------------")
-            self.Procedures.KratosPrintWarning("  WARNING: Property FRICTION is deprecated since April 6th, 2020, ")
-            self.Procedures.KratosPrintWarning("  replace with STATIC_FRICTION, DYNAMIC_FRICTION and FRICTION_DECAY")
-            self.Procedures.KratosPrintWarning("  Automatic replacement is done now.")
-            self.Procedures.KratosPrintWarning("-------------------------------------------------")
-            properties[STATIC_FRICTION] = properties[FRICTION]
-            properties[DYNAMIC_FRICTION] = properties[FRICTION]
-            properties[FRICTION_DECAY] = 500.0
-
-        if not properties.Has(FRICTION_DECAY):
-            properties[FRICTION_DECAY] = 500.0
-
-        if not properties.Has(ROLLING_FRICTION_WITH_WALLS):
-            properties[ROLLING_FRICTION_WITH_WALLS] = properties[ROLLING_FRICTION]
-
-        if not properties.Has(DEM_ROLLING_FRICTION_MODEL_NAME):
-            properties[DEM_ROLLING_FRICTION_MODEL_NAME] = "DEMRollingFrictionModelConstantTorque"
-            self.Procedures.KratosPrintWarning("Using a default rolling friction model [DEMRollingFrictionModelConstantTorque] for material relation with parameter \"material_ids_list\": [" + str(parent_id) + ", " + str(properties.Id) + "]")
-
-        rolling_friction_model = globals().get(properties[DEM_ROLLING_FRICTION_MODEL_NAME])()
-        rolling_friction_model.SetAPrototypeOfThisInProperties(properties, False)
-
-    def ImportModelPart(self): #TODO: for the moment, provided for compatibility
-        pass
-
-    def PrepareModelPart(self): #TODO: for the moment, provided for compatibility
-        pass
-
-    def GetComputingModelPart(self):
-        return self.spheres_model_part
-
-    def TransferRollingFrictionModelNameOrSetDefault(self, properties):
-
-        has_subproperties = False
-        has_rolling_friction_model_name = False
-
-        for subproperties in properties.GetSubProperties():
-            has_subproperties = True
-            if subproperties.Has(DEM_ROLLING_FRICTION_MODEL_NAME):
-                has_rolling_friction_model_name = True
-
-        for subproperties in properties.GetSubProperties():
-            if not subproperties.Has(DEM_ROLLING_FRICTION_MODEL_NAME) and has_rolling_friction_model_name is False:
-                properties[DEM_ROLLING_FRICTION_MODEL_NAME] = "DEMRollingFrictionModelBounded"
-                self.Procedures.KratosPrintWarning("Using a default rolling friction model [DEMRollingFrictionModelBounded] for material property with parameter \"material_id\": [" + str(properties.Id) + "]")
-            else:
-                properties[DEM_ROLLING_FRICTION_MODEL_NAME] = subproperties[DEM_ROLLING_FRICTION_MODEL_NAME]
-
-        if has_subproperties is False and properties.Id != 0:
-            properties[DEM_ROLLING_FRICTION_MODEL_NAME] = "DEMRollingFrictionModelBounded"
-            self.Procedures.KratosPrintWarning("Using a default rolling friction model [DEMRollingFrictionModelBounded] for material property with parameter \"material_id\": [" + str(properties.Id) + "]")
-
-        if properties.Id != 0:
-            rolling_friction_model = globals().get(properties[DEM_ROLLING_FRICTION_MODEL_NAME])()
-            rolling_friction_model.SetAPrototypeOfThisInProperties(properties, False)
+import sys
+from KratosMultiphysics import *
+from KratosMultiphysics.DEMApplication import *
+import math
+import time
+import KratosMultiphysics.DEMApplication.cluster_file_reader as cluster_file_reader
+
+class ExplicitStrategy():
+
+    #def __init__(self, all_model_parts, creator_destructor, dem_fem_search, scheme, DEM_parameters, procedures):
+    def __init__(self, all_model_parts, creator_destructor, dem_fem_search, DEM_parameters, procedures):
+        self.solver_settings = DEM_parameters["solver_settings"]
+
+        default_settings = Parameters("""
+        {
+            "strategy" : "sphere_strategy",
+            "do_search_dem_neighbours" : true,
+            "do_search_fem_neighbours" : true,
+            "RemoveBallsInitiallyTouchingWalls": false,
+            "model_import_settings": {
+                "input_type": "mdpa",
+                "input_filename": "unknown_name"
+            },
+            "material_import_settings"           : {
+                "materials_filename" : "MaterialsDEM.json"
+            }
+        }""")
+
+        if self.solver_settings.Has("do_search_neighbours"):
+            Logger.PrintWarning("DEM", '\nWARNING!:  do_search_neighbours flag is deprecated. Please use do_search_dem_neighbours instead.\n')
+            self.solver_settings.AddValue("do_search_dem_neighbours", self.solver_settings["do_search_neighbours"])
+            self.solver_settings.RemoveValue("do_search_neighbours")
+
+        self.solver_settings.ValidateAndAssignDefaults(default_settings)
+
+        # Initialization of member variables
+        self.all_model_parts = all_model_parts
+        self.spheres_model_part = all_model_parts.Get("SpheresPart")
+        self.inlet_model_part = all_model_parts.Get("DEMInletPart")
+        self.fem_model_part = all_model_parts.Get("RigidFacePart")
+        self.cluster_model_part = all_model_parts.Get("ClusterPart")
+        self.contact_model_part = all_model_parts.Get("ContactPart")
+
+        self.DEM_parameters = DEM_parameters
+        self.dem_fem_utils = DEMFEMUtilities()
+
+        self.dimension = DEM_parameters["Dimension"].GetInt()
+
+        if not "ComputeStressTensorOption" in DEM_parameters.keys():
+            self.compute_stress_tensor_option = 0
+        else:
+            self.compute_stress_tensor_option = DEM_parameters["ComputeStressTensorOption"].GetBool()
+
+        if "PostStressStrainOption" in DEM_parameters.keys() and DEM_parameters["PostStressStrainOption"].GetBool():
+            self.compute_stress_tensor_option = 1
+            self.print_stress_tensor_option = 1
+        else:
+            self.print_stress_tensor_option = 0
+
+        self.trihedron_option        = DEM_parameters["PostEulerAngles"].GetBool()
+        self.rotation_option         = DEM_parameters["RotationOption"].GetBool()
+        self.bounding_box_option     = DEM_parameters["BoundingBoxOption"].GetBool()
+        self.fix_velocities_flag     = 0
+        self.Procedures              = procedures
+        #self.time_integration_scheme = scheme
+        #self.time_integration_scheme.SetRotationOption(self.rotation_option)
+
+        self.clean_init_indentation_option = DEM_parameters["CleanIndentationsOption"].GetBool()
+
+        if self.clean_init_indentation_option and self._GetInputType() == 'rest':
+            Logger.PrintWarning("DEM", '\nWARNING!: \'clean_indentations_option\' is set to true in a restarted simulation. The particles\' radii could be modified before the first time step.\n' * 50)
+
+        self.contact_mesh_option           = 0
+        if "ContactMeshOption" in DEM_parameters.keys():
+            self.contact_mesh_option      = DEM_parameters["ContactMeshOption"].GetBool()
+        self.automatic_bounding_box_option = DEM_parameters["AutomaticBoundingBoxOption"].GetBool()
+
+        self.delta_option = DEM_parameters["DeltaOption"].GetString() #TODO: this is not an option (bool) let's change the name to something including 'type'
+
+        self.search_increment = 0.0
+        self.search_increment_for_walls = 0.0
+        self.search_increment_for_bonds_creation = 0.0
+        self.coordination_number = 10.0
+
+        if self._GetInputType() == 'rest':
+            self.search_control = 2
+
+        else:
+            self.search_control = 1
+
+        if "LocalResolutionMethod" in DEM_parameters.keys():
+            if (DEM_parameters["LocalResolutionMethod"].GetString() == "hierarchical"):
+                self.local_resolution_method = 1
+            elif (DEM_parameters["LocalResolutionMethod"].GetString() == "area_distribution"):
+                self.local_resolution_method = 2
+            else:
+                self.local_resolution_method = 1
+        else:
+            self.local_resolution_method = 1
+
+        if DEM_parameters["DeltaOption"].GetString() == "None":
+            self.delta_option = 0
+
+        elif DEM_parameters["DeltaOption"].GetString() == "Absolute":
+            self.delta_option = 1
+            self.search_increment = DEM_parameters["SearchTolerance"].GetDouble()
+            if not "SearchToleranceForBondsCreation" in DEM_parameters.keys():
+                self.search_increment_for_bonds_creation  = self.search_increment
+            else:
+                self.search_increment_for_bonds_creation = DEM_parameters["SearchToleranceForBondsCreation"].GetDouble()
+
+        elif DEM_parameters["DeltaOption"].GetString() == "Coordination_Number":
+            self.delta_option = 2
+            self.coordination_number = DEM_parameters["CoordinationNumber"].GetDouble()
+            self.search_increment = 0.01 * 0.0001 #DEM_parameters-MeanRadius
+
+        self.search_increment_for_walls = DEM_parameters["search_tolerance_against_walls"].GetDouble()
+
+        # TIME RELATED PARAMETERS
+        self.dt = DEM_parameters["MaxTimeStep"].GetDouble()
+        self.max_delta_time = DEM_parameters["MaxTimeStep"].GetDouble()
+        self.end_time = DEM_parameters["FinalTime"].GetDouble()
+
+        # BOUNDING_BOX
+        self.enlargement_factor = DEM_parameters["BoundingBoxEnlargementFactor"].GetDouble()
+        self.top_corner = Array3()
+        self.bottom_corner = Array3()
+        self.bottom_corner[0] = DEM_parameters["BoundingBoxMinX"].GetDouble()
+        self.bottom_corner[1] = DEM_parameters["BoundingBoxMinY"].GetDouble()
+        self.bottom_corner[2] = DEM_parameters["BoundingBoxMinZ"].GetDouble()
+        self.top_corner[0] = DEM_parameters["BoundingBoxMaxX"].GetDouble()
+        self.top_corner[1] = DEM_parameters["BoundingBoxMaxY"].GetDouble()
+        self.top_corner[2] = DEM_parameters["BoundingBoxMaxZ"].GetDouble()
+
+        if not "BoundingBoxStartTime" in DEM_parameters.keys():
+            self.bounding_box_start_time  = 0.0
+        else:
+            self.bounding_box_start_time  = DEM_parameters["BoundingBoxStartTime"].GetDouble()
+
+        if not "BoundingBoxStopTime" in DEM_parameters.keys():
+            self.bounding_box_stop_time  = self.end_time
+        else:
+            self.bounding_box_stop_time  = DEM_parameters["BoundingBoxStopTime"].GetDouble()
+
+        # GLOBAL PHYSICAL ASPECTS
+        self.gravity = Vector(3)
+        self.gravity[0] = DEM_parameters["GravityX"].GetDouble()
+        self.gravity[1] = DEM_parameters["GravityY"].GetDouble()
+        self.gravity[2] = DEM_parameters["GravityZ"].GetDouble()
+
+        self.virtual_mass_option = 0
+        self.nodal_mass_coeff = DEM_parameters["VirtualMassCoefficient"].GetDouble()
+
+        if (self.nodal_mass_coeff != 1.0):
+            self.virtual_mass_option = 1
+
+        self.rolling_friction_option = DEM_parameters["RollingFrictionOption"].GetBool()
+
+        if not "GlobalDamping" in DEM_parameters.keys():
+            self.global_damping = 0.0
+            Logger.PrintWarning("DEM", "\nGlobal Damping parameter not found! No damping will be applied...\n")
+        else:
+            self.global_damping = DEM_parameters["GlobalDamping"].GetDouble()
+
+        if not "GlobalViscousDamping" in DEM_parameters.keys():
+            self.global_viscous_damping = 0.0
+            Logger.PrintWarning("DEM", "\nGlobal Viscous Damping parameter not found! No damping will be applied...\n")
+        else:
+            self.global_viscous_damping = DEM_parameters["GlobalViscousDamping"].GetDouble()
+
+        # PRINTING VARIABLES
+        self.print_export_id = DEM_parameters["PostExportId"].GetBool()
+        self.print_export_skin_sphere = 0
+        self.poisson_ratio_option = 0
+
+        # RESOLUTION METHODS AND PARAMETERS
+        self.n_step_search = DEM_parameters["NeighbourSearchFrequency"].GetInt() #TODO: NeighbourSearchFrequency change name to something that includes number of steps
+        self.safety_factor = DEM_parameters["DeltaTimeSafetyFactor"].GetDouble()  # For critical time step @53214
+
+        # CREATOR-DESTRUCTOR
+        self.creator_destructor = creator_destructor
+        self.dem_fem_search = dem_fem_search
+
+        # STRATEGIES
+        self.search_strategy = OMP_DEMSearch()
+        if "PeriodicDomainOption" in DEM_parameters.keys():
+            if DEM_parameters["PeriodicDomainOption"].GetBool():
+                self.search_strategy = OMP_DEMSearch(DEM_parameters["BoundingBoxMinX"].GetDouble(),
+                                                     DEM_parameters["BoundingBoxMinY"].GetDouble(),
+                                                     DEM_parameters["BoundingBoxMinZ"].GetDouble(),
+                                                     DEM_parameters["BoundingBoxMaxX"].GetDouble(),
+                                                     DEM_parameters["BoundingBoxMaxY"].GetDouble(),
+                                                     DEM_parameters["BoundingBoxMaxZ"].GetDouble())
+
+
+        self.SetContinuumType()
+
+    def _GetRestartSettings(self, model_part_import_settings):
+        restart_settings = model_part_import_settings.Clone()
+        restart_settings.RemoveValue("input_type")
+        if not restart_settings.Has("restart_load_file_label"):
+            raise Exception('"restart_load_file_label" must be specified when starting from a restart-file!')
+        if model_part_import_settings.Has("echo_level"):
+            restart_settings.AddValue("echo_level", model_part_import_settings["echo_level"])
+
+        return restart_settings
+
+    def SetContinuumType(self):
+        self.continuum_type = False
+
+    def Var_Translator(self, variable):
+
+        if (variable == "OFF" or variable == "0" or variable == 0 or variable == "No"):
+            variable = 0
+        else:
+            variable = 1
+
+        return variable
+
+    def SetOneOrZeroInProcessInfoAccordingToBoolValue(self, model_part, variable, bool_value): #TODO: to be removed, because the Kratos variables should be bools already
+        if bool_value:
+            model_part.ProcessInfo.SetValue(variable, 1)
+        else:
+            model_part.ProcessInfo.SetValue(variable, 0)
+
+    def SetVariablesAndOptions(self):
+
+        # Setting ProcessInfo variables
+        for name in self.all_model_parts.model_parts.keys():
+            self.all_model_parts.Get(name).ProcessInfo.SetValue(IS_RESTARTED, self._GetInputType() == 'rest')
+
+        # DIMENSION PARAMETERS
+        self.spheres_model_part.ProcessInfo.SetValue(DOMAIN_SIZE, self.dimension)
+
+        # SIMULATION FLAGS
+        self.spheres_model_part.ProcessInfo.SetValue(IS_TIME_TO_PRINT, False)
+        self.spheres_model_part.ProcessInfo.SetValue(VIRTUAL_MASS_OPTION, self.virtual_mass_option)
+        self.spheres_model_part.ProcessInfo.SetValue(TRIHEDRON_OPTION, self.trihedron_option)
+        self.SetOneOrZeroInProcessInfoAccordingToBoolValue(self.spheres_model_part, ROTATION_OPTION, self.rotation_option)
+        self.SetOneOrZeroInProcessInfoAccordingToBoolValue(self.spheres_model_part, BOUNDING_BOX_OPTION, self.bounding_box_option)
+        self.spheres_model_part.ProcessInfo.SetValue(SEARCH_CONTROL, self.search_control)
+        self.spheres_model_part.ProcessInfo.SetValue(FIX_VELOCITIES_FLAG, self.fix_velocities_flag)
+        self.spheres_model_part.ProcessInfo.SetValue(NEIGH_INITIALIZED, 0)
+        self.spheres_model_part.ProcessInfo.SetValue(CLEAN_INDENT_OPTION, self.clean_init_indentation_option)
+        self.spheres_model_part.ProcessInfo.SetValue(BOUNDING_BOX_START_TIME, self.bounding_box_start_time)
+        self.spheres_model_part.ProcessInfo.SetValue(BOUNDING_BOX_STOP_TIME, self.bounding_box_stop_time)
+        self.spheres_model_part.ProcessInfo.SetValue(COMPUTE_STRESS_TENSOR_OPTION, self.compute_stress_tensor_option)
+        self.spheres_model_part.ProcessInfo.SetValue(PRINT_STRESS_TENSOR_OPTION, self.print_stress_tensor_option)
+        self.spheres_model_part.ProcessInfo.SetValue(CONTINUUM_OPTION, self.continuum_type)
+        self.spheres_model_part.ProcessInfo.SetValue(IMPOSED_Z_STRAIN_VALUE, 0.0) # A default value
+
+        self.spheres_model_part.ProcessInfo.SetValue(DOMAIN_IS_PERIODIC, 0) #TODO: DOMAIN_IS_PERIODIC should be a bool, and should have the suffix option
+        if "PeriodicDomainOption" in self.DEM_parameters.keys():
+            if self.DEM_parameters["PeriodicDomainOption"].GetBool():
+                self.spheres_model_part.ProcessInfo.SetValue(DOMAIN_IS_PERIODIC, 1) #TODO: DOMAIN_IS_PERIODIC should be a bool, and should have the suffix option
+
+        self.spheres_model_part.ProcessInfo.SetValue(DOMAIN_MIN_CORNER, self.bottom_corner)
+        self.spheres_model_part.ProcessInfo.SetValue(DOMAIN_MAX_CORNER, self.top_corner)
+        self.spheres_model_part.ProcessInfo.SetValue(GRAVITY, self.gravity)
+
+        # GLOBAL MATERIAL PROPERTIES
+        self.spheres_model_part.ProcessInfo.SetValue(NODAL_MASS_COEFF, self.nodal_mass_coeff)
+        self.SetOneOrZeroInProcessInfoAccordingToBoolValue(self.spheres_model_part, ROLLING_FRICTION_OPTION, self.rolling_friction_option)
+        self.spheres_model_part.ProcessInfo.SetValue(GLOBAL_DAMPING, self.global_damping)
+        self.spheres_model_part.ProcessInfo.SetValue(GLOBAL_VISCOUS_DAMPING, self.global_viscous_damping)
+
+        # SEARCH-RELATED
+        self.spheres_model_part.ProcessInfo.SetValue(SEARCH_RADIUS_INCREMENT, self.search_increment)
+        self.spheres_model_part.ProcessInfo.SetValue(SEARCH_RADIUS_INCREMENT_FOR_WALLS, self.search_increment_for_walls)
+        self.spheres_model_part.ProcessInfo.SetValue(SEARCH_RADIUS_INCREMENT_FOR_BONDS_CREATION, self.search_increment_for_bonds_creation)
+        self.spheres_model_part.ProcessInfo.SetValue(COORDINATION_NUMBER, self.coordination_number)
+        self.spheres_model_part.ProcessInfo.SetValue(LOCAL_RESOLUTION_METHOD, self.local_resolution_method)
+        if self.contact_mesh_option:
+            self.spheres_model_part.ProcessInfo.SetValue(CONTACT_MESH_OPTION, 1)
+        else:
+            self.spheres_model_part.ProcessInfo.SetValue(CONTACT_MESH_OPTION, 0)
+
+        # PRINTING VARIABLES
+
+        self.spheres_model_part.ProcessInfo.SetValue(PRINT_EXPORT_ID, self.print_export_id)
+
+        # TIME RELATED PARAMETERS
+        self.spheres_model_part.ProcessInfo.SetValue(DELTA_TIME, self.dt)
+
+        #-----os.chdir('..')   # check functionality
+
+        for properties in self.spheres_model_part.Properties:
+            self.ModifyProperties(properties)
+            for subproperties in properties.GetSubProperties():
+                self.ModifySubProperties(subproperties, properties.Id)
+
+        for submp in self.inlet_model_part.SubModelParts:
+            if submp.Has(CLUSTER_FILE_NAME):
+                cluster_file_name = submp[CLUSTER_FILE_NAME]
+                [name, list_of_coordinates, list_of_radii, size, volume, inertias] = cluster_file_reader.ReadClusterFile(cluster_file_name)
+                pre_utils = PreUtilities(self.spheres_model_part)
+                if not submp.Has(PROPERTIES_ID):
+                    raise Exception("This ModelPart: " + submp.Name + " should contain PROPERTIES_ID. Make sure it was added in the assignation table of the Materials json file.")
+                props_id = submp[PROPERTIES_ID]
+                for prop in self.inlet_model_part.Properties:
+                    if prop.Id == props_id:
+                        properties = prop
+                        break
+                pre_utils.SetClusterInformationInProperties(name, list_of_coordinates, list_of_radii, size, volume, inertias, properties)
+                if not properties.Has(BREAKABLE_CLUSTER):
+                    properties.SetValue(BREAKABLE_CLUSTER, False)
+
+        # RESOLUTION METHODS AND PARAMETERS
+        # Creating the solution strategy
+        self.settings = ExplicitSolverSettings()
+        self.settings.r_model_part = self.spheres_model_part
+        self.settings.contact_model_part = self.contact_model_part
+        self.settings.fem_model_part = self.fem_model_part
+        self.settings.inlet_model_part = self.inlet_model_part
+        self.settings.cluster_model_part = self.cluster_model_part  
+    
+    def CheckMomentumConservation(self):
+
+        previous_discontinuum_constitutive_law_string = ""
+        current_discontinuum_constitutive_law_string = ""
+        output_message = "\n*********************************************************************************************\n"+\
+                           "*********************************************************************************************\n"+\
+                           "WARNING:                                                                                     \n"+\
+                           "A mix of constitutive laws is being used. The momentum conservation law will not be fulfilled\n"+\
+                           "in the interaction of particles of different constitutive laws. Please, cancel the simulation\n"+\
+                           "if that fact represents a problem. Otherwise, computations will resume in a few seconds.     \n"+\
+                           "*********************************************************************************************\n"+\
+                           "*********************************************************************************************\n"
+        delay = 1  # Inserting the desired delay in seconds
+        counter = 0
+        for properties in self.spheres_model_part.Properties:
+            current_discontinuum_constitutive_law_string = properties[DEM_DISCONTINUUM_CONSTITUTIVE_LAW_NAME]
+            if ((counter > 0) and (previous_discontinuum_constitutive_law_string != current_discontinuum_constitutive_law_string)):
+                self.Procedures.KratosPrintInfo(output_message)
+                time.sleep(delay) # Inserting a delay so the user has ample time to read the message
+                break
+            previous_discontinuum_constitutive_law_string = current_discontinuum_constitutive_law_string
+            counter += 1
+
+
+    def CreateCPlusPlusStrategy(self):
+
+        self.SetVariablesAndOptions()
+
+        if (self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Velocity_Verlet'):
+            self.cplusplus_strategy = IterativeSolverStrategy(self.settings, self.max_delta_time, self.n_step_search, self.safety_factor,
+                                                              self.delta_option, self.creator_destructor, self.dem_fem_search,
+                                                              self.search_strategy, self.solver_settings)
+        else:
+            self.cplusplus_strategy = ExplicitSolverStrategy(self.settings, self.max_delta_time, self.n_step_search, self.safety_factor,
+                                                             self.delta_option, self.creator_destructor, self.dem_fem_search,
+                                                             self.search_strategy, self.solver_settings)
+            
+    def UpdateCPlusPlusStrategy(self):
+
+        if (self.DEM_parameters["TranslationalIntegrationScheme"].GetString() == 'Velocity_Verlet'):
+            self.cplusplus_strategy = IterativeSolverStrategy(self.settings, self.max_delta_time, self.n_step_search, self.safety_factor,
+                                                              self.delta_option, self.creator_destructor, self.dem_fem_search,
+                                                              self.search_strategy, self.solver_settings)
+        else:
+            self.cplusplus_strategy = ExplicitSolverStrategy(self.settings, self.max_delta_time, self.n_step_search, self.safety_factor,
+                                                             self.delta_option, self.creator_destructor, self.dem_fem_search,
+                                                             self.search_strategy, self.solver_settings)
+
+    def _GetInputType(self):
+        return self.solver_settings["model_import_settings"]["input_type"].GetString()
+
+    def AddVariables(self):
+        pass
+
+    def BeforeInitialize(self):
+        self.CreateCPlusPlusStrategy()
+        self.RebuildListOfDiscontinuumSphericParticles()
+        self.SetNormalRadiiOnAllParticles()
+        self.SetSearchRadiiOnAllParticles()
+
+    def Initialize(self):
+        self.CheckMomentumConservation()
+        self.cplusplus_strategy.Initialize()  # Calls the cplusplus_strategy (C++) Initialize function (initializes all elements and performs other necessary tasks before starting the time loop in Python)
+
+    def SetDt(self, dt):
+        self.dt = dt
+
+    def Predict(self):
+        time = self.spheres_model_part.ProcessInfo[TIME]
+        self._MoveAllMeshes(time, self.dt)
+
+    def Check(self):
+        pass
+
+    def Solve(self): # deprecated
+        self.SolveSolutionStep()
+
+    def SolveSolutionStep(self):
+        self.cplusplus_strategy.SolveSolutionStep()
+        return True
+
+    def AdvanceInTime(self, time):
+        """This function updates and return the current simulation time
+        """
+        time += self.dt
+        self._UpdateTimeInModelParts(time)
+
+        return time
+
+    def _MoveAllMeshes(self, time, dt):
+        spheres_model_part = self.all_model_parts.Get("SpheresPart")
+        dem_inlet_model_part = self.all_model_parts.Get("DEMInletPart")
+        rigid_face_model_part = self.all_model_parts.Get("RigidFacePart")
+
+        self.dem_fem_utils.MoveAllMeshes(spheres_model_part, time, dt)
+        self.dem_fem_utils.MoveAllMeshes(dem_inlet_model_part, time, dt)
+        self.dem_fem_utils.MoveAllMeshes(rigid_face_model_part, time, dt)
+
+    def _UpdateTimeInModelParts(self, time, is_time_to_print = False):
+        spheres_model_part = self.all_model_parts.Get("SpheresPart")
+        cluster_model_part = self.all_model_parts.Get("ClusterPart")
+        dem_inlet_model_part = self.all_model_parts.Get("DEMInletPart")
+        rigid_face_model_part = self.all_model_parts.Get("RigidFacePart")
+
+        self._UpdateTimeInOneModelPart(spheres_model_part, time, self.dt, is_time_to_print)
+        self._UpdateTimeInOneModelPart(cluster_model_part, time, self.dt, is_time_to_print)
+        self._UpdateTimeInOneModelPart(dem_inlet_model_part, time, self.dt, is_time_to_print)
+        self._UpdateTimeInOneModelPart(rigid_face_model_part, time, self.dt, is_time_to_print)
+
+    @classmethod
+    def _UpdateTimeInOneModelPart(self, model_part, time, dt, is_time_to_print = False):
+        ''' This method is redirected to its cpp version with improved speed.
+        It also has been updated to classmethod and args so it can be called from external App
+        '''
+
+        AuxiliaryUtilities().UpdateTimeInOneModelPart(model_part, time, dt, is_time_to_print)
+
+
+    def FinalizeSolutionStep(self):
+        self.cplusplus_strategy.FinalizeSolutionStep()
+
+    def Finalize(self):
+        pass
+
+    def InitializeSolutionStep(self):
+        time = self.spheres_model_part.ProcessInfo[TIME]
+        self.FixDOFsManually(time)
+        self.cplusplus_strategy.ResetPrescribedMotionFlagsRespectingImposedDofs()
+        self.FixExternalForcesManually(time)
+
+        self.cplusplus_strategy.InitializeSolutionStep()
+
+    def SetNormalRadiiOnAllParticles(self):
+        self.cplusplus_strategy.SetNormalRadiiOnAllParticles(self.spheres_model_part)
+
+    def SetSearchRadiiOnAllParticles(self):
+
+        self.cplusplus_strategy.SetSearchRadiiOnAllParticles(self.spheres_model_part, self.search_increment, 1.0)
+
+    def RebuildListOfDiscontinuumSphericParticles(self):
+        self.cplusplus_strategy.RebuildListOfDiscontinuumSphericParticles()
+
+    def Compute_RigidFace_Movement(self):
+        self.cplusplus_strategy.Compute_RigidFace_Movement()
+
+
+    def FixDOFsManually(self, time):
+    #if time>1.0:
+        #for node in self.spheres_model_part.Nodes:
+            #node.Fix(VELOCITY_X)
+            #node.SetSolutionStepValue(VELOCITY_X, 0.0)
+        pass
+
+    def FixExternalForcesManually(self,time):
+        pass
+
+    def AddAdditionalVariables(self, balls_model_part, DEM_parameters):
+        pass
+
+    def AddClusterVariables(self, spheres_model_part, DEM_parameters):
+        pass
+
+    def AddDofs(self):
+        # this can safely be called also for restarts, it is internally checked if the dofs exist already
+        spheres_model_part = self.all_model_parts.Get("SpheresPart")
+        dem_inlet_model_part = self.all_model_parts.Get("DEMInletPart")
+        cluster_model_part = self.all_model_parts.Get("ClusterPart")
+
+        model_part_list = [spheres_model_part, cluster_model_part, dem_inlet_model_part]
+        variable_list = [VELOCITY_X, VELOCITY_Y, VELOCITY_Z, ANGULAR_VELOCITY_X, ANGULAR_VELOCITY_Y, ANGULAR_VELOCITY_Z]
+        for model_part in model_part_list:
+            for variable in variable_list:
+                VariableUtils().AddDof(variable, model_part)
+            self.Procedures.KratosPrintInfo("DOFs for the DEM solution added correctly")
+
+    def PrepareElementsForPrinting(self):
+        self.cplusplus_strategy.PrepareElementsForPrinting()
+
+    def PrepareContactElementsForPrinting(self):
+        self.cplusplus_strategy.PrepareContactElementsForPrinting()
+
+    def AttachSpheresToStickyWalls(self):
+        self.cplusplus_strategy.AttachSpheresToStickyWalls()
+
+    def coeff_of_rest_diff(self, gamma, desired_coefficient_of_restit):
+
+        if gamma <= 1.0/math.sqrt(2.0) :
+            return math.exp(-gamma/math.sqrt(1.0-gamma*gamma)*(math.pi-math.atan(2.0*gamma*math.sqrt(1.0-gamma*gamma)/(-2.0*gamma*gamma+1.0))))-desired_coefficient_of_restit
+        elif gamma < 1.0 :
+            return math.exp(-gamma/math.sqrt(1.0-gamma*gamma)*math.atan(2.0*gamma*math.sqrt(1.0-gamma*gamma)/(2.0*gamma*gamma-1.0)))-desired_coefficient_of_restit
+        elif gamma == 1.0 :
+            return 0.135335283 - desired_coefficient_of_restit
+        else:
+            return math.exp(-gamma/math.sqrt(gamma*gamma-1.0)*math.log((gamma/math.sqrt(gamma*gamma-1.0)+1.0)/(gamma/math.sqrt(gamma*gamma-1.0)-1.0)))-desired_coefficient_of_restit
+
+
+    def RootByBisection(self, f, a, b, tol, maxiter, coefficient_of_restitution):
+
+        if coefficient_of_restitution < 0.001 :
+            coefficient_of_restitution = 0.001
+
+        if coefficient_of_restitution > 0.999 :
+            return 0.0
+        k=0
+        gamma = 0.5 * (a + b)
+
+        while b - a > tol and k <= maxiter:
+            coefficient_of_restitution_trial = self.coeff_of_rest_diff(gamma, coefficient_of_restitution)
+
+            if self.coeff_of_rest_diff(a, coefficient_of_restitution) * coefficient_of_restitution_trial < 0:
+                b = gamma
+
+            elif coefficient_of_restitution_trial == 0:
+                return gamma
+
+            else:
+                a = gamma
+
+            gamma = 0.5 * (a + b)
+            k += 1
+
+        return gamma
+
+    def GammaForHertzThornton(self, e):
+        if e < 0.001:
+            e = 0.001
+
+        if e > 0.999:
+            return 0.0
+
+        h1  = -6.918798
+        h2  = -16.41105
+        h3  =  146.8049
+        h4  = -796.4559
+        h5  =  2928.711
+        h6  = -7206.864
+        h7  =  11494.29
+        h8  = -11342.18
+        h9  =  6276.757
+        h10 = -1489.915
+
+        alpha = e*(h1+e*(h2+e*(h3+e*(h4+e*(h5+e*(h6+e*(h7+e*(h8+e*(h9+e*h10)))))))))
+
+        return math.sqrt(1.0/(1.0 - (1.0+e)*(1.0+e) * math.exp(alpha)) - 1.0)
+
+    def GammaCritical(self, e):
+        # Traken from 'Determination of the normal spring stiffness coefficient
+        # in the linear springdashpot contact model of discrete element method'
+        # https://www.sciencedirect.com/science/article/pii/S0032591013004178
+        if e < 0.001:
+            e = 0.001
+
+        if e > 0.999:
+            return 0.0
+
+        aux = math.log(e)
+
+        return -aux / math.sqrt(math.pi ** 2 + aux ** 2)
+
+    def SinAlphaConicalDamage(self, e):
+
+        if e < 0.001:
+            sinAlpha = 0.001
+
+        else:
+            sinAlpha = math.sin(math.radians(e))
+
+        return (1-sinAlpha)/sinAlpha
+
+    def TranslationalIntegrationSchemeTranslator(self, name):
+        class_name = None
+
+        if name == 'Forward_Euler':
+            class_name = 'ForwardEulerScheme'
+        elif name == 'Symplectic_Euler':
+            class_name = 'SymplecticEulerScheme'
+        elif name == 'Taylor_Scheme':
+            class_name = 'TaylorScheme'
+        elif name == 'Velocity_Verlet':
+            class_name = 'VelocityVerletScheme'
+
+        return class_name
+
+    def RotationalIntegrationSchemeTranslator(self, name_translational, name_rotational):
+        class_name = None
+
+        if name_rotational == 'Direct_Integration' or name_rotational == 'same_as_translational':
+            class_name = self.TranslationalIntegrationSchemeTranslator(name_translational)
+        elif name_rotational == 'Forward_Euler':
+            class_name = 'ForwardEulerScheme'
+        elif name_rotational == 'Symplectic_Euler':
+            class_name = 'SymplecticEulerScheme'
+        elif name_rotational == 'Taylor_Scheme':
+            class_name = 'TaylorScheme'
+        elif name_rotational == 'Velocity_Verlet':
+            class_name = 'VelocityVerletScheme'
+        elif name_rotational == 'Runge_Kutta':
+            class_name = 'RungeKuttaScheme'
+        elif name_rotational == 'Quaternion_Integration':
+            class_name = 'QuaternionIntegrationScheme'
+
+        return class_name
+
+    def GetTranslationalSchemeInstance(self, class_name):
+        return eval(class_name)()
+
+    def GetRotationalSchemeInstance(self, class_name):
+        return eval(class_name)()
+
+    def GetTranslationalScheme(self, name):
+        class_name = self.TranslationalIntegrationSchemeTranslator(name)
+        translational_scheme = None
+        error_status = 0
+        summary = ''
+
+        if not class_name == None:
+            try:
+                translational_scheme = self.GetTranslationalSchemeInstance(class_name)
+                return translational_scheme, error_status, summary
+            except:
+                error_status = 1
+                summary = 'The class corresponding to the translational integration scheme named ' + name + ' has not been added to python. Please, select a different name or add the required class.'
+        else:
+            error_status = 2
+            summary = 'The translational integration scheme name ' + name + ' does not designate any available scheme. Please, select a different one'
+
+        return translational_scheme, error_status, summary
+
+    def GetRotationalScheme(self, name_translational, name_rotational):
+        class_name = self.RotationalIntegrationSchemeTranslator(name_translational, name_rotational)
+        rotational_scheme = None
+        error_status = 0
+        summary = ''
+
+        if not class_name == None:
+            try:
+                rotational_scheme = self.GetRotationalSchemeInstance(class_name)
+                return rotational_scheme, error_status, summary
+            except:
+                error_status = 1
+                summary = 'The class corresponding to the rotational integration scheme name ' + name + ' has not been added to python. Please, select a different name or add the required class.'
+        else:
+            error_status = 2
+            summary = 'The rotational integration scheme name ' + name + ' does not designate any available scheme. Please, select a different one'
+
+        return rotational_scheme, error_status, summary
+
+    def ModifyProperties(self, properties, param = 0):
+
+        if param:
+            return
+
+        if not properties.Has(COMPUTE_WEAR):
+            properties.SetValue(COMPUTE_WEAR, False)
+
+        if properties.Has(CLUSTER_FILE_NAME):
+            cluster_file_name = properties[CLUSTER_FILE_NAME]
+            [name, list_of_coordinates, list_of_radii, size, volume, inertias] = cluster_file_reader.ReadClusterFile(cluster_file_name)
+            pre_utils = PreUtilities(self.spheres_model_part)
+            pre_utils.SetClusterInformationInProperties(name, list_of_coordinates, list_of_radii, size, volume, inertias, properties)
+            self.Procedures.KratosPrintInfo(properties)
+            if not properties.Has(BREAKABLE_CLUSTER):
+                properties.SetValue(BREAKABLE_CLUSTER, False)
+
+        if properties.Has(DEM_TRANSLATIONAL_INTEGRATION_SCHEME_NAME):
+            translational_scheme_name = properties[DEM_TRANSLATIONAL_INTEGRATION_SCHEME_NAME]
+        else:
+            translational_scheme_name = self.DEM_parameters["TranslationalIntegrationScheme"].GetString()
+
+        translational_scheme, error_status, summary_mssg = self.GetTranslationalScheme(translational_scheme_name)
+
+        translational_scheme.SetTranslationalIntegrationSchemeInProperties(properties, True)
+
+        if properties.Has(DEM_ROTATIONAL_INTEGRATION_SCHEME_NAME):
+            rotational_scheme_name = properties[DEM_ROTATIONAL_INTEGRATION_SCHEME_NAME]
+        else:
+            rotational_scheme_name = self.DEM_parameters["RotationalIntegrationScheme"].GetString()
+
+        rotational_scheme, error_status, summary_mssg = self.GetRotationalScheme(translational_scheme_name, rotational_scheme_name)
+        rotational_scheme.SetRotationalIntegrationSchemeInProperties(properties, True)
+
+        if self.DEM_parameters["RotationOption"].GetBool() and self.DEM_parameters["RollingFrictionOption"].GetBool():
+            #The function is to transfer the Rolling Friction Model Name from subProperties to Properties or set a default name
+            #Because some rolling friction models depend the particle but not the contact between particles
+            self.TransferRollingFrictionModelNameOrSetDefault(properties)
+
+    def ModifySubProperties(self, properties, parent_id, param = 0):
+
+        DiscontinuumConstitutiveLaw = globals().get(properties[DEM_DISCONTINUUM_CONSTITUTIVE_LAW_NAME])()
+        coefficient_of_restitution = properties[COEFFICIENT_OF_RESTITUTION]
+
+        type_of_law = DiscontinuumConstitutiveLaw.GetTypeOfLaw()
+
+        write_gamma = False
+
+        write_AlphaFunction = False
+
+        if (type_of_law == 'Linear'):
+            gamma = self.RootByBisection(self.coeff_of_rest_diff, 0.0, 16.0, 0.0001, 300, coefficient_of_restitution)
+            write_gamma = True
+
+        elif (type_of_law == 'Hertz'):
+            gamma = self.GammaForHertzThornton(coefficient_of_restitution)
+            write_gamma = True
+
+        elif (type_of_law == 'Stress_dependent'):
+            gamma = self.GammaCritical(coefficient_of_restitution)
+            write_gamma = True
+
+        elif (type_of_law == 'Conical_damage'):
+            gamma = self.GammaForHertzThornton(coefficient_of_restitution)
+            write_gamma = True
+            conical_damage_alpha = properties[CONICAL_DAMAGE_ALPHA]
+            AlphaFunction = self.SinAlphaConicalDamage(conical_damage_alpha)
+            write_AlphaFunction = True
+            if not properties.Has(LEVEL_OF_FOULING):
+                properties[LEVEL_OF_FOULING] = 0.0
+
+        else:
+            pass
+
+        if write_gamma == True:
+            properties[DAMPING_GAMMA] = gamma
+
+        if write_AlphaFunction == True:
+            properties[CONICAL_DAMAGE_ALPHA_FUNCTION] = AlphaFunction
+
+        DiscontinuumConstitutiveLaw.SetConstitutiveLawInProperties(properties, False)
+
+        if properties.Has(FRICTION):
+            self.Procedures.KratosPrintWarning("-------------------------------------------------")
+            self.Procedures.KratosPrintWarning("  WARNING: Property FRICTION is deprecated since April 6th, 2020, ")
+            self.Procedures.KratosPrintWarning("  replace with STATIC_FRICTION, DYNAMIC_FRICTION and FRICTION_DECAY")
+            self.Procedures.KratosPrintWarning("  Automatic replacement is done now.")
+            self.Procedures.KratosPrintWarning("-------------------------------------------------")
+            properties[STATIC_FRICTION] = properties[FRICTION]
+            properties[DYNAMIC_FRICTION] = properties[FRICTION]
+            properties[FRICTION_DECAY] = 500.0
+
+        if not properties.Has(FRICTION_DECAY):
+            properties[FRICTION_DECAY] = 500.0
+
+        if not properties.Has(ROLLING_FRICTION_WITH_WALLS):
+            properties[ROLLING_FRICTION_WITH_WALLS] = properties[ROLLING_FRICTION]
+
+        if not properties.Has(DEM_ROLLING_FRICTION_MODEL_NAME):
+            properties[DEM_ROLLING_FRICTION_MODEL_NAME] = "DEMRollingFrictionModelConstantTorque"
+            self.Procedures.KratosPrintWarning("Using a default rolling friction model [DEMRollingFrictionModelConstantTorque] for material relation with parameter \"material_ids_list\": [" + str(parent_id) + ", " + str(properties.Id) + "]")
+
+        rolling_friction_model = globals().get(properties[DEM_ROLLING_FRICTION_MODEL_NAME])()
+        rolling_friction_model.SetAPrototypeOfThisInProperties(properties, False)
+
+    def ImportModelPart(self): #TODO: for the moment, provided for compatibility
+        pass
+
+    def PrepareModelPart(self): #TODO: for the moment, provided for compatibility
+        pass
+
+    def GetComputingModelPart(self):
+        return self.spheres_model_part
+
+    def TransferRollingFrictionModelNameOrSetDefault(self, properties):
+
+        has_subproperties = False
+        has_rolling_friction_model_name = False
+
+        for subproperties in properties.GetSubProperties():
+            has_subproperties = True
+            if subproperties.Has(DEM_ROLLING_FRICTION_MODEL_NAME):
+                has_rolling_friction_model_name = True
+
+        for subproperties in properties.GetSubProperties():
+            if not subproperties.Has(DEM_ROLLING_FRICTION_MODEL_NAME) and has_rolling_friction_model_name is False:
+                properties[DEM_ROLLING_FRICTION_MODEL_NAME] = "DEMRollingFrictionModelBounded"
+                self.Procedures.KratosPrintWarning("Using a default rolling friction model [DEMRollingFrictionModelBounded] for material property with parameter \"material_id\": [" + str(properties.Id) + "]")
+            else:
+                properties[DEM_ROLLING_FRICTION_MODEL_NAME] = subproperties[DEM_ROLLING_FRICTION_MODEL_NAME]
+
+        if has_subproperties is False and properties.Id != 0:
+            properties[DEM_ROLLING_FRICTION_MODEL_NAME] = "DEMRollingFrictionModelBounded"
+            self.Procedures.KratosPrintWarning("Using a default rolling friction model [DEMRollingFrictionModelBounded] for material property with parameter \"material_id\": [" + str(properties.Id) + "]")
+
+        if properties.Id != 0:
+            rolling_friction_model = globals().get(properties[DEM_ROLLING_FRICTION_MODEL_NAME])()
+            rolling_friction_model.SetAPrototypeOfThisInProperties(properties, False)
```

## KratosMultiphysics/DEMApplication/mesh_creator_sphere.py

 * *Ordering differences only*

```diff
@@ -1,36 +1,36 @@
-import os
-
-import KratosMultiphysics
-
-def WriteSphereMdpaFromResults(filename_pre, pre_path, filename_post, spheres_model_part):
-
-    SpheresMdpa_pre = open(os.path.join(pre_path, filename_pre) + ".mdpa", 'r')
-    SpheresMdpa_post = open(os.path.join(pre_path, filename_post) + ".mdpa", 'w')
-
-    for Line in SpheresMdpa_pre:
-        # The next 4 lines mean that, while we do not get to 'Begin Nodes', we simply copy the mdpa contents, in this case the Properties part
-        SpheresMdpa_post.write(Line)
-        if Line.startswith('Begin Nodes'):
-            break
-
-    for node in spheres_model_part.Nodes:
-        SpheresMdpa_post.write(str(node.Id) + ' ' + str(node.X) + ' ' + str(node.Y) + ' ' + str(node.Z) + '\n')
-    SpheresMdpa_post.write('End Nodes\n\n')
-
-    for Line in SpheresMdpa_pre:
-        # We copy the element type line from the previous mdpa
-        if Line.startswith('Begin Elements'):
-            SpheresMdpa_post.write(Line)
-            break
-
-    for element in spheres_model_part.Elements:
-        SpheresMdpa_post.write(str(element.Id) + ' ' + str(element.Properties.Id) + ' ' + str(element.GetNode(0).Id) + '\n')
-    SpheresMdpa_post.write('End Elements\n')
-
-    SpheresMdpa_post.write('\nBegin NodalData RADIUS\n')
-    for node in spheres_model_part.Nodes:
-        SpheresMdpa_post.write(str(node.Id) + ' 0 ' + str(node.GetSolutionStepValue(KratosMultiphysics.RADIUS)) + '\n')
-    SpheresMdpa_post.write('End NodalData\n')
-
-    SpheresMdpa_post.close()
-    SpheresMdpa_pre.close()
+import os
+
+import KratosMultiphysics
+
+def WriteSphereMdpaFromResults(filename_pre, pre_path, filename_post, spheres_model_part):
+
+    SpheresMdpa_pre = open(os.path.join(pre_path, filename_pre) + ".mdpa", 'r')
+    SpheresMdpa_post = open(os.path.join(pre_path, filename_post) + ".mdpa", 'w')
+
+    for Line in SpheresMdpa_pre:
+        # The next 4 lines mean that, while we do not get to 'Begin Nodes', we simply copy the mdpa contents, in this case the Properties part
+        SpheresMdpa_post.write(Line)
+        if Line.startswith('Begin Nodes'):
+            break
+
+    for node in spheres_model_part.Nodes:
+        SpheresMdpa_post.write(str(node.Id) + ' ' + str(node.X) + ' ' + str(node.Y) + ' ' + str(node.Z) + '\n')
+    SpheresMdpa_post.write('End Nodes\n\n')
+
+    for Line in SpheresMdpa_pre:
+        # We copy the element type line from the previous mdpa
+        if Line.startswith('Begin Elements'):
+            SpheresMdpa_post.write(Line)
+            break
+
+    for element in spheres_model_part.Elements:
+        SpheresMdpa_post.write(str(element.Id) + ' ' + str(element.Properties.Id) + ' ' + str(element.GetNode(0).Id) + '\n')
+    SpheresMdpa_post.write('End Elements\n')
+
+    SpheresMdpa_post.write('\nBegin NodalData RADIUS\n')
+    for node in spheres_model_part.Nodes:
+        SpheresMdpa_post.write(str(node.Id) + ' 0 ' + str(node.GetSolutionStepValue(KratosMultiphysics.RADIUS)) + '\n')
+    SpheresMdpa_post.write('End NodalData\n')
+
+    SpheresMdpa_post.close()
+    SpheresMdpa_pre.close()
```

## Comparing `KratosDEMApplication-9.5.dist-info/METADATA` & `KratosDEMApplication-9.5.1.dist-info/METADATA`

 * *Files 11% similar despite different names*

```diff
@@ -1,166 +1,167 @@
-Metadata-Version: 2.1
-Name: KratosDEMApplication
-Version: 9.5
-Summary: KRATOS Multiphysics ("Kratos") is a framework for building parallel, multi-disciplinary simulation software, aiming at modularity, extensibility, and high performance. Kratos is written in C++, and counts with an extensive Python interface.
-Home-page: https://github.com/KratosMultiphysics/
-Author: Kratos Team
-Author-email: kratos@listas.cimne.upc.edu
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: C++
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: Topic :: Scientific/Engineering
-Classifier: Topic :: Scientific/Engineering :: Physics
-Classifier: Topic :: Scientific/Engineering :: Mathematics
-Classifier: Natural Language :: English
-Classifier: Intended Audience :: Science/Research
-Classifier: Intended Audience :: Other Audience
-Classifier: Intended Audience :: Developers
-Classifier: Development Status :: 5 - Production/Stable
-Classifier: Environment :: Console
-Classifier: License :: OSI Approved :: BSD License
-Requires-Python: >=3.8
-Description-Content-Type: text/markdown
-Requires-Dist: KratosMultiphysics ==9.5
-
-# DEM Application
-
-This application focuses on the Discrete Element Method (DEM), a particles method for modeling the bulk behavior of granular materials and many geomaterials such as coal, ores, soil, rocks, aggregates, pellets, tablets and powders.
-
-The [DEMpack Team](www.cimne.com/dem) at [CIMNE](www.cimne.com) is in charge of all developments related to the DEM.
-
-For the coupling between DEM and Fluids, go to the [Swimming DEM Application](https://github.com/KratosMultiphysics/Kratos/tree/master/applications/SwimmingDEMApplication).
-
-For the coupling between DEM and thermal effects, go to the [Thermal DEM Application](https://github.com/KratosMultiphysics/Kratos/tree/master/applications/ThermalDEMApplication).
-
-## Getting started
-
-This application is part of the Kratos Multiphysics Platform. Instructions on how to get you a copy of the project up and running on your local machine for development and testing purposes are available for both [Linux](http://kratos-wiki.cimne.upc.edu/index.php/LinuxInstall) and [Windows](http://kratos-wiki.cimne.upc.edu/index.php/Windows_7_Download_and_Installation) systems.
-
-### Prerequisites
-
-Build [Kratos](https://github.com/KratosMultiphysics/Kratos/wiki) and, before that, make sure that you add
-
-``` cmake
--DDEM_APPLICATION=ON
-```
-
-amongst the compilation options, so the DEM application is compiled.
-
-No auxiliar external libraries are needed.
-
-## Theory
-
-The DEM is a numerical method that has been applied to simulate and analyze flow behavior in a wide range of disciplines including mechanical and process engineering, pharmaceutical, materials science, agricultural engineering and more.
-Coupling with fluid is already available through the Swimming-DEM application, also integrated in the Kratos Multiphysics Platform.
-
-The fundamental theoretical background corresponding to the discontinuous (granular matter) part of the code can be found in the DEM literature easily.
-
-### Contact laws
-
-The contact laws are implemented in [this folder](https://github.com/KratosMultiphysics/Kratos/tree/master/applications/DEMApplication/custom_constitutive). Note that the letter 'D' or 'd' in the file name stands for 'discontiuum'. It is related to non cohesive or slightly cohesive contacts.
-
-#### Linear repulsive force
-
-The most simple representation of a repulsive contact force between a sphere and a wall is given by a linear law, where the force acting on the sphere when contacting the wall is a linear function of the indentation, which in turn would bring a quadratic dependence with the contact radius.
-
-#### Non-Linear repulsive force
-
-Hertz solved in 1882 the non-cohesive normal contact between a sphere and a plane. In 1971 Johnson, Kendall and Roberts presented the solution (JKR-Theory) for the same problem in this case adding cohesive behaviour. Not much later, Derjaguin, Mller and Toporov published similar results (DMT-Theory).
-Both theories are very close and correct and, while the JKR theory is adequate to the study of flexible, large spheres, the DMT theory is specially suited to represent the behaviour of rigid, small ones.
-
-## Numerical approach
-
-The application includes two types of DEM elements used for different purposes:
-
-* Spheric Particle - Base element used to simulate granular materials (non cohesive or slightly cohesive)
-* Spheric Continuum Particle - With specific build-in variables to simulate fracture in cohesive materials. It can also be understood as a discretization method of the continuum by using spheres.
-
-And has the following easy-to-use capabilities:
-
-* Interaction with FEM-based walls - Objects that cannot be crossed by DEM spheres. The user can choose to impose Linear-periodic conditions or rigid body conditions.
-* Inlets - Inject new particles while running the simulation linked to some material properties. With user defined granulometry, mass flow and particle type (single particle or clusters). Inlets are based on FEM-based walls and boundary conditions can also be applied to them.
-* Initial conditions on particle elements.
-* Boundary conditions on particle elements.
-
-It also includes several predefined cluster formations to be used.
-
-### DEM strategies
-
-#### Non-cohesive materials strategy
-
-Once contact between two spheres occurs, the forces at the contact point are computed. The interaction between the two contacting spheres can be represented by two forces with the same module but opposite directions. This force F can be decomposed into its normal and shear components Fn and Fs, respectively.
-The contact interface for the simplest formulation is characterized by the normal and tangential stiffness Kn and Ks, respectively, a frictional device obeying the Couloumb law with a frictional coefficient, and a dashpot defined by a contact damping coefficient.
-
-In order to represent irregular particles with spheres, a numerical correction is used. The rolling friction imposes a virtual moment opposite to particle rotation and dependent on its size.
-
-#### Continuum materials strategy
-
-For continuum materials simulations, the contact between particles can resist tractions up to a certain limit, when breakage occurs. Depending on the chosen constitutive law, the computation of the forces changes. In the basic versions, a bond strategy is used, but more advanced laws use a non-local stress-tensor based strategy.
-
-### DEM integration schemes
-
-The standard translational and rotational equations for the motion of rigid bodies are used to compute the dynamics of the spheres and clusters. The following schemes can be chosen separately for translation and rotation:
-
-* Symplectic Euler
-* Velocity Verlet
-* Forward Euler
-* Taylor
-
-Also, two rotational specific integration schemes are available:
-* [Runge-Kutta](https://link.springer.com/article/10.1007/s40571-019-00232-5)
-* Quaternion based
-
-### Contact search
-
-The contact detection basically consists in determining, for every target object, which other objects are in contact with it, and then apply the corresponding interaction. It is usually not needed to perform a search at every time step, which is generally limited by the stability of the explicit integration of the equations of motion.
-A bins based technique is used for this purpose.
-
-## Available interfaces
-
-### DEM
-
-This is the package that allows a user to create, run and analyze results of a DEM simulation for discontinuum / granular / little-cohesive materials. Requires [GiD](https://www.gidhome.com/) - Pre and Post Processing software. It has both 2D and 3D versions. Check the manuals, follow the tutorials or play with the preloaded sample problems in order to learn how this application works.
-
-### Cohesive-DEM
-
-This package combines the features of the previous one also with the simulation of continuum/cohesive materials. It also offers the possibility of tackling both 2D and 3D problems. Check also the manuals or tutorials or load the test examples in the GUI in order to learn how this problem type works.
-
-### Fluid-DEM
-
-This package allows you to simulate a wide spectrum of problems involving the interaction of granular DEM and fluids. This application has only a 3D version. Check also for existing manuals or tutorials to get a feel of how to work with this application.
-
-
-## Contact
-
-* **Miguel Angel Celigueta** - *Core Development* - [maceli@cimne.upc.edu](mailto:maceli@cimne.upc.edu)
-* **Salva Latorre** - *Granular materials* - [latorre@cimne.upc.edu](mailto:latorre@cimne.upc.edu)
-* **Ferran Arrufat** - *Cohesive materials* - [farrufat@cimne.upc.edu](mailto:farrufat@cimne.upc.edu)
-* **Guillermo Casas** - *Fluid coupling* - [gcasas@cimne.upc.edu](mailto:gcasas@cimne.upc.edu)
-* **Joaqun Irazabal** - *Particle clusters & DEM-Solid interaction* - [jirazabal@cimne.upc.edu](mailto:jirazabal@cimne.upc.edu)
-* **Joaqun Gonzlez-Usa** - *Fluid coupling* - [jgonzalez@cimne.upc.edu](mailto:jgonzalez@cimne.upc.edu)
-* **Chengshun Shang** - *Bonded partcile models* - [cshang@cimne.upc.edu](mailto:cshang@cimne.upc.edu)
-
-
-## License
-
-The DEM application is OPEN SOURCE. The main code and program structure is available and aimed to grow with the need of any users willing to expand it. The BSD (Berkeley Software Distribution) licence allows to use and distribute the existing code without any restriction, but with the possibility to develop new parts of the code on an open or close basis depending on the developers.
-
-
-## New GIDInterface for Kratos
-
-The new GIDInterface currently under developement can be found [here](https://github.com/KratosMultiphysics/GiDInterface). Based on the customLib, it includes the interfaces for most of the Kratos applications in addition to the new DEM interface.
-
-
-## FAQ
-
-### What to do if particles behave strangely
-
-* Check the Young Modulus. Materials with high stiffness may require smaller time steps to ensure stability.
-* Check the material density.
-* Check the time step. If the time step is too large, the elements can fail to interact with each other. In the worst case scenarios, the simulation may even crash.
-* Check the frequency of neighbours' search. If the search is not done frequently enough, new contacts may not be detected.
-* Check the restitution coefficient of the material. Explicit integration schemes gain energy noticeably unless an enough small time step is used. If the time step is large (but stable), use the restitution coefficient to compensate for the gain of energy to obtain more realistic results.
+Metadata-Version: 2.1
+Name: KratosDEMApplication
+Version: 9.5.1
+Summary: KRATOS Multiphysics ("Kratos") is a framework for building parallel, multi-disciplinary simulation software, aiming at modularity, extensibility, and high performance. Kratos is written in C++, and counts with an extensive Python interface.
+Home-page: https://github.com/KratosMultiphysics/
+Author: Kratos Team
+Author-email: kratos@listas.cimne.upc.edu
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: C++
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
+Classifier: Topic :: Scientific/Engineering
+Classifier: Topic :: Scientific/Engineering :: Physics
+Classifier: Topic :: Scientific/Engineering :: Mathematics
+Classifier: Natural Language :: English
+Classifier: Intended Audience :: Science/Research
+Classifier: Intended Audience :: Other Audience
+Classifier: Intended Audience :: Developers
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: Environment :: Console
+Classifier: License :: OSI Approved :: BSD License
+Requires-Python: >=3.8
+Description-Content-Type: text/markdown
+Requires-Dist: KratosMultiphysics ==9.5.1
+
+# DEM Application
+
+This application focuses on the Discrete Element Method (DEM), a particles method for modeling the bulk behavior of granular materials and many geomaterials such as coal, ores, soil, rocks, aggregates, pellets, tablets and powders.
+
+The [DEMpack Team](www.cimne.com/dem) at [CIMNE](www.cimne.com) is in charge of all developments related to the DEM.
+
+For the coupling between DEM and Fluids, go to the [Swimming DEM Application](https://github.com/KratosMultiphysics/Kratos/tree/master/applications/SwimmingDEMApplication).
+
+For the coupling between DEM and thermal effects, go to the [Thermal DEM Application](https://github.com/KratosMultiphysics/Kratos/tree/master/applications/ThermalDEMApplication).
+
+## Getting started
+
+This application is part of the Kratos Multiphysics Platform. Instructions on how to get you a copy of the project up and running on your local machine for development and testing purposes are available for both [Linux](http://kratos-wiki.cimne.upc.edu/index.php/LinuxInstall) and [Windows](http://kratos-wiki.cimne.upc.edu/index.php/Windows_7_Download_and_Installation) systems.
+
+### Prerequisites
+
+Build [Kratos](https://github.com/KratosMultiphysics/Kratos/wiki) and, before that, make sure that you add
+
+``` cmake
+-DDEM_APPLICATION=ON
+```
+
+amongst the compilation options, so the DEM application is compiled.
+
+No auxiliar external libraries are needed.
+
+## Theory
+
+The DEM is a numerical method that has been applied to simulate and analyze flow behavior in a wide range of disciplines including mechanical and process engineering, pharmaceutical, materials science, agricultural engineering and more.
+Coupling with fluid is already available through the Swimming-DEM application, also integrated in the Kratos Multiphysics Platform.
+
+The fundamental theoretical background corresponding to the discontinuous (granular matter) part of the code can be found in the DEM literature easily.
+
+### Contact laws
+
+The contact laws are implemented in [this folder](https://github.com/KratosMultiphysics/Kratos/tree/master/applications/DEMApplication/custom_constitutive). Note that the letter 'D' or 'd' in the file name stands for 'discontiuum'. It is related to non cohesive or slightly cohesive contacts.
+
+#### Linear repulsive force
+
+The most simple representation of a repulsive contact force between a sphere and a wall is given by a linear law, where the force acting on the sphere when contacting the wall is a linear function of the indentation, which in turn would bring a quadratic dependence with the contact radius.
+
+#### Non-Linear repulsive force
+
+Hertz solved in 1882 the non-cohesive normal contact between a sphere and a plane. In 1971 Johnson, Kendall and Roberts presented the solution (JKR-Theory) for the same problem in this case adding cohesive behaviour. Not much later, Derjaguin, Mller and Toporov published similar results (DMT-Theory).
+Both theories are very close and correct and, while the JKR theory is adequate to the study of flexible, large spheres, the DMT theory is specially suited to represent the behaviour of rigid, small ones.
+
+## Numerical approach
+
+The application includes two types of DEM elements used for different purposes:
+
+* Spheric Particle - Base element used to simulate granular materials (non cohesive or slightly cohesive)
+* Spheric Continuum Particle - With specific build-in variables to simulate fracture in cohesive materials. It can also be understood as a discretization method of the continuum by using spheres.
+
+And has the following easy-to-use capabilities:
+
+* Interaction with FEM-based walls - Objects that cannot be crossed by DEM spheres. The user can choose to impose Linear-periodic conditions or rigid body conditions.
+* Inlets - Inject new particles while running the simulation linked to some material properties. With user defined granulometry, mass flow and particle type (single particle or clusters). Inlets are based on FEM-based walls and boundary conditions can also be applied to them.
+* Initial conditions on particle elements.
+* Boundary conditions on particle elements.
+
+It also includes several predefined cluster formations to be used.
+
+### DEM strategies
+
+#### Non-cohesive materials strategy
+
+Once contact between two spheres occurs, the forces at the contact point are computed. The interaction between the two contacting spheres can be represented by two forces with the same module but opposite directions. This force F can be decomposed into its normal and shear components Fn and Fs, respectively.
+The contact interface for the simplest formulation is characterized by the normal and tangential stiffness Kn and Ks, respectively, a frictional device obeying the Couloumb law with a frictional coefficient, and a dashpot defined by a contact damping coefficient.
+
+In order to represent irregular particles with spheres, a numerical correction is used. The rolling friction imposes a virtual moment opposite to particle rotation and dependent on its size.
+
+#### Continuum materials strategy
+
+For continuum materials simulations, the contact between particles can resist tractions up to a certain limit, when breakage occurs. Depending on the chosen constitutive law, the computation of the forces changes. In the basic versions, a bond strategy is used, but more advanced laws use a non-local stress-tensor based strategy.
+
+### DEM integration schemes
+
+The standard translational and rotational equations for the motion of rigid bodies are used to compute the dynamics of the spheres and clusters. The following schemes can be chosen separately for translation and rotation:
+
+* Symplectic Euler
+* Velocity Verlet
+* Forward Euler
+* Taylor
+
+Also, two rotational specific integration schemes are available:
+* [Runge-Kutta](https://link.springer.com/article/10.1007/s40571-019-00232-5)
+* Quaternion based
+
+### Contact search
+
+The contact detection basically consists in determining, for every target object, which other objects are in contact with it, and then apply the corresponding interaction. It is usually not needed to perform a search at every time step, which is generally limited by the stability of the explicit integration of the equations of motion.
+A bins based technique is used for this purpose.
+
+## Available interfaces
+
+### DEM
+
+This is the package that allows a user to create, run and analyze results of a DEM simulation for discontinuum / granular / little-cohesive materials. Requires [GiD](https://www.gidhome.com/) - Pre and Post Processing software. It has both 2D and 3D versions. Check the manuals, follow the tutorials or play with the preloaded sample problems in order to learn how this application works.
+
+### Cohesive-DEM
+
+This package combines the features of the previous one also with the simulation of continuum/cohesive materials. It also offers the possibility of tackling both 2D and 3D problems. Check also the manuals or tutorials or load the test examples in the GUI in order to learn how this problem type works.
+
+### Fluid-DEM
+
+This package allows you to simulate a wide spectrum of problems involving the interaction of granular DEM and fluids. This application has only a 3D version. Check also for existing manuals or tutorials to get a feel of how to work with this application.
+
+
+## Contact
+
+* **Miguel Angel Celigueta** - *Core Development* - [maceli@cimne.upc.edu](mailto:maceli@cimne.upc.edu)
+* **Salva Latorre** - *Granular materials* - [latorre@cimne.upc.edu](mailto:latorre@cimne.upc.edu)
+* **Ferran Arrufat** - *Cohesive materials* - [farrufat@cimne.upc.edu](mailto:farrufat@cimne.upc.edu)
+* **Guillermo Casas** - *Fluid coupling* - [gcasas@cimne.upc.edu](mailto:gcasas@cimne.upc.edu)
+* **Joaqun Irazabal** - *Particle clusters & DEM-Solid interaction* - [jirazabal@cimne.upc.edu](mailto:jirazabal@cimne.upc.edu)
+* **Joaqun Gonzlez-Usa** - *Fluid coupling* - [jgonzalez@cimne.upc.edu](mailto:jgonzalez@cimne.upc.edu)
+* **Chengshun Shang** - *Bonded partcile models* - [cshang@cimne.upc.edu](mailto:cshang@cimne.upc.edu)
+
+
+## License
+
+The DEM application is OPEN SOURCE. The main code and program structure is available and aimed to grow with the need of any users willing to expand it. The BSD (Berkeley Software Distribution) licence allows to use and distribute the existing code without any restriction, but with the possibility to develop new parts of the code on an open or close basis depending on the developers.
+
+
+## New GIDInterface for Kratos
+
+The new GIDInterface currently under developement can be found [here](https://github.com/KratosMultiphysics/GiDInterface). Based on the customLib, it includes the interfaces for most of the Kratos applications in addition to the new DEM interface.
+
+
+## FAQ
+
+### What to do if particles behave strangely
+
+* Check the Young Modulus. Materials with high stiffness may require smaller time steps to ensure stability.
+* Check the material density.
+* Check the time step. If the time step is too large, the elements can fail to interact with each other. In the worst case scenarios, the simulation may even crash.
+* Check the frequency of neighbours' search. If the search is not done frequently enough, new contacts may not be detected.
+* Check the restitution coefficient of the material. Explicit integration schemes gain energy noticeably unless an enough small time step is used. If the time step is large (but stable), use the restitution coefficient to compensate for the gain of energy to obtain more realistic results.
```

## Comparing `KratosDEMApplication-9.5.dist-info/RECORD` & `KratosDEMApplication-9.5.1.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,54 +1,54 @@
-KratosDEMApplication-9.5.dist-info/METADATA,sha256=kwopkU2hjjjbiv0fYr241yk0F4IsVIjnWwul6J3QxTU,10815
-KratosDEMApplication-9.5.dist-info/WHEEL,sha256=rY0Y6THYM7EImsHfF-zs67o8pQciAsMw9_YuSvftjrQ,148
-KratosDEMApplication-9.5.dist-info/top_level.txt,sha256=8Ov--opRCptLbHStjyiZUVpzN1OUU_F7c7fGmsR5cMc,19
-KratosDEMApplication-9.5.dist-info/RECORD,,
-KratosDEMApplication.libs/libKratosDEMCore-264e7349.so,sha256=6AIvHEeFxFUYwsdClP9ut1it9LIu7SP7c5CzNSlbrR0,11346777
-KratosMultiphysics/DEMApplication/continuum_sphere_strategy.py,sha256=TGRtQaWgQoRb3fhLtnYrHq9YyT6F6HbfiKNem-PLEKY,7979
-KratosMultiphysics/DEMApplication/concentric_element_size_coarsener.py,sha256=LHgNxbK77bQ9MiONxItTvHn3QhMEeZtBU8mAzu38aug,10222
-KratosMultiphysics/DEMApplication/KratosDEMAnalysis.py,sha256=iBZpr_YmtKdYfjbvH-KgYcixmOnvj5jH5bOVN3Mkf4I,1195
-KratosMultiphysics/DEMApplication/DEM_restart_utility.py,sha256=3K-ZsF-xwe3j777iPHvVMUDplla52_2s8cH2xjjHzcw,2850
-KratosMultiphysics/DEMApplication/cluster_file_reader.py,sha256=ntSrriotPieol7E7G2tAI45YexBOmxM3AQ30BdYVrvk,2654
-KratosMultiphysics/DEMApplication/angle_finder.py,sha256=nqEm3SeljqM6q5_dmLc2du_9MAGXe7-yuT2xfsxXcNY,2165
-KratosMultiphysics/DEMApplication/spreader.py,sha256=6PfAZa9k5eHn01u-e8-qb7zHootwIl8XJ7i7jEgWq24,3883
-KratosMultiphysics/DEMApplication/mesh_creator_cluster.py,sha256=N0NPsIGPZzQRX67mFx1JsVKBa2FqVXvtey9KM1DMilw,4935
-KratosMultiphysics/DEMApplication/mesh_to_mdpa_converter.py,sha256=74dIippbTIUEKoXreoeaBoAmSrGOheMIooTtWxedmxo,5756
-KratosMultiphysics/DEMApplication/materials_assignation_utility.py,sha256=hCT3mMlVEDDFPD2h7zBw6IMCGXFUyfikaBRDdWp6M0o,5312
-KratosMultiphysics/DEMApplication/MPIer.py,sha256=U4xyoV4ls8SjivDWiVj2dq6wcIgqmaXjQ1zBAgP6H2U,2739
-KratosMultiphysics/DEMApplication/dem_default_input_parameters.py,sha256=NeJ1K8SmNM78WkUWnRaGmdr6tnpCIDsNVQXSerI40P8,9954
-KratosMultiphysics/DEMApplication/DEM_procedures_mpi.py,sha256=KgE2akHph0wFjD3IoTjVAYsQ0-hscuip6niDX7qgljs,6492
-KratosMultiphysics/DEMApplication/DEM_procedures_mpi_no_partitions.py,sha256=d7WJzZYuH8qXAAJm8tG0qXq8WxCcyVrhLLySb761mYE,1296
-KratosMultiphysics/DEMApplication/cartesian_specimen_mdpa_creator.py,sha256=sTo2u96OazxwTVpdPiJPA3OcQU4NHron0bHUM8NhuMQ,580
-KratosMultiphysics/DEMApplication/Chung_Ooi_class.py,sha256=bNPHLtcrzKXyvmKIowWKR1Co6QQLXxpA67Js3HoyAJQ,41250
-KratosMultiphysics/DEMApplication/dem_vtk_output.py,sha256=l23NbKs9RqbcN3OUmrnRyfXMcVQEAxKOsuPz7_tObhI,23107
-KratosMultiphysics/DEMApplication/control_module_2d_process.py,sha256=9pWQzGU0V00JMqcfTqLwSsjegXY8_LaIgN-w5vYFV20,1319
-KratosMultiphysics/DEMApplication/DEM_analysis_stage.py,sha256=YwdVhCizx2KsU8GFqW5dqyxqcaOJaEdgkCXDEO3ASEk,54973
-KratosMultiphysics/DEMApplication/DEM_material_test_script.py,sha256=M-MmInAVCWfHNhIZeiPFymhX_zOJhXgAx9wOuxZCq38,36500
-KratosMultiphysics/DEMApplication/DEM_benchmarks_class.py,sha256=2zTdzDH6w0_KxoOPiOmbddAAxyWfr-LaCRCC_ZTus7E,228284
-KratosMultiphysics/DEMApplication/multiaxial_control_module_generalized_2d_utility.py,sha256=8r5vSzPelKJOV2ge9BgBrJsQ1bLnIJbYo4G13A-LO2E,12540
-KratosMultiphysics/DEMApplication/ice_continuum_sphere_strategy.py,sha256=5Nq6E72x-zWZXXFwYLV3zUrFaclLiJYR5OPacw8XRl8,850
-KratosMultiphysics/DEMApplication/plot_variables.py,sha256=YtnXvpEfFwEK5692kS1rCo65T1OcAetxEHh4Fwh_bsQ,5279
-KratosMultiphysics/DEMApplication/time_step_testing_stage.py,sha256=MZWaT7auTDZmhdaK-dW2OLaZddDgbFETGFkYMf3YDhQ,13341
-KratosMultiphysics/DEMApplication/triaxial2d_test.py,sha256=P5Xv8xfCvm5R-vC_bqujqbjf-Tb6r51wDZYssNV43cA,3609
-KratosMultiphysics/DEMApplication/DEM_procedures.py,sha256=UVS4PPIwCT8k5NcoKnxXAdtkwTGWivQ-0288BqH5MKc,98872
-KratosMultiphysics/DEMApplication/automatic_dt_process.py,sha256=PoLx6uZgwzfnbo8t8OYMOHjKYJJurkw2A2HUoElhvAs,802
-KratosMultiphysics/DEMApplication/DEM_inlet_process.py,sha256=nJSyRUJdkfVFES3-ulBGK5GK8tiLb9T2ouYCx2pUjNw,3211
-KratosMultiphysics/DEMApplication/verlet_continuum_sphere_strategy.py,sha256=cDqUfsJniS7vtSeuBp9HXj86nlbFb9Wn9X4vFUaOZVE,4851
-KratosMultiphysics/DEMApplication/__init__.py,sha256=ILsHXkD-jsHUA6J0ceFUedVoBdD5nKCG3ezNtDxvNvI,216
-KratosMultiphysics/DEMApplication/DEM_material_test_script_mpi.py,sha256=PpdrLjOm_By_O7kjnUkZx1cAl3Jg8uzMdD5mvPIff7c,9251
-KratosMultiphysics/DEMApplication/KratosDEM.py,sha256=EoSCwa3wP8l4osJlkC_rfuXHq5gnqPLBCT1DM5HMQ4w,310
-KratosMultiphysics/DEMApplication/DEM_save_restart_process.py,sha256=iObxx3ggZUFdDY6qOo8iLkDGZdgzZY3kqSiSHppWDIA,2190
-KratosMultiphysics/DEMApplication/sphere_strategy.py,sha256=has3CRv1oZE51xIYdIiUVqKJX4lJIjEwZYgUhuEeMMI,39250
-KratosMultiphysics/DEMApplication/mesh_creator_sphere.py,sha256=mOVvw3NXurpwIuEKXlFMwuZVsH5nZayfRjSsHmMMaIA,1511
-KratosMultiphysics/DEMApplication/analytic_tools/analytic_data_procedures.py,sha256=G8D0cgqHDgN03uI77rrVI3IqqJdF_d-uc7m1RTwNz-g,10484
-KratosMultiphysics/DEMApplication/analytic_tools/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/DEMApplication/processes/multiaxial_control_module_generalized_2d_process.py,sha256=EvfjQN8wrSpPUzKzWeAJ-K25T9V-wPB_qRPI4QWH-pM,4621
-KratosMultiphysics/DEMApplication/processes/apply_forces_and_moments_process.py,sha256=KrJtteIaqKZ2I2T4lbYE_gCKNh1uKPHwjfsfJt7QQsg,1429
-KratosMultiphysics/DEMApplication/processes/apply_kinematic_constraints_process.py,sha256=DxsC9PAp1zVeOqWbUh_FA_SR29LEzSN5Agly0ETWc3U,1557
-KratosMultiphysics/DEMApplication/processes/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/DEMApplication/processes/apply_forces_and_moments_to_walls_process.py,sha256=ch72xCocbioK3N_B2C01xjL27fFtuf8YPIGhgP_ZE1U,1451
-KratosMultiphysics/DEMApplication/processes/apply_kinematic_constraints_to_walls_process.py,sha256=uAtOERiNe3HGchvUXlPcbiZ5uBtFZjVz2UAan78XBRQ,1564
-KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_triaxial_test.py,sha256=KdkKfOUAGRMbw6-EtlxDQ2VueC-eJucuaq9ca9s2BpY,28791
-KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_triaxials_and_bts_tests.py,sha256=dVjTFz3q2EfFZ3ELOOzJ6Bf5aeNcrHdXnDeshrbkqbQ,56180
-KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_bts_test.py,sha256=hH7MAeb5NZmzAKYYrJW_d7xl8vQ5z-4oX4QZ_-jAKeY,24298
-KratosMultiphysics/.libs/KratosDEMApplication.cpython-39-x86_64-linux-gnu.so,sha256=KPNVhoX9gxbfbSo35v8cfW0VgwhMWiyZ_0ta-zS-PkU,4023577
-KratosMultiphysics/.libs/libKratosDEMCore.so,sha256=MHVbHC7J1aocyrWz83vpj3pr1CL50J-CNluc12JNBV4,10728921
+KratosMultiphysics/.libs/KratosDEMApplication.pyd,sha256=oD_Vk9JyLW-11LJVJ-OLQgoUIW7BmYKQ8GmIku3gS3o,1500160
+KratosMultiphysics/.libs/KratosDEMCore.dll,sha256=RdSOBGbWx9kzzkr0Ob_z1aVePJqQbTP7D0ulNdiJ9Z4,3772928
+KratosMultiphysics/.libs/KratosDEMCore.lib,sha256=UyfUjJ6-xxiknC_-4dXS1uaKwhWmD2JOSNEFIIDkIc0,1317282
+KratosMultiphysics/DEMApplication/Chung_Ooi_class.py,sha256=AI_mDsC7-HCZiG64cMr098vG2lkyliwNvR-77mWcewY,42099
+KratosMultiphysics/DEMApplication/DEM_analysis_stage.py,sha256=7etdS-LPcnmaKAXaP83407exRQphTDvi2jwfSFt69MY,56120
+KratosMultiphysics/DEMApplication/DEM_benchmarks_class.py,sha256=AndSQ7V0W9fQWcv0o_ZaAMgUJlEkpDQEfWpZ5P0ODko,233222
+KratosMultiphysics/DEMApplication/DEM_inlet_process.py,sha256=9Gd1uqEvlb5yxQQ6Vi4KYB52EL9-6BEZ9G-gd_d9QsI,3275
+KratosMultiphysics/DEMApplication/DEM_material_test_script.py,sha256=FBr5Ty3j9C5JRk5bNxTrbUNfug8F1IpE9kvztU9deoI,37379
+KratosMultiphysics/DEMApplication/DEM_material_test_script_mpi.py,sha256=P4_QO7cEWWgQs4gG8L0-IuEzdfTysrti5NWAZ8zarWo,9503
+KratosMultiphysics/DEMApplication/DEM_procedures.py,sha256=q7F67u-PfX4WLu2bDgOthZsVk9Q6_pO3UzVbM0FqIlk,100799
+KratosMultiphysics/DEMApplication/DEM_procedures_mpi.py,sha256=1E2O5CSoX2yyzaPsRN5UxF46nPDODeghsUIidUgzUSI,6680
+KratosMultiphysics/DEMApplication/DEM_procedures_mpi_no_partitions.py,sha256=Xe52xy42j5MZ7ZuC_rJnb_VA1ciBOHaVI6Qgq0Je8Cw,1328
+KratosMultiphysics/DEMApplication/DEM_restart_utility.py,sha256=SHmBm-Rmwm63wTVc45mEMxyuJb_oIbW-XAl5gN5p4uI,2914
+KratosMultiphysics/DEMApplication/DEM_save_restart_process.py,sha256=smKCpOUapUK2x9Kko2RpOkCUojCPimMZBufYuYuTlB4,2235
+KratosMultiphysics/DEMApplication/KratosDEM.py,sha256=FXfPUyo8trSbPK3xoaec0lrsZ1NKSUrIzllVfnCivkM,320
+KratosMultiphysics/DEMApplication/KratosDEMAnalysis.py,sha256=jNZJgiJbdaM7KNw2LT5TelZyFGwQQXxngYbersL9sy0,1229
+KratosMultiphysics/DEMApplication/MPIer.py,sha256=g1UzUyprRvnIv1wdf5vlL3Kdo1epNrUqpC-ZOCR8tXA,2821
+KratosMultiphysics/DEMApplication/__init__.py,sha256=kcNmGG3cK0Kqw48Q54XtM8YnvEPHjhTzr7z_vJmQ5qM,223
+KratosMultiphysics/DEMApplication/angle_finder.py,sha256=VRPZpylakya5a3rnWeqVLrVI8sb39i8xVq7NWlLiN_4,2220
+KratosMultiphysics/DEMApplication/automatic_dt_process.py,sha256=8LSgHKcGJwfx6J8tTAGePbAfeYwbpwAJYBYPDPB7Avc,820
+KratosMultiphysics/DEMApplication/cartesian_specimen_mdpa_creator.py,sha256=T_Y52QOjB7hsTpQiROVPBwgzomDFar27WYsqV1baeXw,592
+KratosMultiphysics/DEMApplication/cluster_file_reader.py,sha256=2qNgBTc4ajS7ZerZaB0DwgzWk-wThbLVI47YlAEu_9I,2728
+KratosMultiphysics/DEMApplication/concentric_element_size_coarsener.py,sha256=wVlSBBshUzk5st9koLe_UypYx25XiI3AJ8V_Z1T6vME,10399
+KratosMultiphysics/DEMApplication/continuum_sphere_strategy.py,sha256=TGRtQaWgQoRb3fhLtnYrHq9YyT6F6HbfiKNem-PLEKY,7979
+KratosMultiphysics/DEMApplication/control_module_2d_process.py,sha256=Wmb0qIy_jG5XVgHlvV131qc2_rferRiBdHu6c924Ce8,1347
+KratosMultiphysics/DEMApplication/dem_default_input_parameters.py,sha256=Tp2eaRzbKf5q8boiU4oYrKj5cgiB2isfboHAtZeUqs4,10145
+KratosMultiphysics/DEMApplication/dem_vtk_output.py,sha256=rKCwVr8P-brnkRu63p8w3wHtvWwN7gkYEYjVjxGx4WM,23563
+KratosMultiphysics/DEMApplication/ice_continuum_sphere_strategy.py,sha256=j2o8Z1UZwlcVdsvngQA-YUJ27dreBfLzEuc377wR_44,875
+KratosMultiphysics/DEMApplication/materials_assignation_utility.py,sha256=dM6vsEEsAZWqbt1felZHNybtSROjw8tuLO2Gqt91ilg,5407
+KratosMultiphysics/DEMApplication/mesh_creator_cluster.py,sha256=I6KkeqSRimhPJW2QcrVAp_1sWZopEYlBFv9bNM1NQiw,5056
+KratosMultiphysics/DEMApplication/mesh_creator_sphere.py,sha256=DpF-OFQfrKUXFnCrtgFLL3FnOlmNTCFsj9yfDSyTelk,1547
+KratosMultiphysics/DEMApplication/mesh_to_mdpa_converter.py,sha256=ypMGnAO3zEz3V-z6r2SgqdbiAJrmz7ddrcSc6eLXzmo,5948
+KratosMultiphysics/DEMApplication/multiaxial_control_module_generalized_2d_utility.py,sha256=8r5vSzPelKJOV2ge9BgBrJsQ1bLnIJbYo4G13A-LO2E,12540
+KratosMultiphysics/DEMApplication/plot_variables.py,sha256=_FZc6KWFd9dFDDqYgCsqYc4NRw9Ab9xfnbtSjU_2szU,5408
+KratosMultiphysics/DEMApplication/sphere_strategy.py,sha256=RG884DxwaOPvbeOsFTSdJhKaHQ3REwxRp1xof5uDZVo,40051
+KratosMultiphysics/DEMApplication/spreader.py,sha256=eQCwhH8RjCYva5yecByVzy9bSQXf67G0wtN1yC1xcFQ,3978
+KratosMultiphysics/DEMApplication/time_step_testing_stage.py,sha256=t1JYMlFnp_w96aVsLXBsBD90xthsYPWNiWoofqpYzJI,13624
+KratosMultiphysics/DEMApplication/triaxial2d_test.py,sha256=UR0I73jB5yKp9rx33IxWst6yrDnaKLEpTR7_TpoU7AI,3709
+KratosMultiphysics/DEMApplication/verlet_continuum_sphere_strategy.py,sha256=j3iLYujDdMtezlo2jDLnC99kZhbD-aM4Am4qn3qeSZ8,4939
+KratosMultiphysics/DEMApplication/analytic_tools/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/DEMApplication/analytic_tools/analytic_data_procedures.py,sha256=4QMFUKhBzSzjjl7Vpym9_3I0tWcQJ1cq-06mISC_LXk,10743
+KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_bts_test.py,sha256=ehkxgQH9cfOY43sirRelskv-Flf7aIUkPdRJwA3SAmA,24844
+KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_triaxial_test.py,sha256=DLfwHThCcavgC7BJPoIpdElA7T0TSzksihMPYp86a5Y,29425
+KratosMultiphysics/DEMApplication/custom_material_tests/decompressed_material_triaxials_and_bts_tests.py,sha256=zHxpVEpix5g2EbAi65TRW88lXArCAfNQJqd5KpETEvs,57414
+KratosMultiphysics/DEMApplication/processes/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/DEMApplication/processes/apply_forces_and_moments_process.py,sha256=IEHrlrSMMDAyzTjtdnvNCBNpdceS0qFBL3ws7IKwp7U,1467
+KratosMultiphysics/DEMApplication/processes/apply_forces_and_moments_to_walls_process.py,sha256=SkDouOiUc6z8E9beHnngZTOE71Udr84Kv3rvHxcrG4k,1489
+KratosMultiphysics/DEMApplication/processes/apply_kinematic_constraints_process.py,sha256=t-L3SW3-9bSplUZTgB5MRUHA1Go0GupOGSxUaAZglWU,1599
+KratosMultiphysics/DEMApplication/processes/apply_kinematic_constraints_to_walls_process.py,sha256=t2WMZvzL-cg03Kw6RyHKlT2z_xi7W3vjvhSuazRwE_I,1606
+KratosMultiphysics/DEMApplication/processes/multiaxial_control_module_generalized_2d_process.py,sha256=roDlQgn7GgVM8Jj0a5dD8VdfOjrnTl71qL-LEIUQYkw,4731
+KratosDEMApplication-9.5.1.dist-info/METADATA,sha256=wxM4UsKXWxXJzxsbhb8hlBYtuIRGNapaXn5ET8W4F3U,11037
+KratosDEMApplication-9.5.1.dist-info/WHEEL,sha256=GZFS91_ufm4WrNPBaFVPB9MvOXR6bMZQhPcZRRTN5YM,100
+KratosDEMApplication-9.5.1.dist-info/top_level.txt,sha256=8Ov--opRCptLbHStjyiZUVpzN1OUU_F7c7fGmsR5cMc,19
+KratosDEMApplication-9.5.1.dist-info/RECORD,,
```


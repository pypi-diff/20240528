# Comparing `tmp/KratosCoSimulationApplication-9.5-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip` & `tmp/KratosCoSimulationApplication-9.5.1-cp39-cp39-win_amd64.whl.zip`

## zipinfo -v {}

 * *Differences in extra fields detected; using output from zipinfo -v*

```diff
@@ -1,5085 +1,3439 @@
 There is no zipfile comment.
 
 End-of-central-directory record:
 -------------------------------
 
-  Zip archive file size:                   2730503 (000000000029AA07h)
-  Actual end-cent-dir record offset:       2730481 (000000000029A9F1h)
-  Expected end-cent-dir record offset:     2730481 (000000000029A9F1h)
+  Zip archive file size:                    991289 (00000000000F2039h)
+  Actual end-cent-dir record offset:        991267 (00000000000F2023h)
+  Expected end-cent-dir record offset:      991267 (00000000000F2023h)
   (based on the length of the central directory and its expected offset)
 
   This zipfile constitutes the sole disk of a single-part archive; its
-  central directory contains 138 entries.
-  The central directory is 20184 (0000000000004ED8h) bytes long,
+  central directory contains 118 entries.
+  The central directory is 14785 (00000000000039C1h) bytes long,
   and its (expected) offset in bytes from the beginning of the zipfile
-  is 2710297 (0000000000295B19h).
+  is 976482 (00000000000EE662h).
 
 
 Central directory entry #1:
 ---------------------------
 
-  KratosCoSimulationApplication-9.5.dist-info/
+  KratosMultiphysics/.libs/KratosCoSimulationApplication.pyd
 
   offset of local header from start of archive:   0
                                                   (0000000000000000h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:48
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:47 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:47 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             44 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:28
+  32-bit CRC value (hex):                         0645dbbd
+  compressed size:                                266389 bytes
+  uncompressed size:                              750592 bytes
+  length of filename:                             58 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #2:
 ---------------------------
 
-  KratosCoSimulationApplication-9.5.dist-info/METADATA
+  KratosMultiphysics/.libs/KratosCoSimulationCore.dll
 
-  offset of local header from start of archive:   102
-                                                  (0000000000000066h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   266477
+                                                  (00000000000410EDh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         2d4c28e9
-  compressed size:                                7397 bytes
-  uncompressed size:                              26173 bytes
-  length of filename:                             52 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:28
+  32-bit CRC value (hex):                         a7448a06
+  compressed size:                                295139 bytes
+  uncompressed size:                              910336 bytes
+  length of filename:                             51 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #3:
 ---------------------------
 
-  KratosCoSimulationApplication-9.5.dist-info/WHEEL
+  KratosMultiphysics/.libs/KratosCoSimulationCore.lib
 
-  offset of local header from start of archive:   7609
-                                                  (0000000000001DB9h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   561697
+                                                  (0000000000089221h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         90d34e0d
-  compressed size:                                116 bytes
-  uncompressed size:                              148 bytes
-  length of filename:                             49 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:28
+  32-bit CRC value (hex):                         6decca30
+  compressed size:                                5647 bytes
+  uncompressed size:                              121802 bytes
+  length of filename:                             51 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #4:
 ---------------------------
 
-  KratosCoSimulationApplication-9.5.dist-info/top_level.txt
+  KratosMultiphysics/.libs/co_sim_io.dll
 
-  offset of local header from start of archive:   7832
-                                                  (0000000000001E98h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   567425
+                                                  (000000000008A881h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         f32d789f
-  compressed size:                                19 bytes
-  uncompressed size:                              19 bytes
-  length of filename:                             57 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:28
+  32-bit CRC value (hex):                         db0070ba
+  compressed size:                                267622 bytes
+  uncompressed size:                              755200 bytes
+  length of filename:                             38 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #5:
 ---------------------------
 
-  KratosCoSimulationApplication-9.5.dist-info/RECORD
+  KratosMultiphysics/.libs/co_sim_io.lib
 
-  offset of local header from start of archive:   7966
-                                                  (0000000000001F1Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   835115
+                                                  (00000000000CBE2Bh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:48
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:47 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:47 UTC
-  32-bit CRC value (hex):                         49182d95
-  compressed size:                                5396 bytes
-  uncompressed size:                              16176 bytes
-  length of filename:                             50 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:28
+  32-bit CRC value (hex):                         4d6d2910
+  compressed size:                                21388 bytes
+  uncompressed size:                              207786 bytes
+  length of filename:                             38 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100664 octal):            -rw-rw-r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #6:
 ---------------------------
 
-  KratosCoSimulationApplication.libs/
+  KratosMultiphysics/CoSimulationApplication/MainKratosCoSim.py
 
-  offset of local header from start of archive:   13470
-                                                  (000000000000349Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   856571
+                                                  (00000000000D11FBh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:48
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:47 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:47 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             35 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         eb741b30
+  compressed size:                                304 bytes
+  uncompressed size:                              586 bytes
+  length of filename:                             61 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #7:
 ---------------------------
 
-  KratosCoSimulationApplication.libs/libKratosCoSimulationCore-6b309626.so
+  KratosMultiphysics/CoSimulationApplication/__init__.py
 
-  offset of local header from start of archive:   13563
-                                                  (00000000000034FBh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   856966
+                                                  (00000000000D1386h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         6cd931cb
-  compressed size:                                1048535 bytes
-  uncompressed size:                              4010777 bytes
-  length of filename:                             72 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         a7bdbe3a
+  compressed size:                                452 bytes
+  uncompressed size:                              1008 bytes
+  length of filename:                             54 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100755 octal):            -rwxr-xr-x
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #8:
 ---------------------------
 
-  KratosCoSimulationApplication.libs/libco_sim_io-da5c66c6.so
+  KratosMultiphysics/CoSimulationApplication/analysis_stage_with_co_sim_io.py
 
-  offset of local header from start of archive:   1062228
-                                                  (0000000000103554h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   857502
+                                                  (00000000000D159Eh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         76e2d11a
-  compressed size:                                781351 bytes
-  uncompressed size:                              2801145 bytes
-  length of filename:                             59 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         c9e4ea4f
+  compressed size:                                1380 bytes
+  uncompressed size:                              6006 bytes
+  length of filename:                             75 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100755 octal):            -rwxr-xr-x
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #9:
 ---------------------------
 
-  KratosMultiphysics/
+  KratosMultiphysics/CoSimulationApplication/co_simulation_analysis.py
 
-  offset of local header from start of archive:   1843696
-                                                  (00000000001C21F0h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   858987
+                                                  (00000000000D1B6Bh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             19 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         cce540f7
+  compressed size:                                1606 bytes
+  uncompressed size:                              5253 bytes
+  length of filename:                             68 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #10:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/
+  KratosMultiphysics/CoSimulationApplication/co_simulation_tools.py
 
-  offset of local header from start of archive:   1843773
-                                                  (00000000001C223Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   860691
+                                                  (00000000000D2213h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             43 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         e4a7fa58
+  compressed size:                                329 bytes
+  uncompressed size:                              650 bytes
+  length of filename:                             65 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #11:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/processes/
+  KratosMultiphysics/CoSimulationApplication/colors.py
 
-  offset of local header from start of archive:   1843874
-                                                  (00000000001C22A2h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   861115
+                                                  (00000000000D23BBh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             53 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         16ee3f52
+  compressed size:                                558 bytes
+  uncompressed size:                              2351 bytes
+  length of filename:                             52 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #12:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/processes/create_point_based_entites_process.py
+  KratosMultiphysics/CoSimulationApplication/coupling_interface_data.py
 
-  offset of local header from start of archive:   1843985
-                                                  (00000000001C2311h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   861755
+                                                  (00000000000D263Bh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         e482152c
-  compressed size:                                1887 bytes
-  uncompressed size:                              5919 bytes
-  length of filename:                             90 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         4d02e90a
+  compressed size:                                3045 bytes
+  uncompressed size:                              13186 bytes
+  length of filename:                             69 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #13:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/processes/__init__.py
+  KratosMultiphysics/CoSimulationApplication/empire_wrapper.py
 
-  offset of local header from start of archive:   1846020
-                                                  (00000000001C2B04h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  offset of local header from start of archive:   864899
+                                                  (00000000000D3283h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             64 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         452cb6d9
+  compressed size:                                4389 bytes
+  uncompressed size:                              28834 bytes
+  length of filename:                             60 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #14:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/predictors/
+  KratosMultiphysics/CoSimulationApplication/fluid_dynamics_analysis_with_co_sim_io.py
 
-  offset of local header from start of archive:   1846142
-                                                  (00000000001C2B7Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   869378
+                                                  (00000000000D4402h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             54 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         547f55a0
+  compressed size:                                407 bytes
+  uncompressed size:                              931 bytes
+  length of filename:                             84 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #15:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/predictors/average_value_based.py
+  KratosMultiphysics/CoSimulationApplication/function_callback_utility.py
 
-  offset of local header from start of archive:   1846254
-                                                  (00000000001C2BEEh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   869899
+                                                  (00000000000D460Bh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         5915f0d9
-  compressed size:                                741 bytes
-  uncompressed size:                              1928 bytes
-  length of filename:                             76 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         80d263f5
+  compressed size:                                691 bytes
+  uncompressed size:                              1538 bytes
+  length of filename:                             71 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #16:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/predictors/linear_derivative_based.py
+  KratosMultiphysics/CoSimulationApplication/structural_mechanics_analysis_with_co_sim_io.py
 
-  offset of local header from start of archive:   1847129
-                                                  (00000000001C2F59h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   870691
+                                                  (00000000000D4923h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         76d8bee8
-  compressed size:                                575 bytes
-  uncompressed size:                              1468 bytes
-  length of filename:                             80 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         f972c11c
+  compressed size:                                414 bytes
+  uncompressed size:                              975 bytes
+  length of filename:                             90 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #17:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/predictors/linear.py
+  KratosMultiphysics/CoSimulationApplication/base_classes/__init__.py
 
-  offset of local header from start of archive:   1847842
-                                                  (00000000001C3222h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   871225
+                                                  (00000000000D4B39h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         7c251b1f
-  compressed size:                                313 bytes
-  uncompressed size:                              719 bytes
-  length of filename:                             63 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                2 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             67 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #18:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/predictors/__init__.py
+  KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_convergence_accelerator.py
 
-  offset of local header from start of archive:   1848276
-                                                  (00000000001C33D4h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  offset of local header from start of archive:   871324
+                                                  (00000000000D4B9Ch) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             65 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         3ef3df84
+  compressed size:                                867 bytes
+  uncompressed size:                              2298 bytes
+  length of filename:                             96 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #19:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/MainKratosCoSim.py
+  KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_convergence_criteria.py
 
-  offset of local header from start of archive:   1848399
-                                                  (00000000001C344Fh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   872317
+                                                  (00000000000D4F7Dh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         8d39b52f
-  compressed size:                                297 bytes
-  uncompressed size:                              571 bytes
-  length of filename:                             61 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         ad8d2850
+  compressed size:                                615 bytes
+  uncompressed size:                              1726 bytes
+  length of filename:                             93 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #20:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/colors.py
+  KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_coupled_solver.py
 
-  offset of local header from start of archive:   1848815
-                                                  (00000000001C35EFh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   873055
+                                                  (00000000000D525Fh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         f5529ac0
-  compressed size:                                551 bytes
-  uncompressed size:                              2273 bytes
-  length of filename:                             52 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         9faa6ffe
+  compressed size:                                3878 bytes
+  uncompressed size:                              19041 bytes
+  length of filename:                             87 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #21:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/convergence_criteria/
+  KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_coupling_operation.py
 
-  offset of local header from start of archive:   1849476
-                                                  (00000000001C3884h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   877050
+                                                  (00000000000D61FAh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             64 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         7022a44a
+  compressed size:                                620 bytes
+  uncompressed size:                              1688 bytes
+  length of filename:                             91 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #22:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/convergence_criteria/convergence_criteria_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_data_transfer_operator.py
 
-  offset of local header from start of archive:   1849598
-                                                  (00000000001C38FEh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   877791
+                                                  (00000000000D64DFh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         1f58b48a
-  compressed size:                                1022 bytes
-  uncompressed size:                              3457 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         f525573f
+  compressed size:                                1077 bytes
+  uncompressed size:                              3182 bytes
   length of filename:                             95 characters
-  length of extra field:                          24 bytes
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #23:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/convergence_criteria/relative_norm_previous_residual.py
+  KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_io.py
 
-  offset of local header from start of archive:   1850773
-                                                  (00000000001C3D95h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   878993
+                                                  (00000000000D6991h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         4fff686a
-  compressed size:                                808 bytes
-  uncompressed size:                              2402 bytes
-  length of filename:                             98 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         bd73f75a
+  compressed size:                                774 bytes
+  uncompressed size:                              2741 bytes
+  length of filename:                             75 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #24:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/convergence_criteria/relative_norm_initial_residual.py
+  KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_predictor.py
 
-  offset of local header from start of archive:   1851737
-                                                  (00000000001C4159h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   879872
+                                                  (00000000000D6D00h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         d43fd9b4
-  compressed size:                                800 bytes
-  uncompressed size:                              2432 bytes
-  length of filename:                             97 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         03edc1ba
+  compressed size:                                781 bytes
+  uncompressed size:                              2194 bytes
+  length of filename:                             82 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #25:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/convergence_criteria/absolute_norm_energy_conjugate.py
+  KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_solver_wrapper.py
 
-  offset of local header from start of archive:   1852692
-                                                  (00000000001C4514h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   880765
+                                                  (00000000000D707Dh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         83df62ca
-  compressed size:                                1613 bytes
-  uncompressed size:                              5509 bytes
-  length of filename:                             97 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         f1d3d238
+  compressed size:                                2180 bytes
+  uncompressed size:                              7665 bytes
+  length of filename:                             87 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #26:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/convergence_criteria/__init__.py
+  KratosMultiphysics/CoSimulationApplication/convergence_accelerators/__init__.py
 
-  offset of local header from start of archive:   1854460
-                                                  (00000000001C4BFCh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  offset of local header from start of archive:   883062
+                                                  (00000000000D7976h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
   32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
+  compressed size:                                2 bytes
   uncompressed size:                              0 bytes
-  length of filename:                             75 characters
-  length of extra field:                          24 bytes
+  length of filename:                             79 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #27:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/base_classes/
+  KratosMultiphysics/CoSimulationApplication/convergence_accelerators/aitken.py
 
-  offset of local header from start of archive:   1854593
-                                                  (00000000001C4C81h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   883173
+                                                  (00000000000D79E5h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             56 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         40930132
+  compressed size:                                1163 bytes
+  uncompressed size:                              3704 bytes
+  length of filename:                             77 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #28:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_convergence_accelerator.py
+  KratosMultiphysics/CoSimulationApplication/convergence_accelerators/anderson.py
 
-  offset of local header from start of archive:   1854707
-                                                  (00000000001C4CF3h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   884443
+                                                  (00000000000D7EDBh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         b6236f4e
-  compressed size:                                859 bytes
-  uncompressed size:                              2232 bytes
-  length of filename:                             96 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         8426627f
+  compressed size:                                1313 bytes
+  uncompressed size:                              3956 bytes
+  length of filename:                             79 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #29:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_coupled_solver.py
+  KratosMultiphysics/CoSimulationApplication/convergence_accelerators/constant_relaxation.py
 
-  offset of local header from start of archive:   1855720
-                                                  (00000000001C50E8h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   885865
+                                                  (00000000000D8469h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         7e74d29d
-  compressed size:                                3855 bytes
-  uncompressed size:                              18602 bytes
-  length of filename:                             87 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         55c86f5f
+  compressed size:                                600 bytes
+  uncompressed size:                              1487 bytes
+  length of filename:                             90 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #30:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_coupling_operation.py
+  KratosMultiphysics/CoSimulationApplication/convergence_accelerators/convergence_accelerator_wrapper.py
 
-  offset of local header from start of archive:   1859720
-                                                  (00000000001C6088h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   886585
+                                                  (00000000000D8739h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         008946c0
-  compressed size:                                611 bytes
-  uncompressed size:                              1628 bytes
-  length of filename:                             91 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         e852ba04
+  compressed size:                                1433 bytes
+  uncompressed size:                              6070 bytes
+  length of filename:                             102 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #31:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_data_transfer_operator.py
+  KratosMultiphysics/CoSimulationApplication/convergence_accelerators/iqnils.py
 
-  offset of local header from start of archive:   1860480
-                                                  (00000000001C6380h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   888150
+                                                  (00000000000D8D56h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         32b3ee10
-  compressed size:                                1064 bytes
-  uncompressed size:                              3115 bytes
-  length of filename:                             95 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         cc25a1f4
+  compressed size:                                1889 bytes
+  uncompressed size:                              7762 bytes
+  length of filename:                             77 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #32:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_convergence_criteria.py
+  KratosMultiphysics/CoSimulationApplication/convergence_accelerators/mvqn.py
 
-  offset of local header from start of archive:   1861697
-                                                  (00000000001C6841h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   890146
+                                                  (00000000000D9522h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         b388ff42
-  compressed size:                                605 bytes
-  uncompressed size:                              1670 bytes
-  length of filename:                             93 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         3ef28f60
+  compressed size:                                1590 bytes
+  uncompressed size:                              4328 bytes
+  length of filename:                             75 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #33:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_io.py
+  KratosMultiphysics/CoSimulationApplication/convergence_criteria/__init__.py
 
-  offset of local header from start of archive:   1862453
-                                                  (00000000001C6B35h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   891841
+                                                  (00000000000D9BC1h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         263c870a
-  compressed size:                                764 bytes
-  uncompressed size:                              2668 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                2 bytes
+  uncompressed size:                              0 bytes
   length of filename:                             75 characters
-  length of extra field:                          24 bytes
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #34:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_predictor.py
+  KratosMultiphysics/CoSimulationApplication/convergence_criteria/absolute_norm_energy_conjugate.py
 
-  offset of local header from start of archive:   1863350
-                                                  (00000000001C6EB6h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   891948
+                                                  (00000000000D9C2Ch) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         b9adf41f
-  compressed size:                                774 bytes
-  uncompressed size:                              2126 bytes
-  length of filename:                             82 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         e16e048c
+  compressed size:                                1627 bytes
+  uncompressed size:                              5641 bytes
+  length of filename:                             97 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #35:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_solver_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/convergence_criteria/convergence_criteria_wrapper.py
 
-  offset of local header from start of archive:   1864264
-                                                  (00000000001C7248h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   893702
+                                                  (00000000000DA306h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         22affe11
-  compressed size:                                2165 bytes
-  uncompressed size:                              7497 bytes
-  length of filename:                             87 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         c224112c
+  compressed size:                                1030 bytes
+  uncompressed size:                              3542 bytes
+  length of filename:                             95 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #36:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/base_classes/__init__.py
+  KratosMultiphysics/CoSimulationApplication/convergence_criteria/relative_norm_initial_residual.py
 
-  offset of local header from start of archive:   1866574
-                                                  (00000000001C7B4Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  offset of local header from start of archive:   894857
+                                                  (00000000000DA789h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             67 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         439816d3
+  compressed size:                                812 bytes
+  uncompressed size:                              2506 bytes
+  length of filename:                             97 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #37:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/analysis_stage_with_co_sim_io.py
+  KratosMultiphysics/CoSimulationApplication/convergence_criteria/relative_norm_previous_residual.py
 
-  offset of local header from start of archive:   1866699
-                                                  (00000000001C7BCBh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   895796
+                                                  (00000000000DAB34h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         7cddbd6d
-  compressed size:                                1369 bytes
-  uncompressed size:                              5870 bytes
-  length of filename:                             75 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         88780de0
+  compressed size:                                818 bytes
+  uncompressed size:                              2474 bytes
+  length of filename:                             98 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #38:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/function_callback_utility.py
+  KratosMultiphysics/CoSimulationApplication/coupled_solvers/__init__.py
 
-  offset of local header from start of archive:   1868201
-                                                  (00000000001C81A9h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   896742
+                                                  (00000000000DAEE6h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         52fbc228
-  compressed size:                                681 bytes
-  uncompressed size:                              1497 bytes
-  length of filename:                             71 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                2 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             70 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #39:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/structural_mechanics_analysis_with_co_sim_io.py
+  KratosMultiphysics/CoSimulationApplication/coupled_solvers/feti_dynamic_coupled_solver.py
 
-  offset of local header from start of archive:   1869011
-                                                  (00000000001C84D3h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   896844
+                                                  (00000000000DAF4Ch) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         58014928
-  compressed size:                                408 bytes
-  uncompressed size:                              952 bytes
-  length of filename:                             90 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         f39305af
+  compressed size:                                3202 bytes
+  uncompressed size:                              13897 bytes
+  length of filename:                             89 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #40:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/co_simulation_analysis.py
+  KratosMultiphysics/CoSimulationApplication/coupled_solvers/gauss_seidel_strong.py
 
-  offset of local header from start of archive:   1869567
-                                                  (00000000001C86FFh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   900165
+                                                  (00000000000DBC45h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         06d0e829
-  compressed size:                                1591 bytes
-  uncompressed size:                              5120 bytes
-  length of filename:                             68 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         a0055ba4
+  compressed size:                                1412 bytes
+  uncompressed size:                              6311 bytes
+  length of filename:                             81 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #41:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/coupling_operations/
+  KratosMultiphysics/CoSimulationApplication/coupled_solvers/gauss_seidel_weak.py
 
-  offset of local header from start of archive:   1871284
-                                                  (00000000001C8DB4h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   901688
+                                                  (00000000000DC238h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             63 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         97a78145
+  compressed size:                                318 bytes
+  uncompressed size:                              854 bytes
+  length of filename:                             79 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #42:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/coupling_operations/print_iteration_number.py
+  KratosMultiphysics/CoSimulationApplication/coupled_solvers/jacobi_strong.py
 
-  offset of local header from start of archive:   1871405
-                                                  (00000000001C8E2Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   902115
+                                                  (00000000000DC3E3h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         96662865
-  compressed size:                                1089 bytes
-  uncompressed size:                              3300 bytes
-  length of filename:                             88 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         e20d8cf2
+  compressed size:                                1352 bytes
+  uncompressed size:                              6230 bytes
+  length of filename:                             75 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #43:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/coupling_operations/compute_boundary_force.py
+  KratosMultiphysics/CoSimulationApplication/coupled_solvers/jacobi_weak.py
 
-  offset of local header from start of archive:   1872640
-                                                  (00000000001C9300h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   903572
+                                                  (00000000000DC994h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         18803f59
-  compressed size:                                1968 bytes
-  uncompressed size:                              6537 bytes
-  length of filename:                             88 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         53ac37e4
+  compressed size:                                316 bytes
+  uncompressed size:                              980 bytes
+  length of filename:                             73 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #44:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/coupling_operations/distribute_point_values.py
+  KratosMultiphysics/CoSimulationApplication/coupling_operations/__init__.py
 
-  offset of local header from start of archive:   1874754
-                                                  (00000000001C9B42h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   903991
+                                                  (00000000000DCB37h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         6c4d1fae
-  compressed size:                                1208 bytes
-  uncompressed size:                              4774 bytes
-  length of filename:                             89 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                2 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             74 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #45:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/coupling_operations/convert_distributed_values_to_point.py
+  KratosMultiphysics/CoSimulationApplication/coupling_operations/compute_boundary_force.py
 
-  offset of local header from start of archive:   1876109
-                                                  (00000000001CA08Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   904097
+                                                  (00000000000DCBA1h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         7dab0eeb
-  compressed size:                                1144 bytes
-  uncompressed size:                              4424 bytes
-  length of filename:                             101 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         09c2c5de
+  compressed size:                                1978 bytes
+  uncompressed size:                              6676 bytes
+  length of filename:                             88 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #46:
 ---------------------------
 
   KratosMultiphysics/CoSimulationApplication/coupling_operations/compute_normals.py
 
-  offset of local header from start of archive:   1877412
-                                                  (00000000001CA5A4h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   906193
+                                                  (00000000000DD3D1h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         5827c28c
-  compressed size:                                676 bytes
-  uncompressed size:                              1810 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         21025e64
+  compressed size:                                687 bytes
+  uncompressed size:                              1870 bytes
   length of filename:                             81 characters
-  length of extra field:                          24 bytes
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #47:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/coupling_operations/coupling_output.py
+  KratosMultiphysics/CoSimulationApplication/coupling_operations/convert_distributed_values_to_point.py
 
-  offset of local header from start of archive:   1878227
-                                                  (00000000001CA8D3h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   906991
+                                                  (00000000000DD6EFh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         bcf87764
-  compressed size:                                978 bytes
-  uncompressed size:                              3409 bytes
-  length of filename:                             81 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         64dc053a
+  compressed size:                                1157 bytes
+  uncompressed size:                              4497 bytes
+  length of filename:                             101 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #48:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/coupling_operations/elemental_data_to_nodal_data.py
+  KratosMultiphysics/CoSimulationApplication/coupling_operations/coupling_output.py
 
-  offset of local header from start of archive:   1879344
-                                                  (00000000001CAD30h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   908279
+                                                  (00000000000DDBF7h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         8b20b493
-  compressed size:                                833 bytes
-  uncompressed size:                              2242 bytes
-  length of filename:                             94 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         9c74d7ae
+  compressed size:                                987 bytes
+  uncompressed size:                              3485 bytes
+  length of filename:                             81 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #49:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/coupling_operations/reset_pfem_kinematics.py
+  KratosMultiphysics/CoSimulationApplication/coupling_operations/create_point_load_model_part.py
 
-  offset of local header from start of archive:   1880329
-                                                  (00000000001CB109h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   909377
+                                                  (00000000000DE041h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         5237294b
-  compressed size:                                783 bytes
-  uncompressed size:                              1945 bytes
-  length of filename:                             87 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         342d5324
+  compressed size:                                770 bytes
+  uncompressed size:                              2184 bytes
+  length of filename:                             94 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #50:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/coupling_operations/scaling.py
+  KratosMultiphysics/CoSimulationApplication/coupling_operations/distribute_point_values.py
 
-  offset of local header from start of archive:   1881257
-                                                  (00000000001CB4A9h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   910271
+                                                  (00000000000DE3BFh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         e3122fa4
-  compressed size:                                1193 bytes
-  uncompressed size:                              3502 bytes
-  length of filename:                             73 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         dcc3f7ed
+  compressed size:                                1222 bytes
+  uncompressed size:                              4854 bytes
+  length of filename:                             89 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #51:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/coupling_operations/create_point_load_model_part.py
+  KratosMultiphysics/CoSimulationApplication/coupling_operations/elemental_data_to_nodal_data.py
 
-  offset of local header from start of archive:   1882581
-                                                  (00000000001CB9D5h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   911612
+                                                  (00000000000DE8FCh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         343adbdd
-  compressed size:                                759 bytes
-  uncompressed size:                              2134 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         4c5f3de4
+  compressed size:                                846 bytes
+  uncompressed size:                              2301 bytes
   length of filename:                             94 characters
-  length of extra field:                          24 bytes
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #52:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/coupling_operations/__init__.py
+  KratosMultiphysics/CoSimulationApplication/coupling_operations/print_iteration_number.py
 
-  offset of local header from start of archive:   1883492
-                                                  (00000000001CBD64h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  offset of local header from start of archive:   912582
+                                                  (00000000000DECC6h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             74 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         df43d58d
+  compressed size:                                1100 bytes
+  uncompressed size:                              3377 bytes
+  length of filename:                             88 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #53:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/
+  KratosMultiphysics/CoSimulationApplication/coupling_operations/reset_pfem_kinematics.py
 
-  offset of local header from start of archive:   1883624
-                                                  (00000000001CBDE8h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   913800
+                                                  (00000000000DF188h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             59 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         ed0142de
+  compressed size:                                794 bytes
+  uncompressed size:                              1992 bytes
+  length of filename:                             87 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #54:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/
+  KratosMultiphysics/CoSimulationApplication/coupling_operations/scaling.py
 
-  offset of local header from start of archive:   1883741
-                                                  (00000000001CBE5Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   914711
+                                                  (00000000000DF517h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             66 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         90c96449
+  compressed size:                                1207 bytes
+  uncompressed size:                              3576 bytes
+  length of filename:                             73 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #55:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/kratos_base_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/data_transfer_operators/__init__.py
 
-  offset of local header from start of archive:   1883865
-                                                  (00000000001CBED9h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   916021
+                                                  (00000000000DFA35h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         bd9fd25f
-  compressed size:                                2131 bytes
-  uncompressed size:                              8451 bytes
-  length of filename:                             88 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                2 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             78 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #56:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/particle_mechanics_dirichlet_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/data_transfer_operators/copy.py
 
-  offset of local header from start of archive:   1886142
-                                                  (00000000001CC7BEh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   916131
+                                                  (00000000000DFAA3h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         45c46758
-  compressed size:                                314 bytes
-  uncompressed size:                              799 bytes
-  length of filename:                             105 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         f6fd1189
+  compressed size:                                546 bytes
+  uncompressed size:                              1546 bytes
+  length of filename:                             74 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #57:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/convection_diffusion_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/data_transfer_operators/copy_single_to_distributed.py
 
-  offset of local header from start of archive:   1886619
-                                                  (00000000001CC99Bh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   916781
+                                                  (00000000000DFD2Dh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         9fc6e092
-  compressed size:                                468 bytes
-  uncompressed size:                              1209 bytes
-  length of filename:                             97 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         eb06d7af
+  compressed size:                                179 bytes
+  uncompressed size:                              290 bytes
+  length of filename:                             96 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #58:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/dem_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/data_transfer_operators/kratos_mapping.py
 
-  offset of local header from start of archive:   1887242
-                                                  (00000000001CCC0Ah) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   917086
+                                                  (00000000000DFE5Eh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         9da02f41
-  compressed size:                                729 bytes
-  uncompressed size:                              2037 bytes
-  length of filename:                             80 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         55000446
+  compressed size:                                1971 bytes
+  uncompressed size:                              7097 bytes
+  length of filename:                             84 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #59:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/particle_mechanics_neumann_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/data_transfer_operators/sum_distributed_to_single.py
 
-  offset of local header from start of archive:   1888109
-                                                  (00000000001CCF6Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   919171
+                                                  (00000000000E0683h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         ec821894
-  compressed size:                                313 bytes
-  uncompressed size:                              789 bytes
-  length of filename:                             103 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         9e370542
+  compressed size:                                770 bytes
+  uncompressed size:                              2139 bytes
+  length of filename:                             95 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #60:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/mpm_neumann_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/data_transfer_operators/sum_many_to_many.py
 
-  offset of local header from start of archive:   1888583
-                                                  (00000000001CD147h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   920066
+                                                  (00000000000E0A02h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         57d233d8
-  compressed size:                                832 bytes
-  uncompressed size:                              2490 bytes
-  length of filename:                             88 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         9bbde81c
+  compressed size:                                673 bytes
+  uncompressed size:                              2263 bytes
+  length of filename:                             86 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #61:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/mpm_dirichlet_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/data_transfer_operators/transfer_one_to_many.py
 
-  offset of local header from start of archive:   1889561
-                                                  (00000000001CD519h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   920855
+                                                  (00000000000E0D17h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         404d2387
-  compressed size:                                960 bytes
-  uncompressed size:                              3036 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         64810d7c
+  compressed size:                                851 bytes
+  uncompressed size:                              2897 bytes
   length of filename:                             90 characters
-  length of extra field:                          24 bytes
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #62:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/structural_mechanics_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/factories/__init__.py
 
-  offset of local header from start of archive:   1890669
-                                                  (00000000001CD96Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   921826
+                                                  (00000000000E10E2h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         3f91546a
-  compressed size:                                655 bytes
-  uncompressed size:                              1823 bytes
-  length of filename:                             97 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                2 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             64 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #63:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/pfem_fluid_dynamics_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/factories/base_factory.py
 
-  offset of local header from start of archive:   1891479
-                                                  (00000000001CDC97h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   921922
+                                                  (00000000000E1142h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         e8c5d815
-  compressed size:                                856 bytes
-  uncompressed size:                              2822 bytes
-  length of filename:                             96 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         54b35059
+  compressed size:                                431 bytes
+  uncompressed size:                              949 bytes
+  length of filename:                             68 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #64:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/fluid_dynamics_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/factories/convergence_accelerator_factory.py
 
-  offset of local header from start of archive:   1892489
-                                                  (00000000001CE089h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   922451
+                                                  (00000000000E1353h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         6720c068
-  compressed size:                                694 bytes
-  uncompressed size:                              2061 bytes
-  length of filename:                             91 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         462d7896
+  compressed size:                                197 bytes
+  uncompressed size:                              398 bytes
+  length of filename:                             87 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #65:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/potential_flow_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/factories/convergence_criterion_factory.py
 
-  offset of local header from start of archive:   1893332
-                                                  (00000000001CE3D4h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   922765
+                                                  (00000000000E148Dh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         67266a3e
-  compressed size:                                832 bytes
-  uncompressed size:                              2794 bytes
-  length of filename:                             91 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         3dd34f8f
+  compressed size:                                197 bytes
+  uncompressed size:                              386 bytes
+  length of filename:                             85 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #66:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/rom_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/factories/coupling_operation_factory.py
 
-  offset of local header from start of archive:   1894313
-                                                  (00000000001CE7A9h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   923077
+                                                  (00000000000E15C5h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         eb6833c6
-  compressed size:                                618 bytes
-  uncompressed size:                              1608 bytes
-  length of filename:                             80 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         1b0e1311
+  compressed size:                                194 bytes
+  uncompressed size:                              373 bytes
+  length of filename:                             82 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #67:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/__init__.py
+  KratosMultiphysics/CoSimulationApplication/factories/data_transfer_operator_factory.py
 
-  offset of local header from start of archive:   1895069
-                                                  (00000000001CEA9Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  offset of local header from start of archive:   923383
+                                                  (00000000000E16F7h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             77 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         13d9bab6
+  compressed size:                                208 bytes
+  uncompressed size:                              384 bytes
+  length of filename:                             86 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #68:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos_co_sim_io.py
+  KratosMultiphysics/CoSimulationApplication/factories/helpers.py
 
-  offset of local header from start of archive:   1895204
-                                                  (00000000001CEB24h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   923707
+                                                  (00000000000E183Bh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         4afe75e7
-  compressed size:                                1378 bytes
-  uncompressed size:                              5980 bytes
-  length of filename:                             78 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         ab8379e0
+  compressed size:                                933 bytes
+  uncompressed size:                              4831 bytes
+  length of filename:                             63 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #69:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/empire_io.py
+  KratosMultiphysics/CoSimulationApplication/factories/io_factory.py
 
-  offset of local header from start of archive:   1896718
-                                                  (00000000001CF10Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   924733
+                                                  (00000000000E1C3Dh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         4ca27f46
-  compressed size:                                1186 bytes
-  uncompressed size:                              4173 bytes
-  length of filename:                             71 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         d5adbce8
+  compressed size:                                204 bytes
+  uncompressed size:                              372 bytes
+  length of filename:                             66 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #70:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/dummy_io.py
+  KratosMultiphysics/CoSimulationApplication/factories/predictor_factory.py
 
-  offset of local header from start of archive:   1898033
-                                                  (00000000001CF631h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   925033
+                                                  (00000000000E1D69h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         a25b814b
-  compressed size:                                313 bytes
-  uncompressed size:                              698 bytes
-  length of filename:                             70 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         c86e815e
+  compressed size:                                185 bytes
+  uncompressed size:                              347 bytes
+  length of filename:                             73 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #71:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/existing_co_simulation.py
+  KratosMultiphysics/CoSimulationApplication/factories/solver_wrapper_factory.py
 
-  offset of local header from start of archive:   1898474
-                                                  (00000000001CF7EAh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   925321
+                                                  (00000000000E1E89h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         6e206140
-  compressed size:                                331 bytes
-  uncompressed size:                              729 bytes
-  length of filename:                             84 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         51ccdfe4
+  compressed size:                                191 bytes
+  uncompressed size:                              343 bytes
+  length of filename:                             78 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #72:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/
+  KratosMultiphysics/CoSimulationApplication/helpers/__init__.py
 
-  offset of local header from start of archive:   1898947
-                                                  (00000000001CF9C3h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   925620
+                                                  (00000000000E1FB4h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
   32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
+  compressed size:                                2 bytes
   uncompressed size:                              0 bytes
-  length of filename:                             73 characters
-  length of extra field:                          24 bytes
+  length of filename:                             62 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #73:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/ping_pong_io.py
+  KratosMultiphysics/CoSimulationApplication/helpers/dummy_solver_wrapper.py
 
-  offset of local header from start of archive:   1899078
-                                                  (00000000001CFA46h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   925714
+                                                  (00000000000E2012h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         47223d80
-  compressed size:                                932 bytes
-  uncompressed size:                              3044 bytes
-  length of filename:                             88 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         9b97ee48
+  compressed size:                                695 bytes
+  uncompressed size:                              1853 bytes
+  length of filename:                             74 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #74:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/ping_pong_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/predictors/__init__.py
 
-  offset of local header from start of archive:   1900156
-                                                  (00000000001CFE7Ch) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   926513
+                                                  (00000000000E2331h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         02511afa
-  compressed size:                                885 bytes
-  uncompressed size:                              2836 bytes
-  length of filename:                             93 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                2 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             65 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #75:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/__init__.py
+  KratosMultiphysics/CoSimulationApplication/predictors/average_value_based.py
 
-  offset of local header from start of archive:   1901192
-                                                  (00000000001D0288h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  offset of local header from start of archive:   926610
+                                                  (00000000000E2392h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             84 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         3dbd2cf4
+  compressed size:                                752 bytes
+  uncompressed size:                              1979 bytes
+  length of filename:                             76 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #76:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/
+  KratosMultiphysics/CoSimulationApplication/predictors/linear.py
 
-  offset of local header from start of archive:   1901334
-                                                  (00000000001D0316h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   927468
+                                                  (00000000000E26ECh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             64 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         287b8a92
+  compressed size:                                321 bytes
+  uncompressed size:                              739 bytes
+  length of filename:                             63 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #77:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_solver_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/predictors/linear_derivative_based.py
 
-  offset of local header from start of archive:   1901456
-                                                  (00000000001D0390h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   927882
+                                                  (00000000000E288Ah) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         d5b45779
-  compressed size:                                944 bytes
-  uncompressed size:                              2916 bytes
-  length of filename:                             86 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         125a8728
+  compressed size:                                586 bytes
+  uncompressed size:                              1507 bytes
+  length of filename:                             80 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #78:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_static_solver.py
+  KratosMultiphysics/CoSimulationApplication/processes/__init__.py
 
-  offset of local header from start of archive:   1902544
-                                                  (00000000001D07D0h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   928578
+                                                  (00000000000E2B42h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         24ba5cb8
-  compressed size:                                1516 bytes
-  uncompressed size:                              5620 bytes
-  length of filename:                             85 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                2 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             64 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #79:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/static_sdof_solver_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/processes/create_point_based_entites_process.py
 
-  offset of local header from start of archive:   1904203
-                                                  (00000000001D0E4Bh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   928674
+                                                  (00000000000E2BA2h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         3d13c92e
-  compressed size:                                702 bytes
-  uncompressed size:                              1976 bytes
-  length of filename:                             93 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         a224d288
+  compressed size:                                1904 bytes
+  uncompressed size:                              6031 bytes
+  length of filename:                             90 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #80:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_solver.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/__init__.py
 
-  offset of local header from start of archive:   1905056
-                                                  (00000000001D11A0h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   930698
+                                                  (00000000000E338Ah) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         ec13b320
-  compressed size:                                2869 bytes
-  uncompressed size:                              12765 bytes
-  length of filename:                             78 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                2 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             70 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #81:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/__init__.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/dummy_io.py
 
-  offset of local header from start of archive:   1908061
-                                                  (00000000001D1D5Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  offset of local header from start of archive:   930800
+                                                  (00000000000E33F0h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             75 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         2409808c
+  compressed size:                                320 bytes
+  uncompressed size:                              726 bytes
+  length of filename:                             70 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #82:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/empire_io.py
 
-  offset of local header from start of archive:   1908194
-                                                  (00000000001D1DE2h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   931220
+                                                  (00000000000E3594h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             68 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         dbd38284
+  compressed size:                                1197 bytes
+  uncompressed size:                              4264 bytes
+  length of filename:                             71 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #83:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/openfoam_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/existing_co_simulation.py
 
-  offset of local header from start of archive:   1908320
-                                                  (00000000001D1E60h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   932518
+                                                  (00000000000E3AA6h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         c76d982d
-  compressed size:                                766 bytes
-  uncompressed size:                              2479 bytes
-  length of filename:                             87 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         39b0bfd3
+  compressed size:                                338 bytes
+  uncompressed size:                              747 bytes
+  length of filename:                             84 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #84:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/remote_controlled_solver_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos_co_sim_io.py
 
-  offset of local header from start of archive:   1909231
-                                                  (00000000001D21EFh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   932970
+                                                  (00000000000E3C6Ah) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         10b3d85e
-  compressed size:                                1230 bytes
-  uncompressed size:                              5115 bytes
-  length of filename:                             103 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         e5b4dfd1
+  compressed size:                                1391 bytes
+  uncompressed size:                              6118 bytes
+  length of filename:                             78 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #85:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/flower_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/__init__.py
 
-  offset of local header from start of archive:   1910622
-                                                  (00000000001D275Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   934469
+                                                  (00000000000E4245h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         0418dfce
-  compressed size:                                1044 bytes
-  uncompressed size:                              3778 bytes
-  length of filename:                             85 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                2 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             84 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #86:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/external_solver_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/ping_pong_io.py
 
-  offset of local header from start of archive:   1911809
-                                                  (00000000001D2C01h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   934585
+                                                  (00000000000E42B9h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         6ede7b64
-  compressed size:                                787 bytes
-  uncompressed size:                              2521 bytes
-  length of filename:                             94 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         d1f1489e
+  compressed size:                                940 bytes
+  uncompressed size:                              3113 bytes
+  length of filename:                             88 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #87:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/acusolve_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/ping_pong_wrapper.py
 
-  offset of local header from start of archive:   1912748
-                                                  (00000000001D2FACh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   935643
+                                                  (00000000000E46DBh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         da0e4f75
-  compressed size:                                2314 bytes
-  uncompressed size:                              10000 bytes
-  length of filename:                             87 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         7a0b8f9e
+  compressed size:                                894 bytes
+  uncompressed size:                              2906 bytes
+  length of filename:                             93 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #88:
 ---------------------------
 
   KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/__init__.py
 
-  offset of local header from start of archive:   1915207
-                                                  (00000000001D3947h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  offset of local header from start of archive:   936660
+                                                  (00000000000E4AD4h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
   32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
+  compressed size:                                2 bytes
   uncompressed size:                              0 bytes
   length of filename:                             79 characters
-  length of extra field:                          24 bytes
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #89:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/solver_wrappers/__init__.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/acusolve_wrapper.py
 
-  offset of local header from start of archive:   1915344
-                                                  (00000000001D39D0h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  offset of local header from start of archive:   936771
+                                                  (00000000000E4B43h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
+  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             70 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         56fa4ec8
+  compressed size:                                2326 bytes
+  uncompressed size:                              10201 bytes
+  length of filename:                             87 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #90:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/empire_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/external_solver_wrapper.py
 
-  offset of local header from start of archive:   1915472
-                                                  (00000000001D3A50h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   939214
+                                                  (00000000000E54CEh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         7b2c5fb3
-  compressed size:                                4364 bytes
-  uncompressed size:                              28310 bytes
-  length of filename:                             60 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         a1c9babe
+  compressed size:                                794 bytes
+  uncompressed size:                              2580 bytes
+  length of filename:                             94 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #91:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/coupling_interface_data.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/flower_wrapper.py
 
-  offset of local header from start of archive:   1919954
-                                                  (00000000001D4BD2h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   940132
+                                                  (00000000000E5864h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         1031dd3f
-  compressed size:                                3026 bytes
-  uncompressed size:                              12913 bytes
-  length of filename:                             69 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         037b6d24
+  compressed size:                                1055 bytes
+  uncompressed size:                              3864 bytes
+  length of filename:                             85 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #92:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/fluid_dynamics_analysis_with_co_sim_io.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/openfoam_wrapper.py
 
-  offset of local header from start of archive:   1923107
-                                                  (00000000001D5823h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   941302
+                                                  (00000000000E5CF6h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         ee5aaaa6
-  compressed size:                                400 bytes
-  uncompressed size:                              909 bytes
-  length of filename:                             84 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         062a43c6
+  compressed size:                                773 bytes
+  uncompressed size:                              2540 bytes
+  length of filename:                             87 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #93:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/helpers/
-
-  offset of local header from start of archive:   1923649
-                                                  (00000000001D5A41h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             51 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #94:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/helpers/dummy_solver_wrapper.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/remote_controlled_solver_wrapper.py
 
-  offset of local header from start of archive:   1923758
-                                                  (00000000001D5AAEh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   942192
+                                                  (00000000000E6070h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         476a7017
-  compressed size:                                685 bytes
-  uncompressed size:                              1814 bytes
-  length of filename:                             74 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #95:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/helpers/__init__.py
-
-  offset of local header from start of archive:   1924575
-                                                  (00000000001D5DDFh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             62 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         37edf258
+  compressed size:                                1237 bytes
+  uncompressed size:                              5236 bytes
+  length of filename:                             103 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #96:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/utilities/
-
-  offset of local header from start of archive:   1924695
-                                                  (00000000001D5E57h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             53 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #97:
+Central directory entry #94:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/utilities/data_communicator_utilities.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/__init__.py
 
-  offset of local header from start of archive:   1924806
-                                                  (00000000001D5EC6h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   943562
+                                                  (00000000000E65CAh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         22c83b33
-  compressed size:                                684 bytes
-  uncompressed size:                              1711 bytes
-  length of filename:                             83 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #98:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/utilities/__init__.py
-
-  offset of local header from start of archive:   1925631
-                                                  (00000000001D61FFh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
   32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
+  compressed size:                                2 bytes
   uncompressed size:                              0 bytes
-  length of filename:                             64 characters
-  length of extra field:                          24 bytes
+  length of filename:                             77 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #99:
+Central directory entry #95:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/utilities/model_part_utilities.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/convection_diffusion_wrapper.py
 
-  offset of local header from start of archive:   1925753
-                                                  (00000000001D6279h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   943671
+                                                  (00000000000E6637h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         96dce9d6
-  compressed size:                                976 bytes
-  uncompressed size:                              4463 bytes
-  length of filename:                             76 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #100:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/factories/
-
-  offset of local header from start of archive:   1926863
-                                                  (00000000001D66CFh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             53 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         eb7b0ad5
+  compressed size:                                481 bytes
+  uncompressed size:                              1234 bytes
+  length of filename:                             97 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #101:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/factories/data_transfer_operator_factory.py
-
-  offset of local header from start of archive:   1926974
-                                                  (00000000001D673Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         69377dc6
-  compressed size:                                204 bytes
-  uncompressed size:                              379 bytes
-  length of filename:                             86 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #102:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/factories/helpers.py
-
-  offset of local header from start of archive:   1927322
-                                                  (00000000001D689Ah) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         945b8655
-  compressed size:                                920 bytes
-  uncompressed size:                              4753 bytes
-  length of filename:                             63 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #103:
+Central directory entry #96:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/factories/solver_wrapper_factory.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/dem_wrapper.py
 
-  offset of local header from start of archive:   1928363
-                                                  (00000000001D6CABh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   944279
+                                                  (00000000000E6897h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         0910ce77
-  compressed size:                                188 bytes
-  uncompressed size:                              338 bytes
-  length of filename:                             78 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         1df72719
+  compressed size:                                740 bytes
+  uncompressed size:                              2088 bytes
+  length of filename:                             80 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #104:
+Central directory entry #97:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/factories/coupling_operation_factory.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/fluid_dynamics_wrapper.py
 
-  offset of local header from start of archive:   1928687
-                                                  (00000000001D6DEFh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   945129
+                                                  (00000000000E6BE9h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         b3e739cc
-  compressed size:                                189 bytes
-  uncompressed size:                              368 bytes
-  length of filename:                             82 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         d5b60d7a
+  compressed size:                                704 bytes
+  uncompressed size:                              2104 bytes
+  length of filename:                             91 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #105:
+Central directory entry #98:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/factories/io_factory.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/kratos_base_wrapper.py
 
-  offset of local header from start of archive:   1929016
-                                                  (00000000001D6F38h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   945954
+                                                  (00000000000E6F22h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         7014ed02
-  compressed size:                                199 bytes
-  uncompressed size:                              367 bytes
-  length of filename:                             66 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         ab99188a
+  compressed size:                                2153 bytes
+  uncompressed size:                              8620 bytes
+  length of filename:                             88 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #106:
+Central directory entry #99:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/factories/convergence_accelerator_factory.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/mpm_dirichlet_wrapper.py
 
-  offset of local header from start of archive:   1929339
-                                                  (00000000001D707Bh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   948225
+                                                  (00000000000E7801h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         13ae9d6b
-  compressed size:                                192 bytes
-  uncompressed size:                              393 bytes
-  length of filename:                             87 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         5b54121c
+  compressed size:                                969 bytes
+  uncompressed size:                              3096 bytes
+  length of filename:                             90 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #107:
+Central directory entry #100:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/factories/base_factory.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/mpm_neumann_wrapper.py
 
-  offset of local header from start of archive:   1929676
-                                                  (00000000001D71CCh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   949314
+                                                  (00000000000E7C42h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         2d699562
-  compressed size:                                425 bytes
-  uncompressed size:                              929 bytes
-  length of filename:                             68 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         24660bf5
+  compressed size:                                842 bytes
+  uncompressed size:                              2542 bytes
+  length of filename:                             88 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #108:
+Central directory entry #101:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/factories/convergence_criterion_factory.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/particle_mechanics_dirichlet_wrapper.py
 
-  offset of local header from start of archive:   1930227
-                                                  (00000000001D73F3h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   950274
+                                                  (00000000000E8002h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         e1afbc64
-  compressed size:                                192 bytes
-  uncompressed size:                              381 bytes
-  length of filename:                             85 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #109:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/factories/__init__.py
-
-  offset of local header from start of archive:   1930562
-                                                  (00000000001D7542h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             64 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         3bff7b2c
+  compressed size:                                321 bytes
+  uncompressed size:                              814 bytes
+  length of filename:                             105 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #110:
+Central directory entry #102:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/factories/predictor_factory.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/particle_mechanics_neumann_wrapper.py
 
-  offset of local header from start of archive:   1930684
-                                                  (00000000001D75BCh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   950730
+                                                  (00000000000E81CAh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         6af5fbf3
-  compressed size:                                181 bytes
-  uncompressed size:                              342 bytes
-  length of filename:                             73 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         57efcdbb
+  compressed size:                                320 bytes
+  uncompressed size:                              804 bytes
+  length of filename:                             103 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #111:
+Central directory entry #103:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/co_simulation_tools.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/pfem_fluid_dynamics_wrapper.py
 
-  offset of local header from start of archive:   1930996
-                                                  (00000000001D76F4h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   951183
+                                                  (00000000000E838Fh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         48394be1
-  compressed size:                                326 bytes
-  uncompressed size:                              632 bytes
-  length of filename:                             65 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #112:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/convergence_accelerators/
-
-  offset of local header from start of archive:   1931445
-                                                  (00000000001D78B5h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             68 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         e8c5d815
+  compressed size:                                856 bytes
+  uncompressed size:                              2822 bytes
+  length of filename:                             96 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #113:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/convergence_accelerators/convergence_accelerator_wrapper.py
-
-  offset of local header from start of archive:   1931571
-                                                  (00000000001D7933h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         bcd403ed
-  compressed size:                                1421 bytes
-  uncompressed size:                              5941 bytes
-  length of filename:                             102 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #114:
+Central directory entry #104:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/convergence_accelerators/iqnils.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/potential_flow_wrapper.py
 
-  offset of local header from start of archive:   1933152
-                                                  (00000000001D7F60h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   952165
+                                                  (00000000000E8765h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         5f8766e6
-  compressed size:                                1873 bytes
-  uncompressed size:                              7593 bytes
-  length of filename:                             77 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         dbe3d989
+  compressed size:                                845 bytes
+  uncompressed size:                              2848 bytes
+  length of filename:                             91 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #115:
+Central directory entry #105:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/convergence_accelerators/anderson.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/rom_wrapper.py
 
-  offset of local header from start of archive:   1935160
-                                                  (00000000001D8738h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   953131
+                                                  (00000000000E8B2Bh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         b0a0b124
-  compressed size:                                1300 bytes
-  uncompressed size:                              3851 bytes
-  length of filename:                             79 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         4012f2af
+  compressed size:                                630 bytes
+  uncompressed size:                              1640 bytes
+  length of filename:                             80 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #116:
+Central directory entry #106:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/convergence_accelerators/mvqn.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/structural_mechanics_wrapper.py
 
-  offset of local header from start of archive:   1936597
-                                                  (00000000001D8CD5h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   953871
+                                                  (00000000000E8E0Fh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         e7b3945f
-  compressed size:                                1575 bytes
-  uncompressed size:                              4214 bytes
-  length of filename:                             75 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         5ac52258
+  compressed size:                                666 bytes
+  uncompressed size:                              1862 bytes
+  length of filename:                             97 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #117:
+Central directory entry #107:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/convergence_accelerators/aitken.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/__init__.py
 
-  offset of local header from start of archive:   1938305
-                                                  (00000000001D9381h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   954664
+                                                  (00000000000E9128h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         66b27fcf
-  compressed size:                                1152 bytes
-  uncompressed size:                              3618 bytes
-  length of filename:                             77 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #118:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/convergence_accelerators/__init__.py
-
-  offset of local header from start of archive:   1939592
-                                                  (00000000001D9888h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
   32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
+  compressed size:                                2 bytes
   uncompressed size:                              0 bytes
-  length of filename:                             79 characters
-  length of extra field:                          24 bytes
+  length of filename:                             75 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #119:
+Central directory entry #108:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/convergence_accelerators/constant_relaxation.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_solver.py
 
-  offset of local header from start of archive:   1939729
-                                                  (00000000001D9911h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   954771
+                                                  (00000000000E9193h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         31257488
-  compressed size:                                591 bytes
-  uncompressed size:                              1445 bytes
-  length of filename:                             90 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #120:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/coupled_solvers/
-
-  offset of local header from start of archive:   1940468
-                                                  (00000000001D9BF4h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             59 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         de6d1d0c
+  compressed size:                                2884 bytes
+  uncompressed size:                              13049 bytes
+  length of filename:                             78 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #121:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/coupled_solvers/jacobi_weak.py
-
-  offset of local header from start of archive:   1940585
-                                                  (00000000001D9C69h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         817ee84f
-  compressed size:                                308 bytes
-  uncompressed size:                              956 bytes
-  length of filename:                             73 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #122:
+Central directory entry #109:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/coupled_solvers/gauss_seidel_strong.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_solver_wrapper.py
 
-  offset of local header from start of archive:   1941024
-                                                  (00000000001D9E20h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   957763
+                                                  (00000000000E9D43h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         8362e3cc
-  compressed size:                                1399 bytes
-  uncompressed size:                              6152 bytes
-  length of filename:                             81 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         702f7282
+  compressed size:                                952 bytes
+  uncompressed size:                              2982 bytes
+  length of filename:                             86 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #123:
+Central directory entry #110:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/coupled_solvers/jacobi_strong.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_static_solver.py
 
-  offset of local header from start of archive:   1942562
-                                                  (00000000001DA422h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   958831
+                                                  (00000000000EA16Fh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         5b1bb287
-  compressed size:                                1340 bytes
-  uncompressed size:                              6072 bytes
-  length of filename:                             75 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         d8c51f7e
+  compressed size:                                1528 bytes
+  uncompressed size:                              5765 bytes
+  length of filename:                             85 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #124:
+Central directory entry #111:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/coupled_solvers/feti_dynamic_coupled_solver.py
+  KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/static_sdof_solver_wrapper.py
 
-  offset of local header from start of archive:   1944035
-                                                  (00000000001DA9E3h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   960474
+                                                  (00000000000EA7DAh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         c1513bf6
-  compressed size:                                3180 bytes
-  uncompressed size:                              13627 bytes
-  length of filename:                             89 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         a798fa53
+  compressed size:                                712 bytes
+  uncompressed size:                              2019 bytes
+  length of filename:                             93 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #125:
+Central directory entry #112:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/coupled_solvers/gauss_seidel_weak.py
+  KratosMultiphysics/CoSimulationApplication/utilities/__init__.py
 
-  offset of local header from start of archive:   1947362
-                                                  (00000000001DB6E2h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   961309
+                                                  (00000000000EAB1Dh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         a6305ecd
-  compressed size:                                310 bytes
-  uncompressed size:                              834 bytes
-  length of filename:                             79 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #126:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/coupled_solvers/__init__.py
-
-  offset of local header from start of archive:   1947809
-                                                  (00000000001DB8A1h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
   32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
+  compressed size:                                2 bytes
   uncompressed size:                              0 bytes
-  length of filename:                             70 characters
-  length of extra field:                          24 bytes
+  length of filename:                             64 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #127:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/data_transfer_operators/
-
-  offset of local header from start of archive:   1947937
-                                                  (00000000001DB921h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             67 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #128:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/data_transfer_operators/copy.py
-
-  offset of local header from start of archive:   1948062
-                                                  (00000000001DB99Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         fce68811
-  compressed size:                                539 bytes
-  uncompressed size:                              1517 bytes
-  length of filename:                             74 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #129:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/data_transfer_operators/sum_distributed_to_single.py
-
-  offset of local header from start of archive:   1948733
-                                                  (00000000001DBC3Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         53bf60c6
-  compressed size:                                762 bytes
-  uncompressed size:                              2091 bytes
-  length of filename:                             95 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #130:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/data_transfer_operators/sum_many_to_many.py
-
-  offset of local header from start of archive:   1949648
-                                                  (00000000001DBFD0h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         1919f4e6
-  compressed size:                                662 bytes
-  uncompressed size:                              2214 bytes
-  length of filename:                             86 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #131:
+Central directory entry #113:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/data_transfer_operators/copy_single_to_distributed.py
+  KratosMultiphysics/CoSimulationApplication/utilities/data_communicator_utilities.py
 
-  offset of local header from start of archive:   1950454
-                                                  (00000000001DC2F6h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   961405
+                                                  (00000000000EAB7Dh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         f8f60ce6
-  compressed size:                                174 bytes
-  uncompressed size:                              284 bytes
-  length of filename:                             96 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         6b789d2c
+  compressed size:                                692 bytes
+  uncompressed size:                              1751 bytes
+  length of filename:                             83 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #132:
+Central directory entry #114:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/data_transfer_operators/transfer_one_to_many.py
+  KratosMultiphysics/CoSimulationApplication/utilities/model_part_utilities.py
 
-  offset of local header from start of archive:   1950782
-                                                  (00000000001DC43Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   962210
+                                                  (00000000000EAEA2h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         6b544749
-  compressed size:                                844 bytes
-  uncompressed size:                              2839 bytes
-  length of filename:                             90 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         5c77749f
+  compressed size:                                985 bytes
+  uncompressed size:                              4535 bytes
+  length of filename:                             76 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #133:
+Central directory entry #115:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/data_transfer_operators/kratos_mapping.py
+  KratosCoSimulationApplication-9.5.1.dist-info/METADATA
 
-  offset of local header from start of archive:   1951774
-                                                  (00000000001DC81Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   963301
+                                                  (00000000000EB2E5h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         321685b8
-  compressed size:                                1954 bytes
-  uncompressed size:                              6955 bytes
-  length of filename:                             84 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #134:
----------------------------
-
-  KratosMultiphysics/CoSimulationApplication/data_transfer_operators/__init__.py
-
-  offset of local header from start of archive:   1953870
-                                                  (00000000001DD04Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             78 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:28
+  32-bit CRC value (hex):                         6c6baad4
+  compressed size:                                7425 bytes
+  uncompressed size:                              26723 bytes
+  length of filename:                             54 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #135:
+Central directory entry #116:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/MPIExtension.py
+  KratosCoSimulationApplication-9.5.1.dist-info/WHEEL
 
-  offset of local header from start of archive:   1954006
-                                                  (00000000001DD0D6h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   970810
+                                                  (00000000000ED03Ah) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         661adb80
-  compressed size:                                111 bytes
-  uncompressed size:                              145 bytes
-  length of filename:                             58 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:28
+  32-bit CRC value (hex):                         86fb6b41
+  compressed size:                                96 bytes
+  uncompressed size:                              100 bytes
+  length of filename:                             51 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #136:
+Central directory entry #117:
 ---------------------------
 
-  KratosMultiphysics/CoSimulationApplication/__init__.py
+  KratosCoSimulationApplication-9.5.1.dist-info/top_level.txt
 
-  offset of local header from start of archive:   1954233
-                                                  (00000000001DD1B9h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   970987
+                                                  (00000000000ED0EBh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         34edaf37
-  compressed size:                                445 bytes
-  uncompressed size:                              985 bytes
-  length of filename:                             54 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #137:
----------------------------
-
-  KratosMultiphysics/.libs/
-
-  offset of local header from start of archive:   1954790
-                                                  (00000000001DD3E6h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:48
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:48 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:48 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             25 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:28
+  32-bit CRC value (hex):                         f32d789f
+  compressed size:                                21 bytes
+  uncompressed size:                              19 bytes
+  length of filename:                             59 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
-Central directory entry #138:
+Central directory entry #118:
 ---------------------------
 
-  KratosMultiphysics/.libs/KratosCoSimulationApplication.cpython-39-x86_64-linux-gnu.so
+  KratosCoSimulationApplication-9.5.1.dist-info/RECORD
 
-  offset of local header from start of archive:   1954873
-                                                  (00000000001DD439h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   971097
+                                                  (00000000000ED159h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:34 UTC
-  32-bit CRC value (hex):                         6e6f9373
-  compressed size:                                755281 bytes
-  uncompressed size:                              2132697 bytes
-  length of filename:                             85 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:28
+  32-bit CRC value (hex):                         ff8deb6f
+  compressed size:                                5303 bytes
+  uncompressed size:                              15975 bytes
+  length of filename:                             52 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100755 octal):            -rwxr-xr-x
+  non-MSDOS external file attributes:             81B400 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
```

## zipnote {}

```diff
@@ -1,415 +1,355 @@
-Filename: KratosCoSimulationApplication-9.5.dist-info/
+Filename: KratosMultiphysics/.libs/KratosCoSimulationApplication.pyd
 Comment: 
 
-Filename: KratosCoSimulationApplication-9.5.dist-info/METADATA
+Filename: KratosMultiphysics/.libs/KratosCoSimulationCore.dll
 Comment: 
 
-Filename: KratosCoSimulationApplication-9.5.dist-info/WHEEL
+Filename: KratosMultiphysics/.libs/KratosCoSimulationCore.lib
 Comment: 
 
-Filename: KratosCoSimulationApplication-9.5.dist-info/top_level.txt
+Filename: KratosMultiphysics/.libs/co_sim_io.dll
 Comment: 
 
-Filename: KratosCoSimulationApplication-9.5.dist-info/RECORD
+Filename: KratosMultiphysics/.libs/co_sim_io.lib
 Comment: 
 
-Filename: KratosCoSimulationApplication.libs/
-Comment: 
-
-Filename: KratosCoSimulationApplication.libs/libKratosCoSimulationCore-6b309626.so
-Comment: 
-
-Filename: KratosCoSimulationApplication.libs/libco_sim_io-da5c66c6.so
-Comment: 
-
-Filename: KratosMultiphysics/
-Comment: 
-
-Filename: KratosMultiphysics/CoSimulationApplication/
-Comment: 
-
-Filename: KratosMultiphysics/CoSimulationApplication/processes/
-Comment: 
-
-Filename: KratosMultiphysics/CoSimulationApplication/processes/create_point_based_entites_process.py
-Comment: 
-
-Filename: KratosMultiphysics/CoSimulationApplication/processes/__init__.py
-Comment: 
-
-Filename: KratosMultiphysics/CoSimulationApplication/predictors/
-Comment: 
-
-Filename: KratosMultiphysics/CoSimulationApplication/predictors/average_value_based.py
+Filename: KratosMultiphysics/CoSimulationApplication/MainKratosCoSim.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/predictors/linear_derivative_based.py
+Filename: KratosMultiphysics/CoSimulationApplication/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/predictors/linear.py
+Filename: KratosMultiphysics/CoSimulationApplication/analysis_stage_with_co_sim_io.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/predictors/__init__.py
+Filename: KratosMultiphysics/CoSimulationApplication/co_simulation_analysis.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/MainKratosCoSim.py
+Filename: KratosMultiphysics/CoSimulationApplication/co_simulation_tools.py
 Comment: 
 
 Filename: KratosMultiphysics/CoSimulationApplication/colors.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/convergence_criteria/
+Filename: KratosMultiphysics/CoSimulationApplication/coupling_interface_data.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/convergence_criteria/convergence_criteria_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/empire_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/convergence_criteria/relative_norm_previous_residual.py
+Filename: KratosMultiphysics/CoSimulationApplication/fluid_dynamics_analysis_with_co_sim_io.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/convergence_criteria/relative_norm_initial_residual.py
+Filename: KratosMultiphysics/CoSimulationApplication/function_callback_utility.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/convergence_criteria/absolute_norm_energy_conjugate.py
+Filename: KratosMultiphysics/CoSimulationApplication/structural_mechanics_analysis_with_co_sim_io.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/convergence_criteria/__init__.py
+Filename: KratosMultiphysics/CoSimulationApplication/base_classes/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/base_classes/
+Filename: KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_convergence_accelerator.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_convergence_accelerator.py
+Filename: KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_convergence_criteria.py
 Comment: 
 
 Filename: KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_coupled_solver.py
 Comment: 
 
 Filename: KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_coupling_operation.py
 Comment: 
 
 Filename: KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_data_transfer_operator.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_convergence_criteria.py
-Comment: 
-
 Filename: KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_io.py
 Comment: 
 
 Filename: KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_predictor.py
 Comment: 
 
 Filename: KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_solver_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/base_classes/__init__.py
-Comment: 
-
-Filename: KratosMultiphysics/CoSimulationApplication/analysis_stage_with_co_sim_io.py
-Comment: 
-
-Filename: KratosMultiphysics/CoSimulationApplication/function_callback_utility.py
-Comment: 
-
-Filename: KratosMultiphysics/CoSimulationApplication/structural_mechanics_analysis_with_co_sim_io.py
-Comment: 
-
-Filename: KratosMultiphysics/CoSimulationApplication/co_simulation_analysis.py
-Comment: 
-
-Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/
-Comment: 
-
-Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/print_iteration_number.py
-Comment: 
-
-Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/compute_boundary_force.py
-Comment: 
-
-Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/distribute_point_values.py
-Comment: 
-
-Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/convert_distributed_values_to_point.py
-Comment: 
-
-Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/compute_normals.py
+Filename: KratosMultiphysics/CoSimulationApplication/convergence_accelerators/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/coupling_output.py
+Filename: KratosMultiphysics/CoSimulationApplication/convergence_accelerators/aitken.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/elemental_data_to_nodal_data.py
+Filename: KratosMultiphysics/CoSimulationApplication/convergence_accelerators/anderson.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/reset_pfem_kinematics.py
+Filename: KratosMultiphysics/CoSimulationApplication/convergence_accelerators/constant_relaxation.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/scaling.py
+Filename: KratosMultiphysics/CoSimulationApplication/convergence_accelerators/convergence_accelerator_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/create_point_load_model_part.py
+Filename: KratosMultiphysics/CoSimulationApplication/convergence_accelerators/iqnils.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/__init__.py
+Filename: KratosMultiphysics/CoSimulationApplication/convergence_accelerators/mvqn.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/
+Filename: KratosMultiphysics/CoSimulationApplication/convergence_criteria/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/
+Filename: KratosMultiphysics/CoSimulationApplication/convergence_criteria/absolute_norm_energy_conjugate.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/kratos_base_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/convergence_criteria/convergence_criteria_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/particle_mechanics_dirichlet_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/convergence_criteria/relative_norm_initial_residual.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/convection_diffusion_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/convergence_criteria/relative_norm_previous_residual.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/dem_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/coupled_solvers/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/particle_mechanics_neumann_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/coupled_solvers/feti_dynamic_coupled_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/mpm_neumann_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/coupled_solvers/gauss_seidel_strong.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/mpm_dirichlet_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/coupled_solvers/gauss_seidel_weak.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/structural_mechanics_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/coupled_solvers/jacobi_strong.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/pfem_fluid_dynamics_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/coupled_solvers/jacobi_weak.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/fluid_dynamics_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/potential_flow_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/compute_boundary_force.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/rom_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/compute_normals.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/__init__.py
+Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/convert_distributed_values_to_point.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos_co_sim_io.py
+Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/coupling_output.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/empire_io.py
+Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/create_point_load_model_part.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/dummy_io.py
+Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/distribute_point_values.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/existing_co_simulation.py
+Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/elemental_data_to_nodal_data.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/
+Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/print_iteration_number.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/ping_pong_io.py
+Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/reset_pfem_kinematics.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/ping_pong_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/coupling_operations/scaling.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/__init__.py
+Filename: KratosMultiphysics/CoSimulationApplication/data_transfer_operators/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/
+Filename: KratosMultiphysics/CoSimulationApplication/data_transfer_operators/copy.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_solver_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/data_transfer_operators/copy_single_to_distributed.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_static_solver.py
+Filename: KratosMultiphysics/CoSimulationApplication/data_transfer_operators/kratos_mapping.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/static_sdof_solver_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/data_transfer_operators/sum_distributed_to_single.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_solver.py
+Filename: KratosMultiphysics/CoSimulationApplication/data_transfer_operators/sum_many_to_many.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/__init__.py
+Filename: KratosMultiphysics/CoSimulationApplication/data_transfer_operators/transfer_one_to_many.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/
+Filename: KratosMultiphysics/CoSimulationApplication/factories/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/openfoam_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/factories/base_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/remote_controlled_solver_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/factories/convergence_accelerator_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/flower_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/factories/convergence_criterion_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/external_solver_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/factories/coupling_operation_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/acusolve_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/factories/data_transfer_operator_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/__init__.py
+Filename: KratosMultiphysics/CoSimulationApplication/factories/helpers.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/__init__.py
+Filename: KratosMultiphysics/CoSimulationApplication/factories/io_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/empire_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/factories/predictor_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/coupling_interface_data.py
+Filename: KratosMultiphysics/CoSimulationApplication/factories/solver_wrapper_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/fluid_dynamics_analysis_with_co_sim_io.py
+Filename: KratosMultiphysics/CoSimulationApplication/helpers/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/helpers/
+Filename: KratosMultiphysics/CoSimulationApplication/helpers/dummy_solver_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/helpers/dummy_solver_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/predictors/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/helpers/__init__.py
+Filename: KratosMultiphysics/CoSimulationApplication/predictors/average_value_based.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/utilities/
+Filename: KratosMultiphysics/CoSimulationApplication/predictors/linear.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/utilities/data_communicator_utilities.py
+Filename: KratosMultiphysics/CoSimulationApplication/predictors/linear_derivative_based.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/utilities/__init__.py
+Filename: KratosMultiphysics/CoSimulationApplication/processes/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/utilities/model_part_utilities.py
+Filename: KratosMultiphysics/CoSimulationApplication/processes/create_point_based_entites_process.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/factories/
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/factories/data_transfer_operator_factory.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/dummy_io.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/factories/helpers.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/empire_io.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/factories/solver_wrapper_factory.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/existing_co_simulation.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/factories/coupling_operation_factory.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos_co_sim_io.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/factories/io_factory.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/factories/convergence_accelerator_factory.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/ping_pong_io.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/factories/base_factory.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/ping_pong_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/factories/convergence_criterion_factory.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/factories/__init__.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/acusolve_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/factories/predictor_factory.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/external_solver_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/co_simulation_tools.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/flower_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/convergence_accelerators/
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/openfoam_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/convergence_accelerators/convergence_accelerator_wrapper.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/remote_controlled_solver_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/convergence_accelerators/iqnils.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/convergence_accelerators/anderson.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/convection_diffusion_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/convergence_accelerators/mvqn.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/dem_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/convergence_accelerators/aitken.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/fluid_dynamics_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/convergence_accelerators/__init__.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/kratos_base_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/convergence_accelerators/constant_relaxation.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/mpm_dirichlet_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/coupled_solvers/
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/mpm_neumann_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/coupled_solvers/jacobi_weak.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/particle_mechanics_dirichlet_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/coupled_solvers/gauss_seidel_strong.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/particle_mechanics_neumann_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/coupled_solvers/jacobi_strong.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/pfem_fluid_dynamics_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/coupled_solvers/feti_dynamic_coupled_solver.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/potential_flow_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/coupled_solvers/gauss_seidel_weak.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/rom_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/coupled_solvers/__init__.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/structural_mechanics_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/data_transfer_operators/
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/data_transfer_operators/copy.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/data_transfer_operators/sum_distributed_to_single.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_solver_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/data_transfer_operators/sum_many_to_many.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_static_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/data_transfer_operators/copy_single_to_distributed.py
+Filename: KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/static_sdof_solver_wrapper.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/data_transfer_operators/transfer_one_to_many.py
+Filename: KratosMultiphysics/CoSimulationApplication/utilities/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/data_transfer_operators/kratos_mapping.py
+Filename: KratosMultiphysics/CoSimulationApplication/utilities/data_communicator_utilities.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/data_transfer_operators/__init__.py
+Filename: KratosMultiphysics/CoSimulationApplication/utilities/model_part_utilities.py
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/MPIExtension.py
+Filename: KratosCoSimulationApplication-9.5.1.dist-info/METADATA
 Comment: 
 
-Filename: KratosMultiphysics/CoSimulationApplication/__init__.py
+Filename: KratosCoSimulationApplication-9.5.1.dist-info/WHEEL
 Comment: 
 
-Filename: KratosMultiphysics/.libs/
+Filename: KratosCoSimulationApplication-9.5.1.dist-info/top_level.txt
 Comment: 
 
-Filename: KratosMultiphysics/.libs/KratosCoSimulationApplication.cpython-39-x86_64-linux-gnu.so
+Filename: KratosCoSimulationApplication-9.5.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v1.0 to extract, compression method=store
+Zip archive data, at least v2.0 to extract, compression method=deflate
```

## KratosMultiphysics/CoSimulationApplication/processes/create_point_based_entites_process.py

 * *Ordering differences only*

```diff
@@ -1,112 +1,112 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
-
-# other imports
-from importlib import import_module
-
-
-def Factory(settings, Model):
-    if not isinstance(settings, KM.Parameters):
-        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
-    return CreatePointBasedEntitiesProcess(Model, settings["Parameters"])
-
-
-class CreatePointBasedEntitiesProcess(KM.Process):
-    """This process creates point based entities on the nodes of SubModelPart(s). This process should be used only once per ModelPart to not create the same entities multiple times on the same nodes.
-    It works with restarts as well as in MPI. Also the numbering of the newly created entities is done consistently.
-    """
-
-    def __init__(self, Model, settings ):
-        KM.Process.__init__(self)
-
-        """
-        model_part_name: The name of the MainModelPart for which the entities should be created
-        sub_model_part_names: <optional> Names of the SubModelParts on which the entities should be created. This is needed to not create multiple entities on the same nodes, if model-part are overlapping/contain the same nodes.
-        new_sub_model_part_name: The name of the SubModelPart that will be created as base of MainModelPart. The created entities will be in this ModelPart
-        entity_name: The name of the entities to create
-        entity_type: "condition" or "element"
-        properties_id: Id of the properties to be used for the newly created entities
-        kratos_application: <optional> Application in which the entities to create are implemented, needs to be imported before creating them
-        """
-        default_settings = KM.Parameters("""{
-            "model_part_name"          : "PLEASE_SPECIFY",
-            "sub_model_part_names"     : [],
-            "new_sub_model_part_name"  : "PLEASE_SPECIFY",
-            "entity_name"              : "PointLoadCondition3D1N",
-            "entity_type"              : "condition",
-            "properties_id"            : 0,
-            "kratos_application"       : "",
-            "initialize_communicators" : false
-        }""")
-
-        settings.ValidateAndAssignDefaults(default_settings)
-
-        model_part_name = settings["model_part_name"].GetString()
-        model_part = Model[model_part_name]
-        if model_part.ProcessInfo[KM.IS_RESTARTED]:
-            # Do nothing in case of restart
-            return
-
-        root_model_part = model_part.GetRootModelPart()
-        entity_name = settings["entity_name"].GetString()
-        entity_type = settings["entity_type"].GetString()
-        properties_id = settings["properties_id"].GetInt()
-
-        # importing the Application where the entites are registered (optional)
-        kratos_application = settings["kratos_application"].GetString()
-        if kratos_application != "":
-            if not CheckIfApplicationsAvailable(kratos_application):
-                raise Exception('Application "{}" is not available!'.format(kratos_application))
-            import_module("KratosMultiphysics." + kratos_application) # this registers the entities
-
-        if settings["sub_model_part_names"].size() == 0:
-            # if no sub-model-parts are specified then taking the main-model-part
-            model_parts = [model_part]
-        else:
-            model_parts = [Model[model_part_name+"."+sub_model_part_name] for sub_model_part_name in settings["sub_model_part_names"].GetStringArray()]
-
-        new_model_part = RecursiveCreateModelParts(model_part, settings["new_sub_model_part_name"].GetString())
-
-        node_ids = [node.Id
-            for mp in model_parts
-                for node in mp.GetCommunicator().LocalMesh().Nodes
-        ]
-        node_ids = list(set(node_ids)) # make sure the node-Ids are unique. This is needed to not create multiple entities for the same node
-
-        new_model_part.AddNodes(node_ids)
-
-        props = root_model_part.GetProperties(properties_id)
-        mp_comm = root_model_part.GetCommunicator()
-
-        if entity_type == "element":
-            max_id_entities = max([elem.Id for elem in root_model_part.Elements]+[0]) # "+[0]" in case there are no local entities
-            creation_fct_ptr = new_model_part.CreateNewElement
-        elif entity_type == "condition":
-            max_id_entities = max([cond.Id for cond in root_model_part.Conditions]+[0]) # "+[0]" in case there are no local entities
-            creation_fct_ptr = new_model_part.CreateNewCondition
-        else:
-            raise Exception('"entity_type" "{}" is not valid, only "element" or "condition" are possible!'.format(entity_type))
-
-        # using ScanSum to compute the local Id-start. Otherwise the Ids would start with the same value on every rank
-        data_comm = mp_comm.GetDataCommunicator()
-        scan_sum_nodes = data_comm.ScanSum(len(node_ids))
-        max_id_entities_global = data_comm.MaxAll(max_id_entities)
-        local_id_start = scan_sum_nodes + 1 + max_id_entities_global - len(node_ids)
-
-        for i, node_id in enumerate(node_ids):
-            creation_fct_ptr(entity_name, i+local_id_start, [node_id], props)
-
-        if settings["initialize_communicators"].GetBool() and model_part.IsDistributed():
-            from KratosMultiphysics.mpi import ParallelFillCommunicator
-            ParallelFillCommunicator(model_part, model_part.GetCommunicator().GetDataCommunicator()).Execute()
-
-
-def RecursiveCreateModelParts(model_part, model_part_name):
-    '''This function creates a hierarchy of SubModelParts on a given ModelPart
-    '''
-    model_part_name, *sub_model_part_names = model_part_name.split(".")
-    model_part = model_part.CreateSubModelPart(model_part_name)
-    if len(sub_model_part_names) > 0:
-        model_part = RecursiveCreateModelParts(model_part, ".".join(sub_model_part_names))
-    return model_part
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
+
+# other imports
+from importlib import import_module
+
+
+def Factory(settings, Model):
+    if not isinstance(settings, KM.Parameters):
+        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
+    return CreatePointBasedEntitiesProcess(Model, settings["Parameters"])
+
+
+class CreatePointBasedEntitiesProcess(KM.Process):
+    """This process creates point based entities on the nodes of SubModelPart(s). This process should be used only once per ModelPart to not create the same entities multiple times on the same nodes.
+    It works with restarts as well as in MPI. Also the numbering of the newly created entities is done consistently.
+    """
+
+    def __init__(self, Model, settings ):
+        KM.Process.__init__(self)
+
+        """
+        model_part_name: The name of the MainModelPart for which the entities should be created
+        sub_model_part_names: <optional> Names of the SubModelParts on which the entities should be created. This is needed to not create multiple entities on the same nodes, if model-part are overlapping/contain the same nodes.
+        new_sub_model_part_name: The name of the SubModelPart that will be created as base of MainModelPart. The created entities will be in this ModelPart
+        entity_name: The name of the entities to create
+        entity_type: "condition" or "element"
+        properties_id: Id of the properties to be used for the newly created entities
+        kratos_application: <optional> Application in which the entities to create are implemented, needs to be imported before creating them
+        """
+        default_settings = KM.Parameters("""{
+            "model_part_name"          : "PLEASE_SPECIFY",
+            "sub_model_part_names"     : [],
+            "new_sub_model_part_name"  : "PLEASE_SPECIFY",
+            "entity_name"              : "PointLoadCondition3D1N",
+            "entity_type"              : "condition",
+            "properties_id"            : 0,
+            "kratos_application"       : "",
+            "initialize_communicators" : false
+        }""")
+
+        settings.ValidateAndAssignDefaults(default_settings)
+
+        model_part_name = settings["model_part_name"].GetString()
+        model_part = Model[model_part_name]
+        if model_part.ProcessInfo[KM.IS_RESTARTED]:
+            # Do nothing in case of restart
+            return
+
+        root_model_part = model_part.GetRootModelPart()
+        entity_name = settings["entity_name"].GetString()
+        entity_type = settings["entity_type"].GetString()
+        properties_id = settings["properties_id"].GetInt()
+
+        # importing the Application where the entites are registered (optional)
+        kratos_application = settings["kratos_application"].GetString()
+        if kratos_application != "":
+            if not CheckIfApplicationsAvailable(kratos_application):
+                raise Exception('Application "{}" is not available!'.format(kratos_application))
+            import_module("KratosMultiphysics." + kratos_application) # this registers the entities
+
+        if settings["sub_model_part_names"].size() == 0:
+            # if no sub-model-parts are specified then taking the main-model-part
+            model_parts = [model_part]
+        else:
+            model_parts = [Model[model_part_name+"."+sub_model_part_name] for sub_model_part_name in settings["sub_model_part_names"].GetStringArray()]
+
+        new_model_part = RecursiveCreateModelParts(model_part, settings["new_sub_model_part_name"].GetString())
+
+        node_ids = [node.Id
+            for mp in model_parts
+                for node in mp.GetCommunicator().LocalMesh().Nodes
+        ]
+        node_ids = list(set(node_ids)) # make sure the node-Ids are unique. This is needed to not create multiple entities for the same node
+
+        new_model_part.AddNodes(node_ids)
+
+        props = root_model_part.GetProperties(properties_id)
+        mp_comm = root_model_part.GetCommunicator()
+
+        if entity_type == "element":
+            max_id_entities = max([elem.Id for elem in root_model_part.Elements]+[0]) # "+[0]" in case there are no local entities
+            creation_fct_ptr = new_model_part.CreateNewElement
+        elif entity_type == "condition":
+            max_id_entities = max([cond.Id for cond in root_model_part.Conditions]+[0]) # "+[0]" in case there are no local entities
+            creation_fct_ptr = new_model_part.CreateNewCondition
+        else:
+            raise Exception('"entity_type" "{}" is not valid, only "element" or "condition" are possible!'.format(entity_type))
+
+        # using ScanSum to compute the local Id-start. Otherwise the Ids would start with the same value on every rank
+        data_comm = mp_comm.GetDataCommunicator()
+        scan_sum_nodes = data_comm.ScanSum(len(node_ids))
+        max_id_entities_global = data_comm.MaxAll(max_id_entities)
+        local_id_start = scan_sum_nodes + 1 + max_id_entities_global - len(node_ids)
+
+        for i, node_id in enumerate(node_ids):
+            creation_fct_ptr(entity_name, i+local_id_start, [node_id], props)
+
+        if settings["initialize_communicators"].GetBool() and model_part.IsDistributed():
+            from KratosMultiphysics.mpi import ParallelFillCommunicator
+            ParallelFillCommunicator(model_part, model_part.GetCommunicator().GetDataCommunicator()).Execute()
+
+
+def RecursiveCreateModelParts(model_part, model_part_name):
+    '''This function creates a hierarchy of SubModelParts on a given ModelPart
+    '''
+    model_part_name, *sub_model_part_names = model_part_name.split(".")
+    model_part = model_part.CreateSubModelPart(model_part_name)
+    if len(sub_model_part_names) > 0:
+        model_part = RecursiveCreateModelParts(model_part, ".".join(sub_model_part_names))
+    return model_part
```

## KratosMultiphysics/CoSimulationApplication/predictors/average_value_based.py

 * *Ordering differences only*

```diff
@@ -1,51 +1,51 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_predictor import CoSimulationPredictor
-
-# Other imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-
-# Predictor implemented according to:
-# "A new staggered scheme for fluid-structure interaction"; W.G. Dettmer and D. Peric
-# Numerical Methods in Engineering 2013; 93; 1-22
-
-def Create(settings, solver_wrapper):
-    cs_tools.SettingsTypeCheck(settings)
-    return AverageValuePredictor(settings, solver_wrapper)
-
-class AverageValuePredictor(CoSimulationPredictor):
-    # @param beta factor for weighting last and current value of the predicted values. Can be set in interval: [0, 1.0]
-    def __init__(self, settings, solver_wrapper):
-        super().__init__(settings, solver_wrapper)
-        self.beta = self.settings["beta"].GetDouble()
-        if self.beta > 1.0 or self.beta < 0:
-            raise Exception("Wrong value for beta. Admissible interval [0.0, 1.0]")
-
-    def Predict(self):
-        if not self.interface_data.IsDefinedOnThisRank(): return
-
-        current_data  = self.interface_data.GetData(0)
-        previous_data = self.interface_data.GetData(1)
-
-        self.predicted_data = 2*current_data - previous_data
-
-        self._UpdateData(self.predicted_data)
-
-    def FinalizeSolutionStep(self):
-        if not self.interface_data.IsDefinedOnThisRank(): return
-
-        current_data  = self.interface_data.GetData(0)
-
-        self.predicted_data = self.beta * current_data + (1-self.beta) * self.predicted_data
-
-        self._UpdateData(self.predicted_data)
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "beta"     : 0.5
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_predictor import CoSimulationPredictor
+
+# Other imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+
+# Predictor implemented according to:
+# "A new staggered scheme for fluid-structure interaction"; W.G. Dettmer and D. Peric
+# Numerical Methods in Engineering 2013; 93; 1-22
+
+def Create(settings, solver_wrapper):
+    cs_tools.SettingsTypeCheck(settings)
+    return AverageValuePredictor(settings, solver_wrapper)
+
+class AverageValuePredictor(CoSimulationPredictor):
+    # @param beta factor for weighting last and current value of the predicted values. Can be set in interval: [0, 1.0]
+    def __init__(self, settings, solver_wrapper):
+        super().__init__(settings, solver_wrapper)
+        self.beta = self.settings["beta"].GetDouble()
+        if self.beta > 1.0 or self.beta < 0:
+            raise Exception("Wrong value for beta. Admissible interval [0.0, 1.0]")
+
+    def Predict(self):
+        if not self.interface_data.IsDefinedOnThisRank(): return
+
+        current_data  = self.interface_data.GetData(0)
+        previous_data = self.interface_data.GetData(1)
+
+        self.predicted_data = 2*current_data - previous_data
+
+        self._UpdateData(self.predicted_data)
+
+    def FinalizeSolutionStep(self):
+        if not self.interface_data.IsDefinedOnThisRank(): return
+
+        current_data  = self.interface_data.GetData(0)
+
+        self.predicted_data = self.beta * current_data + (1-self.beta) * self.predicted_data
+
+        self._UpdateData(self.predicted_data)
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "beta"     : 0.5
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
```

## KratosMultiphysics/CoSimulationApplication/predictors/linear_derivative_based.py

 * *Ordering differences only*

```diff
@@ -1,39 +1,39 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_predictor import CoSimulationPredictor
-
-# Other imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-
-def Create(settings, solver_wrapper):
-    cs_tools.SettingsTypeCheck(settings)
-    return LinearDerivativeBasedPredictor(settings, solver_wrapper)
-
-class LinearDerivativeBasedPredictor(CoSimulationPredictor):
-    def __init__(self, settings, solver_wrapper):
-        super().__init__(settings, solver_wrapper)
-        self.interface_derivative_data = solver_wrapper.GetInterfaceData(self.settings["derivative_data_name"].GetString())
-
-    def Predict(self):
-        if not self.interface_data.IsDefinedOnThisRank(): return
-
-        data  = self.interface_data.GetData(1)
-        derivative_data  = self.interface_derivative_data.GetData(1)
-
-        delta_time = self.interface_data.GetModelPart().ProcessInfo[KM.DELTA_TIME]
-        if abs(delta_time) < 1E-15:
-            raise Exception("delta-time is almost zero!")
-
-        data += delta_time * derivative_data
-
-        self._UpdateData(data)
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "derivative_data_name" : "UNSPECIFIED"
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_predictor import CoSimulationPredictor
+
+# Other imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+
+def Create(settings, solver_wrapper):
+    cs_tools.SettingsTypeCheck(settings)
+    return LinearDerivativeBasedPredictor(settings, solver_wrapper)
+
+class LinearDerivativeBasedPredictor(CoSimulationPredictor):
+    def __init__(self, settings, solver_wrapper):
+        super().__init__(settings, solver_wrapper)
+        self.interface_derivative_data = solver_wrapper.GetInterfaceData(self.settings["derivative_data_name"].GetString())
+
+    def Predict(self):
+        if not self.interface_data.IsDefinedOnThisRank(): return
+
+        data  = self.interface_data.GetData(1)
+        derivative_data  = self.interface_derivative_data.GetData(1)
+
+        delta_time = self.interface_data.GetModelPart().ProcessInfo[KM.DELTA_TIME]
+        if abs(delta_time) < 1E-15:
+            raise Exception("delta-time is almost zero!")
+
+        data += delta_time * derivative_data
+
+        self._UpdateData(data)
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "derivative_data_name" : "UNSPECIFIED"
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
```

## KratosMultiphysics/CoSimulationApplication/predictors/linear.py

 * *Ordering differences only*

```diff
@@ -1,20 +1,20 @@
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_predictor import CoSimulationPredictor
-
-# Other imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-
-def Create(settings, solver_wrapper):
-    cs_tools.SettingsTypeCheck(settings)
-    return LinearPredictor(settings, solver_wrapper)
-
-class LinearPredictor(CoSimulationPredictor):
-    def Predict(self):
-        if not self.interface_data.IsDefinedOnThisRank(): return
-
-        current_data  = self.interface_data.GetData(0)
-        previous_data  = self.interface_data.GetData(1)
-
-        predicted_data = 2*current_data - previous_data
-
-        self._UpdateData(predicted_data)
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_predictor import CoSimulationPredictor
+
+# Other imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+
+def Create(settings, solver_wrapper):
+    cs_tools.SettingsTypeCheck(settings)
+    return LinearPredictor(settings, solver_wrapper)
+
+class LinearPredictor(CoSimulationPredictor):
+    def Predict(self):
+        if not self.interface_data.IsDefinedOnThisRank(): return
+
+        current_data  = self.interface_data.GetData(0)
+        previous_data  = self.interface_data.GetData(1)
+
+        predicted_data = 2*current_data - previous_data
+
+        self._UpdateData(predicted_data)
```

## KratosMultiphysics/CoSimulationApplication/MainKratosCoSim.py

 * *Ordering differences only*

```diff
@@ -1,15 +1,15 @@
-import KratosMultiphysics as KM
-from KratosMultiphysics.CoSimulationApplication.co_simulation_analysis import CoSimulationAnalysis
-
-"""
-For user-scripting it is intended that a new class is derived
-from CoSimulationAnalysis to do modifications
-Check also "kratos/python_scripts/analysis-stage.py" for available methods that can be overridden
-"""
-
-parameter_file_name = "ProjectParametersCoSim.json"
-with open(parameter_file_name,'r') as parameter_file:
-    parameters = KM.Parameters(parameter_file.read())
-
-simulation = CoSimulationAnalysis(parameters)
-simulation.Run()
+import KratosMultiphysics as KM
+from KratosMultiphysics.CoSimulationApplication.co_simulation_analysis import CoSimulationAnalysis
+
+"""
+For user-scripting it is intended that a new class is derived
+from CoSimulationAnalysis to do modifications
+Check also "kratos/python_scripts/analysis-stage.py" for available methods that can be overridden
+"""
+
+parameter_file_name = "ProjectParametersCoSim.json"
+with open(parameter_file_name,'r') as parameter_file:
+    parameters = KM.Parameters(parameter_file.read())
+
+simulation = CoSimulationAnalysis(parameters)
+simulation.Run()
```

## KratosMultiphysics/CoSimulationApplication/colors.py

 * *Ordering differences only*

```diff
@@ -1,78 +1,78 @@
-PRINT_COLORS = False # Global var to specify if colors should be printed
-
-def color_string(string2color, color_code):
-    if PRINT_COLORS:
-        return "\x1b["+color_code+"m" + str(string2color) + "\x1b[0m"
-    else:
-        return string2color
-
-def bold(string2color):
-    return color_string(string2color, "1;1")
-def italic(string2color):
-    return color_string(string2color, "1;3")
-def darkify(string2color):
-    return bold(color_string(string2color, "1;2")) # bold is needed bcs it is removed otherwise
-def underline(string2color):
-    return color_string(string2color, "1;4")
-
-def blue(string2color):
-    return color_string(string2color, "1;34")
-def darkblue(string2color):
-    return (darkify(blue(string2color)))
-
-def red(string2color):
-    return color_string(string2color, "1;31")
-def darkred(string2color):
-    return (darkify(red(string2color)))
-
-def green(string2color):
-    return color_string(string2color, "1;32")
-def darkgreen(string2color):
-    return (darkify(green(string2color)))
-
-def yellow(string2color):
-    return color_string(string2color, "1;33")
-def darkyellow(string2color):
-    return (darkify(yellow(string2color)))
-
-def cyan(string2color):
-    return color_string(string2color, "1;36")
-def darkcyan(string2color):
-    return (darkify(cyan(string2color)))
-
-def magenta(string2color):
-    return color_string(string2color, "1;35")
-def darkmagenta(string2color):
-    return (darkify(magenta(string2color)))
-
-if __name__ == "__main__":
-    print("printing all color options:\n")
-
-    str2print = "MyCustomString"
-
-    PRINT_COLORS = True
-
-    print("print:", str2print)
-
-    print("bold:", bold(str2print))
-    print("italic:", italic(str2print))
-    print("darkify:", darkify(str2print))
-    print("underline:", underline(str2print))
-
-    print("blue:", blue(str2print))
-    print("darkblue:", darkblue(str2print))
-
-    print("red:", red(str2print))
-    print("darkred:", darkred(str2print))
-
-    print("green:", green(str2print))
-    print("darkgreen:", darkgreen(str2print))
-
-    print("yellow:", yellow(str2print))
-    print("darkyellow:", darkyellow(str2print))
-
-    print("cyan:", cyan(str2print))
-    print("darkcyan:", darkcyan(str2print))
-
-    print("magenta:", magenta(str2print))
-    print("darkmagenta:", darkmagenta(str2print))
+PRINT_COLORS = False # Global var to specify if colors should be printed
+
+def color_string(string2color, color_code):
+    if PRINT_COLORS:
+        return "\x1b["+color_code+"m" + str(string2color) + "\x1b[0m"
+    else:
+        return string2color
+
+def bold(string2color):
+    return color_string(string2color, "1;1")
+def italic(string2color):
+    return color_string(string2color, "1;3")
+def darkify(string2color):
+    return bold(color_string(string2color, "1;2")) # bold is needed bcs it is removed otherwise
+def underline(string2color):
+    return color_string(string2color, "1;4")
+
+def blue(string2color):
+    return color_string(string2color, "1;34")
+def darkblue(string2color):
+    return (darkify(blue(string2color)))
+
+def red(string2color):
+    return color_string(string2color, "1;31")
+def darkred(string2color):
+    return (darkify(red(string2color)))
+
+def green(string2color):
+    return color_string(string2color, "1;32")
+def darkgreen(string2color):
+    return (darkify(green(string2color)))
+
+def yellow(string2color):
+    return color_string(string2color, "1;33")
+def darkyellow(string2color):
+    return (darkify(yellow(string2color)))
+
+def cyan(string2color):
+    return color_string(string2color, "1;36")
+def darkcyan(string2color):
+    return (darkify(cyan(string2color)))
+
+def magenta(string2color):
+    return color_string(string2color, "1;35")
+def darkmagenta(string2color):
+    return (darkify(magenta(string2color)))
+
+if __name__ == "__main__":
+    print("printing all color options:\n")
+
+    str2print = "MyCustomString"
+
+    PRINT_COLORS = True
+
+    print("print:", str2print)
+
+    print("bold:", bold(str2print))
+    print("italic:", italic(str2print))
+    print("darkify:", darkify(str2print))
+    print("underline:", underline(str2print))
+
+    print("blue:", blue(str2print))
+    print("darkblue:", darkblue(str2print))
+
+    print("red:", red(str2print))
+    print("darkred:", darkred(str2print))
+
+    print("green:", green(str2print))
+    print("darkgreen:", darkgreen(str2print))
+
+    print("yellow:", yellow(str2print))
+    print("darkyellow:", darkyellow(str2print))
+
+    print("cyan:", cyan(str2print))
+    print("darkcyan:", darkcyan(str2print))
+
+    print("magenta:", magenta(str2print))
+    print("darkmagenta:", darkmagenta(str2print))
```

## KratosMultiphysics/CoSimulationApplication/convergence_criteria/convergence_criteria_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,85 +1,85 @@
-# Core imports
-import KratosMultiphysics
-
-# CoSimulation imports
-from KratosMultiphysics.CoSimulationApplication.factories.convergence_criterion_factory import CreateConvergenceCriterion
-from KratosMultiphysics.CoSimulationApplication.coupling_interface_data import CouplingInterfaceData
-import KratosMultiphysics.CoSimulationApplication.colors as colors
-
-# Other imports
-import numpy as np
-
-class ConvergenceCriteriaWrapper:
-    """ @brief This class wraps the convergence criteria such that they can be used "automated".
-        @details This class stores the residual and updates the solutions, such that the
-                 convergence criteria can be configured through JSON.
-                 In case of distributed data, the data is gathered on one rank, the convergence
-                 checked and the result broadcast to the other ranks.
-    """
-    def __init__(self,
-                 settings: KratosMultiphysics.Parameters,
-                 interface_data: CouplingInterfaceData,
-                 parent_coupled_solver_data_communicator: KratosMultiphysics.DataCommunicator):
-        self.interface_data = interface_data
-
-        for key in ("data_name", "solver"):
-            if settings.Has(key):
-                settings.RemoveValue(key)
-
-        if not settings.Has("label"):
-            settings.AddEmptyValue("label").SetString(colors.bold('{}.{}'.format(self.interface_data.solver_name, self.interface_data.name)))
-
-        self.conv_crit = CreateConvergenceCriterion(settings)
-        self.data_communicator = parent_coupled_solver_data_communicator
-
-        self.executing_rank = False
-        if self.interface_data.IsDefinedOnThisRank():
-            self.data_comm = self.interface_data.GetModelPart().GetCommunicator().GetDataCommunicator()
-            self.executing_rank = (self.data_comm.Rank() == 0)
-
-    def Initialize(self):
-        self.conv_crit.Initialize()
-
-    def Finalize(self):
-        self.conv_crit.Finalize()
-
-    def InitializeSolutionStep(self):
-        self.conv_crit.InitializeSolutionStep()
-
-    def FinalizeSolutionStep(self):
-        self.conv_crit.FinalizeSolutionStep()
-
-    def InitializeNonLinearIteration(self):
-        if self.interface_data.IsDefinedOnThisRank():
-            # Saving the previous data for the computation of the residual
-            # and the computation of the solution update
-            self.input_data = self.interface_data.GetData()
-
-        self.conv_crit.InitializeNonLinearIteration()
-
-    def FinalizeNonLinearIteration(self):
-        self.conv_crit.FinalizeNonLinearIteration()
-
-    def IsConverged(self):
-        if self.interface_data.IsDefinedOnThisRank():
-            current_data = self.interface_data.GetData()
-            residual = current_data - self.input_data
-
-            if self.interface_data.IsDistributed():
-                residual = np.array(np.concatenate(self.data_comm.GathervDoubles(residual, 0)))
-                current_data = np.array(np.concatenate(self.data_comm.GathervDoubles(current_data, 0)))
-
-        is_converged = 0
-        if self.executing_rank:
-            is_converged = self.conv_crit.IsConverged(residual, current_data)
-
-        # all ranks of the coupled solver need to know the convergence information
-        is_converged = bool(self.data_communicator.Broadcast(bool(is_converged), 0))
-
-        return is_converged
-
-    def PrintInfo(self):
-        self.conv_crit.PrintInfo()
-
-    def Check(self):
-        self.conv_crit.Check()
+# Core imports
+import KratosMultiphysics
+
+# CoSimulation imports
+from KratosMultiphysics.CoSimulationApplication.factories.convergence_criterion_factory import CreateConvergenceCriterion
+from KratosMultiphysics.CoSimulationApplication.coupling_interface_data import CouplingInterfaceData
+import KratosMultiphysics.CoSimulationApplication.colors as colors
+
+# Other imports
+import numpy as np
+
+class ConvergenceCriteriaWrapper:
+    """ @brief This class wraps the convergence criteria such that they can be used "automated".
+        @details This class stores the residual and updates the solutions, such that the
+                 convergence criteria can be configured through JSON.
+                 In case of distributed data, the data is gathered on one rank, the convergence
+                 checked and the result broadcast to the other ranks.
+    """
+    def __init__(self,
+                 settings: KratosMultiphysics.Parameters,
+                 interface_data: CouplingInterfaceData,
+                 parent_coupled_solver_data_communicator: KratosMultiphysics.DataCommunicator):
+        self.interface_data = interface_data
+
+        for key in ("data_name", "solver"):
+            if settings.Has(key):
+                settings.RemoveValue(key)
+
+        if not settings.Has("label"):
+            settings.AddEmptyValue("label").SetString(colors.bold('{}.{}'.format(self.interface_data.solver_name, self.interface_data.name)))
+
+        self.conv_crit = CreateConvergenceCriterion(settings)
+        self.data_communicator = parent_coupled_solver_data_communicator
+
+        self.executing_rank = False
+        if self.interface_data.IsDefinedOnThisRank():
+            self.data_comm = self.interface_data.GetModelPart().GetCommunicator().GetDataCommunicator()
+            self.executing_rank = (self.data_comm.Rank() == 0)
+
+    def Initialize(self):
+        self.conv_crit.Initialize()
+
+    def Finalize(self):
+        self.conv_crit.Finalize()
+
+    def InitializeSolutionStep(self):
+        self.conv_crit.InitializeSolutionStep()
+
+    def FinalizeSolutionStep(self):
+        self.conv_crit.FinalizeSolutionStep()
+
+    def InitializeNonLinearIteration(self):
+        if self.interface_data.IsDefinedOnThisRank():
+            # Saving the previous data for the computation of the residual
+            # and the computation of the solution update
+            self.input_data = self.interface_data.GetData()
+
+        self.conv_crit.InitializeNonLinearIteration()
+
+    def FinalizeNonLinearIteration(self):
+        self.conv_crit.FinalizeNonLinearIteration()
+
+    def IsConverged(self):
+        if self.interface_data.IsDefinedOnThisRank():
+            current_data = self.interface_data.GetData()
+            residual = current_data - self.input_data
+
+            if self.interface_data.IsDistributed():
+                residual = np.array(np.concatenate(self.data_comm.GathervDoubles(residual, 0)))
+                current_data = np.array(np.concatenate(self.data_comm.GathervDoubles(current_data, 0)))
+
+        is_converged = 0
+        if self.executing_rank:
+            is_converged = self.conv_crit.IsConverged(residual, current_data)
+
+        # all ranks of the coupled solver need to know the convergence information
+        is_converged = bool(self.data_communicator.Broadcast(bool(is_converged), 0))
+
+        return is_converged
+
+    def PrintInfo(self):
+        self.conv_crit.PrintInfo()
+
+    def Check(self):
+        self.conv_crit.Check()
```

## KratosMultiphysics/CoSimulationApplication/convergence_criteria/relative_norm_previous_residual.py

 * *Ordering differences only*

```diff
@@ -1,72 +1,72 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_convergence_criteria import CoSimulationConvergenceCriteria
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-import KratosMultiphysics.CoSimulationApplication.colors as colors
-
-# Other imports
-import numpy as np
-from numpy import linalg as la
-
-def Create(settings):
-    cs_tools.SettingsTypeCheck(settings)
-    return RelativeNormPreviousResidualConvergenceCriteria(settings)
-
-class RelativeNormPreviousResidualConvergenceCriteria(CoSimulationConvergenceCriteria):
-    def __init__(self, settings):
-        super().__init__(settings)
-
-        self.abs_tolerance = self.settings["abs_tolerance"].GetDouble()
-        self.rel_tolerance = self.settings["rel_tolerance"].GetDouble()
-        self.label = self.settings["label"].GetString()
-
-    def IsConverged(self, residual, current_data):
-        res_norm = la.norm(residual)
-        norm_new_data = la.norm(current_data)
-
-        if norm_new_data < 1e-15:
-            norm_new_data = 1.0 # to avoid division by zero
-
-        abs_norm = res_norm / np.sqrt(residual.size)
-        rel_norm = res_norm / norm_new_data
-
-        is_converged = bool(abs_norm < self.abs_tolerance or rel_norm < self.rel_tolerance)
-
-        info_msg = ""
-
-        if self.echo_level > 1:
-            info_msg  = 'Convergence '
-
-            if self.label != "":
-                info_msg += 'for "{}": '.format(self.label)
-
-            if is_converged:
-                info_msg += colors.green("ACHIEVED")
-            else:
-                info_msg += colors.red("NOT ACHIEVED")
-
-        if self.echo_level > 2:
-            info_msg += '\n\t abs-norm = {:.2e} | abs-tol = {} || rel-norm = {:.2e} | rel-tol = {}'.format(abs_norm, self.abs_tolerance, rel_norm, self.rel_tolerance)
-
-        if info_msg != "":
-            cs_tools.cs_print_info(self._ClassName(), info_msg)
-
-        return is_converged
-
-    def Check(self):
-        pass
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "abs_tolerance" : 1e-5,
-            "rel_tolerance" : 1e-5,
-            "label"         : ""
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
-
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_convergence_criteria import CoSimulationConvergenceCriteria
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+import KratosMultiphysics.CoSimulationApplication.colors as colors
+
+# Other imports
+import numpy as np
+from numpy import linalg as la
+
+def Create(settings):
+    cs_tools.SettingsTypeCheck(settings)
+    return RelativeNormPreviousResidualConvergenceCriteria(settings)
+
+class RelativeNormPreviousResidualConvergenceCriteria(CoSimulationConvergenceCriteria):
+    def __init__(self, settings):
+        super().__init__(settings)
+
+        self.abs_tolerance = self.settings["abs_tolerance"].GetDouble()
+        self.rel_tolerance = self.settings["rel_tolerance"].GetDouble()
+        self.label = self.settings["label"].GetString()
+
+    def IsConverged(self, residual, current_data):
+        res_norm = la.norm(residual)
+        norm_new_data = la.norm(current_data)
+
+        if norm_new_data < 1e-15:
+            norm_new_data = 1.0 # to avoid division by zero
+
+        abs_norm = res_norm / np.sqrt(residual.size)
+        rel_norm = res_norm / norm_new_data
+
+        is_converged = bool(abs_norm < self.abs_tolerance or rel_norm < self.rel_tolerance)
+
+        info_msg = ""
+
+        if self.echo_level > 1:
+            info_msg  = 'Convergence '
+
+            if self.label != "":
+                info_msg += 'for "{}": '.format(self.label)
+
+            if is_converged:
+                info_msg += colors.green("ACHIEVED")
+            else:
+                info_msg += colors.red("NOT ACHIEVED")
+
+        if self.echo_level > 2:
+            info_msg += '\n\t abs-norm = {:.2e} | abs-tol = {} || rel-norm = {:.2e} | rel-tol = {}'.format(abs_norm, self.abs_tolerance, rel_norm, self.rel_tolerance)
+
+        if info_msg != "":
+            cs_tools.cs_print_info(self._ClassName(), info_msg)
+
+        return is_converged
+
+    def Check(self):
+        pass
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "abs_tolerance" : 1e-5,
+            "rel_tolerance" : 1e-5,
+            "label"         : ""
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
+
```

## KratosMultiphysics/CoSimulationApplication/convergence_criteria/relative_norm_initial_residual.py

 * *Ordering differences only*

```diff
@@ -1,74 +1,74 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_convergence_criteria import CoSimulationConvergenceCriteria
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-import KratosMultiphysics.CoSimulationApplication.colors as colors
-
-# Other imports
-import numpy as np
-from numpy import linalg as la
-
-def Create(settings):
-    cs_tools.SettingsTypeCheck(settings)
-    return RelativeNormInitialResidualConvergenceCriteria(settings)
-
-class RelativeNormInitialResidualConvergenceCriteria(CoSimulationConvergenceCriteria):
-    def __init__(self, settings):
-        super().__init__(settings)
-
-        self.abs_tolerance = self.settings["abs_tolerance"].GetDouble()
-        self.rel_tolerance = self.settings["rel_tolerance"].GetDouble()
-        self.label = self.settings["label"].GetString()
-
-    def InitializeSolutionStep(self):
-        self.initial_iteration = True
-
-    def IsConverged(self, residual, current_data):
-        abs_norm = la.norm(residual) / np.sqrt(residual.size)
-
-        if self.initial_iteration:
-            self.initial_iteration = False
-            self.initial_norm = abs_norm
-
-        rel_norm = abs_norm / self.initial_norm
-
-        is_converged = bool(abs_norm < self.abs_tolerance or rel_norm < self.rel_tolerance)
-
-        info_msg = ""
-
-        if self.echo_level > 1:
-            info_msg  = 'Convergence '
-
-            if self.label != "":
-                info_msg += 'for "{}": '.format(self.label)
-
-            if is_converged:
-                info_msg += colors.green("ACHIEVED")
-            else:
-                info_msg += colors.red("NOT ACHIEVED")
-
-        if self.echo_level > 2:
-            info_msg += '\n\t abs-norm = {:.2e} | abs-tol = {} || rel-norm = {:.2e} | rel-tol = {}'.format(abs_norm, self.abs_tolerance, rel_norm, self.rel_tolerance)
-
-        if info_msg != "":
-            cs_tools.cs_print_info(self._ClassName(), info_msg)
-
-        return is_converged
-
-    def Check(self):
-        pass
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "abs_tolerance" : 1e-5,
-            "rel_tolerance" : 1e-5,
-            "label"         : ""
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
-
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_convergence_criteria import CoSimulationConvergenceCriteria
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+import KratosMultiphysics.CoSimulationApplication.colors as colors
+
+# Other imports
+import numpy as np
+from numpy import linalg as la
+
+def Create(settings):
+    cs_tools.SettingsTypeCheck(settings)
+    return RelativeNormInitialResidualConvergenceCriteria(settings)
+
+class RelativeNormInitialResidualConvergenceCriteria(CoSimulationConvergenceCriteria):
+    def __init__(self, settings):
+        super().__init__(settings)
+
+        self.abs_tolerance = self.settings["abs_tolerance"].GetDouble()
+        self.rel_tolerance = self.settings["rel_tolerance"].GetDouble()
+        self.label = self.settings["label"].GetString()
+
+    def InitializeSolutionStep(self):
+        self.initial_iteration = True
+
+    def IsConverged(self, residual, current_data):
+        abs_norm = la.norm(residual) / np.sqrt(residual.size)
+
+        if self.initial_iteration:
+            self.initial_iteration = False
+            self.initial_norm = abs_norm
+
+        rel_norm = abs_norm / self.initial_norm
+
+        is_converged = bool(abs_norm < self.abs_tolerance or rel_norm < self.rel_tolerance)
+
+        info_msg = ""
+
+        if self.echo_level > 1:
+            info_msg  = 'Convergence '
+
+            if self.label != "":
+                info_msg += 'for "{}": '.format(self.label)
+
+            if is_converged:
+                info_msg += colors.green("ACHIEVED")
+            else:
+                info_msg += colors.red("NOT ACHIEVED")
+
+        if self.echo_level > 2:
+            info_msg += '\n\t abs-norm = {:.2e} | abs-tol = {} || rel-norm = {:.2e} | rel-tol = {}'.format(abs_norm, self.abs_tolerance, rel_norm, self.rel_tolerance)
+
+        if info_msg != "":
+            cs_tools.cs_print_info(self._ClassName(), info_msg)
+
+        return is_converged
+
+    def Check(self):
+        pass
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "abs_tolerance" : 1e-5,
+            "rel_tolerance" : 1e-5,
+            "label"         : ""
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
+
```

## KratosMultiphysics/CoSimulationApplication/convergence_criteria/absolute_norm_energy_conjugate.py

 * *Ordering differences only*

```diff
@@ -1,132 +1,132 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_convergence_criteria import CoSimulationConvergenceCriteria
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-import KratosMultiphysics.CoSimulationApplication.colors as colors
-
-# Other imports
-from numpy import linalg as la
-
-def Create(settings, solvers):
-    cs_tools.SettingsTypeCheck(settings)
-    return AbsoluteNormResidualConvergenceCriteria(settings, solvers)
-
-class AbsoluteNormResidualConvergenceCriteria(CoSimulationConvergenceCriteria):
-    def __init__(self, settings, solvers):
-        super().__init__(settings)
-
-        if self.settings["criteria_composition"].GetString() != "energy_conjugate":
-            self.__RaiseException('Energy conjugate criteria composition requires energy conjugate variables to be specified in "data_name" and "conjugate_data_name".')
-
-        self.iteration = 1
-        self.abs_tolerance = self.settings["abs_tolerance"].GetDouble()
-        self.ignore_first_convergence = self.settings["ignore_first_convergence"].GetBool()
-
-        # Determine if we are looking at the energy difference between two domains (solvers), or just one
-        self.solver_vec = [solvers[settings["solver"].GetString()]]
-        is_dual_domain = False
-        for criteria_option in settings["criteria_options"]:
-            if criteria_option.GetString() == "domain_difference":
-                is_dual_domain = True
-                break
-        if is_dual_domain:
-            is_error = False
-            if settings.Has("solver_domain_two"):
-                solver_domain_two = settings["solver_domain_two"].GetString()
-                if solver_domain_two == "UNSPECIFIED":
-                    is_error = True
-                else:
-                    self.solver_vec.append(solvers[solver_domain_two])
-            else:
-                is_error = True
-            if is_error:
-                self.__RaiseException('Domain difference requires "solver_domain_two" to be set to the second domain.')
-
-        # Setup interface data matrix (general form)
-        self.interface_data = [None]*len(solvers)
-        for solver_index in range(0,len(self.interface_data)):
-            self.interface_data[solver_index] = [self.solver_vec[solver_index].GetInterfaceData(settings["data_name"].GetString())]
-            self.interface_data[solver_index].append(self.solver_vec[solver_index].GetInterfaceData(settings["conjugate_data_name"].GetString()))
-
-        self.second_domain_data_sign = 1.0
-        if "swap_second_domain_data_sign" in settings["criteria_options"].GetStringArray():
-            self.second_domain_data_sign = -1.0
-
-        settings.RemoveValue("data_name")
-        settings.RemoveValue("solver")
-
-        if not settings.Has("label"):
-            settings.AddEmptyValue("label").SetString(colors.bold('{}.{}'.format(self.interface_data[0][0].solver_name, self.interface_data[0][0].name)))
-        self.label = self.settings["label"].GetString()
-
-    def IsConverged(self):
-        # Compute energy scalar on interface
-        current_data = 0.0
-
-        for solver_index in range(0,len(self.interface_data)):
-            #check length of data vectors are the same
-            interface_energy = 0.0;
-            data_1 = self.interface_data[solver_index][0].GetData()
-            data_2 = self.interface_data[solver_index][1].GetData()
-            if len(data_1) != len(data_2):
-                self.__RaiseException('Data vector lengths for conjugate criteria composition must be identical, but they are different!')
-            else:
-                for i in range(0,len(data_1)):
-                    interface_energy += data_1[i]*data_2[i]
-            if solver_index == 0:
-                current_data = interface_energy
-            else:
-                current_data -= self.second_domain_data_sign*interface_energy #assumes domain_difference
-
-        abs_norm = la.norm(current_data)
-
-        if self.ignore_first_convergence and self.iteration == 1:
-            is_converged = False
-        else:
-            is_converged = abs_norm < self.abs_tolerance
-
-        self.iteration += 1
-
-        info_msg = ""
-
-        if self.echo_level > 1:
-            info_msg  = 'Convergence '
-
-            if self.label != "":
-                info_msg += 'for "{}": '.format(self.label)
-
-            if is_converged:
-                info_msg += colors.green("ACHIEVED")
-            else:
-                info_msg += colors.red("NOT ACHIEVED")
-
-        if self.echo_level > 2:
-            info_msg += '\n\t abs-norm = {:.2e} | abs-tol = {}'.format(abs_norm, self.abs_tolerance)
-
-        if info_msg != "":
-            cs_tools.cs_print_info(self._ClassName(), info_msg)
-
-        return is_converged
-
-    def Check(self):
-        pass
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "abs_tolerance"            : 1e-5,
-            "criteria_options"         : [],
-            "conjugate_data_name"      : "UNSPECIFIED",
-            "solver_domain_two"        : "UNSPECIFIED",
-            "criteria_composition"     : "UNSPECIFIED",
-            "use_wrapper"              : false,
-            "ignore_first_convergence" : false,
-            "label"                    : ""
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
-
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_convergence_criteria import CoSimulationConvergenceCriteria
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+import KratosMultiphysics.CoSimulationApplication.colors as colors
+
+# Other imports
+from numpy import linalg as la
+
+def Create(settings, solvers):
+    cs_tools.SettingsTypeCheck(settings)
+    return AbsoluteNormResidualConvergenceCriteria(settings, solvers)
+
+class AbsoluteNormResidualConvergenceCriteria(CoSimulationConvergenceCriteria):
+    def __init__(self, settings, solvers):
+        super().__init__(settings)
+
+        if self.settings["criteria_composition"].GetString() != "energy_conjugate":
+            self.__RaiseException('Energy conjugate criteria composition requires energy conjugate variables to be specified in "data_name" and "conjugate_data_name".')
+
+        self.iteration = 1
+        self.abs_tolerance = self.settings["abs_tolerance"].GetDouble()
+        self.ignore_first_convergence = self.settings["ignore_first_convergence"].GetBool()
+
+        # Determine if we are looking at the energy difference between two domains (solvers), or just one
+        self.solver_vec = [solvers[settings["solver"].GetString()]]
+        is_dual_domain = False
+        for criteria_option in settings["criteria_options"]:
+            if criteria_option.GetString() == "domain_difference":
+                is_dual_domain = True
+                break
+        if is_dual_domain:
+            is_error = False
+            if settings.Has("solver_domain_two"):
+                solver_domain_two = settings["solver_domain_two"].GetString()
+                if solver_domain_two == "UNSPECIFIED":
+                    is_error = True
+                else:
+                    self.solver_vec.append(solvers[solver_domain_two])
+            else:
+                is_error = True
+            if is_error:
+                self.__RaiseException('Domain difference requires "solver_domain_two" to be set to the second domain.')
+
+        # Setup interface data matrix (general form)
+        self.interface_data = [None]*len(solvers)
+        for solver_index in range(0,len(self.interface_data)):
+            self.interface_data[solver_index] = [self.solver_vec[solver_index].GetInterfaceData(settings["data_name"].GetString())]
+            self.interface_data[solver_index].append(self.solver_vec[solver_index].GetInterfaceData(settings["conjugate_data_name"].GetString()))
+
+        self.second_domain_data_sign = 1.0
+        if "swap_second_domain_data_sign" in settings["criteria_options"].GetStringArray():
+            self.second_domain_data_sign = -1.0
+
+        settings.RemoveValue("data_name")
+        settings.RemoveValue("solver")
+
+        if not settings.Has("label"):
+            settings.AddEmptyValue("label").SetString(colors.bold('{}.{}'.format(self.interface_data[0][0].solver_name, self.interface_data[0][0].name)))
+        self.label = self.settings["label"].GetString()
+
+    def IsConverged(self):
+        # Compute energy scalar on interface
+        current_data = 0.0
+
+        for solver_index in range(0,len(self.interface_data)):
+            #check length of data vectors are the same
+            interface_energy = 0.0;
+            data_1 = self.interface_data[solver_index][0].GetData()
+            data_2 = self.interface_data[solver_index][1].GetData()
+            if len(data_1) != len(data_2):
+                self.__RaiseException('Data vector lengths for conjugate criteria composition must be identical, but they are different!')
+            else:
+                for i in range(0,len(data_1)):
+                    interface_energy += data_1[i]*data_2[i]
+            if solver_index == 0:
+                current_data = interface_energy
+            else:
+                current_data -= self.second_domain_data_sign*interface_energy #assumes domain_difference
+
+        abs_norm = la.norm(current_data)
+
+        if self.ignore_first_convergence and self.iteration == 1:
+            is_converged = False
+        else:
+            is_converged = abs_norm < self.abs_tolerance
+
+        self.iteration += 1
+
+        info_msg = ""
+
+        if self.echo_level > 1:
+            info_msg  = 'Convergence '
+
+            if self.label != "":
+                info_msg += 'for "{}": '.format(self.label)
+
+            if is_converged:
+                info_msg += colors.green("ACHIEVED")
+            else:
+                info_msg += colors.red("NOT ACHIEVED")
+
+        if self.echo_level > 2:
+            info_msg += '\n\t abs-norm = {:.2e} | abs-tol = {}'.format(abs_norm, self.abs_tolerance)
+
+        if info_msg != "":
+            cs_tools.cs_print_info(self._ClassName(), info_msg)
+
+        return is_converged
+
+    def Check(self):
+        pass
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "abs_tolerance"            : 1e-5,
+            "criteria_options"         : [],
+            "conjugate_data_name"      : "UNSPECIFIED",
+            "solver_domain_two"        : "UNSPECIFIED",
+            "criteria_composition"     : "UNSPECIFIED",
+            "use_wrapper"              : false,
+            "ignore_first_convergence" : false,
+            "label"                    : ""
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
+
```

## KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_convergence_accelerator.py

 * *Ordering differences only*

```diff
@@ -1,66 +1,66 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-import KratosMultiphysics.CoSimulationApplication.colors as colors
-
-class CoSimulationConvergenceAccelerator:
-    """Baseclass for the convergence acceleratos used for CoSimulation
-    Relaxes the solution to increase the speed of convergence in a (strongly) coupled simulation
-
-    Note that the interface matches the convergence accelerators in the KratosCore such that they can be used interchangeable
-    ("kratos/solving_strategies/convergence_accelerators/convergence_accelerator.h")
-    """
-    def __init__(self, settings):
-        self.settings = settings
-        self.settings.RecursivelyValidateAndAssignDefaults(self._GetDefaultParameters())
-
-        self.echo_level = self.settings["echo_level"].GetInt()
-
-    def Initialize(self):
-        pass
-
-    def Finalize(self):
-        pass
-
-    def InitializeSolutionStep(self):
-        pass
-
-    def FinalizeSolutionStep(self):
-        pass
-
-    def InitializeNonLinearIteration(self):
-        pass
-
-    def FinalizeNonLinearIteration(self):
-        pass
-
-    def PrintInfo(self):
-        '''Function to print Info abt the Object
-        Can be overridden in derived classes to print more information
-        '''
-        cs_tools.cs_print_info("Convergence Accelerator", colors.bold(self._ClassName()))
-
-    def Check(self):
-        cs_tools.cs_print_warning("Convergence Accelerator", "The convergence accelerators do not yet implement Check!")
-
-    def UpdateSolution(self, residual, iteration_guess):
-        # TODO this should update the solution in place, otherwise not compatible with the conv-acc in the FSI-App
-        # => would probably not be compatible with any C++ Conv-Acc
-        raise NotImplementedError('"UpdateSolution" has to be implemented in the derived class!')
-
-    @classmethod
-    def SupportsDistributedData(cls):
-        return False
-
-    @classmethod
-    def _ClassName(cls):
-        return cls.__name__
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        return KM.Parameters("""{
-            "type"       : "UNSPECIFIED",
-            "echo_level" : 0
-        }""")
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+import KratosMultiphysics.CoSimulationApplication.colors as colors
+
+class CoSimulationConvergenceAccelerator:
+    """Baseclass for the convergence acceleratos used for CoSimulation
+    Relaxes the solution to increase the speed of convergence in a (strongly) coupled simulation
+
+    Note that the interface matches the convergence accelerators in the KratosCore such that they can be used interchangeable
+    ("kratos/solving_strategies/convergence_accelerators/convergence_accelerator.h")
+    """
+    def __init__(self, settings):
+        self.settings = settings
+        self.settings.RecursivelyValidateAndAssignDefaults(self._GetDefaultParameters())
+
+        self.echo_level = self.settings["echo_level"].GetInt()
+
+    def Initialize(self):
+        pass
+
+    def Finalize(self):
+        pass
+
+    def InitializeSolutionStep(self):
+        pass
+
+    def FinalizeSolutionStep(self):
+        pass
+
+    def InitializeNonLinearIteration(self):
+        pass
+
+    def FinalizeNonLinearIteration(self):
+        pass
+
+    def PrintInfo(self):
+        '''Function to print Info abt the Object
+        Can be overridden in derived classes to print more information
+        '''
+        cs_tools.cs_print_info("Convergence Accelerator", colors.bold(self._ClassName()))
+
+    def Check(self):
+        cs_tools.cs_print_warning("Convergence Accelerator", "The convergence accelerators do not yet implement Check!")
+
+    def UpdateSolution(self, residual, iteration_guess):
+        # TODO this should update the solution in place, otherwise not compatible with the conv-acc in the FSI-App
+        # => would probably not be compatible with any C++ Conv-Acc
+        raise NotImplementedError('"UpdateSolution" has to be implemented in the derived class!')
+
+    @classmethod
+    def SupportsDistributedData(cls):
+        return False
+
+    @classmethod
+    def _ClassName(cls):
+        return cls.__name__
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        return KM.Parameters("""{
+            "type"       : "UNSPECIFIED",
+            "echo_level" : 0
+        }""")
```

## KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_coupled_solver.py

 * *Ordering differences only*

```diff
@@ -1,439 +1,439 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.factories.solver_wrapper_factory as solver_wrapper_factory
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-import KratosMultiphysics.CoSimulationApplication.factories.helpers as factories_helper
-import KratosMultiphysics.CoSimulationApplication.colors as colors
-from KratosMultiphysics.CoSimulationApplication.coupling_interface_data import BaseCouplingInterfaceData
-
-# Other imports
-from collections import OrderedDict
-
-class UndefinedSolver:
-    def __init__(self, name, settings):
-        self.name = name
-        self.settings = settings
-
-    def Initialize(self):
-        if self.settings.Has("data"):
-            self.data_dict = {data_name : BaseCouplingInterfaceData(data_config, data_name, self.name) for (data_name, data_config) in self.settings["data"].items()}
-        else:
-            self.data_dict = {}
-
-    def IsDefinedOnThisRank(self):
-        return False
-
-    def GetInterfaceData(self, data_name):
-        try:
-            return self.data_dict[data_name]
-        except KeyError:
-            raise Exception('Requested data field "{}" does not exist for solver "{}"'.format(data_name, self.name))
-
-    def AdvanceInTime(*args): return 0.0
-
-    def __getattr__(self, attr):
-        return lambda *args : None
-
-class CoSimulationCoupledSolver(CoSimulationSolverWrapper):
-    """Baseclass for the coupled solvers used for CoSimulation
-    Performs basic operations that are common among coupled solvers:
-    - holds Predictors
-    - holds DataTransferOperators
-    - holds CouplingOperations
-    - initialization of IOs of solvers
-    - Synchronization of Input and Output
-    - Handles the coupling sequence
-    """
-    def __init__(self, settings, models, solver_name):
-        # perform some initial checks
-        if not settings.Has("coupling_sequence"):
-            err_msg  = 'No "coupling_sequence" was specified for coupled solver\n'
-            err_msg += '"{}" of type "{}"'.format(solver_name, self._ClassName())
-            raise Exception(err_msg)
-
-        if settings["coupling_sequence"].size() == 0:
-            err_msg  = '"coupling_sequence" is empty for coupled solver\n'
-            err_msg += '"{}" of type "{}"'.format(solver_name, self._ClassName())
-            raise Exception(err_msg)
-
-        if not settings.Has("solvers"):
-            err_msg  = 'No "solvers" are specified for coupled solver\n'
-            err_msg += '"{}" of type "{}"'.format(solver_name, self._ClassName())
-            raise Exception(err_msg)
-
-        if len(settings["solvers"].keys()) == 0:
-            err_msg  = '"solvers" is empty for coupled solver\n'
-            err_msg += '"{}" of type "{}"'.format(solver_name, self._ClassName())
-            raise Exception(err_msg)
-
-        if not isinstance(models, dict) and not models is None:
-            err_msg  = 'A coupled solver can either be passed a dict of Models\n'
-            err_msg += 'or None, got object of type "{}"'.format(type(models))
-            raise Exception(err_msg)
-
-        super().__init__(settings, None, solver_name)
-
-        self.process_info = KM.ProcessInfo()
-
-        # TODO initialize this in a restart
-        self.process_info[KM.STEP] = 0
-        self.process_info[KM.TIME] = 0.0
-        self.process_info[KM.IS_RESTARTED] = False
-
-        self.solver_wrappers = self.__CreateSolverWrappers(models)
-
-        # overwriting the Model created in the BaseClass
-        # CoupledSolvers only forward calls to its solvers
-        # this is done with the ModelAccessor
-        self.model = ModelAccessor(self.solver_wrappers)
-
-        self.coupling_sequence = self.__GetSolverCoSimulationDetails()
-
-        for solver in self.solver_wrappers.values():
-            solver.CreateIO(self.echo_level)
-            # using the echo_level of the coupled solver, since IO is needed by the coupling
-
-    def _GetSolver(self, solver_name):
-        solver_name, *sub_solver_names = solver_name.split(".")
-        solver = self.solver_wrappers[solver_name]
-        if len(sub_solver_names) > 0:
-            return solver._GetSolver(".".join(sub_solver_names))
-        else:
-            return solver
-
-    def Initialize(self):
-        for solver in self.solver_wrappers.values():
-            solver.Initialize()
-
-        super().Initialize()
-
-        ### Creating the predictors
-        self.predictors_list = factories_helper.CreatePredictors(
-            self.settings["predictors"],
-            self.solver_wrappers,
-            self.echo_level)
-
-        ### Creating the coupling operations
-        self.coupling_operations_dict = factories_helper.CreateCouplingOperations(
-            self.settings["coupling_operations"],
-            self.solver_wrappers,
-            self.process_info,
-            self.data_communicator,
-            self.echo_level)
-
-        ### Creating the data transfer operators
-        self.data_transfer_operators_dict = factories_helper.CreateDataTransferOperators(
-            self.settings["data_transfer_operators"],
-            self.data_communicator,
-            self.echo_level)
-
-        for predictor in self.predictors_list:
-            predictor.Initialize()
-
-        for coupling_operation in self.coupling_operations_dict.values():
-            coupling_operation.Initialize()
-
-    def Finalize(self):
-        super().Finalize()
-
-        for solver in self.solver_wrappers.values():
-            solver.Finalize()
-
-        for predictor in self.predictors_list:
-            predictor.Finalize()
-
-        for coupling_operation in self.coupling_operations_dict.values():
-            coupling_operation.Finalize()
-
-    def AdvanceInTime(self, current_time):
-        # not all solvers provide time (e.g. external solvers or steady solvers)
-        # hence we have to check first if they return time (i.e. time != 0.0)
-        # and then if the times are matching, since currently no interpolation in time is possible
-
-        self.time = 0.0
-        for solver in self.solver_wrappers.values():
-            # TODO maybe do a check to make sure all ranks have the same time?
-            solver_time = self.data_communicator.MaxAll(solver.AdvanceInTime(current_time))
-            if solver_time != 0.0: # solver provides time
-                if self.time == 0.0: # first time a solver returns a time different from 0.0
-                    self.time = solver_time
-                elif abs(self.time - solver_time) > 1e-12:
-                        raise Exception("Solver time mismatch")
-
-        self.process_info[KM.TIME] = self.time
-        self.process_info[KM.STEP] += 1
-
-        return self.time
-
-    def Predict(self):
-        for predictor in self.predictors_list:
-            predictor.Predict()
-
-        for solver in self.solver_wrappers.values():
-            solver.Predict()
-
-    def InitializeSolutionStep(self):
-        for solver in self.solver_wrappers.values():
-            solver.InitializeSolutionStep()
-
-        for predictor in self.predictors_list:
-            predictor.InitializeSolutionStep()
-
-        for coupling_operation in self.coupling_operations_dict.values():
-            coupling_operation.InitializeSolutionStep()
-
-    def FinalizeSolutionStep(self):
-        for solver in self.solver_wrappers.values():
-            solver.FinalizeSolutionStep()
-
-        for predictor in self.predictors_list:
-            predictor.FinalizeSolutionStep()
-
-        for coupling_operation in self.coupling_operations_dict.values():
-            coupling_operation.FinalizeSolutionStep()
-
-    def OutputSolutionStep(self):
-        for solver in self.solver_wrappers.values():
-            solver.OutputSolutionStep()
-
-    def SolveSolutionStep(self):
-        err_msg  = 'Calling "SolveSolutionStep" of the "CoSimulationCoupledSolver"!\n'
-        err_msg += 'This function has to be implemented in the derived class!'
-        raise Exception(err_msg)
-
-    def _SynchronizeInputData(self, solver_name):
-        data_list = self.coupling_sequence[solver_name]["input_data_list"]
-        if self.echo_level > 2:
-            cs_tools.cs_print_info(self._ClassName(), 'Start Synchronizing Input for solver "{}"'.format(colors.blue(solver_name)))
-
-        for i in range(data_list.size()):
-            i_data = data_list[i]
-
-            to_data_name = i_data["data"].GetString()
-            from_solver_name = i_data["from_solver"].GetString()
-            from_solver_data_name = i_data["from_solver_data"].GetString()
-
-            if self.echo_level > 2:
-                cs_tools.cs_print_info("  Data", '"{}" | from solver: "{}": "{}"'.format(colors.magenta(to_data_name), colors.blue(from_solver_name), colors.magenta(from_solver_data_name)))
-
-            # from solver
-            from_solver_data = self.__GetInterfaceDataFromSolver(from_solver_name, from_solver_data_name)
-
-            # to solver
-            to_solver_data = self.__GetInterfaceDataFromSolver(solver_name, to_data_name)
-
-            self.__SynchronizeData(i_data, from_solver_data, to_solver_data)
-
-        if self.echo_level > 2:
-            cs_tools.cs_print_info(self._ClassName(), 'End Synchronizing Input for solver "{}"'.format(colors.blue(solver_name)))
-
-    def _SynchronizeOutputData(self, solver_name):
-        data_list = self.coupling_sequence[solver_name]["output_data_list"]
-        if self.echo_level > 2:
-            cs_tools.cs_print_info(self._ClassName(), 'Start Synchronizing Output for solver "{}"'.format(colors.blue(solver_name)))
-
-        for i in range(data_list.size()):
-            i_data = data_list[i]
-
-            from_data_name = i_data["data"].GetString()
-            to_solver_name = i_data["to_solver"].GetString()
-
-            to_solver_data_name = i_data["to_solver_data"].GetString()
-
-            if self.echo_level > 2:
-                cs_tools.cs_print_info("  Data", '"{}" | to solver: "{}": "{}"'.format(colors.magenta(from_data_name), colors.blue(to_solver_name), colors.magenta(to_solver_data_name)))
-
-            # from solver
-            from_solver_data = self.__GetInterfaceDataFromSolver(solver_name, from_data_name)
-
-            # to solver
-            to_solver_data = self.__GetInterfaceDataFromSolver(to_solver_name, to_solver_data_name)
-
-            self.__SynchronizeData(i_data, from_solver_data, to_solver_data)
-
-        if self.echo_level > 2:
-            cs_tools.cs_print_info(self._ClassName(), 'End Synchronizing Output for solver "{}"'.format(colors.blue(solver_name)))
-
-    def __SynchronizeData(self, i_data, from_solver_data, to_solver_data):
-        # Check if data-exchange is specified for current time
-        if not KM.IntervalUtility(i_data).IsInInterval(self.time):
-            if self.echo_level > 2:
-                cs_tools.cs_print_info("  Skipped", 'not in interval')
-            return
-
-        # Perform the data transfer
-        self.__ExecuteCouplingOperations(i_data["before_data_transfer_operations"])
-
-        data_transfer_operator_name = i_data["data_transfer_operator"].GetString()
-        # TODO check the order of solvers!
-        self.__GetDataTransferOperator(data_transfer_operator_name).TransferData(from_solver_data, to_solver_data, i_data["data_transfer_operator_options"])
-
-        self.__ExecuteCouplingOperations(i_data["after_data_transfer_operations"])
-
-    def __GetInterfaceDataFromSolver(self, solver_name, interface_data_name):
-        solver = self.solver_wrappers[solver_name]
-        return solver.GetInterfaceData(interface_data_name)
-
-    def __GetDataTransferOperator(self, data_transfer_operator_name):
-        try:
-            return self.data_transfer_operators_dict[data_transfer_operator_name]
-        except KeyError:
-            raise NameError('The data-transfer-operator "{}" does not exist!'.format(data_transfer_operator_name))
-
-    def __ExecuteCouplingOperations(self, settings):
-        for coupling_operation_name in settings.GetStringArray():
-            self.coupling_operations_dict[coupling_operation_name].Execute()
-
-    def PrintInfo(self):
-        super().PrintInfo()
-
-        cs_tools.cs_print_info(self._ClassName(), "Has the following components:")
-        for solver in self.solver_wrappers.values():
-            solver.PrintInfo()
-
-        for predictor in self.predictors_list:
-            predictor.PrintInfo()
-
-        for coupling_operation in self.coupling_operations_dict.values():
-            coupling_operation.PrintInfo()
-
-    def Check(self):
-        # TODO check that there is no self-communication with the same data!
-        # self-communication is allowed within a solver, but not on the same data
-        super().Check()
-
-        for solver in self.solver_wrappers.values():
-            solver.Check()
-
-        for predictor in self.predictors_list:
-            predictor.Check()
-
-        for coupling_operation in self.coupling_operations_dict.values():
-            coupling_operation.Check()
-
-    def __CreateSolverWrappers(self, models):
-        # first create all solvers
-        solvers = {}
-        for solver_name, solver_settings in self.settings["solvers"].items():
-            if models == None:
-                solver_model = None
-            else:
-                solver_model = models.get(solver_name) # returns None if "solver_name" is not in models
-            solvers[solver_name] = solver_wrapper_factory.CreateSolverWrapper(solver_settings, solver_model, solver_name)
-
-        # then order them according to the coupling-loop
-        solvers_map = OrderedDict()
-        for i_solver_settings in range(self.settings["coupling_sequence"].size()):
-            solver_settings = self.settings["coupling_sequence"][i_solver_settings]
-            solver_name = solver_settings["name"].GetString()
-            solver = solvers[solver_name]
-            if solver.IsDefinedOnThisRank():
-                solvers_map[solver_name] = solvers[solver_name]
-            else:
-                solvers_map[solver_name] = UndefinedSolver(solver_name, self.settings["solvers"][solver_name])
-
-        for solver_name in self.settings["solvers"].keys():
-            if solver_name not in solvers_map:
-                err_msg  = 'Solver "{}" of type "{}"\n'.format(solver_name, solvers[solver_name]._ClassName())
-                err_msg += 'is specified in the "solvers" of coupled solver\n'
-                err_msg += '"{}" of type "{}"\n'.format(self.name, self._ClassName())
-                err_msg += 'but not used in the "coupling_sequence"!'
-                raise Exception(err_msg)
-
-        if models != None:
-            for solver_name in models.keys():
-                if solver_name not in solvers_map:
-                    raise Exception('A Model was given for solver "{}" but this solver does not exist!'.format(solver_name))
-
-        return solvers_map
-
-    def __GetSolverCoSimulationDetails(self):
-        def ValidateAndAssignDefaultsDataList(data_list, defaults):
-            for i_data_list in range(data_list.size()):
-                cur_data = data_list[i_data_list]
-
-                # doing some tricks since the type of "scaling_factor" can be double or string and hence would fail in the validation
-                scaling_function_string = None
-                if cur_data.Has("scaling_factor") and cur_data["scaling_factor"].IsString():
-                    scaling_function_string = cur_data["scaling_factor"].GetString()
-                    cur_data.RemoveValue("scaling_factor")
-
-                cur_data.ValidateAndAssignDefaults(defaults)
-
-                if scaling_function_string is not None:
-                    cur_data["scaling_factor"].SetString(scaling_function_string)
-
-        solver_cosim_details = {}
-        for i_solver_settings in range(self.settings["coupling_sequence"].size()):
-            solver_settings = self.settings["coupling_sequence"][i_solver_settings]
-            solver_name = solver_settings["name"].GetString()
-            solver_cosim_details[solver_name] = solver_settings
-
-            ValidateAndAssignDefaultsDataList(solver_settings["input_data_list"], GetInputDataDefaults())
-            ValidateAndAssignDefaultsDataList(solver_settings["output_data_list"], GetOutputDataDefaults())
-
-        return solver_cosim_details
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "coupling_sequence"        : [],
-            "solvers"                  : {},
-            "predictors"               : [],
-            "coupling_operations"      : {},
-            "data_transfer_operators"  : {}
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-
-        return this_defaults
-
-def GetInputDataDefaults():
-    return KM.Parameters("""{
-        "data"                            : "UNSPECIFIED",
-        "from_solver"                     : "UNSPECIFIED",
-        "from_solver_data"                : "UNSPECIFIED",
-        "data_transfer_operator"          : "UNSPECIFIED",
-        "data_transfer_operator_options"  : [],
-        "before_data_transfer_operations" : [],
-        "after_data_transfer_operations"  : [],
-        "interval"                        : [0.0, 1e30]
-    }""")
-
-def GetOutputDataDefaults():
-    return KM.Parameters("""{
-        "data"                            : "UNSPECIFIED",
-        "to_solver"                       : "UNSPECIFIED",
-        "to_solver_data"                  : "UNSPECIFIED",
-        "data_transfer_operator"          : "UNSPECIFIED",
-        "data_transfer_operator_options"  : [],
-        "before_data_transfer_operations" : [],
-        "after_data_transfer_operations"  : [],
-        "interval"                        : [0.0, 1e30]
-    }""")
-
-
-class ModelAccessor(object):
-    """Intermediate class for redirecting the access to the Models
-    to the solvers of the CoupledSolver
-    """
-    def __init__(self, solver_wrappers):
-        self.solver_wrappers = solver_wrappers
-
-    def __getitem__(self, key):
-        splitted_key = key.split('.')
-
-        if key == "":
-            raise Exception("No solver_name was specified!")
-        elif key.count('.') == 0:
-            # if only the solver name was given then return the Model itself
-            return self.solver_wrappers[splitted_key[0]].model
-
-        solver_name, model_part_name = key.split('.', 1)
-        # note that model_part_name can still include solver-names in a multicoupling scenario
-
-        return self.solver_wrappers[solver_name].model[model_part_name]
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.factories.solver_wrapper_factory as solver_wrapper_factory
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+import KratosMultiphysics.CoSimulationApplication.factories.helpers as factories_helper
+import KratosMultiphysics.CoSimulationApplication.colors as colors
+from KratosMultiphysics.CoSimulationApplication.coupling_interface_data import BaseCouplingInterfaceData
+
+# Other imports
+from collections import OrderedDict
+
+class UndefinedSolver:
+    def __init__(self, name, settings):
+        self.name = name
+        self.settings = settings
+
+    def Initialize(self):
+        if self.settings.Has("data"):
+            self.data_dict = {data_name : BaseCouplingInterfaceData(data_config, data_name, self.name) for (data_name, data_config) in self.settings["data"].items()}
+        else:
+            self.data_dict = {}
+
+    def IsDefinedOnThisRank(self):
+        return False
+
+    def GetInterfaceData(self, data_name):
+        try:
+            return self.data_dict[data_name]
+        except KeyError:
+            raise Exception('Requested data field "{}" does not exist for solver "{}"'.format(data_name, self.name))
+
+    def AdvanceInTime(*args): return 0.0
+
+    def __getattr__(self, attr):
+        return lambda *args : None
+
+class CoSimulationCoupledSolver(CoSimulationSolverWrapper):
+    """Baseclass for the coupled solvers used for CoSimulation
+    Performs basic operations that are common among coupled solvers:
+    - holds Predictors
+    - holds DataTransferOperators
+    - holds CouplingOperations
+    - initialization of IOs of solvers
+    - Synchronization of Input and Output
+    - Handles the coupling sequence
+    """
+    def __init__(self, settings, models, solver_name):
+        # perform some initial checks
+        if not settings.Has("coupling_sequence"):
+            err_msg  = 'No "coupling_sequence" was specified for coupled solver\n'
+            err_msg += '"{}" of type "{}"'.format(solver_name, self._ClassName())
+            raise Exception(err_msg)
+
+        if settings["coupling_sequence"].size() == 0:
+            err_msg  = '"coupling_sequence" is empty for coupled solver\n'
+            err_msg += '"{}" of type "{}"'.format(solver_name, self._ClassName())
+            raise Exception(err_msg)
+
+        if not settings.Has("solvers"):
+            err_msg  = 'No "solvers" are specified for coupled solver\n'
+            err_msg += '"{}" of type "{}"'.format(solver_name, self._ClassName())
+            raise Exception(err_msg)
+
+        if len(settings["solvers"].keys()) == 0:
+            err_msg  = '"solvers" is empty for coupled solver\n'
+            err_msg += '"{}" of type "{}"'.format(solver_name, self._ClassName())
+            raise Exception(err_msg)
+
+        if not isinstance(models, dict) and not models is None:
+            err_msg  = 'A coupled solver can either be passed a dict of Models\n'
+            err_msg += 'or None, got object of type "{}"'.format(type(models))
+            raise Exception(err_msg)
+
+        super().__init__(settings, None, solver_name)
+
+        self.process_info = KM.ProcessInfo()
+
+        # TODO initialize this in a restart
+        self.process_info[KM.STEP] = 0
+        self.process_info[KM.TIME] = 0.0
+        self.process_info[KM.IS_RESTARTED] = False
+
+        self.solver_wrappers = self.__CreateSolverWrappers(models)
+
+        # overwriting the Model created in the BaseClass
+        # CoupledSolvers only forward calls to its solvers
+        # this is done with the ModelAccessor
+        self.model = ModelAccessor(self.solver_wrappers)
+
+        self.coupling_sequence = self.__GetSolverCoSimulationDetails()
+
+        for solver in self.solver_wrappers.values():
+            solver.CreateIO(self.echo_level)
+            # using the echo_level of the coupled solver, since IO is needed by the coupling
+
+    def _GetSolver(self, solver_name):
+        solver_name, *sub_solver_names = solver_name.split(".")
+        solver = self.solver_wrappers[solver_name]
+        if len(sub_solver_names) > 0:
+            return solver._GetSolver(".".join(sub_solver_names))
+        else:
+            return solver
+
+    def Initialize(self):
+        for solver in self.solver_wrappers.values():
+            solver.Initialize()
+
+        super().Initialize()
+
+        ### Creating the predictors
+        self.predictors_list = factories_helper.CreatePredictors(
+            self.settings["predictors"],
+            self.solver_wrappers,
+            self.echo_level)
+
+        ### Creating the coupling operations
+        self.coupling_operations_dict = factories_helper.CreateCouplingOperations(
+            self.settings["coupling_operations"],
+            self.solver_wrappers,
+            self.process_info,
+            self.data_communicator,
+            self.echo_level)
+
+        ### Creating the data transfer operators
+        self.data_transfer_operators_dict = factories_helper.CreateDataTransferOperators(
+            self.settings["data_transfer_operators"],
+            self.data_communicator,
+            self.echo_level)
+
+        for predictor in self.predictors_list:
+            predictor.Initialize()
+
+        for coupling_operation in self.coupling_operations_dict.values():
+            coupling_operation.Initialize()
+
+    def Finalize(self):
+        super().Finalize()
+
+        for solver in self.solver_wrappers.values():
+            solver.Finalize()
+
+        for predictor in self.predictors_list:
+            predictor.Finalize()
+
+        for coupling_operation in self.coupling_operations_dict.values():
+            coupling_operation.Finalize()
+
+    def AdvanceInTime(self, current_time):
+        # not all solvers provide time (e.g. external solvers or steady solvers)
+        # hence we have to check first if they return time (i.e. time != 0.0)
+        # and then if the times are matching, since currently no interpolation in time is possible
+
+        self.time = 0.0
+        for solver in self.solver_wrappers.values():
+            # TODO maybe do a check to make sure all ranks have the same time?
+            solver_time = self.data_communicator.MaxAll(solver.AdvanceInTime(current_time))
+            if solver_time != 0.0: # solver provides time
+                if self.time == 0.0: # first time a solver returns a time different from 0.0
+                    self.time = solver_time
+                elif abs(self.time - solver_time) > 1e-12:
+                        raise Exception("Solver time mismatch")
+
+        self.process_info[KM.TIME] = self.time
+        self.process_info[KM.STEP] += 1
+
+        return self.time
+
+    def Predict(self):
+        for predictor in self.predictors_list:
+            predictor.Predict()
+
+        for solver in self.solver_wrappers.values():
+            solver.Predict()
+
+    def InitializeSolutionStep(self):
+        for solver in self.solver_wrappers.values():
+            solver.InitializeSolutionStep()
+
+        for predictor in self.predictors_list:
+            predictor.InitializeSolutionStep()
+
+        for coupling_operation in self.coupling_operations_dict.values():
+            coupling_operation.InitializeSolutionStep()
+
+    def FinalizeSolutionStep(self):
+        for solver in self.solver_wrappers.values():
+            solver.FinalizeSolutionStep()
+
+        for predictor in self.predictors_list:
+            predictor.FinalizeSolutionStep()
+
+        for coupling_operation in self.coupling_operations_dict.values():
+            coupling_operation.FinalizeSolutionStep()
+
+    def OutputSolutionStep(self):
+        for solver in self.solver_wrappers.values():
+            solver.OutputSolutionStep()
+
+    def SolveSolutionStep(self):
+        err_msg  = 'Calling "SolveSolutionStep" of the "CoSimulationCoupledSolver"!\n'
+        err_msg += 'This function has to be implemented in the derived class!'
+        raise Exception(err_msg)
+
+    def _SynchronizeInputData(self, solver_name):
+        data_list = self.coupling_sequence[solver_name]["input_data_list"]
+        if self.echo_level > 2:
+            cs_tools.cs_print_info(self._ClassName(), 'Start Synchronizing Input for solver "{}"'.format(colors.blue(solver_name)))
+
+        for i in range(data_list.size()):
+            i_data = data_list[i]
+
+            to_data_name = i_data["data"].GetString()
+            from_solver_name = i_data["from_solver"].GetString()
+            from_solver_data_name = i_data["from_solver_data"].GetString()
+
+            if self.echo_level > 2:
+                cs_tools.cs_print_info("  Data", '"{}" | from solver: "{}": "{}"'.format(colors.magenta(to_data_name), colors.blue(from_solver_name), colors.magenta(from_solver_data_name)))
+
+            # from solver
+            from_solver_data = self.__GetInterfaceDataFromSolver(from_solver_name, from_solver_data_name)
+
+            # to solver
+            to_solver_data = self.__GetInterfaceDataFromSolver(solver_name, to_data_name)
+
+            self.__SynchronizeData(i_data, from_solver_data, to_solver_data)
+
+        if self.echo_level > 2:
+            cs_tools.cs_print_info(self._ClassName(), 'End Synchronizing Input for solver "{}"'.format(colors.blue(solver_name)))
+
+    def _SynchronizeOutputData(self, solver_name):
+        data_list = self.coupling_sequence[solver_name]["output_data_list"]
+        if self.echo_level > 2:
+            cs_tools.cs_print_info(self._ClassName(), 'Start Synchronizing Output for solver "{}"'.format(colors.blue(solver_name)))
+
+        for i in range(data_list.size()):
+            i_data = data_list[i]
+
+            from_data_name = i_data["data"].GetString()
+            to_solver_name = i_data["to_solver"].GetString()
+
+            to_solver_data_name = i_data["to_solver_data"].GetString()
+
+            if self.echo_level > 2:
+                cs_tools.cs_print_info("  Data", '"{}" | to solver: "{}": "{}"'.format(colors.magenta(from_data_name), colors.blue(to_solver_name), colors.magenta(to_solver_data_name)))
+
+            # from solver
+            from_solver_data = self.__GetInterfaceDataFromSolver(solver_name, from_data_name)
+
+            # to solver
+            to_solver_data = self.__GetInterfaceDataFromSolver(to_solver_name, to_solver_data_name)
+
+            self.__SynchronizeData(i_data, from_solver_data, to_solver_data)
+
+        if self.echo_level > 2:
+            cs_tools.cs_print_info(self._ClassName(), 'End Synchronizing Output for solver "{}"'.format(colors.blue(solver_name)))
+
+    def __SynchronizeData(self, i_data, from_solver_data, to_solver_data):
+        # Check if data-exchange is specified for current time
+        if not KM.IntervalUtility(i_data).IsInInterval(self.time):
+            if self.echo_level > 2:
+                cs_tools.cs_print_info("  Skipped", 'not in interval')
+            return
+
+        # Perform the data transfer
+        self.__ExecuteCouplingOperations(i_data["before_data_transfer_operations"])
+
+        data_transfer_operator_name = i_data["data_transfer_operator"].GetString()
+        # TODO check the order of solvers!
+        self.__GetDataTransferOperator(data_transfer_operator_name).TransferData(from_solver_data, to_solver_data, i_data["data_transfer_operator_options"])
+
+        self.__ExecuteCouplingOperations(i_data["after_data_transfer_operations"])
+
+    def __GetInterfaceDataFromSolver(self, solver_name, interface_data_name):
+        solver = self.solver_wrappers[solver_name]
+        return solver.GetInterfaceData(interface_data_name)
+
+    def __GetDataTransferOperator(self, data_transfer_operator_name):
+        try:
+            return self.data_transfer_operators_dict[data_transfer_operator_name]
+        except KeyError:
+            raise NameError('The data-transfer-operator "{}" does not exist!'.format(data_transfer_operator_name))
+
+    def __ExecuteCouplingOperations(self, settings):
+        for coupling_operation_name in settings.GetStringArray():
+            self.coupling_operations_dict[coupling_operation_name].Execute()
+
+    def PrintInfo(self):
+        super().PrintInfo()
+
+        cs_tools.cs_print_info(self._ClassName(), "Has the following components:")
+        for solver in self.solver_wrappers.values():
+            solver.PrintInfo()
+
+        for predictor in self.predictors_list:
+            predictor.PrintInfo()
+
+        for coupling_operation in self.coupling_operations_dict.values():
+            coupling_operation.PrintInfo()
+
+    def Check(self):
+        # TODO check that there is no self-communication with the same data!
+        # self-communication is allowed within a solver, but not on the same data
+        super().Check()
+
+        for solver in self.solver_wrappers.values():
+            solver.Check()
+
+        for predictor in self.predictors_list:
+            predictor.Check()
+
+        for coupling_operation in self.coupling_operations_dict.values():
+            coupling_operation.Check()
+
+    def __CreateSolverWrappers(self, models):
+        # first create all solvers
+        solvers = {}
+        for solver_name, solver_settings in self.settings["solvers"].items():
+            if models == None:
+                solver_model = None
+            else:
+                solver_model = models.get(solver_name) # returns None if "solver_name" is not in models
+            solvers[solver_name] = solver_wrapper_factory.CreateSolverWrapper(solver_settings, solver_model, solver_name)
+
+        # then order them according to the coupling-loop
+        solvers_map = OrderedDict()
+        for i_solver_settings in range(self.settings["coupling_sequence"].size()):
+            solver_settings = self.settings["coupling_sequence"][i_solver_settings]
+            solver_name = solver_settings["name"].GetString()
+            solver = solvers[solver_name]
+            if solver.IsDefinedOnThisRank():
+                solvers_map[solver_name] = solvers[solver_name]
+            else:
+                solvers_map[solver_name] = UndefinedSolver(solver_name, self.settings["solvers"][solver_name])
+
+        for solver_name in self.settings["solvers"].keys():
+            if solver_name not in solvers_map:
+                err_msg  = 'Solver "{}" of type "{}"\n'.format(solver_name, solvers[solver_name]._ClassName())
+                err_msg += 'is specified in the "solvers" of coupled solver\n'
+                err_msg += '"{}" of type "{}"\n'.format(self.name, self._ClassName())
+                err_msg += 'but not used in the "coupling_sequence"!'
+                raise Exception(err_msg)
+
+        if models != None:
+            for solver_name in models.keys():
+                if solver_name not in solvers_map:
+                    raise Exception('A Model was given for solver "{}" but this solver does not exist!'.format(solver_name))
+
+        return solvers_map
+
+    def __GetSolverCoSimulationDetails(self):
+        def ValidateAndAssignDefaultsDataList(data_list, defaults):
+            for i_data_list in range(data_list.size()):
+                cur_data = data_list[i_data_list]
+
+                # doing some tricks since the type of "scaling_factor" can be double or string and hence would fail in the validation
+                scaling_function_string = None
+                if cur_data.Has("scaling_factor") and cur_data["scaling_factor"].IsString():
+                    scaling_function_string = cur_data["scaling_factor"].GetString()
+                    cur_data.RemoveValue("scaling_factor")
+
+                cur_data.ValidateAndAssignDefaults(defaults)
+
+                if scaling_function_string is not None:
+                    cur_data["scaling_factor"].SetString(scaling_function_string)
+
+        solver_cosim_details = {}
+        for i_solver_settings in range(self.settings["coupling_sequence"].size()):
+            solver_settings = self.settings["coupling_sequence"][i_solver_settings]
+            solver_name = solver_settings["name"].GetString()
+            solver_cosim_details[solver_name] = solver_settings
+
+            ValidateAndAssignDefaultsDataList(solver_settings["input_data_list"], GetInputDataDefaults())
+            ValidateAndAssignDefaultsDataList(solver_settings["output_data_list"], GetOutputDataDefaults())
+
+        return solver_cosim_details
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "coupling_sequence"        : [],
+            "solvers"                  : {},
+            "predictors"               : [],
+            "coupling_operations"      : {},
+            "data_transfer_operators"  : {}
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+
+        return this_defaults
+
+def GetInputDataDefaults():
+    return KM.Parameters("""{
+        "data"                            : "UNSPECIFIED",
+        "from_solver"                     : "UNSPECIFIED",
+        "from_solver_data"                : "UNSPECIFIED",
+        "data_transfer_operator"          : "UNSPECIFIED",
+        "data_transfer_operator_options"  : [],
+        "before_data_transfer_operations" : [],
+        "after_data_transfer_operations"  : [],
+        "interval"                        : [0.0, 1e30]
+    }""")
+
+def GetOutputDataDefaults():
+    return KM.Parameters("""{
+        "data"                            : "UNSPECIFIED",
+        "to_solver"                       : "UNSPECIFIED",
+        "to_solver_data"                  : "UNSPECIFIED",
+        "data_transfer_operator"          : "UNSPECIFIED",
+        "data_transfer_operator_options"  : [],
+        "before_data_transfer_operations" : [],
+        "after_data_transfer_operations"  : [],
+        "interval"                        : [0.0, 1e30]
+    }""")
+
+
+class ModelAccessor(object):
+    """Intermediate class for redirecting the access to the Models
+    to the solvers of the CoupledSolver
+    """
+    def __init__(self, solver_wrappers):
+        self.solver_wrappers = solver_wrappers
+
+    def __getitem__(self, key):
+        splitted_key = key.split('.')
+
+        if key == "":
+            raise Exception("No solver_name was specified!")
+        elif key.count('.') == 0:
+            # if only the solver name was given then return the Model itself
+            return self.solver_wrappers[splitted_key[0]].model
+
+        solver_name, model_part_name = key.split('.', 1)
+        # note that model_part_name can still include solver-names in a multicoupling scenario
+
+        return self.solver_wrappers[solver_name].model[model_part_name]
```

## KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_coupling_operation.py

 * *Ordering differences only*

```diff
@@ -1,60 +1,60 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# CoSimulation imports
-from KratosMultiphysics.CoSimulationApplication.co_simulation_tools import SettingsTypeCheck
-
-class CoSimulationCouplingOperation:
-    """Baseclass for the coupling operations used for CoSimulation
-    This class can be used to customize the behavior of the CoSimulation,
-    by providing a large interface and access to the solvers/models
-    """
-    def __init__(self, settings, parent_coupled_solver_process_info, parent_coupled_solver_data_communicator):
-        SettingsTypeCheck(settings)
-        self.settings = settings
-        self.settings.ValidateAndAssignDefaults(self._GetDefaultParameters())
-        self.process_info = parent_coupled_solver_process_info
-        self.data_communicator = parent_coupled_solver_data_communicator
-        self.echo_level = self.settings["echo_level"].GetInt()
-
-    def Initialize(self):
-        pass
-
-    def Finalize(self):
-        pass
-
-
-    def InitializeSolutionStep(self):
-        pass
-
-    def FinalizeSolutionStep(self):
-        pass
-
-
-    def InitializeCouplingIteration(self):
-        pass
-
-    def FinalizeCouplingIteration(self):
-        pass
-
-
-    def Execute(self):
-        raise NotImplementedError('"Execute" is not implemented for {}!'.format(self._ClassName))
-
-
-    def PrintInfo(self):
-        pass
-
-    def Check(self):
-        pass
-
-    @classmethod
-    def _ClassName(cls):
-        return cls.__name__
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        return KM.Parameters("""{
-            "type"       : "UNSPECIFIED",
-            "echo_level" : 0
-        }""")
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# CoSimulation imports
+from KratosMultiphysics.CoSimulationApplication.co_simulation_tools import SettingsTypeCheck
+
+class CoSimulationCouplingOperation:
+    """Baseclass for the coupling operations used for CoSimulation
+    This class can be used to customize the behavior of the CoSimulation,
+    by providing a large interface and access to the solvers/models
+    """
+    def __init__(self, settings, parent_coupled_solver_process_info, parent_coupled_solver_data_communicator):
+        SettingsTypeCheck(settings)
+        self.settings = settings
+        self.settings.ValidateAndAssignDefaults(self._GetDefaultParameters())
+        self.process_info = parent_coupled_solver_process_info
+        self.data_communicator = parent_coupled_solver_data_communicator
+        self.echo_level = self.settings["echo_level"].GetInt()
+
+    def Initialize(self):
+        pass
+
+    def Finalize(self):
+        pass
+
+
+    def InitializeSolutionStep(self):
+        pass
+
+    def FinalizeSolutionStep(self):
+        pass
+
+
+    def InitializeCouplingIteration(self):
+        pass
+
+    def FinalizeCouplingIteration(self):
+        pass
+
+
+    def Execute(self):
+        raise NotImplementedError('"Execute" is not implemented for {}!'.format(self._ClassName))
+
+
+    def PrintInfo(self):
+        pass
+
+    def Check(self):
+        pass
+
+    @classmethod
+    def _ClassName(cls):
+        return cls.__name__
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        return KM.Parameters("""{
+            "type"       : "UNSPECIFIED",
+            "echo_level" : 0
+        }""")
```

## KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_data_transfer_operator.py

 * *Ordering differences only*

```diff
@@ -1,67 +1,67 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Other imports
-from abc import ABCMeta, abstractmethod
-
-class CoSimulationDataTransferOperator(metaclass=ABCMeta):
-    """Baseclass for the data transfer operators used for CoSimulation
-    It transfers data from one interface to another. This can e.g. be mapping or a copy of values.
-    """
-    def __init__(self, settings, parent_coupled_solver_data_communicator):
-        self.settings = settings
-        self.settings.ValidateAndAssignDefaults(self._GetDefaultParameters())
-        self.echo_level = self.settings["echo_level"].GetInt()
-        self.data_communicator = parent_coupled_solver_data_communicator
-        self.__checked_combinations = []
-
-    def TransferData(self, from_solver_data, to_solver_data, transfer_options):
-        # 1. Check if specified transfer options are available
-        self._CheckAvailabilityTransferOptions(transfer_options)
-
-        # 2. Perform check (only if it has not been done before in this combination)
-        if from_solver_data and to_solver_data:
-            identifier_from_solver_data = from_solver_data.solver_name + "." + from_solver_data.model_part_name
-            identifier_to_solver_data   = to_solver_data.solver_name   + "." + to_solver_data.model_part_name
-
-            identifier_tuple = (identifier_from_solver_data, identifier_to_solver_data)
-            if not identifier_tuple in self.__checked_combinations:
-                self.__checked_combinations.append(identifier_tuple)
-                self._Check(from_solver_data, to_solver_data)
-
-        # 3. Perform data transfer
-        self._ExecuteTransferData(from_solver_data, to_solver_data, transfer_options)
-
-    @abstractmethod
-    def _ExecuteTransferData(self, from_solver_data, to_solver_data, transfer_options): pass
-
-    def _Check(self, from_solver_data, to_solver_data):
-        # this can be implemented in derived classes if necessary
-        # the purpose is to check only once each combination of data
-        # this mechanism is necessary since the data-transfer operators can be used for different
-        # combinations of data on the fly, i.e. they cannot be checked after the Initialization
-        pass
-
-    @classmethod
-    def _ClassName(cls):
-        return cls.__name__
-
-    @classmethod
-    def _GetListAvailableTransferOptions(cls):
-        raise NotImplementedError("This function has to be implemented in the derived class!")
-
-    @classmethod
-    def _CheckAvailabilityTransferOptions(cls, transfer_options):
-        avail_options = cls._GetListAvailableTransferOptions()
-        for option_name in transfer_options.GetStringArray():
-            if not option_name in avail_options:
-                err_msg  = 'transfer option "{}" not recognized for "{}"!\n'.format(option_name, cls._ClassName())
-                err_msg += 'Available options: "{}"'.format('", "'.join(avail_options))
-                raise Exception(err_msg)
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        return KM.Parameters("""{
-            "type"       : "UNSPECIFIED",
-            "echo_level" : 0
-        }""")
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Other imports
+from abc import ABCMeta, abstractmethod
+
+class CoSimulationDataTransferOperator(metaclass=ABCMeta):
+    """Baseclass for the data transfer operators used for CoSimulation
+    It transfers data from one interface to another. This can e.g. be mapping or a copy of values.
+    """
+    def __init__(self, settings, parent_coupled_solver_data_communicator):
+        self.settings = settings
+        self.settings.ValidateAndAssignDefaults(self._GetDefaultParameters())
+        self.echo_level = self.settings["echo_level"].GetInt()
+        self.data_communicator = parent_coupled_solver_data_communicator
+        self.__checked_combinations = []
+
+    def TransferData(self, from_solver_data, to_solver_data, transfer_options):
+        # 1. Check if specified transfer options are available
+        self._CheckAvailabilityTransferOptions(transfer_options)
+
+        # 2. Perform check (only if it has not been done before in this combination)
+        if from_solver_data and to_solver_data:
+            identifier_from_solver_data = from_solver_data.solver_name + "." + from_solver_data.model_part_name
+            identifier_to_solver_data   = to_solver_data.solver_name   + "." + to_solver_data.model_part_name
+
+            identifier_tuple = (identifier_from_solver_data, identifier_to_solver_data)
+            if not identifier_tuple in self.__checked_combinations:
+                self.__checked_combinations.append(identifier_tuple)
+                self._Check(from_solver_data, to_solver_data)
+
+        # 3. Perform data transfer
+        self._ExecuteTransferData(from_solver_data, to_solver_data, transfer_options)
+
+    @abstractmethod
+    def _ExecuteTransferData(self, from_solver_data, to_solver_data, transfer_options): pass
+
+    def _Check(self, from_solver_data, to_solver_data):
+        # this can be implemented in derived classes if necessary
+        # the purpose is to check only once each combination of data
+        # this mechanism is necessary since the data-transfer operators can be used for different
+        # combinations of data on the fly, i.e. they cannot be checked after the Initialization
+        pass
+
+    @classmethod
+    def _ClassName(cls):
+        return cls.__name__
+
+    @classmethod
+    def _GetListAvailableTransferOptions(cls):
+        raise NotImplementedError("This function has to be implemented in the derived class!")
+
+    @classmethod
+    def _CheckAvailabilityTransferOptions(cls, transfer_options):
+        avail_options = cls._GetListAvailableTransferOptions()
+        for option_name in transfer_options.GetStringArray():
+            if not option_name in avail_options:
+                err_msg  = 'transfer option "{}" not recognized for "{}"!\n'.format(option_name, cls._ClassName())
+                err_msg += 'Available options: "{}"'.format('", "'.join(avail_options))
+                raise Exception(err_msg)
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        return KM.Parameters("""{
+            "type"       : "UNSPECIFIED",
+            "echo_level" : 0
+        }""")
```

## KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_convergence_criteria.py

 * *Ordering differences only*

```diff
@@ -1,56 +1,56 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-import KratosMultiphysics.CoSimulationApplication.colors as colors
-
-class CoSimulationConvergenceCriteria:
-    """Baseclass for the convergence criteria used for CoSimulation
-    Checks if convergence was achieved in a (strongly) coupled simulation
-    """
-    def __init__(self, settings):
-        self.settings = settings
-        self.settings.RecursivelyValidateAndAssignDefaults(self._GetDefaultParameters())
-
-        self.echo_level = self.settings["echo_level"].GetInt()
-
-    def Initialize(self):
-        pass
-
-    def Finalize(self):
-        pass
-
-    def InitializeSolutionStep(self):
-        pass
-
-    def FinalizeSolutionStep(self):
-        pass
-
-    def InitializeNonLinearIteration(self):
-        pass
-
-    def FinalizeNonLinearIteration(self):
-        pass
-
-    def IsConverged(self, residual, current_data):
-        raise NotImplementedError('"IsConverged" has to be implemented in the derived class!')
-
-    def PrintInfo(self):
-        cs_tools.cs_print_info("Convergence Criteria", colors.bold(self._ClassName()))
-
-    def Check(self):
-        cs_tools.cs_print_warning("Convergence Criteria", colors.bold(self._ClassName()), 'does not implement "Check"')
-
-    @classmethod
-    def _ClassName(cls):
-        return cls.__name__
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        return KM.Parameters("""{
-            "type"       : "UNSPECIFIED",
-            "solver"     : "UNSPECIFIED",
-            "data_name"  : "UNSPECIFIED",
-            "echo_level" : 0
-        }""")
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+import KratosMultiphysics.CoSimulationApplication.colors as colors
+
+class CoSimulationConvergenceCriteria:
+    """Baseclass for the convergence criteria used for CoSimulation
+    Checks if convergence was achieved in a (strongly) coupled simulation
+    """
+    def __init__(self, settings):
+        self.settings = settings
+        self.settings.RecursivelyValidateAndAssignDefaults(self._GetDefaultParameters())
+
+        self.echo_level = self.settings["echo_level"].GetInt()
+
+    def Initialize(self):
+        pass
+
+    def Finalize(self):
+        pass
+
+    def InitializeSolutionStep(self):
+        pass
+
+    def FinalizeSolutionStep(self):
+        pass
+
+    def InitializeNonLinearIteration(self):
+        pass
+
+    def FinalizeNonLinearIteration(self):
+        pass
+
+    def IsConverged(self, residual, current_data):
+        raise NotImplementedError('"IsConverged" has to be implemented in the derived class!')
+
+    def PrintInfo(self):
+        cs_tools.cs_print_info("Convergence Criteria", colors.bold(self._ClassName()))
+
+    def Check(self):
+        cs_tools.cs_print_warning("Convergence Criteria", colors.bold(self._ClassName()), 'does not implement "Check"')
+
+    @classmethod
+    def _ClassName(cls):
+        return cls.__name__
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        return KM.Parameters("""{
+            "type"       : "UNSPECIFIED",
+            "solver"     : "UNSPECIFIED",
+            "data_name"  : "UNSPECIFIED",
+            "echo_level" : 0
+        }""")
```

## KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_io.py

 * *Ordering differences only*

```diff
@@ -1,73 +1,73 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-def Create(*args):
-    raise Exception('"CoSimulationIO" is a baseclass and cannot be used directly!')
-
-class CoSimulationIO:
-    """Baseclass defining the interface for the input and output methods
-    for the communication with external solvers
-    """
-    def __init__(self, settings, model, solver_name, data_communicator):
-        self.model = model
-        self.solver_name = solver_name # name of the owning solver
-        self.data_communicator = data_communicator # data-comm of the solver that it does IO for (not the parent coupling solver)
-
-        self.settings = settings
-        self.settings.ValidateAndAssignDefaults(self._GetDefaultParameters())
-        self.echo_level = self.settings["echo_level"].GetInt()
-
-    def Initialize(self):
-        pass
-
-    def Finalize(self):
-        pass
-
-    def ImportCouplingInterface(self, interface_config):
-        """Imports coupling interface from an external solver
-        External solver sends, CoSimulation receives
-
-        @param interface_config <python dictionary> : configuration of the interface to be imported
-        """
-        raise NotImplementedError("This function has to be implemented in the derived class!")
-
-    def ExportCouplingInterface(self, interface_config):
-        """Exports coupling interface to an external solver
-        CoSimulation sends, external solver receives
-
-        @param interface_config <python dictionary> : configuration of the interface to be exported
-        """
-        raise NotImplementedError("This function has to be implemented in the derived class!")
-
-    def ImportData(self, data_config):
-        """Imports data from an external solver
-        External solver sends, CoSimulation receives
-
-        @param data_config <python dictionary> : configuration of the data to be imported
-        """
-        raise NotImplementedError("This function has to be implemented in the derived class!")
-
-    def ExportData(self, data_config):
-        """Exports data to an external solver
-        CoSimulation sends, external solver receives
-
-        @param data_config <python dictionary> : configuration of the data to be exported
-        """
-        raise NotImplementedError("This function has to be implemented in the derived class!")
-
-    def PrintInfo(self):
-        pass
-
-    def Check(self):
-        print("!!!WARNING!!! your IO does not implement Check!!!")
-
-    @classmethod
-    def _ClassName(cls):
-        return cls.__name__
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        return KM.Parameters("""{
-            "type"        : "",
-            "echo_level"  : 0
-        }""")
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+def Create(*args):
+    raise Exception('"CoSimulationIO" is a baseclass and cannot be used directly!')
+
+class CoSimulationIO:
+    """Baseclass defining the interface for the input and output methods
+    for the communication with external solvers
+    """
+    def __init__(self, settings, model, solver_name, data_communicator):
+        self.model = model
+        self.solver_name = solver_name # name of the owning solver
+        self.data_communicator = data_communicator # data-comm of the solver that it does IO for (not the parent coupling solver)
+
+        self.settings = settings
+        self.settings.ValidateAndAssignDefaults(self._GetDefaultParameters())
+        self.echo_level = self.settings["echo_level"].GetInt()
+
+    def Initialize(self):
+        pass
+
+    def Finalize(self):
+        pass
+
+    def ImportCouplingInterface(self, interface_config):
+        """Imports coupling interface from an external solver
+        External solver sends, CoSimulation receives
+
+        @param interface_config <python dictionary> : configuration of the interface to be imported
+        """
+        raise NotImplementedError("This function has to be implemented in the derived class!")
+
+    def ExportCouplingInterface(self, interface_config):
+        """Exports coupling interface to an external solver
+        CoSimulation sends, external solver receives
+
+        @param interface_config <python dictionary> : configuration of the interface to be exported
+        """
+        raise NotImplementedError("This function has to be implemented in the derived class!")
+
+    def ImportData(self, data_config):
+        """Imports data from an external solver
+        External solver sends, CoSimulation receives
+
+        @param data_config <python dictionary> : configuration of the data to be imported
+        """
+        raise NotImplementedError("This function has to be implemented in the derived class!")
+
+    def ExportData(self, data_config):
+        """Exports data to an external solver
+        CoSimulation sends, external solver receives
+
+        @param data_config <python dictionary> : configuration of the data to be exported
+        """
+        raise NotImplementedError("This function has to be implemented in the derived class!")
+
+    def PrintInfo(self):
+        pass
+
+    def Check(self):
+        print("!!!WARNING!!! your IO does not implement Check!!!")
+
+    @classmethod
+    def _ClassName(cls):
+        return cls.__name__
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        return KM.Parameters("""{
+            "type"        : "",
+            "echo_level"  : 0
+        }""")
```

## KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_predictor.py

 * *Ordering differences only*

```diff
@@ -1,68 +1,68 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-import KratosMultiphysics.CoSimulationApplication.colors as colors
-
-class CoSimulationPredictor:
-    """Baseclass for the predictors used for CoSimulation
-    It predicts the solution of the next step at the beginning of a step
-    """
-    def __init__(self, settings, solver_wrapper):
-        self.settings = settings
-        self.settings.RecursivelyValidateAndAssignDefaults(self._GetDefaultParameters())
-
-        self.interface_data = solver_wrapper.GetInterfaceData(self.settings["data_name"].GetString())
-
-        self.echo_level = self.settings["echo_level"].GetInt()
-
-        # TODO check buffer size
-        self._GetMinimumBufferSize()
-
-    def Initialize(self):
-        pass
-
-    def Finalize(self):
-        pass
-
-    def InitializeSolutionStep(self):
-        pass
-
-    def Predict(self):
-        raise Exception('"Predict" has to be implemented in the derived class!')
-
-    def FinalizeSolutionStep(self):
-        pass
-
-    def PrintInfo(self):
-        '''Function to print Info abt the Object
-        Can be overridden in derived classes to print more information
-        '''
-        cs_tools.cs_print_info("Predictor", colors.bold(self._ClassName()))
-
-    def Check(self):
-        cs_tools.cs_print_warning("Predictor", "The predictors do not yet implement Check!")
-
-    def _UpdateData(self, updated_data):
-        self.interface_data.SetData(updated_data)
-
-        if self.echo_level > 3:
-            cs_tools.cs_print_info(self._ClassName(), "Computed prediction")
-
-    # returns the buffer size needed by the predictor. Can be overridden in derived classes
-    def _GetMinimumBufferSize(self):
-        return 2
-
-    @classmethod
-    def _ClassName(cls):
-        return cls.__name__
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        return KM.Parameters("""{
-            "type"       : "UNSPECIFIED",
-            "solver"     : "UNSPECIFIED",
-            "data_name"  : "UNSPECIFIED",
-            "echo_level" : 0
-        }""")
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+import KratosMultiphysics.CoSimulationApplication.colors as colors
+
+class CoSimulationPredictor:
+    """Baseclass for the predictors used for CoSimulation
+    It predicts the solution of the next step at the beginning of a step
+    """
+    def __init__(self, settings, solver_wrapper):
+        self.settings = settings
+        self.settings.RecursivelyValidateAndAssignDefaults(self._GetDefaultParameters())
+
+        self.interface_data = solver_wrapper.GetInterfaceData(self.settings["data_name"].GetString())
+
+        self.echo_level = self.settings["echo_level"].GetInt()
+
+        # TODO check buffer size
+        self._GetMinimumBufferSize()
+
+    def Initialize(self):
+        pass
+
+    def Finalize(self):
+        pass
+
+    def InitializeSolutionStep(self):
+        pass
+
+    def Predict(self):
+        raise Exception('"Predict" has to be implemented in the derived class!')
+
+    def FinalizeSolutionStep(self):
+        pass
+
+    def PrintInfo(self):
+        '''Function to print Info abt the Object
+        Can be overridden in derived classes to print more information
+        '''
+        cs_tools.cs_print_info("Predictor", colors.bold(self._ClassName()))
+
+    def Check(self):
+        cs_tools.cs_print_warning("Predictor", "The predictors do not yet implement Check!")
+
+    def _UpdateData(self, updated_data):
+        self.interface_data.SetData(updated_data)
+
+        if self.echo_level > 3:
+            cs_tools.cs_print_info(self._ClassName(), "Computed prediction")
+
+    # returns the buffer size needed by the predictor. Can be overridden in derived classes
+    def _GetMinimumBufferSize(self):
+        return 2
+
+    @classmethod
+    def _ClassName(cls):
+        return cls.__name__
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        return KM.Parameters("""{
+            "type"       : "UNSPECIFIED",
+            "solver"     : "UNSPECIFIED",
+            "data_name"  : "UNSPECIFIED",
+            "echo_level" : 0
+        }""")
```

## KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_solver_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,168 +1,168 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.factories.io_factory as io_factory
-from KratosMultiphysics.CoSimulationApplication.coupling_interface_data import CouplingInterfaceData
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-import KratosMultiphysics.CoSimulationApplication.colors as colors
-from KratosMultiphysics.CoSimulationApplication.utilities import data_communicator_utilities
-
-def Create(settings, name):
-    raise Exception('"CoSimulationSolverWrapper" is a baseclass and cannot be used directly!')
-
-class CoSimulationSolverWrapper:
-    """Baseclass for the solver wrappers used for CoSimulation
-    It wraps solvers used in the CoSimulation
-    """
-    def __init__(self, settings, model, solver_name):
-        """Constructor of the Base Solver Wrapper
-
-        The derived classes should do the following things in their constructors:
-        1. call the base-class constructor (i.e. the constructor of this class => CoSimulationSolverWrapper)
-        2. create the ModelParts required for the CoSimulation
-        3. Optional: call "_AllocateHistoricalVariablesFromCouplingData" to allocate the nodal historical variables on the previously created ModelParts (this should not be necessary for Kratos)
-           => this has to be done before the meshes/coupling-interfaces are read/received/imported (due to how the memory allocation of Kratos works for historical nodal values)
-        """
-
-        # Every SolverWrapper has its own model, because:
-        # - the names can be easily overlapping (e.g. "Structure.Interface")
-        # - Solvers should not be able to access the data of other solvers directly!
-        self.model = model
-        if self.model == None:
-            self.model = KM.Model()
-        elif not isinstance(self.model, KM.Model):
-            err_msg  = 'A solver wrapper can either be passed a Model\n'
-            err_msg += 'or None, got object of type "{}"'.format(type(self.model))
-            raise Exception(err_msg)
-
-        self.settings = settings
-        self.settings.ValidateAndAssignDefaults(self._GetDefaultParameters())
-
-        self.name = solver_name
-        if "." in self.name:
-            raise Exception("cannot contain dot!")
-
-        self.echo_level = self.settings["echo_level"].GetInt()
-
-        self.data_communicator = self._GetDataCommunicator()
-
-        # The IO is only used if the corresponding solver is used in coupling and it initialized from the "higher instance, i.e. the coupling-solver
-        self.__io = None
-
-    def _GetSolver(self, solver_name):
-        raise Exception('Trying to get SolverWrapper "{}" of "{}" which is not a coupled solver!'.format(solver_name, self.name))
-
-    def Initialize(self):
-        self.data_dict = {data_name : CouplingInterfaceData(data_config, self.model, data_name, self.name) for (data_name, data_config) in self.settings["data"].items()}
-
-        if self.__HasIO():
-            self.__GetIO().Initialize()
-
-    def Finalize(self):
-        if self.__HasIO():
-            self.__GetIO().Finalize()
-
-    def AdvanceInTime(self, current_time):
-        # in case a solver does not provide time information (e.g. external or steady solvers),
-        # then this solver should return "0.0" here
-        raise Exception('"AdvanceInTime" must be implemented in the derived class!')
-
-    def Predict(self):
-        pass
-
-    def InitializeSolutionStep(self):
-        pass
-
-    def FinalizeSolutionStep(self):
-        pass
-
-    def OutputSolutionStep(self):
-        pass
-
-    def SolveSolutionStep(self):
-        pass
-
-
-    def CreateIO(self, io_echo_level):
-        if self.__HasIO():
-            raise Exception('IO for solver "{}" is already created!'.format(self.name))
-
-        io_settings = self.settings["io_settings"]
-
-        if not io_settings.Has("echo_level"):
-            io_settings.AddEmptyValue("echo_level").SetInt(io_echo_level)
-
-        self.__io = io_factory.CreateIO(self.settings["io_settings"], self.model, self.name, self.data_communicator, self._GetIOType())
-
-    def ImportCouplingInterface(self, interface_config):
-        if self.echo_level > 2:
-            cs_tools.cs_print_info("CoSimulationSolverWrapper", 'Importing coupling interface "{}" of solver: "{}"'.format(colors.magenta(interface_config["model_part_name"]), colors.blue(self.name)))
-        self.__GetIO().ImportCouplingInterface(interface_config)
-
-    def ExportCouplingInterface(self, interface_config):
-        if self.echo_level > 2:
-            cs_tools.cs_print_info("CoSimulationSolverWrapper", 'Exporting coupling interface "{}" of solver: "{}"'.format(colors.magenta(interface_config["model_part_name"]), colors.blue(self.name)))
-        self.__GetIO().ExportCouplingInterface(interface_config)
-
-    def ImportData(self, data_config):
-        if self.echo_level > 2:
-            cs_tools.cs_print_info("CoSimulationSolverWrapper", 'Importing data of solver: "{}" with type: "{}"'.format(colors.blue(self.name), data_config["type"]))
-        self.__GetIO().ImportData(data_config)
-
-    def ExportData(self, data_config):
-        if self.echo_level > 2:
-            cs_tools.cs_print_info("CoSimulationSolverWrapper", 'Exporting data of solver: "{}" with type: "{}"'.format(colors.blue(self.name), data_config["type"]))
-        self.__GetIO().ExportData(data_config)
-
-    def IsDefinedOnThisRank(self):
-        return self.data_communicator.IsDefinedOnThisRank()
-
-    def GetInterfaceData(self, data_name) -> CouplingInterfaceData:
-        try:
-            return self.data_dict[data_name]
-        except KeyError:
-            raise Exception('Requested data field "{}" does not exist for solver "{}"'.format(data_name, self.name))
-
-    def PrintInfo(self):
-        if self.echo_level > 0 and self.data_communicator.IsDefinedOnThisRank():
-            cs_tools.cs_print_info("CoSimulationSolverWrapper", self._ClassName(), self.name, "Using {} mpi-processes".format(self.data_communicator.Size()))
-
-    def Check(self):
-        cs_tools.cs_print_warning("CoSimulationSolverWrapper", "your solver does not implement Check!!!")
-
-    @classmethod
-    def _ClassName(cls):
-        return cls.__name__
-
-    def _GetIOType(self):
-        # only external solvers have to specify sth here / override this
-        return "dummy_io"
-
-    def __GetIO(self):
-        if not self.__HasIO():
-            raise Exception('IO for solver "{}" is not created!'.format(self.name))
-        return self.__io
-
-    def __HasIO(self):
-        return self.__io is not None
-
-    def _GetDataCommunicator(self):
-        if len(self.settings["mpi_settings"].keys()) > 0:
-            if self.settings["mpi_settings"]["num_processes"].GetInt() == 1:
-                return data_communicator_utilities.GetRankZeroDataCommunicator()
-            return data_communicator_utilities.CreateDataCommunicatorWithNProcesses(self.settings["mpi_settings"])
-        else:
-            # if no special input is specified use the default implementation from the baseclass
-            return KM.ParallelEnvironment.GetDefaultDataCommunicator()
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        return KM.Parameters("""{
-            "type"                    : "",
-            "solver_wrapper_settings" : {},
-            "io_settings"             : {},
-            "data"                    : {},
-            "mpi_settings"            : {},
-            "echo_level"              : 0
-        }""")
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.factories.io_factory as io_factory
+from KratosMultiphysics.CoSimulationApplication.coupling_interface_data import CouplingInterfaceData
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+import KratosMultiphysics.CoSimulationApplication.colors as colors
+from KratosMultiphysics.CoSimulationApplication.utilities import data_communicator_utilities
+
+def Create(settings, name):
+    raise Exception('"CoSimulationSolverWrapper" is a baseclass and cannot be used directly!')
+
+class CoSimulationSolverWrapper:
+    """Baseclass for the solver wrappers used for CoSimulation
+    It wraps solvers used in the CoSimulation
+    """
+    def __init__(self, settings, model, solver_name):
+        """Constructor of the Base Solver Wrapper
+
+        The derived classes should do the following things in their constructors:
+        1. call the base-class constructor (i.e. the constructor of this class => CoSimulationSolverWrapper)
+        2. create the ModelParts required for the CoSimulation
+        3. Optional: call "_AllocateHistoricalVariablesFromCouplingData" to allocate the nodal historical variables on the previously created ModelParts (this should not be necessary for Kratos)
+           => this has to be done before the meshes/coupling-interfaces are read/received/imported (due to how the memory allocation of Kratos works for historical nodal values)
+        """
+
+        # Every SolverWrapper has its own model, because:
+        # - the names can be easily overlapping (e.g. "Structure.Interface")
+        # - Solvers should not be able to access the data of other solvers directly!
+        self.model = model
+        if self.model == None:
+            self.model = KM.Model()
+        elif not isinstance(self.model, KM.Model):
+            err_msg  = 'A solver wrapper can either be passed a Model\n'
+            err_msg += 'or None, got object of type "{}"'.format(type(self.model))
+            raise Exception(err_msg)
+
+        self.settings = settings
+        self.settings.ValidateAndAssignDefaults(self._GetDefaultParameters())
+
+        self.name = solver_name
+        if "." in self.name:
+            raise Exception("cannot contain dot!")
+
+        self.echo_level = self.settings["echo_level"].GetInt()
+
+        self.data_communicator = self._GetDataCommunicator()
+
+        # The IO is only used if the corresponding solver is used in coupling and it initialized from the "higher instance, i.e. the coupling-solver
+        self.__io = None
+
+    def _GetSolver(self, solver_name):
+        raise Exception('Trying to get SolverWrapper "{}" of "{}" which is not a coupled solver!'.format(solver_name, self.name))
+
+    def Initialize(self):
+        self.data_dict = {data_name : CouplingInterfaceData(data_config, self.model, data_name, self.name) for (data_name, data_config) in self.settings["data"].items()}
+
+        if self.__HasIO():
+            self.__GetIO().Initialize()
+
+    def Finalize(self):
+        if self.__HasIO():
+            self.__GetIO().Finalize()
+
+    def AdvanceInTime(self, current_time):
+        # in case a solver does not provide time information (e.g. external or steady solvers),
+        # then this solver should return "0.0" here
+        raise Exception('"AdvanceInTime" must be implemented in the derived class!')
+
+    def Predict(self):
+        pass
+
+    def InitializeSolutionStep(self):
+        pass
+
+    def FinalizeSolutionStep(self):
+        pass
+
+    def OutputSolutionStep(self):
+        pass
+
+    def SolveSolutionStep(self):
+        pass
+
+
+    def CreateIO(self, io_echo_level):
+        if self.__HasIO():
+            raise Exception('IO for solver "{}" is already created!'.format(self.name))
+
+        io_settings = self.settings["io_settings"]
+
+        if not io_settings.Has("echo_level"):
+            io_settings.AddEmptyValue("echo_level").SetInt(io_echo_level)
+
+        self.__io = io_factory.CreateIO(self.settings["io_settings"], self.model, self.name, self.data_communicator, self._GetIOType())
+
+    def ImportCouplingInterface(self, interface_config):
+        if self.echo_level > 2:
+            cs_tools.cs_print_info("CoSimulationSolverWrapper", 'Importing coupling interface "{}" of solver: "{}"'.format(colors.magenta(interface_config["model_part_name"]), colors.blue(self.name)))
+        self.__GetIO().ImportCouplingInterface(interface_config)
+
+    def ExportCouplingInterface(self, interface_config):
+        if self.echo_level > 2:
+            cs_tools.cs_print_info("CoSimulationSolverWrapper", 'Exporting coupling interface "{}" of solver: "{}"'.format(colors.magenta(interface_config["model_part_name"]), colors.blue(self.name)))
+        self.__GetIO().ExportCouplingInterface(interface_config)
+
+    def ImportData(self, data_config):
+        if self.echo_level > 2:
+            cs_tools.cs_print_info("CoSimulationSolverWrapper", 'Importing data of solver: "{}" with type: "{}"'.format(colors.blue(self.name), data_config["type"]))
+        self.__GetIO().ImportData(data_config)
+
+    def ExportData(self, data_config):
+        if self.echo_level > 2:
+            cs_tools.cs_print_info("CoSimulationSolverWrapper", 'Exporting data of solver: "{}" with type: "{}"'.format(colors.blue(self.name), data_config["type"]))
+        self.__GetIO().ExportData(data_config)
+
+    def IsDefinedOnThisRank(self):
+        return self.data_communicator.IsDefinedOnThisRank()
+
+    def GetInterfaceData(self, data_name) -> CouplingInterfaceData:
+        try:
+            return self.data_dict[data_name]
+        except KeyError:
+            raise Exception('Requested data field "{}" does not exist for solver "{}"'.format(data_name, self.name))
+
+    def PrintInfo(self):
+        if self.echo_level > 0 and self.data_communicator.IsDefinedOnThisRank():
+            cs_tools.cs_print_info("CoSimulationSolverWrapper", self._ClassName(), self.name, "Using {} mpi-processes".format(self.data_communicator.Size()))
+
+    def Check(self):
+        cs_tools.cs_print_warning("CoSimulationSolverWrapper", "your solver does not implement Check!!!")
+
+    @classmethod
+    def _ClassName(cls):
+        return cls.__name__
+
+    def _GetIOType(self):
+        # only external solvers have to specify sth here / override this
+        return "dummy_io"
+
+    def __GetIO(self):
+        if not self.__HasIO():
+            raise Exception('IO for solver "{}" is not created!'.format(self.name))
+        return self.__io
+
+    def __HasIO(self):
+        return self.__io is not None
+
+    def _GetDataCommunicator(self):
+        if len(self.settings["mpi_settings"].keys()) > 0:
+            if self.settings["mpi_settings"]["num_processes"].GetInt() == 1:
+                return data_communicator_utilities.GetRankZeroDataCommunicator()
+            return data_communicator_utilities.CreateDataCommunicatorWithNProcesses(self.settings["mpi_settings"])
+        else:
+            # if no special input is specified use the default implementation from the baseclass
+            return KM.ParallelEnvironment.GetDefaultDataCommunicator()
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        return KM.Parameters("""{
+            "type"                    : "",
+            "solver_wrapper_settings" : {},
+            "io_settings"             : {},
+            "data"                    : {},
+            "mpi_settings"            : {},
+            "echo_level"              : 0
+        }""")
```

## KratosMultiphysics/CoSimulationApplication/analysis_stage_with_co_sim_io.py

 * *Ordering differences only*

```diff
@@ -1,136 +1,136 @@
-import KratosMultiphysics as KM
-from KratosMultiphysics.analysis_stage import AnalysisStage
-
-default_data_comm = KM.ParallelEnvironment.GetDefaultDataCommunicator()
-if default_data_comm.IsDistributed():
-    from KratosMultiphysics.CoSimulationApplication import MPIExtension
-
-from KratosMultiphysics.CoSimulationApplication import CoSimIO
-
-import sys
-
-def FlushAll():
-    sys.stdout.flush()
-    KM.Logger.Flush()
-
-def CreateAnalysisStageWithCoSimIO(BaseAnalysisStage):
-    # concept from https://stackoverflow.com/a/1334242
-
-    class AnalysisStageWithCoSimIO(BaseAnalysisStage):
-        '''Adds coupling functionality with CoSimIO to an AnalysisStage'''
-
-        def __init__(self, model, parameters):
-            if not issubclass(BaseAnalysisStage, AnalysisStage):
-                raise Exception(f'Given baseclass "{BaseAnalysisStage}" does not inherit from AnalysisStage!')
-
-            super().__init__(model, parameters)
-
-            # To avoid many prints
-            severity = KM.Logger.Severity.WARNING
-            if self.echo_level > 0:
-                severity = KM.Logger.Severity.INFO
-            KM.Logger.GetDefaultOutput().SetSeverity(severity)
-
-            if self.echo_level > 0: FlushAll()
-
-        def Initialize(self):
-            super().Initialize()
-
-            self.co_sim_settings = self.project_parameters["co_sim_settings"]
-            self.is_strong_coupling = self.co_sim_settings["is_strong_coupling"].GetBool()
-
-            connection_settings = CoSimIO.InfoFromParameters(self.project_parameters["co_sim_settings"]["io_settings"])
-
-            if default_data_comm.IsDistributed():
-                info = MPIExtension.CoSimIO.ConnectMPI(connection_settings, default_data_comm)
-            else:
-                info = CoSimIO.Connect(connection_settings)
-
-            if self.echo_level > 0: FlushAll()
-
-            self.connection_name = info.GetString("connection_name")
-            if info.GetInt("connection_status") != CoSimIO.ConnectionStatus.Connected:
-                raise Exception("Connecting failed!")
-
-            self.communication_settings = self.co_sim_settings["communication_settings"]
-
-            # Exporting meshes to CoSimulation
-            for model_part_name in self.communication_settings["export_meshes"].GetStringArray():
-                info = CoSimIO.Info()
-                info.SetString("connection_name", self.connection_name)
-                info.SetString("identifier", model_part_name.replace(".", "-"))
-
-                CoSimIO.ExportMesh(info, self.model[model_part_name])
-
-            if self.echo_level > 0: FlushAll()
-
-        def RunSolutionLoop(self):
-            """This function executes the solution loop of the AnalysisStage
-            It can be overridden by derived classes
-            """
-            while self.KeepAdvancingSolutionLoop():
-                self.time = self._GetSolver().AdvanceInTime(self.time)
-                self.InitializeSolutionStep()
-                self._GetSolver().Predict()
-
-                if self.is_strong_coupling:
-                    repeat_time_step = True
-                    while repeat_time_step:
-                        self.__InnerLoop()
-                        info = CoSimIO.Info()
-                        info.SetString("connection_name", self.connection_name)
-                        info.SetString("identifier", "repeat_time_step_info")
-                        repeat_time_step_info = CoSimIO.ImportInfo(info)
-                        repeat_time_step = repeat_time_step_info.GetBool("repeat_time_step")
-                else:
-                    self.__InnerLoop()
-
-                self.FinalizeSolutionStep()
-                self.OutputSolutionStep()
-
-        def Finalize(self):
-            super().Finalize()
-
-            disconnect_settings = CoSimIO.Info()
-            disconnect_settings.SetString("connection_name", self.connection_name)
-            info = CoSimIO.Disconnect(disconnect_settings)
-            if info.GetInt("connection_status") != CoSimIO.ConnectionStatus.Disconnected:
-                raise Exception("Disconnecting failed!")
-
-        def _GetSimulationName(self):
-            return super()._GetSimulationName() + " with CoSimIO"
-
-        def __InnerLoop(self):
-            if self.echo_level > 0: FlushAll()
-
-            # Import fields
-            for field_settings in self.communication_settings["import_fields"]:
-                identifier = field_settings["identifier"].GetString()
-                model_part_name = field_settings["model_part_name"].GetString()
-                model_part = self.model[model_part_name]
-                variable_name = field_settings["variable_name"].GetString()
-                variable = KM.KratosGlobals.GetVariable(variable_name)
-
-                info = CoSimIO.Info()
-                info.SetString("connection_name", self.connection_name)
-                info.SetString("identifier", identifier)
-                CoSimIO.ImportData(info, model_part, variable, KM.Globals.DataLocation.NodeHistorical)
-
-            if self.echo_level > 0: FlushAll()
-
-            self._GetSolver().SolveSolutionStep()
-
-            # Export fields
-            for field_settings in self.communication_settings["export_fields"]:
-                identifier = field_settings["identifier"].GetString()
-                model_part_name = field_settings["model_part_name"].GetString()
-                model_part = self.model[model_part_name]
-                variable_name = field_settings["variable_name"].GetString()
-                variable = KM.KratosGlobals.GetVariable(variable_name)
-
-                info = CoSimIO.Info()
-                info.SetString("connection_name", self.connection_name)
-                info.SetString("identifier", identifier)
-                CoSimIO.ExportData(info, model_part, variable, KM.Globals.DataLocation.NodeHistorical)
-
-    return AnalysisStageWithCoSimIO
+import KratosMultiphysics as KM
+from KratosMultiphysics.analysis_stage import AnalysisStage
+
+default_data_comm = KM.ParallelEnvironment.GetDefaultDataCommunicator()
+if default_data_comm.IsDistributed():
+    from KratosMultiphysics.CoSimulationApplication import MPIExtension
+
+from KratosMultiphysics.CoSimulationApplication import CoSimIO
+
+import sys
+
+def FlushAll():
+    sys.stdout.flush()
+    KM.Logger.Flush()
+
+def CreateAnalysisStageWithCoSimIO(BaseAnalysisStage):
+    # concept from https://stackoverflow.com/a/1334242
+
+    class AnalysisStageWithCoSimIO(BaseAnalysisStage):
+        '''Adds coupling functionality with CoSimIO to an AnalysisStage'''
+
+        def __init__(self, model, parameters):
+            if not issubclass(BaseAnalysisStage, AnalysisStage):
+                raise Exception(f'Given baseclass "{BaseAnalysisStage}" does not inherit from AnalysisStage!')
+
+            super().__init__(model, parameters)
+
+            # To avoid many prints
+            severity = KM.Logger.Severity.WARNING
+            if self.echo_level > 0:
+                severity = KM.Logger.Severity.INFO
+            KM.Logger.GetDefaultOutput().SetSeverity(severity)
+
+            if self.echo_level > 0: FlushAll()
+
+        def Initialize(self):
+            super().Initialize()
+
+            self.co_sim_settings = self.project_parameters["co_sim_settings"]
+            self.is_strong_coupling = self.co_sim_settings["is_strong_coupling"].GetBool()
+
+            connection_settings = CoSimIO.InfoFromParameters(self.project_parameters["co_sim_settings"]["io_settings"])
+
+            if default_data_comm.IsDistributed():
+                info = MPIExtension.CoSimIO.ConnectMPI(connection_settings, default_data_comm)
+            else:
+                info = CoSimIO.Connect(connection_settings)
+
+            if self.echo_level > 0: FlushAll()
+
+            self.connection_name = info.GetString("connection_name")
+            if info.GetInt("connection_status") != CoSimIO.ConnectionStatus.Connected:
+                raise Exception("Connecting failed!")
+
+            self.communication_settings = self.co_sim_settings["communication_settings"]
+
+            # Exporting meshes to CoSimulation
+            for model_part_name in self.communication_settings["export_meshes"].GetStringArray():
+                info = CoSimIO.Info()
+                info.SetString("connection_name", self.connection_name)
+                info.SetString("identifier", model_part_name.replace(".", "-"))
+
+                CoSimIO.ExportMesh(info, self.model[model_part_name])
+
+            if self.echo_level > 0: FlushAll()
+
+        def RunSolutionLoop(self):
+            """This function executes the solution loop of the AnalysisStage
+            It can be overridden by derived classes
+            """
+            while self.KeepAdvancingSolutionLoop():
+                self.time = self._GetSolver().AdvanceInTime(self.time)
+                self.InitializeSolutionStep()
+                self._GetSolver().Predict()
+
+                if self.is_strong_coupling:
+                    repeat_time_step = True
+                    while repeat_time_step:
+                        self.__InnerLoop()
+                        info = CoSimIO.Info()
+                        info.SetString("connection_name", self.connection_name)
+                        info.SetString("identifier", "repeat_time_step_info")
+                        repeat_time_step_info = CoSimIO.ImportInfo(info)
+                        repeat_time_step = repeat_time_step_info.GetBool("repeat_time_step")
+                else:
+                    self.__InnerLoop()
+
+                self.FinalizeSolutionStep()
+                self.OutputSolutionStep()
+
+        def Finalize(self):
+            super().Finalize()
+
+            disconnect_settings = CoSimIO.Info()
+            disconnect_settings.SetString("connection_name", self.connection_name)
+            info = CoSimIO.Disconnect(disconnect_settings)
+            if info.GetInt("connection_status") != CoSimIO.ConnectionStatus.Disconnected:
+                raise Exception("Disconnecting failed!")
+
+        def _GetSimulationName(self):
+            return super()._GetSimulationName() + " with CoSimIO"
+
+        def __InnerLoop(self):
+            if self.echo_level > 0: FlushAll()
+
+            # Import fields
+            for field_settings in self.communication_settings["import_fields"]:
+                identifier = field_settings["identifier"].GetString()
+                model_part_name = field_settings["model_part_name"].GetString()
+                model_part = self.model[model_part_name]
+                variable_name = field_settings["variable_name"].GetString()
+                variable = KM.KratosGlobals.GetVariable(variable_name)
+
+                info = CoSimIO.Info()
+                info.SetString("connection_name", self.connection_name)
+                info.SetString("identifier", identifier)
+                CoSimIO.ImportData(info, model_part, variable, KM.Globals.DataLocation.NodeHistorical)
+
+            if self.echo_level > 0: FlushAll()
+
+            self._GetSolver().SolveSolutionStep()
+
+            # Export fields
+            for field_settings in self.communication_settings["export_fields"]:
+                identifier = field_settings["identifier"].GetString()
+                model_part_name = field_settings["model_part_name"].GetString()
+                model_part = self.model[model_part_name]
+                variable_name = field_settings["variable_name"].GetString()
+                variable = KM.KratosGlobals.GetVariable(variable_name)
+
+                info = CoSimIO.Info()
+                info.SetString("connection_name", self.connection_name)
+                info.SetString("identifier", identifier)
+                CoSimIO.ExportData(info, model_part, variable, KM.Globals.DataLocation.NodeHistorical)
+
+    return AnalysisStageWithCoSimIO
```

## KratosMultiphysics/CoSimulationApplication/function_callback_utility.py

 * *Ordering differences only*

```diff
@@ -1,41 +1,41 @@
-# executing a function specified as a string, similar to "kratos/utilities/python_function_callback_utility.h"
-
-from math import *
-
-# list of safe methods that can be used
-safe_methods_list = ['acos', 'asin', 'atan', 'atan2', 'ceil', 'cos',
-             'cosh', 'degrees', 'e', 'exp', 'fabs', 'floor',
-             'fmod', 'frexp', 'hypot', 'ldexp', 'log', 'log10',
-             'modf', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt',
-             'tan', 'tanh']
-
-safe_dict = {}
-for k in safe_methods_list:
-    safe_dict[k] = locals()[k]
-
-def GetWordsFromString(string):
-    words = [""]
-    new_word = False
-    for letter in string:
-        if letter.isalpha():
-            if new_word:
-                words.append("")
-                new_word = False
-            words[-1]+=letter
-        else:
-            new_word = (words[-1]!="")
-
-    return words
-
-def GenericCallFunction(func_string, scope_vars=None, check=True):
-    if scope_vars is not None:
-        safe_dict.update(scope_vars)
-
-    if check: # can be disabled to improve performance
-        splitted_func_args = GetWordsFromString(func_string)
-
-        for func_arg in splitted_func_args:
-            if not func_arg == "" and not func_arg in safe_dict:
-                raise Exception('Argument "{}" in function string "{}" was not recognized!\nOnly the following expressions can be used:\n\t{}'.format(func_arg, func_string, "\n\t".join(sorted(safe_dict.keys()))))
-
-    return eval(func_string, {"__builtins__" : None}, safe_dict)
+# executing a function specified as a string, similar to "kratos/utilities/python_function_callback_utility.h"
+
+from math import *
+
+# list of safe methods that can be used
+safe_methods_list = ['acos', 'asin', 'atan', 'atan2', 'ceil', 'cos',
+             'cosh', 'degrees', 'e', 'exp', 'fabs', 'floor',
+             'fmod', 'frexp', 'hypot', 'ldexp', 'log', 'log10',
+             'modf', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt',
+             'tan', 'tanh']
+
+safe_dict = {}
+for k in safe_methods_list:
+    safe_dict[k] = locals()[k]
+
+def GetWordsFromString(string):
+    words = [""]
+    new_word = False
+    for letter in string:
+        if letter.isalpha():
+            if new_word:
+                words.append("")
+                new_word = False
+            words[-1]+=letter
+        else:
+            new_word = (words[-1]!="")
+
+    return words
+
+def GenericCallFunction(func_string, scope_vars=None, check=True):
+    if scope_vars is not None:
+        safe_dict.update(scope_vars)
+
+    if check: # can be disabled to improve performance
+        splitted_func_args = GetWordsFromString(func_string)
+
+        for func_arg in splitted_func_args:
+            if not func_arg == "" and not func_arg in safe_dict:
+                raise Exception('Argument "{}" in function string "{}" was not recognized!\nOnly the following expressions can be used:\n\t{}'.format(func_arg, func_string, "\n\t".join(sorted(safe_dict.keys()))))
+
+    return eval(func_string, {"__builtins__" : None}, safe_dict)
```

## KratosMultiphysics/CoSimulationApplication/structural_mechanics_analysis_with_co_sim_io.py

 * *Ordering differences only*

```diff
@@ -1,23 +1,23 @@
-
-import KratosMultiphysics as KM
-from KratosMultiphysics.CoSimulationApplication.analysis_stage_with_co_sim_io import CreateAnalysisStageWithCoSimIO
-from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_analysis import StructuralMechanicsAnalysis
-
-from sys import argv
-
-StructuralMechanicsAnalysisWithCoSimIO = CreateAnalysisStageWithCoSimIO(StructuralMechanicsAnalysis)
-
-if __name__ == '__main__':
-    if len(argv) != 2:
-        err_msg  = 'Wrong number of input arguments!\n'
-        err_msg += 'Use this script in the following way:\n'
-        err_msg += '    "python structural_mechanics_analysis_with_co_sim_io.py <project-parameter-file>.json"\n'
-        raise Exception(err_msg)
-
-    parameter_file_name = argv[1]
-
-    with open(parameter_file_name,'r') as parameter_file:
-        parameters = KM.Parameters(parameter_file.read())
-
-    model = KM.Model()
-    StructuralMechanicsAnalysisWithCoSimIO(model, parameters).Run()
+
+import KratosMultiphysics as KM
+from KratosMultiphysics.CoSimulationApplication.analysis_stage_with_co_sim_io import CreateAnalysisStageWithCoSimIO
+from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_analysis import StructuralMechanicsAnalysis
+
+from sys import argv
+
+StructuralMechanicsAnalysisWithCoSimIO = CreateAnalysisStageWithCoSimIO(StructuralMechanicsAnalysis)
+
+if __name__ == '__main__':
+    if len(argv) != 2:
+        err_msg  = 'Wrong number of input arguments!\n'
+        err_msg += 'Use this script in the following way:\n'
+        err_msg += '    "python structural_mechanics_analysis_with_co_sim_io.py <project-parameter-file>.json"\n'
+        raise Exception(err_msg)
+
+    parameter_file_name = argv[1]
+
+    with open(parameter_file_name,'r') as parameter_file:
+        parameters = KM.Parameters(parameter_file.read())
+
+    model = KM.Model()
+    StructuralMechanicsAnalysisWithCoSimIO(model, parameters).Run()
```

## KratosMultiphysics/CoSimulationApplication/co_simulation_analysis.py

 * *Ordering differences only*

```diff
@@ -1,133 +1,133 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-from KratosMultiphysics.analysis_stage import AnalysisStage
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.factories.solver_wrapper_factory as solver_wrapper_factory
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-import KratosMultiphysics.CoSimulationApplication.colors as colors
-
-# Other imports
-import sys
-
-class CoSimulationAnalysis(AnalysisStage):
-    """AnalysisStage of the CoSimulationApplication.
-    It does NOT override the "RunSolutionLoop" method!
-    """
-    def __init__(self, cosim_settings, models=None):
-        # Note: deliberately NOT calling the base-class constructor since arguments are different
-
-        if not isinstance(cosim_settings, KM.Parameters):
-            raise Exception("Input is expected to be provided as a Kratos Parameters object")
-
-        self.cosim_settings = cosim_settings
-        self.models = models
-
-        # this contains only the optional parameters, not the ones that have to be specified
-        problem_data_defaults = KM.Parameters("""{
-            "problem_name" : "default_co_simulation",
-            "print_colors" : false,
-            "echo_level"   : 1
-        }""")
-
-        problem_data = cosim_settings["problem_data"]
-
-        problem_data.AddMissingParameters(problem_data_defaults)
-
-        colors.PRINT_COLORS = problem_data["print_colors"].GetBool()
-        self.echo_level = problem_data["echo_level"].GetInt()
-
-        self.parallel_type = problem_data["parallel_type"].GetString()
-        is_distributed_run = KM.IsDistributedRun()
-        if self.parallel_type == "OpenMP":
-            if is_distributed_run:
-                cs_tools.cs_print_warning("Parallel Type", 'Specified "OpenMP" as "parallel_type", but Kratos is running in "MPI", please check your setup!')
-        elif self.parallel_type == "MPI":
-            if not is_distributed_run:
-                cs_tools.cs_print_warning("Parallel Type", 'Specified "MPI" as "parallel_type", but Kratos is running in "OpenMP", please check your setup!')
-        else:
-            raise Exception('The "parallel_type" can be either "OpenMP" or "MPI"')
-
-        if problem_data.Has("flush_stdout"):
-            self.flush_stdout = problem_data["flush_stdout"].GetBool()
-        else:
-            # flush by default only in OpenMP, can decrease performance in MPI
-            self.flush_stdout = (self.parallel_type == "OpenMP")
-
-        self._GetSolver() # this creates the solver
-
-    def Initialize(self):
-        self._GetSolver().Initialize()
-        self._GetSolver().Check()
-
-        if self.echo_level > 0:
-            self._GetSolver().PrintInfo()
-
-        ## Stepping and time settings
-        self.end_time = self.cosim_settings["problem_data"]["end_time"].GetDouble()
-        self.time = self.cosim_settings["problem_data"]["start_time"].GetDouble()
-        self.step = 0
-
-        if self.flush_stdout:
-            CoSimulationAnalysis.Flush()
-
-    def Finalize(self):
-        self._GetSolver().Finalize()
-
-    def InitializeSolutionStep(self):
-        self.step += 1
-        cs_tools.cs_print_info(colors.bold("\ntime={0:.12g}".format(self.time)+ " | step="+ str(self.step)))
-
-        self._GetSolver().InitializeSolutionStep()
-
-    def FinalizeSolutionStep(self):
-        self._GetSolver().FinalizeSolutionStep()
-
-    def OutputSolutionStep(self):
-        self._GetSolver().OutputSolutionStep()
-
-        if self.flush_stdout:
-            CoSimulationAnalysis.Flush()
-
-    def _GetSolver(self, solver_name=""):
-        solver = super()._GetSolver()
-        if solver_name == "":
-            return solver
-        else:
-            return solver._GetSolver(solver_name)
-
-    @staticmethod
-    def Flush():
-        sys.stdout.flush()
-        KM.Logger.Flush()
-
-    def _CreateSolver(self):
-        """Create the solver
-        """
-        problem_name = self.cosim_settings["problem_data"]["problem_name"].GetString()
-        return solver_wrapper_factory.CreateSolverWrapper(self.cosim_settings["solver_settings"], self.models, problem_name)
-
-    def _GetSimulationName(self):
-        """Returns the name of the Simulation
-        """
-        simulation_name = type(self).__name__ + ": " + self._GetSolver()._ClassName() + " coupling "
-        list_solvers = self.cosim_settings["solver_settings"]["solvers"].keys()
-        for solver_name in list_solvers:
-            simulation_name += self._GetSolver(solver_name)._ClassName() + " - "
-        simulation_name = simulation_name[0:-3] # Removing last " - "
-        return simulation_name
-
-if __name__ == '__main__':
-    if len(sys.argv) != 2:
-        err_msg  = 'Wrong number of input arguments!\n'
-        err_msg += 'Use this script in the following way:\n'
-        err_msg += '    "python co_simulation_analysis.py <cosim-parameter-file>.json"\n'
-        raise Exception(err_msg)
-
-    parameter_file_name = sys.argv[1]
-
-    with open(parameter_file_name,'r') as parameter_file:
-        parameters = KM.Parameters(parameter_file.read())
-
-    simulation = CoSimulationAnalysis(parameters)
-    simulation.Run()
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+from KratosMultiphysics.analysis_stage import AnalysisStage
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.factories.solver_wrapper_factory as solver_wrapper_factory
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+import KratosMultiphysics.CoSimulationApplication.colors as colors
+
+# Other imports
+import sys
+
+class CoSimulationAnalysis(AnalysisStage):
+    """AnalysisStage of the CoSimulationApplication.
+    It does NOT override the "RunSolutionLoop" method!
+    """
+    def __init__(self, cosim_settings, models=None):
+        # Note: deliberately NOT calling the base-class constructor since arguments are different
+
+        if not isinstance(cosim_settings, KM.Parameters):
+            raise Exception("Input is expected to be provided as a Kratos Parameters object")
+
+        self.cosim_settings = cosim_settings
+        self.models = models
+
+        # this contains only the optional parameters, not the ones that have to be specified
+        problem_data_defaults = KM.Parameters("""{
+            "problem_name" : "default_co_simulation",
+            "print_colors" : false,
+            "echo_level"   : 1
+        }""")
+
+        problem_data = cosim_settings["problem_data"]
+
+        problem_data.AddMissingParameters(problem_data_defaults)
+
+        colors.PRINT_COLORS = problem_data["print_colors"].GetBool()
+        self.echo_level = problem_data["echo_level"].GetInt()
+
+        self.parallel_type = problem_data["parallel_type"].GetString()
+        is_distributed_run = KM.IsDistributedRun()
+        if self.parallel_type == "OpenMP":
+            if is_distributed_run:
+                cs_tools.cs_print_warning("Parallel Type", 'Specified "OpenMP" as "parallel_type", but Kratos is running in "MPI", please check your setup!')
+        elif self.parallel_type == "MPI":
+            if not is_distributed_run:
+                cs_tools.cs_print_warning("Parallel Type", 'Specified "MPI" as "parallel_type", but Kratos is running in "OpenMP", please check your setup!')
+        else:
+            raise Exception('The "parallel_type" can be either "OpenMP" or "MPI"')
+
+        if problem_data.Has("flush_stdout"):
+            self.flush_stdout = problem_data["flush_stdout"].GetBool()
+        else:
+            # flush by default only in OpenMP, can decrease performance in MPI
+            self.flush_stdout = (self.parallel_type == "OpenMP")
+
+        self._GetSolver() # this creates the solver
+
+    def Initialize(self):
+        self._GetSolver().Initialize()
+        self._GetSolver().Check()
+
+        if self.echo_level > 0:
+            self._GetSolver().PrintInfo()
+
+        ## Stepping and time settings
+        self.end_time = self.cosim_settings["problem_data"]["end_time"].GetDouble()
+        self.time = self.cosim_settings["problem_data"]["start_time"].GetDouble()
+        self.step = 0
+
+        if self.flush_stdout:
+            CoSimulationAnalysis.Flush()
+
+    def Finalize(self):
+        self._GetSolver().Finalize()
+
+    def InitializeSolutionStep(self):
+        self.step += 1
+        cs_tools.cs_print_info(colors.bold("\ntime={0:.12g}".format(self.time)+ " | step="+ str(self.step)))
+
+        self._GetSolver().InitializeSolutionStep()
+
+    def FinalizeSolutionStep(self):
+        self._GetSolver().FinalizeSolutionStep()
+
+    def OutputSolutionStep(self):
+        self._GetSolver().OutputSolutionStep()
+
+        if self.flush_stdout:
+            CoSimulationAnalysis.Flush()
+
+    def _GetSolver(self, solver_name=""):
+        solver = super()._GetSolver()
+        if solver_name == "":
+            return solver
+        else:
+            return solver._GetSolver(solver_name)
+
+    @staticmethod
+    def Flush():
+        sys.stdout.flush()
+        KM.Logger.Flush()
+
+    def _CreateSolver(self):
+        """Create the solver
+        """
+        problem_name = self.cosim_settings["problem_data"]["problem_name"].GetString()
+        return solver_wrapper_factory.CreateSolverWrapper(self.cosim_settings["solver_settings"], self.models, problem_name)
+
+    def _GetSimulationName(self):
+        """Returns the name of the Simulation
+        """
+        simulation_name = type(self).__name__ + ": " + self._GetSolver()._ClassName() + " coupling "
+        list_solvers = self.cosim_settings["solver_settings"]["solvers"].keys()
+        for solver_name in list_solvers:
+            simulation_name += self._GetSolver(solver_name)._ClassName() + " - "
+        simulation_name = simulation_name[0:-3] # Removing last " - "
+        return simulation_name
+
+if __name__ == '__main__':
+    if len(sys.argv) != 2:
+        err_msg  = 'Wrong number of input arguments!\n'
+        err_msg += 'Use this script in the following way:\n'
+        err_msg += '    "python co_simulation_analysis.py <cosim-parameter-file>.json"\n'
+        raise Exception(err_msg)
+
+    parameter_file_name = sys.argv[1]
+
+    with open(parameter_file_name,'r') as parameter_file:
+        parameters = KM.Parameters(parameter_file.read())
+
+    simulation = CoSimulationAnalysis(parameters)
+    simulation.Run()
```

## KratosMultiphysics/CoSimulationApplication/coupling_operations/print_iteration_number.py

 * *Ordering differences only*

```diff
@@ -1,77 +1,77 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
-
-# Additional imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-from KratosMultiphysics.time_based_ascii_file_writer_utility import TimeBasedAsciiFileWriterUtility
-
-def Create(*args):
-    return PrintIterationNumberOperation(*args)
-
-class PrintIterationNumberOperation(CoSimulationCouplingOperation):
-    """This operation is used to print the number of iterations on the strong coupling schemes
-    TODO:
-    - add tests
-    - more cleanup
-    """
-    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
-        super().__init__(settings, process_info, data_communicator)
-        self.model = solver_wrappers[self.settings["solver"].GetString()].model
-        self.model_part_name = self.settings["model_part_name"].GetString()
-        self.model_part = self.model[self.model_part_name]
-
-        self.interval = KM.IntervalUtility(settings)
-
-        if self.model_part.GetCommunicator().MyPID() == 0:
-            output_file_name = self.model_part_name + "_number_iterations.dat"
-            file_handler_settings = KM.Parameters(self.settings["output_file_settings"])
-            if file_handler_settings.Has("file_name"):
-                warn_msg = 'Unexpected user-specified entry found in "output_file_settings": {"file_name": '
-                warn_msg += '"' + file_handler_settings["file_name"].GetString() + '"}\n'
-                warn_msg += 'Using this specififed file name instead of the default "' + output_file_name + '"'
-                cs_tools.cs_print_info(self._ClassName(), warn_msg)
-            else:
-                file_handler_settings.AddEmptyValue("file_name")
-                file_handler_settings["file_name"].SetString(output_file_name)
-            file_header = self._GetFileHeader()
-            self.output_file = TimeBasedAsciiFileWriterUtility(self.model_part, file_handler_settings, file_header).file
-
-    def InitializeSolutionStep(self):
-        self.iteration_number = 0
-
-    def InitializeCouplingIteration(self):
-        self.iteration_number += 1
-
-    def FinalizeSolutionStep(self):
-        current_time = self.model_part.ProcessInfo[KM.TIME]
-        if self.interval.IsInInterval(current_time):
-            if self.model_part.GetCommunicator().MyPID() == 0:
-                self.output_file.write(str(current_time) + "\t" + str(self.iteration_number) + "\n")
-
-    def Finalize(self):
-        if self.model_part.GetCommunicator().MyPID() == 0:
-            self.output_file.close()
-
-    def PrintInfo(self):
-        pass
-
-    def Check(self):
-        pass
-
-    def _GetFileHeader(self):
-        header = "#TIME[s]" + "\t" + "ITERATION_NUMBER\n"
-        return header
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "solver"                : "UNSPECIFIED",
-            "model_part_name"       : "",
-            "interval"              : [0.0, 1e30],
-            "output_file_settings"  : {}
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
+
+# Additional imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+from KratosMultiphysics.time_based_ascii_file_writer_utility import TimeBasedAsciiFileWriterUtility
+
+def Create(*args):
+    return PrintIterationNumberOperation(*args)
+
+class PrintIterationNumberOperation(CoSimulationCouplingOperation):
+    """This operation is used to print the number of iterations on the strong coupling schemes
+    TODO:
+    - add tests
+    - more cleanup
+    """
+    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
+        super().__init__(settings, process_info, data_communicator)
+        self.model = solver_wrappers[self.settings["solver"].GetString()].model
+        self.model_part_name = self.settings["model_part_name"].GetString()
+        self.model_part = self.model[self.model_part_name]
+
+        self.interval = KM.IntervalUtility(settings)
+
+        if self.model_part.GetCommunicator().MyPID() == 0:
+            output_file_name = self.model_part_name + "_number_iterations.dat"
+            file_handler_settings = KM.Parameters(self.settings["output_file_settings"])
+            if file_handler_settings.Has("file_name"):
+                warn_msg = 'Unexpected user-specified entry found in "output_file_settings": {"file_name": '
+                warn_msg += '"' + file_handler_settings["file_name"].GetString() + '"}\n'
+                warn_msg += 'Using this specififed file name instead of the default "' + output_file_name + '"'
+                cs_tools.cs_print_info(self._ClassName(), warn_msg)
+            else:
+                file_handler_settings.AddEmptyValue("file_name")
+                file_handler_settings["file_name"].SetString(output_file_name)
+            file_header = self._GetFileHeader()
+            self.output_file = TimeBasedAsciiFileWriterUtility(self.model_part, file_handler_settings, file_header).file
+
+    def InitializeSolutionStep(self):
+        self.iteration_number = 0
+
+    def InitializeCouplingIteration(self):
+        self.iteration_number += 1
+
+    def FinalizeSolutionStep(self):
+        current_time = self.model_part.ProcessInfo[KM.TIME]
+        if self.interval.IsInInterval(current_time):
+            if self.model_part.GetCommunicator().MyPID() == 0:
+                self.output_file.write(str(current_time) + "\t" + str(self.iteration_number) + "\n")
+
+    def Finalize(self):
+        if self.model_part.GetCommunicator().MyPID() == 0:
+            self.output_file.close()
+
+    def PrintInfo(self):
+        pass
+
+    def Check(self):
+        pass
+
+    def _GetFileHeader(self):
+        header = "#TIME[s]" + "\t" + "ITERATION_NUMBER\n"
+        return header
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "solver"                : "UNSPECIFIED",
+            "model_part_name"       : "",
+            "interval"              : [0.0, 1e30],
+            "output_file_settings"  : {}
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
```

## KratosMultiphysics/CoSimulationApplication/coupling_operations/compute_boundary_force.py

 * *Ordering differences only*

```diff
@@ -1,139 +1,139 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
-
-# Additional imports
-from KratosMultiphysics.time_based_ascii_file_writer_utility import TimeBasedAsciiFileWriterUtility
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-
-def Create(*args):
-    return ComputeBoundaryForce(*args)
-
-class ComputeBoundaryForce(CoSimulationCouplingOperation):
-    """This operation is used to compute forces in a boundary, based on the pressure.
-    TODO:
-    - add messages with different echo-levels
-    - add tests
-    - more cleanup
-    """
-    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
-        super().__init__(settings, process_info, data_communicator)
-        self.model = solver_wrappers[self.settings["solver"].GetString()].model
-        self.model_part_name = self.settings["model_part_name"].GetString()
-        self.model_part = self.model[self.model_part_name]
-        self.write_output_file = self.settings['write_output_file'].GetBool()
-        self.format = self.settings["print_format"].GetString()
-
-        self.width = self.settings["width"].GetDouble()
-        # If 2D case: width from parameters is used
-        # If 3D case: width is not used
-        domain_size = self.model_part.ProcessInfo[KM.DOMAIN_SIZE]
-        if domain_size == 3:
-            self.width = 1
-
-        self.interval = KM.IntervalUtility(settings)
-
-        if(self.model_part.GetCommunicator().MyPID() == 0):
-            if(self.write_output_file):
-                output_file_name = self.model_part_name + "_global_force.dat"
-                file_handler_settings = KM.Parameters(self.settings["output_file_settings"])
-                if file_handler_settings.Has("file_name"):
-                    warn_msg = 'Unexpected user-specified entry found in "output_file_settings": {"file_name": '
-                    warn_msg += '"' + file_handler_settings["file_name"].GetString() + '"}\n'
-                    warn_msg += 'Using this specififed file name instead of the default "' + output_file_name + '"'
-                    cs_tools.cs_print_info(self._ClassName(), warn_msg)
-                else:
-                    file_handler_settings.AddEmptyValue("file_name")
-                    file_handler_settings["file_name"].SetString(output_file_name)
-                file_header = self._GetFileHeader()
-                self.output_file = TimeBasedAsciiFileWriterUtility(self.model_part, file_handler_settings, file_header).file
-
-    def Execute(self):
-        current_time = self.model_part.ProcessInfo[KM.TIME]
-
-        if(self.interval.IsInInterval(current_time)):
-            results = self._EvaluateGlobalForces()
-
-            if(self.model_part.GetCommunicator().MyPID() == 0):
-                output = []
-                output.extend(results)
-                output_values = [format(val, self.format) for val in output]
-                # not formatting time in order to not lead to problems with time recognition
-                # in the file writer when restarting
-                output_values.insert(0, str(current_time))
-
-                if(self.echo_level > 2):
-                    # print to screen the results at echo level 3 or higher
-                    res_labels = ['time: ', 'vel_x: ', 'vel_y: ', 'vel_z: ', 'f_x: ', 'f_y: ', 'f_z: ', 'p: ',]
-                    result_msg = 'Boundary Force force evaluation for model part ' + self.model_part_name + '\n'
-                    result_msg += ', '.join([a + b for a, b in zip(res_labels, output_values)])
-                    cs_tools.cs_print_info(self._ClassName(), result_msg)
-
-                if(self.write_output_file):
-                    self.output_file.write(' '.join(output_values) + '\n')
-
-    def _EvaluateGlobalForces(self):
-        # vel_x, vel_y, vel_z
-        velocity = [0.0, 0.0, 0.0]
-        sum_forces = [0.0, 0.0, 0.0]
-        pressure_list = [0.0]
-
-        utils = KM.VariableUtils()
-        utils.SetVariable(KM.REACTION_X, 0, self.model_part.Nodes)
-        utils.SetVariable(KM.REACTION_Y, 0, self.model_part.Nodes)
-        utils.SetVariable(KM.REACTION_Z, 0, self.model_part.Nodes)
-
-        for element in self.model_part.Elements:
-            geometry = element.GetGeometry()
-            nodes = element.GetNodes()
-            shape_functions_values = geometry.ShapeFunctionsValues()
-            area = geometry.Area()
-            unit_normal = geometry.UnitNormal()
-            pressure = 0
-            c = 0
-
-            for node in nodes:
-                pressure_node = node.GetSolutionStepValue(KM.PRESSURE, 0)
-                force_node = unit_normal * (-1) * pressure_node * area * shape_functions_values[0, c] * self.width
-                pressure += pressure_node * shape_functions_values[0, c]
-
-                node.SetSolutionStepValue(KM.REACTION_X, 0, node.GetSolutionStepValue(KM.REACTION_X, 0) + force_node[0])
-                node.SetSolutionStepValue(KM.REACTION_Y, 0, node.GetSolutionStepValue(KM.REACTION_Y, 0) + force_node[1])
-                node.SetSolutionStepValue(KM.REACTION_Z, 0, node.GetSolutionStepValue(KM.REACTION_Z, 0) + force_node[2])
-                c += 1
-
-            force = unit_normal * pressure * area * self.width
-
-            for i in range(3):
-                sum_forces[i] += force[i]
-
-            pressure_list[0] += pressure
-
-        if self.echo_level > 1:
-            info_msg = "Computed boundary forces for model part \"" + self.model_part_name  + "\" in solver: \"" + self.settings["solver"].GetString() + "\""
-            cs_tools.cs_print_info(self._ClassName(), info_msg)
-
-        return velocity + sum_forces + pressure_list
-
-    def _GetFileHeader(self):
-        header = '# Global force for model part ' + self.model_part_name + '\n'
-        header += '# Time vel_x vel_y vel_z f_x f_y f_z p\n'
-        return header
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "solver"                : "UNSPECIFIED",
-            "model_part_name"       : "",
-            "interval"              : [0.0, 1e30],
-            "print_format"          : ".8f",
-            "width"                 : 1.0,
-            "write_output_file"     : true,
-            "output_file_settings"  : {}
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
+
+# Additional imports
+from KratosMultiphysics.time_based_ascii_file_writer_utility import TimeBasedAsciiFileWriterUtility
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+
+def Create(*args):
+    return ComputeBoundaryForce(*args)
+
+class ComputeBoundaryForce(CoSimulationCouplingOperation):
+    """This operation is used to compute forces in a boundary, based on the pressure.
+    TODO:
+    - add messages with different echo-levels
+    - add tests
+    - more cleanup
+    """
+    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
+        super().__init__(settings, process_info, data_communicator)
+        self.model = solver_wrappers[self.settings["solver"].GetString()].model
+        self.model_part_name = self.settings["model_part_name"].GetString()
+        self.model_part = self.model[self.model_part_name]
+        self.write_output_file = self.settings['write_output_file'].GetBool()
+        self.format = self.settings["print_format"].GetString()
+
+        self.width = self.settings["width"].GetDouble()
+        # If 2D case: width from parameters is used
+        # If 3D case: width is not used
+        domain_size = self.model_part.ProcessInfo[KM.DOMAIN_SIZE]
+        if domain_size == 3:
+            self.width = 1
+
+        self.interval = KM.IntervalUtility(settings)
+
+        if(self.model_part.GetCommunicator().MyPID() == 0):
+            if(self.write_output_file):
+                output_file_name = self.model_part_name + "_global_force.dat"
+                file_handler_settings = KM.Parameters(self.settings["output_file_settings"])
+                if file_handler_settings.Has("file_name"):
+                    warn_msg = 'Unexpected user-specified entry found in "output_file_settings": {"file_name": '
+                    warn_msg += '"' + file_handler_settings["file_name"].GetString() + '"}\n'
+                    warn_msg += 'Using this specififed file name instead of the default "' + output_file_name + '"'
+                    cs_tools.cs_print_info(self._ClassName(), warn_msg)
+                else:
+                    file_handler_settings.AddEmptyValue("file_name")
+                    file_handler_settings["file_name"].SetString(output_file_name)
+                file_header = self._GetFileHeader()
+                self.output_file = TimeBasedAsciiFileWriterUtility(self.model_part, file_handler_settings, file_header).file
+
+    def Execute(self):
+        current_time = self.model_part.ProcessInfo[KM.TIME]
+
+        if(self.interval.IsInInterval(current_time)):
+            results = self._EvaluateGlobalForces()
+
+            if(self.model_part.GetCommunicator().MyPID() == 0):
+                output = []
+                output.extend(results)
+                output_values = [format(val, self.format) for val in output]
+                # not formatting time in order to not lead to problems with time recognition
+                # in the file writer when restarting
+                output_values.insert(0, str(current_time))
+
+                if(self.echo_level > 2):
+                    # print to screen the results at echo level 3 or higher
+                    res_labels = ['time: ', 'vel_x: ', 'vel_y: ', 'vel_z: ', 'f_x: ', 'f_y: ', 'f_z: ', 'p: ',]
+                    result_msg = 'Boundary Force force evaluation for model part ' + self.model_part_name + '\n'
+                    result_msg += ', '.join([a + b for a, b in zip(res_labels, output_values)])
+                    cs_tools.cs_print_info(self._ClassName(), result_msg)
+
+                if(self.write_output_file):
+                    self.output_file.write(' '.join(output_values) + '\n')
+
+    def _EvaluateGlobalForces(self):
+        # vel_x, vel_y, vel_z
+        velocity = [0.0, 0.0, 0.0]
+        sum_forces = [0.0, 0.0, 0.0]
+        pressure_list = [0.0]
+
+        utils = KM.VariableUtils()
+        utils.SetVariable(KM.REACTION_X, 0, self.model_part.Nodes)
+        utils.SetVariable(KM.REACTION_Y, 0, self.model_part.Nodes)
+        utils.SetVariable(KM.REACTION_Z, 0, self.model_part.Nodes)
+
+        for element in self.model_part.Elements:
+            geometry = element.GetGeometry()
+            nodes = element.GetNodes()
+            shape_functions_values = geometry.ShapeFunctionsValues()
+            area = geometry.Area()
+            unit_normal = geometry.UnitNormal()
+            pressure = 0
+            c = 0
+
+            for node in nodes:
+                pressure_node = node.GetSolutionStepValue(KM.PRESSURE, 0)
+                force_node = unit_normal * (-1) * pressure_node * area * shape_functions_values[0, c] * self.width
+                pressure += pressure_node * shape_functions_values[0, c]
+
+                node.SetSolutionStepValue(KM.REACTION_X, 0, node.GetSolutionStepValue(KM.REACTION_X, 0) + force_node[0])
+                node.SetSolutionStepValue(KM.REACTION_Y, 0, node.GetSolutionStepValue(KM.REACTION_Y, 0) + force_node[1])
+                node.SetSolutionStepValue(KM.REACTION_Z, 0, node.GetSolutionStepValue(KM.REACTION_Z, 0) + force_node[2])
+                c += 1
+
+            force = unit_normal * pressure * area * self.width
+
+            for i in range(3):
+                sum_forces[i] += force[i]
+
+            pressure_list[0] += pressure
+
+        if self.echo_level > 1:
+            info_msg = "Computed boundary forces for model part \"" + self.model_part_name  + "\" in solver: \"" + self.settings["solver"].GetString() + "\""
+            cs_tools.cs_print_info(self._ClassName(), info_msg)
+
+        return velocity + sum_forces + pressure_list
+
+    def _GetFileHeader(self):
+        header = '# Global force for model part ' + self.model_part_name + '\n'
+        header += '# Time vel_x vel_y vel_z f_x f_y f_z p\n'
+        return header
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "solver"                : "UNSPECIFIED",
+            "model_part_name"       : "",
+            "interval"              : [0.0, 1e30],
+            "print_format"          : ".8f",
+            "width"                 : 1.0,
+            "write_output_file"     : true,
+            "output_file_settings"  : {}
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
```

## KratosMultiphysics/CoSimulationApplication/coupling_operations/distribute_point_values.py

 * *Ordering differences only*

```diff
@@ -1,80 +1,80 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
-
-def Create(*args):
-    return DistributePointValuesOperation(*args)
-
-class DistributePointValuesOperation(CoSimulationCouplingOperation):
-    """This operation converts concentrated nodal values (such as nodal loads) into distributed quantities (such as tractions)
-    It is the inverse operation of the "ConvertDistributedValuesToPoint" operation
-    """
-
-    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
-        super().__init__(settings, process_info, data_communicator)
-
-        solver_name = self.settings["solver"].GetString()
-        self.data_point = solver_wrappers[solver_name].GetInterfaceData(self.settings["data_point_values"].GetString())
-        self.data_dist  = solver_wrappers[solver_name].GetInterfaceData(self.settings["data_distributed_values"].GetString())
-
-        self.redistribution_iterations = self.settings["redistribution_iterations"].GetInt()
-        self.redistribution_tolerance  = self.settings["redistribution_tolerance"].GetDouble()
-
-        entities_to_use = self.settings["entities"].GetString()
-        if entities_to_use == "conditions":
-            self.entities = self.data_point.GetModelPart().Conditions
-        elif entities_to_use == "elements":
-            self.entities = self.data_point.GetModelPart().Elements
-        else:
-            raise Exception('"entities" can only be "conditions" or "elements"!')
-
-    def Execute(self):
-        # TODO refactor the utility to allow mixed locations!
-        fct_ptr = KM.VariableRedistributionUtility.DistributePointValues
-        if self.data_point.location == "node_non_historical":
-            fct_ptr = KM.VariableRedistributionUtility.DistributePointValuesNonHistorical
-
-        fct_ptr(
-            self.data_point.GetModelPart(),
-            self.entities,
-            self.data_point.variable,
-            self.data_dist.variable,
-            self.redistribution_tolerance,
-            self.redistribution_iterations)
-
-    def Check(self):
-        if self.data_point.model_part_name != self.data_dist.model_part_name:
-            raise Exception('The ModelParts must be the same!\n    ModelPart of point-data:       "{}"\n    ModelPart of distributed-data: "{}"'.format(self.data_point.model_part_name, self.data_dist.model_part_name))
-
-        num_entities = len(self.entities)
-        data_comm = self.data_point.GetModelPart().GetCommunicator().GetDataCommunicator()
-        num_entities = data_comm.SumAll(num_entities)
-        if num_entities < 1:
-            raise Exception('No entities ("{}") found in ModelPart "{}" of interface data "{}" of solver "{}"!'.format(self.settings["entities"].GetString(), self.data_point.model_part_name, self.data_point.name, self.data_point.solver_name))
-
-        if "node" not in self.data_point.location:
-            raise Exception('Only nodal values are supported (and not "{}")!\n    ModelPart "{}" of interface data "{}" of solver "{}"!'.format(self.data_point.location, self.data_point.model_part_name, self.data_point.name, self.data_point.solver_name))
-
-        if self.data_point.location != self.data_dist.location:
-            raise Exception('The location of the data must be the same!\n    Location of data in point-data:       "{}"\n    Location of data in distributed-data: "{}"'.format(self.data_point.location, self.data_dist.location))
-
-        if self.data_point.variable_type not in ["Double", "Array"]:
-            raise Exception('Only variables of type "Double" or "Array" are supported (and not "{}")!\n    ModelPart "{}" of interface data "{}" of solver "{}"!'.format(self.data_point.variable_type, self.data_point.model_part_name, self.data_point.name, self.data_point.solver_name))
-
-        if self.data_point.variable_type != self.data_dist.variable_type:
-            raise Exception('The variable types of the data must be the same!\n    Variable type of data in point-data:       "{}"\n    Variable type of data in distributed-data: "{}"'.format(self.data_point.variable_type, self.data_dist.variable_type))
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "solver"                    : "UNSPECIFIED",
-            "data_point_values"         : "UNSPECIFIED",
-            "data_distributed_values"   : "UNSPECIFIED",
-            "entities"                  : "conditions",
-            "redistribution_tolerance"  : 1e-7,
-            "redistribution_iterations" : 100
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
+
+def Create(*args):
+    return DistributePointValuesOperation(*args)
+
+class DistributePointValuesOperation(CoSimulationCouplingOperation):
+    """This operation converts concentrated nodal values (such as nodal loads) into distributed quantities (such as tractions)
+    It is the inverse operation of the "ConvertDistributedValuesToPoint" operation
+    """
+
+    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
+        super().__init__(settings, process_info, data_communicator)
+
+        solver_name = self.settings["solver"].GetString()
+        self.data_point = solver_wrappers[solver_name].GetInterfaceData(self.settings["data_point_values"].GetString())
+        self.data_dist  = solver_wrappers[solver_name].GetInterfaceData(self.settings["data_distributed_values"].GetString())
+
+        self.redistribution_iterations = self.settings["redistribution_iterations"].GetInt()
+        self.redistribution_tolerance  = self.settings["redistribution_tolerance"].GetDouble()
+
+        entities_to_use = self.settings["entities"].GetString()
+        if entities_to_use == "conditions":
+            self.entities = self.data_point.GetModelPart().Conditions
+        elif entities_to_use == "elements":
+            self.entities = self.data_point.GetModelPart().Elements
+        else:
+            raise Exception('"entities" can only be "conditions" or "elements"!')
+
+    def Execute(self):
+        # TODO refactor the utility to allow mixed locations!
+        fct_ptr = KM.VariableRedistributionUtility.DistributePointValues
+        if self.data_point.location == "node_non_historical":
+            fct_ptr = KM.VariableRedistributionUtility.DistributePointValuesNonHistorical
+
+        fct_ptr(
+            self.data_point.GetModelPart(),
+            self.entities,
+            self.data_point.variable,
+            self.data_dist.variable,
+            self.redistribution_tolerance,
+            self.redistribution_iterations)
+
+    def Check(self):
+        if self.data_point.model_part_name != self.data_dist.model_part_name:
+            raise Exception('The ModelParts must be the same!\n    ModelPart of point-data:       "{}"\n    ModelPart of distributed-data: "{}"'.format(self.data_point.model_part_name, self.data_dist.model_part_name))
+
+        num_entities = len(self.entities)
+        data_comm = self.data_point.GetModelPart().GetCommunicator().GetDataCommunicator()
+        num_entities = data_comm.SumAll(num_entities)
+        if num_entities < 1:
+            raise Exception('No entities ("{}") found in ModelPart "{}" of interface data "{}" of solver "{}"!'.format(self.settings["entities"].GetString(), self.data_point.model_part_name, self.data_point.name, self.data_point.solver_name))
+
+        if "node" not in self.data_point.location:
+            raise Exception('Only nodal values are supported (and not "{}")!\n    ModelPart "{}" of interface data "{}" of solver "{}"!'.format(self.data_point.location, self.data_point.model_part_name, self.data_point.name, self.data_point.solver_name))
+
+        if self.data_point.location != self.data_dist.location:
+            raise Exception('The location of the data must be the same!\n    Location of data in point-data:       "{}"\n    Location of data in distributed-data: "{}"'.format(self.data_point.location, self.data_dist.location))
+
+        if self.data_point.variable_type not in ["Double", "Array"]:
+            raise Exception('Only variables of type "Double" or "Array" are supported (and not "{}")!\n    ModelPart "{}" of interface data "{}" of solver "{}"!'.format(self.data_point.variable_type, self.data_point.model_part_name, self.data_point.name, self.data_point.solver_name))
+
+        if self.data_point.variable_type != self.data_dist.variable_type:
+            raise Exception('The variable types of the data must be the same!\n    Variable type of data in point-data:       "{}"\n    Variable type of data in distributed-data: "{}"'.format(self.data_point.variable_type, self.data_dist.variable_type))
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "solver"                    : "UNSPECIFIED",
+            "data_point_values"         : "UNSPECIFIED",
+            "data_distributed_values"   : "UNSPECIFIED",
+            "entities"                  : "conditions",
+            "redistribution_tolerance"  : 1e-7,
+            "redistribution_iterations" : 100
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
```

## KratosMultiphysics/CoSimulationApplication/coupling_operations/convert_distributed_values_to_point.py

 * *Ordering differences only*

```diff
@@ -1,73 +1,73 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
-
-def Create(*args):
-    return ConvertDistributedValuesToPoint(*args)
-
-class ConvertDistributedValuesToPoint(CoSimulationCouplingOperation):
-    """This operation converts distributed quantities (such as tractions) into concentrated nodal values (such as nodal loads)
-    It is the inverse operation of the "DistributePointValuesOperation" operation
-    """
-
-    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
-        super().__init__(settings, process_info, data_communicator)
-
-        solver_name = self.settings["solver"].GetString()
-        self.data_point = solver_wrappers[solver_name].GetInterfaceData(self.settings["data_point_values"].GetString())
-        self.data_dist  = solver_wrappers[solver_name].GetInterfaceData(self.settings["data_distributed_values"].GetString())
-
-        entities_to_use = self.settings["entities"].GetString()
-        if entities_to_use == "conditions":
-            self.entities = self.data_point.GetModelPart().Conditions
-        elif entities_to_use == "elements":
-            self.entities = self.data_point.GetModelPart().Elements
-        else:
-            raise Exception('"entities" can only be "conditions" or "elements"!')
-
-    def Execute(self):
-        # TODO refactor the utility to allow mixed locations!
-        fct_ptr = KM.VariableRedistributionUtility.ConvertDistributedValuesToPoint
-        if self.data_point.location == "node_non_historical":
-            fct_ptr = KM.VariableRedistributionUtility.ConvertDistributedValuesToPointNonHistorical
-
-        fct_ptr(
-            self.data_point.GetModelPart(),
-            self.entities,
-            self.data_dist.variable,
-            self.data_point.variable)
-
-    def Check(self):
-        if self.data_point.model_part_name != self.data_dist.model_part_name:
-            raise Exception('The ModelParts must be the same!\n    ModelPart of point-data:       "{}"\n    ModelPart of distributed-data: "{}"'.format(self.data_point.model_part_name, self.data_dist.model_part_name))
-
-        num_entities = len(self.entities)
-        data_comm = self.data_point.GetModelPart().GetCommunicator().GetDataCommunicator()
-        num_entities = data_comm.SumAll(num_entities)
-        if num_entities < 1:
-            raise Exception('No entities ("{}") found in ModelPart "{}" of interface data "{}" of solver "{}"!'.format(self.settings["entities"].GetString(), self.data_point.model_part_name, self.data_point.name, self.data_point.solver_name))
-
-        if "node" not in self.data_point.location:
-            raise Exception('Only nodal values are supported (and not "{}")!\n    ModelPart "{}" of interface data "{}" of solver "{}"!'.format(self.data_point.location, self.data_point.model_part_name, self.data_point.name, self.data_point.solver_name))
-
-        if self.data_point.location != self.data_dist.location:
-            raise Exception('The location of the data must be the same!\n    Location of data in point-data:       "{}"\n    Location of data in distributed-data: "{}"'.format(self.data_point.location, self.data_dist.location))
-
-        if self.data_point.variable_type not in ["Double", "Array"]:
-            raise Exception('Only variables of type "Double" or "Array" are supported (and not "{}")!\n    ModelPart "{}" of interface data "{}" of solver "{}"!'.format(self.data_point.variable_type, self.data_point.model_part_name, self.data_point.name, self.data_point.solver_name))
-
-        if self.data_point.variable_type != self.data_dist.variable_type:
-            raise Exception('The variable types of the data must be the same!\n    Variable type of data in point-data:       "{}"\n    Variable type of data in distributed-data: "{}"'.format(self.data_point.variable_type, self.data_dist.variable_type))
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "solver"                    : "UNSPECIFIED",
-            "data_point_values"         : "UNSPECIFIED",
-            "data_distributed_values"   : "UNSPECIFIED",
-            "entities"                  : "conditions"
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
+
+def Create(*args):
+    return ConvertDistributedValuesToPoint(*args)
+
+class ConvertDistributedValuesToPoint(CoSimulationCouplingOperation):
+    """This operation converts distributed quantities (such as tractions) into concentrated nodal values (such as nodal loads)
+    It is the inverse operation of the "DistributePointValuesOperation" operation
+    """
+
+    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
+        super().__init__(settings, process_info, data_communicator)
+
+        solver_name = self.settings["solver"].GetString()
+        self.data_point = solver_wrappers[solver_name].GetInterfaceData(self.settings["data_point_values"].GetString())
+        self.data_dist  = solver_wrappers[solver_name].GetInterfaceData(self.settings["data_distributed_values"].GetString())
+
+        entities_to_use = self.settings["entities"].GetString()
+        if entities_to_use == "conditions":
+            self.entities = self.data_point.GetModelPart().Conditions
+        elif entities_to_use == "elements":
+            self.entities = self.data_point.GetModelPart().Elements
+        else:
+            raise Exception('"entities" can only be "conditions" or "elements"!')
+
+    def Execute(self):
+        # TODO refactor the utility to allow mixed locations!
+        fct_ptr = KM.VariableRedistributionUtility.ConvertDistributedValuesToPoint
+        if self.data_point.location == "node_non_historical":
+            fct_ptr = KM.VariableRedistributionUtility.ConvertDistributedValuesToPointNonHistorical
+
+        fct_ptr(
+            self.data_point.GetModelPart(),
+            self.entities,
+            self.data_dist.variable,
+            self.data_point.variable)
+
+    def Check(self):
+        if self.data_point.model_part_name != self.data_dist.model_part_name:
+            raise Exception('The ModelParts must be the same!\n    ModelPart of point-data:       "{}"\n    ModelPart of distributed-data: "{}"'.format(self.data_point.model_part_name, self.data_dist.model_part_name))
+
+        num_entities = len(self.entities)
+        data_comm = self.data_point.GetModelPart().GetCommunicator().GetDataCommunicator()
+        num_entities = data_comm.SumAll(num_entities)
+        if num_entities < 1:
+            raise Exception('No entities ("{}") found in ModelPart "{}" of interface data "{}" of solver "{}"!'.format(self.settings["entities"].GetString(), self.data_point.model_part_name, self.data_point.name, self.data_point.solver_name))
+
+        if "node" not in self.data_point.location:
+            raise Exception('Only nodal values are supported (and not "{}")!\n    ModelPart "{}" of interface data "{}" of solver "{}"!'.format(self.data_point.location, self.data_point.model_part_name, self.data_point.name, self.data_point.solver_name))
+
+        if self.data_point.location != self.data_dist.location:
+            raise Exception('The location of the data must be the same!\n    Location of data in point-data:       "{}"\n    Location of data in distributed-data: "{}"'.format(self.data_point.location, self.data_dist.location))
+
+        if self.data_point.variable_type not in ["Double", "Array"]:
+            raise Exception('Only variables of type "Double" or "Array" are supported (and not "{}")!\n    ModelPart "{}" of interface data "{}" of solver "{}"!'.format(self.data_point.variable_type, self.data_point.model_part_name, self.data_point.name, self.data_point.solver_name))
+
+        if self.data_point.variable_type != self.data_dist.variable_type:
+            raise Exception('The variable types of the data must be the same!\n    Variable type of data in point-data:       "{}"\n    Variable type of data in distributed-data: "{}"'.format(self.data_point.variable_type, self.data_dist.variable_type))
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "solver"                    : "UNSPECIFIED",
+            "data_point_values"         : "UNSPECIFIED",
+            "data_distributed_values"   : "UNSPECIFIED",
+            "entities"                  : "conditions"
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
```

## KratosMultiphysics/CoSimulationApplication/coupling_operations/compute_normals.py

 * *Ordering differences only*

```diff
@@ -1,60 +1,60 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
-
-def Create(*args):
-    return ComputeNormalsOperation(*args)
-
-class ComputeNormalsOperation(CoSimulationCouplingOperation):
-    """This operation computes the Normals (NORMAL) on a given ModelPart
-    """
-    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
-        super().__init__(settings, process_info, data_communicator)
-        solver_name = self.settings["solver"].GetString()
-        data_name = self.settings["data_name"].GetString()
-        self.interface_data = solver_wrappers[solver_name].GetInterfaceData(data_name)
-
-    def Initialize(self):
-        pass
-
-    def Finalize(self):
-        pass
-
-    def InitializeSolutionStep(self):
-        pass
-
-    def FinalizeSolutionStep(self):
-        pass
-
-    def InitializeCouplingIteration(self):
-        pass
-
-    def FinalizeCouplingIteration(self):
-        pass
-
-    def Execute(self):
-        if not self.interface_data.IsDefinedOnThisRank(): return
-
-        smp_normal_calculator = self.interface_data.GetModelPart()
-        KM.NormalCalculationUtils().CalculateNormals(smp_normal_calculator)
-
-    def PrintInfo(self):
-        pass
-
-    def Check(self):
-        # TODO in case the NORMALS are computed with historical variables then you should check if the var is in the ModelPart
-        pass
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "solver"    : "UNSPECIFIED",
-            "data_name" : "UNSPECIFIED"
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
-
-
-
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
+
+def Create(*args):
+    return ComputeNormalsOperation(*args)
+
+class ComputeNormalsOperation(CoSimulationCouplingOperation):
+    """This operation computes the Normals (NORMAL) on a given ModelPart
+    """
+    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
+        super().__init__(settings, process_info, data_communicator)
+        solver_name = self.settings["solver"].GetString()
+        data_name = self.settings["data_name"].GetString()
+        self.interface_data = solver_wrappers[solver_name].GetInterfaceData(data_name)
+
+    def Initialize(self):
+        pass
+
+    def Finalize(self):
+        pass
+
+    def InitializeSolutionStep(self):
+        pass
+
+    def FinalizeSolutionStep(self):
+        pass
+
+    def InitializeCouplingIteration(self):
+        pass
+
+    def FinalizeCouplingIteration(self):
+        pass
+
+    def Execute(self):
+        if not self.interface_data.IsDefinedOnThisRank(): return
+
+        smp_normal_calculator = self.interface_data.GetModelPart()
+        KM.NormalCalculationUtils().CalculateNormals(smp_normal_calculator)
+
+    def PrintInfo(self):
+        pass
+
+    def Check(self):
+        # TODO in case the NORMALS are computed with historical variables then you should check if the var is in the ModelPart
+        pass
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "solver"    : "UNSPECIFIED",
+            "data_name" : "UNSPECIFIED"
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
+
+
+
```

## KratosMultiphysics/CoSimulationApplication/coupling_operations/coupling_output.py

 * *Ordering differences only*

```diff
@@ -1,76 +1,76 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
-
-def Create(*args):
-    return CouplingOutput(*args)
-
-class CouplingOutput(CoSimulationCouplingOperation):
-    """This operation is used to output at different points in the coupling.
-    TODO:
-    - add support for json, hdf5, gid
-    - add tests
-    - more cleanup
-    """
-    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
-        super().__init__(settings, process_info, data_communicator)
-        self.model = solver_wrappers[self.settings["solver"].GetString()].model
-        self.execution_point = self.settings["execution_point"].GetString()
-        model_part_name = self.settings["output_parameters"]["model_part_name"].GetString()
-        model_part = self.model[model_part_name]
-        self.base_output_file_name = "{}_{}_{}_{}_".format(self.settings["solver"].GetString(), model_part_name, self.execution_point, model_part.GetCommunicator().MyPID())
-
-        available_execution_points = [
-            "initialize_solution_step",
-            "finalize_solution_step",
-            "initialize_coupling_iteration",
-            "finalize_coupling_iteration"
-        ]
-
-        if self.execution_point not in available_execution_points:
-            err_msg  = 'Execution point "{}" is not available, only the following options are available:\n    '.format(self.execution_point)
-            err_msg += "\n    ".join(available_execution_points)
-            raise Exception(err_msg)
-
-        self.step = 0 # this should come from self.process_info
-        # TODO check if restarted. If not delete the folder => check self.process_info
-        self.output = KM.VtkOutput(model_part, self.settings["output_parameters"]) # currently hardcoded to vtk
-
-    def InitializeSolutionStep(self):
-        self.step += 1
-        self.coupling_iteration = 0
-
-        if self.execution_point == "initialize_solution_step":
-            output_file_name = self.base_output_file_name + str(self.step)
-            self.output.PrintOutput(output_file_name)
-
-    def FinalizeSolutionStep(self):
-        if self.execution_point == "finalize_solution_step":
-            output_file_name = self.base_output_file_name + str(self.step)
-            self.output.PrintOutput(output_file_name)
-
-    def InitializeCouplingIteration(self):
-        self.coupling_iteration += 1
-
-        if self.execution_point == "initialize_coupling_iteration":
-            output_file_name = self.base_output_file_name + "{}_{}".format(self.step, self.coupling_iteration)
-            self.output.PrintOutput(output_file_name)
-
-    def FinalizeCouplingIteration(self):
-        if self.execution_point == "finalize_coupling_iteration":
-            output_file_name = self.base_output_file_name + "{}_{}".format(self.step, self.coupling_iteration)
-            self.output.PrintOutput(output_file_name)
-
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "solver"            : "UNSPECIFIED",
-            "execution_point"   : "UNSPECIFIED",
-            "output_format"     : "vtk",
-            "output_parameters" : { }
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
+
+def Create(*args):
+    return CouplingOutput(*args)
+
+class CouplingOutput(CoSimulationCouplingOperation):
+    """This operation is used to output at different points in the coupling.
+    TODO:
+    - add support for json, hdf5, gid
+    - add tests
+    - more cleanup
+    """
+    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
+        super().__init__(settings, process_info, data_communicator)
+        self.model = solver_wrappers[self.settings["solver"].GetString()].model
+        self.execution_point = self.settings["execution_point"].GetString()
+        model_part_name = self.settings["output_parameters"]["model_part_name"].GetString()
+        model_part = self.model[model_part_name]
+        self.base_output_file_name = "{}_{}_{}_{}_".format(self.settings["solver"].GetString(), model_part_name, self.execution_point, model_part.GetCommunicator().MyPID())
+
+        available_execution_points = [
+            "initialize_solution_step",
+            "finalize_solution_step",
+            "initialize_coupling_iteration",
+            "finalize_coupling_iteration"
+        ]
+
+        if self.execution_point not in available_execution_points:
+            err_msg  = 'Execution point "{}" is not available, only the following options are available:\n    '.format(self.execution_point)
+            err_msg += "\n    ".join(available_execution_points)
+            raise Exception(err_msg)
+
+        self.step = 0 # this should come from self.process_info
+        # TODO check if restarted. If not delete the folder => check self.process_info
+        self.output = KM.VtkOutput(model_part, self.settings["output_parameters"]) # currently hardcoded to vtk
+
+    def InitializeSolutionStep(self):
+        self.step += 1
+        self.coupling_iteration = 0
+
+        if self.execution_point == "initialize_solution_step":
+            output_file_name = self.base_output_file_name + str(self.step)
+            self.output.PrintOutput(output_file_name)
+
+    def FinalizeSolutionStep(self):
+        if self.execution_point == "finalize_solution_step":
+            output_file_name = self.base_output_file_name + str(self.step)
+            self.output.PrintOutput(output_file_name)
+
+    def InitializeCouplingIteration(self):
+        self.coupling_iteration += 1
+
+        if self.execution_point == "initialize_coupling_iteration":
+            output_file_name = self.base_output_file_name + "{}_{}".format(self.step, self.coupling_iteration)
+            self.output.PrintOutput(output_file_name)
+
+    def FinalizeCouplingIteration(self):
+        if self.execution_point == "finalize_coupling_iteration":
+            output_file_name = self.base_output_file_name + "{}_{}".format(self.step, self.coupling_iteration)
+            self.output.PrintOutput(output_file_name)
+
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "solver"            : "UNSPECIFIED",
+            "execution_point"   : "UNSPECIFIED",
+            "output_format"     : "vtk",
+            "output_parameters" : { }
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
```

## KratosMultiphysics/CoSimulationApplication/coupling_operations/elemental_data_to_nodal_data.py

 * *Ordering differences only*

```diff
@@ -1,59 +1,59 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
-from KratosMultiphysics.CoSimulationApplication import ConversionUtilities
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-
-def Create(*args):
-    return ElementalToNodalData(*args)
-
-class ElementalToNodalData(CoSimulationCouplingOperation):
-    """This operation maps the Elemental Data to Nodal Data for a given ModelPart
-    """
-    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
-        super().__init__(settings, process_info, data_communicator)
-        solver_name = self.settings["solver"].GetString()
-        data_name = self.settings["data_name"].GetString()
-        self.interface_data = solver_wrappers[solver_name].GetInterfaceData(data_name)
-
-    def Execute(self):
-        if not self.interface_data.IsDefinedOnThisRank(): return
-
-        process_info = self.interface_data.GetModelPart().ProcessInfo
-        time = process_info[KM.TIME]
-
-        if not KM.IntervalUtility(self.settings).IsInInterval(time):
-            if self.echo_level > 0:
-                cs_tools.cs_print_info("Elemental_data_to_Nodal_data", "Skipped, not in interval")
-            return
-
-        model_part_interface = self.interface_data.GetModelPart()
-
-        ConversionUtilities.ConvertElementalDataToNodalData(model_part_interface, KM.FORCE, KM.FORCE) # TODO this should be configurable
-
-        if self.echo_level > 0:
-            cs_tools.cs_print_info("Elemental_data_to_Nodal_data", "Done")
-
-    def PrintInfo(self):
-        pass
-
-    def Check(self):
-        # TODO in case the NORMALS are computed with historical variables then you should check if the var is in the ModelPart
-        pass
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "solver"    : "UNSPECIFIED",
-            "data_name" : "UNSPECIFIED",
-            "interval"  : [0.0, 1e30]
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
-
-
-
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
+from KratosMultiphysics.CoSimulationApplication import ConversionUtilities
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+
+def Create(*args):
+    return ElementalToNodalData(*args)
+
+class ElementalToNodalData(CoSimulationCouplingOperation):
+    """This operation maps the Elemental Data to Nodal Data for a given ModelPart
+    """
+    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
+        super().__init__(settings, process_info, data_communicator)
+        solver_name = self.settings["solver"].GetString()
+        data_name = self.settings["data_name"].GetString()
+        self.interface_data = solver_wrappers[solver_name].GetInterfaceData(data_name)
+
+    def Execute(self):
+        if not self.interface_data.IsDefinedOnThisRank(): return
+
+        process_info = self.interface_data.GetModelPart().ProcessInfo
+        time = process_info[KM.TIME]
+
+        if not KM.IntervalUtility(self.settings).IsInInterval(time):
+            if self.echo_level > 0:
+                cs_tools.cs_print_info("Elemental_data_to_Nodal_data", "Skipped, not in interval")
+            return
+
+        model_part_interface = self.interface_data.GetModelPart()
+
+        ConversionUtilities.ConvertElementalDataToNodalData(model_part_interface, KM.FORCE, KM.FORCE) # TODO this should be configurable
+
+        if self.echo_level > 0:
+            cs_tools.cs_print_info("Elemental_data_to_Nodal_data", "Done")
+
+    def PrintInfo(self):
+        pass
+
+    def Check(self):
+        # TODO in case the NORMALS are computed with historical variables then you should check if the var is in the ModelPart
+        pass
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "solver"    : "UNSPECIFIED",
+            "data_name" : "UNSPECIFIED",
+            "interval"  : [0.0, 1e30]
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
+
+
+
```

## KratosMultiphysics/CoSimulationApplication/coupling_operations/reset_pfem_kinematics.py

 * *Ordering differences only*

```diff
@@ -1,47 +1,47 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-
-def Create(*args):
-    return ResetPfemKinematics(*args)
-
-class ResetPfemKinematics(CoSimulationCouplingOperation):
-    """This operation is used to reset the PFEM kinematic values on a given model part.
-    It does not touch the SOLID/RIGID nodes
-    (See the PfemFluidDynamicsApp - move_mesh_utility.cpp implementation)
-    TODO:
-    - add tests
-    - more cleanup
-    """
-    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
-        super().__init__(settings, process_info, data_communicator)
-        model = solver_wrappers[self.settings["solver"].GetString()].model
-        self.model_part_name = self.settings["model_part_name"].GetString()
-        self.model_part = model[self.model_part_name]
-
-        self.interval = KM.IntervalUtility(settings)
-
-    def InitializeCouplingIteration(self):
-        if self.interval.IsInInterval(self.model_part.ProcessInfo[KM.TIME]):
-            self._ResetPfemKinematicValues()
-
-            if self.echo_level > 0:
-                cs_tools.cs_print_info(self._ClassName(), "PFEM KINEMATICS RESET IN MODEL PART: " + self.model_part_name)
-
-    def _ResetPfemKinematicValues(self):
-        KM.PfemFluidDynamicsApplication.PFEMMoveMeshUtility.ResetPfemKinematicValues(self.model_part)
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "solver"                : "UNSPECIFIED",
-            "model_part_name"       : "",
-            "interval"              : [0.0, 1e30]
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+
+def Create(*args):
+    return ResetPfemKinematics(*args)
+
+class ResetPfemKinematics(CoSimulationCouplingOperation):
+    """This operation is used to reset the PFEM kinematic values on a given model part.
+    It does not touch the SOLID/RIGID nodes
+    (See the PfemFluidDynamicsApp - move_mesh_utility.cpp implementation)
+    TODO:
+    - add tests
+    - more cleanup
+    """
+    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
+        super().__init__(settings, process_info, data_communicator)
+        model = solver_wrappers[self.settings["solver"].GetString()].model
+        self.model_part_name = self.settings["model_part_name"].GetString()
+        self.model_part = model[self.model_part_name]
+
+        self.interval = KM.IntervalUtility(settings)
+
+    def InitializeCouplingIteration(self):
+        if self.interval.IsInInterval(self.model_part.ProcessInfo[KM.TIME]):
+            self._ResetPfemKinematicValues()
+
+            if self.echo_level > 0:
+                cs_tools.cs_print_info(self._ClassName(), "PFEM KINEMATICS RESET IN MODEL PART: " + self.model_part_name)
+
+    def _ResetPfemKinematicValues(self):
+        KM.PfemFluidDynamicsApplication.PFEMMoveMeshUtility.ResetPfemKinematicValues(self.model_part)
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "solver"                : "UNSPECIFIED",
+            "model_part_name"       : "",
+            "interval"              : [0.0, 1e30]
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
```

## KratosMultiphysics/CoSimulationApplication/coupling_operations/scaling.py

 * *Ordering differences only*

```diff
@@ -1,74 +1,74 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-from KratosMultiphysics.CoSimulationApplication.function_callback_utility import GenericCallFunction
-
-def Create(*args):
-    return ScalingOperation(*args)
-
-class ScalingOperation(CoSimulationCouplingOperation):
-    """This operation performs scaling of values on an InterfaceData
-    The value can be given directly as a value or as a string containing an evaluable function
-    """
-    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
-        if not settings.Has("scaling_factor"):
-            raise Exception('Please provide a "scaling_factor"!')
-
-        if settings["scaling_factor"].IsString():
-            self.scaling_factor = settings["scaling_factor"].GetString()
-        elif settings["scaling_factor"].IsNumber():
-            self.scaling_factor = settings["scaling_factor"].GetDouble()
-        else:
-            raise Exception('The "scaling_factor" can only be provided as a number or a function-string')
-
-        # removing since the type of "scaling_factor" can be double or string and hence would fail in the validation
-        settings.RemoveValue("scaling_factor")
-
-        super().__init__(settings, process_info, data_communicator)
-
-        solver_name = self.settings["solver"].GetString()
-        data_name = self.settings["data_name"].GetString()
-        self.interface_data = solver_wrappers[solver_name].GetInterfaceData(data_name)
-
-    def Execute(self):
-        if not self.interface_data.IsDefinedOnThisRank(): return
-
-        process_info = self.interface_data.GetModelPart().ProcessInfo
-        time = process_info[KM.TIME]
-        step = process_info[KM.STEP]
-
-        if not KM.IntervalUtility(self.settings).IsInInterval(time):
-            if self.echo_level > 0:
-                cs_tools.cs_print_info("ScalingOperation", "Skipped, not in interval")
-            return
-
-        if isinstance(self.scaling_factor, str):
-            # TODO maybe make this to use COSIM_TIME and COSIM_STEP, such that it is generic for all solvers
-            scope_vars = {'t' : time, 'step' : step} # make time and step useable in function
-            current_scaling_factor = GenericCallFunction(self.scaling_factor, scope_vars, check=False) # evaluating function string
-        else:
-            current_scaling_factor = self.scaling_factor
-
-        if self.echo_level > 0:
-            cs_tools.cs_print_info("ScalingOperation", "Scaling-Factor", current_scaling_factor)
-        self.interface_data.SetData(current_scaling_factor*self.interface_data.GetData()) # setting the scaled data
-
-    def Check(self):
-        if isinstance(self.scaling_factor, str):
-            scope_vars = {'t' : 0.1, 'step' : 2} # dummy for testing
-            GenericCallFunction(self.scaling_factor, scope_vars, check=True) # trying to evaluate the function string, such that the check can be disabled later
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "solver"    : "UNSPECIFIED",
-            "data_name" : "UNSPECIFIED",
-            "interval"  : [0.0, 1e30]
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+from KratosMultiphysics.CoSimulationApplication.function_callback_utility import GenericCallFunction
+
+def Create(*args):
+    return ScalingOperation(*args)
+
+class ScalingOperation(CoSimulationCouplingOperation):
+    """This operation performs scaling of values on an InterfaceData
+    The value can be given directly as a value or as a string containing an evaluable function
+    """
+    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
+        if not settings.Has("scaling_factor"):
+            raise Exception('Please provide a "scaling_factor"!')
+
+        if settings["scaling_factor"].IsString():
+            self.scaling_factor = settings["scaling_factor"].GetString()
+        elif settings["scaling_factor"].IsNumber():
+            self.scaling_factor = settings["scaling_factor"].GetDouble()
+        else:
+            raise Exception('The "scaling_factor" can only be provided as a number or a function-string')
+
+        # removing since the type of "scaling_factor" can be double or string and hence would fail in the validation
+        settings.RemoveValue("scaling_factor")
+
+        super().__init__(settings, process_info, data_communicator)
+
+        solver_name = self.settings["solver"].GetString()
+        data_name = self.settings["data_name"].GetString()
+        self.interface_data = solver_wrappers[solver_name].GetInterfaceData(data_name)
+
+    def Execute(self):
+        if not self.interface_data.IsDefinedOnThisRank(): return
+
+        process_info = self.interface_data.GetModelPart().ProcessInfo
+        time = process_info[KM.TIME]
+        step = process_info[KM.STEP]
+
+        if not KM.IntervalUtility(self.settings).IsInInterval(time):
+            if self.echo_level > 0:
+                cs_tools.cs_print_info("ScalingOperation", "Skipped, not in interval")
+            return
+
+        if isinstance(self.scaling_factor, str):
+            # TODO maybe make this to use COSIM_TIME and COSIM_STEP, such that it is generic for all solvers
+            scope_vars = {'t' : time, 'step' : step} # make time and step useable in function
+            current_scaling_factor = GenericCallFunction(self.scaling_factor, scope_vars, check=False) # evaluating function string
+        else:
+            current_scaling_factor = self.scaling_factor
+
+        if self.echo_level > 0:
+            cs_tools.cs_print_info("ScalingOperation", "Scaling-Factor", current_scaling_factor)
+        self.interface_data.SetData(current_scaling_factor*self.interface_data.GetData()) # setting the scaled data
+
+    def Check(self):
+        if isinstance(self.scaling_factor, str):
+            scope_vars = {'t' : 0.1, 'step' : 2} # dummy for testing
+            GenericCallFunction(self.scaling_factor, scope_vars, check=True) # trying to evaluate the function string, such that the check can be disabled later
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "solver"    : "UNSPECIFIED",
+            "data_name" : "UNSPECIFIED",
+            "interval"  : [0.0, 1e30]
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
```

## KratosMultiphysics/CoSimulationApplication/coupling_operations/create_point_load_model_part.py

 * *Ordering differences only*

```diff
@@ -1,50 +1,50 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-from KratosMultiphysics.kratos_utilities import IssueDeprecationWarning
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-
-def Create(*args):
-    return CreatePointLoadModelPart(*args)
-
-class CreatePointLoadModelPart(CoSimulationCouplingOperation):
-    """This operation creates a submodelpart containing PointLoad Conidtions for transferring loads
-    """
-    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
-        IssueDeprecationWarning('CreatePointLoadModelPart', 'please use CreatePointBasedEntitiesProcess" instead')
-        super().__init__(settings, process_info, data_communicator)
-        self.model = solver_wrappers[self.settings["solver"].GetString()].model
-
-    def Initialize(self):
-        computing_model_part_name = self.settings["computing_model_part_name"].GetString()
-        sub_model_part_name = self.settings["sub_model_part_name"].GetString()
-
-        computing_domain = self.model[computing_model_part_name]
-
-        node_id_list = []
-        number_of_conditions = computing_domain.NumberOfConditions()
-        for cond_counter,node_i in enumerate(computing_domain.Nodes):
-            node_id_list.append(node_i.Id)
-            computing_domain.CreateNewCondition(
-                "PointLoadCondition3D1N",cond_counter+number_of_conditions+1,[node_i.Id],
-                computing_domain.GetProperties()[0])
-
-        struct_smp = computing_domain.CreateSubModelPart(sub_model_part_name)
-        struct_smp.AddNodes(node_id_list)
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "solver"    : "UNSPECIFIED",
-            "sub_model_part_name" : "UNSPECIFIED",
-            "computing_model_part_name" : "UNSPECIFIED"
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
-
-
-
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+from KratosMultiphysics.kratos_utilities import IssueDeprecationWarning
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupling_operation import CoSimulationCouplingOperation
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+
+def Create(*args):
+    return CreatePointLoadModelPart(*args)
+
+class CreatePointLoadModelPart(CoSimulationCouplingOperation):
+    """This operation creates a submodelpart containing PointLoad Conidtions for transferring loads
+    """
+    def __init__(self, settings, solver_wrappers, process_info, data_communicator):
+        IssueDeprecationWarning('CreatePointLoadModelPart', 'please use CreatePointBasedEntitiesProcess" instead')
+        super().__init__(settings, process_info, data_communicator)
+        self.model = solver_wrappers[self.settings["solver"].GetString()].model
+
+    def Initialize(self):
+        computing_model_part_name = self.settings["computing_model_part_name"].GetString()
+        sub_model_part_name = self.settings["sub_model_part_name"].GetString()
+
+        computing_domain = self.model[computing_model_part_name]
+
+        node_id_list = []
+        number_of_conditions = computing_domain.NumberOfConditions()
+        for cond_counter,node_i in enumerate(computing_domain.Nodes):
+            node_id_list.append(node_i.Id)
+            computing_domain.CreateNewCondition(
+                "PointLoadCondition3D1N",cond_counter+number_of_conditions+1,[node_i.Id],
+                computing_domain.GetProperties()[0])
+
+        struct_smp = computing_domain.CreateSubModelPart(sub_model_part_name)
+        struct_smp.AddNodes(node_id_list)
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "solver"    : "UNSPECIFIED",
+            "sub_model_part_name" : "UNSPECIFIED",
+            "computing_model_part_name" : "UNSPECIFIED"
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
+
+
+
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/kratos_base_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,169 +1,169 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
-
-# Other imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-
-# Import importlib to be able to load analysis stages from a string
-from importlib import import_module
-
-# Import string for capwords function
-import string
-
-class ThreadManager:
-    """Class for setting and ressting the number of threads a context should use."""
-    def __init__(self, num_threads=None):
-        self.num_threads = num_threads
-        if self.num_threads:
-            self.num_threads_orig = KM.ParallelUtilities.GetNumThreads()
-
-    def __enter__(self):
-        if self.num_threads:
-            KM.ParallelUtilities.SetNumThreads(min(self.num_threads, self.num_threads_orig))
-
-    def __exit__(self, exc_type, exc_value, traceback):
-        if self.num_threads:
-            KM.ParallelUtilities.SetNumThreads(self.num_threads_orig)
-
-
-def Create(settings, model, solver_name):
-    return KratosBaseWrapper(settings, model, solver_name)
-
-class KratosBaseWrapper(CoSimulationSolverWrapper):
-    """This class serves as basis for the kratos-wrappers
-    It uses the AnalysisStage as black-box interface to Kratos
-    """
-    def __init__(self, settings, model, solver_name):
-        # We try to read the input file
-        if settings["solver_wrapper_settings"].Has("input_file"):
-            input_file_name = settings["solver_wrapper_settings"]["input_file"].GetString()
-            if not input_file_name.endswith(".json"):
-                input_file_name += ".json"
-
-            with open(input_file_name,'r') as parameter_file:
-                self.project_parameters = KM.Parameters(parameter_file.read())
-        else: # The settings are in the root Parameters
-            self.project_parameters = settings["solver_wrapper_settings"]
-
-        super().__init__(settings, model, solver_name)
-
-        if self.settings["solver_wrapper_settings"].Has("num_threads"):
-            omp_num_threads = self.settings["solver_wrapper_settings"]["num_threads"].GetInt()
-            self.thread_manager = ThreadManager(omp_num_threads)
-        else:
-            self.thread_manager = ThreadManager()
-
-        # this creates the AnalysisStage, creates the MainModelParts and allocates the historial Variables on the MainModelParts:
-        with self.thread_manager:
-            self._analysis_stage = self.__GetAnalysisStage()
-
-    def Initialize(self):
-        with self.thread_manager:
-            self._analysis_stage.Initialize() # this reades the Meshes
-        super().Initialize()
-
-    def Finalize(self):
-        super().Finalize()
-        with self.thread_manager:
-            self._analysis_stage.Finalize()
-
-    def AdvanceInTime(self, current_time):
-        with self.thread_manager:
-            new_time = self._analysis_stage._GetSolver().AdvanceInTime(current_time)
-        self._analysis_stage.time = new_time # only needed to print the time correctly
-        return new_time
-
-    def InitializeSolutionStep(self):
-        with self.thread_manager:
-            self._analysis_stage.InitializeSolutionStep()
-
-    def Predict(self):
-        with self.thread_manager:
-            self._analysis_stage._GetSolver().Predict()
-
-    def SolveSolutionStep(self):
-        with self.thread_manager:
-            self._analysis_stage._GetSolver().SolveSolutionStep()
-        super().SolveSolutionStep()
-
-    def FinalizeSolutionStep(self):
-        with self.thread_manager:
-            self._analysis_stage.FinalizeSolutionStep()
-
-    def OutputSolutionStep(self):
-        with self.thread_manager:
-            self._analysis_stage.OutputSolutionStep()
-
-    def _CreateAnalysisStage(self):
-        raise Exception('The "KratosBaseWrapper" can only be used when specifying "analysis_stage_module", otherwise the creation of the AnalysisStage must be implemented in the derived class!')
-
-    def __GetAnalysisStage(self):
-        if self.settings["solver_wrapper_settings"].Has("analysis_stage_module"):
-            module_name = self.settings["solver_wrapper_settings"]["analysis_stage_module"].GetString()
-            analysis_stage_module = import_module(module_name)
-            if hasattr(analysis_stage_module, "Create"):
-                return analysis_stage_module.Create(self.model, self.project_parameters)
-            else:
-                KM.Logger.PrintWarning("KratosBaseWrapper", f'The analysis_stage_module "{module_name}" does not have a "Create" function, trying to create the AnalysisStage directly...')
-                # We assume that the name of the AnalysisStage is the same as the name of the module in PascalCase instead of snake_case
-                file_name = module_name.split(".")[-1]
-                # Convert Snake case to Pascal case
-                analysis_stage_name = string.capwords(file_name.replace("_", " ")).replace(" ", "")
-
-                # Getting the analysis class
-                if hasattr(analysis_stage_module, analysis_stage_name):
-                    analysis = getattr(analysis_stage_module, analysis_stage_name)
-                else:
-                    KM.Logger.PrintWarning("KratosBaseWrapper", f'The analysis_stage_module "{module_name}" does not follow the standard way to define the analysis stage name "{analysis_stage_name}" . Trying to retrieve from a custom definition')
-                    if self.settings["solver_wrapper_settings"].Has("analysis_name"):
-                        analysis_stage_name = self.settings["solver_wrapper_settings"]["analysis_stage_name"].GetString()
-                        if hasattr(analysis_stage_module, analysis_stage_name):
-                            analysis = getattr(analysis_stage_module, analysis_stage_name)
-                        else:
-                            raise Exception(f'"{module_name}" does not have a "{analysis_stage_name}" class!')
-                    else:
-                        raise Exception(f'"{module_name}" does not have a "{analysis_stage_name}" class! Please provide a custom "analysis_stage_name" in your settings')
-                    
-                return analysis(self.model, self.project_parameters)
-        else:
-            return self._CreateAnalysisStage()
-
-    def PrintInfo(self):
-        super().PrintInfo()
-        cs_tools.cs_print_info("KratosSolver", self._ClassName())
-        cs_tools.cs_print_info("KratosSolver", 'Using AnalysisStage "{}", defined in module "{}'.format(self._analysis_stage.__class__.__name__, self._analysis_stage.__class__.__module__))
-
-    def _CheckDataCommunicatorIsConsistentlyDefined(self, import_settings, mpi_settings):
-        """
-        Checking if the data-comm used for the solver (specified in the import-settings,
-        see "distributed_import_model_part_utility") is consistent with the one that should be
-        created by the solver-wrapper
-        """
-        solver_uses_custom_data_comm = import_settings.Has("data_communicator_name")
-        creating_new_data_comm       = mpi_settings.Has("data_communicator_name")
-
-        if not creating_new_data_comm:
-            # nothing to check if no new data-comm is created
-            return
-
-        if creating_new_data_comm and not solver_uses_custom_data_comm:
-            import_settings.AddValue("data_communicator_name", mpi_settings["data_communicator_name"])
-            if self.echo_level > 0:
-                cs_tools.cs_print_info("KratosSolver", self._ClassName(), 'Using data commnicator with name "{}"'.format(mpi_settings["data_communicator_name"].GetString()))
-            return
-
-        if not solver_uses_custom_data_comm and not creating_new_data_comm:
-            # using all ranks aka the default data comm hence nothing to do here
-            return
-
-        # check if both settings use the same DataCommunicator
-        solver_data_comm_name = import_settings["data_communicator_name"].GetString()
-        data_comm_creation_name = mpi_settings["data_communicator_name"].GetString()
-        if solver_data_comm_name != data_comm_creation_name:
-            err_msg  = 'Names of data communicators do not match!\n'
-            err_msg += '    Name specified in "model_import_settings: {}\n'.format(solver_data_comm_name)
-            err_msg += '    Name specified in "mpi_settings": {}'.format(data_comm_creation_name)
-            raise Exception(err_msg)
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
+
+# Other imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+
+# Import importlib to be able to load analysis stages from a string
+from importlib import import_module
+
+# Import string for capwords function
+import string
+
+class ThreadManager:
+    """Class for setting and ressting the number of threads a context should use."""
+    def __init__(self, num_threads=None):
+        self.num_threads = num_threads
+        if self.num_threads:
+            self.num_threads_orig = KM.ParallelUtilities.GetNumThreads()
+
+    def __enter__(self):
+        if self.num_threads:
+            KM.ParallelUtilities.SetNumThreads(min(self.num_threads, self.num_threads_orig))
+
+    def __exit__(self, exc_type, exc_value, traceback):
+        if self.num_threads:
+            KM.ParallelUtilities.SetNumThreads(self.num_threads_orig)
+
+
+def Create(settings, model, solver_name):
+    return KratosBaseWrapper(settings, model, solver_name)
+
+class KratosBaseWrapper(CoSimulationSolverWrapper):
+    """This class serves as basis for the kratos-wrappers
+    It uses the AnalysisStage as black-box interface to Kratos
+    """
+    def __init__(self, settings, model, solver_name):
+        # We try to read the input file
+        if settings["solver_wrapper_settings"].Has("input_file"):
+            input_file_name = settings["solver_wrapper_settings"]["input_file"].GetString()
+            if not input_file_name.endswith(".json"):
+                input_file_name += ".json"
+
+            with open(input_file_name,'r') as parameter_file:
+                self.project_parameters = KM.Parameters(parameter_file.read())
+        else: # The settings are in the root Parameters
+            self.project_parameters = settings["solver_wrapper_settings"]
+
+        super().__init__(settings, model, solver_name)
+
+        if self.settings["solver_wrapper_settings"].Has("num_threads"):
+            omp_num_threads = self.settings["solver_wrapper_settings"]["num_threads"].GetInt()
+            self.thread_manager = ThreadManager(omp_num_threads)
+        else:
+            self.thread_manager = ThreadManager()
+
+        # this creates the AnalysisStage, creates the MainModelParts and allocates the historial Variables on the MainModelParts:
+        with self.thread_manager:
+            self._analysis_stage = self.__GetAnalysisStage()
+
+    def Initialize(self):
+        with self.thread_manager:
+            self._analysis_stage.Initialize() # this reades the Meshes
+        super().Initialize()
+
+    def Finalize(self):
+        super().Finalize()
+        with self.thread_manager:
+            self._analysis_stage.Finalize()
+
+    def AdvanceInTime(self, current_time):
+        with self.thread_manager:
+            new_time = self._analysis_stage._GetSolver().AdvanceInTime(current_time)
+        self._analysis_stage.time = new_time # only needed to print the time correctly
+        return new_time
+
+    def InitializeSolutionStep(self):
+        with self.thread_manager:
+            self._analysis_stage.InitializeSolutionStep()
+
+    def Predict(self):
+        with self.thread_manager:
+            self._analysis_stage._GetSolver().Predict()
+
+    def SolveSolutionStep(self):
+        with self.thread_manager:
+            self._analysis_stage._GetSolver().SolveSolutionStep()
+        super().SolveSolutionStep()
+
+    def FinalizeSolutionStep(self):
+        with self.thread_manager:
+            self._analysis_stage.FinalizeSolutionStep()
+
+    def OutputSolutionStep(self):
+        with self.thread_manager:
+            self._analysis_stage.OutputSolutionStep()
+
+    def _CreateAnalysisStage(self):
+        raise Exception('The "KratosBaseWrapper" can only be used when specifying "analysis_stage_module", otherwise the creation of the AnalysisStage must be implemented in the derived class!')
+
+    def __GetAnalysisStage(self):
+        if self.settings["solver_wrapper_settings"].Has("analysis_stage_module"):
+            module_name = self.settings["solver_wrapper_settings"]["analysis_stage_module"].GetString()
+            analysis_stage_module = import_module(module_name)
+            if hasattr(analysis_stage_module, "Create"):
+                return analysis_stage_module.Create(self.model, self.project_parameters)
+            else:
+                KM.Logger.PrintWarning("KratosBaseWrapper", f'The analysis_stage_module "{module_name}" does not have a "Create" function, trying to create the AnalysisStage directly...')
+                # We assume that the name of the AnalysisStage is the same as the name of the module in PascalCase instead of snake_case
+                file_name = module_name.split(".")[-1]
+                # Convert Snake case to Pascal case
+                analysis_stage_name = string.capwords(file_name.replace("_", " ")).replace(" ", "")
+
+                # Getting the analysis class
+                if hasattr(analysis_stage_module, analysis_stage_name):
+                    analysis = getattr(analysis_stage_module, analysis_stage_name)
+                else:
+                    KM.Logger.PrintWarning("KratosBaseWrapper", f'The analysis_stage_module "{module_name}" does not follow the standard way to define the analysis stage name "{analysis_stage_name}" . Trying to retrieve from a custom definition')
+                    if self.settings["solver_wrapper_settings"].Has("analysis_name"):
+                        analysis_stage_name = self.settings["solver_wrapper_settings"]["analysis_stage_name"].GetString()
+                        if hasattr(analysis_stage_module, analysis_stage_name):
+                            analysis = getattr(analysis_stage_module, analysis_stage_name)
+                        else:
+                            raise Exception(f'"{module_name}" does not have a "{analysis_stage_name}" class!')
+                    else:
+                        raise Exception(f'"{module_name}" does not have a "{analysis_stage_name}" class! Please provide a custom "analysis_stage_name" in your settings')
+                    
+                return analysis(self.model, self.project_parameters)
+        else:
+            return self._CreateAnalysisStage()
+
+    def PrintInfo(self):
+        super().PrintInfo()
+        cs_tools.cs_print_info("KratosSolver", self._ClassName())
+        cs_tools.cs_print_info("KratosSolver", 'Using AnalysisStage "{}", defined in module "{}'.format(self._analysis_stage.__class__.__name__, self._analysis_stage.__class__.__module__))
+
+    def _CheckDataCommunicatorIsConsistentlyDefined(self, import_settings, mpi_settings):
+        """
+        Checking if the data-comm used for the solver (specified in the import-settings,
+        see "distributed_import_model_part_utility") is consistent with the one that should be
+        created by the solver-wrapper
+        """
+        solver_uses_custom_data_comm = import_settings.Has("data_communicator_name")
+        creating_new_data_comm       = mpi_settings.Has("data_communicator_name")
+
+        if not creating_new_data_comm:
+            # nothing to check if no new data-comm is created
+            return
+
+        if creating_new_data_comm and not solver_uses_custom_data_comm:
+            import_settings.AddValue("data_communicator_name", mpi_settings["data_communicator_name"])
+            if self.echo_level > 0:
+                cs_tools.cs_print_info("KratosSolver", self._ClassName(), 'Using data commnicator with name "{}"'.format(mpi_settings["data_communicator_name"].GetString()))
+            return
+
+        if not solver_uses_custom_data_comm and not creating_new_data_comm:
+            # using all ranks aka the default data comm hence nothing to do here
+            return
+
+        # check if both settings use the same DataCommunicator
+        solver_data_comm_name = import_settings["data_communicator_name"].GetString()
+        data_comm_creation_name = mpi_settings["data_communicator_name"].GetString()
+        if solver_data_comm_name != data_comm_creation_name:
+            err_msg  = 'Names of data communicators do not match!\n'
+            err_msg += '    Name specified in "model_import_settings: {}\n'.format(solver_data_comm_name)
+            err_msg += '    Name specified in "mpi_settings": {}'.format(data_comm_creation_name)
+            raise Exception(err_msg)
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/particle_mechanics_dirichlet_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,15 +1,15 @@
-import KratosMultiphysics
-from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
-from KratosMultiphysics.kratos_utilities import IssueDeprecationWarning
-
-from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos.mpm_dirichlet_wrapper import MPMDirichletWrapper
-
-# Importing MPM
-if not CheckIfApplicationsAvailable("MPMApplication"):
-    raise ImportError("The MPMApplication is not available!")
-import KratosMultiphysics.MPMApplication as KPM
-from KratosMultiphysics.MPMApplication.mpm_analysis import MPMAnalysis
-
-def Create(settings, model, solver_name):
-    IssueDeprecationWarning('CoSimulationApplication:','"ParticleMechanicsDirichletWrapper" is deprecated and replaced by "MPMDirichletWrapper"')
-    return MPMDirichletWrapper(settings, model, solver_name)
+import KratosMultiphysics
+from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
+from KratosMultiphysics.kratos_utilities import IssueDeprecationWarning
+
+from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos.mpm_dirichlet_wrapper import MPMDirichletWrapper
+
+# Importing MPM
+if not CheckIfApplicationsAvailable("MPMApplication"):
+    raise ImportError("The MPMApplication is not available!")
+import KratosMultiphysics.MPMApplication as KPM
+from KratosMultiphysics.MPMApplication.mpm_analysis import MPMAnalysis
+
+def Create(settings, model, solver_name):
+    IssueDeprecationWarning('CoSimulationApplication:','"ParticleMechanicsDirichletWrapper" is deprecated and replaced by "MPMDirichletWrapper"')
+    return MPMDirichletWrapper(settings, model, solver_name)
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/convection_diffusion_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,25 +1,25 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos import kratos_base_wrapper
-
-# Importing ConvectionDiffusion
-if not CheckIfApplicationsAvailable("ConvectionDiffusionApplication"):
-    raise ImportError("The ConvectionDiffusionApplication is not available!")
-from KratosMultiphysics.ConvectionDiffusionApplication.convection_diffusion_analysis import ConvectionDiffusionAnalysis
-
-def Create(settings, model, solver_name):
-    return ConvectionDiffusionWrapper(settings, model, solver_name)
-
-class ConvectionDiffusionWrapper(kratos_base_wrapper.KratosBaseWrapper):
-    """This class is the interface to the ConvectionDiffusionApplication of Kratos"""
-
-    def _CreateAnalysisStage(self):
-        return ConvectionDiffusionAnalysis(self.model, self.project_parameters)
-
-    def _GetDataCommunicator(self):
-        # unfortunately the ConDiff solvers are using the global parallelism, it cannot be changed
-        # to run with less cores or in serial with the current design!
-        return super()._GetDataCommunicator()
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos import kratos_base_wrapper
+
+# Importing ConvectionDiffusion
+if not CheckIfApplicationsAvailable("ConvectionDiffusionApplication"):
+    raise ImportError("The ConvectionDiffusionApplication is not available!")
+from KratosMultiphysics.ConvectionDiffusionApplication.convection_diffusion_analysis import ConvectionDiffusionAnalysis
+
+def Create(settings, model, solver_name):
+    return ConvectionDiffusionWrapper(settings, model, solver_name)
+
+class ConvectionDiffusionWrapper(kratos_base_wrapper.KratosBaseWrapper):
+    """This class is the interface to the ConvectionDiffusionApplication of Kratos"""
+
+    def _CreateAnalysisStage(self):
+        return ConvectionDiffusionAnalysis(self.model, self.project_parameters)
+
+    def _GetDataCommunicator(self):
+        # unfortunately the ConDiff solvers are using the global parallelism, it cannot be changed
+        # to run with less cores or in serial with the current design!
+        return super()._GetDataCommunicator()
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/dem_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,51 +1,51 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the Kratos Library
-from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos import kratos_base_wrapper
-
-# Importing StructuralMechanics
-if not CheckIfApplicationsAvailable("DEMApplication"):
-    raise ImportError("The DEMApplication is not available!")
-
-from KratosMultiphysics import DEMApplication
-from KratosMultiphysics.DEMApplication.DEM_analysis_stage import DEMAnalysisStage
-
-def Create(settings, model, solver_name):
-    return DEMWrapper(settings, model, solver_name)
-
-class DEMWrapper(kratos_base_wrapper.KratosBaseWrapper):
-    """This class is the interface to the DEMApplication of Kratos"""
-
-    def _CreateAnalysisStage(self):
-        dem_analysis_module = DEMAnalysisStage
-
-        if self.settings["solver_wrapper_settings"].Has("working_directory"):
-            working_dir = self.settings["solver_wrapper_settings"]["working_directory"].GetString()
-
-            class DEMAnalysisStageWithWorkingDir(DEMAnalysisStage):
-                @classmethod
-                def GetMainPath(self):
-                    return working_dir
-
-            dem_analysis_module = DEMAnalysisStageWithWorkingDir
-
-        return dem_analysis_module(self.model, self.project_parameters)
-
-    def Initialize(self):
-        super().Initialize()
-
-        # save nodes in model parts which need to be moved while simulating
-        self.list_of_nodes_in_move_mesh_model_parts = [self.model[mp_name].Nodes for mp_name in self.settings["solver_wrapper_settings"]["move_mesh_model_part"].GetStringArray()]
-
-
-    def SolveSolutionStep(self):
-        # move the rigid wall object in the dem mp w.r.t. the current displacement and velocities
-        for model_part_nodes in self.list_of_nodes_in_move_mesh_model_parts:
-            DEMApplication.MoveMeshUtility().MoveDemMesh(model_part_nodes,True)
-        # solve DEM
-        super().SolveSolutionStep()
-
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the Kratos Library
+from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos import kratos_base_wrapper
+
+# Importing StructuralMechanics
+if not CheckIfApplicationsAvailable("DEMApplication"):
+    raise ImportError("The DEMApplication is not available!")
+
+from KratosMultiphysics import DEMApplication
+from KratosMultiphysics.DEMApplication.DEM_analysis_stage import DEMAnalysisStage
+
+def Create(settings, model, solver_name):
+    return DEMWrapper(settings, model, solver_name)
+
+class DEMWrapper(kratos_base_wrapper.KratosBaseWrapper):
+    """This class is the interface to the DEMApplication of Kratos"""
+
+    def _CreateAnalysisStage(self):
+        dem_analysis_module = DEMAnalysisStage
+
+        if self.settings["solver_wrapper_settings"].Has("working_directory"):
+            working_dir = self.settings["solver_wrapper_settings"]["working_directory"].GetString()
+
+            class DEMAnalysisStageWithWorkingDir(DEMAnalysisStage):
+                @classmethod
+                def GetMainPath(self):
+                    return working_dir
+
+            dem_analysis_module = DEMAnalysisStageWithWorkingDir
+
+        return dem_analysis_module(self.model, self.project_parameters)
+
+    def Initialize(self):
+        super().Initialize()
+
+        # save nodes in model parts which need to be moved while simulating
+        self.list_of_nodes_in_move_mesh_model_parts = [self.model[mp_name].Nodes for mp_name in self.settings["solver_wrapper_settings"]["move_mesh_model_part"].GetStringArray()]
+
+
+    def SolveSolutionStep(self):
+        # move the rigid wall object in the dem mp w.r.t. the current displacement and velocities
+        for model_part_nodes in self.list_of_nodes_in_move_mesh_model_parts:
+            DEMApplication.MoveMeshUtility().MoveDemMesh(model_part_nodes,True)
+        # solve DEM
+        super().SolveSolutionStep()
+
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/particle_mechanics_neumann_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,15 +1,15 @@
-import KratosMultiphysics
-from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
-from KratosMultiphysics.kratos_utilities import IssueDeprecationWarning
-
-from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos.mpm_neumann_wrapper import MPMNeumannWrapper
-
-# Importing MPM
-if not CheckIfApplicationsAvailable("MPMApplication"):
-    raise ImportError("The MPMApplication is not available!")
-import KratosMultiphysics.MPMApplication as KPM
-from KratosMultiphysics.MPMApplication.mpm_analysis import MPMAnalysis
-
-def Create(settings, model, solver_name):
-    IssueDeprecationWarning('CoSimulationApplication:','"ParticleMechanicsNeumannWrapper" is deprecated and replaced by "MPMNeumannWrapper"')
-    return MPMNeumannWrapper(settings, model, solver_name)
+import KratosMultiphysics
+from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
+from KratosMultiphysics.kratos_utilities import IssueDeprecationWarning
+
+from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos.mpm_neumann_wrapper import MPMNeumannWrapper
+
+# Importing MPM
+if not CheckIfApplicationsAvailable("MPMApplication"):
+    raise ImportError("The MPMApplication is not available!")
+import KratosMultiphysics.MPMApplication as KPM
+from KratosMultiphysics.MPMApplication.mpm_analysis import MPMAnalysis
+
+def Create(settings, model, solver_name):
+    IssueDeprecationWarning('CoSimulationApplication:','"ParticleMechanicsNeumannWrapper" is deprecated and replaced by "MPMNeumannWrapper"')
+    return MPMNeumannWrapper(settings, model, solver_name)
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/mpm_neumann_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,52 +1,52 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos import kratos_base_wrapper
-
-# Importing MPM
-if not CheckIfApplicationsAvailable("MPMApplication"):
-    raise ImportError("The MPMApplication is not available!")
-import KratosMultiphysics.MPMApplication as KPM
-from KratosMultiphysics.MPMApplication.mpm_analysis import MPMAnalysis
-
-def Create(settings, model, solver_name):
-    return MPMNeumannWrapper(settings, model, solver_name)
-
-class MPMNeumannWrapper(kratos_base_wrapper.KratosBaseWrapper):
-    """This class is the interface to the MPMApplication of Kratos"""
-    """It is designed for the Neumann Interface in the MPMApplication"""
-
-    def _CreateAnalysisStage(self):
-        return MPMAnalysis(self.model, self.project_parameters)
-
-    def SolveSolutionStep(self):
-        coupling_model_part = self.model.GetModelPart("MPM_Coupling_Neumann_Interface")
-        model_part_name = self.settings["solver_wrapper_settings"]["interface_model_part_name"].GetString()
-        model_part = self.model.GetModelPart(model_part_name)
-
-        ## Transfer information from coupling_mp to mp
-        for coupling_node in coupling_model_part.Nodes:
-            coupling_id  = coupling_node.Id
-
-            ## IMPOSED Point load
-            point_load = coupling_node.GetSolutionStepValue(KM.CONTACT_FORCE)
-            model_part.GetCondition(coupling_id).SetValuesOnIntegrationPoints(KPM.POINT_LOAD, [point_load], model_part.ProcessInfo)
-
-        super().SolveSolutionStep()
-
-        ### Save displacement of mpc in coupling node
-        for mpc in model_part.Conditions:
-            if (mpc.Is(KM.INTERFACE)):
-                coupling_id   = mpc.Id
-
-                # Update displacement
-                delta_x = mpc.CalculateOnIntegrationPoints(KPM.MPC_DELTA_DISPLACEMENT, model_part.ProcessInfo)[0]
-                displacement = coupling_model_part.GetNode(coupling_id).GetSolutionStepValue(KM.DISPLACEMENT)
-                displacement += delta_x
-                coupling_model_part.GetNode(coupling_id).SetSolutionStepValue(KM.DISPLACEMENT,0,displacement)
-
-                # Update velocity
-                velocity = mpc.CalculateOnIntegrationPoints(KPM.MPC_VELOCITY, model_part.ProcessInfo)[0]
-                coupling_model_part.GetNode(coupling_id).SetSolutionStepValue(KM.VELOCITY,0,velocity)
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos import kratos_base_wrapper
+
+# Importing MPM
+if not CheckIfApplicationsAvailable("MPMApplication"):
+    raise ImportError("The MPMApplication is not available!")
+import KratosMultiphysics.MPMApplication as KPM
+from KratosMultiphysics.MPMApplication.mpm_analysis import MPMAnalysis
+
+def Create(settings, model, solver_name):
+    return MPMNeumannWrapper(settings, model, solver_name)
+
+class MPMNeumannWrapper(kratos_base_wrapper.KratosBaseWrapper):
+    """This class is the interface to the MPMApplication of Kratos"""
+    """It is designed for the Neumann Interface in the MPMApplication"""
+
+    def _CreateAnalysisStage(self):
+        return MPMAnalysis(self.model, self.project_parameters)
+
+    def SolveSolutionStep(self):
+        coupling_model_part = self.model.GetModelPart("MPM_Coupling_Neumann_Interface")
+        model_part_name = self.settings["solver_wrapper_settings"]["interface_model_part_name"].GetString()
+        model_part = self.model.GetModelPart(model_part_name)
+
+        ## Transfer information from coupling_mp to mp
+        for coupling_node in coupling_model_part.Nodes:
+            coupling_id  = coupling_node.Id
+
+            ## IMPOSED Point load
+            point_load = coupling_node.GetSolutionStepValue(KM.CONTACT_FORCE)
+            model_part.GetCondition(coupling_id).SetValuesOnIntegrationPoints(KPM.POINT_LOAD, [point_load], model_part.ProcessInfo)
+
+        super().SolveSolutionStep()
+
+        ### Save displacement of mpc in coupling node
+        for mpc in model_part.Conditions:
+            if (mpc.Is(KM.INTERFACE)):
+                coupling_id   = mpc.Id
+
+                # Update displacement
+                delta_x = mpc.CalculateOnIntegrationPoints(KPM.MPC_DELTA_DISPLACEMENT, model_part.ProcessInfo)[0]
+                displacement = coupling_model_part.GetNode(coupling_id).GetSolutionStepValue(KM.DISPLACEMENT)
+                displacement += delta_x
+                coupling_model_part.GetNode(coupling_id).SetSolutionStepValue(KM.DISPLACEMENT,0,displacement)
+
+                # Update velocity
+                velocity = mpc.CalculateOnIntegrationPoints(KPM.MPC_VELOCITY, model_part.ProcessInfo)[0]
+                coupling_model_part.GetNode(coupling_id).SetSolutionStepValue(KM.VELOCITY,0,velocity)
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/mpm_dirichlet_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,60 +1,60 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos import kratos_base_wrapper
-
-# Importing MPM
-if not CheckIfApplicationsAvailable("MPMApplication"):
-    raise ImportError("The MPMApplication is not available!")
-import KratosMultiphysics.MPMApplication as KPM
-from KratosMultiphysics.MPMApplication.mpm_analysis import MPMAnalysis
-
-# Other imports
-import math
-
-def Create(settings, model, solver_name):
-    return MPMDirichletWrapper(settings, model, solver_name)
-
-class MPMDirichletWrapper(kratos_base_wrapper.KratosBaseWrapper):
-    """This class is the interface to the MPMApplication of Kratos."""
-    """It is designed for the Dirichlet Interface in the MPMApplication"""
-
-    def _CreateAnalysisStage(self):
-        return MPMAnalysis(self.model, self.project_parameters)
-
-    def SolveSolutionStep(self):
-        coupling_model_part = self.model.GetModelPart("MPM_Coupling_Dirichlet_Interface")
-        model_part_name = self.settings["solver_wrapper_settings"]["interface_model_part_name"].GetString()
-        model_part = self.model.GetModelPart(model_part_name)
-
-        ## Transfer information from coupling_mp to mp
-        for coupling_node in coupling_model_part.Nodes:
-            coupling_id  = coupling_node.Id
-
-            ## IMPOSED DISPLACEMENT
-            total_displacement = coupling_node.GetSolutionStepValue(KM.DISPLACEMENT,0)
-            old_displacement = model_part.GetCondition(coupling_id).CalculateOnIntegrationPoints(KPM.MPC_DISPLACEMENT, model_part.ProcessInfo)[0]
-            incremental_displacement = total_displacement - old_displacement
-            model_part.GetCondition(coupling_id).SetValuesOnIntegrationPoints(KPM.MPC_IMPOSED_DISPLACEMENT, [incremental_displacement], model_part.ProcessInfo)
-
-            ## ADD VELOCITY
-            current_velocity = coupling_node.GetSolutionStepValue(KM.VELOCITY,0)
-            model_part.GetCondition(coupling_id).SetValuesOnIntegrationPoints(KPM.MPC_VELOCITY, [current_velocity], model_part.ProcessInfo)
-
-            ## ADD NORMAL
-            normal = coupling_node.GetSolutionStepValue(KM.NORMAL,0)
-            # Check and see whether the normal is not zero
-            norm_normal = math.sqrt(normal[0]*normal[0] + normal[1]*normal[1] + normal[2]*normal[2])
-            if norm_normal > 1.e-10:
-                model_part.GetCondition(coupling_id).SetValuesOnIntegrationPoints(KPM.MPC_NORMAL, [normal], model_part.ProcessInfo)
-
-        super().SolveSolutionStep()
-
-        ### Get contact force from mp to coupling_mp
-        for mpc in model_part.Conditions:
-            if (mpc.Is(KM.INTERFACE)):
-                coupling_id   = mpc.Id
-                contact_force = mpc.CalculateOnIntegrationPoints(KPM.MPC_CONTACT_FORCE, model_part.ProcessInfo)[0]
-                coupling_model_part.GetNode(coupling_id).SetSolutionStepValue(KM.CONTACT_FORCE,0,contact_force)
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos import kratos_base_wrapper
+
+# Importing MPM
+if not CheckIfApplicationsAvailable("MPMApplication"):
+    raise ImportError("The MPMApplication is not available!")
+import KratosMultiphysics.MPMApplication as KPM
+from KratosMultiphysics.MPMApplication.mpm_analysis import MPMAnalysis
+
+# Other imports
+import math
+
+def Create(settings, model, solver_name):
+    return MPMDirichletWrapper(settings, model, solver_name)
+
+class MPMDirichletWrapper(kratos_base_wrapper.KratosBaseWrapper):
+    """This class is the interface to the MPMApplication of Kratos."""
+    """It is designed for the Dirichlet Interface in the MPMApplication"""
+
+    def _CreateAnalysisStage(self):
+        return MPMAnalysis(self.model, self.project_parameters)
+
+    def SolveSolutionStep(self):
+        coupling_model_part = self.model.GetModelPart("MPM_Coupling_Dirichlet_Interface")
+        model_part_name = self.settings["solver_wrapper_settings"]["interface_model_part_name"].GetString()
+        model_part = self.model.GetModelPart(model_part_name)
+
+        ## Transfer information from coupling_mp to mp
+        for coupling_node in coupling_model_part.Nodes:
+            coupling_id  = coupling_node.Id
+
+            ## IMPOSED DISPLACEMENT
+            total_displacement = coupling_node.GetSolutionStepValue(KM.DISPLACEMENT,0)
+            old_displacement = model_part.GetCondition(coupling_id).CalculateOnIntegrationPoints(KPM.MPC_DISPLACEMENT, model_part.ProcessInfo)[0]
+            incremental_displacement = total_displacement - old_displacement
+            model_part.GetCondition(coupling_id).SetValuesOnIntegrationPoints(KPM.MPC_IMPOSED_DISPLACEMENT, [incremental_displacement], model_part.ProcessInfo)
+
+            ## ADD VELOCITY
+            current_velocity = coupling_node.GetSolutionStepValue(KM.VELOCITY,0)
+            model_part.GetCondition(coupling_id).SetValuesOnIntegrationPoints(KPM.MPC_VELOCITY, [current_velocity], model_part.ProcessInfo)
+
+            ## ADD NORMAL
+            normal = coupling_node.GetSolutionStepValue(KM.NORMAL,0)
+            # Check and see whether the normal is not zero
+            norm_normal = math.sqrt(normal[0]*normal[0] + normal[1]*normal[1] + normal[2]*normal[2])
+            if norm_normal > 1.e-10:
+                model_part.GetCondition(coupling_id).SetValuesOnIntegrationPoints(KPM.MPC_NORMAL, [normal], model_part.ProcessInfo)
+
+        super().SolveSolutionStep()
+
+        ### Get contact force from mp to coupling_mp
+        for mpc in model_part.Conditions:
+            if (mpc.Is(KM.INTERFACE)):
+                coupling_id   = mpc.Id
+                contact_force = mpc.CalculateOnIntegrationPoints(KPM.MPC_CONTACT_FORCE, model_part.ProcessInfo)[0]
+                coupling_model_part.GetNode(coupling_id).SetSolutionStepValue(KM.CONTACT_FORCE,0,contact_force)
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/structural_mechanics_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,39 +1,39 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos import kratos_base_wrapper
-
-# Importing StructuralMechanics
-if not CheckIfApplicationsAvailable("StructuralMechanicsApplication"):
-    raise ImportError("The StructuralMechanicsApplication is not available!")
-from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_analysis import StructuralMechanicsAnalysis
-
-# Other imports
-from KratosMultiphysics.CoSimulationApplication.utilities import data_communicator_utilities
-
-def Create(settings, model, solver_name):
-    return StructuralMechanicsWrapper(settings, model, solver_name)
-
-class StructuralMechanicsWrapper(kratos_base_wrapper.KratosBaseWrapper):
-    """This class is the interface to the StructuralMechanicsApplication of Kratos"""
-
-    def _CreateAnalysisStage(self):
-        return StructuralMechanicsAnalysis(self.model, self.project_parameters)
-
-    def _GetDataCommunicator(self):
-        if not KM.IsDistributedRun():
-            return KM.ParallelEnvironment.GetDataCommunicator("Serial")
-
-        # now we know that Kratos runs in MPI
-        parallel_type = self.project_parameters["problem_data"]["parallel_type"].GetString()
-
-        # first check if the solver uses MPI
-        if parallel_type != "MPI":
-            return data_communicator_utilities.GetRankZeroDataCommunicator()
-
-        # now we know that the solver uses MPI, only question left is whether to use all ranks or a subset
-        self._CheckDataCommunicatorIsConsistentlyDefined(self.project_parameters["solver_settings"]["model_import_settings"], self.settings["mpi_settings"])
-
-        return super()._GetDataCommunicator()
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos import kratos_base_wrapper
+
+# Importing StructuralMechanics
+if not CheckIfApplicationsAvailable("StructuralMechanicsApplication"):
+    raise ImportError("The StructuralMechanicsApplication is not available!")
+from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_analysis import StructuralMechanicsAnalysis
+
+# Other imports
+from KratosMultiphysics.CoSimulationApplication.utilities import data_communicator_utilities
+
+def Create(settings, model, solver_name):
+    return StructuralMechanicsWrapper(settings, model, solver_name)
+
+class StructuralMechanicsWrapper(kratos_base_wrapper.KratosBaseWrapper):
+    """This class is the interface to the StructuralMechanicsApplication of Kratos"""
+
+    def _CreateAnalysisStage(self):
+        return StructuralMechanicsAnalysis(self.model, self.project_parameters)
+
+    def _GetDataCommunicator(self):
+        if not KM.IsDistributedRun():
+            return KM.ParallelEnvironment.GetDataCommunicator("Serial")
+
+        # now we know that Kratos runs in MPI
+        parallel_type = self.project_parameters["problem_data"]["parallel_type"].GetString()
+
+        # first check if the solver uses MPI
+        if parallel_type != "MPI":
+            return data_communicator_utilities.GetRankZeroDataCommunicator()
+
+        # now we know that the solver uses MPI, only question left is whether to use all ranks or a subset
+        self._CheckDataCommunicatorIsConsistentlyDefined(self.project_parameters["solver_settings"]["model_import_settings"], self.settings["mpi_settings"])
+
+        return super()._GetDataCommunicator()
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/fluid_dynamics_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,43 +1,43 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos import kratos_base_wrapper
-
-# Importing FluidDynamics
-if not CheckIfApplicationsAvailable("FluidDynamicsApplication"):
-    raise ImportError("The FluidDynamicsApplication is not available!")
-from KratosMultiphysics.FluidDynamicsApplication.fluid_dynamics_analysis import FluidDynamicsAnalysis
-
-# Other imports
-from KratosMultiphysics.CoSimulationApplication.utilities import data_communicator_utilities
-
-def Create(settings, model, solver_name):
-    return FluidDynamicsWrapper(settings, model, solver_name)
-
-class FluidDynamicsWrapper(kratos_base_wrapper.KratosBaseWrapper):
-    """This class is the interface to the FluidDynamicsApplication of Kratos"""
-
-    def _CreateAnalysisStage(self):
-        return FluidDynamicsAnalysis(self.model, self.project_parameters)
-
-    def _GetDataCommunicator(self):
-        if not KM.IsDistributedRun():
-            return KM.ParallelEnvironment.GetDataCommunicator("Serial")
-
-        # now we know that Kratos runs in MPI
-        parallel_type = self.project_parameters["problem_data"]["parallel_type"].GetString()
-
-        # first check if the solver uses MPI
-        if parallel_type != "MPI":
-            return data_communicator_utilities.GetRankZeroDataCommunicator()
-
-        # now we know that the solver uses MPI, only question left is whether to use all ranks or a subset
-        if self.project_parameters["solver_settings"]["solver_type"].GetString() == "ale_fluid":
-            model_import_settings = self.project_parameters["solver_settings"]["fluid_solver_settings"]["model_import_settings"]
-        else:
-            model_import_settings = self.project_parameters["solver_settings"]["model_import_settings"]
-        self._CheckDataCommunicatorIsConsistentlyDefined(model_import_settings, self.settings["mpi_settings"])
-
-        return super()._GetDataCommunicator()
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos import kratos_base_wrapper
+
+# Importing FluidDynamics
+if not CheckIfApplicationsAvailable("FluidDynamicsApplication"):
+    raise ImportError("The FluidDynamicsApplication is not available!")
+from KratosMultiphysics.FluidDynamicsApplication.fluid_dynamics_analysis import FluidDynamicsAnalysis
+
+# Other imports
+from KratosMultiphysics.CoSimulationApplication.utilities import data_communicator_utilities
+
+def Create(settings, model, solver_name):
+    return FluidDynamicsWrapper(settings, model, solver_name)
+
+class FluidDynamicsWrapper(kratos_base_wrapper.KratosBaseWrapper):
+    """This class is the interface to the FluidDynamicsApplication of Kratos"""
+
+    def _CreateAnalysisStage(self):
+        return FluidDynamicsAnalysis(self.model, self.project_parameters)
+
+    def _GetDataCommunicator(self):
+        if not KM.IsDistributedRun():
+            return KM.ParallelEnvironment.GetDataCommunicator("Serial")
+
+        # now we know that Kratos runs in MPI
+        parallel_type = self.project_parameters["problem_data"]["parallel_type"].GetString()
+
+        # first check if the solver uses MPI
+        if parallel_type != "MPI":
+            return data_communicator_utilities.GetRankZeroDataCommunicator()
+
+        # now we know that the solver uses MPI, only question left is whether to use all ranks or a subset
+        if self.project_parameters["solver_settings"]["solver_type"].GetString() == "ale_fluid":
+            model_import_settings = self.project_parameters["solver_settings"]["fluid_solver_settings"]["model_import_settings"]
+        else:
+            model_import_settings = self.project_parameters["solver_settings"]["model_import_settings"]
+        self._CheckDataCommunicatorIsConsistentlyDefined(model_import_settings, self.settings["mpi_settings"])
+
+        return super()._GetDataCommunicator()
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/potential_flow_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,54 +1,54 @@
-# Importing the Kratos Library
-from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
-
-if not CheckIfApplicationsAvailable("CompressiblePotentialFlowApplication"):
-    raise ImportError("The CompressiblePotentialFlowApplication is not available!")
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos import kratos_base_wrapper
-
-# Other imports
-from KratosMultiphysics.CompressiblePotentialFlowApplication.potential_flow_analysis import PotentialFlowAnalysis
-from KratosMultiphysics.CompressiblePotentialFlowApplication.compute_forces_on_nodes_process import ComputeForcesOnNodesProcess
-from KratosMultiphysics.CompressiblePotentialFlowApplication.define_wake_process_2d import DefineWakeProcess2D
-from KratosMultiphysics.CompressiblePotentialFlowApplication.compute_lift_process import ComputeLiftProcess
-
-def Create(settings, model, solver_name):
-    return PotentialFlowWrapper(settings, model, solver_name)
-
-class PotentialFlowWrapper(kratos_base_wrapper.KratosBaseWrapper):
-    def _CreateAnalysisStage(self):
-        return PotentialFlowAnalysis(self.model, self.project_parameters)
-
-    def Predict(self):
-        pass
-
-    def Initialize(self):
-
-        super().Initialize()
-
-        sub_project_parameters = self.project_parameters["processes"]["boundary_conditions_process_list"]
-
-        for i in range(sub_project_parameters.size()):
-            if sub_project_parameters[i]["python_module"].GetString() == "define_wake_process_2d":
-                self.wake_process = DefineWakeProcess2D(self.model, sub_project_parameters[i]["Parameters"])
-                if not hasattr(self, "wake_process"):
-                    raise Exception("potential flow requires specification of a process for the wake (currently specifically using 'define_wake_process_2d')")
-
-            if sub_project_parameters[i]["python_module"].GetString() == "compute_forces_on_nodes_process":
-                self.conversion_process = ComputeForcesOnNodesProcess(self.model, sub_project_parameters[i]["Parameters"])
-            if sub_project_parameters[i]["python_module"].GetString() == "compute_lift_process":
-                self.lift_process = ComputeLiftProcess(self.model, sub_project_parameters[i]["Parameters"])
-
-    def SolveSolutionStep(self):
-        self.wake_process.ExecuteInitialize()
-
-        ## the next two lines are needed in order to add Wake DoFs to the new Wake Elements Nodes
-        ## and delete the ones that are no longer in the Wake Region.
-        self._analysis_stage._GetSolver().Clear()
-        self._analysis_stage._GetSolver().InitializeSolutionStep()
-
-        super().SolveSolutionStep()
-
-        self.lift_process.ExecuteFinalizeSolutionStep()
-        self.conversion_process.ExecuteFinalizeSolutionStep()
+# Importing the Kratos Library
+from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
+
+if not CheckIfApplicationsAvailable("CompressiblePotentialFlowApplication"):
+    raise ImportError("The CompressiblePotentialFlowApplication is not available!")
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos import kratos_base_wrapper
+
+# Other imports
+from KratosMultiphysics.CompressiblePotentialFlowApplication.potential_flow_analysis import PotentialFlowAnalysis
+from KratosMultiphysics.CompressiblePotentialFlowApplication.compute_forces_on_nodes_process import ComputeForcesOnNodesProcess
+from KratosMultiphysics.CompressiblePotentialFlowApplication.define_wake_process_2d import DefineWakeProcess2D
+from KratosMultiphysics.CompressiblePotentialFlowApplication.compute_lift_process import ComputeLiftProcess
+
+def Create(settings, model, solver_name):
+    return PotentialFlowWrapper(settings, model, solver_name)
+
+class PotentialFlowWrapper(kratos_base_wrapper.KratosBaseWrapper):
+    def _CreateAnalysisStage(self):
+        return PotentialFlowAnalysis(self.model, self.project_parameters)
+
+    def Predict(self):
+        pass
+
+    def Initialize(self):
+
+        super().Initialize()
+
+        sub_project_parameters = self.project_parameters["processes"]["boundary_conditions_process_list"]
+
+        for i in range(sub_project_parameters.size()):
+            if sub_project_parameters[i]["python_module"].GetString() == "define_wake_process_2d":
+                self.wake_process = DefineWakeProcess2D(self.model, sub_project_parameters[i]["Parameters"])
+                if not hasattr(self, "wake_process"):
+                    raise Exception("potential flow requires specification of a process for the wake (currently specifically using 'define_wake_process_2d')")
+
+            if sub_project_parameters[i]["python_module"].GetString() == "compute_forces_on_nodes_process":
+                self.conversion_process = ComputeForcesOnNodesProcess(self.model, sub_project_parameters[i]["Parameters"])
+            if sub_project_parameters[i]["python_module"].GetString() == "compute_lift_process":
+                self.lift_process = ComputeLiftProcess(self.model, sub_project_parameters[i]["Parameters"])
+
+    def SolveSolutionStep(self):
+        self.wake_process.ExecuteInitialize()
+
+        ## the next two lines are needed in order to add Wake DoFs to the new Wake Elements Nodes
+        ## and delete the ones that are no longer in the Wake Region.
+        self._analysis_stage._GetSolver().Clear()
+        self._analysis_stage._GetSolver().InitializeSolutionStep()
+
+        super().SolveSolutionStep()
+
+        self.lift_process.ExecuteFinalizeSolutionStep()
+        self.conversion_process.ExecuteFinalizeSolutionStep()
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/rom_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,33 +1,33 @@
-# Importing the Kratos Library
-from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
-import importlib
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos import kratos_base_wrapper
-
-# Importing Rom
-if not CheckIfApplicationsAvailable("RomApplication"):
-    raise ImportError("The RomApplication is not available!")
-import KratosMultiphysics.RomApplication.rom_analysis as RomAnalysis
-
-def Create(settings, model, solver_name):
-    return RomWrapper(settings, model, solver_name)
-
-class RomWrapper(kratos_base_wrapper.KratosBaseWrapper):
-    """This class is the interface to the RomApplication of Kratos"""
-
-    def _CreateAnalysisStage(self):
-        # Get the parent simulation class
-        analysis_stage_module_name = self.project_parameters["analysis_stage"].GetString()
-        analysis_stage_class_name = analysis_stage_module_name.split('.')[-1]
-        analysis_stage_class_name = ''.join(x.title() for x in analysis_stage_class_name.split('_'))
-
-        analysis_stage_module = importlib.import_module(analysis_stage_module_name)
-        analysis_stage_class = getattr(analysis_stage_module, analysis_stage_class_name)
-        instance_factory = RomAnalysis.CreateRomAnalysisInstance
-        return instance_factory(analysis_stage_class, self.model, self.project_parameters)
-
-    def _GetDataCommunicator(self):
-        # unfortunately the ConDiff solvers are using the global parallelism, it cannot be changed
-        # to run with less cores or in serial with the current design!
+# Importing the Kratos Library
+from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
+import importlib
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.solver_wrappers.kratos import kratos_base_wrapper
+
+# Importing Rom
+if not CheckIfApplicationsAvailable("RomApplication"):
+    raise ImportError("The RomApplication is not available!")
+import KratosMultiphysics.RomApplication.rom_analysis as RomAnalysis
+
+def Create(settings, model, solver_name):
+    return RomWrapper(settings, model, solver_name)
+
+class RomWrapper(kratos_base_wrapper.KratosBaseWrapper):
+    """This class is the interface to the RomApplication of Kratos"""
+
+    def _CreateAnalysisStage(self):
+        # Get the parent simulation class
+        analysis_stage_module_name = self.project_parameters["analysis_stage"].GetString()
+        analysis_stage_class_name = analysis_stage_module_name.split('.')[-1]
+        analysis_stage_class_name = ''.join(x.title() for x in analysis_stage_class_name.split('_'))
+
+        analysis_stage_module = importlib.import_module(analysis_stage_module_name)
+        analysis_stage_class = getattr(analysis_stage_module, analysis_stage_class_name)
+        instance_factory = RomAnalysis.CreateRomAnalysisInstance
+        return instance_factory(analysis_stage_class, self.model, self.project_parameters)
+
+    def _GetDataCommunicator(self):
+        # unfortunately the ConDiff solvers are using the global parallelism, it cannot be changed
+        # to run with less cores or in serial with the current design!
         return super()._GetDataCommunicator()
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos_co_sim_io.py

 * *Ordering differences only*

```diff
@@ -1,138 +1,138 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_io import CoSimulationIO
-
-# CoSimulation imports
-from KratosMultiphysics.CoSimulationApplication import CoSimIO
-
-
-def Create(*args):
-    return KratosCoSimIO(*args)
-
-class KratosCoSimIO(CoSimulationIO):
-    """Wrapper for the CoSimIO to be used with Kratos
-    """
-    def __init__(self, settings, model, solver_name, data_communicator):
-        # backward compatibility
-        for param in ("connect_to", "communication_format", "print_timing"):
-            if settings.Has(param):
-                if not settings.Has("co_sim_io_settings"):
-                    settings.AddEmptyValue("co_sim_io_settings")
-                co_sim_io_settings = settings["co_sim_io_settings"]
-                co_sim_io_settings.AddValue(param, settings[param])
-                settings.RemoveValue(param)
-
-        super().__init__(settings, model, solver_name, data_communicator)
-
-        co_sim_io_settings = settings["co_sim_io_settings"]
-
-        if not co_sim_io_settings.Has("my_name"):
-            co_sim_io_settings.AddEmptyValue("my_name").SetString(solver_name)
-
-        connection_settings = CoSimIO.InfoFromParameters(co_sim_io_settings)
-
-        if self.data_communicator.IsDistributed():
-            from KratosMultiphysics.CoSimulationApplication.MPIExtension import CoSimIO as CoSimIOMPI
-            info = CoSimIOMPI.ConnectMPI(connection_settings, self.data_communicator)
-        else:
-            info = CoSimIO.Connect(connection_settings)
-
-        if info.GetInt("connection_status") != CoSimIO.ConnectionStatus.Connected:
-            raise Exception("Connecting failed!")
-
-        self.connection_name = info.GetString("connection_name")
-
-    def Finalize(self):
-        disconnect_settings = CoSimIO.Info()
-        disconnect_settings.SetString("connection_name", self.connection_name)
-
-        info = CoSimIO.Disconnect(disconnect_settings)
-        if info.GetInt("connection_status") != CoSimIO.ConnectionStatus.Disconnected:
-            raise Exception("Disconnecting failed!")
-
-    def ImportCouplingInterface(self, interface_config):
-        model_part_name = interface_config["model_part_name"]
-
-        info = CoSimIO.Info()
-        info.SetString("connection_name", self.connection_name)
-        info.SetString("identifier", model_part_name.replace(".", "-")) # TODO chec if better solution can be found
-
-        CoSimIO.ImportMesh(info, self.model[model_part_name], self.data_communicator) # TODO this can also be geometry at some point
-
-    def ExportCouplingInterface(self, interface_config):
-        model_part_name = interface_config["model_part_name"]
-
-        info = CoSimIO.Info()
-        info.SetString("connection_name", self.connection_name)
-        info.SetString("identifier", model_part_name.replace(".", "-")) # TODO chec if better solution can be found
-
-        CoSimIO.ExportMesh(info, self.model[model_part_name]) # TODO this can also be geometry at some point
-
-    def ImportData(self, data_config):
-        data_type = data_config["type"]
-        if data_type == "coupling_interface_data":
-            interface_data = data_config["interface_data"]
-            info = CoSimIO.Info()
-            info.SetString("connection_name", self.connection_name)
-            info.SetString("identifier", interface_data.name)
-
-            CoSimIO.ImportData(info, interface_data.GetModelPart(), interface_data.variable, GetDataLocation(interface_data.location))
-        else:
-            raise NotImplementedError('Exporting interface data of type "{}" is not implemented for this IO: "{}"'.format(data_type, self._ClassName()))
-
-    def ExportData(self, data_config):
-        data_type = data_config["type"]
-        if data_type == "coupling_interface_data":
-            interface_data = data_config["interface_data"]
-            info = CoSimIO.Info()
-            info.SetString("connection_name", self.connection_name)
-            info.SetString("identifier", interface_data.name)
-
-            CoSimIO.ExportData(info, interface_data.GetModelPart(), interface_data.variable, GetDataLocation(interface_data.location))
-
-        elif data_type == "control_signal":
-            info = CoSimIO.Info()
-            info.SetString("connection_name", self.connection_name)
-            info.SetString("identifier", "run_control")
-            info.SetString("control_signal", data_config["control_signal"])
-            settings = data_config.get("settings")
-            if settings:
-                info.SetInfo("settings", CoSimIO.InfoFromParameters(settings))
-
-            CoSimIO.ExportInfo(info)
-
-        elif data_type == "repeat_time_step":
-            info = CoSimIO.Info()
-            info.SetString("connection_name", self.connection_name)
-            info.SetString("identifier", "repeat_time_step_info")
-            info.SetBool("repeat_time_step", data_config["repeat_time_step"])
-
-            CoSimIO.ExportInfo(info)
-        else:
-            raise NotImplementedError('Exporting interface data of type "{}" is not implemented for this IO: "{}"'.format(data_type, self._ClassName()))
-
-    def PrintInfo(self):
-        print("This is the KratosCoSimIO")
-
-    def Check(self):
-        pass
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "co_sim_io_settings" : { }
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
-
-def GetDataLocation(location_str):
-    location_map = {
-        "node_historical"     : KM.Globals.DataLocation.NodeHistorical,
-        "node_non_historical" : KM.Globals.DataLocation.NodeNonHistorical,
-        "element"             : KM.Globals.DataLocation.Element,
-        "condition"           : KM.Globals.DataLocation.Condition,
-        "model_part"          : KM.Globals.DataLocation.ModelPart
-    }
-    return location_map[location_str]
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_io import CoSimulationIO
+
+# CoSimulation imports
+from KratosMultiphysics.CoSimulationApplication import CoSimIO
+
+
+def Create(*args):
+    return KratosCoSimIO(*args)
+
+class KratosCoSimIO(CoSimulationIO):
+    """Wrapper for the CoSimIO to be used with Kratos
+    """
+    def __init__(self, settings, model, solver_name, data_communicator):
+        # backward compatibility
+        for param in ("connect_to", "communication_format", "print_timing"):
+            if settings.Has(param):
+                if not settings.Has("co_sim_io_settings"):
+                    settings.AddEmptyValue("co_sim_io_settings")
+                co_sim_io_settings = settings["co_sim_io_settings"]
+                co_sim_io_settings.AddValue(param, settings[param])
+                settings.RemoveValue(param)
+
+        super().__init__(settings, model, solver_name, data_communicator)
+
+        co_sim_io_settings = settings["co_sim_io_settings"]
+
+        if not co_sim_io_settings.Has("my_name"):
+            co_sim_io_settings.AddEmptyValue("my_name").SetString(solver_name)
+
+        connection_settings = CoSimIO.InfoFromParameters(co_sim_io_settings)
+
+        if self.data_communicator.IsDistributed():
+            from KratosMultiphysics.CoSimulationApplication.MPIExtension import CoSimIO as CoSimIOMPI
+            info = CoSimIOMPI.ConnectMPI(connection_settings, self.data_communicator)
+        else:
+            info = CoSimIO.Connect(connection_settings)
+
+        if info.GetInt("connection_status") != CoSimIO.ConnectionStatus.Connected:
+            raise Exception("Connecting failed!")
+
+        self.connection_name = info.GetString("connection_name")
+
+    def Finalize(self):
+        disconnect_settings = CoSimIO.Info()
+        disconnect_settings.SetString("connection_name", self.connection_name)
+
+        info = CoSimIO.Disconnect(disconnect_settings)
+        if info.GetInt("connection_status") != CoSimIO.ConnectionStatus.Disconnected:
+            raise Exception("Disconnecting failed!")
+
+    def ImportCouplingInterface(self, interface_config):
+        model_part_name = interface_config["model_part_name"]
+
+        info = CoSimIO.Info()
+        info.SetString("connection_name", self.connection_name)
+        info.SetString("identifier", model_part_name.replace(".", "-")) # TODO chec if better solution can be found
+
+        CoSimIO.ImportMesh(info, self.model[model_part_name], self.data_communicator) # TODO this can also be geometry at some point
+
+    def ExportCouplingInterface(self, interface_config):
+        model_part_name = interface_config["model_part_name"]
+
+        info = CoSimIO.Info()
+        info.SetString("connection_name", self.connection_name)
+        info.SetString("identifier", model_part_name.replace(".", "-")) # TODO chec if better solution can be found
+
+        CoSimIO.ExportMesh(info, self.model[model_part_name]) # TODO this can also be geometry at some point
+
+    def ImportData(self, data_config):
+        data_type = data_config["type"]
+        if data_type == "coupling_interface_data":
+            interface_data = data_config["interface_data"]
+            info = CoSimIO.Info()
+            info.SetString("connection_name", self.connection_name)
+            info.SetString("identifier", interface_data.name)
+
+            CoSimIO.ImportData(info, interface_data.GetModelPart(), interface_data.variable, GetDataLocation(interface_data.location))
+        else:
+            raise NotImplementedError('Exporting interface data of type "{}" is not implemented for this IO: "{}"'.format(data_type, self._ClassName()))
+
+    def ExportData(self, data_config):
+        data_type = data_config["type"]
+        if data_type == "coupling_interface_data":
+            interface_data = data_config["interface_data"]
+            info = CoSimIO.Info()
+            info.SetString("connection_name", self.connection_name)
+            info.SetString("identifier", interface_data.name)
+
+            CoSimIO.ExportData(info, interface_data.GetModelPart(), interface_data.variable, GetDataLocation(interface_data.location))
+
+        elif data_type == "control_signal":
+            info = CoSimIO.Info()
+            info.SetString("connection_name", self.connection_name)
+            info.SetString("identifier", "run_control")
+            info.SetString("control_signal", data_config["control_signal"])
+            settings = data_config.get("settings")
+            if settings:
+                info.SetInfo("settings", CoSimIO.InfoFromParameters(settings))
+
+            CoSimIO.ExportInfo(info)
+
+        elif data_type == "repeat_time_step":
+            info = CoSimIO.Info()
+            info.SetString("connection_name", self.connection_name)
+            info.SetString("identifier", "repeat_time_step_info")
+            info.SetBool("repeat_time_step", data_config["repeat_time_step"])
+
+            CoSimIO.ExportInfo(info)
+        else:
+            raise NotImplementedError('Exporting interface data of type "{}" is not implemented for this IO: "{}"'.format(data_type, self._ClassName()))
+
+    def PrintInfo(self):
+        print("This is the KratosCoSimIO")
+
+    def Check(self):
+        pass
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "co_sim_io_settings" : { }
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
+
+def GetDataLocation(location_str):
+    location_map = {
+        "node_historical"     : KM.Globals.DataLocation.NodeHistorical,
+        "node_non_historical" : KM.Globals.DataLocation.NodeNonHistorical,
+        "element"             : KM.Globals.DataLocation.Element,
+        "condition"           : KM.Globals.DataLocation.Condition,
+        "model_part"          : KM.Globals.DataLocation.ModelPart
+    }
+    return location_map[location_str]
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/empire_io.py

 * *Ordering differences only*

```diff
@@ -1,91 +1,91 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-from KratosMultiphysics import kratos_utilities
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_io import CoSimulationIO
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication as KratosCoSim
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-from KratosMultiphysics.CoSimulationApplication.utilities import model_part_utilities
-
-# Other imports
-import os
-
-def Create(*args):
-    return EmpireIO(*args)
-
-communication_folder = ".EmpireIO" # hardcoded in C++
-
-class EmpireIO(CoSimulationIO):
-    """IO for the legacy EMPIRE_API
-    """
-    def __init__(self, settings, model, solver_name, data_communicator):
-        super().__init__(settings, model, solver_name, data_communicator)
-        # Note: calling "EMPIRE_API_Connect" is NOT necessary, it is replaced by the next two lines
-        KratosCoSim.EMPIRE_API.EMPIRE_API_SetEchoLevel(self.echo_level)
-        KratosCoSim.EMPIRE_API.EMPIRE_API_PrintTiming(self.settings["api_print_timing"].GetBool())
-
-        # delete and recreate communication folder to avoid leftover files
-        kratos_utilities.DeleteDirectoryIfExisting(communication_folder)
-        os.mkdir(communication_folder)
-
-    def Finalize(self):
-        kratos_utilities.DeleteDirectoryIfExisting(communication_folder)
-
-    def __del__(self):
-        # make sure no communication files are left even if simulation is terminated prematurely
-        if os.path.isdir(communication_folder):
-            kratos_utilities.DeleteDirectoryIfExisting(communication_folder)
-            if self.echo_level > 0:
-                cs_tools.cs_print_info(self._ClassName(), "Deleting Communication folder in destructor")
-
-    def ImportCouplingInterface(self, interface_config):
-        model_part_name = interface_config["model_part_name"]
-        comm_name = interface_config["comm_name"]
-
-        if not self.model.HasModelPart(model_part_name):
-            main_model_part_name, *sub_model_part_names = model_part_name.split(".")
-            model_part_utilities.RecursiveCreateModelParts(self.model[main_model_part_name], ".".join(sub_model_part_names))
-
-        model_part = self.model[model_part_name]
-        KratosCoSim.EMPIRE_API.EMPIRE_API_recvMesh(model_part, comm_name)
-
-    def ExportCouplingInterface(self, interface_config):
-        model_part_name = interface_config["model_part_name"]
-        comm_name = interface_config["comm_name"]
-        KratosCoSim.EMPIRE_API.EMPIRE_API_sendMesh(self.model[model_part_name], comm_name)
-
-    def ImportData(self, data_config):
-        data_type = data_config["type"]
-        if data_type == "coupling_interface_data":
-            interface_data = data_config["interface_data"]
-            KratosCoSim.EMPIRE_API.EMPIRE_API_recvDataField(interface_data.GetModelPart(), self.solver_name+"_"+interface_data.name, interface_data.variable)
-        else:
-            raise NotImplementedError('Importing interface data of type "{}" is not implemented for this IO: "{}"'.format(data_type, self._ClassName()))
-
-    def ExportData(self, data_config):
-        data_type = data_config["type"]
-        if data_type == "coupling_interface_data":
-            interface_data = data_config["interface_data"]
-            KratosCoSim.EMPIRE_API.EMPIRE_API_sendDataField(interface_data.GetModelPart(), self.solver_name+"_"+interface_data.name, interface_data.variable)
-        elif data_type == "repeat_time_step":
-            KratosCoSim.EMPIRE_API.EMPIRE_API_sendConvergenceSignal((not data_config["repeat_time_step"]), self.solver_name)
-        else:
-            raise NotImplementedError('Exporting interface data of type "{}" is not implemented for this IO: "{}"'.format(data_type, self._ClassName()))
-
-    def PrintInfo(self):
-        print("This is the EMPIRE-IO")
-
-    def Check(self):
-        pass
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "api_print_timing" : false
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-
-        return this_defaults
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+from KratosMultiphysics import kratos_utilities
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_io import CoSimulationIO
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication as KratosCoSim
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+from KratosMultiphysics.CoSimulationApplication.utilities import model_part_utilities
+
+# Other imports
+import os
+
+def Create(*args):
+    return EmpireIO(*args)
+
+communication_folder = ".EmpireIO" # hardcoded in C++
+
+class EmpireIO(CoSimulationIO):
+    """IO for the legacy EMPIRE_API
+    """
+    def __init__(self, settings, model, solver_name, data_communicator):
+        super().__init__(settings, model, solver_name, data_communicator)
+        # Note: calling "EMPIRE_API_Connect" is NOT necessary, it is replaced by the next two lines
+        KratosCoSim.EMPIRE_API.EMPIRE_API_SetEchoLevel(self.echo_level)
+        KratosCoSim.EMPIRE_API.EMPIRE_API_PrintTiming(self.settings["api_print_timing"].GetBool())
+
+        # delete and recreate communication folder to avoid leftover files
+        kratos_utilities.DeleteDirectoryIfExisting(communication_folder)
+        os.mkdir(communication_folder)
+
+    def Finalize(self):
+        kratos_utilities.DeleteDirectoryIfExisting(communication_folder)
+
+    def __del__(self):
+        # make sure no communication files are left even if simulation is terminated prematurely
+        if os.path.isdir(communication_folder):
+            kratos_utilities.DeleteDirectoryIfExisting(communication_folder)
+            if self.echo_level > 0:
+                cs_tools.cs_print_info(self._ClassName(), "Deleting Communication folder in destructor")
+
+    def ImportCouplingInterface(self, interface_config):
+        model_part_name = interface_config["model_part_name"]
+        comm_name = interface_config["comm_name"]
+
+        if not self.model.HasModelPart(model_part_name):
+            main_model_part_name, *sub_model_part_names = model_part_name.split(".")
+            model_part_utilities.RecursiveCreateModelParts(self.model[main_model_part_name], ".".join(sub_model_part_names))
+
+        model_part = self.model[model_part_name]
+        KratosCoSim.EMPIRE_API.EMPIRE_API_recvMesh(model_part, comm_name)
+
+    def ExportCouplingInterface(self, interface_config):
+        model_part_name = interface_config["model_part_name"]
+        comm_name = interface_config["comm_name"]
+        KratosCoSim.EMPIRE_API.EMPIRE_API_sendMesh(self.model[model_part_name], comm_name)
+
+    def ImportData(self, data_config):
+        data_type = data_config["type"]
+        if data_type == "coupling_interface_data":
+            interface_data = data_config["interface_data"]
+            KratosCoSim.EMPIRE_API.EMPIRE_API_recvDataField(interface_data.GetModelPart(), self.solver_name+"_"+interface_data.name, interface_data.variable)
+        else:
+            raise NotImplementedError('Importing interface data of type "{}" is not implemented for this IO: "{}"'.format(data_type, self._ClassName()))
+
+    def ExportData(self, data_config):
+        data_type = data_config["type"]
+        if data_type == "coupling_interface_data":
+            interface_data = data_config["interface_data"]
+            KratosCoSim.EMPIRE_API.EMPIRE_API_sendDataField(interface_data.GetModelPart(), self.solver_name+"_"+interface_data.name, interface_data.variable)
+        elif data_type == "repeat_time_step":
+            KratosCoSim.EMPIRE_API.EMPIRE_API_sendConvergenceSignal((not data_config["repeat_time_step"]), self.solver_name)
+        else:
+            raise NotImplementedError('Exporting interface data of type "{}" is not implemented for this IO: "{}"'.format(data_type, self._ClassName()))
+
+    def PrintInfo(self):
+        print("This is the EMPIRE-IO")
+
+    def Check(self):
+        pass
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "api_print_timing" : false
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+
+        return this_defaults
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/dummy_io.py

 * *Ordering differences only*

```diff
@@ -1,28 +1,28 @@
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_io import CoSimulationIO
-
-def Create(*args):
-    return DummyIO(*args)
-
-class DummyIO(CoSimulationIO):
-    """This class is used if a Solver directly uses Kratos as a data-structure
-    e.g. Kratos itself or simple-solvers written in Python
-    """
-
-    def ImportCouplingInterface(self, interface_config):
-        pass
-
-    def ExportCouplingInterface(self, interface_config):
-        pass
-
-    def ImportData(self, data_config):
-        pass
-
-    def ExportData(self, data_config):
-        pass
-
-    def PrintInfo(self):
-        print("This is the dummy-IO")
-
-    def Check(self):
-        pass
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_io import CoSimulationIO
+
+def Create(*args):
+    return DummyIO(*args)
+
+class DummyIO(CoSimulationIO):
+    """This class is used if a Solver directly uses Kratos as a data-structure
+    e.g. Kratos itself or simple-solvers written in Python
+    """
+
+    def ImportCouplingInterface(self, interface_config):
+        pass
+
+    def ExportCouplingInterface(self, interface_config):
+        pass
+
+    def ImportData(self, data_config):
+        pass
+
+    def ExportData(self, data_config):
+        pass
+
+    def PrintInfo(self):
+        print("This is the dummy-IO")
+
+    def Check(self):
+        pass
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/existing_co_simulation.py

 * *Ordering differences only*

```diff
@@ -1,18 +1,18 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.factories.solver_wrapper_factory as solver_wrapper_factory
-
-def Create(settings, models, solver_name):
-    input_file_name = settings["input_file"].GetString()
-    settings.RemoveValue("input_file")
-    if not input_file_name.endswith(".json"):
-        input_file_name += ".json"
-
-    with open(input_file_name,'r') as parameter_file:
-        existing_parameters = KM.Parameters(parameter_file.read())
-    for key, val in existing_parameters["solver_settings"].items():
-        settings.AddValue(key, val)
-
-    return solver_wrapper_factory.CreateSolverWrapper(settings, models, solver_name)
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.factories.solver_wrapper_factory as solver_wrapper_factory
+
+def Create(settings, models, solver_name):
+    input_file_name = settings["input_file"].GetString()
+    settings.RemoveValue("input_file")
+    if not input_file_name.endswith(".json"):
+        input_file_name += ".json"
+
+    with open(input_file_name,'r') as parameter_file:
+        existing_parameters = KM.Parameters(parameter_file.read())
+    for key, val in existing_parameters["solver_settings"].items():
+        settings.AddValue(key, val)
+
+    return solver_wrapper_factory.CreateSolverWrapper(settings, models, solver_name)
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/ping_pong_io.py

 * *Ordering differences only*

```diff
@@ -1,69 +1,69 @@
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_io import CoSimulationIO
-from pathlib import Path
-import os
-
-def Create(*args):
-    return PingPongIO(*args)
-
-class PingPongIO(CoSimulationIO):
-    """This is the IO wrapper for the PING-PONG example.
-    """
-    def ImportCouplingInterface(self, interface_config):
-        pass
-
-    def ExportCouplingInterface(self, interface_config):
-        pass
-
-    def ImportData(self, data_config):
-        data_type = data_config["type"]
-        if data_type == "coupling_interface_data":
-            interface_data = data_config["interface_data"]
-            data_name = self.solver_name+"_"+interface_data.name
-            data_file_name = "EMPIRE_datafield_" + data_name + ".dat"
-            if( self.__FileExists(data_file_name) ):
-                with open(data_file_name, 'r') as input_file:
-                    length_of_data = int(input_file.readline() )
-                    if(length_of_data != 1):
-                        AttributeError("There is more than expected data in the file. PingPongIO takes only one scalar")
-                    data = float(input_file.readline())
-                    node = interface_data.GetModelPart().Nodes[1]
-                    node.SetSolutionStepValue(interface_data.variable, data)
-                    input_file.close()
-                try:
-                    cwd = os.getcwd()
-                    file_to_rmv = os.path.join(cwd, data_file_name)
-                    print("Removing file :: ", file_to_rmv)
-                    os.remove(data_file_name)
-                except OSError as e: # name the Exception `e`
-                    print ("Failed with:", e.strerror) # look what it says
-                    print ("Error code:", e.code)
-        else:
-            raise NotImplementedError('Importing interface data of type "{}" is not implemented for this IO: "{}"'.format(data_type, self._ClassName()))
-
-    def ExportData(self, data_config):
-        data_type = data_config["type"]
-        if data_type == "coupling_interface_data":
-            interface_data = data_config["interface_data"]
-            data_name = self.solver_name+"_"+interface_data.name
-            data_file_name = "EMPIRE_datafield_" + data_name + ".dat"
-            with open(data_file_name, 'w') as output_file:
-                node = interface_data.GetModelPart().Nodes[1]
-                data = node.GetSolutionStepValue(interface_data.variable)
-                output_file.write(str(1))
-                output_file.write("\n")
-                output_file.write(str(data))
-                output_file.close()
-        else:
-            raise NotImplementedError('Exporting interface data of type "{}" is not implemented for this IO: "{}"'.format(data_type, self._ClassName()))
-
-    def PrintInfo(self):
-        print("This is the PingPong-IO")
-
-    def Check(self):
-        pass
-
-    def __FileExists(self, file_name_including_path):
-        given_file = Path(file_name_including_path)
-        return given_file.is_file()
-
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_io import CoSimulationIO
+from pathlib import Path
+import os
+
+def Create(*args):
+    return PingPongIO(*args)
+
+class PingPongIO(CoSimulationIO):
+    """This is the IO wrapper for the PING-PONG example.
+    """
+    def ImportCouplingInterface(self, interface_config):
+        pass
+
+    def ExportCouplingInterface(self, interface_config):
+        pass
+
+    def ImportData(self, data_config):
+        data_type = data_config["type"]
+        if data_type == "coupling_interface_data":
+            interface_data = data_config["interface_data"]
+            data_name = self.solver_name+"_"+interface_data.name
+            data_file_name = "EMPIRE_datafield_" + data_name + ".dat"
+            if( self.__FileExists(data_file_name) ):
+                with open(data_file_name, 'r') as input_file:
+                    length_of_data = int(input_file.readline() )
+                    if(length_of_data != 1):
+                        AttributeError("There is more than expected data in the file. PingPongIO takes only one scalar")
+                    data = float(input_file.readline())
+                    node = interface_data.GetModelPart().Nodes[1]
+                    node.SetSolutionStepValue(interface_data.variable, data)
+                    input_file.close()
+                try:
+                    cwd = os.getcwd()
+                    file_to_rmv = os.path.join(cwd, data_file_name)
+                    print("Removing file :: ", file_to_rmv)
+                    os.remove(data_file_name)
+                except OSError as e: # name the Exception `e`
+                    print ("Failed with:", e.strerror) # look what it says
+                    print ("Error code:", e.code)
+        else:
+            raise NotImplementedError('Importing interface data of type "{}" is not implemented for this IO: "{}"'.format(data_type, self._ClassName()))
+
+    def ExportData(self, data_config):
+        data_type = data_config["type"]
+        if data_type == "coupling_interface_data":
+            interface_data = data_config["interface_data"]
+            data_name = self.solver_name+"_"+interface_data.name
+            data_file_name = "EMPIRE_datafield_" + data_name + ".dat"
+            with open(data_file_name, 'w') as output_file:
+                node = interface_data.GetModelPart().Nodes[1]
+                data = node.GetSolutionStepValue(interface_data.variable)
+                output_file.write(str(1))
+                output_file.write("\n")
+                output_file.write(str(data))
+                output_file.close()
+        else:
+            raise NotImplementedError('Exporting interface data of type "{}" is not implemented for this IO: "{}"'.format(data_type, self._ClassName()))
+
+    def PrintInfo(self):
+        print("This is the PingPong-IO")
+
+    def Check(self):
+        pass
+
+    def __FileExists(self, file_name_including_path):
+        given_file = Path(file_name_including_path)
+        return given_file.is_file()
+
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/ping_pong_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,70 +1,70 @@
-import subprocess
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
-
-# Other imports
-from KratosMultiphysics.CoSimulationApplication.utilities import model_part_utilities
-
-def Create(settings, model, solver_name):
-    return PingPongWrapper(settings, model, solver_name)
-
-class PingPongWrapper(CoSimulationSolverWrapper):
-    """This class serves as wrapper for the cpp ping and pong solvers
-    """
-    def __init__(self, settings, model, solver_name):
-        super().__init__(settings, model, solver_name)
-
-        settings_defaults = KM.Parameters("""{
-            "main_model_part_name" : "",
-            "domain_size" : 2,
-            "executable_name"  : "",
-            "export_data"      : [ ],
-            "import_data"      : [ ]
-        }""")
-
-        self.settings["solver_wrapper_settings"].ValidateAndAssignDefaults(settings_defaults)
-        model_part_name = self.settings["solver_wrapper_settings"]["main_model_part_name"].GetString()
-        model_part_utilities.CreateMainModelPartsFromCouplingDataSettings(self.settings["data"], self.model, self.name)
-        model_part_utilities.AllocateHistoricalVariablesFromCouplingDataSettings(self.settings["data"], self.model, self.name)
-        self.mp = self.model[model_part_name]
-        self.mp.CreateNewNode(1,0,0,0)
-
-    def Initialize(self):
-        super().Initialize()
-
-    def Finalize(self):
-        super().Finalize()
-        with self.rv.stdout, open(self.name +'.log', 'w') as file:
-            for line in self.rv.stdout:
-                file.write(line.decode("utf-8"))
-
-    def AdvanceInTime(self, current_time):
-        return 1.0
-
-    def SolveSolutionStep(self):
-        for data_name in self.settings["solver_wrapper_settings"]["export_data"].GetStringArray():
-            data_config = {
-                "type" : "coupling_interface_data",
-                "interface_data" : self.GetInterfaceData(data_name)
-            }
-            self.ExportData(data_config)
-
-        super().SolveSolutionStep()
-        self.__RunExecutable()
-
-        for data_name in self.settings["solver_wrapper_settings"]["import_data"].GetStringArray():
-            data_config = {
-                "type" : "coupling_interface_data",
-                "interface_data" : self.GetInterfaceData(data_name)
-            }
-            self.ImportData(data_config)
-
-    def _GetIOType(self):
-        return self.settings["io_settings"]["type"].GetString()
-
-    def __RunExecutable(self):
-        command_txt = self.settings["solver_wrapper_settings"]["executable_name"].GetString()
-        self.rv = subprocess.Popen(command_txt, stdout = subprocess.PIPE, stderr = subprocess.PIPE, shell=True, start_new_session=True)
+import subprocess
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
+
+# Other imports
+from KratosMultiphysics.CoSimulationApplication.utilities import model_part_utilities
+
+def Create(settings, model, solver_name):
+    return PingPongWrapper(settings, model, solver_name)
+
+class PingPongWrapper(CoSimulationSolverWrapper):
+    """This class serves as wrapper for the cpp ping and pong solvers
+    """
+    def __init__(self, settings, model, solver_name):
+        super().__init__(settings, model, solver_name)
+
+        settings_defaults = KM.Parameters("""{
+            "main_model_part_name" : "",
+            "domain_size" : 2,
+            "executable_name"  : "",
+            "export_data"      : [ ],
+            "import_data"      : [ ]
+        }""")
+
+        self.settings["solver_wrapper_settings"].ValidateAndAssignDefaults(settings_defaults)
+        model_part_name = self.settings["solver_wrapper_settings"]["main_model_part_name"].GetString()
+        model_part_utilities.CreateMainModelPartsFromCouplingDataSettings(self.settings["data"], self.model, self.name)
+        model_part_utilities.AllocateHistoricalVariablesFromCouplingDataSettings(self.settings["data"], self.model, self.name)
+        self.mp = self.model[model_part_name]
+        self.mp.CreateNewNode(1,0,0,0)
+
+    def Initialize(self):
+        super().Initialize()
+
+    def Finalize(self):
+        super().Finalize()
+        with self.rv.stdout, open(self.name +'.log', 'w') as file:
+            for line in self.rv.stdout:
+                file.write(line.decode("utf-8"))
+
+    def AdvanceInTime(self, current_time):
+        return 1.0
+
+    def SolveSolutionStep(self):
+        for data_name in self.settings["solver_wrapper_settings"]["export_data"].GetStringArray():
+            data_config = {
+                "type" : "coupling_interface_data",
+                "interface_data" : self.GetInterfaceData(data_name)
+            }
+            self.ExportData(data_config)
+
+        super().SolveSolutionStep()
+        self.__RunExecutable()
+
+        for data_name in self.settings["solver_wrapper_settings"]["import_data"].GetStringArray():
+            data_config = {
+                "type" : "coupling_interface_data",
+                "interface_data" : self.GetInterfaceData(data_name)
+            }
+            self.ImportData(data_config)
+
+    def _GetIOType(self):
+        return self.settings["io_settings"]["type"].GetString()
+
+    def __RunExecutable(self):
+        command_txt = self.settings["solver_wrapper_settings"]["executable_name"].GetString()
+        self.rv = subprocess.Popen(command_txt, stdout = subprocess.PIPE, stderr = subprocess.PIPE, shell=True, start_new_session=True)
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_solver_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,66 +1,66 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-import KratosMultiphysics.CoSimulationApplication as KMC
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
-
-# Other imports
-from .sdof_solver import SDoFSolver
-from KratosMultiphysics.CoSimulationApplication.utilities.data_communicator_utilities import GetRankZeroDataCommunicator
-
-def Create(settings, model, solver_name):
-    return SdofSolverWrapper(settings, model, solver_name)
-
-class SdofSolverWrapper(CoSimulationSolverWrapper):
-    """ This class implements a wrapper for an SDof solver to be used in CoSimulation
-    """
-    def __init__(self, settings, model, solver_name, model_part_name="Sdof"):
-        super().__init__(settings, model, solver_name)
-
-        self.mp = self.model.CreateModelPart(model_part_name)
-        self.mp.ProcessInfo[KM.DOMAIN_SIZE] = 1
-
-        input_file_name = self.settings["solver_wrapper_settings"]["input_file"].GetString()
-        self._sdof_solver = self._CreateSDofSolver(input_file_name)
-
-    @classmethod
-    def _CreateSDofSolver(cls, input_file_name):
-        return SDoFSolver(input_file_name)
-
-    def Initialize(self):
-        super().Initialize()
-        self._sdof_solver.Initialize()
-
-    def OutputSolutionStep(self):
-        self._sdof_solver.OutputSolutionStep()
-
-    def AdvanceInTime(self, current_time):
-        return self._sdof_solver.AdvanceInTime(current_time)
-
-    def SolveSolutionStep(self):
-        self._sdof_solver.SetSolutionStepValue("ROOT_POINT_DISPLACEMENT", self.mp[KMC.SCALAR_ROOT_POINT_DISPLACEMENT], 0)
-        self._sdof_solver.SetSolutionStepValue("LOAD",                    self.mp[KMC.SCALAR_FORCE], 0)
-
-        self._sdof_solver.SolveSolutionStep()
-
-        self.mp[KMC.SCALAR_DISPLACEMENT]        = self._sdof_solver.GetSolutionStepValue("DISPLACEMENT", 0)
-        self.mp[KMC.SCALAR_REACTION]            = self._sdof_solver.GetSolutionStepValue("REACTION", 0)
-        self.mp[KMC.SCALAR_VOLUME_ACCELERATION] = self._sdof_solver.GetSolutionStepValue("VOLUME_ACCELERATION", 0)
-
-    def Check(self):
-        # making sure only a set of variables can be used
-        admissible_variables = [
-            "SCALAR_ROOT_POINT_DISPLACEMENT",
-            "SCALAR_FORCE",
-            "SCALAR_DISPLACEMENT",
-            "SCALAR_REACTION",
-            "SCALAR_VOLUME_ACCELERATION",
-        ]
-        for data in self.data_dict.values():
-            if data.variable.Name() not in admissible_variables:
-                raise Exception('Variable "{}" of interface data "{}" of solver "{}" cannot be used for the SDof Solver!\nOnly the following variables are allowed: {}'.format(data.variable.Name(), data.name, data.solver_name, admissible_variables))
-
-    def _GetDataCommunicator(self):
-        # this solver does not support MPI
-        return GetRankZeroDataCommunicator()
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+import KratosMultiphysics.CoSimulationApplication as KMC
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
+
+# Other imports
+from .sdof_solver import SDoFSolver
+from KratosMultiphysics.CoSimulationApplication.utilities.data_communicator_utilities import GetRankZeroDataCommunicator
+
+def Create(settings, model, solver_name):
+    return SdofSolverWrapper(settings, model, solver_name)
+
+class SdofSolverWrapper(CoSimulationSolverWrapper):
+    """ This class implements a wrapper for an SDof solver to be used in CoSimulation
+    """
+    def __init__(self, settings, model, solver_name, model_part_name="Sdof"):
+        super().__init__(settings, model, solver_name)
+
+        self.mp = self.model.CreateModelPart(model_part_name)
+        self.mp.ProcessInfo[KM.DOMAIN_SIZE] = 1
+
+        input_file_name = self.settings["solver_wrapper_settings"]["input_file"].GetString()
+        self._sdof_solver = self._CreateSDofSolver(input_file_name)
+
+    @classmethod
+    def _CreateSDofSolver(cls, input_file_name):
+        return SDoFSolver(input_file_name)
+
+    def Initialize(self):
+        super().Initialize()
+        self._sdof_solver.Initialize()
+
+    def OutputSolutionStep(self):
+        self._sdof_solver.OutputSolutionStep()
+
+    def AdvanceInTime(self, current_time):
+        return self._sdof_solver.AdvanceInTime(current_time)
+
+    def SolveSolutionStep(self):
+        self._sdof_solver.SetSolutionStepValue("ROOT_POINT_DISPLACEMENT", self.mp[KMC.SCALAR_ROOT_POINT_DISPLACEMENT], 0)
+        self._sdof_solver.SetSolutionStepValue("LOAD",                    self.mp[KMC.SCALAR_FORCE], 0)
+
+        self._sdof_solver.SolveSolutionStep()
+
+        self.mp[KMC.SCALAR_DISPLACEMENT]        = self._sdof_solver.GetSolutionStepValue("DISPLACEMENT", 0)
+        self.mp[KMC.SCALAR_REACTION]            = self._sdof_solver.GetSolutionStepValue("REACTION", 0)
+        self.mp[KMC.SCALAR_VOLUME_ACCELERATION] = self._sdof_solver.GetSolutionStepValue("VOLUME_ACCELERATION", 0)
+
+    def Check(self):
+        # making sure only a set of variables can be used
+        admissible_variables = [
+            "SCALAR_ROOT_POINT_DISPLACEMENT",
+            "SCALAR_FORCE",
+            "SCALAR_DISPLACEMENT",
+            "SCALAR_REACTION",
+            "SCALAR_VOLUME_ACCELERATION",
+        ]
+        for data in self.data_dict.values():
+            if data.variable.Name() not in admissible_variables:
+                raise Exception('Variable "{}" of interface data "{}" of solver "{}" cannot be used for the SDof Solver!\nOnly the following variables are allowed: {}'.format(data.variable.Name(), data.name, data.solver_name, admissible_variables))
+
+    def _GetDataCommunicator(self):
+        # this solver does not support MPI
+        return GetRankZeroDataCommunicator()
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_static_solver.py

 * *Ordering differences only*

```diff
@@ -1,145 +1,145 @@
-# Importing the base class
-import KratosMultiphysics
-from KratosMultiphysics.CoSimulationApplication.function_callback_utility import GenericCallFunction
-
-# Other imports
-import json
-import os
-
-class SDoFStaticSolver(object):
-    def __init__(self, input_name):
-
-        # mimicing two constructors
-        if isinstance(input_name, dict):
-            parameters = input_name
-
-        elif isinstance(input_name, str):
-            if not input_name.endswith(".json"):
-                input_name += ".json"
-
-            with open(input_name,'r') as ProjectParameters:
-                parameters = json.load(ProjectParameters)
-
-        else:
-            raise Exception("The input has to be provided as a dict or a string")
-
-        default_settings = {
-                "system_parameters":{
-                    "stiffness" : 4000.0
-                },
-                "initial_values":{
-                    "displacement"  : 0.0,
-                },
-                "boundary_conditions":{
-                    "external_load" : 5000.0
-                },
-                "solver_parameters": {
-                    "buffer_size"   : 1
-                },
-                "output_parameters":{
-                    "write_output_file": False,
-                    "file_name" : "sdof_static_solver/results_sdof.dat"
-                }}
-
-        RecursivelyValidateAndAssignDefaults(default_settings, parameters)
-
-        self.stiffness = parameters["system_parameters"]["stiffness"]
-
-        self.initial_displacement = parameters["initial_values"]["displacement"]
-
-        self.force = parameters["boundary_conditions"]["external_load"]
-
-        self.buffer_size = parameters["solver_parameters"]["buffer_size"]
-
-        self.output_file_name = parameters["output_parameters"]["file_name"]
-
-        self.write_output_file = parameters["output_parameters"]["write_output_file"]
-
-    def Initialize(self):
-        initial_values = self.initial_displacement
-        self.dx = initial_values
-
-        if self.write_output_file:
-            if os.path.isfile(self.output_file_name):
-                os.remove(self.output_file_name)
-            self.InitializeOutput()
-        self.time = 0.0
-
-    def InitializeOutput(self):
-        with open(self.output_file_name, "w") as results_sdof_static:
-            results_sdof_static.write("displacement" + "\n")
-        self.OutputSolutionStep()
-
-    def OutputSolutionStep(self):
-        if self.write_output_file:
-            with open(self.output_file_name, "a") as results_sdof_static:
-                #outputs results
-                results_sdof_static.write(str(self.dx) + "\n")
-
-    def AdvanceInTime(self, current_time):
-        self.time = 0.0
-        return self.time
-
-    def SolveSolutionStep(self):
-        self.dx = self.force/self.stiffness
-        KratosMultiphysics.Logger.PrintInfo('SDoFStaticSolver', 'Force Imported = ', self.force)
-        KratosMultiphysics.Logger.PrintInfo('SDoFStaticSolver', 'Structure Stiffness = ', self.stiffness)
-        KratosMultiphysics.Logger.PrintInfo('SDoFStaticSolver', 'New Displacement = ', self.dx)
-
-    def CalculateReaction(self, buffer_idx=0):
-        reaction = self.stiffness * (self.dx)
-        return reaction
-
-    def GetSolutionStepValue(self, identifier, buffer_idx=0):
-        if identifier == "DISPLACEMENT":
-            return self.dx
-        elif identifier == "REACTION":
-            return self.CalculateReaction()
-        else:
-            raise Exception("Identifier is unknown!")
-
-    def SetSolutionStepValue(self, identifier, value, buffer_idx=0):
-        if identifier == "DISPLACEMENT":
-            self.dx= value
-        elif identifier == "LOAD":
-            self.force = 0.0
-            self.force = value
-        elif identifier == "ROOT_POINT_DISPLACEMENT":
-            self.root_point_displacement = 0.0
-            self.root_point_displacement = value
-        else:
-            raise Exception("Identifier is unknown!")
-
-def ValidateAndAssignDefaults(defaults, settings, recursive=False):
-    for key, val in settings.items():
-        # check if the current entry also exists in the defaults
-        if not key in defaults.keys():
-            err_msg  = 'The item with name "' + key + '" is present in this '
-            err_msg += 'settings\nbut NOT in the defaults!\n'
-            err_msg += 'settings are:\n'
-            err_msg += json.dumps(settings, indent=4)
-            err_msg += '\ndefaults are:\n'
-            err_msg += json.dumps(defaults, indent=4)
-            raise Exception(err_msg)
-
-        # check if the type is the same in the defaults
-        if type(settings[key]) != type(defaults[key]):
-            err_msg  = 'The type of the item with name "' + key + '" (type: "'
-            err_msg += str(type(settings[key]).__name__)+'") in this '
-            err_msg += 'settings\nis NOT the same as in the defaults (type: "'
-            err_msg += str(type(defaults[key]).__name__)+'")!\n'
-            err_msg += 'settings are:\n'
-            err_msg += json.dumps(settings, indent=4)
-            err_msg += '\ndefaults are:\n'
-            err_msg += json.dumps(defaults, indent=4)
-            raise Exception(err_msg)
-
-    # loop the defaults and add the missing entries
-    for key_d, val_d in defaults.items():
-        if key_d not in settings: # add the default in case the setting is not present
-            settings[key_d] = val_d
-        elif recursive and type(val_d) is dict:
-            RecursivelyValidateAndAssignDefaults(val_d, settings[key_d])
-
-def RecursivelyValidateAndAssignDefaults(defaults, settings):
-    ValidateAndAssignDefaults(defaults, settings, recursive=True)
+# Importing the base class
+import KratosMultiphysics
+from KratosMultiphysics.CoSimulationApplication.function_callback_utility import GenericCallFunction
+
+# Other imports
+import json
+import os
+
+class SDoFStaticSolver(object):
+    def __init__(self, input_name):
+
+        # mimicing two constructors
+        if isinstance(input_name, dict):
+            parameters = input_name
+
+        elif isinstance(input_name, str):
+            if not input_name.endswith(".json"):
+                input_name += ".json"
+
+            with open(input_name,'r') as ProjectParameters:
+                parameters = json.load(ProjectParameters)
+
+        else:
+            raise Exception("The input has to be provided as a dict or a string")
+
+        default_settings = {
+                "system_parameters":{
+                    "stiffness" : 4000.0
+                },
+                "initial_values":{
+                    "displacement"  : 0.0,
+                },
+                "boundary_conditions":{
+                    "external_load" : 5000.0
+                },
+                "solver_parameters": {
+                    "buffer_size"   : 1
+                },
+                "output_parameters":{
+                    "write_output_file": False,
+                    "file_name" : "sdof_static_solver/results_sdof.dat"
+                }}
+
+        RecursivelyValidateAndAssignDefaults(default_settings, parameters)
+
+        self.stiffness = parameters["system_parameters"]["stiffness"]
+
+        self.initial_displacement = parameters["initial_values"]["displacement"]
+
+        self.force = parameters["boundary_conditions"]["external_load"]
+
+        self.buffer_size = parameters["solver_parameters"]["buffer_size"]
+
+        self.output_file_name = parameters["output_parameters"]["file_name"]
+
+        self.write_output_file = parameters["output_parameters"]["write_output_file"]
+
+    def Initialize(self):
+        initial_values = self.initial_displacement
+        self.dx = initial_values
+
+        if self.write_output_file:
+            if os.path.isfile(self.output_file_name):
+                os.remove(self.output_file_name)
+            self.InitializeOutput()
+        self.time = 0.0
+
+    def InitializeOutput(self):
+        with open(self.output_file_name, "w") as results_sdof_static:
+            results_sdof_static.write("displacement" + "\n")
+        self.OutputSolutionStep()
+
+    def OutputSolutionStep(self):
+        if self.write_output_file:
+            with open(self.output_file_name, "a") as results_sdof_static:
+                #outputs results
+                results_sdof_static.write(str(self.dx) + "\n")
+
+    def AdvanceInTime(self, current_time):
+        self.time = 0.0
+        return self.time
+
+    def SolveSolutionStep(self):
+        self.dx = self.force/self.stiffness
+        KratosMultiphysics.Logger.PrintInfo('SDoFStaticSolver', 'Force Imported = ', self.force)
+        KratosMultiphysics.Logger.PrintInfo('SDoFStaticSolver', 'Structure Stiffness = ', self.stiffness)
+        KratosMultiphysics.Logger.PrintInfo('SDoFStaticSolver', 'New Displacement = ', self.dx)
+
+    def CalculateReaction(self, buffer_idx=0):
+        reaction = self.stiffness * (self.dx)
+        return reaction
+
+    def GetSolutionStepValue(self, identifier, buffer_idx=0):
+        if identifier == "DISPLACEMENT":
+            return self.dx
+        elif identifier == "REACTION":
+            return self.CalculateReaction()
+        else:
+            raise Exception("Identifier is unknown!")
+
+    def SetSolutionStepValue(self, identifier, value, buffer_idx=0):
+        if identifier == "DISPLACEMENT":
+            self.dx= value
+        elif identifier == "LOAD":
+            self.force = 0.0
+            self.force = value
+        elif identifier == "ROOT_POINT_DISPLACEMENT":
+            self.root_point_displacement = 0.0
+            self.root_point_displacement = value
+        else:
+            raise Exception("Identifier is unknown!")
+
+def ValidateAndAssignDefaults(defaults, settings, recursive=False):
+    for key, val in settings.items():
+        # check if the current entry also exists in the defaults
+        if not key in defaults.keys():
+            err_msg  = 'The item with name "' + key + '" is present in this '
+            err_msg += 'settings\nbut NOT in the defaults!\n'
+            err_msg += 'settings are:\n'
+            err_msg += json.dumps(settings, indent=4)
+            err_msg += '\ndefaults are:\n'
+            err_msg += json.dumps(defaults, indent=4)
+            raise Exception(err_msg)
+
+        # check if the type is the same in the defaults
+        if type(settings[key]) != type(defaults[key]):
+            err_msg  = 'The type of the item with name "' + key + '" (type: "'
+            err_msg += str(type(settings[key]).__name__)+'") in this '
+            err_msg += 'settings\nis NOT the same as in the defaults (type: "'
+            err_msg += str(type(defaults[key]).__name__)+'")!\n'
+            err_msg += 'settings are:\n'
+            err_msg += json.dumps(settings, indent=4)
+            err_msg += '\ndefaults are:\n'
+            err_msg += json.dumps(defaults, indent=4)
+            raise Exception(err_msg)
+
+    # loop the defaults and add the missing entries
+    for key_d, val_d in defaults.items():
+        if key_d not in settings: # add the default in case the setting is not present
+            settings[key_d] = val_d
+        elif recursive and type(val_d) is dict:
+            RecursivelyValidateAndAssignDefaults(val_d, settings[key_d])
+
+def RecursivelyValidateAndAssignDefaults(defaults, settings):
+    ValidateAndAssignDefaults(defaults, settings, recursive=True)
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/static_sdof_solver_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,43 +1,43 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-import KratosMultiphysics.CoSimulationApplication as KMC
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
-
-# Other imports
-from .sdof_static_solver import SDoFStaticSolver
-from .sdof_solver_wrapper import SdofSolverWrapper
-
-def Create(settings, model, solver_name):
-    return SdofStaticSolverWrapper(settings, model, solver_name)
-
-class SdofStaticSolverWrapper(SdofSolverWrapper):
-    """ This class implements a wrapper for an SDof solver to be used in CoSimulation
-    """
-    def __init__(self, settings, model, solver_name):
-        super().__init__(settings, model, solver_name, "Sdof_Static")
-
-    @classmethod
-    def _CreateSDofSolver(cls, input_file_name):
-        return SDoFStaticSolver(input_file_name)
-
-    def SolveSolutionStep(self):
-        self._sdof_solver.SetSolutionStepValue("ROOT_POINT_DISPLACEMENT", self.mp[KMC.SCALAR_ROOT_POINT_DISPLACEMENT], 0)
-        self._sdof_solver.SetSolutionStepValue("LOAD",                    self.mp[KMC.SCALAR_FORCE], 0)
-
-        self._sdof_solver.SolveSolutionStep()
-
-        self.mp[KMC.SCALAR_DISPLACEMENT]        = self._sdof_solver.GetSolutionStepValue("DISPLACEMENT", 0)
-        self.mp[KMC.SCALAR_REACTION]            = self._sdof_solver.GetSolutionStepValue("REACTION", 0)
-
-    def Check(self):
-        # making sure only a set of vaiables can be used
-        admissible_variables = [
-            "SCALAR_FORCE",
-            "SCALAR_DISPLACEMENT",
-            "SCALAR_REACTION",
-        ]
-        for data in self.data_dict.values():
-            if data.variable.Name() not in admissible_variables:
-                raise Exception('Variable "{}" of interface data "{}" of solver "{}" cannot be used for the SDof Solver!\nOnly the following variables are allowed: {}'.format(data.variable.Name(), data.name, data.solver_name, admissible_variables))
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+import KratosMultiphysics.CoSimulationApplication as KMC
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
+
+# Other imports
+from .sdof_static_solver import SDoFStaticSolver
+from .sdof_solver_wrapper import SdofSolverWrapper
+
+def Create(settings, model, solver_name):
+    return SdofStaticSolverWrapper(settings, model, solver_name)
+
+class SdofStaticSolverWrapper(SdofSolverWrapper):
+    """ This class implements a wrapper for an SDof solver to be used in CoSimulation
+    """
+    def __init__(self, settings, model, solver_name):
+        super().__init__(settings, model, solver_name, "Sdof_Static")
+
+    @classmethod
+    def _CreateSDofSolver(cls, input_file_name):
+        return SDoFStaticSolver(input_file_name)
+
+    def SolveSolutionStep(self):
+        self._sdof_solver.SetSolutionStepValue("ROOT_POINT_DISPLACEMENT", self.mp[KMC.SCALAR_ROOT_POINT_DISPLACEMENT], 0)
+        self._sdof_solver.SetSolutionStepValue("LOAD",                    self.mp[KMC.SCALAR_FORCE], 0)
+
+        self._sdof_solver.SolveSolutionStep()
+
+        self.mp[KMC.SCALAR_DISPLACEMENT]        = self._sdof_solver.GetSolutionStepValue("DISPLACEMENT", 0)
+        self.mp[KMC.SCALAR_REACTION]            = self._sdof_solver.GetSolutionStepValue("REACTION", 0)
+
+    def Check(self):
+        # making sure only a set of vaiables can be used
+        admissible_variables = [
+            "SCALAR_FORCE",
+            "SCALAR_DISPLACEMENT",
+            "SCALAR_REACTION",
+        ]
+        for data in self.data_dict.values():
+            if data.variable.Name() not in admissible_variables:
+                raise Exception('Variable "{}" of interface data "{}" of solver "{}" cannot be used for the SDof Solver!\nOnly the following variables are allowed: {}'.format(data.variable.Name(), data.name, data.solver_name, admissible_variables))
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_solver.py

 * *Ordering differences only*

```diff
@@ -1,284 +1,284 @@
-# CoSimulation imports
-from KratosMultiphysics.CoSimulationApplication.function_callback_utility import GenericCallFunction
-
-# Other imports
-import numpy as np
-import json
-import os
-
-class SDoFSolver(object):
-    """ This class implements an SDof solver, independent of Kratos
-    Several types of applying loads are available
-    """
-    def __init__(self, input_name):
-
-        # mimicing two constructors
-        if isinstance(input_name, dict):
-            parameters = input_name
-
-        elif isinstance(input_name, str):
-            if not input_name.endswith(".json"):
-                input_name += ".json"
-
-            with open(input_name,'r') as ProjectParameters:
-                parameters = json.load(ProjectParameters)
-
-        else:
-            raise Exception("The input has to be provided as a dict or a string")
-
-        default_settings = {
-                "system_parameters":{
-                    "mass"      : 100.0,
-                    "stiffness" : 4000.0,
-                    "damping"   : 0.0,
-                    "modulus_self_weight": 9.81
-                },
-                "time_integration_parameters":{
-                    "alpha_m"   : -0.3,
-                    "start_time": 0.0,
-                    "time_step" : 0.05,
-                },
-                "initial_values":{
-                    "displacement"  : 0.0,
-                    "velocity"      : 0.0,
-                    "acceleration"  : 0.0
-                },
-                "boundary_conditions":{
-                    "load_impulse" : 0.0,
-                    "omega_force"        : 0.0,
-                    "omega_root_point_displacement"        : 0.0,
-                    "excitation_function_force": "A * sin(omega * t)",
-                    "excitation_function_root_point_displacement": "A * sin(omega * t)",
-                    "amplitude_root_point_displacement": 0.0,
-                    "amplitude_force": 0.0
-                },
-                "solver_parameters": {
-                    "buffer_size"   : 2
-                },
-                "output_parameters":{
-                    "write_output_file": True,
-                    "file_name" : "sdof_solver/results_sdof.dat"
-                }}
-
-        RecursivelyValidateAndAssignDefaults(default_settings, parameters)
-
-        self.mass = parameters["system_parameters"]["mass"]
-        self.stiffness = parameters["system_parameters"]["stiffness"]
-        self.damping = parameters["system_parameters"]["damping"]
-        self.modulus_self_weight = parameters["system_parameters"]["modulus_self_weight"]
-
-
-        self.alpha_m = parameters["time_integration_parameters"]["alpha_m"]
-        self.delta_t = parameters["time_integration_parameters"]["time_step"]
-        self.start_time = parameters["time_integration_parameters"]["start_time"]
-
-        self.initial_displacement = parameters["initial_values"]["displacement"]
-        self.initial_velocity = parameters["initial_values"]["velocity"]
-
-        self.excitation_function_force = parameters["boundary_conditions"]["excitation_function_force"]
-        self.excitation_function_root_point_displacement = parameters["boundary_conditions"]["excitation_function_root_point_displacement"]
-        self.load_impulse = parameters["boundary_conditions"]["load_impulse"]
-        self.omega_force = parameters["boundary_conditions"]["omega_force"]
-        self.omega_root_point_displacement = parameters["boundary_conditions"]["omega_root_point_displacement"]
-        self.amplitude_root_point_displacement = parameters["boundary_conditions"]["amplitude_root_point_displacement"]
-        self.amplitude_force = parameters["boundary_conditions"]["amplitude_force"]
-
-        #calculate initial acceleration
-        factor = self.load_impulse - self.stiffness * self.initial_displacement
-        self.initial_acceleration = (1/self.mass) * factor
-
-        self.beta = 0.25 * (1- self.alpha_m)**2
-        self.gamma =  0.50 - self.alpha_m
-
-        self.LHS = np.array([[1.0, 0.0, -self.delta_t**2 * self.beta],
-                             [0.0, 1.0, -self.delta_t * self.gamma],
-                             [self.stiffness,
-                              self.damping,
-                               (1-self.alpha_m) * self.mass]])
-
-        self.RHS_matrix = np.array([[1.0, self.delta_t, self.delta_t**2 * (0.5 - self.beta)],
-                                    [0.0, 1.0, self.delta_t*(1-self.gamma)],
-                                    [0.0,
-                                     0.0,
-                                     -self.alpha_m * self.mass]])
-
-        self.buffer_size = parameters["solver_parameters"]["buffer_size"]
-        self.output_file_name = parameters["output_parameters"]["file_name"]
-        self.write_output_file = parameters["output_parameters"]["write_output_file"]
-
-    def Initialize(self):
-        #solution buffer
-        self.x = np.zeros((3, self.buffer_size))
-        #values at the root point buffer
-        self.x_f = np.zeros((3, self.buffer_size))
-
-        initial_values = np.array([self.initial_displacement,
-                                   self.initial_velocity,
-                                   self.initial_acceleration])
-        self.dx = initial_values
-        self.dx_f = np.zeros(3)
-        self.time = self.start_time
-
-        self.root_point_displacement = 0.0
-
-        #x and dx contain: [displacement, velocity, acceleration]
-        if self.write_output_file:
-            if os.path.isfile(self.output_file_name):
-                os.remove(self.output_file_name)
-            self.InitializeOutput()
-
-        #apply external load as an initial impulse
-        self.load_vector = np.array([0,
-                                     0,
-                                     self.load_impulse])
-
-    def InitializeOutput(self):
-        with open(self.output_file_name, "w") as results_sdof:
-            results_sdof.write("time"+ " " +
-                                "displacement" + " " +
-                                "velocity" + " " +
-                                "acceleration" + " " +
-                                "root point displacement" + " " +
-                                "root point velocity" + " " +
-                                "root point acceleration" + " " +
-                                "relative displacement" + " " +
-                                "relative velocity" + " " +
-                                "relative accleration" + " " +
-                                "reaction" + "\n")
-        self.OutputSolutionStep()
-
-    def OutputSolutionStep(self):
-        reaction = self.CalculateReaction()
-        if self.write_output_file:
-            with open(self.output_file_name, "a") as results_sdof:
-                #outputs results
-                results_sdof.write(str(np.around(self.time, 3)) + " " +
-                                str(self.dx[0]) + " " +
-                                str(self.dx[1]) + " " +
-                                str(self.dx[2]) + " " +
-                                str(self.dx_f[0]) + " " +
-                                str(self.dx_f[1]) + " " +
-                                str(self.dx_f[2]) + " " +
-                                str(self.dx[0] - self.dx_f[0]) + " " +
-                                str(self.dx[1] - self.dx_f[1]) + " " +
-                                str(self.dx[2] - self.dx_f[2]) + " " +
-                                str(reaction) + "\n")
-
-
-    def AdvanceInTime(self, current_time):
-        # similar to the Kratos CloneTimeStep function
-        # advances values along the buffer axis (so rolling columns) using numpy's roll
-        self.x = np.roll(self.x,1,axis=1)
-        self.x_f = np.roll(self.x_f,1,axis=1)
-        # overwriting at the buffer_idx=0 the newest values
-        buffer_idx = 0
-        self.x[:,buffer_idx] = self.dx
-        self.x_f[:,buffer_idx] = self.dx_f
-
-        self.time = current_time + self.delta_t
-        return self.time
-
-    def CalculateEquivalentForceFromRootPointExcitation(self, d_f):
-        #d_f = self.root_point_displacement
-        v_f = self.x_f[1,0] + self.delta_t * (self.gamma * d_f + (1-self.gamma) * self.x_f[2,0])
-        a_f = 1/(self.delta_t**2 * self.beta) * (d_f - self.x_f[0,1])\
-            - 1/(self.delta_t * self.beta) * self.x_f[1,0]\
-            + (1-1/(2*self.beta)) * self.x_f[2,0]
-        self.dx_f = np.array([d_f, v_f, a_f])
-        b_f = np.array([0.0, 0.0, d_f * self.stiffness + v_f * self.damping])
-        return b_f
-
-    def ApplyRootPointExcitation(self):
-        scope_vars = {'t' : self.time, 'omega': self.omega_root_point_displacement, 'A': self.amplitude_root_point_displacement}
-        return GenericCallFunction(self.excitation_function_root_point_displacement, scope_vars, check=False)
-
-    def ApplyForceExcitation(self):
-        scope_vars = {'t' : self.time, 'omega': self.omega_force, 'A': self.amplitude_force}
-        return GenericCallFunction(self.excitation_function_force, scope_vars, check=False)
-
-    def SolveSolutionStep(self):
-        b = self.RHS_matrix @ self.x[:,0]
-        #external load
-        excitation_load = self.ApplyForceExcitation()
-        self.load_vector[-1] += excitation_load
-        # print("external load= ", self.load_vector[-1])
-        b += self.load_vector
-        #root point displacement
-        d_f_excitation = self.ApplyRootPointExcitation()
-        d_f = d_f_excitation + self.root_point_displacement
-        b_f = self.CalculateEquivalentForceFromRootPointExcitation(d_f)
-        b += b_f
-        self.dx = np.linalg.solve(self.LHS, b)
-
-    def CalculateReaction(self, buffer_idx=0):
-        reaction = self.damping * ( self.dx[1] - self.dx_f[1]) \
-                 + self.stiffness * (self.dx[0] - self.dx_f[0])
-        return reaction
-
-    def CalculateSelfWeight(self):
-        self_weight = self.mass * self.modulus_self_weight
-        return self_weight
-
-    def GetSolutionStepValue(self, identifier, buffer_idx=0):
-        if identifier == "DISPLACEMENT":
-            return self.x[:,buffer_idx][0]
-        elif identifier == "VELOCITY":
-            return self.x[:,buffer_idx][1]
-        elif identifier == "ACCELERATION":
-            return self.x[:,buffer_idx][2]
-        elif identifier == "REACTION":
-            return self.CalculateReaction()
-        elif identifier == "VOLUME_ACCELERATION":
-            return self.CalculateSelfWeight()
-        else:
-            raise Exception("Identifier is unknown!")
-
-    def SetSolutionStepValue(self, identifier, value, buffer_idx=0):
-        if identifier == "DISPLACEMENT":
-            self.x[:,buffer_idx][0] = value
-        elif identifier == "VELOCITY":
-            self.x[:,buffer_idx][1] = value
-        elif identifier == "ACCELERATION":
-            self.x[:,buffer_idx][2] = value
-        elif identifier == "LOAD":
-            self.load_vector[-1] = 0.0
-            self.load_vector[-1] = value
-        elif identifier == "ROOT_POINT_DISPLACEMENT":
-            self.root_point_displacement = 0.0
-            self.root_point_displacement = value
-        else:
-            raise Exception("Identifier is unknown!")
-
-def ValidateAndAssignDefaults(defaults, settings, recursive=False):
-    for key, val in settings.items():
-        # check if the current entry also exists in the defaults
-        if not key in defaults.keys():
-            err_msg  = 'The item with name "' + key + '" is present in this '
-            err_msg += 'settings\nbut NOT in the defaults!\n'
-            err_msg += 'settings are:\n'
-            err_msg += json.dumps(settings, indent=4)
-            err_msg += '\ndefaults are:\n'
-            err_msg += json.dumps(defaults, indent=4)
-            raise Exception(err_msg)
-
-        # check if the type is the same in the defaults
-        if type(settings[key]) != type(defaults[key]):
-            err_msg  = 'The type of the item with name "' + key + '" (type: "'
-            err_msg += str(type(settings[key]).__name__)+'") in this '
-            err_msg += 'settings\nis NOT the same as in the defaults (type: "'
-            err_msg += str(type(defaults[key]).__name__)+'")!\n'
-            err_msg += 'settings are:\n'
-            err_msg += json.dumps(settings, indent=4)
-            err_msg += '\ndefaults are:\n'
-            err_msg += json.dumps(defaults, indent=4)
-            raise Exception(err_msg)
-
-    # loop the defaults and add the missing entries
-    for key_d, val_d in defaults.items():
-        if key_d not in settings: # add the default in case the setting is not present
-            settings[key_d] = val_d
-        elif recursive and type(val_d) is dict:
-            RecursivelyValidateAndAssignDefaults(val_d, settings[key_d])
-
-def RecursivelyValidateAndAssignDefaults(defaults, settings):
-    ValidateAndAssignDefaults(defaults, settings, recursive=True)
+# CoSimulation imports
+from KratosMultiphysics.CoSimulationApplication.function_callback_utility import GenericCallFunction
+
+# Other imports
+import numpy as np
+import json
+import os
+
+class SDoFSolver(object):
+    """ This class implements an SDof solver, independent of Kratos
+    Several types of applying loads are available
+    """
+    def __init__(self, input_name):
+
+        # mimicing two constructors
+        if isinstance(input_name, dict):
+            parameters = input_name
+
+        elif isinstance(input_name, str):
+            if not input_name.endswith(".json"):
+                input_name += ".json"
+
+            with open(input_name,'r') as ProjectParameters:
+                parameters = json.load(ProjectParameters)
+
+        else:
+            raise Exception("The input has to be provided as a dict or a string")
+
+        default_settings = {
+                "system_parameters":{
+                    "mass"      : 100.0,
+                    "stiffness" : 4000.0,
+                    "damping"   : 0.0,
+                    "modulus_self_weight": 9.81
+                },
+                "time_integration_parameters":{
+                    "alpha_m"   : -0.3,
+                    "start_time": 0.0,
+                    "time_step" : 0.05,
+                },
+                "initial_values":{
+                    "displacement"  : 0.0,
+                    "velocity"      : 0.0,
+                    "acceleration"  : 0.0
+                },
+                "boundary_conditions":{
+                    "load_impulse" : 0.0,
+                    "omega_force"        : 0.0,
+                    "omega_root_point_displacement"        : 0.0,
+                    "excitation_function_force": "A * sin(omega * t)",
+                    "excitation_function_root_point_displacement": "A * sin(omega * t)",
+                    "amplitude_root_point_displacement": 0.0,
+                    "amplitude_force": 0.0
+                },
+                "solver_parameters": {
+                    "buffer_size"   : 2
+                },
+                "output_parameters":{
+                    "write_output_file": True,
+                    "file_name" : "sdof_solver/results_sdof.dat"
+                }}
+
+        RecursivelyValidateAndAssignDefaults(default_settings, parameters)
+
+        self.mass = parameters["system_parameters"]["mass"]
+        self.stiffness = parameters["system_parameters"]["stiffness"]
+        self.damping = parameters["system_parameters"]["damping"]
+        self.modulus_self_weight = parameters["system_parameters"]["modulus_self_weight"]
+
+
+        self.alpha_m = parameters["time_integration_parameters"]["alpha_m"]
+        self.delta_t = parameters["time_integration_parameters"]["time_step"]
+        self.start_time = parameters["time_integration_parameters"]["start_time"]
+
+        self.initial_displacement = parameters["initial_values"]["displacement"]
+        self.initial_velocity = parameters["initial_values"]["velocity"]
+
+        self.excitation_function_force = parameters["boundary_conditions"]["excitation_function_force"]
+        self.excitation_function_root_point_displacement = parameters["boundary_conditions"]["excitation_function_root_point_displacement"]
+        self.load_impulse = parameters["boundary_conditions"]["load_impulse"]
+        self.omega_force = parameters["boundary_conditions"]["omega_force"]
+        self.omega_root_point_displacement = parameters["boundary_conditions"]["omega_root_point_displacement"]
+        self.amplitude_root_point_displacement = parameters["boundary_conditions"]["amplitude_root_point_displacement"]
+        self.amplitude_force = parameters["boundary_conditions"]["amplitude_force"]
+
+        #calculate initial acceleration
+        factor = self.load_impulse - self.stiffness * self.initial_displacement
+        self.initial_acceleration = (1/self.mass) * factor
+
+        self.beta = 0.25 * (1- self.alpha_m)**2
+        self.gamma =  0.50 - self.alpha_m
+
+        self.LHS = np.array([[1.0, 0.0, -self.delta_t**2 * self.beta],
+                             [0.0, 1.0, -self.delta_t * self.gamma],
+                             [self.stiffness,
+                              self.damping,
+                               (1-self.alpha_m) * self.mass]])
+
+        self.RHS_matrix = np.array([[1.0, self.delta_t, self.delta_t**2 * (0.5 - self.beta)],
+                                    [0.0, 1.0, self.delta_t*(1-self.gamma)],
+                                    [0.0,
+                                     0.0,
+                                     -self.alpha_m * self.mass]])
+
+        self.buffer_size = parameters["solver_parameters"]["buffer_size"]
+        self.output_file_name = parameters["output_parameters"]["file_name"]
+        self.write_output_file = parameters["output_parameters"]["write_output_file"]
+
+    def Initialize(self):
+        #solution buffer
+        self.x = np.zeros((3, self.buffer_size))
+        #values at the root point buffer
+        self.x_f = np.zeros((3, self.buffer_size))
+
+        initial_values = np.array([self.initial_displacement,
+                                   self.initial_velocity,
+                                   self.initial_acceleration])
+        self.dx = initial_values
+        self.dx_f = np.zeros(3)
+        self.time = self.start_time
+
+        self.root_point_displacement = 0.0
+
+        #x and dx contain: [displacement, velocity, acceleration]
+        if self.write_output_file:
+            if os.path.isfile(self.output_file_name):
+                os.remove(self.output_file_name)
+            self.InitializeOutput()
+
+        #apply external load as an initial impulse
+        self.load_vector = np.array([0,
+                                     0,
+                                     self.load_impulse])
+
+    def InitializeOutput(self):
+        with open(self.output_file_name, "w") as results_sdof:
+            results_sdof.write("time"+ " " +
+                                "displacement" + " " +
+                                "velocity" + " " +
+                                "acceleration" + " " +
+                                "root point displacement" + " " +
+                                "root point velocity" + " " +
+                                "root point acceleration" + " " +
+                                "relative displacement" + " " +
+                                "relative velocity" + " " +
+                                "relative accleration" + " " +
+                                "reaction" + "\n")
+        self.OutputSolutionStep()
+
+    def OutputSolutionStep(self):
+        reaction = self.CalculateReaction()
+        if self.write_output_file:
+            with open(self.output_file_name, "a") as results_sdof:
+                #outputs results
+                results_sdof.write(str(np.around(self.time, 3)) + " " +
+                                str(self.dx[0]) + " " +
+                                str(self.dx[1]) + " " +
+                                str(self.dx[2]) + " " +
+                                str(self.dx_f[0]) + " " +
+                                str(self.dx_f[1]) + " " +
+                                str(self.dx_f[2]) + " " +
+                                str(self.dx[0] - self.dx_f[0]) + " " +
+                                str(self.dx[1] - self.dx_f[1]) + " " +
+                                str(self.dx[2] - self.dx_f[2]) + " " +
+                                str(reaction) + "\n")
+
+
+    def AdvanceInTime(self, current_time):
+        # similar to the Kratos CloneTimeStep function
+        # advances values along the buffer axis (so rolling columns) using numpy's roll
+        self.x = np.roll(self.x,1,axis=1)
+        self.x_f = np.roll(self.x_f,1,axis=1)
+        # overwriting at the buffer_idx=0 the newest values
+        buffer_idx = 0
+        self.x[:,buffer_idx] = self.dx
+        self.x_f[:,buffer_idx] = self.dx_f
+
+        self.time = current_time + self.delta_t
+        return self.time
+
+    def CalculateEquivalentForceFromRootPointExcitation(self, d_f):
+        #d_f = self.root_point_displacement
+        v_f = self.x_f[1,0] + self.delta_t * (self.gamma * d_f + (1-self.gamma) * self.x_f[2,0])
+        a_f = 1/(self.delta_t**2 * self.beta) * (d_f - self.x_f[0,1])\
+            - 1/(self.delta_t * self.beta) * self.x_f[1,0]\
+            + (1-1/(2*self.beta)) * self.x_f[2,0]
+        self.dx_f = np.array([d_f, v_f, a_f])
+        b_f = np.array([0.0, 0.0, d_f * self.stiffness + v_f * self.damping])
+        return b_f
+
+    def ApplyRootPointExcitation(self):
+        scope_vars = {'t' : self.time, 'omega': self.omega_root_point_displacement, 'A': self.amplitude_root_point_displacement}
+        return GenericCallFunction(self.excitation_function_root_point_displacement, scope_vars, check=False)
+
+    def ApplyForceExcitation(self):
+        scope_vars = {'t' : self.time, 'omega': self.omega_force, 'A': self.amplitude_force}
+        return GenericCallFunction(self.excitation_function_force, scope_vars, check=False)
+
+    def SolveSolutionStep(self):
+        b = self.RHS_matrix @ self.x[:,0]
+        #external load
+        excitation_load = self.ApplyForceExcitation()
+        self.load_vector[-1] += excitation_load
+        # print("external load= ", self.load_vector[-1])
+        b += self.load_vector
+        #root point displacement
+        d_f_excitation = self.ApplyRootPointExcitation()
+        d_f = d_f_excitation + self.root_point_displacement
+        b_f = self.CalculateEquivalentForceFromRootPointExcitation(d_f)
+        b += b_f
+        self.dx = np.linalg.solve(self.LHS, b)
+
+    def CalculateReaction(self, buffer_idx=0):
+        reaction = self.damping * ( self.dx[1] - self.dx_f[1]) \
+                 + self.stiffness * (self.dx[0] - self.dx_f[0])
+        return reaction
+
+    def CalculateSelfWeight(self):
+        self_weight = self.mass * self.modulus_self_weight
+        return self_weight
+
+    def GetSolutionStepValue(self, identifier, buffer_idx=0):
+        if identifier == "DISPLACEMENT":
+            return self.x[:,buffer_idx][0]
+        elif identifier == "VELOCITY":
+            return self.x[:,buffer_idx][1]
+        elif identifier == "ACCELERATION":
+            return self.x[:,buffer_idx][2]
+        elif identifier == "REACTION":
+            return self.CalculateReaction()
+        elif identifier == "VOLUME_ACCELERATION":
+            return self.CalculateSelfWeight()
+        else:
+            raise Exception("Identifier is unknown!")
+
+    def SetSolutionStepValue(self, identifier, value, buffer_idx=0):
+        if identifier == "DISPLACEMENT":
+            self.x[:,buffer_idx][0] = value
+        elif identifier == "VELOCITY":
+            self.x[:,buffer_idx][1] = value
+        elif identifier == "ACCELERATION":
+            self.x[:,buffer_idx][2] = value
+        elif identifier == "LOAD":
+            self.load_vector[-1] = 0.0
+            self.load_vector[-1] = value
+        elif identifier == "ROOT_POINT_DISPLACEMENT":
+            self.root_point_displacement = 0.0
+            self.root_point_displacement = value
+        else:
+            raise Exception("Identifier is unknown!")
+
+def ValidateAndAssignDefaults(defaults, settings, recursive=False):
+    for key, val in settings.items():
+        # check if the current entry also exists in the defaults
+        if not key in defaults.keys():
+            err_msg  = 'The item with name "' + key + '" is present in this '
+            err_msg += 'settings\nbut NOT in the defaults!\n'
+            err_msg += 'settings are:\n'
+            err_msg += json.dumps(settings, indent=4)
+            err_msg += '\ndefaults are:\n'
+            err_msg += json.dumps(defaults, indent=4)
+            raise Exception(err_msg)
+
+        # check if the type is the same in the defaults
+        if type(settings[key]) != type(defaults[key]):
+            err_msg  = 'The type of the item with name "' + key + '" (type: "'
+            err_msg += str(type(settings[key]).__name__)+'") in this '
+            err_msg += 'settings\nis NOT the same as in the defaults (type: "'
+            err_msg += str(type(defaults[key]).__name__)+'")!\n'
+            err_msg += 'settings are:\n'
+            err_msg += json.dumps(settings, indent=4)
+            err_msg += '\ndefaults are:\n'
+            err_msg += json.dumps(defaults, indent=4)
+            raise Exception(err_msg)
+
+    # loop the defaults and add the missing entries
+    for key_d, val_d in defaults.items():
+        if key_d not in settings: # add the default in case the setting is not present
+            settings[key_d] = val_d
+        elif recursive and type(val_d) is dict:
+            RecursivelyValidateAndAssignDefaults(val_d, settings[key_d])
+
+def RecursivelyValidateAndAssignDefaults(defaults, settings):
+    ValidateAndAssignDefaults(defaults, settings, recursive=True)
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/openfoam_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,61 +1,61 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
-
-# Other imports
-from KratosMultiphysics.CoSimulationApplication.utilities import model_part_utilities
-
-def Create(settings, model, solver_name):
-    return OpenFOAMWrapper(settings, model, solver_name)
-
-class OpenFOAMWrapper(CoSimulationSolverWrapper):
-    """This class serves as wrapper for the CFD solver OpenFOAM
-    """
-    def __init__(self, settings, model, solver_name):
-        super().__init__(settings, model, solver_name)
-
-        settings_defaults = KM.Parameters("""{
-            "import_meshes"    : [ ],
-            "export_data"      : [ ],
-            "import_data"      : [ ]
-        }""")
-
-        self.settings["solver_wrapper_settings"].ValidateAndAssignDefaults(settings_defaults)
-        model_part_utilities.CreateMainModelPartsFromCouplingDataSettings(self.settings["data"], self.model, self.name)
-        model_part_utilities.AllocateHistoricalVariablesFromCouplingDataSettings(self.settings["data"], self.model, self.name)
-
-    def Initialize(self):
-        for model_part_name in self.settings["solver_wrapper_settings"]["import_meshes"].GetStringArray():
-            interface_config = {"model_part_name" : model_part_name}
-            self.ImportCouplingInterface(interface_config)
-
-        super().Initialize()
-
-        for data in self.data_dict.values():
-            data.GetModelPart().GetRootModelPart().SetBufferSize(2)
-
-    def AdvanceInTime(self, current_time):
-        return 0.0 # TODO find a better solution here... maybe get time from solver through IO
-
-    def SolveSolutionStep(self):
-        for data_name in self.settings["solver_wrapper_settings"]["import_data"].GetStringArray():
-            data_config = {
-                "type" : "coupling_interface_data",
-                "interface_data" : self.GetInterfaceData(data_name)
-            }
-            self.ImportData(data_config)
-
-        super().SolveSolutionStep()
-
-        for data_name in self.settings["solver_wrapper_settings"]["export_data"].GetStringArray():
-            data_config = {
-                "type" : "coupling_interface_data",
-                "interface_data" : self.GetInterfaceData(data_name)
-            }
-            self.ExportData(data_config)
-
-
-    def _GetIOType(self):
-        return self.settings["io_settings"]["type"].GetString()
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
+
+# Other imports
+from KratosMultiphysics.CoSimulationApplication.utilities import model_part_utilities
+
+def Create(settings, model, solver_name):
+    return OpenFOAMWrapper(settings, model, solver_name)
+
+class OpenFOAMWrapper(CoSimulationSolverWrapper):
+    """This class serves as wrapper for the CFD solver OpenFOAM
+    """
+    def __init__(self, settings, model, solver_name):
+        super().__init__(settings, model, solver_name)
+
+        settings_defaults = KM.Parameters("""{
+            "import_meshes"    : [ ],
+            "export_data"      : [ ],
+            "import_data"      : [ ]
+        }""")
+
+        self.settings["solver_wrapper_settings"].ValidateAndAssignDefaults(settings_defaults)
+        model_part_utilities.CreateMainModelPartsFromCouplingDataSettings(self.settings["data"], self.model, self.name)
+        model_part_utilities.AllocateHistoricalVariablesFromCouplingDataSettings(self.settings["data"], self.model, self.name)
+
+    def Initialize(self):
+        for model_part_name in self.settings["solver_wrapper_settings"]["import_meshes"].GetStringArray():
+            interface_config = {"model_part_name" : model_part_name}
+            self.ImportCouplingInterface(interface_config)
+
+        super().Initialize()
+
+        for data in self.data_dict.values():
+            data.GetModelPart().GetRootModelPart().SetBufferSize(2)
+
+    def AdvanceInTime(self, current_time):
+        return 0.0 # TODO find a better solution here... maybe get time from solver through IO
+
+    def SolveSolutionStep(self):
+        for data_name in self.settings["solver_wrapper_settings"]["import_data"].GetStringArray():
+            data_config = {
+                "type" : "coupling_interface_data",
+                "interface_data" : self.GetInterfaceData(data_name)
+            }
+            self.ImportData(data_config)
+
+        super().SolveSolutionStep()
+
+        for data_name in self.settings["solver_wrapper_settings"]["export_data"].GetStringArray():
+            data_config = {
+                "type" : "coupling_interface_data",
+                "interface_data" : self.GetInterfaceData(data_name)
+            }
+            self.ExportData(data_config)
+
+
+    def _GetIOType(self):
+        return self.settings["io_settings"]["type"].GetString()
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/remote_controlled_solver_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,121 +1,121 @@
-# CoSimulation imports
-import KratosMultiphysics as KM
-import KratosMultiphysics.CoSimulationApplication as KratosCoSim
-import KratosMultiphysics.StructuralMechanicsApplication # needed for some variables
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
-
-# Other imports
-from KratosMultiphysics.CoSimulationApplication.utilities import model_part_utilities
-
-def Create(settings, model, solver_name):
-    return RemoteControlledSolverWrapper(settings, model, solver_name)
-
-class RemoteControlledSolverWrapper(CoSimulationSolverWrapper):
-    """This class is a generic wrapper for connecting external solvers that are being remote controlled
-    """
-    def __init__(self, settings, model, solver_name):
-        super().__init__(settings, model, solver_name)
-
-        settings_defaults = KM.Parameters("""{
-            "import_meshes"    : [ ],
-            "export_data"      : [ ],
-            "import_data"      : [ ]
-        }""")
-
-        self.settings["solver_wrapper_settings"].ValidateAndAssignDefaults(settings_defaults)
-
-        model_part_utilities.CreateModelPartsFromCouplingDataSettings(self.settings["data"], self.model, self.name)
-        model_part_utilities.AllocateHistoricalVariablesFromCouplingDataSettings(self.settings["data"], self.model, self.name)
-
-    def Initialize(self):
-        super().Initialize()
-
-        for model_part_name in self.settings["solver_wrapper_settings"]["import_meshes"].GetStringArray():
-            interface_config = { "model_part_name" : model_part_name }
-            self.ImportCouplingInterface(interface_config)
-
-    def AdvanceInTime(self, current_time):
-        settings = KM.Parameters("""{}""")
-        settings.AddEmptyValue("current_time").SetDouble(current_time)
-        self.__SendControlSignal("AdvanceInTime", settings)
-
-        # here one could import back the new time from the solver
-        return 0.0
-
-    def Predict(self):
-        super().Predict()
-        self.__SendControlSignal("Predict")
-
-    def InitializeSolutionStep(self):
-        super().InitializeSolutionStep()
-        self.__SendControlSignal("InitializeSolutionStep")
-
-    def SolveSolutionStep(self):
-        for data_name in self.settings["solver_wrapper_settings"]["export_data"].GetStringArray():
-            data_config = {
-                "type" : "coupling_interface_data",
-                "interface_data" : self.GetInterfaceData(data_name)
-            }
-            self.ExportData(data_config)
-
-        super().SolveSolutionStep()
-        self.__SendControlSignal("SolveSolutionStep")
-
-        for data_name in self.settings["solver_wrapper_settings"]["import_data"].GetStringArray():
-            data_config = {
-                "type" : "coupling_interface_data",
-                "interface_data" : self.GetInterfaceData(data_name)
-            }
-            self.ImportData(data_config)
-
-    def FinalizeSolutionStep(self):
-        super().FinalizeSolutionStep()
-        self.__SendControlSignal("FinalizeSolutionStep")
-
-    def OutputSolutionStep(self):
-        super().OutputSolutionStep()
-        self.__SendControlSignal("OutputSolutionStep")
-
-    def Finalize(self):
-        self.__SendControlSignal("exit")
-        super().Finalize() # this also does the disconnect
-
-    def ImportCouplingInterface(self, interface_config):
-        settings = KM.Parameters("""{}""")
-        settings.AddEmptyValue("identifier").SetString(interface_config["model_part_name"])
-        self.__SendControlSignal("ExportMesh", settings) # TODO this can also be geometry at some point
-        super().ImportCouplingInterface(interface_config)
-
-    def ExportCouplingInterface(self, interface_config):
-        self.__SendControlSignal("ImportMesh", interface_config["model_part_name"]) # TODO this can also be geometry at some point
-        super().ExportCouplingInterface(interface_config)
-
-    def ImportData(self, data_config):
-        # CoSim imports, the external solver exports
-        settings = KM.Parameters("""{}""")
-        settings.AddEmptyValue("identifier").SetString(data_config["interface_data"].name)
-        self.__SendControlSignal("ExportData", settings)
-        super().ImportData(data_config)
-
-    def ExportData(self, data_config):
-        if data_config["type"] == "coupling_interface_data":
-            # CoSim exports, the external solver imports
-            settings = KM.Parameters("""{}""")
-            settings.AddEmptyValue("identifier").SetString(data_config["interface_data"].name)
-            self.__SendControlSignal("ImportData", settings)
-        elif data_config["type"] == "repeat_time_step":
-            return # we control the ext solver, no need for sending a repeat_time_step signal
-        super().ExportData(data_config)
-
-    def _GetIOType(self):
-        return "kratos_co_sim_io"
-
-    def __SendControlSignal(self, signal, settings=None):
-        data_config = {
-            "type"           : "control_signal",
-            "control_signal" : signal,
-            "settings"       : settings
-        }
-        self.ExportData(data_config)
+# CoSimulation imports
+import KratosMultiphysics as KM
+import KratosMultiphysics.CoSimulationApplication as KratosCoSim
+import KratosMultiphysics.StructuralMechanicsApplication # needed for some variables
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
+
+# Other imports
+from KratosMultiphysics.CoSimulationApplication.utilities import model_part_utilities
+
+def Create(settings, model, solver_name):
+    return RemoteControlledSolverWrapper(settings, model, solver_name)
+
+class RemoteControlledSolverWrapper(CoSimulationSolverWrapper):
+    """This class is a generic wrapper for connecting external solvers that are being remote controlled
+    """
+    def __init__(self, settings, model, solver_name):
+        super().__init__(settings, model, solver_name)
+
+        settings_defaults = KM.Parameters("""{
+            "import_meshes"    : [ ],
+            "export_data"      : [ ],
+            "import_data"      : [ ]
+        }""")
+
+        self.settings["solver_wrapper_settings"].ValidateAndAssignDefaults(settings_defaults)
+
+        model_part_utilities.CreateModelPartsFromCouplingDataSettings(self.settings["data"], self.model, self.name)
+        model_part_utilities.AllocateHistoricalVariablesFromCouplingDataSettings(self.settings["data"], self.model, self.name)
+
+    def Initialize(self):
+        super().Initialize()
+
+        for model_part_name in self.settings["solver_wrapper_settings"]["import_meshes"].GetStringArray():
+            interface_config = { "model_part_name" : model_part_name }
+            self.ImportCouplingInterface(interface_config)
+
+    def AdvanceInTime(self, current_time):
+        settings = KM.Parameters("""{}""")
+        settings.AddEmptyValue("current_time").SetDouble(current_time)
+        self.__SendControlSignal("AdvanceInTime", settings)
+
+        # here one could import back the new time from the solver
+        return 0.0
+
+    def Predict(self):
+        super().Predict()
+        self.__SendControlSignal("Predict")
+
+    def InitializeSolutionStep(self):
+        super().InitializeSolutionStep()
+        self.__SendControlSignal("InitializeSolutionStep")
+
+    def SolveSolutionStep(self):
+        for data_name in self.settings["solver_wrapper_settings"]["export_data"].GetStringArray():
+            data_config = {
+                "type" : "coupling_interface_data",
+                "interface_data" : self.GetInterfaceData(data_name)
+            }
+            self.ExportData(data_config)
+
+        super().SolveSolutionStep()
+        self.__SendControlSignal("SolveSolutionStep")
+
+        for data_name in self.settings["solver_wrapper_settings"]["import_data"].GetStringArray():
+            data_config = {
+                "type" : "coupling_interface_data",
+                "interface_data" : self.GetInterfaceData(data_name)
+            }
+            self.ImportData(data_config)
+
+    def FinalizeSolutionStep(self):
+        super().FinalizeSolutionStep()
+        self.__SendControlSignal("FinalizeSolutionStep")
+
+    def OutputSolutionStep(self):
+        super().OutputSolutionStep()
+        self.__SendControlSignal("OutputSolutionStep")
+
+    def Finalize(self):
+        self.__SendControlSignal("exit")
+        super().Finalize() # this also does the disconnect
+
+    def ImportCouplingInterface(self, interface_config):
+        settings = KM.Parameters("""{}""")
+        settings.AddEmptyValue("identifier").SetString(interface_config["model_part_name"])
+        self.__SendControlSignal("ExportMesh", settings) # TODO this can also be geometry at some point
+        super().ImportCouplingInterface(interface_config)
+
+    def ExportCouplingInterface(self, interface_config):
+        self.__SendControlSignal("ImportMesh", interface_config["model_part_name"]) # TODO this can also be geometry at some point
+        super().ExportCouplingInterface(interface_config)
+
+    def ImportData(self, data_config):
+        # CoSim imports, the external solver exports
+        settings = KM.Parameters("""{}""")
+        settings.AddEmptyValue("identifier").SetString(data_config["interface_data"].name)
+        self.__SendControlSignal("ExportData", settings)
+        super().ImportData(data_config)
+
+    def ExportData(self, data_config):
+        if data_config["type"] == "coupling_interface_data":
+            # CoSim exports, the external solver imports
+            settings = KM.Parameters("""{}""")
+            settings.AddEmptyValue("identifier").SetString(data_config["interface_data"].name)
+            self.__SendControlSignal("ImportData", settings)
+        elif data_config["type"] == "repeat_time_step":
+            return # we control the ext solver, no need for sending a repeat_time_step signal
+        super().ExportData(data_config)
+
+    def _GetIOType(self):
+        return "kratos_co_sim_io"
+
+    def __SendControlSignal(self, signal, settings=None):
+        data_config = {
+            "type"           : "control_signal",
+            "control_signal" : signal,
+            "settings"       : settings
+        }
+        self.ExportData(data_config)
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/flower_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,86 +1,86 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
-
-# Other imports
-from KratosMultiphysics.CoSimulationApplication.utilities import model_part_utilities
-from KratosMultiphysics.CoSimulationApplication.utilities.data_communicator_utilities import GetRankZeroDataCommunicator
-
-def Create(settings, model, solver_name):
-    return FLOWerWrapper(settings, model, solver_name)
-
-class FLOWerWrapper(CoSimulationSolverWrapper):
-    """This class serves as wrapper for the CFD solver FLOWer
-    """
-    def __init__(self, settings, model, solver_name):
-        super().__init__(settings, model, solver_name)
-
-        settings_defaults = KM.Parameters("""{
-            "model_parts_read"      : { },
-            "model_parts_send"      : { },
-            "model_parts_recv"      : { },
-            "export_data"           : [ ],
-            "import_data"           : [ ],
-            "write_received_meshes" : false
-        }""")
-
-        self.settings["solver_wrapper_settings"].ValidateAndAssignDefaults(settings_defaults)
-
-        model_part_utilities.CreateMainModelPartsFromCouplingDataSettings(self.settings["data"], self.model, self.name)
-        model_part_utilities.AllocateHistoricalVariablesFromCouplingDataSettings(self.settings["data"], self.model, self.name)
-
-    def Initialize(self):
-        for main_model_part_name, mdpa_file_name in self.settings["solver_wrapper_settings"]["model_parts_read"].items():
-            KM.ModelPartIO(mdpa_file_name.GetString()).ReadModelPart(self.model[main_model_part_name])
-
-        for model_part_name, comm_name in self.settings["solver_wrapper_settings"]["model_parts_send"].items():
-            interface_config = {
-                "comm_name" : comm_name.GetString(),
-                "model_part_name" : model_part_name
-            }
-            self.ExportCouplingInterface(interface_config)
-
-        for model_part_name, comm_name in self.settings["solver_wrapper_settings"]["model_parts_recv"].items():
-            interface_config = {
-                "comm_name" : comm_name.GetString(),
-                "model_part_name" : model_part_name
-            }
-
-            self.ImportCouplingInterface(interface_config)
-
-            if self.settings["solver_wrapper_settings"]["write_received_meshes"].GetBool():
-                KM.ModelPartIO(model_part_name, KM.IO.WRITE | KM.IO.MESH_ONLY | KM.IO.SKIP_TIMER).WriteModelPart(self.model[model_part_name])
-
-        super().Initialize()
-
-
-    def SolveSolutionStep(self):
-        for data_name in self.settings["solver_wrapper_settings"]["export_data"].GetStringArray():
-            data_config = {
-                "type" : "coupling_interface_data",
-                "interface_data" : self.GetInterfaceData(data_name)
-            }
-            self.ExportData(data_config)
-
-        super().SolveSolutionStep()
-
-        for data_name in self.settings["solver_wrapper_settings"]["import_data"].GetStringArray():
-            data_config = {
-                "type" : "coupling_interface_data",
-                "interface_data" : self.GetInterfaceData(data_name)
-            }
-            self.ImportData(data_config)
-
-    def AdvanceInTime(self, current_time):
-        return 0.0 # TODO find a better solution here... maybe get time from solver through IO
-
-    def _GetIOType(self):
-        return "empire_io" # FLOWer currently only supports the EmpireIO
-
-    def _GetDataCommunicator(self):
-        # this solver does not support MPI
-        # more specifically the EmpireIO does not support MPI
-        # since FLOWer only uses the EmpireIO this has to be hardcoded (for now)
-        return GetRankZeroDataCommunicator()
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
+
+# Other imports
+from KratosMultiphysics.CoSimulationApplication.utilities import model_part_utilities
+from KratosMultiphysics.CoSimulationApplication.utilities.data_communicator_utilities import GetRankZeroDataCommunicator
+
+def Create(settings, model, solver_name):
+    return FLOWerWrapper(settings, model, solver_name)
+
+class FLOWerWrapper(CoSimulationSolverWrapper):
+    """This class serves as wrapper for the CFD solver FLOWer
+    """
+    def __init__(self, settings, model, solver_name):
+        super().__init__(settings, model, solver_name)
+
+        settings_defaults = KM.Parameters("""{
+            "model_parts_read"      : { },
+            "model_parts_send"      : { },
+            "model_parts_recv"      : { },
+            "export_data"           : [ ],
+            "import_data"           : [ ],
+            "write_received_meshes" : false
+        }""")
+
+        self.settings["solver_wrapper_settings"].ValidateAndAssignDefaults(settings_defaults)
+
+        model_part_utilities.CreateMainModelPartsFromCouplingDataSettings(self.settings["data"], self.model, self.name)
+        model_part_utilities.AllocateHistoricalVariablesFromCouplingDataSettings(self.settings["data"], self.model, self.name)
+
+    def Initialize(self):
+        for main_model_part_name, mdpa_file_name in self.settings["solver_wrapper_settings"]["model_parts_read"].items():
+            KM.ModelPartIO(mdpa_file_name.GetString()).ReadModelPart(self.model[main_model_part_name])
+
+        for model_part_name, comm_name in self.settings["solver_wrapper_settings"]["model_parts_send"].items():
+            interface_config = {
+                "comm_name" : comm_name.GetString(),
+                "model_part_name" : model_part_name
+            }
+            self.ExportCouplingInterface(interface_config)
+
+        for model_part_name, comm_name in self.settings["solver_wrapper_settings"]["model_parts_recv"].items():
+            interface_config = {
+                "comm_name" : comm_name.GetString(),
+                "model_part_name" : model_part_name
+            }
+
+            self.ImportCouplingInterface(interface_config)
+
+            if self.settings["solver_wrapper_settings"]["write_received_meshes"].GetBool():
+                KM.ModelPartIO(model_part_name, KM.IO.WRITE | KM.IO.MESH_ONLY | KM.IO.SKIP_TIMER).WriteModelPart(self.model[model_part_name])
+
+        super().Initialize()
+
+
+    def SolveSolutionStep(self):
+        for data_name in self.settings["solver_wrapper_settings"]["export_data"].GetStringArray():
+            data_config = {
+                "type" : "coupling_interface_data",
+                "interface_data" : self.GetInterfaceData(data_name)
+            }
+            self.ExportData(data_config)
+
+        super().SolveSolutionStep()
+
+        for data_name in self.settings["solver_wrapper_settings"]["import_data"].GetStringArray():
+            data_config = {
+                "type" : "coupling_interface_data",
+                "interface_data" : self.GetInterfaceData(data_name)
+            }
+            self.ImportData(data_config)
+
+    def AdvanceInTime(self, current_time):
+        return 0.0 # TODO find a better solution here... maybe get time from solver through IO
+
+    def _GetIOType(self):
+        return "empire_io" # FLOWer currently only supports the EmpireIO
+
+    def _GetDataCommunicator(self):
+        # this solver does not support MPI
+        # more specifically the EmpireIO does not support MPI
+        # since FLOWer only uses the EmpireIO this has to be hardcoded (for now)
+        return GetRankZeroDataCommunicator()
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/external_solver_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,60 +1,60 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-import KratosMultiphysics.StructuralMechanicsApplication # needed for some variables
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
-
-# Other imports
-from KratosMultiphysics.CoSimulationApplication.utilities import model_part_utilities
-
-def Create(settings, model, solver_name):
-    return ExternalSolverWrapper(settings, model, solver_name)
-
-class ExternalSolverWrapper(CoSimulationSolverWrapper):
-    """This class is a generic wrapper for connecting external solvers
-    The import of meshes is done once in the beginning
-    """
-    def __init__(self, settings, model, solver_name):
-        super().__init__(settings, model, solver_name)
-
-        settings_defaults = KM.Parameters("""{
-            "import_meshes"    : [ ],
-            "export_data"      : [ ],
-            "import_data"      : [ ]
-        }""")
-
-        self.settings["solver_wrapper_settings"].ValidateAndAssignDefaults(settings_defaults)
-
-        model_part_utilities.CreateModelPartsFromCouplingDataSettings(self.settings["data"], self.model, self.name)
-        model_part_utilities.AllocateHistoricalVariablesFromCouplingDataSettings(self.settings["data"], self.model, self.name)
-
-    def Initialize(self):
-        super().Initialize()
-
-        for model_part_name in self.settings["solver_wrapper_settings"]["import_meshes"].GetStringArray():
-            interface_config = { "model_part_name" : model_part_name }
-            self.ImportCouplingInterface(interface_config)
-
-    def AdvanceInTime(self, current_time):
-        return 0.0 # TODO find a better solution here... maybe get time from solver through IO
-
-    def SolveSolutionStep(self):
-        for data_name in self.settings["solver_wrapper_settings"]["export_data"].GetStringArray():
-            data_config = {
-                "type" : "coupling_interface_data",
-                "interface_data" : self.GetInterfaceData(data_name)
-            }
-            self.ExportData(data_config)
-
-        super().SolveSolutionStep()
-
-        for data_name in self.settings["solver_wrapper_settings"]["import_data"].GetStringArray():
-            data_config = {
-                "type" : "coupling_interface_data",
-                "interface_data" : self.GetInterfaceData(data_name)
-            }
-            self.ImportData(data_config)
-
-    def _GetIOType(self):
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+import KratosMultiphysics.StructuralMechanicsApplication # needed for some variables
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
+
+# Other imports
+from KratosMultiphysics.CoSimulationApplication.utilities import model_part_utilities
+
+def Create(settings, model, solver_name):
+    return ExternalSolverWrapper(settings, model, solver_name)
+
+class ExternalSolverWrapper(CoSimulationSolverWrapper):
+    """This class is a generic wrapper for connecting external solvers
+    The import of meshes is done once in the beginning
+    """
+    def __init__(self, settings, model, solver_name):
+        super().__init__(settings, model, solver_name)
+
+        settings_defaults = KM.Parameters("""{
+            "import_meshes"    : [ ],
+            "export_data"      : [ ],
+            "import_data"      : [ ]
+        }""")
+
+        self.settings["solver_wrapper_settings"].ValidateAndAssignDefaults(settings_defaults)
+
+        model_part_utilities.CreateModelPartsFromCouplingDataSettings(self.settings["data"], self.model, self.name)
+        model_part_utilities.AllocateHistoricalVariablesFromCouplingDataSettings(self.settings["data"], self.model, self.name)
+
+    def Initialize(self):
+        super().Initialize()
+
+        for model_part_name in self.settings["solver_wrapper_settings"]["import_meshes"].GetStringArray():
+            interface_config = { "model_part_name" : model_part_name }
+            self.ImportCouplingInterface(interface_config)
+
+    def AdvanceInTime(self, current_time):
+        return 0.0 # TODO find a better solution here... maybe get time from solver through IO
+
+    def SolveSolutionStep(self):
+        for data_name in self.settings["solver_wrapper_settings"]["export_data"].GetStringArray():
+            data_config = {
+                "type" : "coupling_interface_data",
+                "interface_data" : self.GetInterfaceData(data_name)
+            }
+            self.ExportData(data_config)
+
+        super().SolveSolutionStep()
+
+        for data_name in self.settings["solver_wrapper_settings"]["import_data"].GetStringArray():
+            data_config = {
+                "type" : "coupling_interface_data",
+                "interface_data" : self.GetInterfaceData(data_name)
+            }
+            self.ImportData(data_config)
+
+    def _GetIOType(self):
         return self.settings["io_settings"]["type"].GetString()
```

## KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/acusolve_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,202 +1,202 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
-from KratosMultiphysics.vtk_output_process import VtkOutputProcess
-
-# CoSimulation imports
-from KratosMultiphysics.CoSimulationApplication.utilities import model_part_utilities
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-
-# System imports
-import subprocess
-import platform
-
-def Create(settings, model, solver_name):
-    return acuSolveWrapper(settings, model, solver_name)
-
-class acuSolveWrapper(CoSimulationSolverWrapper):
-    """This class serves as a dedicated Kratos wrapper for acuSolve
-    """
-    # -----------------------------------------------
-    # Definition of standard Kratos wrapper functions
-    # -----------------------------------------------
-    # Create the AcuSolve Wrapper instance
-    def __init__(self, settings, model, solver_name):
-        """Constructor of the AcuSolve Wrapper
-        self        : an instance of the class
-        settings    : a Kratos Parameters object containing the settings
-        model       : a Kratos Model object containing the model
-        solver_name : the name of the solver
-        """
-        
-        super().__init__(settings, model, solver_name)
-        # Set default settings and validate JSON settings
-        solver_wrapper_settings_defaults = KM.Parameters("""{
-            "main_model_part_name"    : "",
-            "application"             : "AcuSolve",
-            "problem"                 : "",
-            "input_file"              : "",
-            "working_directory"       : "",
-            "problem_directory"       : ".",
-            "num_processors"          : 1,
-            "num_threads"             : 1,
-            "time_increment"          : 0.0,
-            "region"                  : "",
-            "gpu_flag"                : "FALSE",
-            "restart_flag"            : "FALSE",
-            "fast_restart_flag"       : "FALSE",
-            "echo_level"              : 1,
-            "export_data"             : [ ],
-            "import_data"             : [ ],
-            "import_meshes"           : [ ],
-            "post_process_first_step" :  true
-        }""")
-
-        # Validate settings
-        self.settings["solver_wrapper_settings"].ValidateAndAssignDefaults(solver_wrapper_settings_defaults)
-
-        # Get solver name
-        self.name = solver_name
-        
-        # --------------------------------------------------------------------------------
-        # Creation of the model parts and its associates variables in the Kratos environnement
-        # --------------------------------------------------------------------------------
-        model_part_utilities.CreateMainModelPartsFromCouplingDataSettings(self.settings["data"], self.model, self.name)
-        model_part_utilities.AllocateHistoricalVariablesFromCouplingDataSettings(self.settings["data"], self.model, self.name)        
-        cs_tools.cs_print_info(self.name + ": " +  "Run AcuSolve")
-
-        # ---------------------
-        # Get arguments from JSON file
-        #application                  = self.settings["solver_wrapper_settings"]["application"].GetString()
-        working_directory            = self.settings["solver_wrapper_settings"]["working_directory"].GetString()
-        problem_directory            = self.settings["solver_wrapper_settings"]["problem_directory"].GetString()
-        #region                       = self.settings["solver_wrapper_settings"]["region"].GetString()
-        echo_level                   = self.settings["solver_wrapper_settings"]["echo_level"].GetInt()
-        problem                      = self.settings["solver_wrapper_settings"]["problem"].GetString()
-        inputFile                    = self.settings["solver_wrapper_settings"]["input_file"].GetString()
-        np                           = self.settings["solver_wrapper_settings"]["num_processors"].GetInt()
-        nt                           = self.settings["solver_wrapper_settings"]["num_threads"].GetInt()
-        gpu                          = self.settings["solver_wrapper_settings"]["gpu_flag"].GetString()
-        rst                          = self.settings["solver_wrapper_settings"]["restart_flag"].GetString()
-        frst                         = self.settings["solver_wrapper_settings"]["restart_flag"].GetString()
-        self.deltaT                  = self.settings["solver_wrapper_settings"]["time_increment"].GetDouble()
-        self.post_process_first_step = self.settings["solver_wrapper_settings"]["post_process_first_step"].GetBool()
-
-        # ---------------------
-        # Launch AcuSolve
-        # ---------------------
-        common_cmd = inputFile + " -pb " + problem +" -dir "+ working_directory + " -pdir " + problem_directory + " -np "+ str(np) + " -nt " + str(nt)
-        verbose_cmd = " -verbose " + str(echo_level)
-        platform_details = {
-            "Linux"   : ("acuRun -inp ", " &"),
-            "Windows" : ("acuRun.bat -inp ", " -lbuff")
-        }
-        current_platform = platform.system()
-        if current_platform in platform_details:
-            base_cmd, buffer_cmd = platform_details[current_platform]
-            
-            if gpu != "FALSE":
-                cmd = f"{base_cmd}{common_cmd} -gpu {gpu}{verbose_cmd}{buffer_cmd}"
-            elif rst != "FALSE":
-                cmd = f"{base_cmd}{common_cmd} -rst {verbose_cmd}{buffer_cmd}"
-            elif frst != "FALSE":
-                cmd = f"{base_cmd}{common_cmd} -frst {verbose_cmd}{buffer_cmd}"
-            else:
-                cmd = f"{base_cmd}{common_cmd}{verbose_cmd}{buffer_cmd}"
-        else:
-            raise Exception("Unsupported operating system detected.")
-        cs_tools.cs_print_info(self.name + ": " +  cmd)
-        subprocess.run(cmd, shell=True)
-
-    def Initialize(self):
-        """ This function initializes the AFS Wrapper
-        self : an instance of the class
-        """
-        super().Initialize()
-        for model_part_name in self.settings["solver_wrapper_settings"]["import_meshes"].GetStringArray():
-             interface_config = { "model_part_name" : model_part_name }
-             self.ImportCouplingInterface(interface_config)
-        
-        # Post-process if required
-        if self.post_process_first_step:
-            cs_tools.cs_print_info(self.name + ": " +  "WRITING VTK OUTPUT...........")
-            vtk_output_configuration = KM.Parameters("""{
-                    "model_part_name"        : \""""+model_part_name+"""\",
-                    "output_sub_model_parts" : false,
-                    "nodal_solution_step_data_variables" : ["HEAT_FLUX"]
-                }""")
-            self.vtk_output = VtkOutputProcess(self.model, vtk_output_configuration)
-            self.vtk_output.ExecuteInitialize()
-            self.vtk_output.ExecuteBeforeSolutionLoop()
-            self.vtk_output.PrintOutput()
-
-    def ExportData(self, data_config):
-        """This function exports data to the AFS Wrapper
-        self        : an instance of the class
-        data_config : a dictionary containing the data configuration
-        """
-        if data_config["type"] == "repeat_time_step" and data_config["repeat_time_step"] == True:
-            cs_tools.cs_print_info(self.name + ": " +  "control signal : RepeatTimeStep")
-            self.__SendControlSignal("RepeatTimeStep")
-            #self.__SendControlSignal("Repeat")
-            return # we control the ext solver, no need for sending a repeat_time_step signal
-        elif data_config["type"] == "repeat_time_step" and data_config["repeat_time_step"] == False:
-           return
-        #    cs_tools.cs_print_info(self.name + ": " +  "control signal : NoRepeatTimeStep")
-        #    self.__SendControlSignal("NoRepeatTimeStep")  
-        super().ExportData(data_config)
-
-    def AdvanceInTime(self, current_time):
-        """This function advances the solution in time
-        self        : an instance of the class
-        current_time: the current time
-        """
-        if current_time > 0.0:
-            cs_tools.cs_print_info(self.name + ": " +  "control signal : AdvanceInTime")
-            self.__SendControlSignal("AdvanceInTime")
-            #self.__SendControlSignal("Advance")
-        cs_tools.cs_print_info(self.name + ": " +  self.deltaT)
-        return (current_time+self.deltaT)  # TODO find a better solution here... maybe get time from solver through IO
-        #return 0.0
-
-    def SolveSolutionStep(self):
-        """This function solves the solution step
-        self : an instance of the class
-        """
-        for data_name in self.settings["solver_wrapper_settings"]["export_data"].GetStringArray():
-            data_config = { 
-                "type" : "coupling_interface_data",
-                "interface_data" : self.GetInterfaceData(data_name)
-            }
-            self.ExportData(data_config)
-
-        super().SolveSolutionStep()
-
-        for data_name in self.settings["solver_wrapper_settings"]["import_data"].GetStringArray():
-            data_config = { 
-                "type" : "coupling_interface_data",
-                "interface_data" : self.GetInterfaceData(data_name)
-            }
-            self.ImportData(data_config)
-
-    def Finalize(self):
-        """Finalization of the coupled solver.
-        self : The coupled solver object
-        """
-        cs_tools.cs_print_info(self.name + ": " +  "control signal : exit")
-        self.__SendControlSignal("exit")
-        self.vtk_output.ExecuteFinalize()
-        super().Finalize()
-
-    def _GetIOType(self):
-        return self.settings["io_settings"]["type"].GetString()
-
-    def __SendControlSignal(self, signal, settings=None):
-        data_config = {
-            "type"           : "control_signal",
-            "control_signal" : signal,
-            "settings"       : settings
-        }
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
+from KratosMultiphysics.vtk_output_process import VtkOutputProcess
+
+# CoSimulation imports
+from KratosMultiphysics.CoSimulationApplication.utilities import model_part_utilities
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+
+# System imports
+import subprocess
+import platform
+
+def Create(settings, model, solver_name):
+    return acuSolveWrapper(settings, model, solver_name)
+
+class acuSolveWrapper(CoSimulationSolverWrapper):
+    """This class serves as a dedicated Kratos wrapper for acuSolve
+    """
+    # -----------------------------------------------
+    # Definition of standard Kratos wrapper functions
+    # -----------------------------------------------
+    # Create the AcuSolve Wrapper instance
+    def __init__(self, settings, model, solver_name):
+        """Constructor of the AcuSolve Wrapper
+        self        : an instance of the class
+        settings    : a Kratos Parameters object containing the settings
+        model       : a Kratos Model object containing the model
+        solver_name : the name of the solver
+        """
+        
+        super().__init__(settings, model, solver_name)
+        # Set default settings and validate JSON settings
+        solver_wrapper_settings_defaults = KM.Parameters("""{
+            "main_model_part_name"    : "",
+            "application"             : "AcuSolve",
+            "problem"                 : "",
+            "input_file"              : "",
+            "working_directory"       : "",
+            "problem_directory"       : ".",
+            "num_processors"          : 1,
+            "num_threads"             : 1,
+            "time_increment"          : 0.0,
+            "region"                  : "",
+            "gpu_flag"                : "FALSE",
+            "restart_flag"            : "FALSE",
+            "fast_restart_flag"       : "FALSE",
+            "echo_level"              : 1,
+            "export_data"             : [ ],
+            "import_data"             : [ ],
+            "import_meshes"           : [ ],
+            "post_process_first_step" :  true
+        }""")
+
+        # Validate settings
+        self.settings["solver_wrapper_settings"].ValidateAndAssignDefaults(solver_wrapper_settings_defaults)
+
+        # Get solver name
+        self.name = solver_name
+        
+        # --------------------------------------------------------------------------------
+        # Creation of the model parts and its associates variables in the Kratos environnement
+        # --------------------------------------------------------------------------------
+        model_part_utilities.CreateMainModelPartsFromCouplingDataSettings(self.settings["data"], self.model, self.name)
+        model_part_utilities.AllocateHistoricalVariablesFromCouplingDataSettings(self.settings["data"], self.model, self.name)        
+        cs_tools.cs_print_info(self.name + ": " +  "Run AcuSolve")
+
+        # ---------------------
+        # Get arguments from JSON file
+        #application                  = self.settings["solver_wrapper_settings"]["application"].GetString()
+        working_directory            = self.settings["solver_wrapper_settings"]["working_directory"].GetString()
+        problem_directory            = self.settings["solver_wrapper_settings"]["problem_directory"].GetString()
+        #region                       = self.settings["solver_wrapper_settings"]["region"].GetString()
+        echo_level                   = self.settings["solver_wrapper_settings"]["echo_level"].GetInt()
+        problem                      = self.settings["solver_wrapper_settings"]["problem"].GetString()
+        inputFile                    = self.settings["solver_wrapper_settings"]["input_file"].GetString()
+        np                           = self.settings["solver_wrapper_settings"]["num_processors"].GetInt()
+        nt                           = self.settings["solver_wrapper_settings"]["num_threads"].GetInt()
+        gpu                          = self.settings["solver_wrapper_settings"]["gpu_flag"].GetString()
+        rst                          = self.settings["solver_wrapper_settings"]["restart_flag"].GetString()
+        frst                         = self.settings["solver_wrapper_settings"]["restart_flag"].GetString()
+        self.deltaT                  = self.settings["solver_wrapper_settings"]["time_increment"].GetDouble()
+        self.post_process_first_step = self.settings["solver_wrapper_settings"]["post_process_first_step"].GetBool()
+
+        # ---------------------
+        # Launch AcuSolve
+        # ---------------------
+        common_cmd = inputFile + " -pb " + problem +" -dir "+ working_directory + " -pdir " + problem_directory + " -np "+ str(np) + " -nt " + str(nt)
+        verbose_cmd = " -verbose " + str(echo_level)
+        platform_details = {
+            "Linux"   : ("acuRun -inp ", " &"),
+            "Windows" : ("acuRun.bat -inp ", " -lbuff")
+        }
+        current_platform = platform.system()
+        if current_platform in platform_details:
+            base_cmd, buffer_cmd = platform_details[current_platform]
+            
+            if gpu != "FALSE":
+                cmd = f"{base_cmd}{common_cmd} -gpu {gpu}{verbose_cmd}{buffer_cmd}"
+            elif rst != "FALSE":
+                cmd = f"{base_cmd}{common_cmd} -rst {verbose_cmd}{buffer_cmd}"
+            elif frst != "FALSE":
+                cmd = f"{base_cmd}{common_cmd} -frst {verbose_cmd}{buffer_cmd}"
+            else:
+                cmd = f"{base_cmd}{common_cmd}{verbose_cmd}{buffer_cmd}"
+        else:
+            raise Exception("Unsupported operating system detected.")
+        cs_tools.cs_print_info(self.name + ": " +  cmd)
+        subprocess.run(cmd, shell=True)
+
+    def Initialize(self):
+        """ This function initializes the AFS Wrapper
+        self : an instance of the class
+        """
+        super().Initialize()
+        for model_part_name in self.settings["solver_wrapper_settings"]["import_meshes"].GetStringArray():
+             interface_config = { "model_part_name" : model_part_name }
+             self.ImportCouplingInterface(interface_config)
+        
+        # Post-process if required
+        if self.post_process_first_step:
+            cs_tools.cs_print_info(self.name + ": " +  "WRITING VTK OUTPUT...........")
+            vtk_output_configuration = KM.Parameters("""{
+                    "model_part_name"        : \""""+model_part_name+"""\",
+                    "output_sub_model_parts" : false,
+                    "nodal_solution_step_data_variables" : ["HEAT_FLUX"]
+                }""")
+            self.vtk_output = VtkOutputProcess(self.model, vtk_output_configuration)
+            self.vtk_output.ExecuteInitialize()
+            self.vtk_output.ExecuteBeforeSolutionLoop()
+            self.vtk_output.PrintOutput()
+
+    def ExportData(self, data_config):
+        """This function exports data to the AFS Wrapper
+        self        : an instance of the class
+        data_config : a dictionary containing the data configuration
+        """
+        if data_config["type"] == "repeat_time_step" and data_config["repeat_time_step"] == True:
+            cs_tools.cs_print_info(self.name + ": " +  "control signal : RepeatTimeStep")
+            self.__SendControlSignal("RepeatTimeStep")
+            #self.__SendControlSignal("Repeat")
+            return # we control the ext solver, no need for sending a repeat_time_step signal
+        elif data_config["type"] == "repeat_time_step" and data_config["repeat_time_step"] == False:
+           return
+        #    cs_tools.cs_print_info(self.name + ": " +  "control signal : NoRepeatTimeStep")
+        #    self.__SendControlSignal("NoRepeatTimeStep")  
+        super().ExportData(data_config)
+
+    def AdvanceInTime(self, current_time):
+        """This function advances the solution in time
+        self        : an instance of the class
+        current_time: the current time
+        """
+        if current_time > 0.0:
+            cs_tools.cs_print_info(self.name + ": " +  "control signal : AdvanceInTime")
+            self.__SendControlSignal("AdvanceInTime")
+            #self.__SendControlSignal("Advance")
+        cs_tools.cs_print_info(self.name + ": " +  self.deltaT)
+        return (current_time+self.deltaT)  # TODO find a better solution here... maybe get time from solver through IO
+        #return 0.0
+
+    def SolveSolutionStep(self):
+        """This function solves the solution step
+        self : an instance of the class
+        """
+        for data_name in self.settings["solver_wrapper_settings"]["export_data"].GetStringArray():
+            data_config = { 
+                "type" : "coupling_interface_data",
+                "interface_data" : self.GetInterfaceData(data_name)
+            }
+            self.ExportData(data_config)
+
+        super().SolveSolutionStep()
+
+        for data_name in self.settings["solver_wrapper_settings"]["import_data"].GetStringArray():
+            data_config = { 
+                "type" : "coupling_interface_data",
+                "interface_data" : self.GetInterfaceData(data_name)
+            }
+            self.ImportData(data_config)
+
+    def Finalize(self):
+        """Finalization of the coupled solver.
+        self : The coupled solver object
+        """
+        cs_tools.cs_print_info(self.name + ": " +  "control signal : exit")
+        self.__SendControlSignal("exit")
+        self.vtk_output.ExecuteFinalize()
+        super().Finalize()
+
+    def _GetIOType(self):
+        return self.settings["io_settings"]["type"].GetString()
+
+    def __SendControlSignal(self, signal, settings=None):
+        data_config = {
+            "type"           : "control_signal",
+            "control_signal" : signal,
+            "settings"       : settings
+        }
         self.ExportData(data_config)
```

## KratosMultiphysics/CoSimulationApplication/empire_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,524 +1,524 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Other imports
-import ctypes as ctp
-
-
-# TODO check if variables are in MP!
-
-class EmpireWrapper:
-    # Source of Implementation: https://code.activestate.com/recipes/52558/
-    # storage for the instance reference
-    __instance = None
-
-    def __init__(self, echo_level=0, dry_run=False):
-        """ Create singleton instance """
-        # Check whether we already have an instance
-        if EmpireWrapper.__instance is None:
-            # Create and remember instance
-            EmpireWrapper.__instance = EmpireWrapper.__EmpireWrapper(echo_level, dry_run)
-
-    def __getattr__(self, attr):
-        """ Delegate access to implementation """
-        return getattr(self.__instance, attr)
-
-    def __setattr__(self, attr, value):
-        """ Delegate access to implementation """
-        return setattr(self.__instance, attr, value)
-
-    class __EmpireWrapper:
-        # Wrapper for the EMPIRE API (/EMPIRE-Core/EMPIRE_API/src/include/EMPIRE_API.h)
-        # Implemented as Singleton, bcs otherwise the EMPIRE library can be imported several times
-        ##### Constructor #####
-        # -------------------------------------------------------------------------------------------------
-        def __init__(self, echo_level, dry_run):
-            self.model_parts = {}
-            self.echo_level = echo_level
-            self.dry_run = dry_run # only for debugging to set-up cases without having to execute EMPIRE
-            if not self.dry_run:
-                self._load_empire_library()
-            else:
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped loading empire-library!!')
-        # -------------------------------------------------------------------------------------------------
-
-        ##### Public Functions #####
-        # -------------------------------------------------------------------------------------------------
-        def Connect(self, xml_input_file):
-            ''' Establishes the necessary connection with the Emperor '''
-            info_msg  = 'Attempting to connect with xml-file "'
-            info_msg += xml_input_file + '"'
-            KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', info_msg)
-            if not self.dry_run:
-                self.libempire_api.EMPIRE_API_Connect(xml_input_file.encode())
-            else:
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
-            KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Successfully connected')
-        # -------------------------------------------------------------------------------------------------
-
-        # -------------------------------------------------------------------------------------------------
-        def Disconnect(self):
-            ''' Performs disconnection and finalization operations to the Emperor '''
-            KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Attempting to disconnect')
-            if not self.dry_run:
-                self.libempire_api.EMPIRE_API_Disconnect()
-            else:
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
-            KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Successfully disconnected')
-        # -------------------------------------------------------------------------------------------------
-
-        # -------------------------------------------------------------------------------------------------
-        def SendMesh(self, mesh_name, model_part):
-            ''' Send the mesh to the server
-            \param[in] name name of the mesh
-            \param[in] numNodes number of nodes
-            \param[in] numElems number of elements
-            \param[in] nodes coordinates of all nodes
-            \param[in] nodeIDs IDs of all nodes
-            \param[in] numNodesPerElem number of nodes per element
-            \param[in] elems connectivity table of all elements
-
-            void EMPIRE_API_sendMesh(char *name, int numNodes, int numElems, double *nodes, int *nodeIDs,
-                    int *numNodesPerElem, int *elems); '''
-            # mesh_name: name of mesh in the emperor input
-
-            # Save the ModelPart for data-field exchange later
-            self._save_model_part(mesh_name, model_part)
-
-            # extract interface mesh information
-            numNodes = [];          numElems = []
-            nodeCoors = [];         nodeIDs = []
-            numNodesPerElem = [];   elemTable = []
-            self._get_mesh(model_part, numNodes, numElems, nodeCoors, nodeIDs, numNodesPerElem, elemTable)
-
-            # convert python lists to ctypes, required for empire-function call
-            c_numNodes = (ctp.c_int * len(numNodes))(*numNodes)
-            c_numElems = (ctp.c_int * len(numElems))(*numElems)
-            c_nodeCoors = (ctp.c_double * len(nodeCoors))(*nodeCoors)
-            c_nodeIDs = (ctp.c_int * len(nodeIDs))(*nodeIDs)
-            c_numNodesPerElem = (ctp.c_int * len(numNodesPerElem))(*numNodesPerElem)
-            c_elemTable = (ctp.c_int * len(elemTable))(*elemTable)
-
-            if self.echo_level > 0:
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Attempting to send mesh "' + mesh_name + '"')
-            if not self.dry_run:
-                self.libempire_api.EMPIRE_API_sendMesh("mesh_name.encode()",
-                                                       c_numNodes[0], c_numElems[0],
-                                                       c_nodeCoors, c_nodeIDs,
-                                                       c_numNodesPerElem, c_elemTable)
-            if self.echo_level > 0:
-                if self.dry_run:
-                    KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Sucessfully sent mesh')
-        # -------------------------------------------------------------------------------------------------
-
-        # -------------------------------------------------------------------------------------------------
-        def ReceiveMesh(self, mesh_name, model_part):
-            ''' Recieve mesh from the server
-            \param[in] name name of the mesh
-            \param[in] numNodes number of nodes
-            \param[in] numElems number of elements
-            \param[in] nodes coordinates of all nodes
-            \param[in] nodeIDs IDs of all nodes
-            \param[in] numNodesPerElem number of nodes per element
-            \param[in] elems connectivity table of all elements
-
-            void EMPIRE_API_recvMesh(char *name, int *numNodes, int *numElems, double **nodes, int **nodeIDs,
-                    int **numNodesPerElem, int **elem); '''
-            # mesh_name: name of mesh in the emperor input
-
-            # Save the ModelPart for data-field exchange later
-            self._save_model_part(mesh_name, model_part)
-
-            c_numNodes = ctp.pointer(ctp.c_int(0))
-            c_numElems = ctp.pointer(ctp.c_int(0))
-            c_nodeCoors = ctp.pointer(ctp.pointer(ctp.c_double(0)))
-            c_nodeIDs = ctp.pointer(ctp.pointer(ctp.c_int(0)))
-            c_numNodesPerElem = ctp.pointer(ctp.pointer(ctp.c_int(0)))
-            c_elemTable = ctp.pointer(ctp.pointer(ctp.c_int(0)))
-
-            if self.echo_level > 0:
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Attempting to receive mesh "' + mesh_name + '"')
-            if not self.dry_run:
-                self.libempire_api.EMPIRE_API_recvMesh(mesh_name.encode(),
-                                                       c_numNodes, c_numElems,
-                                                       c_nodeCoors, c_nodeIDs,
-                                                       c_numNodesPerElem, c_elemTable)
-            if self.echo_level > 0:
-                if self.dry_run:
-                    KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Sucessfully received mesh')
-
-            numNodes = c_numNodes.contents.value
-            numElems = c_numElems.contents.value
-            nodeCoors = c_nodeCoors.contents
-            nodeIDs = c_nodeIDs.contents
-            numNodesPerElem = c_numNodesPerElem.contents
-            elemTable = c_elemTable.contents
-
-            self._set_mesh(model_part, numNodes, numElems, nodeCoors, nodeIDs, numNodesPerElem, elemTable)
-        # -------------------------------------------------------------------------------------------------
-
-        # -------------------------------------------------------------------------------------------------
-        def SendDataField(self, mesh_name, data_field_name, kratos_variables):
-            ''' Send data field to the server
-            \param[in] name name of the field
-            \param[in] sizeOfArray size of the array (data field)
-            \param[in] dataField the data field to be sent
-
-            void EMPIRE_API_sendDataField(char *name, int sizeOfArray, double *dataField); '''
-            # mesh_name: name of mesh in the emperor input
-            # data_field_name: name of dataField in the emperor input
-
-            # get ModelPart
-            model_part = self.model_parts[mesh_name]
-
-            if not type(kratos_variables) == list:
-                kratos_variables = [kratos_variables]
-
-            # extract data field from nodes
-            data_field = self._get_data_field(model_part, kratos_variables)
-
-            # convert list containg the data field to ctypes
-            c_data_field = (ctp.c_double * len(data_field))(*data_field)
-            c_size = len(c_data_field)
-
-            if self.echo_level > 1:
-                info_msg  = 'Attempting to send data-field "' + data_field_name
-                info_msg += '" for mesh "' + mesh_name + '"\n                '
-                info_msg += 'With Kratos-Vars: ' + ", ".join([var.Name() for var in kratos_variables])
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', info_msg)
-            if not self.dry_run:
-                self.libempire_api.EMPIRE_API_sendDataField("data_field_name.encode()", c_size, c_data_field)
-            if self.echo_level > 1:
-                if self.dry_run:
-                    KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Successfully sent data-field')
-        # -------------------------------------------------------------------------------------------------
-
-        # -------------------------------------------------------------------------------------------------
-        def ReceiveDataField(self, mesh_name, data_field_name, kratos_variables):
-            ''' Receive data field from the server
-            \param[in] name name of the field
-            \param[in] sizeOfArray size of the array (data field)
-            \param[out] dataField the data field to be received
-
-            void EMPIRE_API_recvDataField(char *name, int sizeOfArray, double *dataField); '''
-            # mesh_name: name of mesh in the emperor input
-            # data_field_name: name of dataField in the emperor input
-
-            # get ModelPart
-            model_part = self.model_parts[mesh_name]
-
-            if not type(kratos_variables) == list:
-                kratos_variables = [kratos_variables]
-
-            # Determine Sizes of Variables
-            sizes_of_variables = self._sizes_of_variables(model_part, kratos_variables)
-            self._check_size_of_variables(sizes_of_variables)
-
-            # initialize vector storing the values
-            size_data_field = model_part.NumberOfNodes() * sum(sizes_of_variables)
-            c_size_data_field = ctp.c_int(size_data_field)
-            c_data_field = (ctp.c_double * size_data_field)(0)
-
-            if self.echo_level > 1:
-                info_msg  = 'Attempting to receive data-field "' + data_field_name
-                info_msg += '" for mesh "' + mesh_name + '"\n                '
-                info_msg += 'With Kratos-Vars: ' + ", ".join([var.Name() for var in kratos_variables])
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', info_msg)
-            if not self.dry_run:
-                self.libempire_api.EMPIRE_API_recvDataField(data_field_name.encode(), c_size_data_field, c_data_field)
-            if self.echo_level > 1:
-                if self.dry_run:
-                    KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Successfully received data-field')
-
-            self._set_data_field(model_part, kratos_variables, c_data_field, sizes_of_variables)
-        # -------------------------------------------------------------------------------------------------
-
-        # -------------------------------------------------------------------------------------------------
-        def SendArray(self, array_name, array_to_send):
-            ''' Send signal to the server
-            \param[in] name name of the signal
-            \param[in] sizeOfArray size of the array (signal)
-            \param[in] signal the signal
-
-            void EMPIRE_API_sendSignal_double(char *name, int sizeOfArray, double *signal); '''
-            # array_name: name of signal in the emperor input
-
-            # convert array to ctypes
-            c_signal = (ctp.c_double * len(array_to_send))(*array_to_send)
-            c_size = len(c_signal)
-
-            if self.echo_level > 1:
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Attempting to send array "' + array_name + '"')
-            if not self.dry_run:
-                self.libempire_api.EMPIRE_API_sendSignal_double(array_name.encode(), c_size, c_signal)
-
-            if self.echo_level > 1:
-                if self.dry_run:
-                    KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Successfully sent array')
-        # -------------------------------------------------------------------------------------------------
-
-        # -------------------------------------------------------------------------------------------------
-        def ReceiveArray(self, array_name, array_size):
-            ''' Receive signal from the server
-            \param[in] name name of the signal
-            \param[in] sizeOfArray size of the array (signal)
-            \param[in] signal the signal
-
-            void EMPIRE_API_recvSignal_double(char *name, int sizeOfArray, double *signal); '''
-            # array_name: name of signal in the emperor input
-
-            # initialize vector storing the values
-            c_signal = (ctp.c_double * array_size)(0)
-
-            if self.echo_level > 1:
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Attempting to receive array "' + array_name + '"')
-            if not self.dry_run:
-                self.libempire_api.EMPIRE_API_recvSignal_double(array_name.encode(), array_size, c_signal)
-            if self.echo_level > 1:
-                if self.dry_run:
-                    KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Successfully received array')
-
-            return self._convert_to_list(array_size, c_signal)
-        # -------------------------------------------------------------------------------------------------
-
-        # -------------------------------------------------------------------------------------------------
-        def SendConvergenceSignal(self, signal):
-            ''' Send the convergence signal of an loop
-            \param[in] signal 1 means convergence, 0 means non-convergence
-            void EMPIRE_API_sendConvergenceSignal(int signal); '''
-
-            if self.echo_level > 1:
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Attempting to send convergence-signal')
-            if not self.dry_run:
-                self.libempire_api.EMPIRE_API_sendConvergenceSignal(signal)
-            if self.echo_level > 1:
-                if self.dry_run:
-                    KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Successfully sent convergence-signal')
-        # -------------------------------------------------------------------------------------------------
-
-        # -------------------------------------------------------------------------------------------------
-        def ReceiveConvergenceSignal(self):
-            '''Receive the convergence signal of an loop
-            \return 1 means convergence, 0 means non-convergence
-
-            int EMPIRE_API_recvConvergenceSignal(); '''
-
-            if self.echo_level > 1:
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Attempting to receive convergence-signal')
-            if not self.dry_run:
-                signal = self.libempire_api.EMPIRE_API_recvConvergenceSignal()
-            else:
-                signal = 0
-            if self.echo_level > 1:
-                if self.dry_run:
-                    KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Successfully received convergence-signal')
-            return signal
-        # -------------------------------------------------------------------------------------------------
-
-        ##### Private Functions #####
-        # -------------------------------------------------------------------------------------------------
-        def _load_empire_library(self):
-            if hasattr(self, 'libempire_api'): # the library has been loaded already
-                raise ImportError("The EMPIRE library must be loaded only once!")
-
-            import os
-
-            if "EMPIRE_API_LIBSO_ON_MACHINE" not in os.environ:
-                raise ImportError("The EMPIRE environment is not set!")
-
-            KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Attempting to load empire-api')
-            try: # OpenMPI
-                self.libempire_api = ctp.CDLL(os.environ['EMPIRE_API_LIBSO_ON_MACHINE'], ctp.RTLD_GLOBAL)
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Using standard OpenMPI')
-            except: # Intel MPI or OpenMPI compiled with "–disable-dlopen" option
-                self.libempire_api = ctp.cdll.LoadLibrary(os.environ['EMPIRE_API_LIBSO_ON_MACHINE'])
-                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Using Intel MPI or OpenMPI compiled with "–disable-dlopen" option')
-            KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Successfully loaded empire-api')
-        # -------------------------------------------------------------------------------------------------
-
-        # -------------------------------------------------------------------------------------------------
-        def _get_mesh(self, model_part, num_nodes, num_elements, node_coords, node_IDs, num_nodes_per_element, element_table):
-            num_nodes.append(model_part.NumberOfNodes())
-            num_elements.append(model_part.NumberOfElements())
-
-            for node in model_part.Nodes:
-                node_coords.append(node.X)
-                node_coords.append(node.Y)
-                node_coords.append(node.Z)
-                node_IDs.append(node.Id)
-
-            for elem in model_part.Elements:
-                num_nodes_per_element.append(len(elem.GetNodes()))
-                for node in elem.GetNodes():
-                    element_table.append(node.Id)
-        # -------------------------------------------------------------------------------------------------
-
-        # -------------------------------------------------------------------------------------------------
-        def _set_mesh(self, model_part, num_nodes, num_elements, node_coords, node_IDs, num_nodes_per_element, element_table):
-            # This function requires an empty ModelPart
-            # It constructs Nodes and Elements from what was received from EMPIRE
-
-            # Some checks to validate input:
-            if model_part.NumberOfNodes() != 0:
-                raise Exception("ModelPart is not empty, it has some Nodes!")
-            if model_part.NumberOfElements() != 0:
-                raise Exception("ModelPart is not empty, it has some Elements!")
-            if model_part.NumberOfConditions() != 0:
-                raise Exception("ModelPart is not empty, it has some Conditions!")
-
-            # Create Nodes
-            for i in range(num_nodes):
-                model_part.CreateNewNode(node_IDs[i], node_coords[3*i+0], node_coords[3*i+1], node_coords[3*i+2]) # Id, X, Y, Z
-
-            # Create dummy Property for Element
-            prop = model_part.GetProperties()[1]
-
-            element_table_counter = 0
-            # Create Elements
-            for i in range(num_elements):
-                num_nodes_element = num_nodes_per_element[i]
-                if num_nodes_element == 2:
-                    name_element = "Element2D2N"
-                elif num_nodes_element == 3:
-                    name_element = "Element2D3N"
-                elif num_nodes_element == 4:
-                    name_element = "Element2D4N"
-                else:
-                    raise Exception("Wrong number of nodes for creating the element")
-
-                element_nodes = []
-                for j in range(num_nodes_element):
-                    element_nodes.append(int(element_table[element_table_counter]))
-                    element_table_counter += 1
-
-                model_part.CreateNewElement(name_element, i+1, element_nodes, prop)
-        # -------------------------------------------------------------------------------------------------
-
-        # -------------------------------------------------------------------------------------------------
-        def _get_data_field(self, model_part, kratos_variables):
-            for var in kratos_variables:
-                if not model_part.HasNodalSolutionStepVariable(var):
-                    err_msg  = 'ModelPart "' + model_part.Name + '" does not have'
-                    err_msg += ' "' + var.Name() + '" as SolutionStepVariable!'
-                    raise Exception(err_msg)
-
-            sizes_of_variables = self._sizes_of_variables(model_part, kratos_variables)
-            self._check_size_of_variables(sizes_of_variables)
-
-            num_nodes = model_part.NumberOfNodes()
-            sum_sizes = sum(sizes_of_variables)
-
-            data_field = [0.0] * (num_nodes * sum_sizes) # preallocate
-
-            for node_i, node in enumerate(model_part.Nodes):
-                size_index = 0
-                for size_of_variable, variable in zip(sizes_of_variables, kratos_variables):
-                    data_value = node.GetSolutionStepValue(variable)
-
-                    if size_of_variable == 1:
-                        data_field[node_i * sum_sizes + size_index] = data_value
-                        size_index += 1
-                    else:
-                        for k in range(size_of_variable):
-                            data_field[node_i * sum_sizes + size_index] = data_value[k]
-                            size_index += 1
-
-            return data_field
-        # -------------------------------------------------------------------------------------------------
-
-        # -------------------------------------------------------------------------------------------------
-        def _set_data_field(self, model_part, kratos_variables, data_field, size_of_variables):
-            # check if size of data field is correct
-            if len(data_field) != model_part.NumberOfNodes() * sum(size_of_variables):
-                raise Exception("received data field has wrong size!")
-
-            for var in kratos_variables:
-                if not model_part.HasNodalSolutionStepVariable(var):
-                    err_msg  = 'ModelPart "' + model_part.Name + '" does not have'
-                    err_msg += ' "' + var.Name() + '" as SolutionStepVariable!'
-                    raise Exception(err_msg)
-
-            # Preallocate values
-            values = []
-            for size_of_variable in size_of_variables:
-                if size_of_variable > 1:
-                    values.append(KratosMultiphysics.Vector(size_of_variable))
-                else:
-                    values.append(0.0)
-
-            sum_sizes = sum(size_of_variables)
-
-            # assign values to nodes of interface for current time step
-            for node_i, node in enumerate(model_part.Nodes):
-                size_index = 0
-                for size_of_variable, variable, value in zip(size_of_variables, kratos_variables, values):
-                    if size_of_variable == 1:
-                        value = data_field[sum_sizes * node_i + size_index]
-                        size_index += 1
-                    else:
-                        for k in range(size_of_variable):
-                            value[k] = data_field[sum_sizes * node_i + size_index]
-                            size_index += 1
-
-                    node.SetSolutionStepValue(variable, 0, value)
-        # -------------------------------------------------------------------------------------------------
-
-        # -------------------------------------------------------------------------------------------------
-        def _sizes_of_variables(self, model_part, kratos_variables):
-            # this function is very general, even though EMPIRE works with Scalar and Vector quantities only!
-            sizes_of_variables = []
-            first_node = next(iter(model_part.Nodes))
-            for variable in kratos_variables:
-                try:
-                    value = first_node.GetSolutionStepValue(variable)
-                    if (isinstance(value, float) or isinstance(value, int)): # Variable is a scalar
-                        size_of_variable = 1
-                    else:
-                        size_of_variable = len(value)
-                    sizes_of_variables.append(size_of_variable)
-                except StopIteration:
-                    raise TypeError("Size of Variable \"" + variable + "\" could not be determined")
-
-            return sizes_of_variables
-        # -------------------------------------------------------------------------------------------------
-
-        # -------------------------------------------------------------------------------------------------
-        def _save_model_part(self, mesh_name, model_part):
-            # Save the model_part for data-field exchange later
-            if mesh_name in self.model_parts:
-                raise ValueError("Mesh exsts already")
-            else:
-                self.model_parts.update({mesh_name : model_part})
-        # -------------------------------------------------------------------------------------------------
-
-        # -------------------------------------------------------------------------------------------------
-        def _convert_to_list(self, array_size, c_signal):
-            converted_list = [0.0] * array_size # preallocate
-
-            for i in range(array_size):
-                converted_list[i] = c_signal[i]
-
-            return converted_list
-        # -------------------------------------------------------------------------------------------------
-
-        # -------------------------------------------------------------------------------------------------
-        def _check_size_of_variables(self, size_of_variables):
-            sum_sizes = sum(size_of_variables)
-
-            possible_sizes = [ 1,  # Scalar
-                               3,  # Vector
-                               6 ] # doubleVector
-
-            if sum_sizes not in possible_sizes:
-                err_msg =  "Wrong size of variables: " + str(sum_sizes) + " !\n"
-                err_msg += "Curently only Scalar, Vector and doubleVector are supported by Empire!"
-                raise Exception(err_msg)
-        # -------------------------------------------------------------------------------------------------
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Other imports
+import ctypes as ctp
+
+
+# TODO check if variables are in MP!
+
+class EmpireWrapper:
+    # Source of Implementation: https://code.activestate.com/recipes/52558/
+    # storage for the instance reference
+    __instance = None
+
+    def __init__(self, echo_level=0, dry_run=False):
+        """ Create singleton instance """
+        # Check whether we already have an instance
+        if EmpireWrapper.__instance is None:
+            # Create and remember instance
+            EmpireWrapper.__instance = EmpireWrapper.__EmpireWrapper(echo_level, dry_run)
+
+    def __getattr__(self, attr):
+        """ Delegate access to implementation """
+        return getattr(self.__instance, attr)
+
+    def __setattr__(self, attr, value):
+        """ Delegate access to implementation """
+        return setattr(self.__instance, attr, value)
+
+    class __EmpireWrapper:
+        # Wrapper for the EMPIRE API (/EMPIRE-Core/EMPIRE_API/src/include/EMPIRE_API.h)
+        # Implemented as Singleton, bcs otherwise the EMPIRE library can be imported several times
+        ##### Constructor #####
+        # -------------------------------------------------------------------------------------------------
+        def __init__(self, echo_level, dry_run):
+            self.model_parts = {}
+            self.echo_level = echo_level
+            self.dry_run = dry_run # only for debugging to set-up cases without having to execute EMPIRE
+            if not self.dry_run:
+                self._load_empire_library()
+            else:
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped loading empire-library!!')
+        # -------------------------------------------------------------------------------------------------
+
+        ##### Public Functions #####
+        # -------------------------------------------------------------------------------------------------
+        def Connect(self, xml_input_file):
+            ''' Establishes the necessary connection with the Emperor '''
+            info_msg  = 'Attempting to connect with xml-file "'
+            info_msg += xml_input_file + '"'
+            KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', info_msg)
+            if not self.dry_run:
+                self.libempire_api.EMPIRE_API_Connect(xml_input_file.encode())
+            else:
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
+            KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Successfully connected')
+        # -------------------------------------------------------------------------------------------------
+
+        # -------------------------------------------------------------------------------------------------
+        def Disconnect(self):
+            ''' Performs disconnection and finalization operations to the Emperor '''
+            KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Attempting to disconnect')
+            if not self.dry_run:
+                self.libempire_api.EMPIRE_API_Disconnect()
+            else:
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
+            KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Successfully disconnected')
+        # -------------------------------------------------------------------------------------------------
+
+        # -------------------------------------------------------------------------------------------------
+        def SendMesh(self, mesh_name, model_part):
+            ''' Send the mesh to the server
+            \param[in] name name of the mesh
+            \param[in] numNodes number of nodes
+            \param[in] numElems number of elements
+            \param[in] nodes coordinates of all nodes
+            \param[in] nodeIDs IDs of all nodes
+            \param[in] numNodesPerElem number of nodes per element
+            \param[in] elems connectivity table of all elements
+
+            void EMPIRE_API_sendMesh(char *name, int numNodes, int numElems, double *nodes, int *nodeIDs,
+                    int *numNodesPerElem, int *elems); '''
+            # mesh_name: name of mesh in the emperor input
+
+            # Save the ModelPart for data-field exchange later
+            self._save_model_part(mesh_name, model_part)
+
+            # extract interface mesh information
+            numNodes = [];          numElems = []
+            nodeCoors = [];         nodeIDs = []
+            numNodesPerElem = [];   elemTable = []
+            self._get_mesh(model_part, numNodes, numElems, nodeCoors, nodeIDs, numNodesPerElem, elemTable)
+
+            # convert python lists to ctypes, required for empire-function call
+            c_numNodes = (ctp.c_int * len(numNodes))(*numNodes)
+            c_numElems = (ctp.c_int * len(numElems))(*numElems)
+            c_nodeCoors = (ctp.c_double * len(nodeCoors))(*nodeCoors)
+            c_nodeIDs = (ctp.c_int * len(nodeIDs))(*nodeIDs)
+            c_numNodesPerElem = (ctp.c_int * len(numNodesPerElem))(*numNodesPerElem)
+            c_elemTable = (ctp.c_int * len(elemTable))(*elemTable)
+
+            if self.echo_level > 0:
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Attempting to send mesh "' + mesh_name + '"')
+            if not self.dry_run:
+                self.libempire_api.EMPIRE_API_sendMesh("mesh_name.encode()",
+                                                       c_numNodes[0], c_numElems[0],
+                                                       c_nodeCoors, c_nodeIDs,
+                                                       c_numNodesPerElem, c_elemTable)
+            if self.echo_level > 0:
+                if self.dry_run:
+                    KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Sucessfully sent mesh')
+        # -------------------------------------------------------------------------------------------------
+
+        # -------------------------------------------------------------------------------------------------
+        def ReceiveMesh(self, mesh_name, model_part):
+            ''' Recieve mesh from the server
+            \param[in] name name of the mesh
+            \param[in] numNodes number of nodes
+            \param[in] numElems number of elements
+            \param[in] nodes coordinates of all nodes
+            \param[in] nodeIDs IDs of all nodes
+            \param[in] numNodesPerElem number of nodes per element
+            \param[in] elems connectivity table of all elements
+
+            void EMPIRE_API_recvMesh(char *name, int *numNodes, int *numElems, double **nodes, int **nodeIDs,
+                    int **numNodesPerElem, int **elem); '''
+            # mesh_name: name of mesh in the emperor input
+
+            # Save the ModelPart for data-field exchange later
+            self._save_model_part(mesh_name, model_part)
+
+            c_numNodes = ctp.pointer(ctp.c_int(0))
+            c_numElems = ctp.pointer(ctp.c_int(0))
+            c_nodeCoors = ctp.pointer(ctp.pointer(ctp.c_double(0)))
+            c_nodeIDs = ctp.pointer(ctp.pointer(ctp.c_int(0)))
+            c_numNodesPerElem = ctp.pointer(ctp.pointer(ctp.c_int(0)))
+            c_elemTable = ctp.pointer(ctp.pointer(ctp.c_int(0)))
+
+            if self.echo_level > 0:
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Attempting to receive mesh "' + mesh_name + '"')
+            if not self.dry_run:
+                self.libempire_api.EMPIRE_API_recvMesh(mesh_name.encode(),
+                                                       c_numNodes, c_numElems,
+                                                       c_nodeCoors, c_nodeIDs,
+                                                       c_numNodesPerElem, c_elemTable)
+            if self.echo_level > 0:
+                if self.dry_run:
+                    KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Sucessfully received mesh')
+
+            numNodes = c_numNodes.contents.value
+            numElems = c_numElems.contents.value
+            nodeCoors = c_nodeCoors.contents
+            nodeIDs = c_nodeIDs.contents
+            numNodesPerElem = c_numNodesPerElem.contents
+            elemTable = c_elemTable.contents
+
+            self._set_mesh(model_part, numNodes, numElems, nodeCoors, nodeIDs, numNodesPerElem, elemTable)
+        # -------------------------------------------------------------------------------------------------
+
+        # -------------------------------------------------------------------------------------------------
+        def SendDataField(self, mesh_name, data_field_name, kratos_variables):
+            ''' Send data field to the server
+            \param[in] name name of the field
+            \param[in] sizeOfArray size of the array (data field)
+            \param[in] dataField the data field to be sent
+
+            void EMPIRE_API_sendDataField(char *name, int sizeOfArray, double *dataField); '''
+            # mesh_name: name of mesh in the emperor input
+            # data_field_name: name of dataField in the emperor input
+
+            # get ModelPart
+            model_part = self.model_parts[mesh_name]
+
+            if not type(kratos_variables) == list:
+                kratos_variables = [kratos_variables]
+
+            # extract data field from nodes
+            data_field = self._get_data_field(model_part, kratos_variables)
+
+            # convert list containg the data field to ctypes
+            c_data_field = (ctp.c_double * len(data_field))(*data_field)
+            c_size = len(c_data_field)
+
+            if self.echo_level > 1:
+                info_msg  = 'Attempting to send data-field "' + data_field_name
+                info_msg += '" for mesh "' + mesh_name + '"\n                '
+                info_msg += 'With Kratos-Vars: ' + ", ".join([var.Name() for var in kratos_variables])
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', info_msg)
+            if not self.dry_run:
+                self.libempire_api.EMPIRE_API_sendDataField("data_field_name.encode()", c_size, c_data_field)
+            if self.echo_level > 1:
+                if self.dry_run:
+                    KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Successfully sent data-field')
+        # -------------------------------------------------------------------------------------------------
+
+        # -------------------------------------------------------------------------------------------------
+        def ReceiveDataField(self, mesh_name, data_field_name, kratos_variables):
+            ''' Receive data field from the server
+            \param[in] name name of the field
+            \param[in] sizeOfArray size of the array (data field)
+            \param[out] dataField the data field to be received
+
+            void EMPIRE_API_recvDataField(char *name, int sizeOfArray, double *dataField); '''
+            # mesh_name: name of mesh in the emperor input
+            # data_field_name: name of dataField in the emperor input
+
+            # get ModelPart
+            model_part = self.model_parts[mesh_name]
+
+            if not type(kratos_variables) == list:
+                kratos_variables = [kratos_variables]
+
+            # Determine Sizes of Variables
+            sizes_of_variables = self._sizes_of_variables(model_part, kratos_variables)
+            self._check_size_of_variables(sizes_of_variables)
+
+            # initialize vector storing the values
+            size_data_field = model_part.NumberOfNodes() * sum(sizes_of_variables)
+            c_size_data_field = ctp.c_int(size_data_field)
+            c_data_field = (ctp.c_double * size_data_field)(0)
+
+            if self.echo_level > 1:
+                info_msg  = 'Attempting to receive data-field "' + data_field_name
+                info_msg += '" for mesh "' + mesh_name + '"\n                '
+                info_msg += 'With Kratos-Vars: ' + ", ".join([var.Name() for var in kratos_variables])
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', info_msg)
+            if not self.dry_run:
+                self.libempire_api.EMPIRE_API_recvDataField(data_field_name.encode(), c_size_data_field, c_data_field)
+            if self.echo_level > 1:
+                if self.dry_run:
+                    KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Successfully received data-field')
+
+            self._set_data_field(model_part, kratos_variables, c_data_field, sizes_of_variables)
+        # -------------------------------------------------------------------------------------------------
+
+        # -------------------------------------------------------------------------------------------------
+        def SendArray(self, array_name, array_to_send):
+            ''' Send signal to the server
+            \param[in] name name of the signal
+            \param[in] sizeOfArray size of the array (signal)
+            \param[in] signal the signal
+
+            void EMPIRE_API_sendSignal_double(char *name, int sizeOfArray, double *signal); '''
+            # array_name: name of signal in the emperor input
+
+            # convert array to ctypes
+            c_signal = (ctp.c_double * len(array_to_send))(*array_to_send)
+            c_size = len(c_signal)
+
+            if self.echo_level > 1:
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Attempting to send array "' + array_name + '"')
+            if not self.dry_run:
+                self.libempire_api.EMPIRE_API_sendSignal_double(array_name.encode(), c_size, c_signal)
+
+            if self.echo_level > 1:
+                if self.dry_run:
+                    KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Successfully sent array')
+        # -------------------------------------------------------------------------------------------------
+
+        # -------------------------------------------------------------------------------------------------
+        def ReceiveArray(self, array_name, array_size):
+            ''' Receive signal from the server
+            \param[in] name name of the signal
+            \param[in] sizeOfArray size of the array (signal)
+            \param[in] signal the signal
+
+            void EMPIRE_API_recvSignal_double(char *name, int sizeOfArray, double *signal); '''
+            # array_name: name of signal in the emperor input
+
+            # initialize vector storing the values
+            c_signal = (ctp.c_double * array_size)(0)
+
+            if self.echo_level > 1:
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Attempting to receive array "' + array_name + '"')
+            if not self.dry_run:
+                self.libempire_api.EMPIRE_API_recvSignal_double(array_name.encode(), array_size, c_signal)
+            if self.echo_level > 1:
+                if self.dry_run:
+                    KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Successfully received array')
+
+            return self._convert_to_list(array_size, c_signal)
+        # -------------------------------------------------------------------------------------------------
+
+        # -------------------------------------------------------------------------------------------------
+        def SendConvergenceSignal(self, signal):
+            ''' Send the convergence signal of an loop
+            \param[in] signal 1 means convergence, 0 means non-convergence
+            void EMPIRE_API_sendConvergenceSignal(int signal); '''
+
+            if self.echo_level > 1:
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Attempting to send convergence-signal')
+            if not self.dry_run:
+                self.libempire_api.EMPIRE_API_sendConvergenceSignal(signal)
+            if self.echo_level > 1:
+                if self.dry_run:
+                    KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Successfully sent convergence-signal')
+        # -------------------------------------------------------------------------------------------------
+
+        # -------------------------------------------------------------------------------------------------
+        def ReceiveConvergenceSignal(self):
+            '''Receive the convergence signal of an loop
+            \return 1 means convergence, 0 means non-convergence
+
+            int EMPIRE_API_recvConvergenceSignal(); '''
+
+            if self.echo_level > 1:
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Attempting to receive convergence-signal')
+            if not self.dry_run:
+                signal = self.libempire_api.EMPIRE_API_recvConvergenceSignal()
+            else:
+                signal = 0
+            if self.echo_level > 1:
+                if self.dry_run:
+                    KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'skipped call to empire!')
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Successfully received convergence-signal')
+            return signal
+        # -------------------------------------------------------------------------------------------------
+
+        ##### Private Functions #####
+        # -------------------------------------------------------------------------------------------------
+        def _load_empire_library(self):
+            if hasattr(self, 'libempire_api'): # the library has been loaded already
+                raise ImportError("The EMPIRE library must be loaded only once!")
+
+            import os
+
+            if "EMPIRE_API_LIBSO_ON_MACHINE" not in os.environ:
+                raise ImportError("The EMPIRE environment is not set!")
+
+            KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Attempting to load empire-api')
+            try: # OpenMPI
+                self.libempire_api = ctp.CDLL(os.environ['EMPIRE_API_LIBSO_ON_MACHINE'], ctp.RTLD_GLOBAL)
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Using standard OpenMPI')
+            except: # Intel MPI or OpenMPI compiled with "–disable-dlopen" option
+                self.libempire_api = ctp.cdll.LoadLibrary(os.environ['EMPIRE_API_LIBSO_ON_MACHINE'])
+                KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Using Intel MPI or OpenMPI compiled with "–disable-dlopen" option')
+            KratosMultiphysics.Logger.PrintInfo('EMPIRE-Wrapper', 'Successfully loaded empire-api')
+        # -------------------------------------------------------------------------------------------------
+
+        # -------------------------------------------------------------------------------------------------
+        def _get_mesh(self, model_part, num_nodes, num_elements, node_coords, node_IDs, num_nodes_per_element, element_table):
+            num_nodes.append(model_part.NumberOfNodes())
+            num_elements.append(model_part.NumberOfElements())
+
+            for node in model_part.Nodes:
+                node_coords.append(node.X)
+                node_coords.append(node.Y)
+                node_coords.append(node.Z)
+                node_IDs.append(node.Id)
+
+            for elem in model_part.Elements:
+                num_nodes_per_element.append(len(elem.GetNodes()))
+                for node in elem.GetNodes():
+                    element_table.append(node.Id)
+        # -------------------------------------------------------------------------------------------------
+
+        # -------------------------------------------------------------------------------------------------
+        def _set_mesh(self, model_part, num_nodes, num_elements, node_coords, node_IDs, num_nodes_per_element, element_table):
+            # This function requires an empty ModelPart
+            # It constructs Nodes and Elements from what was received from EMPIRE
+
+            # Some checks to validate input:
+            if model_part.NumberOfNodes() != 0:
+                raise Exception("ModelPart is not empty, it has some Nodes!")
+            if model_part.NumberOfElements() != 0:
+                raise Exception("ModelPart is not empty, it has some Elements!")
+            if model_part.NumberOfConditions() != 0:
+                raise Exception("ModelPart is not empty, it has some Conditions!")
+
+            # Create Nodes
+            for i in range(num_nodes):
+                model_part.CreateNewNode(node_IDs[i], node_coords[3*i+0], node_coords[3*i+1], node_coords[3*i+2]) # Id, X, Y, Z
+
+            # Create dummy Property for Element
+            prop = model_part.GetProperties()[1]
+
+            element_table_counter = 0
+            # Create Elements
+            for i in range(num_elements):
+                num_nodes_element = num_nodes_per_element[i]
+                if num_nodes_element == 2:
+                    name_element = "Element2D2N"
+                elif num_nodes_element == 3:
+                    name_element = "Element2D3N"
+                elif num_nodes_element == 4:
+                    name_element = "Element2D4N"
+                else:
+                    raise Exception("Wrong number of nodes for creating the element")
+
+                element_nodes = []
+                for j in range(num_nodes_element):
+                    element_nodes.append(int(element_table[element_table_counter]))
+                    element_table_counter += 1
+
+                model_part.CreateNewElement(name_element, i+1, element_nodes, prop)
+        # -------------------------------------------------------------------------------------------------
+
+        # -------------------------------------------------------------------------------------------------
+        def _get_data_field(self, model_part, kratos_variables):
+            for var in kratos_variables:
+                if not model_part.HasNodalSolutionStepVariable(var):
+                    err_msg  = 'ModelPart "' + model_part.Name + '" does not have'
+                    err_msg += ' "' + var.Name() + '" as SolutionStepVariable!'
+                    raise Exception(err_msg)
+
+            sizes_of_variables = self._sizes_of_variables(model_part, kratos_variables)
+            self._check_size_of_variables(sizes_of_variables)
+
+            num_nodes = model_part.NumberOfNodes()
+            sum_sizes = sum(sizes_of_variables)
+
+            data_field = [0.0] * (num_nodes * sum_sizes) # preallocate
+
+            for node_i, node in enumerate(model_part.Nodes):
+                size_index = 0
+                for size_of_variable, variable in zip(sizes_of_variables, kratos_variables):
+                    data_value = node.GetSolutionStepValue(variable)
+
+                    if size_of_variable == 1:
+                        data_field[node_i * sum_sizes + size_index] = data_value
+                        size_index += 1
+                    else:
+                        for k in range(size_of_variable):
+                            data_field[node_i * sum_sizes + size_index] = data_value[k]
+                            size_index += 1
+
+            return data_field
+        # -------------------------------------------------------------------------------------------------
+
+        # -------------------------------------------------------------------------------------------------
+        def _set_data_field(self, model_part, kratos_variables, data_field, size_of_variables):
+            # check if size of data field is correct
+            if len(data_field) != model_part.NumberOfNodes() * sum(size_of_variables):
+                raise Exception("received data field has wrong size!")
+
+            for var in kratos_variables:
+                if not model_part.HasNodalSolutionStepVariable(var):
+                    err_msg  = 'ModelPart "' + model_part.Name + '" does not have'
+                    err_msg += ' "' + var.Name() + '" as SolutionStepVariable!'
+                    raise Exception(err_msg)
+
+            # Preallocate values
+            values = []
+            for size_of_variable in size_of_variables:
+                if size_of_variable > 1:
+                    values.append(KratosMultiphysics.Vector(size_of_variable))
+                else:
+                    values.append(0.0)
+
+            sum_sizes = sum(size_of_variables)
+
+            # assign values to nodes of interface for current time step
+            for node_i, node in enumerate(model_part.Nodes):
+                size_index = 0
+                for size_of_variable, variable, value in zip(size_of_variables, kratos_variables, values):
+                    if size_of_variable == 1:
+                        value = data_field[sum_sizes * node_i + size_index]
+                        size_index += 1
+                    else:
+                        for k in range(size_of_variable):
+                            value[k] = data_field[sum_sizes * node_i + size_index]
+                            size_index += 1
+
+                    node.SetSolutionStepValue(variable, 0, value)
+        # -------------------------------------------------------------------------------------------------
+
+        # -------------------------------------------------------------------------------------------------
+        def _sizes_of_variables(self, model_part, kratos_variables):
+            # this function is very general, even though EMPIRE works with Scalar and Vector quantities only!
+            sizes_of_variables = []
+            first_node = next(iter(model_part.Nodes))
+            for variable in kratos_variables:
+                try:
+                    value = first_node.GetSolutionStepValue(variable)
+                    if (isinstance(value, float) or isinstance(value, int)): # Variable is a scalar
+                        size_of_variable = 1
+                    else:
+                        size_of_variable = len(value)
+                    sizes_of_variables.append(size_of_variable)
+                except StopIteration:
+                    raise TypeError("Size of Variable \"" + variable + "\" could not be determined")
+
+            return sizes_of_variables
+        # -------------------------------------------------------------------------------------------------
+
+        # -------------------------------------------------------------------------------------------------
+        def _save_model_part(self, mesh_name, model_part):
+            # Save the model_part for data-field exchange later
+            if mesh_name in self.model_parts:
+                raise ValueError("Mesh exsts already")
+            else:
+                self.model_parts.update({mesh_name : model_part})
+        # -------------------------------------------------------------------------------------------------
+
+        # -------------------------------------------------------------------------------------------------
+        def _convert_to_list(self, array_size, c_signal):
+            converted_list = [0.0] * array_size # preallocate
+
+            for i in range(array_size):
+                converted_list[i] = c_signal[i]
+
+            return converted_list
+        # -------------------------------------------------------------------------------------------------
+
+        # -------------------------------------------------------------------------------------------------
+        def _check_size_of_variables(self, size_of_variables):
+            sum_sizes = sum(size_of_variables)
+
+            possible_sizes = [ 1,  # Scalar
+                               3,  # Vector
+                               6 ] # doubleVector
+
+            if sum_sizes not in possible_sizes:
+                err_msg =  "Wrong size of variables: " + str(sum_sizes) + " !\n"
+                err_msg += "Curently only Scalar, Vector and doubleVector are supported by Empire!"
+                raise Exception(err_msg)
+        # -------------------------------------------------------------------------------------------------
```

## KratosMultiphysics/CoSimulationApplication/coupling_interface_data.py

 * *Ordering differences only*

```diff
@@ -1,273 +1,273 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-
-# Other imports
-import numpy as np
-
-# STD imports
-import typing
-
-class BaseCouplingInterfaceData:
-    """This class serves as interface to the data structure (Model and ModelPart)
-    that holds the data used during CoSimulation
-    """
-    def __init__(self, custom_settings, name="default", solver_name="default_solver"):
-        custom_settings.ValidateAndAssignDefaults(self.GetDefaultParameters())
-
-        self.settings = custom_settings
-        self.name = name
-        self.solver_name = solver_name
-        self.model_part_name = self.settings["model_part_name"].GetString()
-
-        # checking names
-        if self.name =="" or "." in self.name or " " in self.name:
-            self._RaiseException('The name cannot be empty, contain whitespaces or "."!')
-        if self.model_part_name == "":
-            self._RaiseException('No "model_part_name" was specified!')
-
-        # variable used to identify data
-        variable_name = self.settings["variable_name"].GetString()
-        if variable_name == "":
-            self._RaiseException('No "variable_name" was specified!')
-        if not KM.KratosGlobals.HasVariable(variable_name):
-            # TODO here maybe we could construct a new var if necessary (maybe clashes with delayed app-import ...?)
-            self._RaiseException('Variable "{}" does not exist!'.format(variable_name))
-
-        self.variable_type = KM.KratosGlobals.GetVariableType(variable_name)
-
-        admissible_scalar_variable_types = ["Bool", "Integer", "Unsigned Integer", "Double"]
-        admissible_vector_variable_types = ["Array"]
-
-        if not self.variable_type in admissible_scalar_variable_types and not self.variable_type in admissible_vector_variable_types:
-            self._RaiseException('The input for "variable" "{}" is of variable type "{}" which is not allowed, only the following variable types are allowed:\n{}, {}'.format(variable_name, self.variable_type, ", ".join(admissible_scalar_variable_types), ", ".join(admissible_vector_variable_types)))
-
-        self.variable = KM.KratosGlobals.GetVariable(variable_name)
-
-        self.dtype = GetNumpyDataType(self.variable_type) # required for numpy array creation
-
-        self.is_scalar_variable = self.variable_type in admissible_scalar_variable_types
-
-        # location of data on ModelPart
-        self.location = self.settings["location"].GetString()
-        admissible_locations = ["node_historical", "node_non_historical", "element", "condition", "model_part"]
-        if not self.location in admissible_locations:
-            self._RaiseException('"{}" is not allowed as "location", only the following options are possible:\n{}'.format(self.location, ", ".join(admissible_locations)))
-
-        # dimensionality of the data
-        self.dimension = self.settings["dimension"].GetInt()
-
-    @staticmethod
-    def GetDefaultParameters():
-        return KM.Parameters("""{
-            "model_part_name" : "",
-            "variable_name"   : "",
-            "location"        : "node_historical",
-            "dimension"       : -1,
-            "additional_info" : { }
-        }""")
-
-    def IsDefinedOnThisRank(self):
-        return False
-
-    def _RaiseException(self, err_msg):
-        raise Exception('CouplingInterfaceData "{}" for ModelPart "{}" of SolverWrapper "{}":\n{}'.format(self.name, self.model_part_name, self.solver_name, err_msg))
-
-
-class CouplingInterfaceData(BaseCouplingInterfaceData):
-    """This class serves as interface to the data structure (Model and ModelPart)
-    that holds the data used during CoSimulation
-    """
-    def __init__(self, custom_settings, model, name="default", solver_name="default_solver"):
-        super().__init__(custom_settings, name, solver_name)
-
-        self.model = model
-        self.model_part = self.model[self.model_part_name]
-
-        # dimensionality of the data
-        if self.is_scalar_variable:
-            if self.dimension != -1:
-                self._RaiseException('"dimension" cannot be specifed for scalar variables!')
-            self.dimension = 1 # needed in other places, e.g. for "Size"
-        else:
-            if self.dimension < 1:
-                self._RaiseException('"dimension" has to be specifed for vector variables!')
-            else:
-                if self.variable_type == "Array" and self.dimension not in [1,2,3]:
-                    self._RaiseException('"dimension" can only be 1,2,3 when using variables of type "Array"')
-                if not KM.DOMAIN_SIZE in self.model_part.ProcessInfo:
-                    cs_tools.cs_print_warning('CouplingInterfaceData', 'No "DOMAIN_SIZE" was specified for ModelPart "{}"'.format(self.model_part_name))
-                else:
-                    domain_size = self.model_part.ProcessInfo[KM.DOMAIN_SIZE]
-                    if domain_size != self.dimension:
-                        cs_tools.cs_print_warning('CouplingInterfaceData', '"DOMAIN_SIZE" ({}) of ModelPart "{}" does not match dimension ({})'.format(domain_size, self.model_part_name, self.dimension))
-
-        if self.location == "node_historical" and not self.model_part.HasNodalSolutionStepVariable(self.variable):
-            self._RaiseException('"{}" is missing as SolutionStepVariable in ModelPart "{}"'.format(self.variable.Name(), self.model_part_name))
-
-    def __str__(self):
-        self_str =  'CouplingInterfaceData:\n'
-        self_str += '\tName: "{}"\n'.format(self.name)
-        self_str += '\tSolverWrapper: "{}"\n'.format(self.solver_name)
-        self_str += '\tModelPart: "{}"\n'.format(self.model_part_name)
-        self_str += '\tIsDistributed: {}\n'.format(self.IsDistributed())
-        self_str += '\tVariable: "{}"'.format(self.variable.Name())
-        if self.is_scalar_variable:
-            self_str += ' (Scalar)'
-        else:
-            self_str += ' (Vector with dimension: {})'.format(self.dimension)
-        self_str += '\n\tLocation: "{}"\n'.format(self.location)
-        self_str += '\tSize: {}\n'.format(self.Size())
-
-        return self_str
-
-    def PrintInfo(self):
-        print(self)
-
-    def GetModelPart(self):
-        return self.model_part
-
-    def IsDistributed(self):
-        return self.GetModelPart().IsDistributed()
-
-    def IsDefinedOnThisRank(self):
-        return self.GetModelPart().GetCommunicator().GetDataCommunicator().IsDefinedOnThisRank()
-
-    def Size(self):
-        if self.location == "model_part":
-            return 1 * self.dimension
-        else:
-            return len(self.__GetDataContainer()) * self.dimension
-
-    def GetBufferSize(self):
-        # only historical nodal data can store multiple steps!
-        if self.location == "node_historical":
-            return self.GetModelPart().GetBufferSize()
-        else:
-            return 1
-
-    def GetHistoricalVariableDict(self):
-        # this method returns the historical variable associated to a ModelPart
-        # it is intended to be used before the Mesh is read such that the historical variables
-        # can be allocated beforehand. This is the reason why the name of the ModelPart is
-        # retrieved from the settings and not from the ModelPart itself.
-        if self.location == "node_historical":
-            return {self.model_part_name : self.variable}
-        else:
-            return {}
-
-    def GetData(self, solution_step_index=0) -> "np.ndarray[typing.Union[bool,np.intc,np.uintc,np.double]]":
-        self.__CheckBufferSize(solution_step_index)
-
-        if self.location == "node_historical":
-            data = self.__GetDataFromContainer(self.__GetDataContainer(), GetSolutionStepValue, solution_step_index)
-        elif self.location in ["node_non_historical", "element", "condition"]:
-            data = self.__GetDataFromContainer(self.__GetDataContainer(), GetValue)
-        elif self.location == "model_part":
-            var_val = self.GetModelPart()[self.variable]
-            if self.is_scalar_variable:
-                data = [var_val]
-            else:
-                data = [var_val[i] for i in range(self.dimension)]
-
-        return np.asarray(data, dtype=self.dtype)
-
-    def SetData(self, new_data, solution_step_index=0):
-        self.__CheckBufferSize(solution_step_index)
-
-        # checking size of data
-        if len(new_data) != self.Size():
-            self._RaiseException("The sizes of the data are not matching, got: {}, expected: {}".format(len(new_data), self.Size()))
-
-        if self.location == "node_historical":
-            self.__SetDataOnContainer(self.__GetDataContainer(), SetSolutionStepValue, new_data, solution_step_index)
-        elif self.location in ["node_non_historical", "element", "condition"]:
-            self.__SetDataOnContainer(self.__GetDataContainer(), SetValue, new_data)
-        elif self.location == "model_part":
-            if self.is_scalar_variable:
-                self.GetModelPart()[self.variable] = new_data[0]
-            else:
-                if self.variable_type == "Array":
-                    vec_value = [0.0, 0.0, 0.0] # Array values require three entries
-                    vec_value[:self.dimension] = new_data[:self.dimension] # apply "padding"
-                    self.GetModelPart()[self.variable] = vec_value
-                else:
-                    self.GetModelPart()[self.variable] = new_data
-
-        if self.location == "node_historical":
-            self.GetModelPart().GetCommunicator().SynchronizeVariable(self.variable)
-        elif self.location in "node_non_historical":
-            self.GetModelPart().GetCommunicator().SynchronizeNonHistoricalVariable(self.variable)
-
-    def __GetDataFromContainer(self, container, fct_ptr, *args):
-        if self.is_scalar_variable:
-            return [fct_ptr(entity, self.variable, *args) for entity in container]
-        else:
-            data = []
-            for entity in container:
-                vals = fct_ptr(entity, self.variable, *args)
-                for i in range(self.dimension):
-                    data.append(vals[i])
-            return data
-
-    def __SetDataOnContainer(self, container, fct_ptr, data, *args):
-        if self.is_scalar_variable:
-            [fct_ptr(entity, self.variable, *args, value) for entity, value in zip(container, data)]
-        else:
-            if self.variable_type == "Array":
-                vec_value = [0.0, 0.0, 0.0] # Array values require three entries
-                for i_entity, entity in enumerate(container):
-                    slice_start = i_entity*self.dimension
-                    slice_end = slice_start + self.dimension
-                    vec_value[:self.dimension] = data[slice_start:slice_end] # apply "padding"
-                    fct_ptr(entity, self.variable, *args, vec_value)
-            else:
-                for i_entity, entity in enumerate(container):
-                    slice_start = i_entity*self.dimension
-                    slice_end = slice_start + self.dimension
-                    fct_ptr(entity, self.variable, *args, data[slice_start:slice_end])
-
-    def __GetDataContainer(self):
-        if self.location == "node_historical":
-            return self.GetModelPart().GetCommunicator().LocalMesh().Nodes
-        elif self.location == "node_non_historical":
-            return self.GetModelPart().GetCommunicator().LocalMesh().Nodes
-        elif self.location == "element":
-            return self.GetModelPart().GetCommunicator().LocalMesh().Elements
-        elif self.location == "condition":
-            return self.GetModelPart().GetCommunicator().LocalMesh().Conditions
-
-    def __CheckBufferSize(self, solution_step_index):
-        if solution_step_index+1 > self.GetBufferSize():
-            if self.location == "node_historical":
-                self._RaiseException("The buffer-size is not large enough current buffer size: {} | requested solution_step_index: {}!".format(self.GetBufferSize(), solution_step_index+1))
-            else:
-                self._RaiseException("accessing data from previous steps is only possible with historical nodal data!")
-
-
-def GetValue(entity, variable):
-    return entity.GetValue(variable)
-
-def GetSolutionStepValue(entity, variable, solution_step_index):
-    return entity.GetSolutionStepValue(variable, solution_step_index)
-
-def SetValue(entity, variable, value):
-    return entity.SetValue(variable, value)
-
-def SetSolutionStepValue(entity, variable, solution_step_index, value):
-    return entity.SetSolutionStepValue(variable, solution_step_index, value)
-
-def GetNumpyDataType(variable_type):
-    # https://docs.scipy.org/doc/numpy/user/basics.types.html
-    dtype_map = {
-        "Bool" : bool,
-        "Integer" : np.intc,
-        "Unsigned Integer" : np.uintc,
-        "Double" : np.double,
-        "Component" : np.double,
-        "Array" : np.double,
-    }
-
-    return dtype_map[variable_type]
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+
+# Other imports
+import numpy as np
+
+# STD imports
+import typing
+
+class BaseCouplingInterfaceData:
+    """This class serves as interface to the data structure (Model and ModelPart)
+    that holds the data used during CoSimulation
+    """
+    def __init__(self, custom_settings, name="default", solver_name="default_solver"):
+        custom_settings.ValidateAndAssignDefaults(self.GetDefaultParameters())
+
+        self.settings = custom_settings
+        self.name = name
+        self.solver_name = solver_name
+        self.model_part_name = self.settings["model_part_name"].GetString()
+
+        # checking names
+        if self.name =="" or "." in self.name or " " in self.name:
+            self._RaiseException('The name cannot be empty, contain whitespaces or "."!')
+        if self.model_part_name == "":
+            self._RaiseException('No "model_part_name" was specified!')
+
+        # variable used to identify data
+        variable_name = self.settings["variable_name"].GetString()
+        if variable_name == "":
+            self._RaiseException('No "variable_name" was specified!')
+        if not KM.KratosGlobals.HasVariable(variable_name):
+            # TODO here maybe we could construct a new var if necessary (maybe clashes with delayed app-import ...?)
+            self._RaiseException('Variable "{}" does not exist!'.format(variable_name))
+
+        self.variable_type = KM.KratosGlobals.GetVariableType(variable_name)
+
+        admissible_scalar_variable_types = ["Bool", "Integer", "Unsigned Integer", "Double"]
+        admissible_vector_variable_types = ["Array"]
+
+        if not self.variable_type in admissible_scalar_variable_types and not self.variable_type in admissible_vector_variable_types:
+            self._RaiseException('The input for "variable" "{}" is of variable type "{}" which is not allowed, only the following variable types are allowed:\n{}, {}'.format(variable_name, self.variable_type, ", ".join(admissible_scalar_variable_types), ", ".join(admissible_vector_variable_types)))
+
+        self.variable = KM.KratosGlobals.GetVariable(variable_name)
+
+        self.dtype = GetNumpyDataType(self.variable_type) # required for numpy array creation
+
+        self.is_scalar_variable = self.variable_type in admissible_scalar_variable_types
+
+        # location of data on ModelPart
+        self.location = self.settings["location"].GetString()
+        admissible_locations = ["node_historical", "node_non_historical", "element", "condition", "model_part"]
+        if not self.location in admissible_locations:
+            self._RaiseException('"{}" is not allowed as "location", only the following options are possible:\n{}'.format(self.location, ", ".join(admissible_locations)))
+
+        # dimensionality of the data
+        self.dimension = self.settings["dimension"].GetInt()
+
+    @staticmethod
+    def GetDefaultParameters():
+        return KM.Parameters("""{
+            "model_part_name" : "",
+            "variable_name"   : "",
+            "location"        : "node_historical",
+            "dimension"       : -1,
+            "additional_info" : { }
+        }""")
+
+    def IsDefinedOnThisRank(self):
+        return False
+
+    def _RaiseException(self, err_msg):
+        raise Exception('CouplingInterfaceData "{}" for ModelPart "{}" of SolverWrapper "{}":\n{}'.format(self.name, self.model_part_name, self.solver_name, err_msg))
+
+
+class CouplingInterfaceData(BaseCouplingInterfaceData):
+    """This class serves as interface to the data structure (Model and ModelPart)
+    that holds the data used during CoSimulation
+    """
+    def __init__(self, custom_settings, model, name="default", solver_name="default_solver"):
+        super().__init__(custom_settings, name, solver_name)
+
+        self.model = model
+        self.model_part = self.model[self.model_part_name]
+
+        # dimensionality of the data
+        if self.is_scalar_variable:
+            if self.dimension != -1:
+                self._RaiseException('"dimension" cannot be specifed for scalar variables!')
+            self.dimension = 1 # needed in other places, e.g. for "Size"
+        else:
+            if self.dimension < 1:
+                self._RaiseException('"dimension" has to be specifed for vector variables!')
+            else:
+                if self.variable_type == "Array" and self.dimension not in [1,2,3]:
+                    self._RaiseException('"dimension" can only be 1,2,3 when using variables of type "Array"')
+                if not KM.DOMAIN_SIZE in self.model_part.ProcessInfo:
+                    cs_tools.cs_print_warning('CouplingInterfaceData', 'No "DOMAIN_SIZE" was specified for ModelPart "{}"'.format(self.model_part_name))
+                else:
+                    domain_size = self.model_part.ProcessInfo[KM.DOMAIN_SIZE]
+                    if domain_size != self.dimension:
+                        cs_tools.cs_print_warning('CouplingInterfaceData', '"DOMAIN_SIZE" ({}) of ModelPart "{}" does not match dimension ({})'.format(domain_size, self.model_part_name, self.dimension))
+
+        if self.location == "node_historical" and not self.model_part.HasNodalSolutionStepVariable(self.variable):
+            self._RaiseException('"{}" is missing as SolutionStepVariable in ModelPart "{}"'.format(self.variable.Name(), self.model_part_name))
+
+    def __str__(self):
+        self_str =  'CouplingInterfaceData:\n'
+        self_str += '\tName: "{}"\n'.format(self.name)
+        self_str += '\tSolverWrapper: "{}"\n'.format(self.solver_name)
+        self_str += '\tModelPart: "{}"\n'.format(self.model_part_name)
+        self_str += '\tIsDistributed: {}\n'.format(self.IsDistributed())
+        self_str += '\tVariable: "{}"'.format(self.variable.Name())
+        if self.is_scalar_variable:
+            self_str += ' (Scalar)'
+        else:
+            self_str += ' (Vector with dimension: {})'.format(self.dimension)
+        self_str += '\n\tLocation: "{}"\n'.format(self.location)
+        self_str += '\tSize: {}\n'.format(self.Size())
+
+        return self_str
+
+    def PrintInfo(self):
+        print(self)
+
+    def GetModelPart(self):
+        return self.model_part
+
+    def IsDistributed(self):
+        return self.GetModelPart().IsDistributed()
+
+    def IsDefinedOnThisRank(self):
+        return self.GetModelPart().GetCommunicator().GetDataCommunicator().IsDefinedOnThisRank()
+
+    def Size(self):
+        if self.location == "model_part":
+            return 1 * self.dimension
+        else:
+            return len(self.__GetDataContainer()) * self.dimension
+
+    def GetBufferSize(self):
+        # only historical nodal data can store multiple steps!
+        if self.location == "node_historical":
+            return self.GetModelPart().GetBufferSize()
+        else:
+            return 1
+
+    def GetHistoricalVariableDict(self):
+        # this method returns the historical variable associated to a ModelPart
+        # it is intended to be used before the Mesh is read such that the historical variables
+        # can be allocated beforehand. This is the reason why the name of the ModelPart is
+        # retrieved from the settings and not from the ModelPart itself.
+        if self.location == "node_historical":
+            return {self.model_part_name : self.variable}
+        else:
+            return {}
+
+    def GetData(self, solution_step_index=0) -> "np.ndarray[typing.Union[bool,np.intc,np.uintc,np.double]]":
+        self.__CheckBufferSize(solution_step_index)
+
+        if self.location == "node_historical":
+            data = self.__GetDataFromContainer(self.__GetDataContainer(), GetSolutionStepValue, solution_step_index)
+        elif self.location in ["node_non_historical", "element", "condition"]:
+            data = self.__GetDataFromContainer(self.__GetDataContainer(), GetValue)
+        elif self.location == "model_part":
+            var_val = self.GetModelPart()[self.variable]
+            if self.is_scalar_variable:
+                data = [var_val]
+            else:
+                data = [var_val[i] for i in range(self.dimension)]
+
+        return np.asarray(data, dtype=self.dtype)
+
+    def SetData(self, new_data, solution_step_index=0):
+        self.__CheckBufferSize(solution_step_index)
+
+        # checking size of data
+        if len(new_data) != self.Size():
+            self._RaiseException("The sizes of the data are not matching, got: {}, expected: {}".format(len(new_data), self.Size()))
+
+        if self.location == "node_historical":
+            self.__SetDataOnContainer(self.__GetDataContainer(), SetSolutionStepValue, new_data, solution_step_index)
+        elif self.location in ["node_non_historical", "element", "condition"]:
+            self.__SetDataOnContainer(self.__GetDataContainer(), SetValue, new_data)
+        elif self.location == "model_part":
+            if self.is_scalar_variable:
+                self.GetModelPart()[self.variable] = new_data[0]
+            else:
+                if self.variable_type == "Array":
+                    vec_value = [0.0, 0.0, 0.0] # Array values require three entries
+                    vec_value[:self.dimension] = new_data[:self.dimension] # apply "padding"
+                    self.GetModelPart()[self.variable] = vec_value
+                else:
+                    self.GetModelPart()[self.variable] = new_data
+
+        if self.location == "node_historical":
+            self.GetModelPart().GetCommunicator().SynchronizeVariable(self.variable)
+        elif self.location in "node_non_historical":
+            self.GetModelPart().GetCommunicator().SynchronizeNonHistoricalVariable(self.variable)
+
+    def __GetDataFromContainer(self, container, fct_ptr, *args):
+        if self.is_scalar_variable:
+            return [fct_ptr(entity, self.variable, *args) for entity in container]
+        else:
+            data = []
+            for entity in container:
+                vals = fct_ptr(entity, self.variable, *args)
+                for i in range(self.dimension):
+                    data.append(vals[i])
+            return data
+
+    def __SetDataOnContainer(self, container, fct_ptr, data, *args):
+        if self.is_scalar_variable:
+            [fct_ptr(entity, self.variable, *args, value) for entity, value in zip(container, data)]
+        else:
+            if self.variable_type == "Array":
+                vec_value = [0.0, 0.0, 0.0] # Array values require three entries
+                for i_entity, entity in enumerate(container):
+                    slice_start = i_entity*self.dimension
+                    slice_end = slice_start + self.dimension
+                    vec_value[:self.dimension] = data[slice_start:slice_end] # apply "padding"
+                    fct_ptr(entity, self.variable, *args, vec_value)
+            else:
+                for i_entity, entity in enumerate(container):
+                    slice_start = i_entity*self.dimension
+                    slice_end = slice_start + self.dimension
+                    fct_ptr(entity, self.variable, *args, data[slice_start:slice_end])
+
+    def __GetDataContainer(self):
+        if self.location == "node_historical":
+            return self.GetModelPart().GetCommunicator().LocalMesh().Nodes
+        elif self.location == "node_non_historical":
+            return self.GetModelPart().GetCommunicator().LocalMesh().Nodes
+        elif self.location == "element":
+            return self.GetModelPart().GetCommunicator().LocalMesh().Elements
+        elif self.location == "condition":
+            return self.GetModelPart().GetCommunicator().LocalMesh().Conditions
+
+    def __CheckBufferSize(self, solution_step_index):
+        if solution_step_index+1 > self.GetBufferSize():
+            if self.location == "node_historical":
+                self._RaiseException("The buffer-size is not large enough current buffer size: {} | requested solution_step_index: {}!".format(self.GetBufferSize(), solution_step_index+1))
+            else:
+                self._RaiseException("accessing data from previous steps is only possible with historical nodal data!")
+
+
+def GetValue(entity, variable):
+    return entity.GetValue(variable)
+
+def GetSolutionStepValue(entity, variable, solution_step_index):
+    return entity.GetSolutionStepValue(variable, solution_step_index)
+
+def SetValue(entity, variable, value):
+    return entity.SetValue(variable, value)
+
+def SetSolutionStepValue(entity, variable, solution_step_index, value):
+    return entity.SetSolutionStepValue(variable, solution_step_index, value)
+
+def GetNumpyDataType(variable_type):
+    # https://docs.scipy.org/doc/numpy/user/basics.types.html
+    dtype_map = {
+        "Bool" : bool,
+        "Integer" : np.intc,
+        "Unsigned Integer" : np.uintc,
+        "Double" : np.double,
+        "Component" : np.double,
+        "Array" : np.double,
+    }
+
+    return dtype_map[variable_type]
```

## KratosMultiphysics/CoSimulationApplication/fluid_dynamics_analysis_with_co_sim_io.py

 * *Ordering differences only*

```diff
@@ -1,22 +1,22 @@
-import KratosMultiphysics as KM
-from KratosMultiphysics.CoSimulationApplication.analysis_stage_with_co_sim_io import CreateAnalysisStageWithCoSimIO
-from KratosMultiphysics.FluidDynamicsApplication.fluid_dynamics_analysis import FluidDynamicsAnalysis
-
-from sys import argv
-
-FluidDynamicsAnalysisWithCoSimIO = CreateAnalysisStageWithCoSimIO(FluidDynamicsAnalysis)
-
-if __name__ == '__main__':
-    if len(argv) != 2:
-        err_msg  = 'Wrong number of input arguments!\n'
-        err_msg += 'Use this script in the following way:\n'
-        err_msg += '    "python fluid_dynamics_analysis_with_co_sim_io.py <project-parameter-file>.json"\n'
-        raise Exception(err_msg)
-
-    parameter_file_name = argv[1]
-
-    with open(parameter_file_name,'r') as parameter_file:
-        parameters = KM.Parameters(parameter_file.read())
-
-    model = KM.Model()
-    FluidDynamicsAnalysisWithCoSimIO(model, parameters).Run()
+import KratosMultiphysics as KM
+from KratosMultiphysics.CoSimulationApplication.analysis_stage_with_co_sim_io import CreateAnalysisStageWithCoSimIO
+from KratosMultiphysics.FluidDynamicsApplication.fluid_dynamics_analysis import FluidDynamicsAnalysis
+
+from sys import argv
+
+FluidDynamicsAnalysisWithCoSimIO = CreateAnalysisStageWithCoSimIO(FluidDynamicsAnalysis)
+
+if __name__ == '__main__':
+    if len(argv) != 2:
+        err_msg  = 'Wrong number of input arguments!\n'
+        err_msg += 'Use this script in the following way:\n'
+        err_msg += '    "python fluid_dynamics_analysis_with_co_sim_io.py <project-parameter-file>.json"\n'
+        raise Exception(err_msg)
+
+    parameter_file_name = argv[1]
+
+    with open(parameter_file_name,'r') as parameter_file:
+        parameters = KM.Parameters(parameter_file.read())
+
+    model = KM.Model()
+    FluidDynamicsAnalysisWithCoSimIO(model, parameters).Run()
```

## KratosMultiphysics/CoSimulationApplication/helpers/dummy_solver_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,39 +1,39 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
-
-# Other imports
-from KratosMultiphysics.CoSimulationApplication.utilities import model_part_utilities
-
-def Create(settings, model, solver_name):
-    return DummySolverWrapper(settings, model, solver_name)
-
-class DummySolverWrapper(CoSimulationSolverWrapper):
-    """This class serves as dummy for testing, it does not solve anything
-    It only imports a mesh that can be used in the testing workflow
-
-    Note that this is only an example, other configurations are of course also possible
-    """
-    def __init__(self, settings, model, solver_name):
-        super().__init__(settings, model, solver_name)
-
-        self.time_step = self.settings["solver_wrapper_settings"]["time_step"].GetDouble()
-        self.model_part = self.model.CreateModelPart(self.settings["solver_wrapper_settings"]["main_model_part_name"].GetString())
-
-        self.model_part.ProcessInfo[KM.DOMAIN_SIZE] = self.settings["solver_wrapper_settings"]["domain_size"].GetInt()
-
-        model_part_utilities.AllocateHistoricalVariablesFromCouplingDataSettings(self.settings["data"], self.model, self.name)
-
-    def Initialize(self):
-        severity = KM.Logger.GetDefaultOutput().GetSeverity()
-        KM.Logger.GetDefaultOutput().SetSeverity(KM.Logger.Severity.WARNING) # mute MP-IO
-        model_part_io = KM.ModelPartIO(self.settings["solver_wrapper_settings"]["mdpa_file_name"].GetString())
-        model_part_io.ReadModelPart(self.model_part)
-        KM.Logger.GetDefaultOutput().SetSeverity(severity)
-
-        super().Initialize()
-
-    def AdvanceInTime(self, current_time):
-        return current_time + self.time_step
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
+
+# Other imports
+from KratosMultiphysics.CoSimulationApplication.utilities import model_part_utilities
+
+def Create(settings, model, solver_name):
+    return DummySolverWrapper(settings, model, solver_name)
+
+class DummySolverWrapper(CoSimulationSolverWrapper):
+    """This class serves as dummy for testing, it does not solve anything
+    It only imports a mesh that can be used in the testing workflow
+
+    Note that this is only an example, other configurations are of course also possible
+    """
+    def __init__(self, settings, model, solver_name):
+        super().__init__(settings, model, solver_name)
+
+        self.time_step = self.settings["solver_wrapper_settings"]["time_step"].GetDouble()
+        self.model_part = self.model.CreateModelPart(self.settings["solver_wrapper_settings"]["main_model_part_name"].GetString())
+
+        self.model_part.ProcessInfo[KM.DOMAIN_SIZE] = self.settings["solver_wrapper_settings"]["domain_size"].GetInt()
+
+        model_part_utilities.AllocateHistoricalVariablesFromCouplingDataSettings(self.settings["data"], self.model, self.name)
+
+    def Initialize(self):
+        severity = KM.Logger.GetDefaultOutput().GetSeverity()
+        KM.Logger.GetDefaultOutput().SetSeverity(KM.Logger.Severity.WARNING) # mute MP-IO
+        model_part_io = KM.ModelPartIO(self.settings["solver_wrapper_settings"]["mdpa_file_name"].GetString())
+        model_part_io.ReadModelPart(self.model_part)
+        KM.Logger.GetDefaultOutput().SetSeverity(severity)
+
+        super().Initialize()
+
+    def AdvanceInTime(self, current_time):
+        return current_time + self.time_step
```

## KratosMultiphysics/CoSimulationApplication/utilities/data_communicator_utilities.py

 * *Ordering differences only*

```diff
@@ -1,40 +1,40 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-if KM.IsDistributedRun():
-    from KratosMultiphysics.mpi import DataCommunicatorFactory
-
-def GetRankZeroDataCommunicator():
-    """In distributed runs, the "Serial" data communicator is defined on all ranks, hence it cannot be used, and we need to create another one that is only defined on rank zero to be used in solvers that do not support MPI
-    """
-    if KM.IsDistributedRun():
-        data_comm_name = "co_simulation_data_comm_rank_zero"
-    else:
-        data_comm_name = "Serial"
-
-    return KM.ParallelEnvironment.GetDataCommunicator(data_comm_name)
-
-def CreateDataCommunicatorWithNProcesses(settings):
-    if not KM.IsDistributedRun():
-        raise Exception("This function can only be used when running with MPI!")
-
-    defaults = KM.Parameters("""{
-        "num_processes" : 0,
-        "data_communicator_name" : ""
-    }""")
-
-    settings.ValidateAndAssignDefaults(defaults)
-
-    num_processes = settings["num_processes"].GetInt()
-    name = settings["data_communicator_name"].GetString()
-
-    world_data_comm = KM.ParallelEnvironment.GetDataCommunicator("World")
-
-    if num_processes < 1:
-        raise Exception('Input for "num_processes" ({}) must be > 0!'.format(num_processes))
-    if num_processes > world_data_comm.Size():
-        raise Exception('Input for "num_processes" ({}) cannot be larger than the number of MPI processes ({})!'.format(num_processes, world_data_comm.Size()))
-    if name == "":
-        raise Exception('Input for "name" cannot be empty!')
-
-    ranks = list(range(num_processes)) # [ 0 ... num_processes-1 ]
-    return DataCommunicatorFactory.CreateFromRanksAndRegister(world_data_comm, ranks, name)
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+if KM.IsDistributedRun():
+    from KratosMultiphysics.mpi import DataCommunicatorFactory
+
+def GetRankZeroDataCommunicator():
+    """In distributed runs, the "Serial" data communicator is defined on all ranks, hence it cannot be used, and we need to create another one that is only defined on rank zero to be used in solvers that do not support MPI
+    """
+    if KM.IsDistributedRun():
+        data_comm_name = "co_simulation_data_comm_rank_zero"
+    else:
+        data_comm_name = "Serial"
+
+    return KM.ParallelEnvironment.GetDataCommunicator(data_comm_name)
+
+def CreateDataCommunicatorWithNProcesses(settings):
+    if not KM.IsDistributedRun():
+        raise Exception("This function can only be used when running with MPI!")
+
+    defaults = KM.Parameters("""{
+        "num_processes" : 0,
+        "data_communicator_name" : ""
+    }""")
+
+    settings.ValidateAndAssignDefaults(defaults)
+
+    num_processes = settings["num_processes"].GetInt()
+    name = settings["data_communicator_name"].GetString()
+
+    world_data_comm = KM.ParallelEnvironment.GetDataCommunicator("World")
+
+    if num_processes < 1:
+        raise Exception('Input for "num_processes" ({}) must be > 0!'.format(num_processes))
+    if num_processes > world_data_comm.Size():
+        raise Exception('Input for "num_processes" ({}) cannot be larger than the number of MPI processes ({})!'.format(num_processes, world_data_comm.Size()))
+    if name == "":
+        raise Exception('Input for "name" cannot be empty!')
+
+    ranks = list(range(num_processes)) # [ 0 ... num_processes-1 ]
+    return DataCommunicatorFactory.CreateFromRanksAndRegister(world_data_comm, ranks, name)
```

## KratosMultiphysics/CoSimulationApplication/utilities/model_part_utilities.py

 * *Ordering differences only*

```diff
@@ -1,72 +1,72 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# CoSimulation imports
-from KratosMultiphysics.CoSimulationApplication.co_simulation_tools import cs_print_info
-from KratosMultiphysics.CoSimulationApplication.coupling_interface_data import CouplingInterfaceData
-
-def AllocateHistoricalVariablesFromCouplingDataSettings(data_settings_list, model, solver_name):
-    '''This function allocates historical variables for the Modelparts
-
-    It retrieves the historical variables that are needed for the ModelParts from the
-    specified CouplingInterfaceData-settings and allocates them on the ModelParts
-    Note that it can only be called after the (Main-)ModelParts are created
-    '''
-    data_settings_list = data_settings_list.Clone() # clone to not mess with the following validation
-
-    for data_settings in data_settings_list.values():
-        CouplingInterfaceData.GetDefaultParameters()
-        data_settings.ValidateAndAssignDefaults(CouplingInterfaceData.GetDefaultParameters())
-
-        if data_settings["location"].GetString() == "node_historical":
-            variable = KM.KratosGlobals.GetVariable(data_settings["variable_name"].GetString())
-            main_model_part_name = data_settings["model_part_name"].GetString().split(".")[0]
-            if not model.HasModelPart(main_model_part_name):
-                raise Exception('ModelPart "{}" does not exist in solver "{}"!'.format(main_model_part_name, solver_name))
-            main_model_part = model[main_model_part_name]
-            if not main_model_part.HasNodalSolutionStepVariable(variable):
-                cs_print_info("CoSimTools", 'Allocating historical variable "{}" in ModelPart "{}" for solver "{}"'.format(variable.Name(), main_model_part_name, solver_name))
-                main_model_part.AddNodalSolutionStepVariable(variable)
-
-def CreateMainModelPartsFromCouplingDataSettings(data_settings_list, model, solver_name):
-    '''This function creates the Main-ModelParts that are used in the specified CouplingInterfaceData-settings'''
-    data_settings_list = data_settings_list.Clone() # clone to not mess with the following validation
-
-    for data_settings in data_settings_list.values():
-        CouplingInterfaceData.GetDefaultParameters()
-        data_settings.ValidateAndAssignDefaults(CouplingInterfaceData.GetDefaultParameters())
-
-        main_model_part_name = data_settings["model_part_name"].GetString().split(".")[0]
-        if not model.HasModelPart(main_model_part_name):
-            model.CreateModelPart(main_model_part_name)
-            cs_print_info("CoSimTools", 'Created ModelPart "{}" for solver "{}"'.format(main_model_part_name, solver_name))
-
-def RecursiveCreateModelParts(model_part, model_part_name):
-    '''This function creates a hierarchy of SubModelParts on a given ModelPart'''
-    model_part_name, *sub_model_part_names = model_part_name.split(".")
-    if model_part.HasSubModelPart(model_part_name):
-        model_part = model_part.GetSubModelPart(model_part_name)
-    else:
-        cs_print_info("CoSimTools", 'Created "{}" as SubModelPart of "{}"'.format(model_part_name, model_part.Name))
-        model_part = model_part.CreateSubModelPart(model_part_name)
-    if len(sub_model_part_names) > 0:
-        RecursiveCreateModelParts(model_part, ".".join(sub_model_part_names))
-
-def CreateModelPartsFromCouplingDataSettings(data_settings_list, model, solver_name):
-    '''This function creates the ModelParts-hierarchie that are used in the specified CouplingInterfaceData-settings'''
-    data_settings_list = data_settings_list.Clone() # clone to not mess with the following validation
-
-    for data_settings in data_settings_list.values():
-        CouplingInterfaceData.GetDefaultParameters()
-        data_settings.ValidateAndAssignDefaults(CouplingInterfaceData.GetDefaultParameters())
-
-        splitted_name = data_settings["model_part_name"].GetString().split(".")
-        main_model_part_name = splitted_name[0]
-        sub_model_part_names = splitted_name[1:]
-        if model.HasModelPart(main_model_part_name):
-            main_model_part = model.GetModelPart(main_model_part_name)
-        else:
-            main_model_part = model.CreateModelPart(main_model_part_name)
-            cs_print_info("CoSimTools", 'Created ModelPart "{}" for solver "{}"'.format(main_model_part_name, solver_name))
-        if len(sub_model_part_names) > 0:
-            RecursiveCreateModelParts(main_model_part, ".".join(sub_model_part_names))
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# CoSimulation imports
+from KratosMultiphysics.CoSimulationApplication.co_simulation_tools import cs_print_info
+from KratosMultiphysics.CoSimulationApplication.coupling_interface_data import CouplingInterfaceData
+
+def AllocateHistoricalVariablesFromCouplingDataSettings(data_settings_list, model, solver_name):
+    '''This function allocates historical variables for the Modelparts
+
+    It retrieves the historical variables that are needed for the ModelParts from the
+    specified CouplingInterfaceData-settings and allocates them on the ModelParts
+    Note that it can only be called after the (Main-)ModelParts are created
+    '''
+    data_settings_list = data_settings_list.Clone() # clone to not mess with the following validation
+
+    for data_settings in data_settings_list.values():
+        CouplingInterfaceData.GetDefaultParameters()
+        data_settings.ValidateAndAssignDefaults(CouplingInterfaceData.GetDefaultParameters())
+
+        if data_settings["location"].GetString() == "node_historical":
+            variable = KM.KratosGlobals.GetVariable(data_settings["variable_name"].GetString())
+            main_model_part_name = data_settings["model_part_name"].GetString().split(".")[0]
+            if not model.HasModelPart(main_model_part_name):
+                raise Exception('ModelPart "{}" does not exist in solver "{}"!'.format(main_model_part_name, solver_name))
+            main_model_part = model[main_model_part_name]
+            if not main_model_part.HasNodalSolutionStepVariable(variable):
+                cs_print_info("CoSimTools", 'Allocating historical variable "{}" in ModelPart "{}" for solver "{}"'.format(variable.Name(), main_model_part_name, solver_name))
+                main_model_part.AddNodalSolutionStepVariable(variable)
+
+def CreateMainModelPartsFromCouplingDataSettings(data_settings_list, model, solver_name):
+    '''This function creates the Main-ModelParts that are used in the specified CouplingInterfaceData-settings'''
+    data_settings_list = data_settings_list.Clone() # clone to not mess with the following validation
+
+    for data_settings in data_settings_list.values():
+        CouplingInterfaceData.GetDefaultParameters()
+        data_settings.ValidateAndAssignDefaults(CouplingInterfaceData.GetDefaultParameters())
+
+        main_model_part_name = data_settings["model_part_name"].GetString().split(".")[0]
+        if not model.HasModelPart(main_model_part_name):
+            model.CreateModelPart(main_model_part_name)
+            cs_print_info("CoSimTools", 'Created ModelPart "{}" for solver "{}"'.format(main_model_part_name, solver_name))
+
+def RecursiveCreateModelParts(model_part, model_part_name):
+    '''This function creates a hierarchy of SubModelParts on a given ModelPart'''
+    model_part_name, *sub_model_part_names = model_part_name.split(".")
+    if model_part.HasSubModelPart(model_part_name):
+        model_part = model_part.GetSubModelPart(model_part_name)
+    else:
+        cs_print_info("CoSimTools", 'Created "{}" as SubModelPart of "{}"'.format(model_part_name, model_part.Name))
+        model_part = model_part.CreateSubModelPart(model_part_name)
+    if len(sub_model_part_names) > 0:
+        RecursiveCreateModelParts(model_part, ".".join(sub_model_part_names))
+
+def CreateModelPartsFromCouplingDataSettings(data_settings_list, model, solver_name):
+    '''This function creates the ModelParts-hierarchie that are used in the specified CouplingInterfaceData-settings'''
+    data_settings_list = data_settings_list.Clone() # clone to not mess with the following validation
+
+    for data_settings in data_settings_list.values():
+        CouplingInterfaceData.GetDefaultParameters()
+        data_settings.ValidateAndAssignDefaults(CouplingInterfaceData.GetDefaultParameters())
+
+        splitted_name = data_settings["model_part_name"].GetString().split(".")
+        main_model_part_name = splitted_name[0]
+        sub_model_part_names = splitted_name[1:]
+        if model.HasModelPart(main_model_part_name):
+            main_model_part = model.GetModelPart(main_model_part_name)
+        else:
+            main_model_part = model.CreateModelPart(main_model_part_name)
+            cs_print_info("CoSimTools", 'Created ModelPart "{}" for solver "{}"'.format(main_model_part_name, solver_name))
+        if len(sub_model_part_names) > 0:
+            RecursiveCreateModelParts(main_model_part, ".".join(sub_model_part_names))
```

## KratosMultiphysics/CoSimulationApplication/factories/data_transfer_operator_factory.py

 * *Ordering differences only*

```diff
@@ -1,5 +1,5 @@
-from KratosMultiphysics.CoSimulationApplication.factories import base_factory
-
-def CreateDataTransferOperator(coupling_operation_settings, *args):
-    """This function creates and returns the Data Transfer Operator used for CoSimulation"""
-    return base_factory.Create(coupling_operation_settings, [*args], "KratosMultiphysics.CoSimulationApplication.data_transfer_operators")
+from KratosMultiphysics.CoSimulationApplication.factories import base_factory
+
+def CreateDataTransferOperator(coupling_operation_settings, *args):
+    """This function creates and returns the Data Transfer Operator used for CoSimulation"""
+    return base_factory.Create(coupling_operation_settings, [*args], "KratosMultiphysics.CoSimulationApplication.data_transfer_operators")
```

## KratosMultiphysics/CoSimulationApplication/factories/helpers.py

 * *Ordering differences only*

```diff
@@ -1,78 +1,78 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# CoSimulation imports
-from KratosMultiphysics.CoSimulationApplication.factories.coupling_operation_factory import CreateCouplingOperation
-from KratosMultiphysics.CoSimulationApplication.factories.data_transfer_operator_factory import CreateDataTransferOperator
-from KratosMultiphysics.CoSimulationApplication.convergence_accelerators.convergence_accelerator_wrapper import ConvergenceAcceleratorWrapper
-from KratosMultiphysics.CoSimulationApplication.convergence_criteria.convergence_criteria_wrapper import ConvergenceCriteriaWrapper
-from KratosMultiphysics.CoSimulationApplication.factories.convergence_criterion_factory import CreateConvergenceCriterion
-from KratosMultiphysics.CoSimulationApplication.factories.predictor_factory import CreatePredictor
-from ..base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
-
-# STD Imports
-import collections
-
-def AddEchoLevelToSettings(settings, echo_level):
-    echo_level_params = KM.Parameters("""{
-        "echo_level" : %d
-    }""" % echo_level)
-    settings.AddMissingParameters(echo_level_params)
-
-
-def CreatePredictors(predictor_settings_list, solvers, parent_echo_level):
-    predictors = []
-    for predictor_settings in predictor_settings_list.values():
-        solver = solvers[predictor_settings["solver"].GetString()]
-        AddEchoLevelToSettings(predictor_settings, parent_echo_level)
-        predictors.append(CreatePredictor(predictor_settings, solver))
-    return predictors
-
-def CreateConvergenceAccelerators(convergence_accelerator_settings_list: KM.Parameters,
-                                  solvers: "collections.OrderedDict[str,CoSimulationSolverWrapper]",
-                                  parent_data_communicator: KM.DataCommunicator,
-                                  parent_echo_level: int):
-    convergence_accelerators = []
-    for conv_acc_settings in convergence_accelerator_settings_list.values():
-        solver = solvers[conv_acc_settings["solver"].GetString()]
-        interface_data_dict = solver.data_dict
-        AddEchoLevelToSettings(conv_acc_settings, parent_echo_level)
-        convergence_accelerators.append(ConvergenceAcceleratorWrapper(conv_acc_settings,
-                                                                      interface_data_dict,
-                                                                      parent_data_communicator))
-
-    return convergence_accelerators
-
-def CreateConvergenceCriteria(convergence_criterion_settings_list: KM.Parameters,
-                              solvers: "collections.OrderedDict[str,CoSimulationSolverWrapper]",
-                              parent_data_communicator: KM.DataCommunicator,
-                              parent_echo_level: int):
-    convergence_criteria = []
-    for conv_crit_settings in convergence_criterion_settings_list.values():
-        AddEchoLevelToSettings(conv_crit_settings, parent_echo_level)
-        if conv_crit_settings.Has("use_wrapper") and not conv_crit_settings["use_wrapper"].GetBool():
-            convergence_criteria.append(CreateConvergenceCriterion(conv_crit_settings, solvers))
-        else:
-            solver = solvers[conv_crit_settings["solver"].GetString()]
-            interface_data = solver.GetInterfaceData(conv_crit_settings["data_name"].GetString())
-            convergence_criteria.append(ConvergenceCriteriaWrapper(conv_crit_settings,
-                                                                   interface_data,
-                                                                   parent_data_communicator))
-
-    return convergence_criteria
-
-def CreateCouplingOperations(coupling_operations_settings_dict, solvers, parent_coupled_solver_process_info, parent_data_communicator, parent_echo_level):
-    coupling_operations = {}
-    for coupling_operation_name, coupling_operation_settings in coupling_operations_settings_dict.items():
-        AddEchoLevelToSettings(coupling_operation_settings, parent_echo_level)
-        coupling_operations[coupling_operation_name] = CreateCouplingOperation(coupling_operation_settings, solvers, parent_coupled_solver_process_info, parent_data_communicator)
-
-    return coupling_operations
-
-def CreateDataTransferOperators(data_transfer_operators_settings_dict, parent_data_communicator, parent_echo_level):
-    data_transfer_operators = {}
-    for data_transfer_operators_name, data_transfer_operators_settings in data_transfer_operators_settings_dict.items():
-        AddEchoLevelToSettings(data_transfer_operators_settings, parent_echo_level)
-        data_transfer_operators[data_transfer_operators_name] = CreateDataTransferOperator(data_transfer_operators_settings, parent_data_communicator)
-
-    return data_transfer_operators
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# CoSimulation imports
+from KratosMultiphysics.CoSimulationApplication.factories.coupling_operation_factory import CreateCouplingOperation
+from KratosMultiphysics.CoSimulationApplication.factories.data_transfer_operator_factory import CreateDataTransferOperator
+from KratosMultiphysics.CoSimulationApplication.convergence_accelerators.convergence_accelerator_wrapper import ConvergenceAcceleratorWrapper
+from KratosMultiphysics.CoSimulationApplication.convergence_criteria.convergence_criteria_wrapper import ConvergenceCriteriaWrapper
+from KratosMultiphysics.CoSimulationApplication.factories.convergence_criterion_factory import CreateConvergenceCriterion
+from KratosMultiphysics.CoSimulationApplication.factories.predictor_factory import CreatePredictor
+from ..base_classes.co_simulation_solver_wrapper import CoSimulationSolverWrapper
+
+# STD Imports
+import collections
+
+def AddEchoLevelToSettings(settings, echo_level):
+    echo_level_params = KM.Parameters("""{
+        "echo_level" : %d
+    }""" % echo_level)
+    settings.AddMissingParameters(echo_level_params)
+
+
+def CreatePredictors(predictor_settings_list, solvers, parent_echo_level):
+    predictors = []
+    for predictor_settings in predictor_settings_list.values():
+        solver = solvers[predictor_settings["solver"].GetString()]
+        AddEchoLevelToSettings(predictor_settings, parent_echo_level)
+        predictors.append(CreatePredictor(predictor_settings, solver))
+    return predictors
+
+def CreateConvergenceAccelerators(convergence_accelerator_settings_list: KM.Parameters,
+                                  solvers: "collections.OrderedDict[str,CoSimulationSolverWrapper]",
+                                  parent_data_communicator: KM.DataCommunicator,
+                                  parent_echo_level: int):
+    convergence_accelerators = []
+    for conv_acc_settings in convergence_accelerator_settings_list.values():
+        solver = solvers[conv_acc_settings["solver"].GetString()]
+        interface_data_dict = solver.data_dict
+        AddEchoLevelToSettings(conv_acc_settings, parent_echo_level)
+        convergence_accelerators.append(ConvergenceAcceleratorWrapper(conv_acc_settings,
+                                                                      interface_data_dict,
+                                                                      parent_data_communicator))
+
+    return convergence_accelerators
+
+def CreateConvergenceCriteria(convergence_criterion_settings_list: KM.Parameters,
+                              solvers: "collections.OrderedDict[str,CoSimulationSolverWrapper]",
+                              parent_data_communicator: KM.DataCommunicator,
+                              parent_echo_level: int):
+    convergence_criteria = []
+    for conv_crit_settings in convergence_criterion_settings_list.values():
+        AddEchoLevelToSettings(conv_crit_settings, parent_echo_level)
+        if conv_crit_settings.Has("use_wrapper") and not conv_crit_settings["use_wrapper"].GetBool():
+            convergence_criteria.append(CreateConvergenceCriterion(conv_crit_settings, solvers))
+        else:
+            solver = solvers[conv_crit_settings["solver"].GetString()]
+            interface_data = solver.GetInterfaceData(conv_crit_settings["data_name"].GetString())
+            convergence_criteria.append(ConvergenceCriteriaWrapper(conv_crit_settings,
+                                                                   interface_data,
+                                                                   parent_data_communicator))
+
+    return convergence_criteria
+
+def CreateCouplingOperations(coupling_operations_settings_dict, solvers, parent_coupled_solver_process_info, parent_data_communicator, parent_echo_level):
+    coupling_operations = {}
+    for coupling_operation_name, coupling_operation_settings in coupling_operations_settings_dict.items():
+        AddEchoLevelToSettings(coupling_operation_settings, parent_echo_level)
+        coupling_operations[coupling_operation_name] = CreateCouplingOperation(coupling_operation_settings, solvers, parent_coupled_solver_process_info, parent_data_communicator)
+
+    return coupling_operations
+
+def CreateDataTransferOperators(data_transfer_operators_settings_dict, parent_data_communicator, parent_echo_level):
+    data_transfer_operators = {}
+    for data_transfer_operators_name, data_transfer_operators_settings in data_transfer_operators_settings_dict.items():
+        AddEchoLevelToSettings(data_transfer_operators_settings, parent_echo_level)
+        data_transfer_operators[data_transfer_operators_name] = CreateDataTransferOperator(data_transfer_operators_settings, parent_data_communicator)
+
+    return data_transfer_operators
```

## KratosMultiphysics/CoSimulationApplication/factories/solver_wrapper_factory.py

 * *Ordering differences only*

```diff
@@ -1,5 +1,5 @@
-from KratosMultiphysics.CoSimulationApplication.factories import base_factory
-
-def CreateSolverWrapper(settings, models, solver_name):
-    """This function creates and returns the Wrapper for the Solver used for CoSimulation"""
-    return base_factory.Create(settings, [models, solver_name], "KratosMultiphysics.CoSimulationApplication")
+from KratosMultiphysics.CoSimulationApplication.factories import base_factory
+
+def CreateSolverWrapper(settings, models, solver_name):
+    """This function creates and returns the Wrapper for the Solver used for CoSimulation"""
+    return base_factory.Create(settings, [models, solver_name], "KratosMultiphysics.CoSimulationApplication")
```

## KratosMultiphysics/CoSimulationApplication/factories/coupling_operation_factory.py

 * *Ordering differences only*

```diff
@@ -1,5 +1,5 @@
-from KratosMultiphysics.CoSimulationApplication.factories import base_factory
-
-def CreateCouplingOperation(coupling_operation_settings, *args):
-    """This function creates and returns the Coupling Operation used for CoSimulation"""
-    return base_factory.Create(coupling_operation_settings, [*args], "KratosMultiphysics.CoSimulationApplication.coupling_operations")
+from KratosMultiphysics.CoSimulationApplication.factories import base_factory
+
+def CreateCouplingOperation(coupling_operation_settings, *args):
+    """This function creates and returns the Coupling Operation used for CoSimulation"""
+    return base_factory.Create(coupling_operation_settings, [*args], "KratosMultiphysics.CoSimulationApplication.coupling_operations")
```

## KratosMultiphysics/CoSimulationApplication/factories/io_factory.py

 * *Ordering differences only*

```diff
@@ -1,5 +1,5 @@
-from KratosMultiphysics.CoSimulationApplication.factories import base_factory
-
-def CreateIO(io_settings, model, solver_name, data_comm, io_name):
-    """This function creates and returns the IO used for CoSimulation"""
-    return base_factory.Create(io_settings, [model, solver_name, data_comm], "KratosMultiphysics.CoSimulationApplication.solver_wrappers", io_name)
+from KratosMultiphysics.CoSimulationApplication.factories import base_factory
+
+def CreateIO(io_settings, model, solver_name, data_comm, io_name):
+    """This function creates and returns the IO used for CoSimulation"""
+    return base_factory.Create(io_settings, [model, solver_name, data_comm], "KratosMultiphysics.CoSimulationApplication.solver_wrappers", io_name)
```

## KratosMultiphysics/CoSimulationApplication/factories/convergence_accelerator_factory.py

 * *Ordering differences only*

```diff
@@ -1,5 +1,5 @@
-from KratosMultiphysics.CoSimulationApplication.factories import base_factory
-
-def CreateConvergenceAccelerator(convergence_accelerator_settings, *args):
-    """This function creates and returns the Convergence Accelerator used for CoSimulation"""
-    return base_factory.Create(convergence_accelerator_settings, [*args], "KratosMultiphysics.CoSimulationApplication.convergence_accelerators")
+from KratosMultiphysics.CoSimulationApplication.factories import base_factory
+
+def CreateConvergenceAccelerator(convergence_accelerator_settings, *args):
+    """This function creates and returns the Convergence Accelerator used for CoSimulation"""
+    return base_factory.Create(convergence_accelerator_settings, [*args], "KratosMultiphysics.CoSimulationApplication.convergence_accelerators")
```

## KratosMultiphysics/CoSimulationApplication/factories/base_factory.py

 * *Ordering differences only*

```diff
@@ -1,20 +1,20 @@
-from importlib import import_module
-
-def Create(settings, args, folder, module_name=None):
-    """This function creates and returns a class from a module based on the use input
-    First the requested module is searched in CoSimulation
-    If it is not part of CoSimulation then it is attempted to be imported directly from PYTHONPATH
-    """
-    if module_name is None: # if the module name was not specified separately then take it from the settings
-        module_name = settings["type"].GetString()
-    full_module_path = ".".join([folder, module_name])
-
-    try:
-        imported_module = import_module(full_module_path)
-    except ImportError:
-        try:
-            imported_module = import_module(module_name)
-        except ImportError:
-            raise ImportError('Module "{}" could neither be imported from CoSimulation nor from PYTHONPATH'.format(module_name))
-
-    return imported_module.Create(settings, *args)
+from importlib import import_module
+
+def Create(settings, args, folder, module_name=None):
+    """This function creates and returns a class from a module based on the use input
+    First the requested module is searched in CoSimulation
+    If it is not part of CoSimulation then it is attempted to be imported directly from PYTHONPATH
+    """
+    if module_name is None: # if the module name was not specified separately then take it from the settings
+        module_name = settings["type"].GetString()
+    full_module_path = ".".join([folder, module_name])
+
+    try:
+        imported_module = import_module(full_module_path)
+    except ImportError:
+        try:
+            imported_module = import_module(module_name)
+        except ImportError:
+            raise ImportError('Module "{}" could neither be imported from CoSimulation nor from PYTHONPATH'.format(module_name))
+
+    return imported_module.Create(settings, *args)
```

## KratosMultiphysics/CoSimulationApplication/factories/convergence_criterion_factory.py

 * *Ordering differences only*

```diff
@@ -1,5 +1,5 @@
-from KratosMultiphysics.CoSimulationApplication.factories import base_factory
-
-def CreateConvergenceCriterion(convergence_criterion_settings, *args):
-    """This function creates and returns the Convergence Criterion used for CoSimulation"""
-    return base_factory.Create(convergence_criterion_settings, [*args], "KratosMultiphysics.CoSimulationApplication.convergence_criteria")
+from KratosMultiphysics.CoSimulationApplication.factories import base_factory
+
+def CreateConvergenceCriterion(convergence_criterion_settings, *args):
+    """This function creates and returns the Convergence Criterion used for CoSimulation"""
+    return base_factory.Create(convergence_criterion_settings, [*args], "KratosMultiphysics.CoSimulationApplication.convergence_criteria")
```

## KratosMultiphysics/CoSimulationApplication/factories/predictor_factory.py

 * *Ordering differences only*

```diff
@@ -1,5 +1,5 @@
-from KratosMultiphysics.CoSimulationApplication.factories import base_factory
-
-def CreatePredictor(predictor_settings, solver_wrapper):
-    """This function creates and returns the Predictor used for CoSimulation"""
-    return base_factory.Create(predictor_settings, [solver_wrapper], "KratosMultiphysics.CoSimulationApplication.predictors")
+from KratosMultiphysics.CoSimulationApplication.factories import base_factory
+
+def CreatePredictor(predictor_settings, solver_wrapper):
+    """This function creates and returns the Predictor used for CoSimulation"""
+    return base_factory.Create(predictor_settings, [solver_wrapper], "KratosMultiphysics.CoSimulationApplication.predictors")
```

## KratosMultiphysics/CoSimulationApplication/co_simulation_tools.py

 * *Ordering differences only*

```diff
@@ -1,18 +1,18 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.colors as colors
-
-### This file contains functionalities that are commonly used in CoSimulation ###
-
-def cs_print_info(label, *args):
-    KM.Logger.PrintInfo(colors.bold(label), " ".join(map(str,args)))
-
-def cs_print_warning(label, *args):
-    KM.Logger.PrintWarning(colors.bold(label), " ".join(map(str,args)))
-
-
-def SettingsTypeCheck(settings):
-    if not isinstance(settings, KM.Parameters):
-        raise TypeError("Expected input shall be a Parameters object, encapsulating a json string")
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.colors as colors
+
+### This file contains functionalities that are commonly used in CoSimulation ###
+
+def cs_print_info(label, *args):
+    KM.Logger.PrintInfo(colors.bold(label), " ".join(map(str,args)))
+
+def cs_print_warning(label, *args):
+    KM.Logger.PrintWarning(colors.bold(label), " ".join(map(str,args)))
+
+
+def SettingsTypeCheck(settings):
+    if not isinstance(settings, KM.Parameters):
+        raise TypeError("Expected input shall be a Parameters object, encapsulating a json string")
```

## KratosMultiphysics/CoSimulationApplication/convergence_accelerators/convergence_accelerator_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,129 +1,129 @@
-# Core imports
-import KratosMultiphysics
-
-# CoSimulation imports
-from KratosMultiphysics.CoSimulationApplication.factories.convergence_accelerator_factory import CreateConvergenceAccelerator
-from ..coupling_interface_data import CouplingInterfaceData
-
-# Other imports
-import numpy as np
-from abc import ABCMeta, abstractmethod
-
-class ConvergenceAcceleratorWrapper:
-    """This class wraps the convergence accelerators such that they can be used "automized"
-    => this class stores the residual and updates the solutions, such that the
-    convergence accelerator can be configured through json
-    In case of distributed data, it is checked whether the convergence accelerator supports it.
-    If not, the data is gathered / scattered and the accelerator is executed on only one rank
-    """
-    def __init__(self,
-                 settings: KratosMultiphysics.Parameters,
-                 interface_data_dict: "dict[str,CouplingInterfaceData]",
-                 parent_coupled_solver_data_communicator: KratosMultiphysics.DataCommunicator):
-        self.interface_data = interface_data_dict[settings["data_name"].GetString()]
-        self.residual_computation = CreateResidualComputation(settings, interface_data_dict)
-
-        # Remove extra entries from accelerator parameters
-        for key in ("data_name", "solver", "residual_computation"):
-            if settings.Has(key):
-                settings.RemoveValue(key)
-
-        self.conv_acc = CreateConvergenceAccelerator(settings)
-        self.data_communicator = parent_coupled_solver_data_communicator
-
-        if self.interface_data.IsDefinedOnThisRank():
-            conv_acc_supports_dist_data = self.conv_acc.SupportsDistributedData()
-            self.executing_rank = conv_acc_supports_dist_data or (self.interface_data.GetModelPart().GetCommunicator().MyPID() == 0)
-            self.gather_scatter_required = self.interface_data.IsDistributed() and not conv_acc_supports_dist_data
-            if self.gather_scatter_required:
-                self.data_comm = self.interface_data.GetModelPart().GetCommunicator().GetDataCommunicator()
-                self.sizes_from_ranks = np.cumsum(self.data_comm.GatherInts([self.interface_data.Size()], 0))
-
-    def Initialize(self):
-        self.conv_acc.Initialize()
-
-    def Finalize(self):
-        self.conv_acc.Finalize()
-
-    def InitializeSolutionStep(self):
-        self.conv_acc.InitializeSolutionStep()
-
-    def FinalizeSolutionStep(self):
-        self.conv_acc.FinalizeSolutionStep()
-
-    def InitializeNonLinearIteration(self):
-        if self.interface_data.IsDefinedOnThisRank():
-            # Saving the previous data for the computation of the residual
-            # and the computation of the solution update
-            self.input_data = self.interface_data.GetData()
-
-        self.conv_acc.InitializeNonLinearIteration()
-
-    def FinalizeNonLinearIteration(self):
-        self.conv_acc.FinalizeNonLinearIteration()
-
-    def ComputeAndApplyUpdate(self):
-        if not self.interface_data.IsDefinedOnThisRank(): return
-
-        residual = self.residual_computation.ComputeResidual(self.input_data)
-        input_data_for_acc = self.input_data
-
-        if self.gather_scatter_required:
-            residual = np.array(np.concatenate(self.data_comm.GathervDoubles(residual, 0)))
-            input_data_for_acc = np.array(np.concatenate(self.data_comm.GathervDoubles(input_data_for_acc, 0)))
-
-        if self.executing_rank:
-            updated_data = input_data_for_acc + self.conv_acc.UpdateSolution(residual, input_data_for_acc)
-
-        if self.gather_scatter_required:
-            if self.executing_rank:
-                data_to_scatter = np.split(updated_data, self.sizes_from_ranks[:-1])
-            else:
-                data_to_scatter = []
-
-            updated_data = self.data_comm.ScattervDoubles(data_to_scatter, 0)
-
-        self.interface_data.SetData(updated_data)
-
-    def PrintInfo(self):
-        self.conv_acc.PrintInfo()
-
-    def Check(self):
-        self.conv_acc.Check()
-
-class ConvergenceAcceleratorResidual(metaclass=ABCMeta):
-    @abstractmethod
-    def ComputeResidual(self, input_data): pass
-
-class DataDifferenceResidual(ConvergenceAcceleratorResidual):
-    def __init__(self,
-                 settings: KratosMultiphysics.Parameters,
-                 interface_data_dict: "dict[str,CouplingInterfaceData]"):
-        self.interface_data = interface_data_dict[settings["data_name"].GetString()]
-
-    def ComputeResidual(self, input_data):
-        return self.interface_data.GetData() - input_data
-
-class DifferentDataDifferenceResidual(ConvergenceAcceleratorResidual):
-    def __init__(self,
-                 settings: KratosMultiphysics.Parameters,
-                 interface_data_dict: "dict[str,CouplingInterfaceData]"):
-        self.interface_data =  interface_data_dict[settings["data_name"].GetString()]
-        self.interface_data1 = interface_data_dict[settings["residual_computation"]["data_name1"].GetString()]
-        self.interface_data2 = interface_data_dict[settings["residual_computation"]["data_name2"].GetString()]
-
-    def ComputeResidual(self, input_data):
-        return self.interface_data1.GetData() - self.interface_data2.GetData()
-
-def CreateResidualComputation(settings: KratosMultiphysics.Parameters,
-                              interface_data_dict: "dict[str,CouplingInterfaceData]"):
-    residual_computation_type = "data_difference"
-    if settings.Has("residual_computation"):
-        residual_computation_type = settings["residual_computation"]["type"].GetString()
-
-    if residual_computation_type == "data_difference":
-        return DataDifferenceResidual(settings, interface_data_dict)
-    elif residual_computation_type == "different_data_difference":
-        return DifferentDataDifferenceResidual(settings, interface_data_dict)
-    else:
-        raise Exception('The specified residual computation "{}" is not available!'.format(residual_computation_type))
+# Core imports
+import KratosMultiphysics
+
+# CoSimulation imports
+from KratosMultiphysics.CoSimulationApplication.factories.convergence_accelerator_factory import CreateConvergenceAccelerator
+from ..coupling_interface_data import CouplingInterfaceData
+
+# Other imports
+import numpy as np
+from abc import ABCMeta, abstractmethod
+
+class ConvergenceAcceleratorWrapper:
+    """This class wraps the convergence accelerators such that they can be used "automized"
+    => this class stores the residual and updates the solutions, such that the
+    convergence accelerator can be configured through json
+    In case of distributed data, it is checked whether the convergence accelerator supports it.
+    If not, the data is gathered / scattered and the accelerator is executed on only one rank
+    """
+    def __init__(self,
+                 settings: KratosMultiphysics.Parameters,
+                 interface_data_dict: "dict[str,CouplingInterfaceData]",
+                 parent_coupled_solver_data_communicator: KratosMultiphysics.DataCommunicator):
+        self.interface_data = interface_data_dict[settings["data_name"].GetString()]
+        self.residual_computation = CreateResidualComputation(settings, interface_data_dict)
+
+        # Remove extra entries from accelerator parameters
+        for key in ("data_name", "solver", "residual_computation"):
+            if settings.Has(key):
+                settings.RemoveValue(key)
+
+        self.conv_acc = CreateConvergenceAccelerator(settings)
+        self.data_communicator = parent_coupled_solver_data_communicator
+
+        if self.interface_data.IsDefinedOnThisRank():
+            conv_acc_supports_dist_data = self.conv_acc.SupportsDistributedData()
+            self.executing_rank = conv_acc_supports_dist_data or (self.interface_data.GetModelPart().GetCommunicator().MyPID() == 0)
+            self.gather_scatter_required = self.interface_data.IsDistributed() and not conv_acc_supports_dist_data
+            if self.gather_scatter_required:
+                self.data_comm = self.interface_data.GetModelPart().GetCommunicator().GetDataCommunicator()
+                self.sizes_from_ranks = np.cumsum(self.data_comm.GatherInts([self.interface_data.Size()], 0))
+
+    def Initialize(self):
+        self.conv_acc.Initialize()
+
+    def Finalize(self):
+        self.conv_acc.Finalize()
+
+    def InitializeSolutionStep(self):
+        self.conv_acc.InitializeSolutionStep()
+
+    def FinalizeSolutionStep(self):
+        self.conv_acc.FinalizeSolutionStep()
+
+    def InitializeNonLinearIteration(self):
+        if self.interface_data.IsDefinedOnThisRank():
+            # Saving the previous data for the computation of the residual
+            # and the computation of the solution update
+            self.input_data = self.interface_data.GetData()
+
+        self.conv_acc.InitializeNonLinearIteration()
+
+    def FinalizeNonLinearIteration(self):
+        self.conv_acc.FinalizeNonLinearIteration()
+
+    def ComputeAndApplyUpdate(self):
+        if not self.interface_data.IsDefinedOnThisRank(): return
+
+        residual = self.residual_computation.ComputeResidual(self.input_data)
+        input_data_for_acc = self.input_data
+
+        if self.gather_scatter_required:
+            residual = np.array(np.concatenate(self.data_comm.GathervDoubles(residual, 0)))
+            input_data_for_acc = np.array(np.concatenate(self.data_comm.GathervDoubles(input_data_for_acc, 0)))
+
+        if self.executing_rank:
+            updated_data = input_data_for_acc + self.conv_acc.UpdateSolution(residual, input_data_for_acc)
+
+        if self.gather_scatter_required:
+            if self.executing_rank:
+                data_to_scatter = np.split(updated_data, self.sizes_from_ranks[:-1])
+            else:
+                data_to_scatter = []
+
+            updated_data = self.data_comm.ScattervDoubles(data_to_scatter, 0)
+
+        self.interface_data.SetData(updated_data)
+
+    def PrintInfo(self):
+        self.conv_acc.PrintInfo()
+
+    def Check(self):
+        self.conv_acc.Check()
+
+class ConvergenceAcceleratorResidual(metaclass=ABCMeta):
+    @abstractmethod
+    def ComputeResidual(self, input_data): pass
+
+class DataDifferenceResidual(ConvergenceAcceleratorResidual):
+    def __init__(self,
+                 settings: KratosMultiphysics.Parameters,
+                 interface_data_dict: "dict[str,CouplingInterfaceData]"):
+        self.interface_data = interface_data_dict[settings["data_name"].GetString()]
+
+    def ComputeResidual(self, input_data):
+        return self.interface_data.GetData() - input_data
+
+class DifferentDataDifferenceResidual(ConvergenceAcceleratorResidual):
+    def __init__(self,
+                 settings: KratosMultiphysics.Parameters,
+                 interface_data_dict: "dict[str,CouplingInterfaceData]"):
+        self.interface_data =  interface_data_dict[settings["data_name"].GetString()]
+        self.interface_data1 = interface_data_dict[settings["residual_computation"]["data_name1"].GetString()]
+        self.interface_data2 = interface_data_dict[settings["residual_computation"]["data_name2"].GetString()]
+
+    def ComputeResidual(self, input_data):
+        return self.interface_data1.GetData() - self.interface_data2.GetData()
+
+def CreateResidualComputation(settings: KratosMultiphysics.Parameters,
+                              interface_data_dict: "dict[str,CouplingInterfaceData]"):
+    residual_computation_type = "data_difference"
+    if settings.Has("residual_computation"):
+        residual_computation_type = settings["residual_computation"]["type"].GetString()
+
+    if residual_computation_type == "data_difference":
+        return DataDifferenceResidual(settings, interface_data_dict)
+    elif residual_computation_type == "different_data_difference":
+        return DifferentDataDifferenceResidual(settings, interface_data_dict)
+    else:
+        raise Exception('The specified residual computation "{}" is not available!'.format(residual_computation_type))
```

## KratosMultiphysics/CoSimulationApplication/convergence_accelerators/iqnils.py

 * *Ordering differences only*

```diff
@@ -1,169 +1,169 @@
-## @module iqnils
-# This module contains the class IQNILSConvergenceAccelerator
-# Author: Wei He
-# Date: Feb. 20, 2017
-
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_convergence_accelerator import CoSimulationConvergenceAccelerator
-
-# CoSimulation imports
-from KratosMultiphysics.CoSimulationApplication.co_simulation_tools import cs_print_info, cs_print_warning, SettingsTypeCheck
-import KratosMultiphysics.CoSimulationApplication.colors as colors
-
-# Other imports
-import numpy as np
-from copy import deepcopy
-from collections import deque
-
-def Create(settings):
-    SettingsTypeCheck(settings)
-    return IQNILSConvergenceAccelerator(settings)
-
-## Class IQNILSConvergenceAccelerator.
-# This class contains the implementation of the IQN-ILS method and helper functions.
-# Reference: Joris Degroote, PhD thesis "Development of algorithms for the partitioned simulation of strongly coupled fluid-structure interaction problems", 84-91.
-class IQNILSConvergenceAccelerator(CoSimulationConvergenceAccelerator):
-    ## The constructor.
-    # @param iteration_horizon Maximum number of vectors to be stored in each time step.
-    # @param timestep_horizon Maximum number of time steps of which the vectors are used.
-    # @param alpha Relaxation factor for computing the update, when no vectors available.
-    def __init__( self, settings):
-        super().__init__(settings)
-
-        iteration_horizon = self.settings["iteration_horizon"].GetInt()
-        timestep_horizon = self.settings["timestep_horizon"].GetInt()
-        self.alpha = self.settings["alpha"].GetDouble()
-
-        self.R = deque( maxlen = iteration_horizon )
-        self.X = deque( maxlen = iteration_horizon )
-        self.q = timestep_horizon - 1
-        self.v_old_matrices = deque( maxlen = self.q )
-        self.w_old_matrices = deque( maxlen = self.q )
-        self.V_new = []
-        self.W_new = []
-        self.V_old = []
-        self.W_old = []
-
-    ## UpdateSolution(r, x)
-    # @param r residual r_k
-    # @param x solution x_k
-    # Computes the approximated update in each iteration.
-    def UpdateSolution( self, r, x ):
-        self.R.appendleft( deepcopy(r) )
-        self.X.appendleft(    x + r    )  # r = x~ - x
-        row = len(r)
-        col = len( self.R ) - 1
-        k = col
-        num_old_matrices = len( self.v_old_matrices )
-
-        if self.V_old == [] and self.W_old == []: # No previous vectors to reuse
-            if k == 0:
-                ## For the first iteration in the first time step, do relaxation only
-                if self.echo_level > 3:
-                    cs_print_info(self._ClassName(), "Doing relaxation in the first iteration with factor = ", "{0:.1g}".format(self.alpha))
-                return self.alpha * r
-            else:
-                if self.echo_level > 3:
-                    cs_print_info(self._ClassName(), "Doing multi-vector extrapolation")
-                    cs_print_info(self._ClassName(), "Number of new modes: ", col)
-                self.V_new = np.empty( shape = (col, row) ) # will be transposed later
-                for i in range(0, col):
-                    self.V_new[i] = self.R[i] - self.R[i + 1]
-                self.V_new = self.V_new.T
-                V = self.V_new
-
-                ## Check the dimension of the newly constructed matrix
-                if ( V.shape[0] < V.shape[1] ) and self.echo_level > 0:
-                    cs_print_warning(self._ClassName(), ": "+ colors.red("WARNING: column number larger than row number!"))
-
-                ## Construct matrix W(differences of predictions)
-                self.W_new = np.empty( shape = (col, row) ) # will be transposed later
-                for i in range(0, col):
-                    self.W_new[i] = self.X[i] - self.X[i + 1]
-                self.W_new = self.W_new.T
-                W = self.W_new
-
-                ## Solve least-squares problem
-                delta_r = -self.R[0]
-                c = np.linalg.lstsq(V, delta_r)[0]
-
-                ## Compute the update
-                delta_x = np.dot(W, c) - delta_r
-
-                return delta_x
-        else:  # previous vectors can be reused
-            if k == 0: # first iteration
-                if self.echo_level > 3:
-                    cs_print_info(self._ClassName(), "Using matrices from previous time steps")
-                    cs_print_info(self._ClassName(), "Number of previous matrices: ", num_old_matrices)
-                V = self.V_old
-                W = self.W_old
-                ## Solve least-squares problem
-                delta_r = -self.R[0]
-                c = np.linalg.lstsq(V, delta_r)[0]
-
-                ## Compute the update
-                delta_x = np.dot(W, c) - delta_r
-                return delta_x
-            else:
-                ## For other iterations, construct new V and W matrices and combine them with old ones
-                if self.echo_level > 3:
-                    cs_print_info(self._ClassName(), "Doing multi-vector extrapolation")
-                    cs_print_info(self._ClassName(), "Number of new modes: ", col)
-                    cs_print_info(self._ClassName(), "Number of previous matrices: ", num_old_matrices)
-                ## Construct matrix V (differences of residuals)
-                self.V_new = np.empty( shape = (col, row) ) # will be transposed later
-                for i in range(0, col):
-                    self.V_new[i] = self.R[i] - self.R[i + 1]
-                self.V_new = self.V_new.T
-                V = np.hstack( (self.V_new, self.V_old) )
-                ## Check the dimension of the newly constructed matrix
-                if ( V.shape[0] < V.shape[1] ) and self.echo_level > 0:
-                    cs_print_warning(self._ClassName(), ": "+ colors.red("WARNING: column number larger than row number!"))
-
-                ## Construct matrix W(differences of predictions)
-                self.W_new = np.empty( shape = (col, row) ) # will be transposed later
-                for i in range(0, col):
-                    self.W_new[i] = self.X[i] - self.X[i + 1]
-                self.W_new = self.W_new.T
-                W = np.hstack( (self.W_new, self.W_old) )
-
-                ## Solve least-squares problem
-                delta_r = -self.R[0]
-                c = np.linalg.lstsq(V, delta_r)[0]
-
-                ## Compute the update
-                delta_x = np.dot(W, c) - delta_r
-
-                return delta_x
-
-    ## FinalizeSolutionStep()
-    # Finalizes the current time step and initializes the next time step.
-    def FinalizeSolutionStep( self ):
-        if self.V_new != [] and self.W_new != []:
-            self.v_old_matrices.appendleft( self.V_new )
-            self.w_old_matrices.appendleft( self.W_new )
-        if self.v_old_matrices and self.w_old_matrices:
-            self.V_old = np.concatenate( self.v_old_matrices, 1 )
-            self.W_old = np.concatenate( self.w_old_matrices, 1 )
-        ## Clear the buffer
-        if self.R and self.X:
-            if self.echo_level > 3:
-                cs_print_info(self._ClassName(), "Cleaning")
-            self.R.clear()
-            self.X.clear()
-        self.V_new = []
-        self.W_new = []
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "iteration_horizon" : 20,
-            "timestep_horizon"  : 1,
-            "alpha"             : 0.125
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
+## @module iqnils
+# This module contains the class IQNILSConvergenceAccelerator
+# Author: Wei He
+# Date: Feb. 20, 2017
+
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_convergence_accelerator import CoSimulationConvergenceAccelerator
+
+# CoSimulation imports
+from KratosMultiphysics.CoSimulationApplication.co_simulation_tools import cs_print_info, cs_print_warning, SettingsTypeCheck
+import KratosMultiphysics.CoSimulationApplication.colors as colors
+
+# Other imports
+import numpy as np
+from copy import deepcopy
+from collections import deque
+
+def Create(settings):
+    SettingsTypeCheck(settings)
+    return IQNILSConvergenceAccelerator(settings)
+
+## Class IQNILSConvergenceAccelerator.
+# This class contains the implementation of the IQN-ILS method and helper functions.
+# Reference: Joris Degroote, PhD thesis "Development of algorithms for the partitioned simulation of strongly coupled fluid-structure interaction problems", 84-91.
+class IQNILSConvergenceAccelerator(CoSimulationConvergenceAccelerator):
+    ## The constructor.
+    # @param iteration_horizon Maximum number of vectors to be stored in each time step.
+    # @param timestep_horizon Maximum number of time steps of which the vectors are used.
+    # @param alpha Relaxation factor for computing the update, when no vectors available.
+    def __init__( self, settings):
+        super().__init__(settings)
+
+        iteration_horizon = self.settings["iteration_horizon"].GetInt()
+        timestep_horizon = self.settings["timestep_horizon"].GetInt()
+        self.alpha = self.settings["alpha"].GetDouble()
+
+        self.R = deque( maxlen = iteration_horizon )
+        self.X = deque( maxlen = iteration_horizon )
+        self.q = timestep_horizon - 1
+        self.v_old_matrices = deque( maxlen = self.q )
+        self.w_old_matrices = deque( maxlen = self.q )
+        self.V_new = []
+        self.W_new = []
+        self.V_old = []
+        self.W_old = []
+
+    ## UpdateSolution(r, x)
+    # @param r residual r_k
+    # @param x solution x_k
+    # Computes the approximated update in each iteration.
+    def UpdateSolution( self, r, x ):
+        self.R.appendleft( deepcopy(r) )
+        self.X.appendleft(    x + r    )  # r = x~ - x
+        row = len(r)
+        col = len( self.R ) - 1
+        k = col
+        num_old_matrices = len( self.v_old_matrices )
+
+        if self.V_old == [] and self.W_old == []: # No previous vectors to reuse
+            if k == 0:
+                ## For the first iteration in the first time step, do relaxation only
+                if self.echo_level > 3:
+                    cs_print_info(self._ClassName(), "Doing relaxation in the first iteration with factor = ", "{0:.1g}".format(self.alpha))
+                return self.alpha * r
+            else:
+                if self.echo_level > 3:
+                    cs_print_info(self._ClassName(), "Doing multi-vector extrapolation")
+                    cs_print_info(self._ClassName(), "Number of new modes: ", col)
+                self.V_new = np.empty( shape = (col, row) ) # will be transposed later
+                for i in range(0, col):
+                    self.V_new[i] = self.R[i] - self.R[i + 1]
+                self.V_new = self.V_new.T
+                V = self.V_new
+
+                ## Check the dimension of the newly constructed matrix
+                if ( V.shape[0] < V.shape[1] ) and self.echo_level > 0:
+                    cs_print_warning(self._ClassName(), ": "+ colors.red("WARNING: column number larger than row number!"))
+
+                ## Construct matrix W(differences of predictions)
+                self.W_new = np.empty( shape = (col, row) ) # will be transposed later
+                for i in range(0, col):
+                    self.W_new[i] = self.X[i] - self.X[i + 1]
+                self.W_new = self.W_new.T
+                W = self.W_new
+
+                ## Solve least-squares problem
+                delta_r = -self.R[0]
+                c = np.linalg.lstsq(V, delta_r)[0]
+
+                ## Compute the update
+                delta_x = np.dot(W, c) - delta_r
+
+                return delta_x
+        else:  # previous vectors can be reused
+            if k == 0: # first iteration
+                if self.echo_level > 3:
+                    cs_print_info(self._ClassName(), "Using matrices from previous time steps")
+                    cs_print_info(self._ClassName(), "Number of previous matrices: ", num_old_matrices)
+                V = self.V_old
+                W = self.W_old
+                ## Solve least-squares problem
+                delta_r = -self.R[0]
+                c = np.linalg.lstsq(V, delta_r)[0]
+
+                ## Compute the update
+                delta_x = np.dot(W, c) - delta_r
+                return delta_x
+            else:
+                ## For other iterations, construct new V and W matrices and combine them with old ones
+                if self.echo_level > 3:
+                    cs_print_info(self._ClassName(), "Doing multi-vector extrapolation")
+                    cs_print_info(self._ClassName(), "Number of new modes: ", col)
+                    cs_print_info(self._ClassName(), "Number of previous matrices: ", num_old_matrices)
+                ## Construct matrix V (differences of residuals)
+                self.V_new = np.empty( shape = (col, row) ) # will be transposed later
+                for i in range(0, col):
+                    self.V_new[i] = self.R[i] - self.R[i + 1]
+                self.V_new = self.V_new.T
+                V = np.hstack( (self.V_new, self.V_old) )
+                ## Check the dimension of the newly constructed matrix
+                if ( V.shape[0] < V.shape[1] ) and self.echo_level > 0:
+                    cs_print_warning(self._ClassName(), ": "+ colors.red("WARNING: column number larger than row number!"))
+
+                ## Construct matrix W(differences of predictions)
+                self.W_new = np.empty( shape = (col, row) ) # will be transposed later
+                for i in range(0, col):
+                    self.W_new[i] = self.X[i] - self.X[i + 1]
+                self.W_new = self.W_new.T
+                W = np.hstack( (self.W_new, self.W_old) )
+
+                ## Solve least-squares problem
+                delta_r = -self.R[0]
+                c = np.linalg.lstsq(V, delta_r)[0]
+
+                ## Compute the update
+                delta_x = np.dot(W, c) - delta_r
+
+                return delta_x
+
+    ## FinalizeSolutionStep()
+    # Finalizes the current time step and initializes the next time step.
+    def FinalizeSolutionStep( self ):
+        if self.V_new != [] and self.W_new != []:
+            self.v_old_matrices.appendleft( self.V_new )
+            self.w_old_matrices.appendleft( self.W_new )
+        if self.v_old_matrices and self.w_old_matrices:
+            self.V_old = np.concatenate( self.v_old_matrices, 1 )
+            self.W_old = np.concatenate( self.w_old_matrices, 1 )
+        ## Clear the buffer
+        if self.R and self.X:
+            if self.echo_level > 3:
+                cs_print_info(self._ClassName(), "Cleaning")
+            self.R.clear()
+            self.X.clear()
+        self.V_new = []
+        self.W_new = []
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "iteration_horizon" : 20,
+            "timestep_horizon"  : 1,
+            "alpha"             : 0.125
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
```

## KratosMultiphysics/CoSimulationApplication/convergence_accelerators/anderson.py

 * *Ordering differences only*

```diff
@@ -1,105 +1,105 @@
-# This module contains the class AndersonConvergenceAccelerator
-# Author: Andreas Winterstein
-# Date: Jul. 2018
-
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_convergence_accelerator import CoSimulationConvergenceAccelerator
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-
-# Other imports
-import numpy as np
-from copy import deepcopy
-from collections import deque
-
-def Create(settings):
-    cs_tools.SettingsTypeCheck(settings)
-    return AndersonConvergenceAccelerator(settings)
-
-class AndersonConvergenceAccelerator(CoSimulationConvergenceAccelerator):
-    ## The constructor.
-    # @param iteration_horizon number of values to be stored of last iterations.
-    # @param alpha Relaxation factor for computing the update.
-    # @param beta weighting factor of constant relaxation
-    # @param p factor for switch between constant relaxation and alternating anderson Gauß-Seidel/Jacobian method
-    # p = 1 results in the Anderson acceleration and p -> infinity results in constant relaxation
-    def __init__( self, settings):
-        super().__init__(settings)
-
-        iteration_horizon = self.settings["iteration_horizon"].GetInt()
-        self.alpha = self.settings["alpha"].GetDouble()
-        self.beta = self.settings["beta"].GetDouble()
-        self.p = self.settings["p"].GetInt()
-
-        self.V = deque( maxlen = iteration_horizon )
-        self.W = deque( maxlen = iteration_horizon )
-
-        self.iteration_counter = 0
-
-    def InitializeSolutionStep(self):
-        self.iteration_counter = 0
-
-   ## UpdateSolution(r, x)
-    # @param r residual r_k
-    # @param x solution x_k
-    # Computes the approximated update in each iteration.
-
-    def UpdateSolution(self, r, x):
-
-        self.V.appendleft( deepcopy(r) )
-        self.W.appendleft( deepcopy(x) )
-        row = len(r)
-        col = len( self.V ) - 1
-        k = col
-        if k == 0:
-            ## For the first iteration, do relaxation only
-            if self.echo_level > 3:
-                cs_tools.cs_print_info(self._ClassName(), ": Doing relaxation in the first iteration with factor = {}".format(self.alpha))
-            return self.alpha * r
-        else:
-            self.F = np.empty( shape = (col, row) ) # will be transposed later
-            self.X = np.empty( shape = (col, row) ) # will be transposed later
-            for i in range(0, col):
-                self.F[i] = self.V[i] - self.V[i + 1]
-                self.X[i] = self.W[i] - self.W[i + 1]
-            self.F = self.F.T
-            self.X = self.X.T
-
-            #compute Moore-Penrose inverse of F^T F
-            A = np.linalg.pinv(self.F.T @ self.F)
-
-            switch = (self.iteration_counter + 1)/self.p
-
-            if switch.is_integer():
-                B = self.beta * np.identity(row) - (self.X + self.beta * self.F) @ A @ self.F.T
-                if self.echo_level > 3:
-                    cs_tools.cs_print_info(self._ClassName(), "Compute B with Anderson")
-            else:
-                B = self.alpha * np.identity(row)
-                if self.echo_level > 3:
-                    cs_tools.cs_print_info(self._ClassName(), "Constant underrelaxtion")
-
-            delta_x = B @ r
-
-            self.iteration_counter += 1
-
-            return delta_x
-
-    def FinalizeSolutionStep(self):
-        self.V.clear()
-        self.W.clear()
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "iteration_horizon" : 20,
-            "alpha"             : 0.1,
-            "beta"              : 0.2,
-            "p"                 : 2
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
+# This module contains the class AndersonConvergenceAccelerator
+# Author: Andreas Winterstein
+# Date: Jul. 2018
+
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_convergence_accelerator import CoSimulationConvergenceAccelerator
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+
+# Other imports
+import numpy as np
+from copy import deepcopy
+from collections import deque
+
+def Create(settings):
+    cs_tools.SettingsTypeCheck(settings)
+    return AndersonConvergenceAccelerator(settings)
+
+class AndersonConvergenceAccelerator(CoSimulationConvergenceAccelerator):
+    ## The constructor.
+    # @param iteration_horizon number of values to be stored of last iterations.
+    # @param alpha Relaxation factor for computing the update.
+    # @param beta weighting factor of constant relaxation
+    # @param p factor for switch between constant relaxation and alternating anderson Gauß-Seidel/Jacobian method
+    # p = 1 results in the Anderson acceleration and p -> infinity results in constant relaxation
+    def __init__( self, settings):
+        super().__init__(settings)
+
+        iteration_horizon = self.settings["iteration_horizon"].GetInt()
+        self.alpha = self.settings["alpha"].GetDouble()
+        self.beta = self.settings["beta"].GetDouble()
+        self.p = self.settings["p"].GetInt()
+
+        self.V = deque( maxlen = iteration_horizon )
+        self.W = deque( maxlen = iteration_horizon )
+
+        self.iteration_counter = 0
+
+    def InitializeSolutionStep(self):
+        self.iteration_counter = 0
+
+   ## UpdateSolution(r, x)
+    # @param r residual r_k
+    # @param x solution x_k
+    # Computes the approximated update in each iteration.
+
+    def UpdateSolution(self, r, x):
+
+        self.V.appendleft( deepcopy(r) )
+        self.W.appendleft( deepcopy(x) )
+        row = len(r)
+        col = len( self.V ) - 1
+        k = col
+        if k == 0:
+            ## For the first iteration, do relaxation only
+            if self.echo_level > 3:
+                cs_tools.cs_print_info(self._ClassName(), ": Doing relaxation in the first iteration with factor = {}".format(self.alpha))
+            return self.alpha * r
+        else:
+            self.F = np.empty( shape = (col, row) ) # will be transposed later
+            self.X = np.empty( shape = (col, row) ) # will be transposed later
+            for i in range(0, col):
+                self.F[i] = self.V[i] - self.V[i + 1]
+                self.X[i] = self.W[i] - self.W[i + 1]
+            self.F = self.F.T
+            self.X = self.X.T
+
+            #compute Moore-Penrose inverse of F^T F
+            A = np.linalg.pinv(self.F.T @ self.F)
+
+            switch = (self.iteration_counter + 1)/self.p
+
+            if switch.is_integer():
+                B = self.beta * np.identity(row) - (self.X + self.beta * self.F) @ A @ self.F.T
+                if self.echo_level > 3:
+                    cs_tools.cs_print_info(self._ClassName(), "Compute B with Anderson")
+            else:
+                B = self.alpha * np.identity(row)
+                if self.echo_level > 3:
+                    cs_tools.cs_print_info(self._ClassName(), "Constant underrelaxtion")
+
+            delta_x = B @ r
+
+            self.iteration_counter += 1
+
+            return delta_x
+
+    def FinalizeSolutionStep(self):
+        self.V.clear()
+        self.W.clear()
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "iteration_horizon" : 20,
+            "alpha"             : 0.1,
+            "beta"              : 0.2,
+            "p"                 : 2
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
```

## KratosMultiphysics/CoSimulationApplication/convergence_accelerators/mvqn.py

 * *Ordering differences only*

```diff
@@ -1,114 +1,114 @@
-## @module iqnils
-# This module contains the class MVQNConvergenceAccelerator
-# Author: Wei He
-# Date: Feb. 20, 2017
-
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_convergence_accelerator import CoSimulationConvergenceAccelerator
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-
-# Other imports
-import numpy as np
-from copy import deepcopy
-from collections import deque
-import typing
-
-def Create(settings):
-    cs_tools.SettingsTypeCheck(settings)
-    return MVQNConvergenceAccelerator(settings)
-
-## Class MVQNConvergenceAccelerator.
-# This class contains the implementation of the MVQN method and helper functions.
-# Reference: A.E.J. Bogaers et al. "Quasi-Newton methods for implicit black-box FSI coupling", Computational methods in applied mechanics and engineering. 279(2014) 113-132.
-class MVQNConvergenceAccelerator(CoSimulationConvergenceAccelerator):
-    ## The constructor.
-    # @param horizon Maximum number of vectors to be stored in each time step.
-    # @param alpha Relaxation factor for computing the update, when no vectors available.
-    def __init__( self, settings):
-        super().__init__(settings)
-
-        horizon = self.settings["horizon"].GetInt()
-        self.alpha = self.settings["alpha"].GetDouble()
-
-        self.R = deque( maxlen = horizon )
-        self.X = deque( maxlen = horizon )
-        self.J: typing.Optional[np.ndarray] = None # size will be determined when first time get the input vector
-        self.J_hat: typing.Optional[np.ndarray] = None
-
-    ## UpdateSolution(r, x)
-    # @param r residual r_k
-    # @param x solution x_k
-    # Computes the approximated update in each iteration.
-    def UpdateSolution( self, r, x ):
-        self.R.appendleft( deepcopy(r) )
-        self.X.appendleft( deepcopy(x) )
-        col = len(self.R) - 1
-        row = len(r)
-        k = col
-        if self.echo_level > 3:
-            cs_tools.cs_print_info(self._ClassName(), "Number of new modes: ", col )
-
-        ## For the first iteration
-        if k == 0:
-            if self.J is None:
-                return self.alpha * r  # if no Jacobian, do relaxation
-            else:
-                return np.linalg.solve( self.J, -r ) # use the Jacobian from previous step
-
-        ## Let the initial Jacobian correspond to a constant relaxation
-        if self.J is None:
-            self.J = - np.identity( row ) / self.alpha # correspongding to constant relaxation
-
-        ## Construct matrix V (differences of residuals)
-        V = np.empty( shape = (col, row) ) # will be transposed later
-        for i in range(0, col):
-            V[i] = self.R[i] - self.R[i + 1]
-        V = V.T
-
-        ## Construct matrix W(differences of intermediate solutions x)
-        W = np.empty( shape = (col, row) ) # will be transposed later
-        for i in range(0, col):
-            W[i] = self.X[i] - self.X[i + 1]
-        W = W.T
-
-        ## Solve least norm problem
-        rhs = V - np.dot(self.J, W)
-        b = np.identity( row )
-        W_right_inverse = np.linalg.lstsq(W, b, rcond=-1)[0]
-        J_tilde = np.dot(rhs, W_right_inverse)
-        self.J_hat = self.J + J_tilde
-        delta_r = -self.R[0]
-        delta_x = np.linalg.solve(self.J_hat, delta_r)
-
-        return delta_x
-
-    ## FinalizeSolutionStep()
-    # Finalizes the current time step and initializes the next time step.
-    def FinalizeSolutionStep( self ):
-        if self.J is None:
-            return
-
-        row = self.J.shape[0]
-        col = self.J.shape[1]
-        ## Assign J=J_hat
-        self.J[:row,:col] = self.J_hat[:row,:col]
-        if self.echo_level > 3:
-            cs_tools.cs_print_info(self._ClassName(), "Jacobian matrix updated!")
-        ## Clear the buffer
-        if self.R and self.X:
-            self.R.clear()
-            self.X.clear()
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "horizon" : 15,
-            "alpha"   : 0.125
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
+## @module iqnils
+# This module contains the class MVQNConvergenceAccelerator
+# Author: Wei He
+# Date: Feb. 20, 2017
+
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_convergence_accelerator import CoSimulationConvergenceAccelerator
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+
+# Other imports
+import numpy as np
+from copy import deepcopy
+from collections import deque
+import typing
+
+def Create(settings):
+    cs_tools.SettingsTypeCheck(settings)
+    return MVQNConvergenceAccelerator(settings)
+
+## Class MVQNConvergenceAccelerator.
+# This class contains the implementation of the MVQN method and helper functions.
+# Reference: A.E.J. Bogaers et al. "Quasi-Newton methods for implicit black-box FSI coupling", Computational methods in applied mechanics and engineering. 279(2014) 113-132.
+class MVQNConvergenceAccelerator(CoSimulationConvergenceAccelerator):
+    ## The constructor.
+    # @param horizon Maximum number of vectors to be stored in each time step.
+    # @param alpha Relaxation factor for computing the update, when no vectors available.
+    def __init__( self, settings):
+        super().__init__(settings)
+
+        horizon = self.settings["horizon"].GetInt()
+        self.alpha = self.settings["alpha"].GetDouble()
+
+        self.R = deque( maxlen = horizon )
+        self.X = deque( maxlen = horizon )
+        self.J: typing.Optional[np.ndarray] = None # size will be determined when first time get the input vector
+        self.J_hat: typing.Optional[np.ndarray] = None
+
+    ## UpdateSolution(r, x)
+    # @param r residual r_k
+    # @param x solution x_k
+    # Computes the approximated update in each iteration.
+    def UpdateSolution( self, r, x ):
+        self.R.appendleft( deepcopy(r) )
+        self.X.appendleft( deepcopy(x) )
+        col = len(self.R) - 1
+        row = len(r)
+        k = col
+        if self.echo_level > 3:
+            cs_tools.cs_print_info(self._ClassName(), "Number of new modes: ", col )
+
+        ## For the first iteration
+        if k == 0:
+            if self.J is None:
+                return self.alpha * r  # if no Jacobian, do relaxation
+            else:
+                return np.linalg.solve( self.J, -r ) # use the Jacobian from previous step
+
+        ## Let the initial Jacobian correspond to a constant relaxation
+        if self.J is None:
+            self.J = - np.identity( row ) / self.alpha # correspongding to constant relaxation
+
+        ## Construct matrix V (differences of residuals)
+        V = np.empty( shape = (col, row) ) # will be transposed later
+        for i in range(0, col):
+            V[i] = self.R[i] - self.R[i + 1]
+        V = V.T
+
+        ## Construct matrix W(differences of intermediate solutions x)
+        W = np.empty( shape = (col, row) ) # will be transposed later
+        for i in range(0, col):
+            W[i] = self.X[i] - self.X[i + 1]
+        W = W.T
+
+        ## Solve least norm problem
+        rhs = V - np.dot(self.J, W)
+        b = np.identity( row )
+        W_right_inverse = np.linalg.lstsq(W, b, rcond=-1)[0]
+        J_tilde = np.dot(rhs, W_right_inverse)
+        self.J_hat = self.J + J_tilde
+        delta_r = -self.R[0]
+        delta_x = np.linalg.solve(self.J_hat, delta_r)
+
+        return delta_x
+
+    ## FinalizeSolutionStep()
+    # Finalizes the current time step and initializes the next time step.
+    def FinalizeSolutionStep( self ):
+        if self.J is None:
+            return
+
+        row = self.J.shape[0]
+        col = self.J.shape[1]
+        ## Assign J=J_hat
+        self.J[:row,:col] = self.J_hat[:row,:col]
+        if self.echo_level > 3:
+            cs_tools.cs_print_info(self._ClassName(), "Jacobian matrix updated!")
+        ## Clear the buffer
+        if self.R and self.X:
+            self.R.clear()
+            self.X.clear()
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "horizon" : 15,
+            "alpha"   : 0.125
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
```

## KratosMultiphysics/CoSimulationApplication/convergence_accelerators/aitken.py

 * *Ordering differences only*

```diff
@@ -1,86 +1,86 @@
-## @module aitken
-# This module contains the class AitkenConvergenceAccelerator
-# Author: Wei He
-# Date: Feb. 20, 2017
-
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_convergence_accelerator import CoSimulationConvergenceAccelerator
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-
-# Other imports
-import numpy as np
-from copy import deepcopy
-from collections import deque
-
-def Create(settings):
-    cs_tools.SettingsTypeCheck(settings)
-    return AitkenConvergenceAccelerator(settings)
-
-## Class AitkenConvergenceAccelerator.
-# This class contains the implementation of Aitken relaxation and helper functions.
-# Reference: Ulrich Küttler et al., "Fixed-point fluid–structure interaction solvers with dynamic relaxation"
-class AitkenConvergenceAccelerator(CoSimulationConvergenceAccelerator):
-    ## The constructor.
-    # @param init_alpha Initial relaxation factor in the first time step.
-    # @param init_alpha_max Maximum relaxation factor for the first iteration in each time step
-    def __init__( self, settings):
-        super().__init__(settings)
-        self.R = deque( maxlen = 2 )
-
-        self.alpha_old      = self.settings["init_alpha"].GetDouble()
-        self.init_alpha_max = self.settings["init_alpha_max"].GetDouble()
-        self.alpha_max      = self.settings["alpha_max"].GetDouble()
-        self.alpha_min      = self.settings["alpha_min"].GetDouble()
-
-    def InitializeSolutionStep(self):
-        self.initial_iteration = True
-
-    ## UpdateSolution(r, x)
-    # @param r residual r_k
-    # @param x solution x_k
-    # Computes the approximated update in each iteration.
-    def UpdateSolution( self, r, x ):
-        self.R.appendleft( deepcopy(r) )
-
-        ## For the first iteration, do relaxation only
-        if self.initial_iteration:
-            self.initial_iteration = False
-            alpha = min( self.alpha_old, self.init_alpha_max )
-            if self.echo_level > 3:
-                cs_tools.cs_print_info(self._ClassName(), ": Doing relaxation in the first iteration with initial factor = {}".format(alpha))
-            return alpha * r
-
-        else:
-            r_diff = self.R[0] - self.R[1]
-            numerator = np.inner( self.R[1], r_diff )
-            denominator = np.inner( r_diff, r_diff )
-            alpha = -self.alpha_old * numerator/denominator
-            if self.echo_level > 3:
-                cs_tools.cs_print_info(self._ClassName(), ": Doing relaxation with factor = {}".format(alpha))
-            if alpha > self.alpha_max:
-                alpha = self.alpha_max
-                if self.echo_level > 0:
-                    cs_tools.cs_print_warning(self._ClassName(), "dynamic relaxation factor reaches upper bound: {}".format(self.alpha_max))
-            elif alpha < self.alpha_min:
-                alpha = self.alpha_min
-                if self.echo_level > 0:
-                    cs_tools.cs_print_warning(self._ClassName(), "dynamic relaxation factor reaches lower bound: {}".format(self.alpha_min))
-            delta_x = alpha * self.R[0]
-            self.alpha_old = alpha
-            return delta_x
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "init_alpha"     :  0.1,
-            "init_alpha_max" :  0.45,
-            "alpha_max"      :  2.0,
-            "alpha_min"      : -2.0
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
+## @module aitken
+# This module contains the class AitkenConvergenceAccelerator
+# Author: Wei He
+# Date: Feb. 20, 2017
+
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_convergence_accelerator import CoSimulationConvergenceAccelerator
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+
+# Other imports
+import numpy as np
+from copy import deepcopy
+from collections import deque
+
+def Create(settings):
+    cs_tools.SettingsTypeCheck(settings)
+    return AitkenConvergenceAccelerator(settings)
+
+## Class AitkenConvergenceAccelerator.
+# This class contains the implementation of Aitken relaxation and helper functions.
+# Reference: Ulrich Küttler et al., "Fixed-point fluid–structure interaction solvers with dynamic relaxation"
+class AitkenConvergenceAccelerator(CoSimulationConvergenceAccelerator):
+    ## The constructor.
+    # @param init_alpha Initial relaxation factor in the first time step.
+    # @param init_alpha_max Maximum relaxation factor for the first iteration in each time step
+    def __init__( self, settings):
+        super().__init__(settings)
+        self.R = deque( maxlen = 2 )
+
+        self.alpha_old      = self.settings["init_alpha"].GetDouble()
+        self.init_alpha_max = self.settings["init_alpha_max"].GetDouble()
+        self.alpha_max      = self.settings["alpha_max"].GetDouble()
+        self.alpha_min      = self.settings["alpha_min"].GetDouble()
+
+    def InitializeSolutionStep(self):
+        self.initial_iteration = True
+
+    ## UpdateSolution(r, x)
+    # @param r residual r_k
+    # @param x solution x_k
+    # Computes the approximated update in each iteration.
+    def UpdateSolution( self, r, x ):
+        self.R.appendleft( deepcopy(r) )
+
+        ## For the first iteration, do relaxation only
+        if self.initial_iteration:
+            self.initial_iteration = False
+            alpha = min( self.alpha_old, self.init_alpha_max )
+            if self.echo_level > 3:
+                cs_tools.cs_print_info(self._ClassName(), ": Doing relaxation in the first iteration with initial factor = {}".format(alpha))
+            return alpha * r
+
+        else:
+            r_diff = self.R[0] - self.R[1]
+            numerator = np.inner( self.R[1], r_diff )
+            denominator = np.inner( r_diff, r_diff )
+            alpha = -self.alpha_old * numerator/denominator
+            if self.echo_level > 3:
+                cs_tools.cs_print_info(self._ClassName(), ": Doing relaxation with factor = {}".format(alpha))
+            if alpha > self.alpha_max:
+                alpha = self.alpha_max
+                if self.echo_level > 0:
+                    cs_tools.cs_print_warning(self._ClassName(), "dynamic relaxation factor reaches upper bound: {}".format(self.alpha_max))
+            elif alpha < self.alpha_min:
+                alpha = self.alpha_min
+                if self.echo_level > 0:
+                    cs_tools.cs_print_warning(self._ClassName(), "dynamic relaxation factor reaches lower bound: {}".format(self.alpha_min))
+            delta_x = alpha * self.R[0]
+            self.alpha_old = alpha
+            return delta_x
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "init_alpha"     :  0.1,
+            "init_alpha_max" :  0.45,
+            "alpha_max"      :  2.0,
+            "alpha_min"      : -2.0
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
```

## KratosMultiphysics/CoSimulationApplication/convergence_accelerators/constant_relaxation.py

 * *Ordering differences only*

```diff
@@ -1,42 +1,42 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_convergence_accelerator import CoSimulationConvergenceAccelerator
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-
-def Create(settings):
-    cs_tools.SettingsTypeCheck(settings)
-    return ConstantRelaxationConvergenceAccelerator(settings)
-
-class ConstantRelaxationConvergenceAccelerator(CoSimulationConvergenceAccelerator):
-    ## The constructor.
-    # @param alpha relaxation factor.
-    def __init__(self, settings):
-        super().__init__(settings)
-        self.alpha = self.settings["alpha"].GetDouble()
-
-    ## UpdateSolution(r, x)
-    # @param r residual r_k
-    # @param x solution x_k
-    # Computes the approximated update in each iteration.
-    def UpdateSolution( self, r, x ):
-        if self.echo_level > 3:
-            cs_tools.cs_print_info(self._ClassName(), "Doing relaxation with factor = ", "{0:.1g}".format(self.alpha))
-        delta_x = self.alpha * r
-        return delta_x
-
-    @classmethod
-    def SupportsDistributedData(cls):
-        return True
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "alpha" : 0.125
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
-
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_convergence_accelerator import CoSimulationConvergenceAccelerator
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+
+def Create(settings):
+    cs_tools.SettingsTypeCheck(settings)
+    return ConstantRelaxationConvergenceAccelerator(settings)
+
+class ConstantRelaxationConvergenceAccelerator(CoSimulationConvergenceAccelerator):
+    ## The constructor.
+    # @param alpha relaxation factor.
+    def __init__(self, settings):
+        super().__init__(settings)
+        self.alpha = self.settings["alpha"].GetDouble()
+
+    ## UpdateSolution(r, x)
+    # @param r residual r_k
+    # @param x solution x_k
+    # Computes the approximated update in each iteration.
+    def UpdateSolution( self, r, x ):
+        if self.echo_level > 3:
+            cs_tools.cs_print_info(self._ClassName(), "Doing relaxation with factor = ", "{0:.1g}".format(self.alpha))
+        delta_x = self.alpha * r
+        return delta_x
+
+    @classmethod
+    def SupportsDistributedData(cls):
+        return True
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "alpha" : 0.125
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
+
```

## KratosMultiphysics/CoSimulationApplication/coupled_solvers/jacobi_weak.py

 * *Ordering differences only*

```diff
@@ -1,24 +1,24 @@
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupled_solver import CoSimulationCoupledSolver
-
-def Create(settings, models, solver_name):
-    return JacobiWeakCoupledSolver(settings, models, solver_name)
-
-class JacobiWeakCoupledSolver(CoSimulationCoupledSolver):
-    def SolveSolutionStep(self):
-        for coupling_op in self.coupling_operations_dict.values():
-            coupling_op.InitializeCouplingIteration()
-
-        for solver_name, solver in self.solver_wrappers.items():
-            self._SynchronizeInputData(solver_name)
-
-        for solver_name, solver in self.solver_wrappers.items():
-            solver.SolveSolutionStep()
-
-        for solver_name, solver in self.solver_wrappers.items():
-            self._SynchronizeOutputData(solver_name)
-
-        for coupling_op in self.coupling_operations_dict.values():
-            coupling_op.FinalizeCouplingIteration()
-
-        return True
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupled_solver import CoSimulationCoupledSolver
+
+def Create(settings, models, solver_name):
+    return JacobiWeakCoupledSolver(settings, models, solver_name)
+
+class JacobiWeakCoupledSolver(CoSimulationCoupledSolver):
+    def SolveSolutionStep(self):
+        for coupling_op in self.coupling_operations_dict.values():
+            coupling_op.InitializeCouplingIteration()
+
+        for solver_name, solver in self.solver_wrappers.items():
+            self._SynchronizeInputData(solver_name)
+
+        for solver_name, solver in self.solver_wrappers.items():
+            solver.SolveSolutionStep()
+
+        for solver_name, solver in self.solver_wrappers.items():
+            self._SynchronizeOutputData(solver_name)
+
+        for coupling_op in self.coupling_operations_dict.values():
+            coupling_op.FinalizeCouplingIteration()
+
+        return True
```

## KratosMultiphysics/CoSimulationApplication/coupled_solvers/gauss_seidel_strong.py

 * *Ordering differences only*

```diff
@@ -1,159 +1,159 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-import KratosMultiphysics.CoSimulationApplication as KratosCoSim
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupled_solver import CoSimulationCoupledSolver
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-import KratosMultiphysics.CoSimulationApplication.factories.helpers as factories_helper
-import KratosMultiphysics.CoSimulationApplication.colors as colors
-
-def Create(settings, models, solver_name):
-    return GaussSeidelStrongCoupledSolver(settings, models, solver_name)
-
-class GaussSeidelStrongCoupledSolver(CoSimulationCoupledSolver):
-    def __init__(self, settings, models, solver_name):
-        super().__init__(settings, models, solver_name)
-
-        self.num_coupling_iterations = self.settings["num_coupling_iterations"].GetInt()
-
-    def Initialize(self):
-        super().Initialize()
-
-        self.convergence_accelerators_list = factories_helper.CreateConvergenceAccelerators(
-            self.settings["convergence_accelerators"],
-            self.solver_wrappers,
-            self.data_communicator,
-            self.echo_level)
-
-        self.convergence_criteria_list = factories_helper.CreateConvergenceCriteria(
-            self.settings["convergence_criteria"],
-            self.solver_wrappers,
-            self.data_communicator,
-            self.echo_level)
-
-        for conv_acc in self.convergence_accelerators_list:
-            conv_acc.Initialize()
-
-        for conv_crit in self.convergence_criteria_list:
-            conv_crit.Initialize()
-
-    def Finalize(self):
-        super().Finalize()
-
-        for conv_acc in self.convergence_accelerators_list:
-            conv_acc.Finalize()
-
-        for conv_crit in self.convergence_criteria_list:
-            conv_crit.Finalize()
-
-    def InitializeSolutionStep(self):
-        super().InitializeSolutionStep()
-
-        for conv_acc in self.convergence_accelerators_list:
-            conv_acc.InitializeSolutionStep()
-
-        for conv_crit in self.convergence_criteria_list:
-            conv_crit.InitializeSolutionStep()
-
-        self.process_info[KratosCoSim.COUPLING_ITERATION_NUMBER] = 0
-
-    def FinalizeSolutionStep(self):
-        super().FinalizeSolutionStep()
-
-        for conv_acc in self.convergence_accelerators_list:
-            conv_acc.FinalizeSolutionStep()
-
-        for conv_crit in self.convergence_criteria_list:
-            conv_crit.FinalizeSolutionStep()
-
-
-    def SolveSolutionStep(self):
-        for k in range(self.num_coupling_iterations):
-            self.process_info[KratosCoSim.COUPLING_ITERATION_NUMBER] += 1
-
-            if self.echo_level > 0:
-                cs_tools.cs_print_info(self._ClassName(), colors.cyan("Coupling iteration:"), colors.bold(str(k+1)+" / " + str(self.num_coupling_iterations)))
-
-            for coupling_op in self.coupling_operations_dict.values():
-                coupling_op.InitializeCouplingIteration()
-
-            for conv_acc in self.convergence_accelerators_list:
-                conv_acc.InitializeNonLinearIteration()
-
-            for conv_crit in self.convergence_criteria_list:
-                conv_crit.InitializeNonLinearIteration()
-
-            for solver_name, solver in self.solver_wrappers.items():
-                self._SynchronizeInputData(solver_name)
-                solver.SolveSolutionStep()
-                self._SynchronizeOutputData(solver_name)
-
-            for coupling_op in self.coupling_operations_dict.values():
-                coupling_op.FinalizeCouplingIteration()
-
-            for conv_acc in self.convergence_accelerators_list:
-                conv_acc.FinalizeNonLinearIteration()
-
-            for conv_crit in self.convergence_criteria_list:
-                conv_crit.FinalizeNonLinearIteration()
-
-            is_converged = all([conv_crit.IsConverged() for conv_crit in self.convergence_criteria_list])
-
-            if is_converged:
-                if self.echo_level > 0:
-                    cs_tools.cs_print_info(self._ClassName(), colors.green("### CONVERGENCE WAS ACHIEVED ###"))
-                self.__CommunicateIfTimeStepNeedsToBeRepeated(False)
-                return True
-
-            if k+1 >= self.num_coupling_iterations:
-                if self.echo_level > 0:
-                    cs_tools.cs_print_info(self._ClassName(), colors.red("XXX CONVERGENCE WAS NOT ACHIEVED XXX"))
-                self.__CommunicateIfTimeStepNeedsToBeRepeated(False)
-                return False
-
-            # if it reaches here it means that the coupling has not converged and this was not the last coupling iteration
-            self.__CommunicateIfTimeStepNeedsToBeRepeated(True)
-
-            # do relaxation only if this iteration is not the last iteration of this timestep
-            for conv_acc in self.convergence_accelerators_list:
-                conv_acc.ComputeAndApplyUpdate()
-
-
-    def Check(self):
-        super().Check()
-
-        if len(self.convergence_criteria_list) == 0:
-            raise Exception("At least one convergence criteria has to be specified")
-
-        # TODO check if an accelerator was specified for a field that is manipulated in the input!
-
-        for conv_crit in self.convergence_criteria_list:
-            conv_crit.Check()
-
-        for conv_crit in self.convergence_accelerators_list:
-            conv_crit.Check()
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "convergence_accelerators" : [],
-            "convergence_criteria"     : [],
-            "num_coupling_iterations"  : 10
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-
-        return this_defaults
-
-    def __CommunicateIfTimeStepNeedsToBeRepeated(self, repeat_time_step):
-        # Communicate if the time step needs to be repeated with external solvers through IO
-        export_config = {
-            "type" : "repeat_time_step",
-            "repeat_time_step" : repeat_time_step
-        }
-
-        for solver in self.solver_wrappers.values():
-            solver.ExportData(export_config)
-
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+import KratosMultiphysics.CoSimulationApplication as KratosCoSim
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupled_solver import CoSimulationCoupledSolver
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+import KratosMultiphysics.CoSimulationApplication.factories.helpers as factories_helper
+import KratosMultiphysics.CoSimulationApplication.colors as colors
+
+def Create(settings, models, solver_name):
+    return GaussSeidelStrongCoupledSolver(settings, models, solver_name)
+
+class GaussSeidelStrongCoupledSolver(CoSimulationCoupledSolver):
+    def __init__(self, settings, models, solver_name):
+        super().__init__(settings, models, solver_name)
+
+        self.num_coupling_iterations = self.settings["num_coupling_iterations"].GetInt()
+
+    def Initialize(self):
+        super().Initialize()
+
+        self.convergence_accelerators_list = factories_helper.CreateConvergenceAccelerators(
+            self.settings["convergence_accelerators"],
+            self.solver_wrappers,
+            self.data_communicator,
+            self.echo_level)
+
+        self.convergence_criteria_list = factories_helper.CreateConvergenceCriteria(
+            self.settings["convergence_criteria"],
+            self.solver_wrappers,
+            self.data_communicator,
+            self.echo_level)
+
+        for conv_acc in self.convergence_accelerators_list:
+            conv_acc.Initialize()
+
+        for conv_crit in self.convergence_criteria_list:
+            conv_crit.Initialize()
+
+    def Finalize(self):
+        super().Finalize()
+
+        for conv_acc in self.convergence_accelerators_list:
+            conv_acc.Finalize()
+
+        for conv_crit in self.convergence_criteria_list:
+            conv_crit.Finalize()
+
+    def InitializeSolutionStep(self):
+        super().InitializeSolutionStep()
+
+        for conv_acc in self.convergence_accelerators_list:
+            conv_acc.InitializeSolutionStep()
+
+        for conv_crit in self.convergence_criteria_list:
+            conv_crit.InitializeSolutionStep()
+
+        self.process_info[KratosCoSim.COUPLING_ITERATION_NUMBER] = 0
+
+    def FinalizeSolutionStep(self):
+        super().FinalizeSolutionStep()
+
+        for conv_acc in self.convergence_accelerators_list:
+            conv_acc.FinalizeSolutionStep()
+
+        for conv_crit in self.convergence_criteria_list:
+            conv_crit.FinalizeSolutionStep()
+
+
+    def SolveSolutionStep(self):
+        for k in range(self.num_coupling_iterations):
+            self.process_info[KratosCoSim.COUPLING_ITERATION_NUMBER] += 1
+
+            if self.echo_level > 0:
+                cs_tools.cs_print_info(self._ClassName(), colors.cyan("Coupling iteration:"), colors.bold(str(k+1)+" / " + str(self.num_coupling_iterations)))
+
+            for coupling_op in self.coupling_operations_dict.values():
+                coupling_op.InitializeCouplingIteration()
+
+            for conv_acc in self.convergence_accelerators_list:
+                conv_acc.InitializeNonLinearIteration()
+
+            for conv_crit in self.convergence_criteria_list:
+                conv_crit.InitializeNonLinearIteration()
+
+            for solver_name, solver in self.solver_wrappers.items():
+                self._SynchronizeInputData(solver_name)
+                solver.SolveSolutionStep()
+                self._SynchronizeOutputData(solver_name)
+
+            for coupling_op in self.coupling_operations_dict.values():
+                coupling_op.FinalizeCouplingIteration()
+
+            for conv_acc in self.convergence_accelerators_list:
+                conv_acc.FinalizeNonLinearIteration()
+
+            for conv_crit in self.convergence_criteria_list:
+                conv_crit.FinalizeNonLinearIteration()
+
+            is_converged = all([conv_crit.IsConverged() for conv_crit in self.convergence_criteria_list])
+
+            if is_converged:
+                if self.echo_level > 0:
+                    cs_tools.cs_print_info(self._ClassName(), colors.green("### CONVERGENCE WAS ACHIEVED ###"))
+                self.__CommunicateIfTimeStepNeedsToBeRepeated(False)
+                return True
+
+            if k+1 >= self.num_coupling_iterations:
+                if self.echo_level > 0:
+                    cs_tools.cs_print_info(self._ClassName(), colors.red("XXX CONVERGENCE WAS NOT ACHIEVED XXX"))
+                self.__CommunicateIfTimeStepNeedsToBeRepeated(False)
+                return False
+
+            # if it reaches here it means that the coupling has not converged and this was not the last coupling iteration
+            self.__CommunicateIfTimeStepNeedsToBeRepeated(True)
+
+            # do relaxation only if this iteration is not the last iteration of this timestep
+            for conv_acc in self.convergence_accelerators_list:
+                conv_acc.ComputeAndApplyUpdate()
+
+
+    def Check(self):
+        super().Check()
+
+        if len(self.convergence_criteria_list) == 0:
+            raise Exception("At least one convergence criteria has to be specified")
+
+        # TODO check if an accelerator was specified for a field that is manipulated in the input!
+
+        for conv_crit in self.convergence_criteria_list:
+            conv_crit.Check()
+
+        for conv_crit in self.convergence_accelerators_list:
+            conv_crit.Check()
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "convergence_accelerators" : [],
+            "convergence_criteria"     : [],
+            "num_coupling_iterations"  : 10
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+
+        return this_defaults
+
+    def __CommunicateIfTimeStepNeedsToBeRepeated(self, repeat_time_step):
+        # Communicate if the time step needs to be repeated with external solvers through IO
+        export_config = {
+            "type" : "repeat_time_step",
+            "repeat_time_step" : repeat_time_step
+        }
+
+        for solver in self.solver_wrappers.values():
+            solver.ExportData(export_config)
+
```

## KratosMultiphysics/CoSimulationApplication/coupled_solvers/jacobi_strong.py

 * *Ordering differences only*

```diff
@@ -1,158 +1,158 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupled_solver import CoSimulationCoupledSolver
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-import KratosMultiphysics.CoSimulationApplication.factories.helpers as factories_helper
-import KratosMultiphysics.CoSimulationApplication.colors as colors
-
-def Create(settings, models, solver_name):
-    return JacobiStrongCoupledSolver(settings, models, solver_name)
-
-class JacobiStrongCoupledSolver(CoSimulationCoupledSolver):
-    def __init__(self, settings, models, solver_name):
-        super().__init__(settings, models, solver_name)
-
-        self.num_coupling_iterations = self.settings["num_coupling_iterations"].GetInt()
-
-    def Initialize(self):
-        super().Initialize()
-
-        self.convergence_accelerators_list = factories_helper.CreateConvergenceAccelerators(
-            self.settings["convergence_accelerators"],
-            self.solver_wrappers,
-            self.data_communicator,
-            self.echo_level)
-
-        self.convergence_criteria_list = factories_helper.CreateConvergenceCriteria(
-            self.settings["convergence_criteria"],
-            self.solver_wrappers,
-            self.data_communicator,
-            self.echo_level)
-
-        for conv_acc in self.convergence_accelerators_list:
-            conv_acc.Initialize()
-
-        for conv_crit in self.convergence_criteria_list:
-            conv_crit.Initialize()
-
-    def Finalize(self):
-        super().Finalize()
-
-        for conv_acc in self.convergence_accelerators_list:
-            conv_acc.Finalize()
-
-        for conv_crit in self.convergence_criteria_list:
-            conv_crit.Finalize()
-
-    def InitializeSolutionStep(self):
-        super().InitializeSolutionStep()
-
-        for conv_acc in self.convergence_accelerators_list:
-            conv_acc.InitializeSolutionStep()
-
-        for conv_crit in self.convergence_criteria_list:
-            conv_crit.InitializeSolutionStep()
-
-    def FinalizeSolutionStep(self):
-        super().FinalizeSolutionStep()
-
-        for conv_acc in self.convergence_accelerators_list:
-            conv_acc.FinalizeSolutionStep()
-
-        for conv_crit in self.convergence_criteria_list:
-            conv_crit.FinalizeSolutionStep()
-
-
-    def SolveSolutionStep(self):
-        for k in range(self.num_coupling_iterations):
-            if self.echo_level > 0:
-                cs_tools.cs_print_info(self._ClassName(), colors.cyan("Coupling iteration:"), colors.bold(str(k+1)+" / " + str(self.num_coupling_iterations)))
-
-            for coupling_op in self.coupling_operations_dict.values():
-                coupling_op.InitializeCouplingIteration()
-
-            for conv_acc in self.convergence_accelerators_list:
-                conv_acc.InitializeNonLinearIteration()
-
-            for conv_crit in self.convergence_criteria_list:
-                conv_crit.InitializeNonLinearIteration()
-
-            for solver_name, solver in self.solver_wrappers.items():
-                self._SynchronizeInputData(solver_name)
-
-            for solver_name, solver in self.solver_wrappers.items():
-                solver.SolveSolutionStep()
-
-            for solver_name, solver in self.solver_wrappers.items():
-                self._SynchronizeOutputData(solver_name)
-
-            for coupling_op in self.coupling_operations_dict.values():
-                coupling_op.FinalizeCouplingIteration()
-
-            for conv_acc in self.convergence_accelerators_list:
-                conv_acc.FinalizeNonLinearIteration()
-
-            for conv_crit in self.convergence_criteria_list:
-                conv_crit.FinalizeNonLinearIteration()
-
-            is_converged = all([conv_crit.IsConverged() for conv_crit in self.convergence_criteria_list])
-
-            if is_converged:
-                if self.echo_level > 0:
-                    cs_tools.cs_print_info(self._ClassName(), colors.green("### CONVERGENCE WAS ACHIEVED ###"))
-                self.__CommunicateIfTimeStepNeedsToBeRepeated(False)
-                return True
-
-            if k+1 >= self.num_coupling_iterations:
-                if self.echo_level > 0:
-                    cs_tools.cs_print_info(self._ClassName(), colors.red("XXX CONVERGENCE WAS NOT ACHIEVED XXX"))
-                self.__CommunicateIfTimeStepNeedsToBeRepeated(False)
-                return False
-
-            # if it reaches here it means that the coupling has not converged and this was not the last coupling iteration
-            self.__CommunicateIfTimeStepNeedsToBeRepeated(True)
-
-            # do relaxation only if this iteration is not the last iteration of this timestep
-            for conv_acc in self.convergence_accelerators_list:
-                conv_acc.ComputeAndApplyUpdate()
-
-
-    def Check(self):
-        super().Check()
-
-        if len(self.convergence_criteria_list) == 0:
-            raise Exception("At least one convergence criteria has to be specified")
-
-        # TODO check if an accelerator was specified for a field that is manipulated in the input!
-
-        for conv_crit in self.convergence_criteria_list:
-            conv_crit.Check()
-
-        for conv_crit in self.convergence_accelerators_list:
-            conv_crit.Check()
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "convergence_accelerators" : [],
-            "convergence_criteria"     : [],
-            "num_coupling_iterations"  : 10
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-
-        return this_defaults
-
-    def __CommunicateIfTimeStepNeedsToBeRepeated(self, repeat_time_step):
-        # Communicate if the time step needs to be repeated with external solvers through IO
-        export_config = {
-            "type" : "repeat_time_step",
-            "repeat_time_step" : repeat_time_step
-        }
-
-        for solver in self.solver_wrappers.values():
-            solver.ExportData(export_config)
-
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupled_solver import CoSimulationCoupledSolver
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+import KratosMultiphysics.CoSimulationApplication.factories.helpers as factories_helper
+import KratosMultiphysics.CoSimulationApplication.colors as colors
+
+def Create(settings, models, solver_name):
+    return JacobiStrongCoupledSolver(settings, models, solver_name)
+
+class JacobiStrongCoupledSolver(CoSimulationCoupledSolver):
+    def __init__(self, settings, models, solver_name):
+        super().__init__(settings, models, solver_name)
+
+        self.num_coupling_iterations = self.settings["num_coupling_iterations"].GetInt()
+
+    def Initialize(self):
+        super().Initialize()
+
+        self.convergence_accelerators_list = factories_helper.CreateConvergenceAccelerators(
+            self.settings["convergence_accelerators"],
+            self.solver_wrappers,
+            self.data_communicator,
+            self.echo_level)
+
+        self.convergence_criteria_list = factories_helper.CreateConvergenceCriteria(
+            self.settings["convergence_criteria"],
+            self.solver_wrappers,
+            self.data_communicator,
+            self.echo_level)
+
+        for conv_acc in self.convergence_accelerators_list:
+            conv_acc.Initialize()
+
+        for conv_crit in self.convergence_criteria_list:
+            conv_crit.Initialize()
+
+    def Finalize(self):
+        super().Finalize()
+
+        for conv_acc in self.convergence_accelerators_list:
+            conv_acc.Finalize()
+
+        for conv_crit in self.convergence_criteria_list:
+            conv_crit.Finalize()
+
+    def InitializeSolutionStep(self):
+        super().InitializeSolutionStep()
+
+        for conv_acc in self.convergence_accelerators_list:
+            conv_acc.InitializeSolutionStep()
+
+        for conv_crit in self.convergence_criteria_list:
+            conv_crit.InitializeSolutionStep()
+
+    def FinalizeSolutionStep(self):
+        super().FinalizeSolutionStep()
+
+        for conv_acc in self.convergence_accelerators_list:
+            conv_acc.FinalizeSolutionStep()
+
+        for conv_crit in self.convergence_criteria_list:
+            conv_crit.FinalizeSolutionStep()
+
+
+    def SolveSolutionStep(self):
+        for k in range(self.num_coupling_iterations):
+            if self.echo_level > 0:
+                cs_tools.cs_print_info(self._ClassName(), colors.cyan("Coupling iteration:"), colors.bold(str(k+1)+" / " + str(self.num_coupling_iterations)))
+
+            for coupling_op in self.coupling_operations_dict.values():
+                coupling_op.InitializeCouplingIteration()
+
+            for conv_acc in self.convergence_accelerators_list:
+                conv_acc.InitializeNonLinearIteration()
+
+            for conv_crit in self.convergence_criteria_list:
+                conv_crit.InitializeNonLinearIteration()
+
+            for solver_name, solver in self.solver_wrappers.items():
+                self._SynchronizeInputData(solver_name)
+
+            for solver_name, solver in self.solver_wrappers.items():
+                solver.SolveSolutionStep()
+
+            for solver_name, solver in self.solver_wrappers.items():
+                self._SynchronizeOutputData(solver_name)
+
+            for coupling_op in self.coupling_operations_dict.values():
+                coupling_op.FinalizeCouplingIteration()
+
+            for conv_acc in self.convergence_accelerators_list:
+                conv_acc.FinalizeNonLinearIteration()
+
+            for conv_crit in self.convergence_criteria_list:
+                conv_crit.FinalizeNonLinearIteration()
+
+            is_converged = all([conv_crit.IsConverged() for conv_crit in self.convergence_criteria_list])
+
+            if is_converged:
+                if self.echo_level > 0:
+                    cs_tools.cs_print_info(self._ClassName(), colors.green("### CONVERGENCE WAS ACHIEVED ###"))
+                self.__CommunicateIfTimeStepNeedsToBeRepeated(False)
+                return True
+
+            if k+1 >= self.num_coupling_iterations:
+                if self.echo_level > 0:
+                    cs_tools.cs_print_info(self._ClassName(), colors.red("XXX CONVERGENCE WAS NOT ACHIEVED XXX"))
+                self.__CommunicateIfTimeStepNeedsToBeRepeated(False)
+                return False
+
+            # if it reaches here it means that the coupling has not converged and this was not the last coupling iteration
+            self.__CommunicateIfTimeStepNeedsToBeRepeated(True)
+
+            # do relaxation only if this iteration is not the last iteration of this timestep
+            for conv_acc in self.convergence_accelerators_list:
+                conv_acc.ComputeAndApplyUpdate()
+
+
+    def Check(self):
+        super().Check()
+
+        if len(self.convergence_criteria_list) == 0:
+            raise Exception("At least one convergence criteria has to be specified")
+
+        # TODO check if an accelerator was specified for a field that is manipulated in the input!
+
+        for conv_crit in self.convergence_criteria_list:
+            conv_crit.Check()
+
+        for conv_crit in self.convergence_accelerators_list:
+            conv_crit.Check()
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "convergence_accelerators" : [],
+            "convergence_criteria"     : [],
+            "num_coupling_iterations"  : 10
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+
+        return this_defaults
+
+    def __CommunicateIfTimeStepNeedsToBeRepeated(self, repeat_time_step):
+        # Communicate if the time step needs to be repeated with external solvers through IO
+        export_config = {
+            "type" : "repeat_time_step",
+            "repeat_time_step" : repeat_time_step
+        }
+
+        for solver in self.solver_wrappers.values():
+            solver.ExportData(export_config)
+
```

## KratosMultiphysics/CoSimulationApplication/coupled_solvers/feti_dynamic_coupled_solver.py

 * *Ordering differences only*

```diff
@@ -1,270 +1,270 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-import KratosMultiphysics.MappingApplication as KratosMapping
-import KratosMultiphysics.CoSimulationApplication as CoSim
-
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupled_solver import CoSimulationCoupledSolver
-
-# Other imports
-from KratosMultiphysics import python_linear_solver_factory as linear_solver_factory
-
-def Create(settings, models, solver_name):
-    return FetiDynamicCoupledSolver(settings, models, solver_name)
-
-class FetiDynamicCoupledSolver(CoSimulationCoupledSolver):
-    def __init__(self, settings, models, solver_name):
-        super().__init__(settings, models, solver_name)
-
-        if len(self.solver_wrappers.items()) != 2:
-            raise Exception("FETI solver only works with two solvers!")
-
-        # Add solution step variables while models are empty
-        self.__CheckSolversCompatibility()
-        self.__AddNodalSolutionStepVariables()
-        self.is_initial_step = True
-
-    def Initialize(self):
-        super().Initialize()
-
-    def AdvanceInTime(self, current_time):
-        # The CoSimulation runs at the SMALLEST Timestep.
-        # The solver with the smallest timestep will dictate the CoSimulation.
-        # The solver(s) with the larger timesteps will be called only at times that match their time
-        advanced_time = current_time
-        self.departing_time = current_time # the time we are departing from - this is used to sync everything
-
-        if self.is_initial_step:
-            self._solver_delta_times = {}
-            advanced_time = 1E20
-            for solver_name, solver in self.solver_wrappers.items():
-                self._solver_delta_times[solver_name] = solver.AdvanceInTime(current_time)
-                advanced_time = min(advanced_time,self._solver_delta_times[solver_name])
-
-            self.is_initial_step = False
-
-            # Initialize the FETI utilites
-            self.__InitializeFetiMethod()
-        else:
-            for solver_name, solver in self.solver_wrappers.items():
-                if self.SolverSolvesAtThisTime(solver_name):
-                    solver_time = solver.AdvanceInTime(self.departing_time)
-                    if self._solver_origin_dest_dict[solver_name] == CoSim.FetiSolverIndexType.Destination:
-                        advanced_time = solver_time #only advance global time finely
-
-        if advanced_time == current_time:
-            raise Exception("No solvers advanced any timestep.")
-        else:
-            return advanced_time
-
-    def SolverSolvesAtThisTime(self, solver_name):
-        solver_delta_time = self._solver_delta_times[solver_name]
-        # the following only works if timesteps are multiple of each other
-        time_error = (self.departing_time % solver_delta_time)
-        if time_error < 1E-12 or abs(time_error - solver_delta_time) < 1E-12:
-            return True
-        else:
-            return False
-
-    def InitializeSolutionStep(self):
-        for solver_name, solver in self.solver_wrappers.items():
-            if self.SolverSolvesAtThisTime(solver_name):
-                solver.InitializeSolutionStep()
-
-        for coupling_op_name, coupling_op in self.coupling_operations_dict.items():
-            if self.__CouplingOpActsNow(coupling_op_name):
-                coupling_op.InitializeSolutionStep()
-
-    def Predict(self):
-        for solver_name, solver in self.solver_wrappers.items():
-            if self.SolverSolvesAtThisTime(solver_name):
-                solver.Predict()
-
-    def FinalizeSolutionStep(self):
-        for solver_name, solver in self.solver_wrappers.items():
-            if self.SolverSolvesAtThisTime(solver_name):
-                solver.FinalizeSolutionStep()
-
-        for coupling_op_name, coupling_op in self.coupling_operations_dict.items():
-            if self.__CouplingOpActsNow(coupling_op_name):
-                coupling_op.FinalizeSolutionStep()
-
-    def OutputSolutionStep(self):
-        for solver_name, solver in self.solver_wrappers.items():
-            if self.SolverSolvesAtThisTime(solver_name):
-                solver.OutputSolutionStep()
-
-    def SolveSolutionStep(self):
-        for coupling_op_name, coupling_op in self.coupling_operations_dict.items():
-            if self.__CouplingOpActsNow(coupling_op_name):
-                coupling_op.InitializeCouplingIteration()
-
-        for solver_name, solver in self.solver_wrappers.items():
-            if self.SolverSolvesAtThisTime(solver_name):
-                #self._SynchronizeInputData(solver_name) @phil not needed since corrections are applied within the feti cpp
-                solver.SolveSolutionStep()
-                #self._SynchronizeOutputData(solver_name) @phil not needed since corrections are applied within the feti cpp
-                self.__SendStiffnessMatrixToUtility(solver_name)
-
-        self.feti_coupling.EquilibrateDomains()
-
-        for coupling_op_name, coupling_op in self.coupling_operations_dict.items():
-            if self.__CouplingOpActsNow(coupling_op_name):
-                coupling_op.FinalizeCouplingIteration()
-
-        return True
-
-    def __AddNodalSolutionStepVariables(self):
-        for solver_name, solver in self.solver_wrappers.items():
-            structure = solver.model.GetModelPart("Structure")
-            structure.AddNodalSolutionStepVariable(KM.VECTOR_LAGRANGE_MULTIPLIER)
-
-    def __InitializeFetiMethod(self):
-        # Create vector of solver indices for convenience
-        self.__CreateSolverOriginDestDict()
-
-        # Check timestep ratio is valid and add to settings
-        timestep_ratio = self._CalculateAndCheckTimestepRatio()
-        self.settings.AddInt('timestep_ratio',int(timestep_ratio))
-
-        # get mapper parameters
-        self.mapper_parameters = self.data_transfer_operators_dict["mapper"].settings["mapper_settings"]
-        mapper_type = self.mapper_parameters["mapper_type"].GetString()
-
-        # get mapper origin and destination modelparts
-        origin_modelpart_name = self.mapper_parameters["modeler_parameters"]["origin_interface_sub_model_part_name"].GetString()
-        destination_modelpart_name = self.mapper_parameters["modeler_parameters"]["destination_interface_sub_model_part_name"].GetString()
-        for solver_name, solver in self.solver_wrappers.items():
-            if self._solver_origin_dest_dict[solver_name] == CoSim.FetiSolverIndexType.Origin:
-                self.model_part_origin_interface = self.solver_wrappers[solver_name].model.GetModelPart(origin_modelpart_name)
-            else:
-                self.model_part_destination_interface = self.solver_wrappers[solver_name].model.GetModelPart(destination_modelpart_name)
-
-        # manually create mapper
-        mapper_create_fct = KratosMapping.MapperFactory.CreateMapper
-        self.mapper = mapper_create_fct(self.model_part_origin_interface, self.model_part_destination_interface, self.mapper_parameters.Clone())
-
-        # get interface modelparts created by the mapper modeler
-        self.modelpart_interface_origin_from_mapper = self.mapper.GetInterfaceModelPartOrigin()
-        self.modelpart_interface_destination_from_mapper = self.mapper.GetInterfaceModelPartDestination()
-
-        # Create feti class instance
-        self.feti_coupling = CoSim.FetiDynamicCouplingUtilities(
-            self.modelpart_interface_origin_from_mapper,
-            self.modelpart_interface_destination_from_mapper,
-            self.settings)
-
-        # set the mapper
-        if mapper_type == "coupling_geometry":
-            self.feti_coupling.SetMappingMatrix(self.mapper.GetMappingMatrix())
-        else:
-            raise Exception("Dynamic coupled solver currently only compatible with the coupling_geometry mapper.")
-
-        # The origin and destination interfaces from the mapper submitted above are both
-        # stored within the origin modelpart. Now we submit the 'original' origin and destination
-        # interface model parts stored on the origin and destination models to get access to the
-        # origin and destination models.
-        self.feti_coupling.SetOriginAndDestinationDomainsWithInterfaceModelParts(
-            self.model_part_origin_interface,
-            self.model_part_destination_interface)
-
-        # create the solver
-        linear_solver = self._CreateLinearSolver()
-        self.feti_coupling.SetLinearSolver(linear_solver)
-
-        # Set origin initial velocities
-        self.feti_coupling.SetOriginInitialKinematics()
-
-        # Create output-solver relation dict to ensure mixed timestep ouput is handled properly
-        self.__CreateOutputSolverDict()
-
-    def __CreateSolverOriginDestDict(self):
-        self._solver_origin_dest_dict = {}
-        for solver_index in range(self.settings["coupling_sequence"].size()):
-            ordered_solver_name = self.settings["coupling_sequence"][solver_index]["name"].GetString()
-            if solver_index == 0:
-                self._solver_origin_dest_dict[ordered_solver_name] = CoSim.FetiSolverIndexType.Origin
-            else:
-                self._solver_origin_dest_dict[ordered_solver_name] = CoSim.FetiSolverIndexType.Destination
-
-    def __SendStiffnessMatrixToUtility(self, solver_name):
-        beta = 0.0
-        solver_index = self._solver_origin_dest_dict[solver_name]
-        if solver_index == CoSim.FetiSolverIndexType.Origin:
-            beta = self.settings["origin_newmark_beta"].GetDouble()
-        else:
-            beta = self.settings["destination_newmark_beta"].GetDouble()
-
-        if abs(beta-0.25) < 1e-9:
-                system_matrix = self._GetSolverStrategy(solver_name).GetSystemMatrix()
-                self.feti_coupling.SetEffectiveStiffnessMatrixImplicit(system_matrix,solver_index)
-        else:
-            self.feti_coupling.SetEffectiveStiffnessMatrixExplicit(solver_index)
-
-    def _CreateLinearSolver(self):
-        linear_solver_configuration = self.settings["linear_solver_settings"]
-        if linear_solver_configuration.Has("solver_type"): # user specified a linear solver
-            return linear_solver_factory.ConstructSolver(linear_solver_configuration)
-        else:
-            KM.Logger.PrintInfo('::[FETISolver]:: No linear solver was specified, using fastest available solver')
-            return linear_solver_factory.CreateFastestAvailableDirectLinearSolver()
-
-    def _CalculateAndCheckTimestepRatio(self):
-        # Check timestep ratio is valid
-        timesteps = [0.0] * len(self._solver_delta_times)
-        for solver_index in range(self.settings["coupling_sequence"].size()):
-            ordered_solver_name = self.settings["coupling_sequence"][solver_index]["name"].GetString()
-            timesteps[solver_index] = self._solver_delta_times[ordered_solver_name]
-        timestep_ratio = timesteps[0] / timesteps[1]
-        if timestep_ratio < 0.99 or int(timestep_ratio) % timestep_ratio > 1E-12:
-            raise Exception("The timestep ratio between origin and destination domains is invalid. It must be a positive integer greater than 1.")
-        return timestep_ratio
-
-    def _GetSolverStrategy(self,solverName):
-        # This is a utility method to get access to the solver's strategy, later used to access the system matrix.
-        # Provision to expand to other solver wrappers in the future.
-        solver_type = str(self.solver_wrappers[solverName]._ClassName())
-        if solver_type == "StructuralMechanicsWrapper":
-            return self.solver_wrappers[solverName]._analysis_stage._GetSolver()._GetSolutionStrategy()
-        else:
-            raise Exception("_GetSolverStrategy not implemented for solver wrapper = " + solver_type)
-
-    def __CheckSolversCompatibility(self):
-        compatible_solver_wrappers = ['StructuralMechanicsWrapper']
-        for solver_name, solver in self.solver_wrappers.items():
-            solver_type = str(solver._ClassName())
-            if solver_type not in compatible_solver_wrappers:
-                raise Exception("The coupled solver '" + solver_type + "' is not yet compatible with the FETI coupling")
-
-    def __CreateOutputSolverDict(self):
-        # This function links each coupling output entry with a solver (if applicable)
-        # This means we can now apply SolverSolvesAtThisTime() to the coupling output
-        self.output_solver_dict = {}
-        for coupling_op_name in self.coupling_operations_dict.keys():
-            coupling_op_type = self.settings["coupling_operations"][coupling_op_name]["type"].GetString()
-            if coupling_op_type == "coupling_output":
-                coupling_output_solver_name = self.settings["coupling_operations"][coupling_op_name]["solver"].GetString()
-                self.output_solver_dict[coupling_op_name] = coupling_output_solver_name
-
-    def __CouplingOpActsNow(self,couplingOpName):
-        if couplingOpName in self.output_solver_dict:
-            solver_name = self.output_solver_dict[couplingOpName]
-            return self.SolverSolvesAtThisTime(solver_name)
-        else:
-            return True #only restrict coupling operations for outputs
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "origin_newmark_beta" : -1.0,
-            "origin_newmark_gamma" : -1.0,
-            "destination_newmark_beta" : -1.0,
-            "destination_newmark_gamma" : -1.0,
-            "equilibrium_variable" : "VELOCITY",
-            "is_disable_coupling" : false,
-            "is_linear" : false,
-            "linear_solver_settings" : {}
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-
-        return this_defaults
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+import KratosMultiphysics.MappingApplication as KratosMapping
+import KratosMultiphysics.CoSimulationApplication as CoSim
+
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupled_solver import CoSimulationCoupledSolver
+
+# Other imports
+from KratosMultiphysics import python_linear_solver_factory as linear_solver_factory
+
+def Create(settings, models, solver_name):
+    return FetiDynamicCoupledSolver(settings, models, solver_name)
+
+class FetiDynamicCoupledSolver(CoSimulationCoupledSolver):
+    def __init__(self, settings, models, solver_name):
+        super().__init__(settings, models, solver_name)
+
+        if len(self.solver_wrappers.items()) != 2:
+            raise Exception("FETI solver only works with two solvers!")
+
+        # Add solution step variables while models are empty
+        self.__CheckSolversCompatibility()
+        self.__AddNodalSolutionStepVariables()
+        self.is_initial_step = True
+
+    def Initialize(self):
+        super().Initialize()
+
+    def AdvanceInTime(self, current_time):
+        # The CoSimulation runs at the SMALLEST Timestep.
+        # The solver with the smallest timestep will dictate the CoSimulation.
+        # The solver(s) with the larger timesteps will be called only at times that match their time
+        advanced_time = current_time
+        self.departing_time = current_time # the time we are departing from - this is used to sync everything
+
+        if self.is_initial_step:
+            self._solver_delta_times = {}
+            advanced_time = 1E20
+            for solver_name, solver in self.solver_wrappers.items():
+                self._solver_delta_times[solver_name] = solver.AdvanceInTime(current_time)
+                advanced_time = min(advanced_time,self._solver_delta_times[solver_name])
+
+            self.is_initial_step = False
+
+            # Initialize the FETI utilites
+            self.__InitializeFetiMethod()
+        else:
+            for solver_name, solver in self.solver_wrappers.items():
+                if self.SolverSolvesAtThisTime(solver_name):
+                    solver_time = solver.AdvanceInTime(self.departing_time)
+                    if self._solver_origin_dest_dict[solver_name] == CoSim.FetiSolverIndexType.Destination:
+                        advanced_time = solver_time #only advance global time finely
+
+        if advanced_time == current_time:
+            raise Exception("No solvers advanced any timestep.")
+        else:
+            return advanced_time
+
+    def SolverSolvesAtThisTime(self, solver_name):
+        solver_delta_time = self._solver_delta_times[solver_name]
+        # the following only works if timesteps are multiple of each other
+        time_error = (self.departing_time % solver_delta_time)
+        if time_error < 1E-12 or abs(time_error - solver_delta_time) < 1E-12:
+            return True
+        else:
+            return False
+
+    def InitializeSolutionStep(self):
+        for solver_name, solver in self.solver_wrappers.items():
+            if self.SolverSolvesAtThisTime(solver_name):
+                solver.InitializeSolutionStep()
+
+        for coupling_op_name, coupling_op in self.coupling_operations_dict.items():
+            if self.__CouplingOpActsNow(coupling_op_name):
+                coupling_op.InitializeSolutionStep()
+
+    def Predict(self):
+        for solver_name, solver in self.solver_wrappers.items():
+            if self.SolverSolvesAtThisTime(solver_name):
+                solver.Predict()
+
+    def FinalizeSolutionStep(self):
+        for solver_name, solver in self.solver_wrappers.items():
+            if self.SolverSolvesAtThisTime(solver_name):
+                solver.FinalizeSolutionStep()
+
+        for coupling_op_name, coupling_op in self.coupling_operations_dict.items():
+            if self.__CouplingOpActsNow(coupling_op_name):
+                coupling_op.FinalizeSolutionStep()
+
+    def OutputSolutionStep(self):
+        for solver_name, solver in self.solver_wrappers.items():
+            if self.SolverSolvesAtThisTime(solver_name):
+                solver.OutputSolutionStep()
+
+    def SolveSolutionStep(self):
+        for coupling_op_name, coupling_op in self.coupling_operations_dict.items():
+            if self.__CouplingOpActsNow(coupling_op_name):
+                coupling_op.InitializeCouplingIteration()
+
+        for solver_name, solver in self.solver_wrappers.items():
+            if self.SolverSolvesAtThisTime(solver_name):
+                #self._SynchronizeInputData(solver_name) @phil not needed since corrections are applied within the feti cpp
+                solver.SolveSolutionStep()
+                #self._SynchronizeOutputData(solver_name) @phil not needed since corrections are applied within the feti cpp
+                self.__SendStiffnessMatrixToUtility(solver_name)
+
+        self.feti_coupling.EquilibrateDomains()
+
+        for coupling_op_name, coupling_op in self.coupling_operations_dict.items():
+            if self.__CouplingOpActsNow(coupling_op_name):
+                coupling_op.FinalizeCouplingIteration()
+
+        return True
+
+    def __AddNodalSolutionStepVariables(self):
+        for solver_name, solver in self.solver_wrappers.items():
+            structure = solver.model.GetModelPart("Structure")
+            structure.AddNodalSolutionStepVariable(KM.VECTOR_LAGRANGE_MULTIPLIER)
+
+    def __InitializeFetiMethod(self):
+        # Create vector of solver indices for convenience
+        self.__CreateSolverOriginDestDict()
+
+        # Check timestep ratio is valid and add to settings
+        timestep_ratio = self._CalculateAndCheckTimestepRatio()
+        self.settings.AddInt('timestep_ratio',int(timestep_ratio))
+
+        # get mapper parameters
+        self.mapper_parameters = self.data_transfer_operators_dict["mapper"].settings["mapper_settings"]
+        mapper_type = self.mapper_parameters["mapper_type"].GetString()
+
+        # get mapper origin and destination modelparts
+        origin_modelpart_name = self.mapper_parameters["modeler_parameters"]["origin_interface_sub_model_part_name"].GetString()
+        destination_modelpart_name = self.mapper_parameters["modeler_parameters"]["destination_interface_sub_model_part_name"].GetString()
+        for solver_name, solver in self.solver_wrappers.items():
+            if self._solver_origin_dest_dict[solver_name] == CoSim.FetiSolverIndexType.Origin:
+                self.model_part_origin_interface = self.solver_wrappers[solver_name].model.GetModelPart(origin_modelpart_name)
+            else:
+                self.model_part_destination_interface = self.solver_wrappers[solver_name].model.GetModelPart(destination_modelpart_name)
+
+        # manually create mapper
+        mapper_create_fct = KratosMapping.MapperFactory.CreateMapper
+        self.mapper = mapper_create_fct(self.model_part_origin_interface, self.model_part_destination_interface, self.mapper_parameters.Clone())
+
+        # get interface modelparts created by the mapper modeler
+        self.modelpart_interface_origin_from_mapper = self.mapper.GetInterfaceModelPartOrigin()
+        self.modelpart_interface_destination_from_mapper = self.mapper.GetInterfaceModelPartDestination()
+
+        # Create feti class instance
+        self.feti_coupling = CoSim.FetiDynamicCouplingUtilities(
+            self.modelpart_interface_origin_from_mapper,
+            self.modelpart_interface_destination_from_mapper,
+            self.settings)
+
+        # set the mapper
+        if mapper_type == "coupling_geometry":
+            self.feti_coupling.SetMappingMatrix(self.mapper.GetMappingMatrix())
+        else:
+            raise Exception("Dynamic coupled solver currently only compatible with the coupling_geometry mapper.")
+
+        # The origin and destination interfaces from the mapper submitted above are both
+        # stored within the origin modelpart. Now we submit the 'original' origin and destination
+        # interface model parts stored on the origin and destination models to get access to the
+        # origin and destination models.
+        self.feti_coupling.SetOriginAndDestinationDomainsWithInterfaceModelParts(
+            self.model_part_origin_interface,
+            self.model_part_destination_interface)
+
+        # create the solver
+        linear_solver = self._CreateLinearSolver()
+        self.feti_coupling.SetLinearSolver(linear_solver)
+
+        # Set origin initial velocities
+        self.feti_coupling.SetOriginInitialKinematics()
+
+        # Create output-solver relation dict to ensure mixed timestep ouput is handled properly
+        self.__CreateOutputSolverDict()
+
+    def __CreateSolverOriginDestDict(self):
+        self._solver_origin_dest_dict = {}
+        for solver_index in range(self.settings["coupling_sequence"].size()):
+            ordered_solver_name = self.settings["coupling_sequence"][solver_index]["name"].GetString()
+            if solver_index == 0:
+                self._solver_origin_dest_dict[ordered_solver_name] = CoSim.FetiSolverIndexType.Origin
+            else:
+                self._solver_origin_dest_dict[ordered_solver_name] = CoSim.FetiSolverIndexType.Destination
+
+    def __SendStiffnessMatrixToUtility(self, solver_name):
+        beta = 0.0
+        solver_index = self._solver_origin_dest_dict[solver_name]
+        if solver_index == CoSim.FetiSolverIndexType.Origin:
+            beta = self.settings["origin_newmark_beta"].GetDouble()
+        else:
+            beta = self.settings["destination_newmark_beta"].GetDouble()
+
+        if abs(beta-0.25) < 1e-9:
+                system_matrix = self._GetSolverStrategy(solver_name).GetSystemMatrix()
+                self.feti_coupling.SetEffectiveStiffnessMatrixImplicit(system_matrix,solver_index)
+        else:
+            self.feti_coupling.SetEffectiveStiffnessMatrixExplicit(solver_index)
+
+    def _CreateLinearSolver(self):
+        linear_solver_configuration = self.settings["linear_solver_settings"]
+        if linear_solver_configuration.Has("solver_type"): # user specified a linear solver
+            return linear_solver_factory.ConstructSolver(linear_solver_configuration)
+        else:
+            KM.Logger.PrintInfo('::[FETISolver]:: No linear solver was specified, using fastest available solver')
+            return linear_solver_factory.CreateFastestAvailableDirectLinearSolver()
+
+    def _CalculateAndCheckTimestepRatio(self):
+        # Check timestep ratio is valid
+        timesteps = [0.0] * len(self._solver_delta_times)
+        for solver_index in range(self.settings["coupling_sequence"].size()):
+            ordered_solver_name = self.settings["coupling_sequence"][solver_index]["name"].GetString()
+            timesteps[solver_index] = self._solver_delta_times[ordered_solver_name]
+        timestep_ratio = timesteps[0] / timesteps[1]
+        if timestep_ratio < 0.99 or int(timestep_ratio) % timestep_ratio > 1E-12:
+            raise Exception("The timestep ratio between origin and destination domains is invalid. It must be a positive integer greater than 1.")
+        return timestep_ratio
+
+    def _GetSolverStrategy(self,solverName):
+        # This is a utility method to get access to the solver's strategy, later used to access the system matrix.
+        # Provision to expand to other solver wrappers in the future.
+        solver_type = str(self.solver_wrappers[solverName]._ClassName())
+        if solver_type == "StructuralMechanicsWrapper":
+            return self.solver_wrappers[solverName]._analysis_stage._GetSolver()._GetSolutionStrategy()
+        else:
+            raise Exception("_GetSolverStrategy not implemented for solver wrapper = " + solver_type)
+
+    def __CheckSolversCompatibility(self):
+        compatible_solver_wrappers = ['StructuralMechanicsWrapper']
+        for solver_name, solver in self.solver_wrappers.items():
+            solver_type = str(solver._ClassName())
+            if solver_type not in compatible_solver_wrappers:
+                raise Exception("The coupled solver '" + solver_type + "' is not yet compatible with the FETI coupling")
+
+    def __CreateOutputSolverDict(self):
+        # This function links each coupling output entry with a solver (if applicable)
+        # This means we can now apply SolverSolvesAtThisTime() to the coupling output
+        self.output_solver_dict = {}
+        for coupling_op_name in self.coupling_operations_dict.keys():
+            coupling_op_type = self.settings["coupling_operations"][coupling_op_name]["type"].GetString()
+            if coupling_op_type == "coupling_output":
+                coupling_output_solver_name = self.settings["coupling_operations"][coupling_op_name]["solver"].GetString()
+                self.output_solver_dict[coupling_op_name] = coupling_output_solver_name
+
+    def __CouplingOpActsNow(self,couplingOpName):
+        if couplingOpName in self.output_solver_dict:
+            solver_name = self.output_solver_dict[couplingOpName]
+            return self.SolverSolvesAtThisTime(solver_name)
+        else:
+            return True #only restrict coupling operations for outputs
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "origin_newmark_beta" : -1.0,
+            "origin_newmark_gamma" : -1.0,
+            "destination_newmark_beta" : -1.0,
+            "destination_newmark_gamma" : -1.0,
+            "equilibrium_variable" : "VELOCITY",
+            "is_disable_coupling" : false,
+            "is_linear" : false,
+            "linear_solver_settings" : {}
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+
+        return this_defaults
```

## KratosMultiphysics/CoSimulationApplication/coupled_solvers/gauss_seidel_weak.py

 * *Ordering differences only*

```diff
@@ -1,20 +1,20 @@
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupled_solver import CoSimulationCoupledSolver
-
-def Create(settings, models, solver_name):
-    return GaussSeidelWeakCoupledSolver(settings, models, solver_name)
-
-class GaussSeidelWeakCoupledSolver(CoSimulationCoupledSolver):
-    def SolveSolutionStep(self):
-        for coupling_op in self.coupling_operations_dict.values():
-            coupling_op.InitializeCouplingIteration()
-
-        for solver_name, solver in self.solver_wrappers.items():
-            self._SynchronizeInputData(solver_name)
-            solver.SolveSolutionStep()
-            self._SynchronizeOutputData(solver_name)
-
-        for coupling_op in self.coupling_operations_dict.values():
-            coupling_op.FinalizeCouplingIteration()
-
-        return True
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_coupled_solver import CoSimulationCoupledSolver
+
+def Create(settings, models, solver_name):
+    return GaussSeidelWeakCoupledSolver(settings, models, solver_name)
+
+class GaussSeidelWeakCoupledSolver(CoSimulationCoupledSolver):
+    def SolveSolutionStep(self):
+        for coupling_op in self.coupling_operations_dict.values():
+            coupling_op.InitializeCouplingIteration()
+
+        for solver_name, solver in self.solver_wrappers.items():
+            self._SynchronizeInputData(solver_name)
+            solver.SolveSolutionStep()
+            self._SynchronizeOutputData(solver_name)
+
+        for coupling_op in self.coupling_operations_dict.values():
+            coupling_op.FinalizeCouplingIteration()
+
+        return True
```

## KratosMultiphysics/CoSimulationApplication/data_transfer_operators/copy.py

 * *Ordering differences only*

```diff
@@ -1,30 +1,30 @@
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_data_transfer_operator import CoSimulationDataTransferOperator
-
-def Create(*args):
-    return CopyDataTransferOperator(*args)
-
-class CopyDataTransferOperator(CoSimulationDataTransferOperator):
-    """DataTransferOperator that copies values from one interface to another, without any checks
-    """
-    def _ExecuteTransferData(self, from_solver_data, to_solver_data, transfer_options):
-        from_solver_data_size = from_solver_data.Size()
-        to_solver_data_size = to_solver_data.Size()
-        if not from_solver_data_size == to_solver_data_size:
-            raise Exception('The sizes of the data are not matching: {} != {} for interface data "{}" of solver "{}" and interface data "{}" of solver "{}"!'.format(from_solver_data_size, to_solver_data_size, from_solver_data.name, from_solver_data.solver_name, to_solver_data.name, to_solver_data.solver_name))
-
-        from_solver_data_array = from_solver_data.GetData()
-
-        transfer_options_list = transfer_options.GetStringArray()
-
-        # the order is IMPORTANT here!
-        if "swap_sign" in transfer_options_list:
-            from_solver_data_array *= (-1)
-        if "add_values" in transfer_options.GetStringArray():
-            from_solver_data_array += to_solver_data.GetData()
-
-        to_solver_data.SetData(from_solver_data_array)
-
-    @classmethod
-    def _GetListAvailableTransferOptions(cls):
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_data_transfer_operator import CoSimulationDataTransferOperator
+
+def Create(*args):
+    return CopyDataTransferOperator(*args)
+
+class CopyDataTransferOperator(CoSimulationDataTransferOperator):
+    """DataTransferOperator that copies values from one interface to another, without any checks
+    """
+    def _ExecuteTransferData(self, from_solver_data, to_solver_data, transfer_options):
+        from_solver_data_size = from_solver_data.Size()
+        to_solver_data_size = to_solver_data.Size()
+        if not from_solver_data_size == to_solver_data_size:
+            raise Exception('The sizes of the data are not matching: {} != {} for interface data "{}" of solver "{}" and interface data "{}" of solver "{}"!'.format(from_solver_data_size, to_solver_data_size, from_solver_data.name, from_solver_data.solver_name, to_solver_data.name, to_solver_data.solver_name))
+
+        from_solver_data_array = from_solver_data.GetData()
+
+        transfer_options_list = transfer_options.GetStringArray()
+
+        # the order is IMPORTANT here!
+        if "swap_sign" in transfer_options_list:
+            from_solver_data_array *= (-1)
+        if "add_values" in transfer_options.GetStringArray():
+            from_solver_data_array += to_solver_data.GetData()
+
+        to_solver_data.SetData(from_solver_data_array)
+
+    @classmethod
+    def _GetListAvailableTransferOptions(cls):
         return ["swap_sign", "add_values"]
```

## KratosMultiphysics/CoSimulationApplication/data_transfer_operators/sum_distributed_to_single.py

 * *Ordering differences only*

```diff
@@ -1,48 +1,48 @@
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_data_transfer_operator import CoSimulationDataTransferOperator
-
-# Other imports
-import numpy as np
-
-def Create(*args):
-    return SumDistributedToSingle(*args)
-
-class SumDistributedToSingle(CoSimulationDataTransferOperator):
-    """DataTransferOperator to sum values on one interface and put it to another interface.
-    Used e.g. for FSI with SDof, where the loads on the fluid interface are summed up and set to the SDof interface
-    """
-    def _ExecuteTransferData(self, from_solver_data, to_solver_data, transfer_options):
-        if not from_solver_data.IsDefinedOnThisRank():
-            return
-
-        data_array = from_solver_data.GetData()
-
-        value = data_array.sum()
-        value = from_solver_data.GetModelPart().GetCommunicator().GetDataCommunicator().Sum(value, 0)
-        summed_data_array = np.array([value])
-
-        if not to_solver_data.IsDefinedOnThisRank():
-            return
-
-        if to_solver_data.IsDistributed():
-            raise Exception("The destination if the data cannot be distributed!")
-
-        to_solver_data_size = to_solver_data.Size()
-        if not to_solver_data_size == 1:
-            raise Exception('Interface data "{}" of solver "{}" requires to be of size 1, got: {}'.format(to_solver_data.name, to_solver_data.solver_name, to_solver_data_size))
-
-        # the order is IMPORTANT here!
-        if "swap_sign" in transfer_options.GetStringArray():
-            summed_data_array *= (-1)
-        if "add_values" in transfer_options.GetStringArray():
-            summed_data_array += to_solver_data.GetData()
-
-        to_solver_data.SetData(summed_data_array)
-
-    def _Check(self, from_solver_data, to_solver_data):
-        if not from_solver_data.is_scalar_variable:
-            raise Exception('Variable of interface data "{}" of solver "{}" has to be a scalar!'.format(from_solver_data.name, from_solver_data.solver_name))
-
-    @classmethod
-    def _GetListAvailableTransferOptions(cls):
-        return ["swap_sign", "add_values"]
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_data_transfer_operator import CoSimulationDataTransferOperator
+
+# Other imports
+import numpy as np
+
+def Create(*args):
+    return SumDistributedToSingle(*args)
+
+class SumDistributedToSingle(CoSimulationDataTransferOperator):
+    """DataTransferOperator to sum values on one interface and put it to another interface.
+    Used e.g. for FSI with SDof, where the loads on the fluid interface are summed up and set to the SDof interface
+    """
+    def _ExecuteTransferData(self, from_solver_data, to_solver_data, transfer_options):
+        if not from_solver_data.IsDefinedOnThisRank():
+            return
+
+        data_array = from_solver_data.GetData()
+
+        value = data_array.sum()
+        value = from_solver_data.GetModelPart().GetCommunicator().GetDataCommunicator().Sum(value, 0)
+        summed_data_array = np.array([value])
+
+        if not to_solver_data.IsDefinedOnThisRank():
+            return
+
+        if to_solver_data.IsDistributed():
+            raise Exception("The destination if the data cannot be distributed!")
+
+        to_solver_data_size = to_solver_data.Size()
+        if not to_solver_data_size == 1:
+            raise Exception('Interface data "{}" of solver "{}" requires to be of size 1, got: {}'.format(to_solver_data.name, to_solver_data.solver_name, to_solver_data_size))
+
+        # the order is IMPORTANT here!
+        if "swap_sign" in transfer_options.GetStringArray():
+            summed_data_array *= (-1)
+        if "add_values" in transfer_options.GetStringArray():
+            summed_data_array += to_solver_data.GetData()
+
+        to_solver_data.SetData(summed_data_array)
+
+    def _Check(self, from_solver_data, to_solver_data):
+        if not from_solver_data.is_scalar_variable:
+            raise Exception('Variable of interface data "{}" of solver "{}" has to be a scalar!'.format(from_solver_data.name, from_solver_data.solver_name))
+
+    @classmethod
+    def _GetListAvailableTransferOptions(cls):
+        return ["swap_sign", "add_values"]
```

## KratosMultiphysics/CoSimulationApplication/data_transfer_operators/sum_many_to_many.py

 * *Ordering differences only*

```diff
@@ -1,50 +1,50 @@
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_data_transfer_operator import CoSimulationDataTransferOperator
-
-def Create(*args):
-    return SumManyToMany(*args)
-
-class SumManyToMany(CoSimulationDataTransferOperator):
-    """DataTransferOperator to sum values on one interface and put it to another interface, if desired equally distributed.    
-    """
-
-    def _ExecuteTransferData(self, from_solver_data, to_solver_data, transfer_options):
-        if not from_solver_data.IsDefinedOnThisRank():
-            return
-
-        data_values = from_solver_data.GetData()
-        data_value = data_values.sum()        
-
-        if from_solver_data.IsDistributed():
-            data_value = self.data_communicator.SumAll(data_value)       
-
-        if not to_solver_data.IsDefinedOnThisRank():
-            return
-
-        to_solver_values = to_solver_data.GetData()
-        to_solver_values.fill(data_value)        
-
-        # the order is IMPORTANT here!
-        if "swap_sign" in transfer_options.GetStringArray():
-            to_solver_values *= (-1)
-        if "distribute_values" in transfer_options.GetStringArray():
-            to_solver_values /= self.data_communicator.SumAll(to_solver_data.Size())
-        if "add_values" in transfer_options.GetStringArray():
-            to_solver_values += to_solver_data.GetData()
-
-        to_solver_data.SetData(to_solver_values)
-
-    def _Check(self, from_solver_data, to_solver_data):
-        # check the from_solver_data
-        if from_solver_data.IsDefinedOnThisRank():
-            if not from_solver_data.is_scalar_variable:
-                raise Exception('Variable of interface data "{}" of solver "{}" has to be a scalar!'.format(from_solver_data.name, from_solver_data.solver_name))
-
-        # check the to_solver_data
-        if to_solver_data.IsDefinedOnThisRank():
-            if not to_solver_data.is_scalar_variable:
-                raise Exception('Variable of interface data "{}" of solver "{}" has to be a scalar!'.format(to_solver_data.name, to_solver_data.solver_name))
-
-    @classmethod
-    def _GetListAvailableTransferOptions(cls):
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_data_transfer_operator import CoSimulationDataTransferOperator
+
+def Create(*args):
+    return SumManyToMany(*args)
+
+class SumManyToMany(CoSimulationDataTransferOperator):
+    """DataTransferOperator to sum values on one interface and put it to another interface, if desired equally distributed.    
+    """
+
+    def _ExecuteTransferData(self, from_solver_data, to_solver_data, transfer_options):
+        if not from_solver_data.IsDefinedOnThisRank():
+            return
+
+        data_values = from_solver_data.GetData()
+        data_value = data_values.sum()        
+
+        if from_solver_data.IsDistributed():
+            data_value = self.data_communicator.SumAll(data_value)       
+
+        if not to_solver_data.IsDefinedOnThisRank():
+            return
+
+        to_solver_values = to_solver_data.GetData()
+        to_solver_values.fill(data_value)        
+
+        # the order is IMPORTANT here!
+        if "swap_sign" in transfer_options.GetStringArray():
+            to_solver_values *= (-1)
+        if "distribute_values" in transfer_options.GetStringArray():
+            to_solver_values /= self.data_communicator.SumAll(to_solver_data.Size())
+        if "add_values" in transfer_options.GetStringArray():
+            to_solver_values += to_solver_data.GetData()
+
+        to_solver_data.SetData(to_solver_values)
+
+    def _Check(self, from_solver_data, to_solver_data):
+        # check the from_solver_data
+        if from_solver_data.IsDefinedOnThisRank():
+            if not from_solver_data.is_scalar_variable:
+                raise Exception('Variable of interface data "{}" of solver "{}" has to be a scalar!'.format(from_solver_data.name, from_solver_data.solver_name))
+
+        # check the to_solver_data
+        if to_solver_data.IsDefinedOnThisRank():
+            if not to_solver_data.is_scalar_variable:
+                raise Exception('Variable of interface data "{}" of solver "{}" has to be a scalar!'.format(to_solver_data.name, to_solver_data.solver_name))
+
+    @classmethod
+    def _GetListAvailableTransferOptions(cls):
         return ["swap_sign", "distribute_values", "add_values"]
```

## KratosMultiphysics/CoSimulationApplication/data_transfer_operators/copy_single_to_distributed.py

 * *Ordering differences only*

```diff
@@ -1,6 +1,6 @@
-from KratosMultiphysics.kratos_utilities import IssueDeprecationWarning
-from . import transfer_one_to_many
-
-def Create(*args):
-    IssueDeprecationWarning('CopySingleToDistributed', 'please use "transfer_one_to_many" instead')
-    return transfer_one_to_many.TransferOneToMany(*args)
+from KratosMultiphysics.kratos_utilities import IssueDeprecationWarning
+from . import transfer_one_to_many
+
+def Create(*args):
+    IssueDeprecationWarning('CopySingleToDistributed', 'please use "transfer_one_to_many" instead')
+    return transfer_one_to_many.TransferOneToMany(*args)
```

## KratosMultiphysics/CoSimulationApplication/data_transfer_operators/transfer_one_to_many.py

 * *Ordering differences only*

```diff
@@ -1,58 +1,58 @@
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_data_transfer_operator import CoSimulationDataTransferOperator
-
-def Create(*args):
-    return TransferOneToMany(*args)
-
-class TransferOneToMany(CoSimulationDataTransferOperator):
-    """DataTransferOperator to take one single value and set it to all values on another interface.
-    Used e.g. for FSI with SDof, where the SDof has one value and the fluid interface has many
-    """
-    def _ExecuteTransferData(self, from_solver_data, to_solver_data, transfer_options):
-        data_value = 0.0
-        if from_solver_data.IsDefinedOnThisRank():
-            data_values = from_solver_data.GetData()
-            if data_values.size == 1: # this is the rank that actually contains the value
-                data_value = data_values[0]
-
-        data_value = self.data_communicator.SumAll(data_value)
-
-        if not to_solver_data.IsDefinedOnThisRank():
-            return
-
-        to_solver_values = to_solver_data.GetData()
-        to_solver_values.fill(data_value)
-
-        # the order is IMPORTANT here!
-        if "swap_sign" in transfer_options.GetStringArray():
-            to_solver_values *= (-1)
-        if "distribute_values" in transfer_options.GetStringArray():
-            to_solver_values /= self.data_communicator.SumAll(to_solver_data.Size())
-        if "add_values" in transfer_options.GetStringArray():
-            to_solver_values += to_solver_data.GetData()
-
-        to_solver_data.SetData(to_solver_values)
-
-    def _Check(self, from_solver_data, to_solver_data):
-        # check the from_solver_data
-        if from_solver_data.IsDefinedOnThisRank():
-            if not from_solver_data.is_scalar_variable:
-                raise Exception('Variable of interface data "{}" of solver "{}" has to be a scalar!'.format(from_solver_data.name, from_solver_data.solver_name))
-
-        # make sure there is only one value
-        if from_solver_data.IsDefinedOnThisRank():
-            data_size = from_solver_data.Size()
-            if from_solver_data.IsDistributed():
-                data_size = from_solver_data.GetModelPart().GetCommunicator().GetDataCommunicator().SumAll(data_size)
-
-            if not data_size == 1:
-                raise Exception('Interface data "{}" of solver "{}" requires to be of size 1, got: {}'.format(from_solver_data.name, from_solver_data.solver_name, data_size))
-
-        # check the to_solver_data
-        if to_solver_data.IsDefinedOnThisRank():
-            if not to_solver_data.is_scalar_variable:
-                raise Exception('Variable of interface data "{}" of solver "{}" has to be a scalar!'.format(to_solver_data.name, to_solver_data.solver_name))
-
-    @classmethod
-    def _GetListAvailableTransferOptions(cls):
-        return ["swap_sign", "distribute_values", "add_values"]
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_data_transfer_operator import CoSimulationDataTransferOperator
+
+def Create(*args):
+    return TransferOneToMany(*args)
+
+class TransferOneToMany(CoSimulationDataTransferOperator):
+    """DataTransferOperator to take one single value and set it to all values on another interface.
+    Used e.g. for FSI with SDof, where the SDof has one value and the fluid interface has many
+    """
+    def _ExecuteTransferData(self, from_solver_data, to_solver_data, transfer_options):
+        data_value = 0.0
+        if from_solver_data.IsDefinedOnThisRank():
+            data_values = from_solver_data.GetData()
+            if data_values.size == 1: # this is the rank that actually contains the value
+                data_value = data_values[0]
+
+        data_value = self.data_communicator.SumAll(data_value)
+
+        if not to_solver_data.IsDefinedOnThisRank():
+            return
+
+        to_solver_values = to_solver_data.GetData()
+        to_solver_values.fill(data_value)
+
+        # the order is IMPORTANT here!
+        if "swap_sign" in transfer_options.GetStringArray():
+            to_solver_values *= (-1)
+        if "distribute_values" in transfer_options.GetStringArray():
+            to_solver_values /= self.data_communicator.SumAll(to_solver_data.Size())
+        if "add_values" in transfer_options.GetStringArray():
+            to_solver_values += to_solver_data.GetData()
+
+        to_solver_data.SetData(to_solver_values)
+
+    def _Check(self, from_solver_data, to_solver_data):
+        # check the from_solver_data
+        if from_solver_data.IsDefinedOnThisRank():
+            if not from_solver_data.is_scalar_variable:
+                raise Exception('Variable of interface data "{}" of solver "{}" has to be a scalar!'.format(from_solver_data.name, from_solver_data.solver_name))
+
+        # make sure there is only one value
+        if from_solver_data.IsDefinedOnThisRank():
+            data_size = from_solver_data.Size()
+            if from_solver_data.IsDistributed():
+                data_size = from_solver_data.GetModelPart().GetCommunicator().GetDataCommunicator().SumAll(data_size)
+
+            if not data_size == 1:
+                raise Exception('Interface data "{}" of solver "{}" requires to be of size 1, got: {}'.format(from_solver_data.name, from_solver_data.solver_name, data_size))
+
+        # check the to_solver_data
+        if to_solver_data.IsDefinedOnThisRank():
+            if not to_solver_data.is_scalar_variable:
+                raise Exception('Variable of interface data "{}" of solver "{}" has to be a scalar!'.format(to_solver_data.name, to_solver_data.solver_name))
+
+    @classmethod
+    def _GetListAvailableTransferOptions(cls):
+        return ["swap_sign", "distribute_values", "add_values"]
```

## KratosMultiphysics/CoSimulationApplication/data_transfer_operators/kratos_mapping.py

 * *Ordering differences only*

```diff
@@ -1,142 +1,142 @@
-# Importing the base class
-from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_data_transfer_operator import CoSimulationDataTransferOperator
-
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-from KratosMultiphysics.MappingApplication import python_mapper_factory
-
-# CoSimulation imports
-import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
-import KratosMultiphysics.CoSimulationApplication.colors as colors
-
-# other imports
-from KratosMultiphysics.CoSimulationApplication.utilities import data_communicator_utilities
-from time import time
-
-def Create(*args):
-    return KratosMappingDataTransferOperator(*args)
-
-class KratosMappingDataTransferOperator(CoSimulationDataTransferOperator):
-    """DataTransferOperator that maps values from one interface (ModelPart) to another.
-    The mappers of the Kratos-MappingApplication are used
-    """
-    # currently available mapper-flags aka transfer-options
-    __mapper_flags_dict = {
-        "add_values"    : KM.Mapper.ADD_VALUES,
-        "swap_sign"     : KM.Mapper.SWAP_SIGN,
-        "use_transpose" : KM.Mapper.USE_TRANSPOSE
-    }
-
-    # initializing the static members necessary for MPI
-    # initializing on the fly does not work and leads to memory problems
-    # as the members are not proberly saved and randomly destucted!
-    __dummy_model = None
-    __rank_zero_model_part = None
-
-    def __init__(self, settings, parent_coupled_solver_data_communicator):
-        if not settings.Has("mapper_settings"):
-            raise Exception('No "mapper_settings" provided!')
-        super().__init__(settings, parent_coupled_solver_data_communicator)
-        self.__mappers = {}
-
-    def _ExecuteTransferData(self, from_solver_data, to_solver_data, transfer_options):
-        model_part_origin_name = from_solver_data.model_part_name
-        variable_origin        = from_solver_data.variable
-        identifier_origin      = from_solver_data.solver_name + "." + model_part_origin_name
-
-        model_part_destination_name = to_solver_data.model_part_name
-        variable_destination        = to_solver_data.variable
-        identifier_destination      = to_solver_data.solver_name + "." + model_part_destination_name
-
-        mapper_flags = self.__GetMapperFlags(transfer_options, from_solver_data, to_solver_data)
-
-        identifier_tuple         = (identifier_origin, identifier_destination)
-        inverse_identifier_tuple = (identifier_destination, identifier_origin)
-
-        if identifier_tuple in self.__mappers:
-            self.__mappers[identifier_tuple].Map(variable_origin, variable_destination, mapper_flags)
-        elif inverse_identifier_tuple in self.__mappers:
-            self.__mappers[inverse_identifier_tuple].InverseMap(variable_destination, variable_origin, mapper_flags)
-        else:
-            model_part_origin      = self.__GetModelPartFromInterfaceData(from_solver_data)
-            model_part_destination = self.__GetModelPartFromInterfaceData(to_solver_data)
-
-            if model_part_origin.IsDistributed() or model_part_destination.IsDistributed():
-                mapper_create_fct = python_mapper_factory.CreateMPIMapper
-            else:
-                mapper_create_fct = python_mapper_factory.CreateMapper
-
-            if self.echo_level > 0:
-                info_msg  = "Creating Mapper:\n"
-                info_msg += '    Origin: ModelPart "{}" of solver "{}"\n'.format(model_part_origin_name, from_solver_data.solver_name)
-                info_msg += '    Destination: ModelPart "{}" of solver "{}"'.format(model_part_destination_name, to_solver_data.solver_name)
-
-                cs_tools.cs_print_info(colors.bold(self._ClassName()), info_msg)
-
-            mapper_creation_start_time = time()
-            self.__mappers[identifier_tuple] = mapper_create_fct(model_part_origin, model_part_destination, self.settings["mapper_settings"].Clone()) # Clone is necessary because the settings are validated and defaults assigned, which could influence the creation of other mappers
-
-            if self.echo_level > 2:
-                cs_tools.cs_print_info(colors.bold(self._ClassName()), "Creating Mapper took: {0:.{1}f} [s]".format(time()-mapper_creation_start_time,2))
-            self.__mappers[identifier_tuple].Map(variable_origin, variable_destination, mapper_flags)
-
-    def _Check(self, from_solver_data, to_solver_data):
-        def CheckData(data_to_check):
-            if "node" not in data_to_check.location:
-                raise Exception('Mapping only supports nodal values!"{}"\nChecking ModelPart "{}" of solver "{}"'.format(self._ClassName(), data_to_check.model_part_name, data_to_check.solver_name))
-
-        CheckData(from_solver_data)
-        CheckData(to_solver_data)
-
-    @classmethod
-    def _GetDefaultParameters(cls):
-        this_defaults = KM.Parameters("""{
-            "mapper_settings" : {
-                "mapper_type" : "UNSPECIFIED"
-            }
-        }""")
-        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
-        return this_defaults
-
-    @classmethod
-    def _GetListAvailableTransferOptions(cls):
-        return cls.__mapper_flags_dict.keys()
-
-    def __GetMapperFlags(self, transfer_options, from_solver_data, to_solver_data):
-        mapper_flags = KM.Flags()
-        for flag_name in transfer_options.GetStringArray():
-            mapper_flags |= self.__mapper_flags_dict[flag_name]
-        if from_solver_data.location == "node_non_historical":
-            mapper_flags |= KM.Mapper.FROM_NON_HISTORICAL
-        if to_solver_data.location == "node_non_historical":
-            mapper_flags |= KM.Mapper.TO_NON_HISTORICAL
-
-        return mapper_flags
-
-    @staticmethod
-    def __GetModelPartFromInterfaceData(interface_data):
-        """If the solver does not exist on this rank, then pass a
-        dummy ModelPart to the Mapper that has a DataCommunicator
-        that is not defined on this rank
-        """
-        if interface_data.IsDefinedOnThisRank():
-            return interface_data.GetModelPart()
-        else:
-            return KratosMappingDataTransferOperator.__GetRankZeroModelPart()
-
-    @staticmethod
-    def __GetRankZeroModelPart():
-        if not KM.IsDistributedRun():
-            raise Exception("This function can only be called when Kratos is running in MPI!")
-
-        if KratosMappingDataTransferOperator.__rank_zero_model_part is None:
-            model = KM.Model()
-            rank_zero_model_part = model.CreateModelPart("rank_zero")
-
-            from KratosMultiphysics.mpi import ModelPartCommunicatorUtilities
-            ModelPartCommunicatorUtilities.SetMPICommunicator(rank_zero_model_part, data_communicator_utilities.GetRankZeroDataCommunicator())
-
-            KratosMappingDataTransferOperator.__dummy_model = model
-            KratosMappingDataTransferOperator.__rank_zero_model_part = rank_zero_model_part
-
-        return KratosMappingDataTransferOperator.__rank_zero_model_part
+# Importing the base class
+from KratosMultiphysics.CoSimulationApplication.base_classes.co_simulation_data_transfer_operator import CoSimulationDataTransferOperator
+
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+from KratosMultiphysics.MappingApplication import python_mapper_factory
+
+# CoSimulation imports
+import KratosMultiphysics.CoSimulationApplication.co_simulation_tools as cs_tools
+import KratosMultiphysics.CoSimulationApplication.colors as colors
+
+# other imports
+from KratosMultiphysics.CoSimulationApplication.utilities import data_communicator_utilities
+from time import time
+
+def Create(*args):
+    return KratosMappingDataTransferOperator(*args)
+
+class KratosMappingDataTransferOperator(CoSimulationDataTransferOperator):
+    """DataTransferOperator that maps values from one interface (ModelPart) to another.
+    The mappers of the Kratos-MappingApplication are used
+    """
+    # currently available mapper-flags aka transfer-options
+    __mapper_flags_dict = {
+        "add_values"    : KM.Mapper.ADD_VALUES,
+        "swap_sign"     : KM.Mapper.SWAP_SIGN,
+        "use_transpose" : KM.Mapper.USE_TRANSPOSE
+    }
+
+    # initializing the static members necessary for MPI
+    # initializing on the fly does not work and leads to memory problems
+    # as the members are not proberly saved and randomly destucted!
+    __dummy_model = None
+    __rank_zero_model_part = None
+
+    def __init__(self, settings, parent_coupled_solver_data_communicator):
+        if not settings.Has("mapper_settings"):
+            raise Exception('No "mapper_settings" provided!')
+        super().__init__(settings, parent_coupled_solver_data_communicator)
+        self.__mappers = {}
+
+    def _ExecuteTransferData(self, from_solver_data, to_solver_data, transfer_options):
+        model_part_origin_name = from_solver_data.model_part_name
+        variable_origin        = from_solver_data.variable
+        identifier_origin      = from_solver_data.solver_name + "." + model_part_origin_name
+
+        model_part_destination_name = to_solver_data.model_part_name
+        variable_destination        = to_solver_data.variable
+        identifier_destination      = to_solver_data.solver_name + "." + model_part_destination_name
+
+        mapper_flags = self.__GetMapperFlags(transfer_options, from_solver_data, to_solver_data)
+
+        identifier_tuple         = (identifier_origin, identifier_destination)
+        inverse_identifier_tuple = (identifier_destination, identifier_origin)
+
+        if identifier_tuple in self.__mappers:
+            self.__mappers[identifier_tuple].Map(variable_origin, variable_destination, mapper_flags)
+        elif inverse_identifier_tuple in self.__mappers:
+            self.__mappers[inverse_identifier_tuple].InverseMap(variable_destination, variable_origin, mapper_flags)
+        else:
+            model_part_origin      = self.__GetModelPartFromInterfaceData(from_solver_data)
+            model_part_destination = self.__GetModelPartFromInterfaceData(to_solver_data)
+
+            if model_part_origin.IsDistributed() or model_part_destination.IsDistributed():
+                mapper_create_fct = python_mapper_factory.CreateMPIMapper
+            else:
+                mapper_create_fct = python_mapper_factory.CreateMapper
+
+            if self.echo_level > 0:
+                info_msg  = "Creating Mapper:\n"
+                info_msg += '    Origin: ModelPart "{}" of solver "{}"\n'.format(model_part_origin_name, from_solver_data.solver_name)
+                info_msg += '    Destination: ModelPart "{}" of solver "{}"'.format(model_part_destination_name, to_solver_data.solver_name)
+
+                cs_tools.cs_print_info(colors.bold(self._ClassName()), info_msg)
+
+            mapper_creation_start_time = time()
+            self.__mappers[identifier_tuple] = mapper_create_fct(model_part_origin, model_part_destination, self.settings["mapper_settings"].Clone()) # Clone is necessary because the settings are validated and defaults assigned, which could influence the creation of other mappers
+
+            if self.echo_level > 2:
+                cs_tools.cs_print_info(colors.bold(self._ClassName()), "Creating Mapper took: {0:.{1}f} [s]".format(time()-mapper_creation_start_time,2))
+            self.__mappers[identifier_tuple].Map(variable_origin, variable_destination, mapper_flags)
+
+    def _Check(self, from_solver_data, to_solver_data):
+        def CheckData(data_to_check):
+            if "node" not in data_to_check.location:
+                raise Exception('Mapping only supports nodal values!"{}"\nChecking ModelPart "{}" of solver "{}"'.format(self._ClassName(), data_to_check.model_part_name, data_to_check.solver_name))
+
+        CheckData(from_solver_data)
+        CheckData(to_solver_data)
+
+    @classmethod
+    def _GetDefaultParameters(cls):
+        this_defaults = KM.Parameters("""{
+            "mapper_settings" : {
+                "mapper_type" : "UNSPECIFIED"
+            }
+        }""")
+        this_defaults.AddMissingParameters(super()._GetDefaultParameters())
+        return this_defaults
+
+    @classmethod
+    def _GetListAvailableTransferOptions(cls):
+        return cls.__mapper_flags_dict.keys()
+
+    def __GetMapperFlags(self, transfer_options, from_solver_data, to_solver_data):
+        mapper_flags = KM.Flags()
+        for flag_name in transfer_options.GetStringArray():
+            mapper_flags |= self.__mapper_flags_dict[flag_name]
+        if from_solver_data.location == "node_non_historical":
+            mapper_flags |= KM.Mapper.FROM_NON_HISTORICAL
+        if to_solver_data.location == "node_non_historical":
+            mapper_flags |= KM.Mapper.TO_NON_HISTORICAL
+
+        return mapper_flags
+
+    @staticmethod
+    def __GetModelPartFromInterfaceData(interface_data):
+        """If the solver does not exist on this rank, then pass a
+        dummy ModelPart to the Mapper that has a DataCommunicator
+        that is not defined on this rank
+        """
+        if interface_data.IsDefinedOnThisRank():
+            return interface_data.GetModelPart()
+        else:
+            return KratosMappingDataTransferOperator.__GetRankZeroModelPart()
+
+    @staticmethod
+    def __GetRankZeroModelPart():
+        if not KM.IsDistributedRun():
+            raise Exception("This function can only be called when Kratos is running in MPI!")
+
+        if KratosMappingDataTransferOperator.__rank_zero_model_part is None:
+            model = KM.Model()
+            rank_zero_model_part = model.CreateModelPart("rank_zero")
+
+            from KratosMultiphysics.mpi import ModelPartCommunicatorUtilities
+            ModelPartCommunicatorUtilities.SetMPICommunicator(rank_zero_model_part, data_communicator_utilities.GetRankZeroDataCommunicator())
+
+            KratosMappingDataTransferOperator.__dummy_model = model
+            KratosMappingDataTransferOperator.__rank_zero_model_part = rank_zero_model_part
+
+        return KratosMappingDataTransferOperator.__rank_zero_model_part
```

## KratosMultiphysics/CoSimulationApplication/__init__.py

 * *Ordering differences only*

```diff
@@ -1,23 +1,23 @@
-# Application dependent names and paths
-from KratosMultiphysics import _ImportApplication
-from KratosCoSimulationApplication import *
-application = KratosCoSimulationApplication()
-application_name = "KratosCoSimulationApplication"
-
-_ImportApplication(application, application_name)
-
-def __ModuleInitDetail():
-    """
-    Create a DataCommunicator that only contains rank zero and is undefined in other ranks
-    This is necessary for solvers that can only run in serial
-    It is defined as a function to avoid polluting the Kratos namespace with local variables.
-    """
-    import KratosMultiphysics as KM
-    if KM.IsDistributedRun():
-        from KratosMultiphysics.mpi import DataCommunicatorFactory
-        data_comm_name = "co_simulation_data_comm_rank_zero"
-        world_data_comm = KM.ParallelEnvironment.GetDataCommunicator("World")
-        ranks = [0]
-        DataCommunicatorFactory.CreateFromRanksAndRegister(world_data_comm, ranks, data_comm_name)
-
-__ModuleInitDetail()
+# Application dependent names and paths
+from KratosMultiphysics import _ImportApplication
+from KratosCoSimulationApplication import *
+application = KratosCoSimulationApplication()
+application_name = "KratosCoSimulationApplication"
+
+_ImportApplication(application, application_name)
+
+def __ModuleInitDetail():
+    """
+    Create a DataCommunicator that only contains rank zero and is undefined in other ranks
+    This is necessary for solvers that can only run in serial
+    It is defined as a function to avoid polluting the Kratos namespace with local variables.
+    """
+    import KratosMultiphysics as KM
+    if KM.IsDistributedRun():
+        from KratosMultiphysics.mpi import DataCommunicatorFactory
+        data_comm_name = "co_simulation_data_comm_rank_zero"
+        world_data_comm = KM.ParallelEnvironment.GetDataCommunicator("World")
+        ranks = [0]
+        DataCommunicatorFactory.CreateFromRanksAndRegister(world_data_comm, ranks, data_comm_name)
+
+__ModuleInitDetail()
```

## Comparing `KratosCoSimulationApplication-9.5.dist-info/METADATA` & `KratosCoSimulationApplication-9.5.1.dist-info/METADATA`

 * *Files 8% similar despite different names*

```diff
@@ -1,494 +1,495 @@
-Metadata-Version: 2.1
-Name: KratosCoSimulationApplication
-Version: 9.5
-Summary: KRATOS Multiphysics ("Kratos") is a framework for building parallel, multi-disciplinary simulation software, aiming at modularity, extensibility, and high performance. Kratos is written in C++, and counts with an extensive Python interface.
-Home-page: https://github.com/KratosMultiphysics/
-Author: Kratos Team
-Author-email: kratos@listas.cimne.upc.edu
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: C++
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: Topic :: Scientific/Engineering
-Classifier: Topic :: Scientific/Engineering :: Physics
-Classifier: Topic :: Scientific/Engineering :: Mathematics
-Classifier: Natural Language :: English
-Classifier: Intended Audience :: Science/Research
-Classifier: Intended Audience :: Other Audience
-Classifier: Intended Audience :: Developers
-Classifier: Development Status :: 5 - Production/Stable
-Classifier: Environment :: Console
-Classifier: License :: OSI Approved :: BSD License
-Requires-Python: >=3.8
-Description-Content-Type: text/markdown
-Requires-Dist: KratosMultiphysics ==9.5
-
-# CoSimulation Application
-
-The CoSimulation Application contains the core developments in coupling black-box solvers and other software-tools within Kratos Multiphysics.
-
-<a name="overview"></a>
-
-
-## Overview
-- [CoSimulation Application](#cosimulation-application)
-  - [Overview](#overview)
-  - [List of features](#list-of-features)
-  - [Dependencies](#dependencies)
-  - [Examples](#examples)
-  - [User Guide](#user-guide)
-    - [Setting up a coupled simulation](#setting-up-a-coupled-simulation)
-    - [The JSON configuration file](#the-json-configuration-file)
-    - [Basic FSI example](#basic-fsi-example)
-  - [Developer Guide](#developer-guide)
-    - [Structure of the Application](#structure-of-the-application)
-    - [How to couple a new solver / software-tool?](#how-to-couple-a-new-solver--software-tool)
-      - [Interface of SolverWrapper](#interface-of-solverwrapper)
-      - [Remote controlled CoSimulation](#remote-controlled-cosimulation)
-    - [Using a solver in MPI](#using-a-solver-in-mpi)
-  - [References](#references)
-
-<a name="list-of-features"></a>
-
-
-## List of features
-
-- Various features available for CoSimulation:
-  - [Coupling Algorithms](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/coupled_solvers)
-  - [Wrappers for various solvers and other software-tools](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/solver_wrappers)
-  - [Data Transfer Operators (including Mapping)](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/data_transfer_operators)
-  - [Convergence Accelerators](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/convergence_accelerators)
-  - [Convergence Criteria](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/convergence_criteria)
-  - [Predictors](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/predictors)
-
-- Support for MPI parallelization. This is independent of whether or not the ued solvers support/run in MPI.
-
-- Coupling of Kratos <=> Kratos without overhead since the same database is used and data duplication is avoided.
-
-- The [MappingApplication](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/MappingApplication) is used for mapping between nonmatching grids.
-
-
-<a name="dependencies"></a>
-
-
-## Dependencies
-
-The CoSimulation Application itself doesn't have any dependencies (except the `KratosCore` / `KratosMPICore` for serial/MPI-compilation).
-
-For running coupled simulations the solvers to be used have to be available. Those dependencies are python-only.
-
-The [MappingApplication](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/MappingApplication) is required when mapping is used.
-
-
-<a name="examples"></a>
-
-
-## Examples
-
-The examples can be found in the [examples repository](https://github.com/KratosMultiphysics/Examples/tree/master/co_simulation).
-Please also refer to the [tests](tests) for examples of how the coupling can be configured.
-Especially the [Mok-FSI](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/tests/fsi_mok) and the [Wall-FSI](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/tests/fsi_wall) tests are very suitable for getting a basic understanding.
-
-
-<a name="user-guide"></a>
-
-
-## User Guide
-
-This section guides users of the _CoSimulationApplication_ to setting up and performing coupled simulations. The overall workflow is the same as what is used for most Kratos applications. It consists of the following files:
-
-- **MainKratosCoSim.py** This file is to be executed with python to run the coupled simulation
-- **ProjectParametersCoSim.json** This file contains the configuration for the coupled simulation
-
-
-<a name="user-guide-setting-up-a-coupled-simulation"></a>
-
-
-### Setting up a coupled simulation
-For running a coulpled simulation at least the two files above are required. In addition, the input for the solvers / codes participating in the coupled simulation are necessary.
-
-The **MainKratosCoSim.py** file looks like this (see also [here](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/MainKratosCoSim.py):
-
-```py
-import KratosMultiphysics as KM
-from KratosMultiphysics.CoSimulationApplication.co_simulation_analysis import CoSimulationAnalysis
-
-"""
-For user-scripting it is intended that a new class is derived
-from CoSimulationAnalysis to do modifications
-Check also "kratos/python_scripts/analysis-stage.py" for available methods that can be overridden
-"""
-
-parameter_file_name = "ProjectParametersCoSim.json"
-with open(parameter_file_name,'r') as parameter_file:
-    parameters = KM.Parameters(parameter_file.read())
-
-simulation = CoSimulationAnalysis(parameters)
-simulation.Run()
-```
-
-It can be executed with python:
-
-```
-python MainKratosCoSim.py
-```
-
-If the coupled simulation runs in a distributed environment (MPI) then MPI is required to launch the script
-
-```
-mpiexec -np 4 python MainKratosCoSim.py --using-mpi
-```
-
-Not the passing of the `--using-mpi` flag which tells Kratos that it runs in MPI.
-
-
-<a name="user-guide-the-json-configuration-file"></a>
-
-
-### The JSON configuration file
-
-The configuration of the coupled simulation is written in `json` format, same as for the rest of Kratos.
-
-It contains two settings:
-- _problem_data_: this setting contains global settings of the coupled problem.
-  ```json
-  "start_time" : 0.0,
-  "end_time" : 15.0,
-  "echo_level" : 0, // verbosity, higher values mean more output
-  "print_colors" : true, // use colors in the prints
-  "parallel_type" : "OpenMP" // or "MPI"
-  ```
-
-- _solver_settings_: the settings of the coupled solver.
-  ```json
-  "type" : "coupled_solvers.gauss_seidel_weak", // type of the coupled solver, see python_scripts/coupled_solvers
-  "predictors" : [], // list of predictors
-  "num_coupling_iterations" : 10, // max number of coupling iterations, only available for strongly coupled solvers
-  "convergence_accelerators" : [] // list of convergence accelerators, only available for strongly coupled solvers
-  "convergence_criteria" : [] // list of convergence criteria, only available for strongly coupled solvers
-  "data_transfer_operators" : {} // map of data transfer operators (e.g. mapping)
-  "coupling_sequence" : [] // list specifying in which order the solvers are called
-  "solvers" : {} // map of solvers participating in the coupled simulation, specifying their input and interfaces
-  ```
-
-See the next section for a basic example with more explanations.
-
-
-<a name="user-guide-basic-fsi-example"></a>
-
-
-### Basic FSI example
-
-This example is the Wall FSI benchmark, see [1], chapter 7.5.3. The Kratos solvers are used to solve this problem. The input files for this example can be found [here](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/tests/fsi_wall)
-
-```json
-{
-    "problem_data" :
-    {
-        "start_time" : 0.0,
-        "end_time" : 3.0,
-        "echo_level" : 0, // printing no additional output
-        "print_colors" : true, // using colors for prints
-        "parallel_type" : "OpenMP"
-    },
-    "solver_settings" :
-    {
-        "type" : "coupled_solvers.gauss_seidel_weak", // weakly coupled simulation, no interface convergence is checked
-        "echo_level" : 0, // no additional output from the coupled solver
-        "predictors" : [ // using a predictor to improve the stability of the simulation
-            {
-                "type" : "average_value_based",
-                "solver"         : "fluid",
-                "data_name"      : "load"
-            }
-        ],
-        "data_transfer_operators" : {
-            "mapper" : {
-                "type" : "kratos_mapping",
-                "mapper_settings" : {
-                    "mapper_type" : "nearest_neighbor" // using a simple mapper, see the README in the MappingApplications
-                }
-            }
-        },
-        "coupling_sequence":
-        [
-        {
-            "name": "structure", // the structural solver comes first
-            "input_data_list": [ // before solving, the following data is imported in the structural solver
-                {
-                    "data"              : "load",
-                    "from_solver"       : "fluid",
-                    "from_solver_data"  : "load", // the fluid loads are mapped onto the structure
-                    "data_transfer_operator" : "mapper", // using the mapper defined above (nearest neighbor)
-                    "data_transfer_operator_options" : ["swap_sign"] // in Kratos, the loads have the opposite sign, hence it has to be swapped
-                }
-            ],
-            "output_data_list": [ // after solving, the displacements are mapped to the fluid solver
-                {
-                    "data"           : "disp",
-                    "to_solver"      : "fluid",
-                    "to_solver_data" : "disp",
-                    "data_transfer_operator" : "mapper"
-                }
-            ]
-        },
-        {
-            "name": "fluid", // the fluid solver solves after the structure
-            "output_data_list": [],
-            "input_data_list": []
-        }
-        ],
-        "solvers" : // here we specify the solvers, their input and interfaces for CoSimulation
-        {
-            "fluid":
-            {
-                "type" : "solver_wrappers.kratos.fluid_dynamics_wrapper", // using the Kratos FluidDynamicsApplication for the fluid
-                "solver_wrapper_settings" : {
-                    "input_file"  : "fsi_wall/ProjectParametersCFD" // input file for the fluid solver
-                },
-                "data" : { // definition of interfaces used in the simulation
-                    "disp" : {
-                        "model_part_name" : "FluidModelPart.NoSlip2D_FSI_Interface",
-                        "variable_name" : "MESH_DISPLACEMENT",
-                        "dimension" : 2
-                    },
-                    "load" : {
-                        "model_part_name" : "FluidModelPart.NoSlip2D_FSI_Interface",
-                        "variable_name" : "REACTION",
-                        "dimension" : 2
-                    }
-                }
-            },
-            "structure" :
-            {
-                "type" : "solver_wrappers.kratos.structural_mechanics_wrapper", // using the Kratos StructuralMechanicsApplication for the structure
-                "solver_wrapper_settings" : {
-                    "input_file"  : "fsi_wall/ProjectParametersCSM" // input file for the structural solver
-                },
-                "data" : { // definition of interfaces used in the simulation
-                    "disp" : {
-                        "model_part_name" : "Structure.GENERIC_FSI_Interface",
-                        "variable_name" : "DISPLACEMENT",
-                        "dimension" : 2
-                    },
-                    "load" : {
-                        "model_part_name" : "Structure.GENERIC_FSI_Interface",
-                        "variable_name" : "POINT_LOAD",
-                        "dimension" : 2
-                    }
-                }
-            }
-        }
-    }
-}
-```
-
-
-<a name="developer-guide"></a>
-
-
-## Developer Guide
-
-
-<a name="developer-guide_structure-of-the-application"></a>
-
-
-### Structure of the Application
-
-The _CoSimulationApplication_ consists of the following main components (taken from [2]):
-- **SolverWrapper**: Baseclass and CoSimulationApplication-interface for all solvers/codes participating in the coupled simulation, each solver/code has its own specific version.
-- **CoupledSolver**: Implements coupling schemes such as weak/strong coupling with *Gauss-Seidel/Jacobi* pattern. It derives from SolverWrapper such that it can beused in nested coupled simulations.
-- **IO**: Responsible for communicating and data exchange with external solvers/codes
-- **DataTransferOperator**: Transfers data from one discretization to another, e.g. by use of mapping techniques
-- **CouplingOperation**: Tool for customizing coupled simulations
-- **ConvergenceAccelerator**: Accelerating the solution in strongly coupled simulations by use of relaxation or Quasi-Newton techniques
-- **ConvergenceCriteria**: Checks if convergence is achieved in a strongly coupled simulation.
-- **Predictor**: Improves the convergence by using a prediction as initial guess for the coupled solution
-
-The following UML diagram shows the relation between these components:
-
-<p align="center">
-  <img src="https://github.com/KratosMultiphysics/Documentation/blob/master/Readme_files/CoSimulationApplication/CoSimulation_uml.png?raw=true" style="width: 300px;"/>
-</p>
-
-Besides the functionalities [listed above](#list-of-features), the modular design of the application makes it straightforward to add a new or customized version of e.g. a _ConvergenceAccelerator_. It is not necessary to have those custom python scripts inside the _CoSimulationApplication_, it is sufficient that they are in a directory that is included in the _PYTHONPATH_ (e.g. the working directory).
-
-
-<a name="developer-guide_how-to-couple-a-new-solver--software-tool"></a>
-
-
-### How to couple a new solver / software-tool?
-
-The _CoSimulationApplication_ is very modular and designed to be extended to coupling of more solvers / software-tools. This requires basically two components on the Kratos side:
-
-The interface between the _CoSimulationApplication_ and a solver is done with the [**SolverWrapper**](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/base_classes/co_simulation_solver_wrapper.py). This wrapper is specific to every solver and calls the solver-custom methods based on the input of CoSimulation.
-
-The second component necessary is an [**IO**](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/base_classes/co_simulation_io.py). This component is used by the SolverWrapper and is responsible for the exchange of data (e.g. mesh, field-quantities, geometry etc) between the solver and the _CoSimulationApplication_.
-
-In principle three different options are possible for exchanging data with CoSimulation:
-
-- For very simple solvers IO can directly be done in python inside the SolverWrapper, which makes a separate IO superfluous (see e.g. a [python-only single degree of freedom solver](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/solver_wrappers/sdof))
-- Using the [_CoSimIO_](https://github.com/KratosMultiphysics/CoSimIO). This which is the preferred way of exchanging data with the _CoSimulationApplication_. It is currently available for _C++_, _C_, and _Python_. The _CoSimIO_ is included as the [KratosCoSimIO](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/solver_wrappers/kratos_co_sim_io.py) and can be used directly. Its modular and Kratos-independent design as _detached interface_ allows for easy integration into other codes.
-- Using a custom solution based on capabilities that are offered by the solver that is to be coupled.
-
-The following picture shows the interaction of these components with the _CoSimulationApplication_ and the external solver:
-
-<p align="center">
-  <img src="https://raw.githubusercontent.com/KratosMultiphysics/Documentation/master/Readme_files/CoSimulationApplication/detached_interface.png" style="width: 300px;"/>
-</p>
-
-
-<a name="developer-guide_interface-of-solverwrapper"></a>
-
-
-#### Interface of SolverWrapper
-
-The [**SolverWrapper**](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/base_classes/co_simulation_solver_wrapper.py) is the interface in the _CoSimulationApplication_ to all involved codes / solvers. It provides the following interface (adapted from [2]), which is also called in this order:
-
-- **Initialize**: This function is called once at the beginning of the simulation, it e.g .reads the input files and prepares the internal data structures.
-- The solution loop is split into the following six functions:
-  - **AdvanceInTime**: Advancing in time and preparing the data structure for the next time step.
-  - **InitializeSolutionStep**: Applying boundary conditions
-  - **Predict**: Predicting the solution of this time step to accelerate the solution.\
-  iterate until convergence in a strongly coupled solution:
-    - **SolveSolutionStep**: Solving the problem for this time step. This is the only function that can be called multiple times in an iterative (strongly coupled) solution procedure.
-  - **FinalizeSolutionStep**: Updating internals after solving this time step.
-  - **OutputSolutionStep**: Writing output at the end of a time step
-- **Finalize**: Finalizing and cleaning up after the simulation
-
-Each of these functions can implement functionalities to communicate with the external solver, telling it what to do. However, this is often skipped if the data exchange is used for the synchronization of the solvers. This is often done in "classical" coupling tools. I.e. the code to couple internally duplicates the coupling sequence and synchronizes with the coupling tool through the data exchange.
-
-An example of a _SolverWrapper_ coupled to an external solver using this approach can be found [here](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/solver_wrappers/external/external_solver_wrapper.py). Only the mesh exchange is done explicitly at the beginning of the simulation, the data exchange is done inside _SolveSolutionStep_.
-
-The coupled solver has to duplicate the coupling sequence, it would look e.g. like this (using _CoSimIO_) for a weak coupling:
-```py
-# solver initializes ...
-
-CoSimIO::ExportMesh(...) # send meshes to the CoSimulationApplication
-
-# start solution loop
-while time < end_time:
-    CoSimIO::ImportData(...) # get interface data
-
-    # solve the time step
-
-    CoSimIO::ExportData(...) # send new data to the CoSimulationApplication
-```
-
-An example for an FSI problem where the structural solver of Kratos is used as an external solver can be found [here](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/tests/structural_mechanics_analysis_with_co_sim_io.py). The _CoSimIO_ is used for communicating between the _CoSimulationApplication_ and the structural solver
-
-While this approach is commonly used, it has the significant drawback that the coupling sequence has to be duplicated, which not only has the potential for bugs and deadlocks but also severely limits the useability when it comes to trying different coupling algorithms. Then not only the input for the _CoSimulationApplication_ has to be changed but also the source code in the external solver!
-
-Hence a better solution is proposed in the next section:
-
-
-<a name="developer-guide_remote-controller-cosimulation"></a>
-
-
-#### Remote controlled CoSimulation
-A unique feature of Kratos CoSimulation (in combination with the _CoSimIO_) is the remotely controlled CoSimulation. The main difference to the "classical" approach which duplicates the coupling sequence in the external solver is to give the full control to CoSimulation. This is the most flexible approach from the point of CoSimulation, as then neither the coupling sequence nor any other coupling logic has to be duplicated in the external solver.
-
-In this approach the external solver registers the functions necessary to perform coupled simulations through the _CoSimIO_. These are then called remotely through the _CoSimulationApplication_. This way any coupling algorithm can be used without changing anything in the external solver.
-
-```py
-# defining functions to be registered
-def SolveSolution()
-{
-    # external solver solves timestep
-}
-
-def ExportData()
-{
-    # external solver exports data to the CoSimulationApplication
-}
-
-# after defining the functions they can be registered in the CoSimIO:
-
-CoSimIO::Register(SolveSolution)
-CoSimIO::Register(ExportData)
-# ...
-
-# After all the functions are registered and the solver is fully initialized for CoSimulation, the Run method is called
-CoSimIO::Run() # this function runs the coupled simulation. It returns only after finishing
-```
-
-A [simple example of this can be found in the _CoSimIO_](https://github.com/KratosMultiphysics/CoSimIO/blob/master/tests/integration_tutorials/cpp/run.cpp).
-
-The _SolverWrapper_ for this approach sends a small control signal in each of its functions to the external solver to tell it what to do. This could be implemented as the following:
-
-```py
-class RemoteControlSolverWrapper(CoSimulationSolverWrapper):
-    # ...
-    # implement other methods as necessary
-    # ...
-
-    def InitializeSolutionStep(self):
-        data_config = {
-            "type"           : "control_signal",
-            "control_signal" : "InitializeSolutionStep"
-        }
-        self.ExportData(data_config)
-
-    def SolveSolutionStep(self):
-        for data_name in self.settings["solver_wrapper_settings"]["export_data"].GetStringArray():
-            # first tell the controlled solver to import data
-            data_config = {
-                "type"            : "control_signal",
-                "control_signal"  : "ImportData",
-                "data_identifier" : data_name
-            }
-            self.ExportData(data_config)
-
-            # then export the data from Kratos
-            data_config = {
-                "type" : "coupling_interface_data",
-                "interface_data" : self.GetInterfaceData(data_name)
-            }
-            self.ExportData(data_config)
-
-        # now the external solver solves
-        super().SolveSolutionStep()
-
-        for data_name in self.settings["solver_wrapper_settings"]["import_data"].GetStringArray():
-            # first tell the controlled solver to export data
-            data_config = {
-                "type"            : "control_signal",
-                "control_signal"  : "ExportData",
-                "data_identifier" : data_name
-            }
-            self.ExportData(data_config)
-
-            # then import the data to Kratos
-            data_config = {
-                "type" : "coupling_interface_data",
-                "interface_data" : self.GetInterfaceData(data_name)
-            }
-            self.ImportData(data_config)
-```
-
-A full example for this can be found [here](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/tests/structural_mechanics_analysis_remote_controlled.py).
-
-If it is possible for an external solver to implement this approach, it is recommended to use it as it is the most robust and flexible.
-
-Nevertheless both approaches are possible with the _CoSimulationApplication_.
-
-
-<a name="developer-guide_using-a-solver-in-mpi"></a>
-
-
-### Using a solver in MPI
-By default, each _SolverWrapper_ makes use of all ranks in MPI. This can be changed if e.g. the solver that is wrapped by the _SolverWrapper_ does not support MPI or to specify to use less rank.
-
-The base _SolverWrapper_ provides the `_GetDataCommunicator` function for this purpose. In the baseclass, the default _DataCommunicator_ (which contains all ranks in MPI) is returned. The _SolverWrapper_ will be instantiated on all the ranks on which this _DataCommunicator_ is defined (i.e. on the ranks where `data_communicator.IsDefinedOnThisRank() == True`).
-
-If a solver does not support MPI-parallelism then it can only run on one rank. In such cases it should return a _DataCommunicator_ which contains only one rank. For this purpose the function `KratosMultiphysics.CoSimulationApplication.utilities.data_communicator_utilities.GetRankZeroDataCommunicator` can be used. Other custom solutions are also possible, see for example the [structural_solver_wrapper](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/solver_wrappers/kratos/structural_mechanics_wrapper.py).
-
-<a name="references"></a>
-
-## References
-
-- [1] Wall, Wolfgang A., _Fluid structure interaction with stabilized finite elements_, PhD Thesis, University of Stuttgart, 1999, http://dx.doi.org/10.18419/opus-127
-- [2] Bucher et al., _Realizing CoSimulation in and with a multiphysics framework_, conference proceedings, IX International Conference on Computational Methods for Coupled Problems in Science and Engineering, 2021, https://www.scipedia.com/public/Bucher_et_al_2021a
+Metadata-Version: 2.1
+Name: KratosCoSimulationApplication
+Version: 9.5.1
+Summary: KRATOS Multiphysics ("Kratos") is a framework for building parallel, multi-disciplinary simulation software, aiming at modularity, extensibility, and high performance. Kratos is written in C++, and counts with an extensive Python interface.
+Home-page: https://github.com/KratosMultiphysics/
+Author: Kratos Team
+Author-email: kratos@listas.cimne.upc.edu
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: C++
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
+Classifier: Topic :: Scientific/Engineering
+Classifier: Topic :: Scientific/Engineering :: Physics
+Classifier: Topic :: Scientific/Engineering :: Mathematics
+Classifier: Natural Language :: English
+Classifier: Intended Audience :: Science/Research
+Classifier: Intended Audience :: Other Audience
+Classifier: Intended Audience :: Developers
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: Environment :: Console
+Classifier: License :: OSI Approved :: BSD License
+Requires-Python: >=3.8
+Description-Content-Type: text/markdown
+Requires-Dist: KratosMultiphysics ==9.5.1
+
+# CoSimulation Application
+
+The CoSimulation Application contains the core developments in coupling black-box solvers and other software-tools within Kratos Multiphysics.
+
+<a name="overview"></a>
+
+
+## Overview
+- [CoSimulation Application](#cosimulation-application)
+  - [Overview](#overview)
+  - [List of features](#list-of-features)
+  - [Dependencies](#dependencies)
+  - [Examples](#examples)
+  - [User Guide](#user-guide)
+    - [Setting up a coupled simulation](#setting-up-a-coupled-simulation)
+    - [The JSON configuration file](#the-json-configuration-file)
+    - [Basic FSI example](#basic-fsi-example)
+  - [Developer Guide](#developer-guide)
+    - [Structure of the Application](#structure-of-the-application)
+    - [How to couple a new solver / software-tool?](#how-to-couple-a-new-solver--software-tool)
+      - [Interface of SolverWrapper](#interface-of-solverwrapper)
+      - [Remote controlled CoSimulation](#remote-controlled-cosimulation)
+    - [Using a solver in MPI](#using-a-solver-in-mpi)
+  - [References](#references)
+
+<a name="list-of-features"></a>
+
+
+## List of features
+
+- Various features available for CoSimulation:
+  - [Coupling Algorithms](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/coupled_solvers)
+  - [Wrappers for various solvers and other software-tools](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/solver_wrappers)
+  - [Data Transfer Operators (including Mapping)](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/data_transfer_operators)
+  - [Convergence Accelerators](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/convergence_accelerators)
+  - [Convergence Criteria](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/convergence_criteria)
+  - [Predictors](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/predictors)
+
+- Support for MPI parallelization. This is independent of whether or not the ued solvers support/run in MPI.
+
+- Coupling of Kratos <=> Kratos without overhead since the same database is used and data duplication is avoided.
+
+- The [MappingApplication](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/MappingApplication) is used for mapping between nonmatching grids.
+
+
+<a name="dependencies"></a>
+
+
+## Dependencies
+
+The CoSimulation Application itself doesn't have any dependencies (except the `KratosCore` / `KratosMPICore` for serial/MPI-compilation).
+
+For running coupled simulations the solvers to be used have to be available. Those dependencies are python-only.
+
+The [MappingApplication](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/MappingApplication) is required when mapping is used.
+
+
+<a name="examples"></a>
+
+
+## Examples
+
+The examples can be found in the [examples repository](https://github.com/KratosMultiphysics/Examples/tree/master/co_simulation).
+Please also refer to the [tests](tests) for examples of how the coupling can be configured.
+Especially the [Mok-FSI](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/tests/fsi_mok) and the [Wall-FSI](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/tests/fsi_wall) tests are very suitable for getting a basic understanding.
+
+
+<a name="user-guide"></a>
+
+
+## User Guide
+
+This section guides users of the _CoSimulationApplication_ to setting up and performing coupled simulations. The overall workflow is the same as what is used for most Kratos applications. It consists of the following files:
+
+- **MainKratosCoSim.py** This file is to be executed with python to run the coupled simulation
+- **ProjectParametersCoSim.json** This file contains the configuration for the coupled simulation
+
+
+<a name="user-guide-setting-up-a-coupled-simulation"></a>
+
+
+### Setting up a coupled simulation
+For running a coulpled simulation at least the two files above are required. In addition, the input for the solvers / codes participating in the coupled simulation are necessary.
+
+The **MainKratosCoSim.py** file looks like this (see also [here](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/MainKratosCoSim.py):
+
+```py
+import KratosMultiphysics as KM
+from KratosMultiphysics.CoSimulationApplication.co_simulation_analysis import CoSimulationAnalysis
+
+"""
+For user-scripting it is intended that a new class is derived
+from CoSimulationAnalysis to do modifications
+Check also "kratos/python_scripts/analysis-stage.py" for available methods that can be overridden
+"""
+
+parameter_file_name = "ProjectParametersCoSim.json"
+with open(parameter_file_name,'r') as parameter_file:
+    parameters = KM.Parameters(parameter_file.read())
+
+simulation = CoSimulationAnalysis(parameters)
+simulation.Run()
+```
+
+It can be executed with python:
+
+```
+python MainKratosCoSim.py
+```
+
+If the coupled simulation runs in a distributed environment (MPI) then MPI is required to launch the script
+
+```
+mpiexec -np 4 python MainKratosCoSim.py --using-mpi
+```
+
+Not the passing of the `--using-mpi` flag which tells Kratos that it runs in MPI.
+
+
+<a name="user-guide-the-json-configuration-file"></a>
+
+
+### The JSON configuration file
+
+The configuration of the coupled simulation is written in `json` format, same as for the rest of Kratos.
+
+It contains two settings:
+- _problem_data_: this setting contains global settings of the coupled problem.
+  ```json
+  "start_time" : 0.0,
+  "end_time" : 15.0,
+  "echo_level" : 0, // verbosity, higher values mean more output
+  "print_colors" : true, // use colors in the prints
+  "parallel_type" : "OpenMP" // or "MPI"
+  ```
+
+- _solver_settings_: the settings of the coupled solver.
+  ```json
+  "type" : "coupled_solvers.gauss_seidel_weak", // type of the coupled solver, see python_scripts/coupled_solvers
+  "predictors" : [], // list of predictors
+  "num_coupling_iterations" : 10, // max number of coupling iterations, only available for strongly coupled solvers
+  "convergence_accelerators" : [] // list of convergence accelerators, only available for strongly coupled solvers
+  "convergence_criteria" : [] // list of convergence criteria, only available for strongly coupled solvers
+  "data_transfer_operators" : {} // map of data transfer operators (e.g. mapping)
+  "coupling_sequence" : [] // list specifying in which order the solvers are called
+  "solvers" : {} // map of solvers participating in the coupled simulation, specifying their input and interfaces
+  ```
+
+See the next section for a basic example with more explanations.
+
+
+<a name="user-guide-basic-fsi-example"></a>
+
+
+### Basic FSI example
+
+This example is the Wall FSI benchmark, see [1], chapter 7.5.3. The Kratos solvers are used to solve this problem. The input files for this example can be found [here](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/tests/fsi_wall)
+
+```json
+{
+    "problem_data" :
+    {
+        "start_time" : 0.0,
+        "end_time" : 3.0,
+        "echo_level" : 0, // printing no additional output
+        "print_colors" : true, // using colors for prints
+        "parallel_type" : "OpenMP"
+    },
+    "solver_settings" :
+    {
+        "type" : "coupled_solvers.gauss_seidel_weak", // weakly coupled simulation, no interface convergence is checked
+        "echo_level" : 0, // no additional output from the coupled solver
+        "predictors" : [ // using a predictor to improve the stability of the simulation
+            {
+                "type" : "average_value_based",
+                "solver"         : "fluid",
+                "data_name"      : "load"
+            }
+        ],
+        "data_transfer_operators" : {
+            "mapper" : {
+                "type" : "kratos_mapping",
+                "mapper_settings" : {
+                    "mapper_type" : "nearest_neighbor" // using a simple mapper, see the README in the MappingApplications
+                }
+            }
+        },
+        "coupling_sequence":
+        [
+        {
+            "name": "structure", // the structural solver comes first
+            "input_data_list": [ // before solving, the following data is imported in the structural solver
+                {
+                    "data"              : "load",
+                    "from_solver"       : "fluid",
+                    "from_solver_data"  : "load", // the fluid loads are mapped onto the structure
+                    "data_transfer_operator" : "mapper", // using the mapper defined above (nearest neighbor)
+                    "data_transfer_operator_options" : ["swap_sign"] // in Kratos, the loads have the opposite sign, hence it has to be swapped
+                }
+            ],
+            "output_data_list": [ // after solving, the displacements are mapped to the fluid solver
+                {
+                    "data"           : "disp",
+                    "to_solver"      : "fluid",
+                    "to_solver_data" : "disp",
+                    "data_transfer_operator" : "mapper"
+                }
+            ]
+        },
+        {
+            "name": "fluid", // the fluid solver solves after the structure
+            "output_data_list": [],
+            "input_data_list": []
+        }
+        ],
+        "solvers" : // here we specify the solvers, their input and interfaces for CoSimulation
+        {
+            "fluid":
+            {
+                "type" : "solver_wrappers.kratos.fluid_dynamics_wrapper", // using the Kratos FluidDynamicsApplication for the fluid
+                "solver_wrapper_settings" : {
+                    "input_file"  : "fsi_wall/ProjectParametersCFD" // input file for the fluid solver
+                },
+                "data" : { // definition of interfaces used in the simulation
+                    "disp" : {
+                        "model_part_name" : "FluidModelPart.NoSlip2D_FSI_Interface",
+                        "variable_name" : "MESH_DISPLACEMENT",
+                        "dimension" : 2
+                    },
+                    "load" : {
+                        "model_part_name" : "FluidModelPart.NoSlip2D_FSI_Interface",
+                        "variable_name" : "REACTION",
+                        "dimension" : 2
+                    }
+                }
+            },
+            "structure" :
+            {
+                "type" : "solver_wrappers.kratos.structural_mechanics_wrapper", // using the Kratos StructuralMechanicsApplication for the structure
+                "solver_wrapper_settings" : {
+                    "input_file"  : "fsi_wall/ProjectParametersCSM" // input file for the structural solver
+                },
+                "data" : { // definition of interfaces used in the simulation
+                    "disp" : {
+                        "model_part_name" : "Structure.GENERIC_FSI_Interface",
+                        "variable_name" : "DISPLACEMENT",
+                        "dimension" : 2
+                    },
+                    "load" : {
+                        "model_part_name" : "Structure.GENERIC_FSI_Interface",
+                        "variable_name" : "POINT_LOAD",
+                        "dimension" : 2
+                    }
+                }
+            }
+        }
+    }
+}
+```
+
+
+<a name="developer-guide"></a>
+
+
+## Developer Guide
+
+
+<a name="developer-guide_structure-of-the-application"></a>
+
+
+### Structure of the Application
+
+The _CoSimulationApplication_ consists of the following main components (taken from [2]):
+- **SolverWrapper**: Baseclass and CoSimulationApplication-interface for all solvers/codes participating in the coupled simulation, each solver/code has its own specific version.
+- **CoupledSolver**: Implements coupling schemes such as weak/strong coupling with *Gauss-Seidel/Jacobi* pattern. It derives from SolverWrapper such that it can beused in nested coupled simulations.
+- **IO**: Responsible for communicating and data exchange with external solvers/codes
+- **DataTransferOperator**: Transfers data from one discretization to another, e.g. by use of mapping techniques
+- **CouplingOperation**: Tool for customizing coupled simulations
+- **ConvergenceAccelerator**: Accelerating the solution in strongly coupled simulations by use of relaxation or Quasi-Newton techniques
+- **ConvergenceCriteria**: Checks if convergence is achieved in a strongly coupled simulation.
+- **Predictor**: Improves the convergence by using a prediction as initial guess for the coupled solution
+
+The following UML diagram shows the relation between these components:
+
+<p align="center">
+  <img src="https://github.com/KratosMultiphysics/Documentation/blob/master/Readme_files/CoSimulationApplication/CoSimulation_uml.png?raw=true" style="width: 300px;"/>
+</p>
+
+Besides the functionalities [listed above](#list-of-features), the modular design of the application makes it straightforward to add a new or customized version of e.g. a _ConvergenceAccelerator_. It is not necessary to have those custom python scripts inside the _CoSimulationApplication_, it is sufficient that they are in a directory that is included in the _PYTHONPATH_ (e.g. the working directory).
+
+
+<a name="developer-guide_how-to-couple-a-new-solver--software-tool"></a>
+
+
+### How to couple a new solver / software-tool?
+
+The _CoSimulationApplication_ is very modular and designed to be extended to coupling of more solvers / software-tools. This requires basically two components on the Kratos side:
+
+The interface between the _CoSimulationApplication_ and a solver is done with the [**SolverWrapper**](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/base_classes/co_simulation_solver_wrapper.py). This wrapper is specific to every solver and calls the solver-custom methods based on the input of CoSimulation.
+
+The second component necessary is an [**IO**](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/base_classes/co_simulation_io.py). This component is used by the SolverWrapper and is responsible for the exchange of data (e.g. mesh, field-quantities, geometry etc) between the solver and the _CoSimulationApplication_.
+
+In principle three different options are possible for exchanging data with CoSimulation:
+
+- For very simple solvers IO can directly be done in python inside the SolverWrapper, which makes a separate IO superfluous (see e.g. a [python-only single degree of freedom solver](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/solver_wrappers/sdof))
+- Using the [_CoSimIO_](https://github.com/KratosMultiphysics/CoSimIO). This which is the preferred way of exchanging data with the _CoSimulationApplication_. It is currently available for _C++_, _C_, and _Python_. The _CoSimIO_ is included as the [KratosCoSimIO](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/solver_wrappers/kratos_co_sim_io.py) and can be used directly. Its modular and Kratos-independent design as _detached interface_ allows for easy integration into other codes.
+- Using a custom solution based on capabilities that are offered by the solver that is to be coupled.
+
+The following picture shows the interaction of these components with the _CoSimulationApplication_ and the external solver:
+
+<p align="center">
+  <img src="https://raw.githubusercontent.com/KratosMultiphysics/Documentation/master/Readme_files/CoSimulationApplication/detached_interface.png" style="width: 300px;"/>
+</p>
+
+
+<a name="developer-guide_interface-of-solverwrapper"></a>
+
+
+#### Interface of SolverWrapper
+
+The [**SolverWrapper**](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/base_classes/co_simulation_solver_wrapper.py) is the interface in the _CoSimulationApplication_ to all involved codes / solvers. It provides the following interface (adapted from [2]), which is also called in this order:
+
+- **Initialize**: This function is called once at the beginning of the simulation, it e.g .reads the input files and prepares the internal data structures.
+- The solution loop is split into the following six functions:
+  - **AdvanceInTime**: Advancing in time and preparing the data structure for the next time step.
+  - **InitializeSolutionStep**: Applying boundary conditions
+  - **Predict**: Predicting the solution of this time step to accelerate the solution.\
+  iterate until convergence in a strongly coupled solution:
+    - **SolveSolutionStep**: Solving the problem for this time step. This is the only function that can be called multiple times in an iterative (strongly coupled) solution procedure.
+  - **FinalizeSolutionStep**: Updating internals after solving this time step.
+  - **OutputSolutionStep**: Writing output at the end of a time step
+- **Finalize**: Finalizing and cleaning up after the simulation
+
+Each of these functions can implement functionalities to communicate with the external solver, telling it what to do. However, this is often skipped if the data exchange is used for the synchronization of the solvers. This is often done in "classical" coupling tools. I.e. the code to couple internally duplicates the coupling sequence and synchronizes with the coupling tool through the data exchange.
+
+An example of a _SolverWrapper_ coupled to an external solver using this approach can be found [here](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/solver_wrappers/external/external_solver_wrapper.py). Only the mesh exchange is done explicitly at the beginning of the simulation, the data exchange is done inside _SolveSolutionStep_.
+
+The coupled solver has to duplicate the coupling sequence, it would look e.g. like this (using _CoSimIO_) for a weak coupling:
+```py
+# solver initializes ...
+
+CoSimIO::ExportMesh(...) # send meshes to the CoSimulationApplication
+
+# start solution loop
+while time < end_time:
+    CoSimIO::ImportData(...) # get interface data
+
+    # solve the time step
+
+    CoSimIO::ExportData(...) # send new data to the CoSimulationApplication
+```
+
+An example for an FSI problem where the structural solver of Kratos is used as an external solver can be found [here](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/tests/structural_mechanics_analysis_with_co_sim_io.py). The _CoSimIO_ is used for communicating between the _CoSimulationApplication_ and the structural solver
+
+While this approach is commonly used, it has the significant drawback that the coupling sequence has to be duplicated, which not only has the potential for bugs and deadlocks but also severely limits the useability when it comes to trying different coupling algorithms. Then not only the input for the _CoSimulationApplication_ has to be changed but also the source code in the external solver!
+
+Hence a better solution is proposed in the next section:
+
+
+<a name="developer-guide_remote-controller-cosimulation"></a>
+
+
+#### Remote controlled CoSimulation
+A unique feature of Kratos CoSimulation (in combination with the _CoSimIO_) is the remotely controlled CoSimulation. The main difference to the "classical" approach which duplicates the coupling sequence in the external solver is to give the full control to CoSimulation. This is the most flexible approach from the point of CoSimulation, as then neither the coupling sequence nor any other coupling logic has to be duplicated in the external solver.
+
+In this approach the external solver registers the functions necessary to perform coupled simulations through the _CoSimIO_. These are then called remotely through the _CoSimulationApplication_. This way any coupling algorithm can be used without changing anything in the external solver.
+
+```py
+# defining functions to be registered
+def SolveSolution()
+{
+    # external solver solves timestep
+}
+
+def ExportData()
+{
+    # external solver exports data to the CoSimulationApplication
+}
+
+# after defining the functions they can be registered in the CoSimIO:
+
+CoSimIO::Register(SolveSolution)
+CoSimIO::Register(ExportData)
+# ...
+
+# After all the functions are registered and the solver is fully initialized for CoSimulation, the Run method is called
+CoSimIO::Run() # this function runs the coupled simulation. It returns only after finishing
+```
+
+A [simple example of this can be found in the _CoSimIO_](https://github.com/KratosMultiphysics/CoSimIO/blob/master/tests/integration_tutorials/cpp/run.cpp).
+
+The _SolverWrapper_ for this approach sends a small control signal in each of its functions to the external solver to tell it what to do. This could be implemented as the following:
+
+```py
+class RemoteControlSolverWrapper(CoSimulationSolverWrapper):
+    # ...
+    # implement other methods as necessary
+    # ...
+
+    def InitializeSolutionStep(self):
+        data_config = {
+            "type"           : "control_signal",
+            "control_signal" : "InitializeSolutionStep"
+        }
+        self.ExportData(data_config)
+
+    def SolveSolutionStep(self):
+        for data_name in self.settings["solver_wrapper_settings"]["export_data"].GetStringArray():
+            # first tell the controlled solver to import data
+            data_config = {
+                "type"            : "control_signal",
+                "control_signal"  : "ImportData",
+                "data_identifier" : data_name
+            }
+            self.ExportData(data_config)
+
+            # then export the data from Kratos
+            data_config = {
+                "type" : "coupling_interface_data",
+                "interface_data" : self.GetInterfaceData(data_name)
+            }
+            self.ExportData(data_config)
+
+        # now the external solver solves
+        super().SolveSolutionStep()
+
+        for data_name in self.settings["solver_wrapper_settings"]["import_data"].GetStringArray():
+            # first tell the controlled solver to export data
+            data_config = {
+                "type"            : "control_signal",
+                "control_signal"  : "ExportData",
+                "data_identifier" : data_name
+            }
+            self.ExportData(data_config)
+
+            # then import the data to Kratos
+            data_config = {
+                "type" : "coupling_interface_data",
+                "interface_data" : self.GetInterfaceData(data_name)
+            }
+            self.ImportData(data_config)
+```
+
+A full example for this can be found [here](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/tests/structural_mechanics_analysis_remote_controlled.py).
+
+If it is possible for an external solver to implement this approach, it is recommended to use it as it is the most robust and flexible.
+
+Nevertheless both approaches are possible with the _CoSimulationApplication_.
+
+
+<a name="developer-guide_using-a-solver-in-mpi"></a>
+
+
+### Using a solver in MPI
+By default, each _SolverWrapper_ makes use of all ranks in MPI. This can be changed if e.g. the solver that is wrapped by the _SolverWrapper_ does not support MPI or to specify to use less rank.
+
+The base _SolverWrapper_ provides the `_GetDataCommunicator` function for this purpose. In the baseclass, the default _DataCommunicator_ (which contains all ranks in MPI) is returned. The _SolverWrapper_ will be instantiated on all the ranks on which this _DataCommunicator_ is defined (i.e. on the ranks where `data_communicator.IsDefinedOnThisRank() == True`).
+
+If a solver does not support MPI-parallelism then it can only run on one rank. In such cases it should return a _DataCommunicator_ which contains only one rank. For this purpose the function `KratosMultiphysics.CoSimulationApplication.utilities.data_communicator_utilities.GetRankZeroDataCommunicator` can be used. Other custom solutions are also possible, see for example the [structural_solver_wrapper](https://github.com/KratosMultiphysics/Kratos/blob/master/applications/CoSimulationApplication/python_scripts/solver_wrappers/kratos/structural_mechanics_wrapper.py).
+
+<a name="references"></a>
+
+## References
+
+- [1] Wall, Wolfgang A., _Fluid structure interaction with stabilized finite elements_, PhD Thesis, University of Stuttgart, 1999, http://dx.doi.org/10.18419/opus-127
+- [2] Bucher et al., _Realizing CoSimulation in and with a multiphysics framework_, conference proceedings, IX International Conference on Computational Methods for Coupled Problems in Science and Engineering, 2021, https://www.scipedia.com/public/Bucher_et_al_2021a
```

## Comparing `KratosCoSimulationApplication-9.5.dist-info/RECORD` & `KratosCoSimulationApplication-9.5.1.dist-info/RECORD`

 * *Files 6% similar despite different names*

```diff
@@ -1,118 +1,118 @@
-KratosCoSimulationApplication-9.5.dist-info/METADATA,sha256=Y8yF-_1F4vmYUI_J1jqFiMkq2YGKR4fTOrj6QXkxrsY,26173
-KratosCoSimulationApplication-9.5.dist-info/WHEEL,sha256=rY0Y6THYM7EImsHfF-zs67o8pQciAsMw9_YuSvftjrQ,148
-KratosCoSimulationApplication-9.5.dist-info/top_level.txt,sha256=8Ov--opRCptLbHStjyiZUVpzN1OUU_F7c7fGmsR5cMc,19
-KratosCoSimulationApplication-9.5.dist-info/RECORD,,
-KratosCoSimulationApplication.libs/libKratosCoSimulationCore-6b309626.so,sha256=Edwf86TxNRjio5gvzF5PaiacJSTz_9ZLTwja4iKKzSc,4010777
-KratosCoSimulationApplication.libs/libco_sim_io-da5c66c6.so,sha256=mtOPRshD3PD2s7ahB6EKXHbfdX1txwc0vM08iJRJOj8,2801145
-KratosMultiphysics/CoSimulationApplication/MainKratosCoSim.py,sha256=hiwve_VqaO8POv-xIFryCnv2_2Ae0v0W1pjn9KAPVZk,571
-KratosMultiphysics/CoSimulationApplication/colors.py,sha256=267hqCa44lx81QQf2RvXohlP4en3FXwn4JR-k5Xitm0,2273
-KratosMultiphysics/CoSimulationApplication/analysis_stage_with_co_sim_io.py,sha256=1pg7MPcHAJedJzvL12lorQdZe0MFVcxAThxBeXhJMhY,5870
-KratosMultiphysics/CoSimulationApplication/function_callback_utility.py,sha256=AhrUI5b3zNwFn5ZHnD3BsU2OYQIXFNRShQEkNFnk7Ug,1497
-KratosMultiphysics/CoSimulationApplication/structural_mechanics_analysis_with_co_sim_io.py,sha256=ovSpt4sHIHIJGd7l75thj4Vl4gFLe1RACv5JiTkX1t8,952
-KratosMultiphysics/CoSimulationApplication/co_simulation_analysis.py,sha256=mSAhsXjYmZ9bnhPN9mE6LtrkezJEzvcNdwrgAs7r978,5120
-KratosMultiphysics/CoSimulationApplication/empire_wrapper.py,sha256=64ZQLxz5EYaTJlEmplepFYuc58Z0SFNgIsLIx1xX238,28310
-KratosMultiphysics/CoSimulationApplication/coupling_interface_data.py,sha256=rW3YVLXFi9FR-ior0sof7j04SvbUVSVftIhmgDOD7R0,12913
-KratosMultiphysics/CoSimulationApplication/fluid_dynamics_analysis_with_co_sim_io.py,sha256=GY4oQErYgznPBKFAD0LCZhAxFlFp35tZ5xI6RDY4-8I,909
-KratosMultiphysics/CoSimulationApplication/co_simulation_tools.py,sha256=VOB6x-uaJnCBGDP_vjr4st8EB88WOzSHCys_HVHKdlU,632
-KratosMultiphysics/CoSimulationApplication/MPIExtension.py,sha256=iuFmS1EIzThetq_T82nvMyQxhaq94bqIUZgpddLrq0Q,145
-KratosMultiphysics/CoSimulationApplication/__init__.py,sha256=q0BTWyjKhfJWJGqQWurFTzxWjloXlUhaPo_5APHn7rY,985
-KratosMultiphysics/CoSimulationApplication/processes/create_point_based_entites_process.py,sha256=vd2xoOEdBbsm4TpVPZfsyO5gYcc5NiRT2hLboe_Fm_8,5919
-KratosMultiphysics/CoSimulationApplication/processes/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/CoSimulationApplication/predictors/average_value_based.py,sha256=1ohLfb-N9HBaCBsfvVkHBTVO114_5yfLxNS6mmjvQOo,1928
-KratosMultiphysics/CoSimulationApplication/predictors/linear_derivative_based.py,sha256=_FDk0trdYBEH_HEN23zOXVItN5JPbOaKx93ZJ6-ojZg,1468
-KratosMultiphysics/CoSimulationApplication/predictors/linear.py,sha256=BtKYDZZ0SjMjxZoiW5cLpPZu1awXTGp3iWy7RJxnVtQ,719
-KratosMultiphysics/CoSimulationApplication/predictors/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/CoSimulationApplication/convergence_criteria/convergence_criteria_wrapper.py,sha256=xdRVbRCpYofoAL4dIZecmoGixX41uodaqHtCQuehJI8,3457
-KratosMultiphysics/CoSimulationApplication/convergence_criteria/relative_norm_previous_residual.py,sha256=xvWbxf4fZwohn4WEIXqZp0zaUlFu7sI_gtzLyTQoCT8,2402
-KratosMultiphysics/CoSimulationApplication/convergence_criteria/relative_norm_initial_residual.py,sha256=QqOCge8QEQBpTOI_PQq5wMf39GbLM7-wVMl0BdlrTBw,2432
-KratosMultiphysics/CoSimulationApplication/convergence_criteria/absolute_norm_energy_conjugate.py,sha256=nreePwbXlgdDHrxsQ-Nfz564AbQ8I_cK0jXNwWE70yM,5509
-KratosMultiphysics/CoSimulationApplication/convergence_criteria/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_convergence_accelerator.py,sha256=GYdrmXf4ObY9wvbjii2wuv-DCVCaGRkPcAEeBUHr8uA,2232
-KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_coupled_solver.py,sha256=Jd9IQKbdL0tfDRNWUg3TLGjiq1HTxO9dPOvykB2QPBw,18602
-KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_coupling_operation.py,sha256=AuDf4HDNwb3mOF_Pi0s97XVvBUquTTEnxkgvjIgMNmw,1628
-KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_data_transfer_operator.py,sha256=cwTRvc-YMNeXOfn19YTRq5cqYWgJpWGYfp-PRhYpsWw,3115
-KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_convergence_criteria.py,sha256=i4p5Hw_5QwSKuXGxP7ZI7WRRgeFvcJ613jx5MRSKFUc,1670
-KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_io.py,sha256=hD252mUT1JiGfrlzp8FOMzQRwbS6RMSrCserAuqC3Dc,2668
-KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_predictor.py,sha256=qc26CKYCpRBPWsvVdpCJdSg-JLw3d_s8ylXh5Pb49UE,2126
-KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_solver_wrapper.py,sha256=Pv4oe_thtO89cXEs5K1z0DvL_jqQ7Hm-uHobw3MZOI0,7497
-KratosMultiphysics/CoSimulationApplication/base_classes/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/CoSimulationApplication/coupling_operations/print_iteration_number.py,sha256=PN2f1B4ET2oQJKt7lVJfqksn_f_X6TWTaXqaRpVpfdU,3300
-KratosMultiphysics/CoSimulationApplication/coupling_operations/compute_boundary_force.py,sha256=zwLPKl80Q6aggwd9iVdU2QOEtPlGJzWZdWI9k2p2lqU,6537
-KratosMultiphysics/CoSimulationApplication/coupling_operations/distribute_point_values.py,sha256=23zUeTJ7WjwrPFh_xPf423WYAtucpjGPZw1DJdHw9Cg,4774
-KratosMultiphysics/CoSimulationApplication/coupling_operations/convert_distributed_values_to_point.py,sha256=T2y4WauUGg2u4VXKmUEwdhuCW2n-tnSxI6Yw0Llu6es,4424
-KratosMultiphysics/CoSimulationApplication/coupling_operations/compute_normals.py,sha256=f5306PaJRHi0dLALszGZ6H5He7-8iefTO1sGtexTXF4,1810
-KratosMultiphysics/CoSimulationApplication/coupling_operations/coupling_output.py,sha256=DodbEouXKoRPtos9wnpNgrG_0ppCZPo9iJmBLVgqBsc,3409
-KratosMultiphysics/CoSimulationApplication/coupling_operations/elemental_data_to_nodal_data.py,sha256=jSmVyvjvCWe8D04SoSvGfTHPsJHp9LWvoVw6DEDzP40,2242
-KratosMultiphysics/CoSimulationApplication/coupling_operations/reset_pfem_kinematics.py,sha256=gwg7XkfPoVBhWPCKrIZxtk-nttJIcOzNXovZ_tH8PGo,1945
-KratosMultiphysics/CoSimulationApplication/coupling_operations/scaling.py,sha256=Bm_xGcPYkbUoUgcV3iOMyW2KXpmbLarNJQ_vmLKOMUw,3502
-KratosMultiphysics/CoSimulationApplication/coupling_operations/create_point_load_model_part.py,sha256=JFmLNF4E_AhkMrWYw61JfMwDYqGM2ReJu3NwVAbkg7g,2134
-KratosMultiphysics/CoSimulationApplication/coupling_operations/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos_co_sim_io.py,sha256=8fuJXfWjM291KKAKXrNzjuziJYcEzjHBIX_MxL8uxjA,5980
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/empire_io.py,sha256=G-0gla7OR2W1LV6WpLcm1WnbbDyUhr8WmNRexcBD1Bk,4173
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/dummy_io.py,sha256=f9paBF7m0WQMlzXSwcOpS5pUD5LIbBRsby8Yjv4u1-0,698
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/existing_co_simulation.py,sha256=V16B8f1aReJLfs4M9mQsq_UsDDFbDHeEWJRW6k1Zye4,729
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/kratos_base_wrapper.py,sha256=6xePGLTHWvUKjRSo6mGk49cUIuU8hGCJ4Q_DdLgeV10,8451
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/particle_mechanics_dirichlet_wrapper.py,sha256=LVvnpZ2dT8MYB-IQBwSpUU-mE1678GQ1qxjBjx4i0SI,799
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/convection_diffusion_wrapper.py,sha256=KTc3EponkXBMURIZxJ9iCCK69wPHOZBI97LfNN8Naqw,1209
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/dem_wrapper.py,sha256=d_T-j1MMcmElN6ijwK-dnR2IfsrQlp7c_AfvZ7eE3PM,2037
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/particle_mechanics_neumann_wrapper.py,sha256=ZIB32mCV7MeOdL1iPPLDWOljVunjfuMNjaTSwLjTXj8,789
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/mpm_neumann_wrapper.py,sha256=Keb3my3_iP_doGX_IvpvrfToMV2lJv0xdyHuCQqfnUA,2490
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/mpm_dirichlet_wrapper.py,sha256=YAyeNErcE8gSobsTgUHMSk8NOkG9-brWkz0PlFJdIYQ,3036
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/structural_mechanics_wrapper.py,sha256=eP2vQoUmHIVgZQ6oXwY5UhumaAfKA3Vo72zxOpg3K_s,1823
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/pfem_fluid_dynamics_wrapper.py,sha256=Plbxpq1boxiNchLNJ2al6tYhPjioFWnKDif9wosUPg4,2822
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/fluid_dynamics_wrapper.py,sha256=BiY1qQuy_s3mkMwzk9m5cUsIRm9UGoN3TSKRObENF4U,2061
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/potential_flow_wrapper.py,sha256=jhYGmWpqmva1COs2Jeraq7dTge2HYUmkHnuZygy4tNI,2794
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/rom_wrapper.py,sha256=UUvnkPARJNLQ-i8IfdFTXcRaHRZniHc4baXPxhPkEDs,1608
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/ping_pong_io.py,sha256=1m2i3XCwX0SXkqyZ0_7nJhBYL5S8a9AKjuSchzOkm3o,3044
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/ping_pong_wrapper.py,sha256=KD553c6A3Z7hCipquKB94wfkgpzjbEryKl8mJTkS21M,2836
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_solver_wrapper.py,sha256=CGAudlQeOQ6yD0DimFXmLAQKWydLFYXhB6mLSWjpkms,2916
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_static_solver.py,sha256=qiIjRFJ6Y8Bj3v5easUvWhMN5rEssdlbgHDatETK2fY,5620
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/static_sdof_solver_wrapper.py,sha256=RkSq6t0beVf5TaVUmSdKTqSJPp9-Ie8NlExWHi-pvWs,1976
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_solver.py,sha256=mIQi1pQTlug5TZkUbmarXQX6jIuuhHbg6xGjjvhbWHI,12765
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/openfoam_wrapper.py,sha256=0aAcoHFV0sshdHK3HRxmLZ1PtR20cjLqeieKK5s7Pio,2479
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/remote_controlled_solver_wrapper.py,sha256=FIbbdGm10rgivJwxz-aEIQIlcOUWAtoTEYjv5-yJEX0,5115
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/flower_wrapper.py,sha256=EUX51w_8vfbQka7mAyfgGDf1zhG6OaqlBp0QXm-yi6g,3778
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/external_solver_wrapper.py,sha256=0E0TxRC9HnpaS0ZI9Dpr3YaUfbeS_UW8U_3XT-7byYc,2521
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/acusolve_wrapper.py,sha256=ulVIAXa83V2nAbF2Dl3GDXxhx-DTFEJBQpm-cypa2Sc,10000
-KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/CoSimulationApplication/helpers/dummy_solver_wrapper.py,sha256=P-AXeO86W20hUJrM_58P2nAD3I2q8dqaCPoHDHqPk0M,1814
-KratosMultiphysics/CoSimulationApplication/helpers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/CoSimulationApplication/utilities/data_communicator_utilities.py,sha256=4daUAKS6GJDiznthN1D6EEI_kmswPDyXBdHXu2umQbM,1711
-KratosMultiphysics/CoSimulationApplication/utilities/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/CoSimulationApplication/utilities/model_part_utilities.py,sha256=4Nrm5K71AaDlefnhZKIn5jyFWVButniulsvGjSc_WUI,4463
-KratosMultiphysics/CoSimulationApplication/factories/data_transfer_operator_factory.py,sha256=H1qrIqGOtgC_xg3NjwjiJwLmNqPuKGQ05viij19eTik,379
-KratosMultiphysics/CoSimulationApplication/factories/helpers.py,sha256=q1XswnQaQ9YzKxBGJ4FCaNUE86aIFxn7aTH-261ge98,4753
-KratosMultiphysics/CoSimulationApplication/factories/solver_wrapper_factory.py,sha256=wj2E1gnE-TrNe_F_kQDaGjXgjUcieRgpn1_Q-4RyY_U,338
-KratosMultiphysics/CoSimulationApplication/factories/coupling_operation_factory.py,sha256=0dYdlLVDBiZDkwird5l3wa015GFoXHBv4jqQV_QMzxo,368
-KratosMultiphysics/CoSimulationApplication/factories/io_factory.py,sha256=GOcMYsLojx6Z6DhTin9UwkCMf5OW-FKQvQ_DizuxIEI,367
-KratosMultiphysics/CoSimulationApplication/factories/convergence_accelerator_factory.py,sha256=3y_YrXVOt4quZkVJL3-ZXcguunQinb3gf9ddAwaJcQk,393
-KratosMultiphysics/CoSimulationApplication/factories/base_factory.py,sha256=iT0pZQ3DWSlkYuhtkbbn-33LAvVTYeBhE0wzEvKwY5Q,929
-KratosMultiphysics/CoSimulationApplication/factories/convergence_criterion_factory.py,sha256=KZcRFI66vuY8IUSyyfz7kGSqft9fJqkCyZWXs32IZlE,381
-KratosMultiphysics/CoSimulationApplication/factories/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/CoSimulationApplication/factories/predictor_factory.py,sha256=vlqSD43bOVCrv3EdauZsPUX-AAecLkbtZC16WWsHwjk,342
-KratosMultiphysics/CoSimulationApplication/convergence_accelerators/convergence_accelerator_wrapper.py,sha256=pGPPsTlaafxSXu6EP4bjpPrWaebNGG1VZnDNQQJAPms,5941
-KratosMultiphysics/CoSimulationApplication/convergence_accelerators/iqnils.py,sha256=065FMFvOQF0RnyJqLcSqOZZMAJgvpD0KJbg0S7j3b38,7593
-KratosMultiphysics/CoSimulationApplication/convergence_accelerators/anderson.py,sha256=ldpxZfk5d3Km7mxupk_wkRZXwouM-uK4r5paSYfStdc,3851
-KratosMultiphysics/CoSimulationApplication/convergence_accelerators/mvqn.py,sha256=1F-Yb0ZveJcOthuNa07mEFSpx1HvLG5xcESR0-o9t9U,4214
-KratosMultiphysics/CoSimulationApplication/convergence_accelerators/aitken.py,sha256=aIskMNUvcSO0ryGP3ipwJBO6Pf_hUCi4K5rXKUM7ykQ,3618
-KratosMultiphysics/CoSimulationApplication/convergence_accelerators/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/CoSimulationApplication/convergence_accelerators/constant_relaxation.py,sha256=BQ11kEBE7U71oq3-tEwqx_8w60zrBavGpYOkUDJ-WB0,1445
-KratosMultiphysics/CoSimulationApplication/coupled_solvers/jacobi_weak.py,sha256=jNCT2I-zrF51yG8STM9k9DzyjW4UE0GMflVo2JnAgEQ,956
-KratosMultiphysics/CoSimulationApplication/coupled_solvers/gauss_seidel_strong.py,sha256=N4l8yGS3mnWKp-jjl2t_uMdtcU8KLsvjtBOhpXUsG7c,6152
-KratosMultiphysics/CoSimulationApplication/coupled_solvers/jacobi_strong.py,sha256=WuRdIpyM3P5sBsyb5VK0lprtrnsEgI5Vfl0Pkw3Z220,6072
-KratosMultiphysics/CoSimulationApplication/coupled_solvers/feti_dynamic_coupled_solver.py,sha256=9S9KaMIz8vXAED23qC-Mt1Oh8H9-h0bxAP7ru7MNJ18,13627
-KratosMultiphysics/CoSimulationApplication/coupled_solvers/gauss_seidel_weak.py,sha256=FyZwGECdi9eJ1f16sLzLJkMM0dwTA_OLLCpP5UoztDA,834
-KratosMultiphysics/CoSimulationApplication/coupled_solvers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/CoSimulationApplication/data_transfer_operators/copy.py,sha256=vJJUfER3XGgkd2T8Sxd3qlkItG-T7ozOOyyTtzAw2bU,1517
-KratosMultiphysics/CoSimulationApplication/data_transfer_operators/sum_distributed_to_single.py,sha256=-mzMEM-O1b0CEkYp36o9CjQA3dMpUeH1-_-vbdHlGZg,2091
-KratosMultiphysics/CoSimulationApplication/data_transfer_operators/sum_many_to_many.py,sha256=o5_NW6ARGabVGlmyyuUbbX__C-c5Xz_M9iv4tDg5Ggw,2214
-KratosMultiphysics/CoSimulationApplication/data_transfer_operators/copy_single_to_distributed.py,sha256=cNeTP-yWyqB3coWbkKkoeQNDpMHaCg5xxADVBhUee7w,284
-KratosMultiphysics/CoSimulationApplication/data_transfer_operators/transfer_one_to_many.py,sha256=I6QSkdAkvnTarMDe9-fUuSFgNd9pyk05kPeL3lS2soU,2839
-KratosMultiphysics/CoSimulationApplication/data_transfer_operators/kratos_mapping.py,sha256=k9e6i8gsBrdsKw8oatU_WfO68W0fUyere9HpBHM5BT0,6955
-KratosMultiphysics/CoSimulationApplication/data_transfer_operators/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosMultiphysics/.libs/KratosCoSimulationApplication.cpython-39-x86_64-linux-gnu.so,sha256=EUU7NIQV_3Cc4H1zbTGLYboCz4V7weisPMtvhk9sna8,2132697
-KratosMultiphysics/.libs/libKratosCoSimulationCore.so,sha256=zZzqt38jdBG0qUgT90TXeX6fo3td1VJ0GlDe41hpSRk,3757481
+KratosMultiphysics/.libs/KratosCoSimulationApplication.pyd,sha256=FG1M5vx2z9_WxyQeHzjAVVpa18mOdYJc3UK-eaOtf5A,750592
+KratosMultiphysics/.libs/KratosCoSimulationCore.dll,sha256=LTUPy8S-yJbb_nHLJc8kr_p0YxfcXVB1mgGv09NpzFc,910336
+KratosMultiphysics/.libs/KratosCoSimulationCore.lib,sha256=elF_ApYBygKqzIaRL_kzxPioQ-XGR_7kJft5JWywRLo,121802
+KratosMultiphysics/.libs/co_sim_io.dll,sha256=jcYsn735UKoi-Ufr0jsYqQPLEWp7XSmQjpkZ21o-A2o,755200
+KratosMultiphysics/.libs/co_sim_io.lib,sha256=Pp6tVc2s09JIoIhjSkuQ7Nnq47KFvRMNu4TIN58Pt58,207786
+KratosMultiphysics/CoSimulationApplication/MainKratosCoSim.py,sha256=WvjKozlWL36qpa0OC12DBCsIVrlHtEa8Ls_HG-D-Cr4,586
+KratosMultiphysics/CoSimulationApplication/__init__.py,sha256=PId_Yx1vjYSbCWG8YzsoD4A5hrkmC-4XpM49NgIoEF0,1008
+KratosMultiphysics/CoSimulationApplication/analysis_stage_with_co_sim_io.py,sha256=HiKtJ7wDRsICO9QDB_OKbH17L7fbZN8-fSP1SPnqQQ8,6006
+KratosMultiphysics/CoSimulationApplication/co_simulation_analysis.py,sha256=J5wJ_xPEij48i_25rLgwV-eC-jU6sIzE2L_1Io8D1RY,5253
+KratosMultiphysics/CoSimulationApplication/co_simulation_tools.py,sha256=gwd_RJkD5pUG-nlWRzQ4WJ5JmRU3OddBLhH9Q577n6U,650
+KratosMultiphysics/CoSimulationApplication/colors.py,sha256=1TiL1eVLuNDbWOVAvoDv3s47cDR56GO_x8Y27p2qrzo,2351
+KratosMultiphysics/CoSimulationApplication/coupling_interface_data.py,sha256=4fcyfx76zUDH7MDLmVMFX7Bj8WUYDzOPijcBjmRyVNY,13186
+KratosMultiphysics/CoSimulationApplication/empire_wrapper.py,sha256=w-FA6wMqkTW2_mn54ncVDO0LcC_of7nKjrbZk6Czxg0,28834
+KratosMultiphysics/CoSimulationApplication/fluid_dynamics_analysis_with_co_sim_io.py,sha256=gU3zxu0vXsask4g4DciO_5Rf-pGJ08lAKAUNvqhXKW0,931
+KratosMultiphysics/CoSimulationApplication/function_callback_utility.py,sha256=79uT5UNJrt4A-6KsDriREyx6QD_uCI-1aTibN7X9LzQ,1538
+KratosMultiphysics/CoSimulationApplication/structural_mechanics_analysis_with_co_sim_io.py,sha256=FU7Y82ExEhwk0floF6IeVlkydw4Bd5WfYt_v12NoUAI,975
+KratosMultiphysics/CoSimulationApplication/base_classes/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_convergence_accelerator.py,sha256=jdX0aT9cpmpsi5QKq3oBTc6-ndfdKFs-R9yA1h6ictg,2298
+KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_convergence_criteria.py,sha256=xuloCmoIpKCmqfcSz_tMoceAHJ9F_HHqu0_FoWiC4VA,1726
+KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_coupled_solver.py,sha256=NTb7YteikUsSZ8dYizM5XBkCK7n034OwJll_AWTiNyI,19041
+KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_coupling_operation.py,sha256=Y0PPNs7mfOQEZymtflIE_pTASxKyrI36HC5JUbZQqYs,1688
+KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_data_transfer_operator.py,sha256=UVl8a89sFvF9w0qp2f43RbTjb4tY3pqCOJxV4p18xGA,3182
+KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_io.py,sha256=R0NONjm9xsqAITF-jjNJBBS6kBDZND1Hy-5qmzXV4yQ,2741
+KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_predictor.py,sha256=LUyrU00I0DOI2zzsGKGNh405xTZ-wy26XpmNLJhuchI,2194
+KratosMultiphysics/CoSimulationApplication/base_classes/co_simulation_solver_wrapper.py,sha256=Ye7DYGnLlAJUy3dEHx-E0NGsN_M3E0WYuS24X__Hzms,7665
+KratosMultiphysics/CoSimulationApplication/convergence_accelerators/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/CoSimulationApplication/convergence_accelerators/aitken.py,sha256=S3VgCnpAoja65n-jnuWiLZZo6QcdKLToyFthIxyIJl0,3704
+KratosMultiphysics/CoSimulationApplication/convergence_accelerators/anderson.py,sha256=msF_8jBRGR9WA6U1voJ2YAVUu8y5Jn57k_j1gUy7XtE,3956
+KratosMultiphysics/CoSimulationApplication/convergence_accelerators/constant_relaxation.py,sha256=Rcn4Jl13c2iGrfweeAaaZ6d9nPN9PLUIvaSp8pazFF8,1487
+KratosMultiphysics/CoSimulationApplication/convergence_accelerators/convergence_accelerator_wrapper.py,sha256=0w5hRKxhAygTmNYySeScngadi3rlyVW5hKl8IzWdQIo,6070
+KratosMultiphysics/CoSimulationApplication/convergence_accelerators/iqnils.py,sha256=6HcBRPNuyWx8SiOY8aIfGhaY_q8nhbTnVYwTk9ziRcM,7762
+KratosMultiphysics/CoSimulationApplication/convergence_accelerators/mvqn.py,sha256=lOkk0x5v0linMwqilejIty6nN9W_a72EcPf-Wep80Bc,4328
+KratosMultiphysics/CoSimulationApplication/convergence_criteria/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/CoSimulationApplication/convergence_criteria/absolute_norm_energy_conjugate.py,sha256=p9MTu6P_xD0re1Iu2kV_4io9XLym9wwX4Zs9_FbSbkY,5641
+KratosMultiphysics/CoSimulationApplication/convergence_criteria/convergence_criteria_wrapper.py,sha256=JeC53WHO-LaKBcgxreFSiEK9A9N5vThh1PnPClJZVaI,3542
+KratosMultiphysics/CoSimulationApplication/convergence_criteria/relative_norm_initial_residual.py,sha256=8SMGsEgsJueeu2K7QCKzbA0WGcwoyZJ-p5QxnD-dyoM,2506
+KratosMultiphysics/CoSimulationApplication/convergence_criteria/relative_norm_previous_residual.py,sha256=8mFKzBacxXp1MmQFgthac3tabllQtE-kGcGn2psZSY8,2474
+KratosMultiphysics/CoSimulationApplication/coupled_solvers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/CoSimulationApplication/coupled_solvers/feti_dynamic_coupled_solver.py,sha256=4msBGn7iEQ0ua8Uxqo6UZa7u3UiCCCiTPlOnUGc8QyE,13897
+KratosMultiphysics/CoSimulationApplication/coupled_solvers/gauss_seidel_strong.py,sha256=aUn3LRlviUn2yIKCJb8Br7qxTuXIokh30rRQFeTFl-U,6311
+KratosMultiphysics/CoSimulationApplication/coupled_solvers/gauss_seidel_weak.py,sha256=DBQKAf_A2LabKyM5MxZTs807eFL0dfApSBnkB7EXia4,854
+KratosMultiphysics/CoSimulationApplication/coupled_solvers/jacobi_strong.py,sha256=kbyN6yVOUEnp2ip7yG8US3qGjDzqSwHCG8i9Iz6Ask4,6230
+KratosMultiphysics/CoSimulationApplication/coupled_solvers/jacobi_weak.py,sha256=CuJCmJO7ksom_IKDzHH4gpKbA0SIuPTdqtpLvwsROSI,980
+KratosMultiphysics/CoSimulationApplication/coupling_operations/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/CoSimulationApplication/coupling_operations/compute_boundary_force.py,sha256=c973Tiz7s0FXfJrjCho5WnYpB4Xsf7_T2kGfTg15k38,6676
+KratosMultiphysics/CoSimulationApplication/coupling_operations/compute_normals.py,sha256=aPfnJrSc06KIC70kh8jmfdiDKr67RkXz04-hLP_RHrA,1870
+KratosMultiphysics/CoSimulationApplication/coupling_operations/convert_distributed_values_to_point.py,sha256=jC4KnTfrnGDQaA80-D8JGTEKAVKcaHrKjPE1MA32QkA,4497
+KratosMultiphysics/CoSimulationApplication/coupling_operations/coupling_output.py,sha256=VpU0uPupLN2XSg82rEbKTXjG5N_aYLQwZ4hEi12gXBw,3485
+KratosMultiphysics/CoSimulationApplication/coupling_operations/create_point_load_model_part.py,sha256=SfvQMPJW-8l0bLFPJYq5VGzsE1U9Tj1e4GI693FaohY,2184
+KratosMultiphysics/CoSimulationApplication/coupling_operations/distribute_point_values.py,sha256=j_5CeljZLBV_Owyyfyr8DlIWTh6xW_V0w-L6x8jcD7g,4854
+KratosMultiphysics/CoSimulationApplication/coupling_operations/elemental_data_to_nodal_data.py,sha256=gvv25JNi7z8oCKRKRQcDSUDObAYBnuUl_NQrwFlbwzA,2301
+KratosMultiphysics/CoSimulationApplication/coupling_operations/print_iteration_number.py,sha256=5eCOChZbjjWvZrvbYhHv1wlZhPHHUMRRiS6j5UhPFDU,3377
+KratosMultiphysics/CoSimulationApplication/coupling_operations/reset_pfem_kinematics.py,sha256=6NT2EgTdUSnjTriFE-KFYMpDVto8C4V2H1POGh2r75k,1992
+KratosMultiphysics/CoSimulationApplication/coupling_operations/scaling.py,sha256=EMyEgbU2UpLgYGcLAiCp_UVfCbNhfxEuN1wv_1nhJeI,3576
+KratosMultiphysics/CoSimulationApplication/data_transfer_operators/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/CoSimulationApplication/data_transfer_operators/copy.py,sha256=nKs0eKG9ONO6V3Zg0sji_n-Mi3MaMZBQ7whWleySVug,1546
+KratosMultiphysics/CoSimulationApplication/data_transfer_operators/copy_single_to_distributed.py,sha256=2_zBXwBJXym8S_ml4XxJaAGPK1WzEbfAqeVvlaRCxz0,290
+KratosMultiphysics/CoSimulationApplication/data_transfer_operators/kratos_mapping.py,sha256=yEcSEIfzF8a7dDAnWBSeBBiC52y4wns652xpWBG6qHI,7097
+KratosMultiphysics/CoSimulationApplication/data_transfer_operators/sum_distributed_to_single.py,sha256=BL9Vuv4a_QyUuEl6DzRIldRgqtmMIfxPaDohKGJCvA0,2139
+KratosMultiphysics/CoSimulationApplication/data_transfer_operators/sum_many_to_many.py,sha256=edjQEVNxsbGcO6yXNegxBgN6ZoaJ9Vw6OBmJ49m7Ueg,2263
+KratosMultiphysics/CoSimulationApplication/data_transfer_operators/transfer_one_to_many.py,sha256=wwTjtkunsks8EsuFVla_nbPg58dWVoMhX9C79MVFI2M,2897
+KratosMultiphysics/CoSimulationApplication/factories/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/CoSimulationApplication/factories/base_factory.py,sha256=XTy_XqVHncD9_sa612_M_0cLl3aZi1XGHz7S4bYiRXM,949
+KratosMultiphysics/CoSimulationApplication/factories/convergence_accelerator_factory.py,sha256=delyUqT2XaAI08hJleRPHFtFTZb0CJathQTmUapuGSg,398
+KratosMultiphysics/CoSimulationApplication/factories/convergence_criterion_factory.py,sha256=9ftVwsjt05Ye20jduXmqg-MxNN71GPiuEf-YUsyJUec,386
+KratosMultiphysics/CoSimulationApplication/factories/coupling_operation_factory.py,sha256=5LSHoVj9RU7lftKm_olV13LZKlb-T921mVudQBW_jZg,373
+KratosMultiphysics/CoSimulationApplication/factories/data_transfer_operator_factory.py,sha256=6s0_yvHVtGdtUh1ogD2HKLlG8yJ94dQy-6HF4FSY9yk,384
+KratosMultiphysics/CoSimulationApplication/factories/helpers.py,sha256=PKYMMS7SSMVCyMeh6Qv5qQ-yOvtV2oCUhi9doaLqCsE,4831
+KratosMultiphysics/CoSimulationApplication/factories/io_factory.py,sha256=TKThfAF39PoaKalYJVVEBfFL7b_9Wqbq6nZpBIcvFLU,372
+KratosMultiphysics/CoSimulationApplication/factories/predictor_factory.py,sha256=wT5bo0KYDMGL42rt3nHpNHDMsdFo47oexI9CBERgWHA,347
+KratosMultiphysics/CoSimulationApplication/factories/solver_wrapper_factory.py,sha256=Y-LtkRAosmiRlrtKHUVAMLWfBeolElclO4OFPVovvSM,343
+KratosMultiphysics/CoSimulationApplication/helpers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/CoSimulationApplication/helpers/dummy_solver_wrapper.py,sha256=1SpKJC2zhJn4rECo7q8h4pIknYs9PWi9pM1icZ0-t_s,1853
+KratosMultiphysics/CoSimulationApplication/predictors/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/CoSimulationApplication/predictors/average_value_based.py,sha256=PS6AlEOwMRdJdQeRXWTayhxi-CHLMsc2c_cFL97k7D4,1979
+KratosMultiphysics/CoSimulationApplication/predictors/linear.py,sha256=ZN_Ck1xVLETCddhvbFBHEGPI137P8CVoiC_3v9o5CoU,739
+KratosMultiphysics/CoSimulationApplication/predictors/linear_derivative_based.py,sha256=9ulzJ0exmUbGQLAtNNK2IcCPR7yura40lyv7a4_XmIc,1507
+KratosMultiphysics/CoSimulationApplication/processes/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/CoSimulationApplication/processes/create_point_based_entites_process.py,sha256=UTw8DpgSIh4P9yADyC7bFMb6x8_Cr9ka4Tk5-JPM-aQ,6031
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/dummy_io.py,sha256=4SqGghd8h7NGXQPvWsc1UxtZ0cFv189rXqS2G4zeIAg,726
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/empire_io.py,sha256=Sd9blBxj6Wyni4KozUZad301ROpJXyKSX3NdHjkLF5g,4264
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/existing_co_simulation.py,sha256=lSTGlLWZD3mVagH1HEwHgKaCExsZfO_ITOUCEE5zXh0,747
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos_co_sim_io.py,sha256=Q7uT8wMoR_1ZEkzc-7_e9afyP7HiUE2GWnh3z3bSSfg,6118
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/ping_pong_io.py,sha256=0i7qogVUEaL-mXU_X4_GAUfvQIrI1bBFzjKXzb8HtXs,3113
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/cpp_ping_pong/ping_pong_wrapper.py,sha256=8vVpC6W_XRp32RtgCgJA2zvakZ5vBMhWSWcRAj-aW18,2906
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/acusolve_wrapper.py,sha256=82e_f7Xgutyw8brNZ_qasIJLH7rK_hBeOhO_77Lxtgg,10201
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/external_solver_wrapper.py,sha256=yoJCYyLWaHrUbH8qBL9icygMwoN6iR-72oNsQcBcKfk,2580
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/flower_wrapper.py,sha256=ubBK1C_9fVn-8Mss8UVHQ00rW3Wv7qMsBKHfumKL9GE,3864
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/openfoam_wrapper.py,sha256=lM0gOWKA830r0OZdYzcvzUsDDdNQoDs59Db-qDj274k,2540
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/external/remote_controlled_solver_wrapper.py,sha256=fOnBlTChjP1qsSjEM-ABT4N-DdDhPCOcPXgwuSHPns0,5236
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/convection_diffusion_wrapper.py,sha256=Bt1CewG4AMv1BKaDxRJQ4cJ8Sr7-OREml00VO0dxlKA,1234
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/dem_wrapper.py,sha256=pGnyCHQ4w4scrWNeKejnQ_g8QxSA73pkYs_br-T-T1A,2088
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/fluid_dynamics_wrapper.py,sha256=N9XsjTKQqLDsU5aL-ZAt3E__QMI0gn8nQCt3UXLDJ8U,2104
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/kratos_base_wrapper.py,sha256=k8pBx3-qiIvF7S2vZbHBEfVuyP4_kQyuOKslMReYzuE,8620
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/mpm_dirichlet_wrapper.py,sha256=24Durm10ImxKS_m6bAGgXEN1R_FbbGBR5W1LlOX6R4I,3096
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/mpm_neumann_wrapper.py,sha256=5hGjnq8tx0DXBEFfrsdC_ymgSuZNUwKb8i9mcQmX8Dc,2542
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/particle_mechanics_dirichlet_wrapper.py,sha256=nntCK1bb1UAKpDGllNI8PZGHvdWjT5PxaugE0sV_ZXI,814
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/particle_mechanics_neumann_wrapper.py,sha256=K-9w1lcNdy1vylq5yPB53n6eySzFgZ0hUjI3QOl53p8,804
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/pfem_fluid_dynamics_wrapper.py,sha256=Plbxpq1boxiNchLNJ2al6tYhPjioFWnKDif9wosUPg4,2822
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/potential_flow_wrapper.py,sha256=4Tha92_HywNShHqFS59ahMlrm-kohuBrJqnOPOfBMY8,2848
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/rom_wrapper.py,sha256=4h5dM1_JKeB6Wd0twrxSgFRjl5C4SP-rEHesxSomMZk,1640
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/kratos/structural_mechanics_wrapper.py,sha256=MFdUt_s0sLVHLBnCJ6VqSP-wmAm3LCRTDArTX743PU4,1862
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_solver.py,sha256=qAxMcLinWqHWFztfimSl8Bqj0lFe26tWa5ctgvCnw0E,13049
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_solver_wrapper.py,sha256=RdC3xi1EVPEpMWRzHi11xKJa0-OCUPTO3lxJbOYdGyI,2982
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/sdof_static_solver.py,sha256=SprOKVuAoPAbNJqe2PAFv1HDyNo9FG7F0eBKy6S12hE,5765
+KratosMultiphysics/CoSimulationApplication/solver_wrappers/sdof/static_sdof_solver_wrapper.py,sha256=AtVOjUP1-Li6s1x2_Zn640V6ITU0jKD4ERF_PnF2ptA,2019
+KratosMultiphysics/CoSimulationApplication/utilities/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/CoSimulationApplication/utilities/data_communicator_utilities.py,sha256=rIbsNAZeUcAiHsRap3O9rnFRITQKbj7QokzNX4VFbx0,1751
+KratosMultiphysics/CoSimulationApplication/utilities/model_part_utilities.py,sha256=9m9EBSxvAuh8VuqRLst5M54m4q9e5sDKZMch7GQb3vI,4535
+KratosCoSimulationApplication-9.5.1.dist-info/METADATA,sha256=quHmYsV6rj7c3ovJMdODEB0Aiumrcap2a9evF5b9GBc,26723
+KratosCoSimulationApplication-9.5.1.dist-info/WHEEL,sha256=GZFS91_ufm4WrNPBaFVPB9MvOXR6bMZQhPcZRRTN5YM,100
+KratosCoSimulationApplication-9.5.1.dist-info/top_level.txt,sha256=8Ov--opRCptLbHStjyiZUVpzN1OUU_F7c7fGmsR5cMc,19
+KratosCoSimulationApplication-9.5.1.dist-info/RECORD,,
```


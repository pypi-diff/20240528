# Comparing `tmp/KratosConvectionDiffusionApplication-9.5-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip` & `tmp/KratosConvectionDiffusionApplication-9.5.1-cp39-cp39-win_amd64.whl.zip`

## zipinfo -v {}

 * *Differences in extra fields detected; using output from zipinfo -v*

```diff
@@ -1,1193 +1,800 @@
 There is no zipfile comment.
 
 End-of-central-directory record:
 -------------------------------
 
-  Zip archive file size:                   3788652 (000000000039CF6Ch)
-  Actual end-cent-dir record offset:       3788630 (000000000039CF56h)
-  Expected end-cent-dir record offset:     3788630 (000000000039CF56h)
+  Zip archive file size:                   1405351 (00000000001571A7h)
+  Actual end-cent-dir record offset:       1405329 (0000000000157191h)
+  Expected end-cent-dir record offset:     1405329 (0000000000157191h)
   (based on the length of the central directory and its expected offset)
 
   This zipfile constitutes the sole disk of a single-part archive; its
-  central directory contains 32 entries.
-  The central directory is 4686 (000000000000124Eh) bytes long,
+  central directory contains 27 entries.
+  The central directory is 3443 (0000000000000D73h) bytes long,
   and its (expected) offset in bytes from the beginning of the zipfile
-  is 3783944 (000000000039BD08h).
+  is 1401886 (000000000015641Eh).
 
 
 Central directory entry #1:
 ---------------------------
 
-  KratosConvectionDiffusionApplication-9.5.dist-info/
+  KratosMultiphysics/.libs/KratosConvectionDiffusionApplication.pyd
 
   offset of local header from start of archive:   0
                                                   (0000000000000000h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:33 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:33 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             51 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:28
+  32-bit CRC value (hex):                         bfe474fd
+  compressed size:                                694429 bytes
+  uncompressed size:                              2300928 bytes
+  length of filename:                             65 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #2:
 ---------------------------
 
-  KratosConvectionDiffusionApplication-9.5.dist-info/METADATA
+  KratosMultiphysics/.libs/KratosConvectionDiffusionCore.dll
 
-  offset of local header from start of archive:   109
-                                                  (000000000000006Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   694524
+                                                  (00000000000A98FCh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         be3f27e9
-  compressed size:                                1050 bytes
-  uncompressed size:                              2670 bytes
-  length of filename:                             59 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:28
+  32-bit CRC value (hex):                         225bcc9f
+  compressed size:                                649268 bytes
+  uncompressed size:                              2008576 bytes
+  length of filename:                             58 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #3:
 ---------------------------
 
-  KratosConvectionDiffusionApplication-9.5.dist-info/WHEEL
+  KratosMultiphysics/.libs/KratosConvectionDiffusionCore.lib
 
-  offset of local header from start of archive:   1276
-                                                  (00000000000004FCh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1343880
+                                                  (0000000000148188h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         90d34e0d
-  compressed size:                                116 bytes
-  uncompressed size:                              148 bytes
-  length of filename:                             56 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:28
+  32-bit CRC value (hex):                         6b86aff5
+  compressed size:                                17293 bytes
+  uncompressed size:                              221526 bytes
+  length of filename:                             58 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #4:
 ---------------------------
 
-  KratosConvectionDiffusionApplication-9.5.dist-info/top_level.txt
+  KratosMultiphysics/ConvectionDiffusionApplication/__init__.py
 
-  offset of local header from start of archive:   1506
-                                                  (00000000000005E2h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1361261
+                                                  (000000000014C56Dh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         f32d789f
-  compressed size:                                19 bytes
-  uncompressed size:                              19 bytes
-  length of filename:                             64 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         6d869a6d
+  compressed size:                                140 bytes
+  uncompressed size:                              312 bytes
+  length of filename:                             61 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #5:
 ---------------------------
 
-  KratosConvectionDiffusionApplication-9.5.dist-info/RECORD
+  KratosMultiphysics/ConvectionDiffusionApplication/adjoint_diffusion_solver.py
 
-  offset of local header from start of archive:   1647
-                                                  (000000000000066Fh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1361492
+                                                  (000000000014C654h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:33 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:33 UTC
-  32-bit CRC value (hex):                         abfc13aa
-  compressed size:                                1450 bytes
-  uncompressed size:                              3766 bytes
-  length of filename:                             57 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         ef5e1bdb
+  compressed size:                                2711 bytes
+  uncompressed size:                              12240 bytes
+  length of filename:                             77 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100664 octal):            -rw-rw-r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #6:
 ---------------------------
 
-  KratosConvectionDiffusionApplication.libs/
+  KratosMultiphysics/ConvectionDiffusionApplication/apply_thermal_face_process.py
 
-  offset of local header from start of archive:   3212
-                                                  (0000000000000C8Ch) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1364310
+                                                  (000000000014D156h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:33 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:33 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             42 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         d0cc8bfd
+  compressed size:                                1026 bytes
+  uncompressed size:                              3141 bytes
+  length of filename:                             79 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #7:
 ---------------------------
 
-  KratosConvectionDiffusionApplication.libs/libKratosConvectionDiffusionCore-775db808.so
+  KratosMultiphysics/ConvectionDiffusionApplication/conjugate_heat_transfer_solver.py
 
-  offset of local header from start of archive:   3312
-                                                  (0000000000000CF0h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1365445
+                                                  (000000000014D5C5h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         c778f53c
-  compressed size:                                2171588 bytes
-  uncompressed size:                              8135737 bytes
-  length of filename:                             86 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         4f935f66
+  compressed size:                                4989 bytes
+  uncompressed size:                              29159 bytes
+  length of filename:                             83 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100755 octal):            -rwxr-xr-x
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #8:
 ---------------------------
 
-  KratosMultiphysics/
-
-  offset of local header from start of archive:   2175044
-                                                  (0000000000213044h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             19 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #9:
----------------------------
-
-  KratosMultiphysics/.libs/
-
-  offset of local header from start of archive:   2175121
-                                                  (0000000000213091h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:34
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:33 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:33 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             25 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #10:
----------------------------
-
-  KratosMultiphysics/.libs/KratosConvectionDiffusionApplication.cpython-39-x86_64-linux-gnu.so
+  KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_analysis.py
 
-  offset of local header from start of archive:   2175204
-                                                  (00000000002130E4h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1370547
+                                                  (000000000014E9B3h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         631e2f52
-  compressed size:                                1570419 bytes
-  uncompressed size:                              4287857 bytes
-  length of filename:                             92 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         653110b9
+  compressed size:                                968 bytes
+  uncompressed size:                              2694 bytes
+  length of filename:                             82 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100755 octal):            -rwxr-xr-x
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #11:
----------------------------
-
-  KratosMultiphysics/ConvectionDiffusionApplication/
-
-  offset of local header from start of archive:   3745773
-                                                  (00000000003927EDh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             50 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #12:
+Central directory entry #9:
 ---------------------------
 
   KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_explicit_solver.py
 
-  offset of local header from start of archive:   3745881
-                                                  (0000000000392859h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1371627
+                                                  (000000000014EDEBh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         8586e9dc
-  compressed size:                                1051 bytes
-  uncompressed size:                              3461 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         82f36b68
+  compressed size:                                1063 bytes
+  uncompressed size:                              3552 bytes
   length of filename:                             89 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #13:
----------------------------
-
-  KratosMultiphysics/ConvectionDiffusionApplication/response_functions/
-
-  offset of local header from start of archive:   3747079
-                                                  (0000000000392D07h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             69 characters
-  length of extra field:                          24 bytes
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
-Central directory entry #14:
+Central directory entry #10:
 ---------------------------
 
-  KratosMultiphysics/ConvectionDiffusionApplication/response_functions/convection_diffusion_response_function_factory.py
+  KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_semi_eulerian_solver.py
 
-  offset of local header from start of archive:   3747206
-                                                  (0000000000392D86h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1372809
+                                                  (000000000014F289h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         5554a676
-  compressed size:                                290 bytes
-  uncompressed size:                              620 bytes
-  length of filename:                             118 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         f75f9e78
+  compressed size:                                1838 bytes
+  uncompressed size:                              7288 bytes
+  length of filename:                             94 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #15:
+Central directory entry #11:
 ---------------------------
 
-  KratosMultiphysics/ConvectionDiffusionApplication/response_functions/convection_diffusion_response.py
+  KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_solver.py
 
-  offset of local header from start of archive:   3747672
-                                                  (0000000000392F58h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1374771
+                                                  (000000000014FA33h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         cf2c2981
-  compressed size:                                1641 bytes
-  uncompressed size:                              6796 bytes
-  length of filename:                             101 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #16:
----------------------------
-
-  KratosMultiphysics/ConvectionDiffusionApplication/response_functions/__init__.py
-
-  offset of local header from start of archive:   3749472
-                                                  (0000000000393660h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         dc35cc6b
+  compressed size:                                7887 bytes
+  uncompressed size:                              45858 bytes
   length of filename:                             80 characters
-  length of extra field:                          24 bytes
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #17:
+Central directory entry #12:
 ---------------------------
 
-  KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_matrix_solver.py
+  KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_embedded_solver.py
 
-  offset of local header from start of archive:   3749610
-                                                  (00000000003936EAh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1382768
+                                                  (0000000000151970h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         5142087e
-  compressed size:                                1071 bytes
-  uncompressed size:                              3342 bytes
-  length of filename:                             98 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         914cbbde
+  compressed size:                                1998 bytes
+  uncompressed size:                              7854 bytes
+  length of filename:                             100 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #18:
+Central directory entry #13:
 ---------------------------
 
-  KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_embedded_solver.py
+  KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_matrix_solver.py
 
-  offset of local header from start of archive:   3750837
-                                                  (0000000000393BB5h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1384896
+                                                  (00000000001521C0h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         a03dab5b
-  compressed size:                                1983 bytes
-  uncompressed size:                              7701 bytes
-  length of filename:                             100 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         dbc8b59b
+  compressed size:                                1084 bytes
+  uncompressed size:                              3427 bytes
+  length of filename:                             98 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #19:
+Central directory entry #14:
 ---------------------------
 
-  KratosMultiphysics/ConvectionDiffusionApplication/conjugate_heat_transfer_solver.py
+  KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_shifted_boundary_solver.py
 
-  offset of local header from start of archive:   3752978
-                                                  (0000000000394412h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1386108
+                                                  (000000000015267Ch) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         b2d8d661
-  compressed size:                                4965 bytes
-  uncompressed size:                              28624 bytes
-  length of filename:                             83 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         1f3019ec
+  compressed size:                                1665 bytes
+  uncompressed size:                              6021 bytes
+  length of filename:                             108 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #20:
+Central directory entry #15:
 ---------------------------
 
-  KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_analysis.py
+  KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_solver.py
 
-  offset of local header from start of archive:   3758084
-                                                  (0000000000395804h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1387911
+                                                  (0000000000152D87h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         d55e9a20
-  compressed size:                                960 bytes
-  uncompressed size:                              2634 bytes
-  length of filename:                             82 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         e955ae09
+  compressed size:                                947 bytes
+  uncompressed size:                              2630 bytes
+  length of filename:                             91 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #21:
+Central directory entry #16:
 ---------------------------
 
   KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_transient_solver.py
 
-  offset of local header from start of archive:   3759184
-                                                  (0000000000395C50h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1388979
+                                                  (00000000001531B3h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         37f9eeef
-  compressed size:                                948 bytes
-  uncompressed size:                              2671 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         8882c98f
+  compressed size:                                958 bytes
+  uncompressed size:                              2731 bytes
   length of filename:                             90 characters
-  length of extra field:                          24 bytes
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #22:
+Central directory entry #17:
 ---------------------------
 
   KratosMultiphysics/ConvectionDiffusionApplication/coupled_fluid_thermal_solver.py
 
-  offset of local header from start of archive:   3760280
-                                                  (0000000000396098h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1390057
+                                                  (00000000001535E9h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         13d52ac0
-  compressed size:                                1965 bytes
-  uncompressed size:                              7782 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         f111b266
+  compressed size:                                1977 bytes
+  uncompressed size:                              7970 bytes
   length of filename:                             81 characters
-  length of extra field:                          24 bytes
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #23:
+Central directory entry #18:
 ---------------------------
 
-  KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_solver.py
+  KratosMultiphysics/ConvectionDiffusionApplication/coupled_structural_thermal_solver.py
 
-  offset of local header from start of archive:   3762384
-                                                  (00000000003968D0h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1392145
+                                                  (0000000000153E11h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         1f35e773
-  compressed size:                                7857 bytes
-  uncompressed size:                              45051 bytes
-  length of filename:                             80 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         0c35d799
+  compressed size:                                1673 bytes
+  uncompressed size:                              7245 bytes
+  length of filename:                             86 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #24:
+Central directory entry #19:
 ---------------------------
 
-  KratosMultiphysics/ConvectionDiffusionApplication/adjoint_diffusion_solver.py
+  KratosMultiphysics/ConvectionDiffusionApplication/move_particle_utility_process.py
 
-  offset of local header from start of archive:   3770379
-                                                  (000000000039880Bh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1393934
+                                                  (000000000015450Eh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         ca41b8a5
-  compressed size:                                2697 bytes
-  uncompressed size:                              11985 bytes
-  length of filename:                             77 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         37facc4b
+  compressed size:                                1133 bytes
+  uncompressed size:                              4289 bytes
+  length of filename:                             82 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #25:
+Central directory entry #20:
 ---------------------------
 
-  KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_semi_eulerian_solver.py
+  KratosMultiphysics/ConvectionDiffusionApplication/python_solvers_wrapper_convection_diffusion.py
 
-  offset of local header from start of archive:   3773211
-                                                  (000000000039931Bh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1395179
+                                                  (00000000001549EBh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         49a5158f
-  compressed size:                                1828 bytes
-  uncompressed size:                              7131 bytes
-  length of filename:                             94 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         91341b4d
+  compressed size:                                1236 bytes
+  uncompressed size:                              6376 bytes
+  length of filename:                             96 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #26:
+Central directory entry #21:
 ---------------------------
 
-  KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_solver.py
+  KratosMultiphysics/ConvectionDiffusionApplication/response_functions/__init__.py
 
-  offset of local header from start of archive:   3775191
-                                                  (0000000000399AD7h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1396541
+                                                  (0000000000154F3Dh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         40383903
-  compressed size:                                934 bytes
-  uncompressed size:                              2577 bytes
-  length of filename:                             91 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         00000000
+  compressed size:                                2 bytes
+  uncompressed size:                              0 bytes
+  length of filename:                             80 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #27:
+Central directory entry #22:
 ---------------------------
 
-  KratosMultiphysics/ConvectionDiffusionApplication/move_particle_utility_process.py
+  KratosMultiphysics/ConvectionDiffusionApplication/response_functions/convection_diffusion_response.py
 
-  offset of local header from start of archive:   3776274
-                                                  (0000000000399F12h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1396653
+                                                  (0000000000154FADh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         5402cbb1
-  compressed size:                                1122 bytes
-  uncompressed size:                              4206 bytes
-  length of filename:                             82 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         5cbded05
+  compressed size:                                1658 bytes
+  uncompressed size:                              6941 bytes
+  length of filename:                             101 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #28:
+Central directory entry #23:
 ---------------------------
 
-  KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_shifted_boundary_solver.py
+  KratosMultiphysics/ConvectionDiffusionApplication/response_functions/convection_diffusion_response_function_factory.py
 
-  offset of local header from start of archive:   3777536
-                                                  (000000000039A400h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1398442
+                                                  (00000000001556AAh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         8e16e9f2
-  compressed size:                                1654 bytes
-  uncompressed size:                              5907 bytes
-  length of filename:                             108 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:54
+  32-bit CRC value (hex):                         6cc936c0
+  compressed size:                                299 bytes
+  uncompressed size:                              633 bytes
+  length of filename:                             118 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #29:
+Central directory entry #24:
 ---------------------------
 
-  KratosMultiphysics/ConvectionDiffusionApplication/__init__.py
+  KratosConvectionDiffusionApplication-9.5.1.dist-info/METADATA
 
-  offset of local header from start of archive:   3779356
-                                                  (000000000039AB1Ch) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1398889
+                                                  (0000000000155869h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         e0542744
-  compressed size:                                135 bytes
-  uncompressed size:                              304 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:28
+  32-bit CRC value (hex):                         146ec2e0
+  compressed size:                                1070 bytes
+  uncompressed size:                              2791 bytes
   length of filename:                             61 characters
-  length of extra field:                          24 bytes
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #30:
+Central directory entry #25:
 ---------------------------
 
-  KratosMultiphysics/ConvectionDiffusionApplication/apply_thermal_face_process.py
+  KratosConvectionDiffusionApplication-9.5.1.dist-info/WHEEL
 
-  offset of local header from start of archive:   3779610
-                                                  (000000000039AC1Ah) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1400050
+                                                  (0000000000155CF2h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         10620e26
-  compressed size:                                1017 bytes
-  uncompressed size:                              3085 bytes
-  length of filename:                             79 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:28
+  32-bit CRC value (hex):                         86fb6b41
+  compressed size:                                96 bytes
+  uncompressed size:                              100 bytes
+  length of filename:                             58 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #31:
+Central directory entry #26:
 ---------------------------
 
-  KratosMultiphysics/ConvectionDiffusionApplication/coupled_structural_thermal_solver.py
+  KratosConvectionDiffusionApplication-9.5.1.dist-info/top_level.txt
 
-  offset of local header from start of archive:   3780764
-                                                  (000000000039B09Ch) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1400234
+                                                  (0000000000155DAAh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         cb166059
-  compressed size:                                1659 bytes
-  uncompressed size:                              7071 bytes
-  length of filename:                             86 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:28
+  32-bit CRC value (hex):                         f32d789f
+  compressed size:                                21 bytes
+  uncompressed size:                              19 bytes
+  length of filename:                             66 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #32:
+Central directory entry #27:
 ---------------------------
 
-  KratosMultiphysics/ConvectionDiffusionApplication/python_solvers_wrapper_convection_diffusion.py
+  KratosConvectionDiffusionApplication-9.5.1.dist-info/RECORD
 
-  offset of local header from start of archive:   3782567
-                                                  (000000000039B7A7h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   1400351
+                                                  (0000000000155E1Fh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 15:57:26
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 15:57:26 UTC
-  32-bit CRC value (hex):                         abd4608c
-  compressed size:                                1223 bytes
-  uncompressed size:                              6266 bytes
-  length of filename:                             96 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:28
+  32-bit CRC value (hex):                         92ec2b21
+  compressed size:                                1446 bytes
+  uncompressed size:                              3689 bytes
+  length of filename:                             59 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B400 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
```

## zipnote {}

```diff
@@ -1,97 +1,82 @@
-Filename: KratosConvectionDiffusionApplication-9.5.dist-info/
+Filename: KratosMultiphysics/.libs/KratosConvectionDiffusionApplication.pyd
 Comment: 
 
-Filename: KratosConvectionDiffusionApplication-9.5.dist-info/METADATA
+Filename: KratosMultiphysics/.libs/KratosConvectionDiffusionCore.dll
 Comment: 
 
-Filename: KratosConvectionDiffusionApplication-9.5.dist-info/WHEEL
+Filename: KratosMultiphysics/.libs/KratosConvectionDiffusionCore.lib
 Comment: 
 
-Filename: KratosConvectionDiffusionApplication-9.5.dist-info/top_level.txt
-Comment: 
-
-Filename: KratosConvectionDiffusionApplication-9.5.dist-info/RECORD
-Comment: 
-
-Filename: KratosConvectionDiffusionApplication.libs/
-Comment: 
-
-Filename: KratosConvectionDiffusionApplication.libs/libKratosConvectionDiffusionCore-775db808.so
+Filename: KratosMultiphysics/ConvectionDiffusionApplication/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/
+Filename: KratosMultiphysics/ConvectionDiffusionApplication/adjoint_diffusion_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/.libs/
+Filename: KratosMultiphysics/ConvectionDiffusionApplication/apply_thermal_face_process.py
 Comment: 
 
-Filename: KratosMultiphysics/.libs/KratosConvectionDiffusionApplication.cpython-39-x86_64-linux-gnu.so
+Filename: KratosMultiphysics/ConvectionDiffusionApplication/conjugate_heat_transfer_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/ConvectionDiffusionApplication/
+Filename: KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_analysis.py
 Comment: 
 
 Filename: KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_explicit_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/ConvectionDiffusionApplication/response_functions/
-Comment: 
-
-Filename: KratosMultiphysics/ConvectionDiffusionApplication/response_functions/convection_diffusion_response_function_factory.py
+Filename: KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_semi_eulerian_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/ConvectionDiffusionApplication/response_functions/convection_diffusion_response.py
+Filename: KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/ConvectionDiffusionApplication/response_functions/__init__.py
+Filename: KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_embedded_solver.py
 Comment: 
 
 Filename: KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_matrix_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_embedded_solver.py
-Comment: 
-
-Filename: KratosMultiphysics/ConvectionDiffusionApplication/conjugate_heat_transfer_solver.py
+Filename: KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_shifted_boundary_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_analysis.py
+Filename: KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_solver.py
 Comment: 
 
 Filename: KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_transient_solver.py
 Comment: 
 
 Filename: KratosMultiphysics/ConvectionDiffusionApplication/coupled_fluid_thermal_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_solver.py
+Filename: KratosMultiphysics/ConvectionDiffusionApplication/coupled_structural_thermal_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/ConvectionDiffusionApplication/adjoint_diffusion_solver.py
+Filename: KratosMultiphysics/ConvectionDiffusionApplication/move_particle_utility_process.py
 Comment: 
 
-Filename: KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_semi_eulerian_solver.py
+Filename: KratosMultiphysics/ConvectionDiffusionApplication/python_solvers_wrapper_convection_diffusion.py
 Comment: 
 
-Filename: KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_solver.py
+Filename: KratosMultiphysics/ConvectionDiffusionApplication/response_functions/__init__.py
 Comment: 
 
-Filename: KratosMultiphysics/ConvectionDiffusionApplication/move_particle_utility_process.py
+Filename: KratosMultiphysics/ConvectionDiffusionApplication/response_functions/convection_diffusion_response.py
 Comment: 
 
-Filename: KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_shifted_boundary_solver.py
+Filename: KratosMultiphysics/ConvectionDiffusionApplication/response_functions/convection_diffusion_response_function_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/ConvectionDiffusionApplication/__init__.py
+Filename: KratosConvectionDiffusionApplication-9.5.1.dist-info/METADATA
 Comment: 
 
-Filename: KratosMultiphysics/ConvectionDiffusionApplication/apply_thermal_face_process.py
+Filename: KratosConvectionDiffusionApplication-9.5.1.dist-info/WHEEL
 Comment: 
 
-Filename: KratosMultiphysics/ConvectionDiffusionApplication/coupled_structural_thermal_solver.py
+Filename: KratosConvectionDiffusionApplication-9.5.1.dist-info/top_level.txt
 Comment: 
 
-Filename: KratosMultiphysics/ConvectionDiffusionApplication/python_solvers_wrapper_convection_diffusion.py
+Filename: KratosConvectionDiffusionApplication-9.5.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v1.0 to extract, compression method=store
+Zip archive data, at least v2.0 to extract, compression method=deflate
```

## KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_explicit_solver.py

 * *Ordering differences only*

```diff
@@ -1,91 +1,91 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.ConvectionDiffusionApplication as ConvectionDiffusionApplication
-
-# Import base class file
-from KratosMultiphysics.ConvectionDiffusionApplication import convection_diffusion_solver
-
-
-def CreateSolver(model, custom_settings):
-    return ConvectionDiffusionExplicitSolver(model, custom_settings)
-
-
-class ConvectionDiffusionExplicitSolver(convection_diffusion_solver.ConvectionDiffusionSolver):
-    """
-    The explicit class for convection-diffusion solvers.
-    See convection_diffusion_solver.py for more information.
-    """
-
-    def __init__(self, model, custom_settings):
-        # Construct the base solver and validate the remaining settings in the base class
-        super().__init__(model, custom_settings)
-
-        # Overwrite the base solver minimum buffer size
-        self.min_buffer_size = 2
-
-        element_name = self.settings["element_replace_settings"]["element_name"].GetString()
-        if self.settings["use_orthogonal_subscales"].GetBool() is True:
-            oss_element_list = ["QSConvectionDiffusionExplicit", "DConvectionDiffusionExplicit"]
-            if element_name in oss_element_list:
-                self.main_model_part.ProcessInfo.SetValue(
-                    KratosMultiphysics.OSS_SWITCH, 1
-                )
-            else:
-                err_msg = (
-                    "The selected element",
-                    element_name,
-                    "does not support OSS projection. Select QSConvectionDiffusionExplicit or DConvectionDiffusionExplicit instead.",
-                )
-                raise Exception(err_msg)
-        else:
-            if element_name in (
-                "QSConvectionDiffusionExplicit",
-                "DConvectionDiffusionExplicit",
-            ):
-                self.main_model_part.ProcessInfo.SetValue(
-                    KratosMultiphysics.OSS_SWITCH, 0
-                )
-
-        KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "Construction finished")
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        default_settings = KratosMultiphysics.Parameters(
-        """
-        {
-            "time_integration_method" : "explicit",
-            "use_orthogonal_subscales" : false,
-            "dynamic_tau": 1.0
-        }
-        """
-        )
-
-        default_settings.AddMissingParameters(super().GetDefaultParameters())
-        return default_settings
-
-    def Initialize(self):
-        super().Initialize()
-        self.GetComputingModelPart().ProcessInfo[KratosMultiphysics.DYNAMIC_TAU] = self.settings["dynamic_tau"].GetDouble()
-
-    #### Private functions ####
-
-    def _CreateBuilderAndSolver(self):
-        builder_and_solver = KratosMultiphysics.ExplicitBuilder()
-        return builder_and_solver
-
-    def _CreateSolutionStrategy(self):
-        convection_diffusion_solution_strategy = self._create_runge_kutta_4_strategy()
-        return convection_diffusion_solution_strategy
-
-    def _create_runge_kutta_4_strategy(self):
-        computing_model_part = self.GetComputingModelPart()
-        explicit_builder_and_solver = self._GetBuilderAndSolver()
-        rebuild_level = 0
-        return ConvectionDiffusionApplication.ExplicitSolvingStrategyRungeKutta4ConvectionDiffusion(
-            computing_model_part,
-            explicit_builder_and_solver,
-            self.settings["move_mesh_flag"].GetBool(),
-            rebuild_level,
-        )
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.ConvectionDiffusionApplication as ConvectionDiffusionApplication
+
+# Import base class file
+from KratosMultiphysics.ConvectionDiffusionApplication import convection_diffusion_solver
+
+
+def CreateSolver(model, custom_settings):
+    return ConvectionDiffusionExplicitSolver(model, custom_settings)
+
+
+class ConvectionDiffusionExplicitSolver(convection_diffusion_solver.ConvectionDiffusionSolver):
+    """
+    The explicit class for convection-diffusion solvers.
+    See convection_diffusion_solver.py for more information.
+    """
+
+    def __init__(self, model, custom_settings):
+        # Construct the base solver and validate the remaining settings in the base class
+        super().__init__(model, custom_settings)
+
+        # Overwrite the base solver minimum buffer size
+        self.min_buffer_size = 2
+
+        element_name = self.settings["element_replace_settings"]["element_name"].GetString()
+        if self.settings["use_orthogonal_subscales"].GetBool() is True:
+            oss_element_list = ["QSConvectionDiffusionExplicit", "DConvectionDiffusionExplicit"]
+            if element_name in oss_element_list:
+                self.main_model_part.ProcessInfo.SetValue(
+                    KratosMultiphysics.OSS_SWITCH, 1
+                )
+            else:
+                err_msg = (
+                    "The selected element",
+                    element_name,
+                    "does not support OSS projection. Select QSConvectionDiffusionExplicit or DConvectionDiffusionExplicit instead.",
+                )
+                raise Exception(err_msg)
+        else:
+            if element_name in (
+                "QSConvectionDiffusionExplicit",
+                "DConvectionDiffusionExplicit",
+            ):
+                self.main_model_part.ProcessInfo.SetValue(
+                    KratosMultiphysics.OSS_SWITCH, 0
+                )
+
+        KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "Construction finished")
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        default_settings = KratosMultiphysics.Parameters(
+        """
+        {
+            "time_integration_method" : "explicit",
+            "use_orthogonal_subscales" : false,
+            "dynamic_tau": 1.0
+        }
+        """
+        )
+
+        default_settings.AddMissingParameters(super().GetDefaultParameters())
+        return default_settings
+
+    def Initialize(self):
+        super().Initialize()
+        self.GetComputingModelPart().ProcessInfo[KratosMultiphysics.DYNAMIC_TAU] = self.settings["dynamic_tau"].GetDouble()
+
+    #### Private functions ####
+
+    def _CreateBuilderAndSolver(self):
+        builder_and_solver = KratosMultiphysics.ExplicitBuilder()
+        return builder_and_solver
+
+    def _CreateSolutionStrategy(self):
+        convection_diffusion_solution_strategy = self._create_runge_kutta_4_strategy()
+        return convection_diffusion_solution_strategy
+
+    def _create_runge_kutta_4_strategy(self):
+        computing_model_part = self.GetComputingModelPart()
+        explicit_builder_and_solver = self._GetBuilderAndSolver()
+        rebuild_level = 0
+        return ConvectionDiffusionApplication.ExplicitSolvingStrategyRungeKutta4ConvectionDiffusion(
+            computing_model_part,
+            explicit_builder_and_solver,
+            self.settings["move_mesh_flag"].GetBool(),
+            rebuild_level,
+        )
```

## KratosMultiphysics/ConvectionDiffusionApplication/response_functions/convection_diffusion_response_function_factory.py

 * *Ordering differences only*

```diff
@@ -1,13 +1,13 @@
-
-# importing the Kratos Library
-from KratosMultiphysics.ConvectionDiffusionApplication.response_functions import convection_diffusion_response
-
-def CreateResponseFunction(response_id, response_settings, model):
-    response_type = response_settings["response_type"].GetString()
-
-    if response_type == "point_temperature":
-        return convection_diffusion_response.AdjointResponseFunction(response_id, response_settings, model)
-
-    else:
-        raise NameError("The type of the following response function is not specified: "+ response_id +
-                        ".\nAvailable types are: 'point_temperature'." )
+
+# importing the Kratos Library
+from KratosMultiphysics.ConvectionDiffusionApplication.response_functions import convection_diffusion_response
+
+def CreateResponseFunction(response_id, response_settings, model):
+    response_type = response_settings["response_type"].GetString()
+
+    if response_type == "point_temperature":
+        return convection_diffusion_response.AdjointResponseFunction(response_id, response_settings, model)
+
+    else:
+        raise NameError("The type of the following response function is not specified: "+ response_id +
+                        ".\nAvailable types are: 'point_temperature'." )
```

## KratosMultiphysics/ConvectionDiffusionApplication/response_functions/convection_diffusion_response.py

 * *Ordering differences only*

```diff
@@ -1,145 +1,145 @@
-"""
-This module contains an interface to the available response functions
-"""
-import time as timer
-
-import KratosMultiphysics as KM
-from KratosMultiphysics import Parameters, Logger
-from KratosMultiphysics.response_functions.response_function_interface import ResponseFunctionInterface
-import KratosMultiphysics.ConvectionDiffusionApplication as ConvectionDiffusionApplication
-from KratosMultiphysics.ConvectionDiffusionApplication.convection_diffusion_analysis import ConvectionDiffusionAnalysis
-
-
-class AdjointResponseFunction(ResponseFunctionInterface):
-    """Linear adjoint response function.
-    - runs the primal analysis
-    - primal results are transferred to adjoint model part via python
-    - uses primal results to calculate value
-    - uses primal results to calculate gradient by running the adjoint analysis
-
-    Attributes
-    ----------
-    primal_analysis : Primal analysis object of the response function
-    adjoint_analysis : Adjoint analysis object of the response function
-    """
-    def __init__(self, identifier, response_settings, model):
-        self.identifier = identifier
-        self.response_settings = response_settings
-
-        # Create the primal solver
-        with open(self.response_settings["primal_settings"].GetString(),'r') as parameter_file:
-            primal_parameters = Parameters( parameter_file.read() )
-
-        self.primal_analysis = ConvectionDiffusionAnalysis(model, primal_parameters)
-        self.primal_model_part = model.GetModelPart(primal_parameters["solver_settings"]["model_part_name"].GetString())
-
-        # Create the adjoint solver
-        adjoint_parameters = self._GetAdjointParameters()
-
-        self.adjoint_analysis = ConvectionDiffusionAnalysis(model, adjoint_parameters)
-        self.adjoint_model_part = model.GetModelPart(adjoint_parameters["solver_settings"]["model_part_name"].GetString())
-
-        self.primal_state_variables = [
-            KM.CONDUCTIVITY,
-            KM.TEMPERATURE,
-            KM.HEAT_FLUX,
-            KM.FACE_HEAT_FLUX
-        ]
-
-        self.value = None
-
-    def Initialize(self):
-        self.primal_analysis.Initialize()
-        self.adjoint_analysis.Initialize()
-
-    def InitializeSolutionStep(self):
-        self.value = None
-
-        # Run the primal analysis.
-        Logger.PrintInfo(self._GetLabel(), "Starting primal analysis for response:", self.identifier)
-        startTime = timer.time()
-        if not self.primal_analysis.time < self.primal_analysis.end_time:
-            self.primal_analysis.end_time += 1
-        self.primal_analysis.RunSolutionLoop()
-        Logger.PrintInfo(self._GetLabel(), "Time needed for solving the primal analysis = ",round(timer.time() - startTime,2),"s")
-
-    def CalculateValue(self):
-        startTime = timer.time()
-        self.value = self._GetResponseFunctionUtility().CalculateValue(self.primal_model_part)
-        Logger.PrintInfo(self._GetLabel(), "Time needed for calculating the response value = ",round(timer.time() - startTime,2),"s")
-
-    def CalculateGradient(self):
-        # synchronize the modelparts
-        self._SynchronizeAdjointFromPrimal()
-        startTime = timer.time()
-        Logger.PrintInfo(self._GetLabel(), "Starting adjoint analysis for response:", self.identifier)
-        if not self.adjoint_analysis.time < self.adjoint_analysis.end_time:
-            self.adjoint_analysis.end_time += 1
-        self.adjoint_analysis.RunSolutionLoop()
-        Logger.PrintInfo(self._GetLabel(), "Time needed for solving the adjoint analysis = ",round(timer.time() - startTime,2),"s")
-
-    def GetValue(self):
-        return self.value
-
-    def GetNodalGradient(self, variable):
-        if variable != KM.SHAPE_SENSITIVITY:
-            raise RuntimeError("GetNodalGradient: No gradient for {}!".format(variable.Name))
-        gradient = {}
-        for node in self.adjoint_model_part.Nodes:
-            gradient[node.Id] = node.GetSolutionStepValue(variable)
-        return gradient
-
-    def Finalize(self):
-        self.primal_analysis.Finalize()
-        self.adjoint_analysis.Finalize()
-
-    def _GetResponseFunctionUtility(self):
-        return self.adjoint_analysis._GetSolver().response_function
-
-    def _SynchronizeAdjointFromPrimal(self):
-        Logger.PrintInfo(self._GetLabel(), "Synchronize primal and adjoint modelpart for response:", self.identifier)
-
-        if len(self.primal_model_part.Nodes) != len(self.adjoint_model_part.Nodes):
-            raise RuntimeError("_SynchronizeAdjointFromPrimal: Model parts have a different number of nodes!")
-
-        for primal_node, adjoint_node in zip(self.primal_model_part.Nodes, self.adjoint_model_part.Nodes):
-            adjoint_node.X0 = primal_node.X0
-            adjoint_node.Y0 = primal_node.Y0
-            adjoint_node.Z0 = primal_node.Z0
-            adjoint_node.X = primal_node.X
-            adjoint_node.Y = primal_node.Y
-            adjoint_node.Z = primal_node.Z
-
-        # Put primal solution on adjoint model
-        Logger.PrintInfo(self._GetLabel(), "Transfer primal state to adjoint model part.")
-        variable_utils = KM.VariableUtils()
-        for variable in self.primal_state_variables:
-            variable_utils.CopyModelPartNodalVar(variable, self.primal_model_part, self.adjoint_model_part, 0)
-
-    def _GetAdjointParameters(self):
-
-        with open(self.response_settings["adjoint_settings"].GetString(),'r') as parameter_file:
-            adjoint_parameters = Parameters( parameter_file.read() )
-
-        if self.response_settings["transfer_response_parameters"].GetBool():
-
-            # sensitivity settings
-            if adjoint_parameters["solver_settings"].Has("sensitivity_settings"):
-                Logger.PrintWarning(self._GetLabel(), "Adjoint settings already have 'sensitivity_settings' - Will be overwritten!")
-                adjoint_parameters["solver_settings"].RemoveValue("sensitivity_settings")
-            adjoint_parameters["solver_settings"].AddValue("sensitivity_settings", self.response_settings["sensitivity_settings"])
-
-            # response settings
-            if adjoint_parameters["solver_settings"].Has("response_function_settings"):
-                Logger.PrintWarning(self._GetLabel(), "Adjoint settings already have 'response_function_settings' - Will be overwritten!")
-                adjoint_parameters["solver_settings"].RemoveValue("response_function_settings")
-            adjoint_parameters["solver_settings"].AddValue("response_function_settings", self.response_settings)
-        
-        return adjoint_parameters
-
-    def _GetLabel(self):
-        type_labels = {
-            "point_temperature" : "LocalTemperatureAverageResponseFunction"
-        }
-        response_type = self.response_settings["response_type"].GetString()
-        return "Adjoint" + type_labels[response_type] + "Response"
+"""
+This module contains an interface to the available response functions
+"""
+import time as timer
+
+import KratosMultiphysics as KM
+from KratosMultiphysics import Parameters, Logger
+from KratosMultiphysics.response_functions.response_function_interface import ResponseFunctionInterface
+import KratosMultiphysics.ConvectionDiffusionApplication as ConvectionDiffusionApplication
+from KratosMultiphysics.ConvectionDiffusionApplication.convection_diffusion_analysis import ConvectionDiffusionAnalysis
+
+
+class AdjointResponseFunction(ResponseFunctionInterface):
+    """Linear adjoint response function.
+    - runs the primal analysis
+    - primal results are transferred to adjoint model part via python
+    - uses primal results to calculate value
+    - uses primal results to calculate gradient by running the adjoint analysis
+
+    Attributes
+    ----------
+    primal_analysis : Primal analysis object of the response function
+    adjoint_analysis : Adjoint analysis object of the response function
+    """
+    def __init__(self, identifier, response_settings, model):
+        self.identifier = identifier
+        self.response_settings = response_settings
+
+        # Create the primal solver
+        with open(self.response_settings["primal_settings"].GetString(),'r') as parameter_file:
+            primal_parameters = Parameters( parameter_file.read() )
+
+        self.primal_analysis = ConvectionDiffusionAnalysis(model, primal_parameters)
+        self.primal_model_part = model.GetModelPart(primal_parameters["solver_settings"]["model_part_name"].GetString())
+
+        # Create the adjoint solver
+        adjoint_parameters = self._GetAdjointParameters()
+
+        self.adjoint_analysis = ConvectionDiffusionAnalysis(model, adjoint_parameters)
+        self.adjoint_model_part = model.GetModelPart(adjoint_parameters["solver_settings"]["model_part_name"].GetString())
+
+        self.primal_state_variables = [
+            KM.CONDUCTIVITY,
+            KM.TEMPERATURE,
+            KM.HEAT_FLUX,
+            KM.FACE_HEAT_FLUX
+        ]
+
+        self.value = None
+
+    def Initialize(self):
+        self.primal_analysis.Initialize()
+        self.adjoint_analysis.Initialize()
+
+    def InitializeSolutionStep(self):
+        self.value = None
+
+        # Run the primal analysis.
+        Logger.PrintInfo(self._GetLabel(), "Starting primal analysis for response:", self.identifier)
+        startTime = timer.time()
+        if not self.primal_analysis.time < self.primal_analysis.end_time:
+            self.primal_analysis.end_time += 1
+        self.primal_analysis.RunSolutionLoop()
+        Logger.PrintInfo(self._GetLabel(), "Time needed for solving the primal analysis = ",round(timer.time() - startTime,2),"s")
+
+    def CalculateValue(self):
+        startTime = timer.time()
+        self.value = self._GetResponseFunctionUtility().CalculateValue(self.primal_model_part)
+        Logger.PrintInfo(self._GetLabel(), "Time needed for calculating the response value = ",round(timer.time() - startTime,2),"s")
+
+    def CalculateGradient(self):
+        # synchronize the modelparts
+        self._SynchronizeAdjointFromPrimal()
+        startTime = timer.time()
+        Logger.PrintInfo(self._GetLabel(), "Starting adjoint analysis for response:", self.identifier)
+        if not self.adjoint_analysis.time < self.adjoint_analysis.end_time:
+            self.adjoint_analysis.end_time += 1
+        self.adjoint_analysis.RunSolutionLoop()
+        Logger.PrintInfo(self._GetLabel(), "Time needed for solving the adjoint analysis = ",round(timer.time() - startTime,2),"s")
+
+    def GetValue(self):
+        return self.value
+
+    def GetNodalGradient(self, variable):
+        if variable != KM.SHAPE_SENSITIVITY:
+            raise RuntimeError("GetNodalGradient: No gradient for {}!".format(variable.Name))
+        gradient = {}
+        for node in self.adjoint_model_part.Nodes:
+            gradient[node.Id] = node.GetSolutionStepValue(variable)
+        return gradient
+
+    def Finalize(self):
+        self.primal_analysis.Finalize()
+        self.adjoint_analysis.Finalize()
+
+    def _GetResponseFunctionUtility(self):
+        return self.adjoint_analysis._GetSolver().response_function
+
+    def _SynchronizeAdjointFromPrimal(self):
+        Logger.PrintInfo(self._GetLabel(), "Synchronize primal and adjoint modelpart for response:", self.identifier)
+
+        if len(self.primal_model_part.Nodes) != len(self.adjoint_model_part.Nodes):
+            raise RuntimeError("_SynchronizeAdjointFromPrimal: Model parts have a different number of nodes!")
+
+        for primal_node, adjoint_node in zip(self.primal_model_part.Nodes, self.adjoint_model_part.Nodes):
+            adjoint_node.X0 = primal_node.X0
+            adjoint_node.Y0 = primal_node.Y0
+            adjoint_node.Z0 = primal_node.Z0
+            adjoint_node.X = primal_node.X
+            adjoint_node.Y = primal_node.Y
+            adjoint_node.Z = primal_node.Z
+
+        # Put primal solution on adjoint model
+        Logger.PrintInfo(self._GetLabel(), "Transfer primal state to adjoint model part.")
+        variable_utils = KM.VariableUtils()
+        for variable in self.primal_state_variables:
+            variable_utils.CopyModelPartNodalVar(variable, self.primal_model_part, self.adjoint_model_part, 0)
+
+    def _GetAdjointParameters(self):
+
+        with open(self.response_settings["adjoint_settings"].GetString(),'r') as parameter_file:
+            adjoint_parameters = Parameters( parameter_file.read() )
+
+        if self.response_settings["transfer_response_parameters"].GetBool():
+
+            # sensitivity settings
+            if adjoint_parameters["solver_settings"].Has("sensitivity_settings"):
+                Logger.PrintWarning(self._GetLabel(), "Adjoint settings already have 'sensitivity_settings' - Will be overwritten!")
+                adjoint_parameters["solver_settings"].RemoveValue("sensitivity_settings")
+            adjoint_parameters["solver_settings"].AddValue("sensitivity_settings", self.response_settings["sensitivity_settings"])
+
+            # response settings
+            if adjoint_parameters["solver_settings"].Has("response_function_settings"):
+                Logger.PrintWarning(self._GetLabel(), "Adjoint settings already have 'response_function_settings' - Will be overwritten!")
+                adjoint_parameters["solver_settings"].RemoveValue("response_function_settings")
+            adjoint_parameters["solver_settings"].AddValue("response_function_settings", self.response_settings)
+        
+        return adjoint_parameters
+
+    def _GetLabel(self):
+        type_labels = {
+            "point_temperature" : "LocalTemperatureAverageResponseFunction"
+        }
+        response_type = self.response_settings["response_type"].GetString()
+        return "Adjoint" + type_labels[response_type] + "Response"
```

## KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_matrix_solver.py

 * *Ordering differences only*

```diff
@@ -1,85 +1,85 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import base class file
-from KratosMultiphysics.ConvectionDiffusionApplication import convection_diffusion_stationary_solver
-import KratosMultiphysics.scipy_conversion_tools
-import numpy as np
-
-
-def CreateSolver(main_model_part, custom_settings):
-    return ConvectionDiffusionStationaryMatrixSolver(main_model_part, custom_settings)
-
-
-class ConvectionDiffusionStationaryMatrixSolver(convection_diffusion_stationary_solver.ConvectionDiffusionStationarySolver):
-
-    """Variant of the stationary convection diffusion solver that extracts:
-    - the system matrix as scipy.sparse.csr_matrix
-    - the system vector as np.ndarray
-    """
-
-    def __init__(self, main_model_part, custom_settings):
-
-        # Construct the base solver and validate the remaining settings in the base class
-        super(ConvectionDiffusionStationaryMatrixSolver, self).__init__(main_model_part, custom_settings)
-
-        KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "Construction finished")
-
-
-    def SolveSolutionStep(self):
-        """Assembles the system and stores the system matrix and vector as member variables."""
-        self.K, self.p = self._SystemComputation()
-
-        # example of a solution with the extracted matrix and vector
-        # ----
-        # import scipy.sparse.linalg
-        # x = scipy.sparse.linalg.spsolve(self.K, self.p)
-
-        # self._AssignSystemVector(x)
-        # ----
-
-        KratosMultiphysics.Logger.PrintInfo("::[{}]:: ".format(self.__class__.__name__), "Extracted system matrix and vector.")
-        KratosMultiphysics.Logger.PrintInfo("::[{}]:: ".format(self.__class__.__name__), "No solution triggered!")
-
-        return True
-
-    def _SystemComputation(self):
-        """Assembles the system matrix and vector and returns them as scipy.sparse.csr_matrix and np.ndarray respectively."""
-        space = KratosMultiphysics.UblasSparseSpace()
-        strategy = self._GetSolutionStrategy()
-        scheme = strategy.GetScheme()
-
-        A = strategy.GetSystemMatrix()
-        space.SetToZeroMatrix(A)
-
-        b = strategy.GetSystemVector()
-        space.SetToZeroVector(b)
-
-        # Create dummy vector
-        xD = space.CreateEmptyVectorPointer()
-        space.ResizeVector( xD, space.Size1(A) )
-        space.SetToZeroVector(xD)
-
-        # Build matrix
-        builder_and_solver = self._GetBuilderAndSolver()
-        builder_and_solver.Build(scheme, self.GetComputingModelPart(), A, b)
-        # Apply constraints
-        builder_and_solver.ApplyConstraints(scheme, self.GetComputingModelPart(), A, b)
-        # Apply boundary conditions
-        builder_and_solver.ApplyDirichletConditions(scheme, self.GetComputingModelPart(), A, xD, b)
-        # Convert system matrix to scipy
-        A_csr = KratosMultiphysics.scipy_conversion_tools.to_csr(A)
-        # Convert system vector to np
-        b_np = np.array(b)
-
-        return A_csr, b_np
-
-
-    def _AssignSystemVector(self, vector):
-        """Assigns the values of the vector to the TEMPERATURE dofs."""
-        for node in self.GetComputingModelPart().Nodes:
-            dof = node.GetDof(KratosMultiphysics.TEMPERATURE)
-
-            if not dof.IsFixed():
-                value = vector[dof.EquationId]
-                node.SetSolutionStepValue(KratosMultiphysics.TEMPERATURE, value)
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import base class file
+from KratosMultiphysics.ConvectionDiffusionApplication import convection_diffusion_stationary_solver
+import KratosMultiphysics.scipy_conversion_tools
+import numpy as np
+
+
+def CreateSolver(main_model_part, custom_settings):
+    return ConvectionDiffusionStationaryMatrixSolver(main_model_part, custom_settings)
+
+
+class ConvectionDiffusionStationaryMatrixSolver(convection_diffusion_stationary_solver.ConvectionDiffusionStationarySolver):
+
+    """Variant of the stationary convection diffusion solver that extracts:
+    - the system matrix as scipy.sparse.csr_matrix
+    - the system vector as np.ndarray
+    """
+
+    def __init__(self, main_model_part, custom_settings):
+
+        # Construct the base solver and validate the remaining settings in the base class
+        super(ConvectionDiffusionStationaryMatrixSolver, self).__init__(main_model_part, custom_settings)
+
+        KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "Construction finished")
+
+
+    def SolveSolutionStep(self):
+        """Assembles the system and stores the system matrix and vector as member variables."""
+        self.K, self.p = self._SystemComputation()
+
+        # example of a solution with the extracted matrix and vector
+        # ----
+        # import scipy.sparse.linalg
+        # x = scipy.sparse.linalg.spsolve(self.K, self.p)
+
+        # self._AssignSystemVector(x)
+        # ----
+
+        KratosMultiphysics.Logger.PrintInfo("::[{}]:: ".format(self.__class__.__name__), "Extracted system matrix and vector.")
+        KratosMultiphysics.Logger.PrintInfo("::[{}]:: ".format(self.__class__.__name__), "No solution triggered!")
+
+        return True
+
+    def _SystemComputation(self):
+        """Assembles the system matrix and vector and returns them as scipy.sparse.csr_matrix and np.ndarray respectively."""
+        space = KratosMultiphysics.UblasSparseSpace()
+        strategy = self._GetSolutionStrategy()
+        scheme = strategy.GetScheme()
+
+        A = strategy.GetSystemMatrix()
+        space.SetToZeroMatrix(A)
+
+        b = strategy.GetSystemVector()
+        space.SetToZeroVector(b)
+
+        # Create dummy vector
+        xD = space.CreateEmptyVectorPointer()
+        space.ResizeVector( xD, space.Size1(A) )
+        space.SetToZeroVector(xD)
+
+        # Build matrix
+        builder_and_solver = self._GetBuilderAndSolver()
+        builder_and_solver.Build(scheme, self.GetComputingModelPart(), A, b)
+        # Apply constraints
+        builder_and_solver.ApplyConstraints(scheme, self.GetComputingModelPart(), A, b)
+        # Apply boundary conditions
+        builder_and_solver.ApplyDirichletConditions(scheme, self.GetComputingModelPart(), A, xD, b)
+        # Convert system matrix to scipy
+        A_csr = KratosMultiphysics.scipy_conversion_tools.to_csr(A)
+        # Convert system vector to np
+        b_np = np.array(b)
+
+        return A_csr, b_np
+
+
+    def _AssignSystemVector(self, vector):
+        """Assigns the values of the vector to the TEMPERATURE dofs."""
+        for node in self.GetComputingModelPart().Nodes:
+            dof = node.GetDof(KratosMultiphysics.TEMPERATURE)
+
+            if not dof.IsFixed():
+                value = vector[dof.EquationId]
+                node.SetSolutionStepValue(KratosMultiphysics.TEMPERATURE, value)
```

## KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_embedded_solver.py

 * *Ordering differences only*

```diff
@@ -1,153 +1,153 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.ConvectionDiffusionApplication as ConvectionDiffusionApplication
-
-# Import base class file
-from KratosMultiphysics.ConvectionDiffusionApplication import convection_diffusion_stationary_solver
-
-def CreateSolver(main_model_part, custom_settings):
-    return ConvectionDiffusionStationaryEmbeddedSolver(main_model_part, custom_settings)
-
-class ConvectionDiffusionStationaryEmbeddedSolver(convection_diffusion_stationary_solver.ConvectionDiffusionStationarySolver):
-    """The embedded class for a stationary convection-diffusion solvers.
-
-    Public member variables:
-
-    See convection_diffusion_solver.py for more information.
-    """
-
-    def __init__(self, main_model_part, custom_settings):
-        # Construct the base solver and validate the remaining settings in the base class
-        super().__init__(main_model_part, custom_settings)
-
-        # Overwrite the base solver minimum buffer size
-        self.min_buffer_size = 1
-
-        KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "Construction finished")
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KratosMultiphysics.Parameters(r"""{
-            "mls_extension_operator_order" : 1,
-            "use_mls_constraints" : false,
-            "use_distance_modification" : false
-        }""")
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
-
-    def AddVariables(self):
-        # Add heat transfer required variables
-        super().AddVariables()
-
-        # Add distance variable to represent the embedded skin
-        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.DISTANCE)
-
-    def Initialize(self):
-
-        # Either EmbeddedMLSConstraintProcess, distance modification or no treatment will be used against small cut instabilities
-        # Either way the nodal distances will be modified slightly to avoid level set zeros (tol=1e-12)
-        # and elements in the negative distance region will be deactivated
-        if self.settings["use_mls_constraints"].GetBool():
-            if self.settings["use_distance_modification"].GetBool():
-                KratosMultiphysics.Logger.PrintWarning("ConvectionDiffusionStationaryEmbeddedSolver", "Giving precedence to MLS constraints over distance modification")
-
-            # Avoid zero distances
-            self.__modify_nodal_distances(distance_threshold=1.0e-12)
-
-            # Calculate the required neighbors
-            nodal_neighbors_process = KratosMultiphysics.FindGlobalNodalNeighboursProcess(self.main_model_part)
-            nodal_neighbors_process.Execute()
-
-            # Create the MLS basis and add multi-point constraints for all negative nodes of intersected elements
-            settings = KratosMultiphysics.Parameters("""{}""")
-            settings.AddEmptyValue("model_part_name").SetString(self.main_model_part.Name)
-            settings.AddEmptyValue("unknown_variable").SetString(self.settings["convection_diffusion_variables"]["unknown_variable"].GetString())
-            settings.AddEmptyValue("mls_extension_operator_order").SetInt(self.settings["mls_extension_operator_order"].GetInt())
-            settings.AddEmptyValue("deactivate_negative_elements").SetBool(True)
-            settings.AddEmptyValue("deactivate_intersected_elements").SetBool(False)
-            constraint_process = ConvectionDiffusionApplication.EmbeddedMLSConstraintProcess(self.model, settings)
-            constraint_process.Execute()
-
-        elif self.settings["use_distance_modification"].GetBool():
-            # Avoid small cuts and deactivate elements in negative distance region
-            self.__modify_nodal_distances(distance_threshold=0.001)
-            self.__deactivate_negative_elements()
-
-        else:
-            # Avoid zero distances and deactivate elements in negative distance region
-            self.__modify_nodal_distances(distance_threshold=1.0e-12)
-            self.__deactivate_negative_elements()
-
-        # Initialize base solver strategy
-        super().Initialize()
-
-    def _get_element_condition_replace_settings(self):
-        domain_size = self.main_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE]
-        if domain_size not in (2,3):
-            raise Exception("DOMAIN_SIZE not set")
-
-        # Get element data
-        num_nodes_elements = 0
-        if (len(self.main_model_part.Elements) > 0):
-            for elem in self.main_model_part.Elements:
-                num_nodes_elements = len(elem.GetNodes())
-                break
-        num_nodes_elements = self.main_model_part.GetCommunicator().GetDataCommunicator().MaxAll(num_nodes_elements)
-        element_name = self.settings["element_replace_settings"]["element_name"].GetString()
-
-        # Element checks
-        if num_nodes_elements not in (3,4):
-            raise Exception("Only simplex elements are supported so far.")
-        if element_name != "EmbeddedLaplacianElement":
-            raise Exception("Only \'EmbeddedLaplacianElement\' is supported so far.")
-
-        # Set registering element name
-        name_string = "{0}{1}D{2}N".format(element_name, domain_size, num_nodes_elements)
-        self.settings["element_replace_settings"]["element_name"].SetString(name_string)
-
-        # Conditions
-        num_conditions = self.main_model_part.GetCommunicator().GetDataCommunicator().SumAll(len(self.main_model_part.Conditions))
-
-        if num_conditions > 0:
-            num_nodes_conditions = 0
-            if (len(self.main_model_part.Conditions) > 0):
-                for cond in self.main_model_part.Conditions:
-                    num_nodes_conditions = len(cond.GetNodes())
-                    break
-
-            num_nodes_conditions = self.main_model_part.GetCommunicator().GetDataCommunicator().MaxAll(num_nodes_conditions)
-
-            condition_name = self.settings["element_replace_settings"]["condition_name"].GetString()
-            if condition_name in ("FluxCondition","ThermalFace","Condition"):
-                name_string = "{0}{1}D{2}N".format(condition_name,domain_size, num_nodes_conditions)
-                self.settings["element_replace_settings"]["condition_name"].SetString(name_string)
-        else:
-            self.settings["element_replace_settings"]["condition_name"].SetString("")
-
-        return self.settings["element_replace_settings"]
-
-    def __modify_nodal_distances(self, distance_threshold=1.0e-12, avoid_almost_empty_elements=False):
-        # FUTURE: use DistanceModificationProcess with distance_threshold
-        for node in self.GetComputingModelPart().Nodes:
-            d = node.GetSolutionStepValue(KratosMultiphysics.DISTANCE)
-            if abs(d) < distance_threshold:
-                if d > 0.0:
-                    if avoid_almost_empty_elements:
-                        node.SetSolutionStepValue(KratosMultiphysics.DISTANCE, 0, -distance_threshold)
-                    else:
-                        node.SetSolutionStepValue(KratosMultiphysics.DISTANCE, 0, distance_threshold)
-                else:
-                    node.SetSolutionStepValue(KratosMultiphysics.DISTANCE, 0, -distance_threshold)
-
-    def __deactivate_negative_elements(self):
-        for element in self.GetComputingModelPart().Elements:
-            n_pos = 0
-            for node in element.GetGeometry():
-                if node.GetSolutionStepValue(KratosMultiphysics.DISTANCE) > 0.0:
-                    n_pos += 1
-            if n_pos == 0:
-                element.Set(KratosMultiphysics.ACTIVE, False)
-                for node in element.GetGeometry():
-                    node.Set(KratosMultiphysics.ACTIVE, False)
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.ConvectionDiffusionApplication as ConvectionDiffusionApplication
+
+# Import base class file
+from KratosMultiphysics.ConvectionDiffusionApplication import convection_diffusion_stationary_solver
+
+def CreateSolver(main_model_part, custom_settings):
+    return ConvectionDiffusionStationaryEmbeddedSolver(main_model_part, custom_settings)
+
+class ConvectionDiffusionStationaryEmbeddedSolver(convection_diffusion_stationary_solver.ConvectionDiffusionStationarySolver):
+    """The embedded class for a stationary convection-diffusion solvers.
+
+    Public member variables:
+
+    See convection_diffusion_solver.py for more information.
+    """
+
+    def __init__(self, main_model_part, custom_settings):
+        # Construct the base solver and validate the remaining settings in the base class
+        super().__init__(main_model_part, custom_settings)
+
+        # Overwrite the base solver minimum buffer size
+        self.min_buffer_size = 1
+
+        KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "Construction finished")
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KratosMultiphysics.Parameters(r"""{
+            "mls_extension_operator_order" : 1,
+            "use_mls_constraints" : false,
+            "use_distance_modification" : false
+        }""")
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
+
+    def AddVariables(self):
+        # Add heat transfer required variables
+        super().AddVariables()
+
+        # Add distance variable to represent the embedded skin
+        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.DISTANCE)
+
+    def Initialize(self):
+
+        # Either EmbeddedMLSConstraintProcess, distance modification or no treatment will be used against small cut instabilities
+        # Either way the nodal distances will be modified slightly to avoid level set zeros (tol=1e-12)
+        # and elements in the negative distance region will be deactivated
+        if self.settings["use_mls_constraints"].GetBool():
+            if self.settings["use_distance_modification"].GetBool():
+                KratosMultiphysics.Logger.PrintWarning("ConvectionDiffusionStationaryEmbeddedSolver", "Giving precedence to MLS constraints over distance modification")
+
+            # Avoid zero distances
+            self.__modify_nodal_distances(distance_threshold=1.0e-12)
+
+            # Calculate the required neighbors
+            nodal_neighbors_process = KratosMultiphysics.FindGlobalNodalNeighboursProcess(self.main_model_part)
+            nodal_neighbors_process.Execute()
+
+            # Create the MLS basis and add multi-point constraints for all negative nodes of intersected elements
+            settings = KratosMultiphysics.Parameters("""{}""")
+            settings.AddEmptyValue("model_part_name").SetString(self.main_model_part.Name)
+            settings.AddEmptyValue("unknown_variable").SetString(self.settings["convection_diffusion_variables"]["unknown_variable"].GetString())
+            settings.AddEmptyValue("mls_extension_operator_order").SetInt(self.settings["mls_extension_operator_order"].GetInt())
+            settings.AddEmptyValue("deactivate_negative_elements").SetBool(True)
+            settings.AddEmptyValue("deactivate_intersected_elements").SetBool(False)
+            constraint_process = ConvectionDiffusionApplication.EmbeddedMLSConstraintProcess(self.model, settings)
+            constraint_process.Execute()
+
+        elif self.settings["use_distance_modification"].GetBool():
+            # Avoid small cuts and deactivate elements in negative distance region
+            self.__modify_nodal_distances(distance_threshold=0.001)
+            self.__deactivate_negative_elements()
+
+        else:
+            # Avoid zero distances and deactivate elements in negative distance region
+            self.__modify_nodal_distances(distance_threshold=1.0e-12)
+            self.__deactivate_negative_elements()
+
+        # Initialize base solver strategy
+        super().Initialize()
+
+    def _get_element_condition_replace_settings(self):
+        domain_size = self.main_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE]
+        if domain_size not in (2,3):
+            raise Exception("DOMAIN_SIZE not set")
+
+        # Get element data
+        num_nodes_elements = 0
+        if (len(self.main_model_part.Elements) > 0):
+            for elem in self.main_model_part.Elements:
+                num_nodes_elements = len(elem.GetNodes())
+                break
+        num_nodes_elements = self.main_model_part.GetCommunicator().GetDataCommunicator().MaxAll(num_nodes_elements)
+        element_name = self.settings["element_replace_settings"]["element_name"].GetString()
+
+        # Element checks
+        if num_nodes_elements not in (3,4):
+            raise Exception("Only simplex elements are supported so far.")
+        if element_name != "EmbeddedLaplacianElement":
+            raise Exception("Only \'EmbeddedLaplacianElement\' is supported so far.")
+
+        # Set registering element name
+        name_string = "{0}{1}D{2}N".format(element_name, domain_size, num_nodes_elements)
+        self.settings["element_replace_settings"]["element_name"].SetString(name_string)
+
+        # Conditions
+        num_conditions = self.main_model_part.GetCommunicator().GetDataCommunicator().SumAll(len(self.main_model_part.Conditions))
+
+        if num_conditions > 0:
+            num_nodes_conditions = 0
+            if (len(self.main_model_part.Conditions) > 0):
+                for cond in self.main_model_part.Conditions:
+                    num_nodes_conditions = len(cond.GetNodes())
+                    break
+
+            num_nodes_conditions = self.main_model_part.GetCommunicator().GetDataCommunicator().MaxAll(num_nodes_conditions)
+
+            condition_name = self.settings["element_replace_settings"]["condition_name"].GetString()
+            if condition_name in ("FluxCondition","ThermalFace","Condition"):
+                name_string = "{0}{1}D{2}N".format(condition_name,domain_size, num_nodes_conditions)
+                self.settings["element_replace_settings"]["condition_name"].SetString(name_string)
+        else:
+            self.settings["element_replace_settings"]["condition_name"].SetString("")
+
+        return self.settings["element_replace_settings"]
+
+    def __modify_nodal_distances(self, distance_threshold=1.0e-12, avoid_almost_empty_elements=False):
+        # FUTURE: use DistanceModificationProcess with distance_threshold
+        for node in self.GetComputingModelPart().Nodes:
+            d = node.GetSolutionStepValue(KratosMultiphysics.DISTANCE)
+            if abs(d) < distance_threshold:
+                if d > 0.0:
+                    if avoid_almost_empty_elements:
+                        node.SetSolutionStepValue(KratosMultiphysics.DISTANCE, 0, -distance_threshold)
+                    else:
+                        node.SetSolutionStepValue(KratosMultiphysics.DISTANCE, 0, distance_threshold)
+                else:
+                    node.SetSolutionStepValue(KratosMultiphysics.DISTANCE, 0, -distance_threshold)
+
+    def __deactivate_negative_elements(self):
+        for element in self.GetComputingModelPart().Elements:
+            n_pos = 0
+            for node in element.GetGeometry():
+                if node.GetSolutionStepValue(KratosMultiphysics.DISTANCE) > 0.0:
+                    n_pos += 1
+            if n_pos == 0:
+                element.Set(KratosMultiphysics.ACTIVE, False)
+                for node in element.GetGeometry():
+                    node.Set(KratosMultiphysics.ACTIVE, False)
```

## KratosMultiphysics/ConvectionDiffusionApplication/conjugate_heat_transfer_solver.py

 * *Ordering differences only*

```diff
@@ -1,535 +1,535 @@
-import sys
-
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.FSIApplication as KratosFSI
-import KratosMultiphysics.FluidDynamicsApplication as KratosCFD
-import KratosMultiphysics.ConvectionDiffusionApplication as KratosConvDiff
-from KratosMultiphysics.FSIApplication import convergence_accelerator_factory
-
-# Importing the base class
-from KratosMultiphysics.python_solver import PythonSolver
-
-def CreateSolver(main_model_part, custom_settings):
-    return ConjugateHeatTransferSolver(main_model_part, custom_settings)
-
-class ConjugateHeatTransferSolver(PythonSolver):
-
-    def __init__(self, model, custom_settings):
-        super().__init__(model, custom_settings)
-
-        ## Get domain size
-        self.domain_size = self.settings["domain_size"].GetInt()
-
-        ## Set the fluid dynamics solver
-        from KratosMultiphysics.FluidDynamicsApplication import python_solvers_wrapper_fluid
-        self.fluid_solver = python_solvers_wrapper_fluid.CreateSolverByParameters(self.model, self.settings["fluid_domain_solver_settings"]["fluid_solver_settings"], "OpenMP")
-
-        # Set the fluid and solid heat solvers
-        from KratosMultiphysics.ConvectionDiffusionApplication import python_solvers_wrapper_convection_diffusion
-        self.fluid_thermal_solver = python_solvers_wrapper_convection_diffusion.CreateSolverByParameters(self.model, self.settings["fluid_domain_solver_settings"]["thermal_solver_settings"], "OpenMP")
-        self.solid_thermal_solver = python_solvers_wrapper_convection_diffusion.CreateSolverByParameters(self.model, self.settings["solid_domain_solver_settings"]["thermal_solver_settings"], "OpenMP")
-
-    @classmethod
-    def GetDefaultParameters(cls):
-
-        default_settings = KratosMultiphysics.Parameters("""
-        {
-            "solver_type": "conjugate_heat_transfer",
-            "domain_size": -1,
-            "echo_level": 0,
-            "fluid_domain_solver_settings": {
-                "solver_type": "ThermallyCoupled",
-                "domain_size": -1,
-                "echo_level": 1,
-                "fluid_solver_settings": {
-                    "solver_type": "Monolithic",
-                    "model_import_settings": {
-                        "input_type": "mdpa",
-                        "input_filename": "unknown_name"
-                    }
-                },
-                "thermal_solver_settings":{
-                    "model_part_name": "FluidThermalModelPart",
-                    "solver_type": "Transient",
-                    "analysis_type": "linear",
-                    "model_import_settings": {
-                        "input_type": "use_input_model_part"
-                    },
-                    "material_import_settings": {
-                        "materials_filename": "ThermicMaterialsFluid.json"
-                    }
-                }
-            },
-            "solid_domain_solver_settings":{
-                "solid_solver_settings": {
-                },
-                "thermal_solver_settings": {
-                    "model_part_name": "SolidThermalModelPart",
-                    "solver_type": "Transient",
-                    "analysis_type": "linear",
-                    "model_import_settings": {
-                        "input_type": "mdpa",
-                        "input_filename": "unknown_name"
-                    },
-                    "material_import_settings": {
-                        "materials_filename": "ThermicMaterialsSolid.json"
-                    }
-                }
-            },
-            "coupling_settings":{
-                "max_iteration": 10,
-                "temperature_relative_tolerance": 1e-5,
-                "dirichlet_coupling_interface": "fluid",
-                "variable_redistribution_settings": {
-                    "absolute_tolerance": 1.0e-9,
-                    "max_iterations": 200
-                },
-                "mappers_settings": {
-                    "echo_level": 0,
-                    "distance_threshold": 1.0e+24,
-                    "absolute_convergence_tolerance": 1.0e-9,
-                    "relative_convergence_tolerance": 1.0e-7,
-                    "max_number_iterations": 10,
-                    "integration_order": 2,
-                    "search_parameters": {
-                        "allocation_size": 1000,
-                        "bucket_size": 4,
-                        "search_factor": 1.0
-                    }
-                },
-                "convergence_accelerator_settings": {
-                    "solver_type": "Relaxation",
-                    "acceleration_type": "Aitken",
-                    "w_0": 0.5
-                },
-                "fluid_interfaces_list": [],
-                "solid_interfaces_list": []
-            }
-        }
-        """)
-
-        default_settings.AddMissingParameters(super().GetDefaultParameters())
-        return default_settings
-
-    def ValidateSettings(self):
-        default_settings = self.GetDefaultParameters()
-
-        ## Base class settings validation
-        super().ValidateSettings()
-
-        ## Validate fluid and solid domains settings
-        self.settings["fluid_domain_solver_settings"].ValidateAndAssignDefaults(default_settings["fluid_domain_solver_settings"])
-        self.settings["solid_domain_solver_settings"].ValidateAndAssignDefaults(default_settings["solid_domain_solver_settings"])
-
-        ## Validate coupling settings
-        self.settings["coupling_settings"].ValidateAndAssignDefaults(default_settings["coupling_settings"])
-
-    def AddVariables(self):
-        self.fluid_solver.AddVariables()
-        self.fluid_thermal_solver.AddVariables()
-
-        self.fluid_solver.main_model_part.AddNodalSolutionStepVariable(KratosConvDiff.AUX_FLUX)
-        self.fluid_solver.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.NORMAL)
-        self.fluid_solver.main_model_part.AddNodalSolutionStepVariable(KratosConvDiff.AUX_TEMPERATURE)
-        self.fluid_thermal_solver.main_model_part.AddNodalSolutionStepVariable(KratosConvDiff.AUX_FLUX)
-        self.fluid_thermal_solver.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.NORMAL)
-        self.fluid_thermal_solver.main_model_part.AddNodalSolutionStepVariable(KratosConvDiff.AUX_TEMPERATURE)
-        self.fluid_thermal_solver.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.SCALAR_INTERFACE_RESIDUAL)
-
-        # Temporary container for un-relaxed temperature
-        KratosMultiphysics.MergeVariableListsUtility().Merge(
-            self.fluid_solver.main_model_part,
-            self.fluid_thermal_solver.main_model_part)
-
-        self.solid_thermal_solver.AddVariables()
-        self.solid_thermal_solver.main_model_part.AddNodalSolutionStepVariable(KratosConvDiff.AUX_FLUX)
-        self.solid_thermal_solver.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.NORMAL)
-        self.solid_thermal_solver.main_model_part.AddNodalSolutionStepVariable(KratosConvDiff.AUX_TEMPERATURE)
-        self.solid_thermal_solver.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.SCALAR_INTERFACE_RESIDUAL)
-
-    def ImportModelPart(self):
-        # Check that both thermal solvers have a different model part name. If
-        # both model part names coincide the solver will fail to acces them. This
-        # is the case if the default one in the convection diffusion is taken.
-        fluid_thermal_model_part_name = self.settings["fluid_domain_solver_settings"]["thermal_solver_settings"]["model_part_name"].GetString()
-        solid_thermal_model_part_name = self.settings["solid_domain_solver_settings"]["thermal_solver_settings"]["model_part_name"].GetString()
-        if fluid_thermal_model_part_name == solid_thermal_model_part_name:
-            err_msg = "\nFluid thermal solver settings model_part_name and solid thermal solver settings model_part_name can not coincide.\n"
-            err_msg += "- fluid model_part_name: " + fluid_thermal_model_part_name + "\n"
-            err_msg += "- solid model_part_name: " + solid_thermal_model_part_name + "\n"
-            err_msg += "Provide different model_part_names in the JSON settings file."
-            raise Exception(err_msg)
-
-        # Import the fluid domain in the fluid dynamics solver
-        self.fluid_solver.ImportModelPart()
-
-        # In order to consider the buoyancy effects, the nodes in the fluid model part must
-        # be shared with the nodes in the fluid thermal model part. To do that, we use the modeler
-        # Save the convection diffusion settings
-        convection_diffusion_settings = self.fluid_thermal_solver.main_model_part.ProcessInfo.GetValue(KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS)
-
-        # Here the fluid model part is cloned to be thermal model part so that the nodes are shared
-        modeler = KratosMultiphysics.ConnectivityPreserveModeler()
-        if(self.domain_size == 2):
-            modeler.GenerateModelPart(self.fluid_solver.main_model_part,
-                                      self.fluid_thermal_solver.main_model_part,
-                                      "Element2D3N",
-                                      "LineCondition2D2N")
-        else:
-            modeler.GenerateModelPart(self.fluid_solver.main_model_part,
-                                      self.fluid_thermal_solver.main_model_part,
-                                      "Element3D4N",
-                                      "SurfaceCondition3D3N")
-
-        # Set the saved convection diffusion settings to the new thermal model part
-        self.fluid_thermal_solver.main_model_part.ProcessInfo.SetValue(KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS, convection_diffusion_settings)
-
-        # Confirm that the buffer size in the shared nodes is the maximum required one
-        fluid_solver_buffer = self.fluid_solver.GetMinimumBufferSize()
-        fluid_thermal_solver_buffer = self.fluid_thermal_solver.GetMinimumBufferSize()
-        if (fluid_solver_buffer != fluid_thermal_solver_buffer):
-            max_buffer_size = max(fluid_solver_buffer, fluid_thermal_solver_buffer)
-            self.fluid_solver.min_buffer_size = max_buffer_size
-            self.fluid_thermal_solver.min_buffer_size = max_buffer_size
-            if self.settings["echo_level"].GetInt() >= 1:
-                warning_msg = "Fluid solver and fluid thermal solver have different buffer size:\n"
-                warning_msg += " - Fluid solver buffer size: " + str(fluid_solver_buffer) + "\n"
-                warning_msg += " - Fluid thermal solver buffer size: " + str(fluid_thermal_solver_buffer) + "\n"
-                warning_msg += "Setting buffer size equal to " + str(max_buffer_size) + " in both solvers."
-                KratosMultiphysics.Logger.PrintWarning("::[ConjugateHeatTransferSolver]::", warning_msg)
-
-        # Import the solid domain
-        self.solid_thermal_solver.ImportModelPart()
-
-    def AddDofs(self):
-        (self.fluid_solver).AddDofs()
-        (self.fluid_thermal_solver).AddDofs()
-        (self.solid_thermal_solver).AddDofs()
-
-    def GetComputingModelPart(self):
-        return self.fluid_solver.GetComputingModelPart()
-
-    def ComputeDeltaTime(self):
-        return self.fluid_solver._ComputeDeltaTime()
-
-    def GetMinimumBufferSize(self):
-        buffer_size_fluid = self.fluid_solver.GetMinimumBufferSize()
-        buffer_size_thermal_fluid = self.fluid_thermal_solver.GetMinimumBufferSize()
-        buffer_size_thermal_solid = self.solid_thermal_solver.GetMinimumBufferSize()
-
-        return max(buffer_size_fluid, buffer_size_thermal_fluid, buffer_size_thermal_solid)
-
-    def Initialize(self):
-        # Check that the reactions are computed in the Dirichlet side
-        if self.settings["coupling_settings"]["dirichlet_coupling_interface"].GetString() == "fluid":
-            if not (self.fluid_thermal_solver).settings["compute_reactions"].GetBool():
-                (self.fluid_thermal_solver).settings["compute_reactions"].SetBool(True)
-        else:
-            if not (self.solid_thermal_solver).settings["compute_reactions"].GetBool():
-                (self.solid_thermal_solver).settings["compute_reactions"].SetBool(True)
-
-        # Initialize the fluid and solid solvers
-        (self.fluid_solver).Initialize()
-        (self.fluid_thermal_solver).Initialize()
-        (self.solid_thermal_solver).Initialize()
-
-        # Create the fluid and solid interface mapper
-        self._set_up_mappers()
-
-        # Coupling utility initialization
-        # The _get_convergence_accelerator is supposed to construct the convergence accelerator in here
-        self._get_convergence_accelerator().Initialize()
-
-    def Clear(self):
-        (self.fluid_solver).Clear()
-        (self.fluid_thermal_solver).Clear()
-        (self.solid_thermal_solver).Clear()
-
-    def Check(self):
-        (self.fluid_solver).Check()
-        (self.fluid_thermal_solver).Check()
-        (self.solid_thermal_solver).Check()
-
-    def SetEchoLevel(self, level):
-        (self.fluid_solver).SetEchoLevel(level)
-        (self.fluid_thermal_solver).SetEchoLevel(level)
-        (self.solid_thermal_solver).SetEchoLevel(level)
-
-    def AdvanceInTime(self, current_time):
-        #The cloning is done ONLY ONCE since the nodes are shared between the fluid and thermal solvers
-        new_time = self.fluid_solver.AdvanceInTime(current_time)
-
-        # Do the time advance in the solid thermal solver
-        self.solid_thermal_solver.main_model_part.CloneTimeStep(new_time)
-        self.solid_thermal_solver.main_model_part.ProcessInfo[KratosMultiphysics.STEP] += 1
-
-        return new_time
-
-    def PrepareModelPart(self):
-        self.fluid_solver.PrepareModelPart()
-        # TODO: CHECK THIS (if we switch the order in thermal solvers the solver breaks)
-        self.solid_thermal_solver.PrepareModelPart()
-        self.fluid_thermal_solver.PrepareModelPart()
-
-        self._set_up_dirichlet_coupling_boundary()
-
-    def InitializeSolutionStep(self):
-        if self._time_buffer_is_initialized():
-            self.fluid_solver.InitializeSolutionStep()
-            self.fluid_thermal_solver.InitializeSolutionStep()
-            self.solid_thermal_solver.InitializeSolutionStep()
-            self._get_convergence_accelerator().InitializeSolutionStep()
-
-    def Predict(self):
-        if self._time_buffer_is_initialized():
-            self.fluid_solver.Predict()
-            self.fluid_thermal_solver.Predict()
-            self.solid_thermal_solver.Predict()
-
-    def SolveSolutionStep(self):
-        if self._time_buffer_is_initialized():
-            max_iteration = self.settings["coupling_settings"]["max_iteration"].GetInt()
-            temp_rel_tol = self.settings["coupling_settings"]["temperature_relative_tolerance"].GetDouble()
-            redistribution_tolerance = self.settings["coupling_settings"]["variable_redistribution_settings"]["absolute_tolerance"].GetDouble()
-            redistribution_max_iterations = self.settings["coupling_settings"]["variable_redistribution_settings"]["max_iterations"].GetInt()
-
-            # Solve the buoyancy solver
-            self.fluid_solver.SolveSolutionStep()
-
-            # Interface temperature prediction
-            self._temperature_coupling_prediction()
-
-            # Initialize iteration value vector
-            self._initialize_iteration_value_vector()
-
-            # Couple the solid and fluid thermal problems
-            iteration = 0
-            KratosMultiphysics.Logger.PrintInfo("::[ConjugateHeatTransferSolver]::", "Starting non-linear temperature coupling")
-            while iteration < max_iteration:
-                # Initialize non-linear iteration
-                iteration += 1
-                self.solid_thermal_solver.main_model_part.ProcessInfo[KratosMultiphysics.CONVERGENCE_ACCELERATOR_ITERATION] = iteration
-                self.fluid_thermal_solver.main_model_part.ProcessInfo[KratosMultiphysics.CONVERGENCE_ACCELERATOR_ITERATION] = iteration
-                self._get_convergence_accelerator().InitializeNonLinearIteration()
-
-                # Solve Dirichlet side to get reactions from fluid domain
-                # self.fluid_thermal_solver.SolveSolutionStep()
-                self._get_dirichlet_interface_thermal_solver().SolveSolutionStep()
-
-                # Map reactions to the solid interface. Note that we first call the redistribution utility to convert the point values to distributed ones
-                KratosMultiphysics.VariableRedistributionUtility.DistributePointValues(
-                    self._get_dirichlet_coupling_interface(),
-                    KratosMultiphysics.REACTION_FLUX,
-                    KratosConvDiff.AUX_FLUX,
-                    redistribution_tolerance,
-                    redistribution_max_iterations)
-
-                self.flux_mapper.Execute()
-
-                # Solve Neumann side to get temperature values from fluid solid
-                # self.solid_thermal_solver.Solve()
-                self._get_neumann_interface_thermal_solver().Solve()
-
-                # Map back the Neumann domain obtained temperature
-                self.temp_mapper.Execute()
-
-                # Compute the interface residual
-                temp_residual = KratosMultiphysics.Vector(self._get_partitioned_FSI_utilities().GetInterfaceResidualSize(self._get_dirichlet_coupling_interface()))
-                self._get_partitioned_FSI_utilities().ComputeInterfaceResidualVector(
-                    self._get_dirichlet_coupling_interface(),
-                    KratosMultiphysics.TEMPERATURE,
-                    KratosConvDiff.AUX_TEMPERATURE,
-                    KratosMultiphysics.SCALAR_INTERFACE_RESIDUAL,
-                    temp_residual,
-                    "nodal",
-                    KratosMultiphysics.FSI_INTERFACE_RESIDUAL_NORM) #TODO: Rename this variable
-
-                # Residual computation
-                rel_res_norm = self._get_dirichlet_coupling_interface().ProcessInfo[KratosMultiphysics.FSI_INTERFACE_RESIDUAL_NORM] / len(self._get_dirichlet_coupling_interface().Nodes)
-                KratosMultiphysics.Logger.PrintInfo("::[ConjugateHeatTransferSolver]::", "Iteration: " + str(iteration) + " Relative residual: " + str(rel_res_norm))
-
-                # Perform the convergence accelerator solution update
-                self._get_convergence_accelerator().UpdateSolution(temp_residual, self.iteration_value)
-
-                # Update the interface with the corrected values
-                self._get_partitioned_FSI_utilities().UpdateInterfaceValues(
-                    self._get_dirichlet_coupling_interface(),
-                    KratosMultiphysics.TEMPERATURE,
-                    self.iteration_value)
-
-                # Finalize the congergence accelerator iteration
-                self._get_convergence_accelerator().FinalizeNonLinearIteration()
-
-                # Check convergence
-                if rel_res_norm <= temp_rel_tol:
-                    KratosMultiphysics.Logger.PrintInfo("::[ConjugateHeatTransferSolver]::", "Converged in " + str(iteration) + " iterations.")
-                    break
-                elif iteration == max_iteration:
-                    KratosMultiphysics.Logger.PrintInfo("::[ConjugateHeatTransferSolver]::", "Did not converge in " + str(iteration) + " iterations.")
-
-    def FinalizeSolutionStep(self):
-        if self._time_buffer_is_initialized():
-            self.fluid_solver.FinalizeSolutionStep()
-            self.fluid_thermal_solver.FinalizeSolutionStep()
-            self.solid_thermal_solver.FinalizeSolutionStep()
-            self._get_convergence_accelerator().FinalizeSolutionStep()
-
-    def _set_up_dirichlet_coupling_boundary(self):
-        # Run the solid interfaces list to fix the temperature DOFs.
-        for node in self._get_dirichlet_coupling_interface().Nodes:
-            node.Fix(KratosMultiphysics.TEMPERATURE)
-
-    def _set_up_mappers(self):
-        # Set mappers settings
-        mappers_settings = self.settings["coupling_settings"]["mappers_settings"]
-
-        flux_mapper_parameters = KratosMultiphysics.Parameters(r'''{
-            "mapping_coefficient": -1.0,
-            "origin_variable": "AUX_FLUX",
-            "destination_variable": "FACE_HEAT_FLUX"
-        }''')
-        flux_mapper_parameters.AddValue("echo_level", mappers_settings["echo_level"])
-        flux_mapper_parameters.AddValue("integration_order", mappers_settings["integration_order"])
-        flux_mapper_parameters.AddValue("distance_threshold", mappers_settings["distance_threshold"])
-        flux_mapper_parameters.AddValue("max_number_iterations", mappers_settings["max_number_iterations"])
-        flux_mapper_parameters.AddValue("absolute_convergence_tolerance", mappers_settings["absolute_convergence_tolerance"])
-        flux_mapper_parameters.AddValue("relative_convergence_tolerance", mappers_settings["relative_convergence_tolerance"])
-        flux_mapper_parameters.AddValue("search_parameters", mappers_settings["search_parameters"])
-
-        temp_mapper_parameters = KratosMultiphysics.Parameters(r'''{
-            "origin_variable": "TEMPERATURE",
-            "destination_variable": "AUX_TEMPERATURE"
-        }''')
-        temp_mapper_parameters.AddValue("echo_level", mappers_settings["echo_level"])
-        temp_mapper_parameters.AddValue("integration_order", mappers_settings["integration_order"])
-        temp_mapper_parameters.AddValue("distance_threshold", mappers_settings["distance_threshold"])
-        temp_mapper_parameters.AddValue("max_number_iterations", mappers_settings["max_number_iterations"])
-        temp_mapper_parameters.AddValue("absolute_convergence_tolerance", mappers_settings["absolute_convergence_tolerance"])
-        temp_mapper_parameters.AddValue("relative_convergence_tolerance", mappers_settings["relative_convergence_tolerance"])
-        temp_mapper_parameters.AddValue("search_parameters", mappers_settings["search_parameters"])
-
-        # Create flux mapper
-        self.flux_mapper = KratosMultiphysics.SimpleMortarMapperProcess(
-            self._get_dirichlet_coupling_interface(),
-            self._get_neumann_coupling_interface(),
-            flux_mapper_parameters)
-
-        # Create temperature mapper
-        self.temp_mapper = KratosMultiphysics.SimpleMortarMapperProcess(
-            self._get_neumann_coupling_interface(),
-            self._get_dirichlet_coupling_interface(),
-            temp_mapper_parameters)
-
-    # This method returns the fluid thermal interface
-    def _get_fluid_thermal_interface(self):
-        if self.settings["coupling_settings"]["fluid_interfaces_list"].size() > 1:
-            raise Exception("More than one fluid interfaces is not supported yet.")
-
-        fluid_int_name = self.settings["coupling_settings"]["fluid_interfaces_list"][0].GetString()
-        return self.model.GetModelPart(fluid_int_name)
-
-    # This method returns the solid thermal interface
-    def _get_solid_thermal_interface(self):
-        if self.settings["coupling_settings"]["solid_interfaces_list"].size() > 1:
-            raise Exception("More than one solid interfaces is not supported yet.")
-
-        solid_int_name = self.settings["coupling_settings"]["solid_interfaces_list"][0].GetString()
-        return self.model.GetModelPart(solid_int_name)
-
-    # This method returns the Dirichlet coupling interface model part
-    def _get_dirichlet_coupling_interface(self):
-        if self.settings["coupling_settings"]["dirichlet_coupling_interface"].GetString() == "fluid":
-            return self._get_fluid_thermal_interface()
-        else:
-            return self._get_solid_thermal_interface()
-
-    # This method returns the Neumann coupling interface model part
-    def _get_neumann_coupling_interface(self):
-        if self.settings["coupling_settings"]["dirichlet_coupling_interface"].GetString() == "fluid":
-            return self._get_solid_thermal_interface()
-        else:
-            return self._get_fluid_thermal_interface()
-
-    # This method returns the domain thermal solver corresponding to the Dirichlet coupling interface
-    def _get_dirichlet_interface_thermal_solver(self):
-        if self.settings["coupling_settings"]["dirichlet_coupling_interface"].GetString() == "fluid":
-            return self.fluid_thermal_solver
-        else:
-            return self.solid_thermal_solver
-
-    # This method returns the domain thermal solver corresponding to the Neumann coupling interface
-    def _get_neumann_interface_thermal_solver(self):
-        if self.settings["coupling_settings"]["dirichlet_coupling_interface"].GetString() == "fluid":
-            return self.solid_thermal_solver
-        else:
-            return self.fluid_thermal_solver
-
-    # This method returns the convergence accelerator.
-    # If it is not created yet, it calls the _create_convergence_accelerator first
-    def _get_convergence_accelerator(self):
-        if not hasattr(self, '_convergence_accelerator'):
-            self._convergence_accelerator = self._create_convergence_accelerator()
-        return self._convergence_accelerator
-
-    # This method constructs the convergence accelerator coupling utility
-    def _create_convergence_accelerator(self):
-        conv_acc_parameters = self.settings["coupling_settings"]["convergence_accelerator_settings"]
-        convergence_accelerator = convergence_accelerator_factory.CreateConvergenceAccelerator(conv_acc_parameters)
-        KratosMultiphysics.Logger.PrintInfo("::[ConjugateHeatTransferSolver]::", "Convergence accelerator construction finished.")
-        return convergence_accelerator
-
-    # This method returns the partitioned FSI utilities class
-    def _get_partitioned_FSI_utilities(self):
-        if (self.domain_size == 2):
-            return KratosFSI.PartitionedFSIUtilitiesDouble2D()
-        else:
-            return KratosFSI.PartitionedFSIUtilitiesDouble3D()
-
-    def _initialize_iteration_value_vector(self):
-        # Initialize the iteration value for the residual computation
-        self.iteration_value = KratosMultiphysics.Vector(
-            self._get_partitioned_FSI_utilities().GetInterfaceResidualSize(self._get_dirichlet_coupling_interface()))
-        i = 0
-        for node in self._get_dirichlet_coupling_interface().Nodes:
-            self.iteration_value[i] = node.GetSolutionStepValue(KratosMultiphysics.TEMPERATURE)
-            i += 1
-
-    def _temperature_coupling_prediction(self):
-        # Create temperature prediction mapper
-        mappers_settings = self.settings["coupling_settings"]["mappers_settings"]
-        temp_pred_mapper_parameters = KratosMultiphysics.Parameters(r'''{
-            "origin_variable": "TEMPERATURE",
-            "destination_variable": "TEMPERATURE"
-        }''')
-        temp_pred_mapper_parameters.AddValue("echo_level", mappers_settings["echo_level"])
-        temp_pred_mapper_parameters.AddValue("integration_order", mappers_settings["integration_order"])
-        temp_pred_mapper_parameters.AddValue("distance_threshold", mappers_settings["distance_threshold"])
-        temp_pred_mapper_parameters.AddValue("max_number_iterations", mappers_settings["max_number_iterations"])
-        temp_pred_mapper_parameters.AddValue("absolute_convergence_tolerance", mappers_settings["absolute_convergence_tolerance"])
-        temp_pred_mapper_parameters.AddValue("relative_convergence_tolerance", mappers_settings["relative_convergence_tolerance"])
-        temp_pred_mapper_parameters.AddValue("search_parameters", mappers_settings["search_parameters"])
-
-        # Map TEMPERATURE from the Neumann side to the Dirichlet side
-        KratosMultiphysics.SimpleMortarMapperProcess(
-            self._get_neumann_coupling_interface(),
-            self._get_dirichlet_coupling_interface(),
-            temp_pred_mapper_parameters).Execute()
-
-    def _time_buffer_is_initialized(self):
-        # Get current step counter. Note that the buoyancy and thermal fluid domain main_model_part
-        # share the same ProcessInfo(), so the STEP counter is always the same.
-        fluid_step = self.fluid_solver.main_model_part.ProcessInfo[KratosMultiphysics.STEP]
-        solid_step = self.solid_thermal_solver.main_model_part.ProcessInfo[KratosMultiphysics.STEP]
-
-        if (fluid_step != solid_step):
-            err_msg = "Fluid domain and solid domain time steps do not coincide\n"
-            err_msg += "-Fluid domain time step: " + str(fluid_step) + "\n"
-            err_msg += "-Solid domain time step: " + str(solid_step) + "\n"
-            err_msg += "Check AdvanceInTime() method."
-            raise Exception(err_msg)
-
-        # We always have one extra old step (step 0, read from input)
-        return fluid_step + 1 >= self.GetMinimumBufferSize()
+import sys
+
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.FSIApplication as KratosFSI
+import KratosMultiphysics.FluidDynamicsApplication as KratosCFD
+import KratosMultiphysics.ConvectionDiffusionApplication as KratosConvDiff
+from KratosMultiphysics.FSIApplication import convergence_accelerator_factory
+
+# Importing the base class
+from KratosMultiphysics.python_solver import PythonSolver
+
+def CreateSolver(main_model_part, custom_settings):
+    return ConjugateHeatTransferSolver(main_model_part, custom_settings)
+
+class ConjugateHeatTransferSolver(PythonSolver):
+
+    def __init__(self, model, custom_settings):
+        super().__init__(model, custom_settings)
+
+        ## Get domain size
+        self.domain_size = self.settings["domain_size"].GetInt()
+
+        ## Set the fluid dynamics solver
+        from KratosMultiphysics.FluidDynamicsApplication import python_solvers_wrapper_fluid
+        self.fluid_solver = python_solvers_wrapper_fluid.CreateSolverByParameters(self.model, self.settings["fluid_domain_solver_settings"]["fluid_solver_settings"], "OpenMP")
+
+        # Set the fluid and solid heat solvers
+        from KratosMultiphysics.ConvectionDiffusionApplication import python_solvers_wrapper_convection_diffusion
+        self.fluid_thermal_solver = python_solvers_wrapper_convection_diffusion.CreateSolverByParameters(self.model, self.settings["fluid_domain_solver_settings"]["thermal_solver_settings"], "OpenMP")
+        self.solid_thermal_solver = python_solvers_wrapper_convection_diffusion.CreateSolverByParameters(self.model, self.settings["solid_domain_solver_settings"]["thermal_solver_settings"], "OpenMP")
+
+    @classmethod
+    def GetDefaultParameters(cls):
+
+        default_settings = KratosMultiphysics.Parameters("""
+        {
+            "solver_type": "conjugate_heat_transfer",
+            "domain_size": -1,
+            "echo_level": 0,
+            "fluid_domain_solver_settings": {
+                "solver_type": "ThermallyCoupled",
+                "domain_size": -1,
+                "echo_level": 1,
+                "fluid_solver_settings": {
+                    "solver_type": "Monolithic",
+                    "model_import_settings": {
+                        "input_type": "mdpa",
+                        "input_filename": "unknown_name"
+                    }
+                },
+                "thermal_solver_settings":{
+                    "model_part_name": "FluidThermalModelPart",
+                    "solver_type": "Transient",
+                    "analysis_type": "linear",
+                    "model_import_settings": {
+                        "input_type": "use_input_model_part"
+                    },
+                    "material_import_settings": {
+                        "materials_filename": "ThermicMaterialsFluid.json"
+                    }
+                }
+            },
+            "solid_domain_solver_settings":{
+                "solid_solver_settings": {
+                },
+                "thermal_solver_settings": {
+                    "model_part_name": "SolidThermalModelPart",
+                    "solver_type": "Transient",
+                    "analysis_type": "linear",
+                    "model_import_settings": {
+                        "input_type": "mdpa",
+                        "input_filename": "unknown_name"
+                    },
+                    "material_import_settings": {
+                        "materials_filename": "ThermicMaterialsSolid.json"
+                    }
+                }
+            },
+            "coupling_settings":{
+                "max_iteration": 10,
+                "temperature_relative_tolerance": 1e-5,
+                "dirichlet_coupling_interface": "fluid",
+                "variable_redistribution_settings": {
+                    "absolute_tolerance": 1.0e-9,
+                    "max_iterations": 200
+                },
+                "mappers_settings": {
+                    "echo_level": 0,
+                    "distance_threshold": 1.0e+24,
+                    "absolute_convergence_tolerance": 1.0e-9,
+                    "relative_convergence_tolerance": 1.0e-7,
+                    "max_number_iterations": 10,
+                    "integration_order": 2,
+                    "search_parameters": {
+                        "allocation_size": 1000,
+                        "bucket_size": 4,
+                        "search_factor": 1.0
+                    }
+                },
+                "convergence_accelerator_settings": {
+                    "solver_type": "Relaxation",
+                    "acceleration_type": "Aitken",
+                    "w_0": 0.5
+                },
+                "fluid_interfaces_list": [],
+                "solid_interfaces_list": []
+            }
+        }
+        """)
+
+        default_settings.AddMissingParameters(super().GetDefaultParameters())
+        return default_settings
+
+    def ValidateSettings(self):
+        default_settings = self.GetDefaultParameters()
+
+        ## Base class settings validation
+        super().ValidateSettings()
+
+        ## Validate fluid and solid domains settings
+        self.settings["fluid_domain_solver_settings"].ValidateAndAssignDefaults(default_settings["fluid_domain_solver_settings"])
+        self.settings["solid_domain_solver_settings"].ValidateAndAssignDefaults(default_settings["solid_domain_solver_settings"])
+
+        ## Validate coupling settings
+        self.settings["coupling_settings"].ValidateAndAssignDefaults(default_settings["coupling_settings"])
+
+    def AddVariables(self):
+        self.fluid_solver.AddVariables()
+        self.fluid_thermal_solver.AddVariables()
+
+        self.fluid_solver.main_model_part.AddNodalSolutionStepVariable(KratosConvDiff.AUX_FLUX)
+        self.fluid_solver.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.NORMAL)
+        self.fluid_solver.main_model_part.AddNodalSolutionStepVariable(KratosConvDiff.AUX_TEMPERATURE)
+        self.fluid_thermal_solver.main_model_part.AddNodalSolutionStepVariable(KratosConvDiff.AUX_FLUX)
+        self.fluid_thermal_solver.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.NORMAL)
+        self.fluid_thermal_solver.main_model_part.AddNodalSolutionStepVariable(KratosConvDiff.AUX_TEMPERATURE)
+        self.fluid_thermal_solver.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.SCALAR_INTERFACE_RESIDUAL)
+
+        # Temporary container for un-relaxed temperature
+        KratosMultiphysics.MergeVariableListsUtility().Merge(
+            self.fluid_solver.main_model_part,
+            self.fluid_thermal_solver.main_model_part)
+
+        self.solid_thermal_solver.AddVariables()
+        self.solid_thermal_solver.main_model_part.AddNodalSolutionStepVariable(KratosConvDiff.AUX_FLUX)
+        self.solid_thermal_solver.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.NORMAL)
+        self.solid_thermal_solver.main_model_part.AddNodalSolutionStepVariable(KratosConvDiff.AUX_TEMPERATURE)
+        self.solid_thermal_solver.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.SCALAR_INTERFACE_RESIDUAL)
+
+    def ImportModelPart(self):
+        # Check that both thermal solvers have a different model part name. If
+        # both model part names coincide the solver will fail to acces them. This
+        # is the case if the default one in the convection diffusion is taken.
+        fluid_thermal_model_part_name = self.settings["fluid_domain_solver_settings"]["thermal_solver_settings"]["model_part_name"].GetString()
+        solid_thermal_model_part_name = self.settings["solid_domain_solver_settings"]["thermal_solver_settings"]["model_part_name"].GetString()
+        if fluid_thermal_model_part_name == solid_thermal_model_part_name:
+            err_msg = "\nFluid thermal solver settings model_part_name and solid thermal solver settings model_part_name can not coincide.\n"
+            err_msg += "- fluid model_part_name: " + fluid_thermal_model_part_name + "\n"
+            err_msg += "- solid model_part_name: " + solid_thermal_model_part_name + "\n"
+            err_msg += "Provide different model_part_names in the JSON settings file."
+            raise Exception(err_msg)
+
+        # Import the fluid domain in the fluid dynamics solver
+        self.fluid_solver.ImportModelPart()
+
+        # In order to consider the buoyancy effects, the nodes in the fluid model part must
+        # be shared with the nodes in the fluid thermal model part. To do that, we use the modeler
+        # Save the convection diffusion settings
+        convection_diffusion_settings = self.fluid_thermal_solver.main_model_part.ProcessInfo.GetValue(KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS)
+
+        # Here the fluid model part is cloned to be thermal model part so that the nodes are shared
+        modeler = KratosMultiphysics.ConnectivityPreserveModeler()
+        if(self.domain_size == 2):
+            modeler.GenerateModelPart(self.fluid_solver.main_model_part,
+                                      self.fluid_thermal_solver.main_model_part,
+                                      "Element2D3N",
+                                      "LineCondition2D2N")
+        else:
+            modeler.GenerateModelPart(self.fluid_solver.main_model_part,
+                                      self.fluid_thermal_solver.main_model_part,
+                                      "Element3D4N",
+                                      "SurfaceCondition3D3N")
+
+        # Set the saved convection diffusion settings to the new thermal model part
+        self.fluid_thermal_solver.main_model_part.ProcessInfo.SetValue(KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS, convection_diffusion_settings)
+
+        # Confirm that the buffer size in the shared nodes is the maximum required one
+        fluid_solver_buffer = self.fluid_solver.GetMinimumBufferSize()
+        fluid_thermal_solver_buffer = self.fluid_thermal_solver.GetMinimumBufferSize()
+        if (fluid_solver_buffer != fluid_thermal_solver_buffer):
+            max_buffer_size = max(fluid_solver_buffer, fluid_thermal_solver_buffer)
+            self.fluid_solver.min_buffer_size = max_buffer_size
+            self.fluid_thermal_solver.min_buffer_size = max_buffer_size
+            if self.settings["echo_level"].GetInt() >= 1:
+                warning_msg = "Fluid solver and fluid thermal solver have different buffer size:\n"
+                warning_msg += " - Fluid solver buffer size: " + str(fluid_solver_buffer) + "\n"
+                warning_msg += " - Fluid thermal solver buffer size: " + str(fluid_thermal_solver_buffer) + "\n"
+                warning_msg += "Setting buffer size equal to " + str(max_buffer_size) + " in both solvers."
+                KratosMultiphysics.Logger.PrintWarning("::[ConjugateHeatTransferSolver]::", warning_msg)
+
+        # Import the solid domain
+        self.solid_thermal_solver.ImportModelPart()
+
+    def AddDofs(self):
+        (self.fluid_solver).AddDofs()
+        (self.fluid_thermal_solver).AddDofs()
+        (self.solid_thermal_solver).AddDofs()
+
+    def GetComputingModelPart(self):
+        return self.fluid_solver.GetComputingModelPart()
+
+    def ComputeDeltaTime(self):
+        return self.fluid_solver._ComputeDeltaTime()
+
+    def GetMinimumBufferSize(self):
+        buffer_size_fluid = self.fluid_solver.GetMinimumBufferSize()
+        buffer_size_thermal_fluid = self.fluid_thermal_solver.GetMinimumBufferSize()
+        buffer_size_thermal_solid = self.solid_thermal_solver.GetMinimumBufferSize()
+
+        return max(buffer_size_fluid, buffer_size_thermal_fluid, buffer_size_thermal_solid)
+
+    def Initialize(self):
+        # Check that the reactions are computed in the Dirichlet side
+        if self.settings["coupling_settings"]["dirichlet_coupling_interface"].GetString() == "fluid":
+            if not (self.fluid_thermal_solver).settings["compute_reactions"].GetBool():
+                (self.fluid_thermal_solver).settings["compute_reactions"].SetBool(True)
+        else:
+            if not (self.solid_thermal_solver).settings["compute_reactions"].GetBool():
+                (self.solid_thermal_solver).settings["compute_reactions"].SetBool(True)
+
+        # Initialize the fluid and solid solvers
+        (self.fluid_solver).Initialize()
+        (self.fluid_thermal_solver).Initialize()
+        (self.solid_thermal_solver).Initialize()
+
+        # Create the fluid and solid interface mapper
+        self._set_up_mappers()
+
+        # Coupling utility initialization
+        # The _get_convergence_accelerator is supposed to construct the convergence accelerator in here
+        self._get_convergence_accelerator().Initialize()
+
+    def Clear(self):
+        (self.fluid_solver).Clear()
+        (self.fluid_thermal_solver).Clear()
+        (self.solid_thermal_solver).Clear()
+
+    def Check(self):
+        (self.fluid_solver).Check()
+        (self.fluid_thermal_solver).Check()
+        (self.solid_thermal_solver).Check()
+
+    def SetEchoLevel(self, level):
+        (self.fluid_solver).SetEchoLevel(level)
+        (self.fluid_thermal_solver).SetEchoLevel(level)
+        (self.solid_thermal_solver).SetEchoLevel(level)
+
+    def AdvanceInTime(self, current_time):
+        #The cloning is done ONLY ONCE since the nodes are shared between the fluid and thermal solvers
+        new_time = self.fluid_solver.AdvanceInTime(current_time)
+
+        # Do the time advance in the solid thermal solver
+        self.solid_thermal_solver.main_model_part.CloneTimeStep(new_time)
+        self.solid_thermal_solver.main_model_part.ProcessInfo[KratosMultiphysics.STEP] += 1
+
+        return new_time
+
+    def PrepareModelPart(self):
+        self.fluid_solver.PrepareModelPart()
+        # TODO: CHECK THIS (if we switch the order in thermal solvers the solver breaks)
+        self.solid_thermal_solver.PrepareModelPart()
+        self.fluid_thermal_solver.PrepareModelPart()
+
+        self._set_up_dirichlet_coupling_boundary()
+
+    def InitializeSolutionStep(self):
+        if self._time_buffer_is_initialized():
+            self.fluid_solver.InitializeSolutionStep()
+            self.fluid_thermal_solver.InitializeSolutionStep()
+            self.solid_thermal_solver.InitializeSolutionStep()
+            self._get_convergence_accelerator().InitializeSolutionStep()
+
+    def Predict(self):
+        if self._time_buffer_is_initialized():
+            self.fluid_solver.Predict()
+            self.fluid_thermal_solver.Predict()
+            self.solid_thermal_solver.Predict()
+
+    def SolveSolutionStep(self):
+        if self._time_buffer_is_initialized():
+            max_iteration = self.settings["coupling_settings"]["max_iteration"].GetInt()
+            temp_rel_tol = self.settings["coupling_settings"]["temperature_relative_tolerance"].GetDouble()
+            redistribution_tolerance = self.settings["coupling_settings"]["variable_redistribution_settings"]["absolute_tolerance"].GetDouble()
+            redistribution_max_iterations = self.settings["coupling_settings"]["variable_redistribution_settings"]["max_iterations"].GetInt()
+
+            # Solve the buoyancy solver
+            self.fluid_solver.SolveSolutionStep()
+
+            # Interface temperature prediction
+            self._temperature_coupling_prediction()
+
+            # Initialize iteration value vector
+            self._initialize_iteration_value_vector()
+
+            # Couple the solid and fluid thermal problems
+            iteration = 0
+            KratosMultiphysics.Logger.PrintInfo("::[ConjugateHeatTransferSolver]::", "Starting non-linear temperature coupling")
+            while iteration < max_iteration:
+                # Initialize non-linear iteration
+                iteration += 1
+                self.solid_thermal_solver.main_model_part.ProcessInfo[KratosMultiphysics.CONVERGENCE_ACCELERATOR_ITERATION] = iteration
+                self.fluid_thermal_solver.main_model_part.ProcessInfo[KratosMultiphysics.CONVERGENCE_ACCELERATOR_ITERATION] = iteration
+                self._get_convergence_accelerator().InitializeNonLinearIteration()
+
+                # Solve Dirichlet side to get reactions from fluid domain
+                # self.fluid_thermal_solver.SolveSolutionStep()
+                self._get_dirichlet_interface_thermal_solver().SolveSolutionStep()
+
+                # Map reactions to the solid interface. Note that we first call the redistribution utility to convert the point values to distributed ones
+                KratosMultiphysics.VariableRedistributionUtility.DistributePointValues(
+                    self._get_dirichlet_coupling_interface(),
+                    KratosMultiphysics.REACTION_FLUX,
+                    KratosConvDiff.AUX_FLUX,
+                    redistribution_tolerance,
+                    redistribution_max_iterations)
+
+                self.flux_mapper.Execute()
+
+                # Solve Neumann side to get temperature values from fluid solid
+                # self.solid_thermal_solver.Solve()
+                self._get_neumann_interface_thermal_solver().Solve()
+
+                # Map back the Neumann domain obtained temperature
+                self.temp_mapper.Execute()
+
+                # Compute the interface residual
+                temp_residual = KratosMultiphysics.Vector(self._get_partitioned_FSI_utilities().GetInterfaceResidualSize(self._get_dirichlet_coupling_interface()))
+                self._get_partitioned_FSI_utilities().ComputeInterfaceResidualVector(
+                    self._get_dirichlet_coupling_interface(),
+                    KratosMultiphysics.TEMPERATURE,
+                    KratosConvDiff.AUX_TEMPERATURE,
+                    KratosMultiphysics.SCALAR_INTERFACE_RESIDUAL,
+                    temp_residual,
+                    "nodal",
+                    KratosMultiphysics.FSI_INTERFACE_RESIDUAL_NORM) #TODO: Rename this variable
+
+                # Residual computation
+                rel_res_norm = self._get_dirichlet_coupling_interface().ProcessInfo[KratosMultiphysics.FSI_INTERFACE_RESIDUAL_NORM] / len(self._get_dirichlet_coupling_interface().Nodes)
+                KratosMultiphysics.Logger.PrintInfo("::[ConjugateHeatTransferSolver]::", "Iteration: " + str(iteration) + " Relative residual: " + str(rel_res_norm))
+
+                # Perform the convergence accelerator solution update
+                self._get_convergence_accelerator().UpdateSolution(temp_residual, self.iteration_value)
+
+                # Update the interface with the corrected values
+                self._get_partitioned_FSI_utilities().UpdateInterfaceValues(
+                    self._get_dirichlet_coupling_interface(),
+                    KratosMultiphysics.TEMPERATURE,
+                    self.iteration_value)
+
+                # Finalize the congergence accelerator iteration
+                self._get_convergence_accelerator().FinalizeNonLinearIteration()
+
+                # Check convergence
+                if rel_res_norm <= temp_rel_tol:
+                    KratosMultiphysics.Logger.PrintInfo("::[ConjugateHeatTransferSolver]::", "Converged in " + str(iteration) + " iterations.")
+                    break
+                elif iteration == max_iteration:
+                    KratosMultiphysics.Logger.PrintInfo("::[ConjugateHeatTransferSolver]::", "Did not converge in " + str(iteration) + " iterations.")
+
+    def FinalizeSolutionStep(self):
+        if self._time_buffer_is_initialized():
+            self.fluid_solver.FinalizeSolutionStep()
+            self.fluid_thermal_solver.FinalizeSolutionStep()
+            self.solid_thermal_solver.FinalizeSolutionStep()
+            self._get_convergence_accelerator().FinalizeSolutionStep()
+
+    def _set_up_dirichlet_coupling_boundary(self):
+        # Run the solid interfaces list to fix the temperature DOFs.
+        for node in self._get_dirichlet_coupling_interface().Nodes:
+            node.Fix(KratosMultiphysics.TEMPERATURE)
+
+    def _set_up_mappers(self):
+        # Set mappers settings
+        mappers_settings = self.settings["coupling_settings"]["mappers_settings"]
+
+        flux_mapper_parameters = KratosMultiphysics.Parameters(r'''{
+            "mapping_coefficient": -1.0,
+            "origin_variable": "AUX_FLUX",
+            "destination_variable": "FACE_HEAT_FLUX"
+        }''')
+        flux_mapper_parameters.AddValue("echo_level", mappers_settings["echo_level"])
+        flux_mapper_parameters.AddValue("integration_order", mappers_settings["integration_order"])
+        flux_mapper_parameters.AddValue("distance_threshold", mappers_settings["distance_threshold"])
+        flux_mapper_parameters.AddValue("max_number_iterations", mappers_settings["max_number_iterations"])
+        flux_mapper_parameters.AddValue("absolute_convergence_tolerance", mappers_settings["absolute_convergence_tolerance"])
+        flux_mapper_parameters.AddValue("relative_convergence_tolerance", mappers_settings["relative_convergence_tolerance"])
+        flux_mapper_parameters.AddValue("search_parameters", mappers_settings["search_parameters"])
+
+        temp_mapper_parameters = KratosMultiphysics.Parameters(r'''{
+            "origin_variable": "TEMPERATURE",
+            "destination_variable": "AUX_TEMPERATURE"
+        }''')
+        temp_mapper_parameters.AddValue("echo_level", mappers_settings["echo_level"])
+        temp_mapper_parameters.AddValue("integration_order", mappers_settings["integration_order"])
+        temp_mapper_parameters.AddValue("distance_threshold", mappers_settings["distance_threshold"])
+        temp_mapper_parameters.AddValue("max_number_iterations", mappers_settings["max_number_iterations"])
+        temp_mapper_parameters.AddValue("absolute_convergence_tolerance", mappers_settings["absolute_convergence_tolerance"])
+        temp_mapper_parameters.AddValue("relative_convergence_tolerance", mappers_settings["relative_convergence_tolerance"])
+        temp_mapper_parameters.AddValue("search_parameters", mappers_settings["search_parameters"])
+
+        # Create flux mapper
+        self.flux_mapper = KratosMultiphysics.SimpleMortarMapperProcess(
+            self._get_dirichlet_coupling_interface(),
+            self._get_neumann_coupling_interface(),
+            flux_mapper_parameters)
+
+        # Create temperature mapper
+        self.temp_mapper = KratosMultiphysics.SimpleMortarMapperProcess(
+            self._get_neumann_coupling_interface(),
+            self._get_dirichlet_coupling_interface(),
+            temp_mapper_parameters)
+
+    # This method returns the fluid thermal interface
+    def _get_fluid_thermal_interface(self):
+        if self.settings["coupling_settings"]["fluid_interfaces_list"].size() > 1:
+            raise Exception("More than one fluid interfaces is not supported yet.")
+
+        fluid_int_name = self.settings["coupling_settings"]["fluid_interfaces_list"][0].GetString()
+        return self.model.GetModelPart(fluid_int_name)
+
+    # This method returns the solid thermal interface
+    def _get_solid_thermal_interface(self):
+        if self.settings["coupling_settings"]["solid_interfaces_list"].size() > 1:
+            raise Exception("More than one solid interfaces is not supported yet.")
+
+        solid_int_name = self.settings["coupling_settings"]["solid_interfaces_list"][0].GetString()
+        return self.model.GetModelPart(solid_int_name)
+
+    # This method returns the Dirichlet coupling interface model part
+    def _get_dirichlet_coupling_interface(self):
+        if self.settings["coupling_settings"]["dirichlet_coupling_interface"].GetString() == "fluid":
+            return self._get_fluid_thermal_interface()
+        else:
+            return self._get_solid_thermal_interface()
+
+    # This method returns the Neumann coupling interface model part
+    def _get_neumann_coupling_interface(self):
+        if self.settings["coupling_settings"]["dirichlet_coupling_interface"].GetString() == "fluid":
+            return self._get_solid_thermal_interface()
+        else:
+            return self._get_fluid_thermal_interface()
+
+    # This method returns the domain thermal solver corresponding to the Dirichlet coupling interface
+    def _get_dirichlet_interface_thermal_solver(self):
+        if self.settings["coupling_settings"]["dirichlet_coupling_interface"].GetString() == "fluid":
+            return self.fluid_thermal_solver
+        else:
+            return self.solid_thermal_solver
+
+    # This method returns the domain thermal solver corresponding to the Neumann coupling interface
+    def _get_neumann_interface_thermal_solver(self):
+        if self.settings["coupling_settings"]["dirichlet_coupling_interface"].GetString() == "fluid":
+            return self.solid_thermal_solver
+        else:
+            return self.fluid_thermal_solver
+
+    # This method returns the convergence accelerator.
+    # If it is not created yet, it calls the _create_convergence_accelerator first
+    def _get_convergence_accelerator(self):
+        if not hasattr(self, '_convergence_accelerator'):
+            self._convergence_accelerator = self._create_convergence_accelerator()
+        return self._convergence_accelerator
+
+    # This method constructs the convergence accelerator coupling utility
+    def _create_convergence_accelerator(self):
+        conv_acc_parameters = self.settings["coupling_settings"]["convergence_accelerator_settings"]
+        convergence_accelerator = convergence_accelerator_factory.CreateConvergenceAccelerator(conv_acc_parameters)
+        KratosMultiphysics.Logger.PrintInfo("::[ConjugateHeatTransferSolver]::", "Convergence accelerator construction finished.")
+        return convergence_accelerator
+
+    # This method returns the partitioned FSI utilities class
+    def _get_partitioned_FSI_utilities(self):
+        if (self.domain_size == 2):
+            return KratosFSI.PartitionedFSIUtilitiesDouble2D()
+        else:
+            return KratosFSI.PartitionedFSIUtilitiesDouble3D()
+
+    def _initialize_iteration_value_vector(self):
+        # Initialize the iteration value for the residual computation
+        self.iteration_value = KratosMultiphysics.Vector(
+            self._get_partitioned_FSI_utilities().GetInterfaceResidualSize(self._get_dirichlet_coupling_interface()))
+        i = 0
+        for node in self._get_dirichlet_coupling_interface().Nodes:
+            self.iteration_value[i] = node.GetSolutionStepValue(KratosMultiphysics.TEMPERATURE)
+            i += 1
+
+    def _temperature_coupling_prediction(self):
+        # Create temperature prediction mapper
+        mappers_settings = self.settings["coupling_settings"]["mappers_settings"]
+        temp_pred_mapper_parameters = KratosMultiphysics.Parameters(r'''{
+            "origin_variable": "TEMPERATURE",
+            "destination_variable": "TEMPERATURE"
+        }''')
+        temp_pred_mapper_parameters.AddValue("echo_level", mappers_settings["echo_level"])
+        temp_pred_mapper_parameters.AddValue("integration_order", mappers_settings["integration_order"])
+        temp_pred_mapper_parameters.AddValue("distance_threshold", mappers_settings["distance_threshold"])
+        temp_pred_mapper_parameters.AddValue("max_number_iterations", mappers_settings["max_number_iterations"])
+        temp_pred_mapper_parameters.AddValue("absolute_convergence_tolerance", mappers_settings["absolute_convergence_tolerance"])
+        temp_pred_mapper_parameters.AddValue("relative_convergence_tolerance", mappers_settings["relative_convergence_tolerance"])
+        temp_pred_mapper_parameters.AddValue("search_parameters", mappers_settings["search_parameters"])
+
+        # Map TEMPERATURE from the Neumann side to the Dirichlet side
+        KratosMultiphysics.SimpleMortarMapperProcess(
+            self._get_neumann_coupling_interface(),
+            self._get_dirichlet_coupling_interface(),
+            temp_pred_mapper_parameters).Execute()
+
+    def _time_buffer_is_initialized(self):
+        # Get current step counter. Note that the buoyancy and thermal fluid domain main_model_part
+        # share the same ProcessInfo(), so the STEP counter is always the same.
+        fluid_step = self.fluid_solver.main_model_part.ProcessInfo[KratosMultiphysics.STEP]
+        solid_step = self.solid_thermal_solver.main_model_part.ProcessInfo[KratosMultiphysics.STEP]
+
+        if (fluid_step != solid_step):
+            err_msg = "Fluid domain and solid domain time steps do not coincide\n"
+            err_msg += "-Fluid domain time step: " + str(fluid_step) + "\n"
+            err_msg += "-Solid domain time step: " + str(solid_step) + "\n"
+            err_msg += "Check AdvanceInTime() method."
+            raise Exception(err_msg)
+
+        # We always have one extra old step (step 0, read from input)
+        return fluid_step + 1 >= self.GetMinimumBufferSize()
```

## KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_analysis.py

 * *Ordering differences only*

```diff
@@ -1,60 +1,60 @@
-
-# Importing Kratos
-import KratosMultiphysics
-from KratosMultiphysics.ConvectionDiffusionApplication import python_solvers_wrapper_convection_diffusion as solver_wrapper
-
-# Importing the base class
-from KratosMultiphysics.analysis_stage import AnalysisStage
-
-# Other imports
-import sys
-
-class ConvectionDiffusionAnalysis(AnalysisStage):
-    """
-    This class is the main-script of the ConvectionDiffusionApplication put in a class
-
-    It can be imported and used as "black-box"
-    """
-    def __init__(self, model, project_parameters):
-        # Making sure that older cases still work by properly initalizing the parameters
-        solver_settings = project_parameters["solver_settings"]
-
-        if not solver_settings.Has("domain_size"):
-            KratosMultiphysics.Logger.PrintInfo("ConvectionDiffusionAnalysis", "Using the old way to pass the domain_size, this will be removed!")
-            solver_settings.AddEmptyValue("domain_size")
-            solver_settings["domain_size"].SetInt(project_parameters["problem_data"]["domain_size"].GetInt())
-
-        super(ConvectionDiffusionAnalysis, self).__init__(model, project_parameters)
-
-    #### Internal functions ####
-    def _CreateSolver(self):
-        """ Create the Solver (and create and import the ModelPart if it is not alread in the model) """
-        ## Solver construction
-        return solver_wrapper.CreateSolverByParameters(self.model, self.project_parameters["solver_settings"],self.project_parameters["problem_data"]["parallel_type"].GetString())
-
-    def _GetSimulationName(self):
-        return "::[Convection-Diffusion Simulation]:: "
-
-if __name__ == "__main__":
-    from sys import argv
-
-    if len(argv) > 2:
-        err_msg =  'Too many input arguments!\n'
-        err_msg += 'Use this script in the following way:\n'
-        err_msg += '- With default ProjectParameters (read from "ProjectParameters.json"):\n'
-        err_msg += '    "python3 convection_diffusion_analysis.py"\n'
-        err_msg += '- With custom ProjectParameters:\n'
-        err_msg += '    "python3 convection_diffusion_analysis.py CustomProjectParameters.json"\n'
-        raise Exception(err_msg)
-
-    if len(argv) == 2: # ProjectParameters is being passed from outside
-        project_parameters_file_name = argv[1]
-    else: # using default name
-        project_parameters_file_name = "ProjectParameters.json"
-
-    with open(project_parameters_file_name,'r') as parameter_file:
-        parameters = KratosMultiphysics.Parameters(parameter_file.read())
-
-    model = KratosMultiphysics.Model()
-    simulation = ConvectionDiffusionAnalysis(model, parameters)
-    simulation.Run()
+
+# Importing Kratos
+import KratosMultiphysics
+from KratosMultiphysics.ConvectionDiffusionApplication import python_solvers_wrapper_convection_diffusion as solver_wrapper
+
+# Importing the base class
+from KratosMultiphysics.analysis_stage import AnalysisStage
+
+# Other imports
+import sys
+
+class ConvectionDiffusionAnalysis(AnalysisStage):
+    """
+    This class is the main-script of the ConvectionDiffusionApplication put in a class
+
+    It can be imported and used as "black-box"
+    """
+    def __init__(self, model, project_parameters):
+        # Making sure that older cases still work by properly initalizing the parameters
+        solver_settings = project_parameters["solver_settings"]
+
+        if not solver_settings.Has("domain_size"):
+            KratosMultiphysics.Logger.PrintInfo("ConvectionDiffusionAnalysis", "Using the old way to pass the domain_size, this will be removed!")
+            solver_settings.AddEmptyValue("domain_size")
+            solver_settings["domain_size"].SetInt(project_parameters["problem_data"]["domain_size"].GetInt())
+
+        super(ConvectionDiffusionAnalysis, self).__init__(model, project_parameters)
+
+    #### Internal functions ####
+    def _CreateSolver(self):
+        """ Create the Solver (and create and import the ModelPart if it is not alread in the model) """
+        ## Solver construction
+        return solver_wrapper.CreateSolverByParameters(self.model, self.project_parameters["solver_settings"],self.project_parameters["problem_data"]["parallel_type"].GetString())
+
+    def _GetSimulationName(self):
+        return "::[Convection-Diffusion Simulation]:: "
+
+if __name__ == "__main__":
+    from sys import argv
+
+    if len(argv) > 2:
+        err_msg =  'Too many input arguments!\n'
+        err_msg += 'Use this script in the following way:\n'
+        err_msg += '- With default ProjectParameters (read from "ProjectParameters.json"):\n'
+        err_msg += '    "python3 convection_diffusion_analysis.py"\n'
+        err_msg += '- With custom ProjectParameters:\n'
+        err_msg += '    "python3 convection_diffusion_analysis.py CustomProjectParameters.json"\n'
+        raise Exception(err_msg)
+
+    if len(argv) == 2: # ProjectParameters is being passed from outside
+        project_parameters_file_name = argv[1]
+    else: # using default name
+        project_parameters_file_name = "ProjectParameters.json"
+
+    with open(project_parameters_file_name,'r') as parameter_file:
+        parameters = KratosMultiphysics.Parameters(parameter_file.read())
+
+    model = KratosMultiphysics.Model()
+    simulation = ConvectionDiffusionAnalysis(model, parameters)
+    simulation.Run()
```

## KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_transient_solver.py

 * *Ordering differences only*

```diff
@@ -1,60 +1,60 @@
-
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.ConvectionDiffusionApplication as ConvectionDiffusionApplication
-if KratosMultiphysics.ParallelEnvironment.GetDefaultDataCommunicator().IsDistributed():
-    import KratosMultiphysics.mpi as KratosMPI
-    import KratosMultiphysics.MetisApplication as KratosMetis
-    import KratosMultiphysics.TrilinosApplication as KratosTrilinos
-
-# Import base class file
-from KratosMultiphysics.ConvectionDiffusionApplication import convection_diffusion_solver
-
-def CreateSolver(model, custom_settings):
-    return ConvectionDiffusionTransientSolver(model, custom_settings)
-
-class ConvectionDiffusionTransientSolver(convection_diffusion_solver.ConvectionDiffusionSolver):
-    """The transient class for convection-diffusion solvers.
-
-    Public member variables:
-    transient_settings -- settings for the implicit dynamic solvers.
-
-    See convection_diffusion_solver.py for more information.
-    """
-
-    def __init__(self, model, custom_settings):
-        # Construct the base solver and validate the settings in base class
-        super().__init__(model, custom_settings)
-
-        # Overwrite the base solver minimum buffer size
-        self.min_buffer_size = 2
-
-        KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "Construction finished")
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KratosMultiphysics.Parameters(r"""{
-            "time_integration_method" : "implicit",
-            "transient_parameters" : {
-                "dynamic_tau": 1.0,
-                "theta"    : 0.5
-            }
-        }""")
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
-
-    #### Private functions ####
-    def _CreateScheme(self):
-        # Variable defining the temporal scheme (0: Forward Euler, 1: Backward Euler, 0.5: Crank-Nicolson)
-        self.GetComputingModelPart().ProcessInfo[KratosMultiphysics.TIME_INTEGRATION_THETA] = self.settings["transient_parameters"]["theta"].GetDouble()
-        self.GetComputingModelPart().ProcessInfo[KratosMultiphysics.DYNAMIC_TAU] = self.settings["transient_parameters"]["dynamic_tau"].GetDouble()
-
-        # As the time integration is managed by the element, we set a "fake" scheme to perform the solution update
-        if not self.main_model_part.IsDistributed():
-            convection_diffusion_scheme = KratosMultiphysics.ResidualBasedIncrementalUpdateStaticScheme()
-        else:
-            convection_diffusion_scheme = KratosTrilinos.TrilinosResidualBasedIncrementalUpdateStaticScheme()
-
-        return convection_diffusion_scheme
+
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.ConvectionDiffusionApplication as ConvectionDiffusionApplication
+if KratosMultiphysics.ParallelEnvironment.GetDefaultDataCommunicator().IsDistributed():
+    import KratosMultiphysics.mpi as KratosMPI
+    import KratosMultiphysics.MetisApplication as KratosMetis
+    import KratosMultiphysics.TrilinosApplication as KratosTrilinos
+
+# Import base class file
+from KratosMultiphysics.ConvectionDiffusionApplication import convection_diffusion_solver
+
+def CreateSolver(model, custom_settings):
+    return ConvectionDiffusionTransientSolver(model, custom_settings)
+
+class ConvectionDiffusionTransientSolver(convection_diffusion_solver.ConvectionDiffusionSolver):
+    """The transient class for convection-diffusion solvers.
+
+    Public member variables:
+    transient_settings -- settings for the implicit dynamic solvers.
+
+    See convection_diffusion_solver.py for more information.
+    """
+
+    def __init__(self, model, custom_settings):
+        # Construct the base solver and validate the settings in base class
+        super().__init__(model, custom_settings)
+
+        # Overwrite the base solver minimum buffer size
+        self.min_buffer_size = 2
+
+        KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "Construction finished")
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KratosMultiphysics.Parameters(r"""{
+            "time_integration_method" : "implicit",
+            "transient_parameters" : {
+                "dynamic_tau": 1.0,
+                "theta"    : 0.5
+            }
+        }""")
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
+
+    #### Private functions ####
+    def _CreateScheme(self):
+        # Variable defining the temporal scheme (0: Forward Euler, 1: Backward Euler, 0.5: Crank-Nicolson)
+        self.GetComputingModelPart().ProcessInfo[KratosMultiphysics.TIME_INTEGRATION_THETA] = self.settings["transient_parameters"]["theta"].GetDouble()
+        self.GetComputingModelPart().ProcessInfo[KratosMultiphysics.DYNAMIC_TAU] = self.settings["transient_parameters"]["dynamic_tau"].GetDouble()
+
+        # As the time integration is managed by the element, we set a "fake" scheme to perform the solution update
+        if not self.main_model_part.IsDistributed():
+            convection_diffusion_scheme = KratosMultiphysics.ResidualBasedIncrementalUpdateStaticScheme()
+        else:
+            convection_diffusion_scheme = KratosTrilinos.TrilinosResidualBasedIncrementalUpdateStaticScheme()
+
+        return convection_diffusion_scheme
```

## KratosMultiphysics/ConvectionDiffusionApplication/coupled_fluid_thermal_solver.py

 * *Ordering differences only*

```diff
@@ -1,189 +1,189 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications modules
-from KratosMultiphysics.FluidDynamicsApplication import python_solvers_wrapper_fluid
-from KratosMultiphysics.ConvectionDiffusionApplication import python_solvers_wrapper_convection_diffusion
-
-# Importing the base class
-from KratosMultiphysics.python_solver import PythonSolver
-
-def CreateSolver(main_model_part, custom_settings):
-    return CoupledFluidThermalSolver(main_model_part, custom_settings)
-
-class CoupledFluidThermalSolver(PythonSolver):
-
-    @classmethod
-    def GetDefaultParameters(cls):
-
-        default_settings = KratosMultiphysics.Parameters("""
-        {
-            "solver_type" : "ThermallyCoupled",
-            "domain_size" : -1,
-            "echo_level": 0,
-            "fluid_solver_settings": {
-                "solver_type": "navier_stokes_solver_vmsmonolithic",
-                "model_import_settings": {
-                    "input_type": "mdpa",
-                    "input_filename": "unknown_name"
-                }
-            },
-            "thermal_solver_settings": {
-                "solver_type": "transient",
-                "analysis_type": "linear",
-                "model_import_settings": {
-                    "input_type": "use_input_model_part"
-                },
-                "material_import_settings": {
-                    "materials_filename": "ThermalMaterials.json"
-                }
-            }
-        }
-        """)
-
-        default_settings.AddMissingParameters(super().GetDefaultParameters())
-        return default_settings
-
-    def __init__(self, model, custom_settings):
-        ## Cal base class constructor
-        super().__init__(model, custom_settings)
-
-        ## Get domain size
-        self.domain_size = self.settings["domain_size"].GetInt()
-
-        ## Create subdomain solvers
-        self.fluid_solver = python_solvers_wrapper_fluid.CreateSolverByParameters(self.model, self.settings["fluid_solver_settings"],"OpenMP")
-        self.thermal_solver = python_solvers_wrapper_convection_diffusion.CreateSolverByParameters(self.model,self.settings["thermal_solver_settings"],"OpenMP")
-
-    def AddVariables(self):
-        # Import the fluid and thermal solver variables. Then merge them to have them in both fluid and thermal solvers.
-        self.fluid_solver.AddVariables()
-        self.thermal_solver.AddVariables()
-        KratosMultiphysics.MergeVariableListsUtility().Merge(self.fluid_solver.main_model_part, self.thermal_solver.main_model_part)
-
-    def ImportModelPart(self):
-        # Call the fluid solver to import the model part from the mdpa
-        self.fluid_solver.ImportModelPart()
-
-        # Save the convection diffusion settings
-        convection_diffusion_settings = self.thermal_solver.main_model_part.ProcessInfo.GetValue(KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS)
-
-        # Here the fluid model part is cloned to be thermal model part so that the nodes are shared
-        element_name, condition_name = self.__GetElementAndConditionNames()
-        modeler = KratosMultiphysics.ConnectivityPreserveModeler()
-        modeler.GenerateModelPart(
-            self.fluid_solver.main_model_part,
-            self.thermal_solver.main_model_part,
-            element_name,
-            condition_name)
-
-        # Set the saved convection diffusion settings to the new thermal model part
-        self.thermal_solver.main_model_part.ProcessInfo.SetValue(KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS, convection_diffusion_settings)
-
-    def PrepareModelPart(self):
-        self.fluid_solver.PrepareModelPart()
-        self.thermal_solver.PrepareModelPart()
-
-    def AddDofs(self):
-        self.fluid_solver.AddDofs()
-        self.thermal_solver.AddDofs()
-
-    def AdaptMesh(self):
-        pass
-
-    def GetComputingModelPart(self):
-        return self.fluid_solver.GetComputingModelPart()
-
-    def GetOutputVariables(self):
-        pass
-
-    def ComputeDeltaTime(self):
-        return self.fluid_solver._ComputeDeltaTime()
-
-    def GetMinimumBufferSize(self):
-        buffer_size_fluid = self.fluid_solver.GetMinimumBufferSize()
-        buffer_size_thermal = self.thermal_solver.GetMinimumBufferSize()
-        return max(buffer_size_fluid, buffer_size_thermal)
-
-    def Initialize(self):
-        self.fluid_solver.Initialize()
-        self.thermal_solver.Initialize()
-
-    def Clear(self):
-        (self.fluid_solver).Clear()
-        (self.thermal_solver).Clear()
-
-    def Check(self):
-        (self.fluid_solver).Check()
-        (self.thermal_solver).Check()
-
-    def SetEchoLevel(self, level):
-        (self.fluid_solver).SetEchoLevel(level)
-        (self.thermal_solver).SetEchoLevel(level)
-
-    def AdvanceInTime(self, current_time):
-        #NOTE: the cloning is done ONLY ONCE since the nodes are shared
-        new_time = self.fluid_solver.AdvanceInTime(current_time)
-        return new_time
-
-    def InitializeSolutionStep(self):
-        self.fluid_solver.InitializeSolutionStep()
-        self.thermal_solver.InitializeSolutionStep()
-
-    def Predict(self):
-        self.fluid_solver.Predict()
-        self.thermal_solver.Predict()
-
-    def SolveSolutionStep(self):
-        fluid_is_converged = self.fluid_solver.SolveSolutionStep()
-        thermal_is_converged = self.thermal_solver.SolveSolutionStep()
-
-        return (fluid_is_converged and thermal_is_converged)
-
-    def FinalizeSolutionStep(self):
-        self.fluid_solver.FinalizeSolutionStep()
-        self.thermal_solver.FinalizeSolutionStep()
-
-    def __GetElementAndConditionNames(self):
-        ''' Auxiliary function to get the element and condition names for the connectivity preserve modeler call
-
-        This function returns the element and condition names from the domain size and number of nodes.
-        Note that throughout all the substitution process a unique element type and condition is assumed.
-        Also note that the connectivity preserve modeler call will create standard base elements as these are to
-        be substituted by the corresponding ones in the PrepareModelPart call of the thermal solver.
-        '''
-
-        ## Get and check domain size
-        fluid_model_part = self.fluid_solver.main_model_part
-        domain_size = fluid_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE]
-        if domain_size not in [2,3]:
-            raise Exception("DOMAIN_SIZE is not set in ProcessInfo container.")
-
-        ## Elements
-        ## Get the number of nodes from the fluid mesh elements (if there are no elements simplicial are assumed)
-        num_nodes_elements = 0
-        if (len(fluid_model_part.Elements) > 0):
-            for elem in fluid_model_part.Elements:
-                num_nodes_elements = len(elem.GetNodes())
-                break
-        num_nodes_elements = fluid_model_part.GetCommunicator().GetDataCommunicator().MaxAll(num_nodes_elements)
-        if not num_nodes_elements:
-            num_nodes_elements = domain_size + 1
-
-        element_name = f"Element{domain_size}D{num_nodes_elements}N"
-
-        ## Conditions
-        ## Get the number of nodes from the fluid mesh conditions (if there are no elements simplicial are assumed)
-        num_nodes_conditions = 0
-        if (len(fluid_model_part.Conditions) > 0):
-            for cond in fluid_model_part.Conditions:
-                num_nodes_conditions = len(cond.GetNodes())
-                break
-        num_nodes_conditions = fluid_model_part.GetCommunicator().GetDataCommunicator().MaxAll(num_nodes_conditions)
-        if not num_nodes_conditions:
-            num_nodes_conditions = domain_size
-
-        aux_condition_name = "LineCondition" if domain_size == 2 else "SurfaceCondition"
-        condition_name = f"{aux_condition_name}{domain_size}D{num_nodes_conditions}N"
-
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications modules
+from KratosMultiphysics.FluidDynamicsApplication import python_solvers_wrapper_fluid
+from KratosMultiphysics.ConvectionDiffusionApplication import python_solvers_wrapper_convection_diffusion
+
+# Importing the base class
+from KratosMultiphysics.python_solver import PythonSolver
+
+def CreateSolver(main_model_part, custom_settings):
+    return CoupledFluidThermalSolver(main_model_part, custom_settings)
+
+class CoupledFluidThermalSolver(PythonSolver):
+
+    @classmethod
+    def GetDefaultParameters(cls):
+
+        default_settings = KratosMultiphysics.Parameters("""
+        {
+            "solver_type" : "ThermallyCoupled",
+            "domain_size" : -1,
+            "echo_level": 0,
+            "fluid_solver_settings": {
+                "solver_type": "navier_stokes_solver_vmsmonolithic",
+                "model_import_settings": {
+                    "input_type": "mdpa",
+                    "input_filename": "unknown_name"
+                }
+            },
+            "thermal_solver_settings": {
+                "solver_type": "transient",
+                "analysis_type": "linear",
+                "model_import_settings": {
+                    "input_type": "use_input_model_part"
+                },
+                "material_import_settings": {
+                    "materials_filename": "ThermalMaterials.json"
+                }
+            }
+        }
+        """)
+
+        default_settings.AddMissingParameters(super().GetDefaultParameters())
+        return default_settings
+
+    def __init__(self, model, custom_settings):
+        ## Cal base class constructor
+        super().__init__(model, custom_settings)
+
+        ## Get domain size
+        self.domain_size = self.settings["domain_size"].GetInt()
+
+        ## Create subdomain solvers
+        self.fluid_solver = python_solvers_wrapper_fluid.CreateSolverByParameters(self.model, self.settings["fluid_solver_settings"],"OpenMP")
+        self.thermal_solver = python_solvers_wrapper_convection_diffusion.CreateSolverByParameters(self.model,self.settings["thermal_solver_settings"],"OpenMP")
+
+    def AddVariables(self):
+        # Import the fluid and thermal solver variables. Then merge them to have them in both fluid and thermal solvers.
+        self.fluid_solver.AddVariables()
+        self.thermal_solver.AddVariables()
+        KratosMultiphysics.MergeVariableListsUtility().Merge(self.fluid_solver.main_model_part, self.thermal_solver.main_model_part)
+
+    def ImportModelPart(self):
+        # Call the fluid solver to import the model part from the mdpa
+        self.fluid_solver.ImportModelPart()
+
+        # Save the convection diffusion settings
+        convection_diffusion_settings = self.thermal_solver.main_model_part.ProcessInfo.GetValue(KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS)
+
+        # Here the fluid model part is cloned to be thermal model part so that the nodes are shared
+        element_name, condition_name = self.__GetElementAndConditionNames()
+        modeler = KratosMultiphysics.ConnectivityPreserveModeler()
+        modeler.GenerateModelPart(
+            self.fluid_solver.main_model_part,
+            self.thermal_solver.main_model_part,
+            element_name,
+            condition_name)
+
+        # Set the saved convection diffusion settings to the new thermal model part
+        self.thermal_solver.main_model_part.ProcessInfo.SetValue(KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS, convection_diffusion_settings)
+
+    def PrepareModelPart(self):
+        self.fluid_solver.PrepareModelPart()
+        self.thermal_solver.PrepareModelPart()
+
+    def AddDofs(self):
+        self.fluid_solver.AddDofs()
+        self.thermal_solver.AddDofs()
+
+    def AdaptMesh(self):
+        pass
+
+    def GetComputingModelPart(self):
+        return self.fluid_solver.GetComputingModelPart()
+
+    def GetOutputVariables(self):
+        pass
+
+    def ComputeDeltaTime(self):
+        return self.fluid_solver._ComputeDeltaTime()
+
+    def GetMinimumBufferSize(self):
+        buffer_size_fluid = self.fluid_solver.GetMinimumBufferSize()
+        buffer_size_thermal = self.thermal_solver.GetMinimumBufferSize()
+        return max(buffer_size_fluid, buffer_size_thermal)
+
+    def Initialize(self):
+        self.fluid_solver.Initialize()
+        self.thermal_solver.Initialize()
+
+    def Clear(self):
+        (self.fluid_solver).Clear()
+        (self.thermal_solver).Clear()
+
+    def Check(self):
+        (self.fluid_solver).Check()
+        (self.thermal_solver).Check()
+
+    def SetEchoLevel(self, level):
+        (self.fluid_solver).SetEchoLevel(level)
+        (self.thermal_solver).SetEchoLevel(level)
+
+    def AdvanceInTime(self, current_time):
+        #NOTE: the cloning is done ONLY ONCE since the nodes are shared
+        new_time = self.fluid_solver.AdvanceInTime(current_time)
+        return new_time
+
+    def InitializeSolutionStep(self):
+        self.fluid_solver.InitializeSolutionStep()
+        self.thermal_solver.InitializeSolutionStep()
+
+    def Predict(self):
+        self.fluid_solver.Predict()
+        self.thermal_solver.Predict()
+
+    def SolveSolutionStep(self):
+        fluid_is_converged = self.fluid_solver.SolveSolutionStep()
+        thermal_is_converged = self.thermal_solver.SolveSolutionStep()
+
+        return (fluid_is_converged and thermal_is_converged)
+
+    def FinalizeSolutionStep(self):
+        self.fluid_solver.FinalizeSolutionStep()
+        self.thermal_solver.FinalizeSolutionStep()
+
+    def __GetElementAndConditionNames(self):
+        ''' Auxiliary function to get the element and condition names for the connectivity preserve modeler call
+
+        This function returns the element and condition names from the domain size and number of nodes.
+        Note that throughout all the substitution process a unique element type and condition is assumed.
+        Also note that the connectivity preserve modeler call will create standard base elements as these are to
+        be substituted by the corresponding ones in the PrepareModelPart call of the thermal solver.
+        '''
+
+        ## Get and check domain size
+        fluid_model_part = self.fluid_solver.main_model_part
+        domain_size = fluid_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE]
+        if domain_size not in [2,3]:
+            raise Exception("DOMAIN_SIZE is not set in ProcessInfo container.")
+
+        ## Elements
+        ## Get the number of nodes from the fluid mesh elements (if there are no elements simplicial are assumed)
+        num_nodes_elements = 0
+        if (len(fluid_model_part.Elements) > 0):
+            for elem in fluid_model_part.Elements:
+                num_nodes_elements = len(elem.GetNodes())
+                break
+        num_nodes_elements = fluid_model_part.GetCommunicator().GetDataCommunicator().MaxAll(num_nodes_elements)
+        if not num_nodes_elements:
+            num_nodes_elements = domain_size + 1
+
+        element_name = f"Element{domain_size}D{num_nodes_elements}N"
+
+        ## Conditions
+        ## Get the number of nodes from the fluid mesh conditions (if there are no elements simplicial are assumed)
+        num_nodes_conditions = 0
+        if (len(fluid_model_part.Conditions) > 0):
+            for cond in fluid_model_part.Conditions:
+                num_nodes_conditions = len(cond.GetNodes())
+                break
+        num_nodes_conditions = fluid_model_part.GetCommunicator().GetDataCommunicator().MaxAll(num_nodes_conditions)
+        if not num_nodes_conditions:
+            num_nodes_conditions = domain_size
+
+        aux_condition_name = "LineCondition" if domain_size == 2 else "SurfaceCondition"
+        condition_name = f"{aux_condition_name}{domain_size}D{num_nodes_conditions}N"
+
         return element_name, condition_name
```

## KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_solver.py

 * *Ordering differences only*

```diff
@@ -1,807 +1,807 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Auxiliary function to check the parallel type at runtime
-#TODO: Delete this once we come up with the final factory-based design
-def _CheckIsDistributed():
-    if KratosMultiphysics.ParallelEnvironment.HasDataCommunicator("World"):
-        world_data_comm = KratosMultiphysics.ParallelEnvironment.GetDataCommunicator("World")
-        return world_data_comm.IsDistributed()
-    else:
-        return False
-
-# Import applications
-import KratosMultiphysics.ConvectionDiffusionApplication
-
-# If required, import parallel applications and modules
-if _CheckIsDistributed():
-    import KratosMultiphysics.mpi as KratosMPI
-    import KratosMultiphysics.MetisApplication as KratosMetis
-    import KratosMultiphysics.TrilinosApplication as KratosTrilinos
-    import KratosMultiphysics.mpi.distributed_import_model_part_utility as distributed_import_model_part_utility
-
-# Importing factories
-if _CheckIsDistributed():
-    import KratosMultiphysics.TrilinosApplication.trilinos_linear_solver_factory as linear_solver_factory
-else:
-    import KratosMultiphysics.python_linear_solver_factory as linear_solver_factory
-    import KratosMultiphysics.base_convergence_criteria_factory as convergence_criteria_factory
-
-# Importing the base class
-from KratosMultiphysics.python_solver import PythonSolver
-from KratosMultiphysics import auxiliary_solver_utilities
-
-def CreateSolver(model, custom_settings):
-    return ConvectionDiffusionSolver(model, custom_settings)
-
-class ConvectionDiffusionSolver(PythonSolver):
-    """The base class for convection-diffusion solvers.
-
-    This class provides functions for importing and exporting models,
-    adding nodal variables and dofs and solving each solution step.
-
-    Derived classes must override the function _CreateScheme which
-    constructs and returns a solution scheme. Depending on the type of
-    solver, derived classes may also need to override the following functions:
-
-    _CreateScheme
-    _CreateConvergenceCriterion
-    _CreateLinearSolver
-    _CreateBuilderAndSolver
-    _CreateSolutionStrategy
-
-    The convection_diffusion_solution_strategy, builder_and_solver, etc. should alway be retrieved
-    using the getter functions _GetSolutionStrategy, get_builder_and_solver,
-    etc. from this base class.
-
-    Only the member variables listed below should be accessed directly.
-
-    Public member variables:
-    model -- the model containing the modelpart used to construct the solver.
-    settings -- Kratos parameters containing solver settings.
-    """
-
-    def __init__(self, model, custom_settings):
-        super().__init__(model, custom_settings)
-
-        # Convection diffusion variables check
-        self._ConvectionDiffusionVariablesCheck(custom_settings)
-
-        model_part_name = self.settings["model_part_name"].GetString()
-
-        # Set default buffer size
-        self.min_buffer_size = 1
-
-        if model_part_name == "":
-            raise Exception('Please specify a model_part name!')
-
-        # This will be changed once the Model is fully supported!
-        if self.model.HasModelPart(model_part_name):
-            self.main_model_part = self.model[model_part_name]
-            self.solver_imports_model_part = False
-        else:
-            self.main_model_part = self.model.CreateModelPart(model_part_name) # Model.CreateodelPart()
-            domain_size = self.settings["domain_size"].GetInt()
-            if domain_size < 0:
-                raise Exception('Please specify a "domain_size" >= 0!')
-            self.main_model_part.ProcessInfo.SetValue(KratosMultiphysics.DOMAIN_SIZE, domain_size)
-            self.solver_imports_model_part = True
-
-        KratosMultiphysics.Logger.PrintInfo("::[ConvectionDiffusionSolver]:: ", "Construction finished")
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        default_settings = KratosMultiphysics.Parameters("""
-        {
-            "model_part_name" : "ThermalModelPart",
-            "domain_size" : -1,
-            "echo_level": 0,
-            "analysis_type": "linear",
-            "solver_type": "convection_diffusion_solver",
-            "model_import_settings": {
-                "input_type": "mdpa",
-                "input_filename": "unknown_name"
-            },
-            "material_import_settings" :{
-                "materials_filename": ""
-            },
-            "convection_diffusion_variables" : {
-                "density_variable"              : "DENSITY",
-                "diffusion_variable"            : "CONDUCTIVITY",
-                "unknown_variable"              : "TEMPERATURE",
-                "volume_source_variable"        : "HEAT_FLUX",
-                "surface_source_variable"       : "FACE_HEAT_FLUX",
-                "projection_variable"           : "PROJECTED_SCALAR1",
-                "convection_variable"           : "CONVECTION_VELOCITY",
-                "gradient_variable"             : "TEMPERATURE_GRADIENT",
-                "mesh_velocity_variable"        : "MESH_VELOCITY",
-                "transfer_coefficient_variable" : "TRANSFER_COEFFICIENT",
-                "velocity_variable"             : "VELOCITY",
-                "specific_heat_variable"        : "SPECIFIC_HEAT",
-                "reaction_variable"             : "REACTION_FLUX",
-                "reaction_gradient_variable"    : "REACTION"
-            },
-            "time_stepping" : {
-                "time_step": 1.0
-            },
-            "reform_dofs_at_each_step": false,
-            "gradient_dofs" : false,
-            "line_search": false,
-            "compute_reactions": true,
-            "block_builder": true,
-            "clear_storage": false,
-            "move_mesh_flag": false,
-            "convergence_criterion": "residual_criterion",
-            "solution_relative_tolerance": 1.0e-4,
-            "solution_absolute_tolerance": 1.0e-9,
-            "residual_relative_tolerance": 1.0e-4,
-            "residual_absolute_tolerance": 1.0e-9,
-            "max_iteration": 10,
-            "linear_solver_settings":{
-                "solver_type": "amgcl",
-                "smoother_type":"ilu0",
-                "krylov_type":"gmres",
-                "coarsening_type":"aggregation",
-                "max_iteration": 5000,
-                "tolerance": 1e-9,
-                "scaling": false
-            },
-            "element_replace_settings" : {
-                "element_name" : "EulerianConvDiff",
-                "condition_name" : "ThermalFace"
-            },
-            "problem_domain_sub_model_part_list": [""],
-            "processes_sub_model_part_list": [""],
-            "auxiliary_variables_list" : [],
-            "assign_neighbour_elements_to_conditions" : true
-        }
-        """)
-        default_settings.AddMissingParameters(super().GetDefaultParameters())
-        return default_settings
-
-    def AddVariables(self, target_model_part=None):
-
-        if target_model_part == None:
-            target_model_part = self.main_model_part
-
-        ''' Add nodal solution step variables based on provided CONVECTION_DIFFUSION_SETTINGS
-        '''
-        convention_diffusion_settings = KratosMultiphysics.ConvectionDiffusionSettings()
-        density_variable = self.settings["convection_diffusion_variables"]["density_variable"].GetString()
-        if (density_variable != ""):
-            convention_diffusion_settings.SetDensityVariable(KratosMultiphysics.KratosGlobals.GetVariable(density_variable))
-        diffusion_variable = self.settings["convection_diffusion_variables"]["diffusion_variable"].GetString()
-        if (diffusion_variable != ""):
-            convention_diffusion_settings.SetDiffusionVariable(KratosMultiphysics.KratosGlobals.GetVariable(diffusion_variable))
-        unknown_variable = self.settings["convection_diffusion_variables"]["unknown_variable"].GetString()
-        if (unknown_variable != ""):
-            convention_diffusion_settings.SetUnknownVariable(KratosMultiphysics.KratosGlobals.GetVariable(unknown_variable))
-        volume_source_variable = self.settings["convection_diffusion_variables"]["volume_source_variable"].GetString()
-        if (volume_source_variable != ""):
-            convention_diffusion_settings.SetVolumeSourceVariable(KratosMultiphysics.KratosGlobals.GetVariable(volume_source_variable))
-        surface_source_variable = self.settings["convection_diffusion_variables"]["surface_source_variable"].GetString()
-        if (surface_source_variable != ""):
-            convention_diffusion_settings.SetSurfaceSourceVariable(KratosMultiphysics.KratosGlobals.GetVariable(surface_source_variable))
-        projection_variable = self.settings["convection_diffusion_variables"]["projection_variable"].GetString()
-        if (projection_variable != ""):
-            convention_diffusion_settings.SetProjectionVariable(KratosMultiphysics.KratosGlobals.GetVariable(projection_variable))
-        convection_variable = self.settings["convection_diffusion_variables"]["convection_variable"].GetString()
-        if (convection_variable != ""):
-            convention_diffusion_settings.SetConvectionVariable(KratosMultiphysics.KratosGlobals.GetVariable(convection_variable))
-        gradient_variable = self.settings["convection_diffusion_variables"]["gradient_variable"].GetString()
-        if gradient_variable != "":
-            convention_diffusion_settings.SetGradientVariable(KratosMultiphysics.KratosGlobals.GetVariable(gradient_variable))
-        mesh_velocity_variable = self.settings["convection_diffusion_variables"]["mesh_velocity_variable"].GetString()
-        if (mesh_velocity_variable != ""):
-            convention_diffusion_settings.SetMeshVelocityVariable(KratosMultiphysics.KratosGlobals.GetVariable(mesh_velocity_variable))
-        transfer_coefficient_variable = self.settings["convection_diffusion_variables"]["transfer_coefficient_variable"].GetString()
-        if (transfer_coefficient_variable != ""):
-            convention_diffusion_settings.SetTransferCoefficientVariable(KratosMultiphysics.KratosGlobals.GetVariable(transfer_coefficient_variable))
-        velocity_variable = self.settings["convection_diffusion_variables"]["velocity_variable"].GetString()
-        if (velocity_variable != ""):
-            convention_diffusion_settings.SetVelocityVariable(KratosMultiphysics.KratosGlobals.GetVariable(velocity_variable))
-        specific_heat_variable = self.settings["convection_diffusion_variables"]["specific_heat_variable"].GetString()
-        if (specific_heat_variable != ""):
-            convention_diffusion_settings.SetSpecificHeatVariable(KratosMultiphysics.KratosGlobals.GetVariable(specific_heat_variable))
-        reaction_variable = self.settings["convection_diffusion_variables"]["reaction_variable"].GetString()
-        if (reaction_variable != ""):
-            convention_diffusion_settings.SetReactionVariable(KratosMultiphysics.KratosGlobals.GetVariable(reaction_variable))
-        reaction_gradient_variable = self.settings["convection_diffusion_variables"]["reaction_gradient_variable"].GetString()
-        if (reaction_gradient_variable != ""):
-            convention_diffusion_settings.SetReactionGradientVariable(KratosMultiphysics.KratosGlobals.GetVariable(reaction_gradient_variable))
-
-        target_model_part.ProcessInfo.SetValue(KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS, convention_diffusion_settings)
-
-        if target_model_part.ProcessInfo.Has(KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS):
-            if convention_diffusion_settings.IsDefinedDensityVariable():
-                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetDensityVariable())
-            if convention_diffusion_settings.IsDefinedDiffusionVariable():
-                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetDiffusionVariable())
-            if convention_diffusion_settings.IsDefinedUnknownVariable():
-                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetUnknownVariable())
-            if convention_diffusion_settings.IsDefinedVolumeSourceVariable():
-                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetVolumeSourceVariable())
-            if convention_diffusion_settings.IsDefinedSurfaceSourceVariable():
-                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetSurfaceSourceVariable())
-            if convention_diffusion_settings.IsDefinedProjectionVariable():
-                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetProjectionVariable())
-            if convention_diffusion_settings.IsDefinedConvectionVariable():
-                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetConvectionVariable())
-            if convention_diffusion_settings.IsDefinedGradientVariable():
-                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetGradientVariable())
-            if convention_diffusion_settings.IsDefinedMeshVelocityVariable():
-                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetMeshVelocityVariable())
-            if convention_diffusion_settings.IsDefinedTransferCoefficientVariable():
-                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetTransferCoefficientVariable())
-            if convention_diffusion_settings.IsDefinedVelocityVariable():
-                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetVelocityVariable())
-            if convention_diffusion_settings.IsDefinedSpecificHeatVariable():
-                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetSpecificHeatVariable())
-            if convention_diffusion_settings.IsDefinedReactionVariable():
-                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetReactionVariable())
-            if convention_diffusion_settings.IsDefinedReactionGradientVariable():
-                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetReactionGradientVariable())
-        else:
-            raise Exception("The provided target_model_part does not have CONVECTION_DIFFUSION_SETTINGS defined.")
-
-        # Adding nodal area variable (some solvers use it. TODO: Ask)
-        #target_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.NODAL_AREA)
-        # If LaplacianElement is used
-        if (self.settings["element_replace_settings"]["element_name"].GetString() == "LaplacianElement"):
-            target_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.NORMAL)
-
-        # If MPI distributed, add the PARTITION_INDEX
-        if _CheckIsDistributed():
-            target_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.PARTITION_INDEX)
-
-        auxiliary_solver_utilities.AddVariables(self.main_model_part, self.settings["auxiliary_variables_list"])
-
-        KratosMultiphysics.Logger.PrintInfo("::[ConvectionDiffusionSolver]:: ", "Variables ADDED")
-
-    def GetMinimumBufferSize(self):
-        return self.min_buffer_size
-
-    def AddDofs(self):
-        # Set DOFs and reaction variables list from Kratos parameters settings
-        dofs_with_reactions_list = []
-        conv_diff_vars = self.settings["convection_diffusion_variables"]
-        dof_var_name = conv_diff_vars["unknown_variable"].GetString()
-        reaction_var_name = conv_diff_vars["reaction_variable"].GetString()
-        dofs_with_reactions_list.append([dof_var_name,reaction_var_name])
-        if self.settings["gradient_dofs"].GetBool():
-            grad_dof_var_name = conv_diff_vars["gradient_variable"].GetString()
-            grad_react_var_name = conv_diff_vars["reaction_gradient_variable"].GetString()
-            comp_list = ["_X","_Y"] if self.settings["domain_size"].GetInt() == 2 else ["_X","_Y","_Z"]
-            for comp in comp_list:
-                dofs_with_reactions_list.append([grad_dof_var_name+comp,grad_react_var_name+comp])
-
-        # Add the DOFs and reaction list to each node
-        KratosMultiphysics.VariableUtils.AddDofsList(dofs_with_reactions_list, self.main_model_part)
-
-        KratosMultiphysics.Logger.PrintInfo("::[ConvectionDiffusionSolver]:: ", "DOF's ADDED")
-
-    def GetDofsList(self):
-        """This function creates and returns a list with the DOFs defined in the Kratos parameters settings
-        Note that element GetSpecifications method cannot be used in this case as DOF variables are a priori unknown
-        """
-
-        dofs_list = []
-        conv_diff_vars = self.settings["convection_diffusion_variables"]
-        dofs_list.append(conv_diff_vars["unknown_variable"].GetString())
-        if self.settings["gradient_dofs"].GetBool():
-            grad_dof_var_name = conv_diff_vars["gradient_variable"].GetString()
-            comp_list = ["_X","_Y"] if self.settings["domain_size"].GetInt() == 2 else ["_X","_Y","_Z"]
-            for comp in comp_list:
-                dofs_list.append(grad_dof_var_name + comp)
-
-        return dofs_list
-
-    def ImportModelPart(self):
-        """This function imports the ModelPart"""
-        if self.solver_imports_model_part:
-            if not _CheckIsDistributed():
-                self._ImportModelPart(self.main_model_part, self.settings["model_import_settings"])
-            else:
-                self.distributed_model_part_importer = distributed_import_model_part_utility.DistributedImportModelPartUtility(
-                    self.main_model_part,
-                    self.settings)
-                self.distributed_model_part_importer.ImportModelPart()
-
-    def PrepareModelPart(self):
-        assign_neighbour_elements = self.settings["assign_neighbour_elements_to_conditions"].GetBool()
-        if not self.is_restarted():
-            # Import material properties
-            materials_imported = self.import_materials()
-            if materials_imported:
-                KratosMultiphysics.Logger.PrintInfo("::[ConvectionDiffusionSolver]:: ", "Materials were successfully imported.")
-            else:
-                KratosMultiphysics.Logger.PrintInfo("::[ConvectionDiffusionSolver]:: ", "Materials were not imported.")
-
-            KratosMultiphysics.ReplaceElementsAndConditionsProcess(self.main_model_part,self._get_element_condition_replace_settings()).Execute()
-
-            tmoc = KratosMultiphysics.TetrahedralMeshOrientationCheck
-            throw_errors = False
-            flags = (tmoc.COMPUTE_NODAL_NORMALS).AsFalse() | (tmoc.COMPUTE_CONDITION_NORMALS).AsFalse()
-            if assign_neighbour_elements:
-                flags |= tmoc.ASSIGN_NEIGHBOUR_ELEMENTS_TO_CONDITIONS
-            else:
-                flags |= (tmoc.ASSIGN_NEIGHBOUR_ELEMENTS_TO_CONDITIONS).AsFalse()
-            tmoc(self.main_model_part,throw_errors, flags).Execute()
-
-            self._set_and_fill_buffer()
-
-        # Create the MPI communicators
-        if _CheckIsDistributed():
-            self.distributed_model_part_importer.CreateCommunicators()
-
-        if (self.settings["echo_level"].GetInt() > 0):
-            KratosMultiphysics.Logger.PrintInfo(self.model)
-
-        KratosMultiphysics.Logger.PrintInfo("::[ConvectionDiffusionSolver]::", "ModelPart prepared for Solver.")
-
-    def Initialize(self):
-        """Perform initialization after adding nodal variables and dofs to the main model part."""
-        KratosMultiphysics.Logger.PrintInfo("::[ConvectionDiffusionSolver]:: ", "Initializing ...")
-        # The convection_diffusion solution strategy is created here if it does not already exist.
-        if self.settings["clear_storage"].GetBool():
-            self.Clear()
-        convection_diffusion_solution_strategy = self._GetSolutionStrategy()
-        convection_diffusion_solution_strategy.SetEchoLevel(self.settings["echo_level"].GetInt())
-        if not self.is_restarted():
-            convection_diffusion_solution_strategy.Initialize()
-        else:
-            # SetInitializePerformedFlag is not a member of ImplicitSolvingStrategy but
-            # is used by ResidualBasedNewtonRaphsonStrategy.
-            try:
-                convection_diffusion_solution_strategy.SetInitializePerformedFlag(True)
-            except AttributeError:
-                pass
-        self.Check()
-        KratosMultiphysics.Logger.PrintInfo("::[ConvectionDiffusionSolver]:: ", "Finished initialization.")
-
-    def GetOutputVariables(self):
-        pass
-
-    def Solve(self):
-        if self.settings["clear_storage"].GetBool():
-            self.Clear()
-        convection_diffusion_solution_strategy = self._GetSolutionStrategy()
-        convection_diffusion_solution_strategy.Solve()
-
-    def InitializeSolutionStep(self):
-        self._GetSolutionStrategy().InitializeSolutionStep()
-
-    def Predict(self):
-        self._GetSolutionStrategy().Predict()
-
-    def SolveSolutionStep(self):
-        is_converged = self._GetSolutionStrategy().SolveSolutionStep()
-        return is_converged
-
-    def FinalizeSolutionStep(self):
-        self._GetSolutionStrategy().FinalizeSolutionStep()
-
-    def AdvanceInTime(self, current_time):
-        dt = self.ComputeDeltaTime()
-        new_time = current_time + dt
-        self.main_model_part.ProcessInfo[KratosMultiphysics.STEP] += 1
-        self.main_model_part.CloneTimeStep(new_time)
-
-        return new_time
-
-    def ComputeDeltaTime(self):
-        return self.settings["time_stepping"]["time_step"].GetDouble()
-
-    def GetComputingModelPart(self):
-        return self.main_model_part
-
-    def ExportModelPart(self):
-        name_out_file = self.settings["model_import_settings"]["input_filename"].GetString()+".out"
-        file = open(name_out_file + ".mdpa","w")
-        file.close()
-        KratosMultiphysics.ModelPartIO(name_out_file, KratosMultiphysics.IO.WRITE).WriteModelPart(self.main_model_part)
-
-    def SetEchoLevel(self, level):
-        self._GetSolutionStrategy().SetEchoLevel(level)
-
-    def Clear(self):
-        self._GetSolutionStrategy().Clear()
-
-    def Check(self):
-        self._GetSolutionStrategy().Check()
-
-    #### Specific internal functions ####
-
-    def _GetScheme(self):
-        if not hasattr(self, '_solution_scheme'):
-            self._solution_scheme = self._CreateScheme()
-        return self._solution_scheme
-
-    def _GetConvergenceCriterion(self):
-        if not hasattr(self, '_convergence_criterion'):
-            self._convergence_criterion = self._CreateConvergenceCriterion()
-        return self._convergence_criterion
-
-    def _GetLinearSolver(self):
-        if not hasattr(self, '_linear_solver'):
-            self._linear_solver = self._CreateLinearSolver()
-        return self._linear_solver
-
-    def _GetBuilderAndSolver(self):
-        if not hasattr(self, '_builder_and_solver'):
-            self._builder_and_solver = self._CreateBuilderAndSolver()
-        return self._builder_and_solver
-
-    def _GetSolutionStrategy(self):
-        if not hasattr(self, '_convection_diffusion_solution_strategy'):
-            self._convection_diffusion_solution_strategy = self._CreateSolutionStrategy()
-        return self._convection_diffusion_solution_strategy
-
-    def import_materials(self):
-        materials_filename = self.settings["material_import_settings"]["materials_filename"].GetString()
-        if (materials_filename != ""):
-            # Add constitutive laws and material properties from json file to model parts.
-            material_settings = KratosMultiphysics.Parameters("""{"Parameters": {"materials_filename": ""}} """)
-            material_settings["Parameters"]["materials_filename"].SetString(materials_filename)
-            KratosMultiphysics.ReadMaterialsUtility(material_settings, self.model)
-
-            # We set the properties that are nodal
-            self._assign_nodally_properties()
-            materials_imported = True
-        else:
-            materials_imported = False
-        return materials_imported
-
-    def is_restarted(self):
-        # this function avoids the long call to ProcessInfo and is also safer
-        # in case the detection of a restart is changed later
-        return self.main_model_part.ProcessInfo[KratosMultiphysics.IS_RESTARTED]
-
-    #### Private functions ####
-
-    def _assign_nodally_properties(self):
-
-        # We transfer the values of the con.diff variables to the nodes
-        with open(self.settings["material_import_settings"]["materials_filename"].GetString(), 'r') as parameter_file:
-            materials = KratosMultiphysics.Parameters(parameter_file.read())
-
-        for i in range(materials["properties"].size()):
-            model_part = self.model.GetModelPart(materials["properties"][i]["model_part_name"].GetString())
-            mat = materials["properties"][i]["Material"]
-
-            for key, value in mat["Variables"].items():
-                var = KratosMultiphysics.KratosGlobals.GetVariable(key)
-                if (self._check_variable_to_set(var)):
-                    if value.IsDouble():
-                        KratosMultiphysics.VariableUtils().SetVariable(var, value.GetDouble(), model_part.Nodes)
-                    elif value.IsVector():
-                        KratosMultiphysics.VariableUtils().SetVariable(var, value.GetVector(), model_part.Nodes)
-                    else:
-                        raise ValueError("Type of value is not available")
-
-    def _check_variable_to_set(self, var):
-        thermal_settings = self.main_model_part.ProcessInfo[KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS]
-        if (thermal_settings.IsDefinedDensityVariable()):
-            if (thermal_settings.GetDensityVariable() == var):
-                return True
-        if (thermal_settings.IsDefinedDiffusionVariable()):
-            if (thermal_settings.GetDiffusionVariable() == var):
-                return True
-        if (thermal_settings.IsDefinedVolumeSourceVariable()):
-            if (thermal_settings.GetVolumeSourceVariable() == var):
-                return True
-        if (thermal_settings.IsDefinedSurfaceSourceVariable()):
-            if (thermal_settings.GetSurfaceSourceVariable() == var):
-                return True
-        if (thermal_settings.IsDefinedProjectionVariable()):
-            if (thermal_settings.GetProjectionVariable() == var):
-                return True
-        if (thermal_settings.IsDefinedConvectionVariable()):
-            if (thermal_settings.GetConvectionVariable() == var):
-                return True
-        if thermal_settings.IsDefinedGradientVariable():
-            if thermal_settings.GetGradientVariable() == var:
-                return True
-        if (thermal_settings.IsDefinedTransferCoefficientVariable()):
-            if (thermal_settings.GetTransferCoefficientVariable() == var):
-                return True
-        if (thermal_settings.IsDefinedSpecificHeatVariable()):
-            if (thermal_settings.GetSpecificHeatVariable() == var):
-                return True
-        else:
-            return False
-
-    def _set_and_fill_buffer(self):
-        """Prepare nodal solution step data containers and time step information."""
-        # Set the buffer size for the nodal solution steps data. Existing nodal
-        # solution step data may be lost.
-        required_buffer_size = self.GetMinimumBufferSize()
-        current_buffer_size = self.main_model_part.GetBufferSize()
-        buffer_size = max(current_buffer_size, required_buffer_size)
-        self.main_model_part.SetBufferSize(buffer_size)
-        # Cycle the buffer. This sets all historical nodal solution step data to
-        # the current value and initializes the time stepping in the process info.
-        delta_time = self.main_model_part.ProcessInfo[KratosMultiphysics.DELTA_TIME]
-        time = self.main_model_part.ProcessInfo[KratosMultiphysics.TIME]
-        step =-buffer_size
-        time = time - delta_time * buffer_size
-        self.main_model_part.ProcessInfo.SetValue(KratosMultiphysics.TIME, time)
-        for _ in range(0, buffer_size):
-            step = step + 1
-            time = time + delta_time
-            self.main_model_part.ProcessInfo.SetValue(KratosMultiphysics.STEP, step)
-            self.main_model_part.CloneTimeStep(time)
-
-    def _get_element_condition_replace_settings(self):
-        ## Get and check domain size
-        domain_size = self.main_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE]
-        if domain_size not in [2,3]:
-            raise Exception("DOMAIN_SIZE is not set in ProcessInfo container.")
-
-        ## Validate the replace settings
-        default_replace_settings = self.GetDefaultParameters()["element_replace_settings"]
-        self.settings["element_replace_settings"].ValidateAndAssignDefaults(default_replace_settings)
-
-        ## Elements
-        ## Note that we check for the elements that require substitution to allow for custom elements
-        element_name = self.settings["element_replace_settings"]["element_name"].GetString()
-        element_list = ["EulerianConvDiff","LaplacianElement","MixedLaplacianElement","AdjointHeatDiffusionElement","QSConvectionDiffusionExplicit","DConvectionDiffusionExplicit","AxisymmetricEulerianConvectionDiffusion"]
-        if element_name in element_list:
-            num_nodes_elements = 0
-            if (len(self.main_model_part.Elements) > 0):
-                for elem in self.main_model_part.Elements:
-                    num_nodes_elements = len(elem.GetNodes())
-                    break
-
-            num_nodes_elements = self.main_model_part.GetCommunicator().GetDataCommunicator().MaxAll(num_nodes_elements)
-            if not num_nodes_elements:
-                num_nodes_elements = domain_size + 1
-
-            name_string = f"{element_name}{domain_size}D{num_nodes_elements}N"
-            self.settings["element_replace_settings"]["element_name"].SetString(name_string)
-
-        ## Conditions
-        condition_name = self.settings["element_replace_settings"]["condition_name"].GetString()
-        condition_list = ["FluxCondition","ThermalFace","AxisymmetricThermalFace","LineCondition","SurfaceCondition"]
-        if condition_name in condition_list:
-            num_nodes_conditions = 0
-            if (len(self.main_model_part.Conditions) > 0):
-                for cond in self.main_model_part.Conditions:
-                    num_nodes_conditions = len(cond.GetNodes())
-                    break
-
-            num_nodes_conditions = self.main_model_part.GetCommunicator().GetDataCommunicator().MaxAll(num_nodes_conditions)
-            if not num_nodes_conditions:
-                num_nodes_conditions = domain_size
-
-            name_string = f"{condition_name}{domain_size}D{num_nodes_conditions}N"
-            self.settings["element_replace_settings"]["condition_name"].SetString(name_string)
-
-        return self.settings["element_replace_settings"]
-
-    def _get_convergence_criterion_settings(self):
-        # Create an auxiliary Kratos parameters object to store the convergence settings.
-        conv_params = KratosMultiphysics.Parameters("{}")
-        conv_params.AddValue("convergence_criterion",self.settings["convergence_criterion"])
-        conv_params.AddValue("echo_level",self.settings["echo_level"])
-        conv_params.AddValue("solution_relative_tolerance",self.settings["solution_relative_tolerance"])
-        conv_params.AddValue("solution_absolute_tolerance",self.settings["solution_absolute_tolerance"])
-        conv_params.AddValue("residual_relative_tolerance",self.settings["residual_relative_tolerance"])
-        conv_params.AddValue("residual_absolute_tolerance",self.settings["residual_absolute_tolerance"])
-
-        return conv_params
-
-    def _CreateConvergenceCriterion(self):
-        if not self.main_model_part.IsDistributed():
-            convergence_criterion = convergence_criteria_factory.ConvergenceCriteriaFactory(self._get_convergence_criterion_settings())
-            return convergence_criterion.convergence_criterion
-        else:
-            convergence_criterion = self.__base_convergence_criteria_factory_mpi(self._get_convergence_criterion_settings())
-            return convergence_criterion
-
-    def _CreateLinearSolver(self):
-        linear_solver = linear_solver_factory.ConstructSolver(self.settings["linear_solver_settings"])
-        return linear_solver
-
-    def _CreateBuilderAndSolver(self):
-        linear_solver = self._GetLinearSolver()
-        if not self.main_model_part.IsDistributed():
-            # Set the serial builder and solver
-            if self.settings["block_builder"].GetBool():
-                builder_and_solver = KratosMultiphysics.ResidualBasedBlockBuilderAndSolver(linear_solver)
-            else:
-                builder_and_solver = KratosMultiphysics.ResidualBasedEliminationBuilderAndSolver(linear_solver)
-        else:
-            # Set the Epetra vectors communicator
-            epetra_communicator = self.get_epetra_communicator()
-
-            # Set the guess_row_size (guess about the number of zero entries) for the Trilinos builder and solver
-            domain_size = self.main_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE]
-            if domain_size == 3:
-                guess_row_size = 20
-            else:
-                guess_row_size = 10
-
-            # Set the parallel builder and solver
-            if self.settings["block_builder"].GetBool():
-                builder_and_solver = KratosTrilinos.TrilinosBlockBuilderAndSolver(
-                    epetra_communicator,
-                    guess_row_size,
-                    linear_solver)
-            else:
-                builder_and_solver = KratosTrilinos.TrilinosEliminationBuilderAndSolver(
-                    epetra_communicator,
-                    guess_row_size,
-                    linear_solver)
-
-        return builder_and_solver
-
-    @classmethod
-    def _CreateScheme(self):
-        """Create the solution scheme for the convection-diffusion problem."""
-        raise Exception("Solution Scheme creation must be implemented in the derived class.")
-
-    def _CreateSolutionStrategy(self):
-        analysis_type = self.settings["analysis_type"].GetString()
-        if analysis_type == "linear":
-            convection_diffusion_solution_strategy = self._create_linear_strategy()
-        elif analysis_type == "non_linear":
-            if(self.settings["line_search"].GetBool() == False):
-                convection_diffusion_solution_strategy = self._create_newton_raphson_strategy()
-            else:
-                convection_diffusion_solution_strategy = self._create_line_search_strategy()
-        else:
-            err_msg =  "The requested analysis type \"" + analysis_type + "\" is not available!\n"
-            err_msg += "Available options are: \"linear\", \"non_linear\""
-            raise Exception(err_msg)
-        return convection_diffusion_solution_strategy
-
-    def _create_linear_strategy(self):
-        computing_model_part = self.GetComputingModelPart()
-        convection_diffusion_scheme = self._GetScheme()
-        builder_and_solver = self._GetBuilderAndSolver()
-        if not computing_model_part.IsDistributed():
-            return KratosMultiphysics.ResidualBasedLinearStrategy(
-                computing_model_part,
-                convection_diffusion_scheme,
-                builder_and_solver,
-                self.settings["compute_reactions"].GetBool(),
-                self.settings["reform_dofs_at_each_step"].GetBool(),
-                False,
-                self.settings["move_mesh_flag"].GetBool())
-        else:
-            return KratosTrilinos.TrilinosLinearStrategy(
-                computing_model_part,
-                convection_diffusion_scheme,
-                builder_and_solver,
-                self.settings["compute_reactions"].GetBool(),
-                self.settings["reform_dofs_at_each_step"].GetBool(),
-                False,
-                self.settings["move_mesh_flag"].GetBool())
-
-    def _create_newton_raphson_strategy(self):
-        computing_model_part = self.GetComputingModelPart()
-        convection_diffusion_scheme = self._GetScheme()
-        convection_diffusion_convergence_criterion = self._GetConvergenceCriterion()
-        builder_and_solver = self._GetBuilderAndSolver()
-        if not computing_model_part.IsDistributed():
-            return KratosMultiphysics.ResidualBasedNewtonRaphsonStrategy(
-                computing_model_part,
-                convection_diffusion_scheme,
-                convection_diffusion_convergence_criterion,
-                builder_and_solver,
-                self.settings["max_iteration"].GetInt(),
-                self.settings["compute_reactions"].GetBool(),
-                self.settings["reform_dofs_at_each_step"].GetBool(),
-                self.settings["move_mesh_flag"].GetBool())
-        else:
-            return KratosTrilinos.TrilinosNewtonRaphsonStrategy(
-                computing_model_part,
-                convection_diffusion_scheme,
-                convection_diffusion_convergence_criterion,
-                builder_and_solver,
-                self.settings["max_iteration"].GetInt(),
-                self.settings["compute_reactions"].GetBool(),
-                self.settings["reform_dofs_at_each_step"].GetBool(),
-                self.settings["move_mesh_flag"].GetBool())
-
-    def _create_line_search_strategy(self):
-        computing_model_part = self.GetComputingModelPart()
-        convection_diffusion_scheme = self._GetScheme()
-        convection_diffusion_convergence_criterion = self._GetConvergenceCriterion()
-        builder_and_solver = self._GetBuilderAndSolver()
-        if not computing_model_part.IsDistributed():
-            return KratosMultiphysics.LineSearchStrategy(
-                computing_model_part,
-                convection_diffusion_scheme,
-                convection_diffusion_convergence_criterion,
-                builder_and_solver,
-                self.settings["max_iteration"].GetInt(),
-                self.settings["compute_reactions"].GetBool(),
-                self.settings["reform_dofs_at_each_step"].GetBool(),
-                self.settings["move_mesh_flag"].GetBool())
-        else:
-            err_msg = "\'line_search\' solution strategy is not MPI compatible."
-            raise Exception(err_msg)
-
-    def _ConvectionDiffusionVariablesCheck(self, custom_settings):
-        """This checks the user provided set of variables.
-        If there are no custom \'convection_diffusion_variables\', the default ones are taken.
-        If these are defined by the user, it checks one by one the provided values. If one is missing, it is taken form the defaults.
-        Note that this ensures that all the historical nodal variables to be used are defined in \'convection_diffusion_settings\' at construction time.
-        """
-
-        default_settings = self.GetDefaultParameters()
-        default_conv_diff_variables = default_settings["convection_diffusion_variables"]
-        if not custom_settings.Has("convection_diffusion_variables"):
-            KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "\'convection_diffusion_variables\' not defined, taking default ", default_conv_diff_variables)
-        else:
-            custom_conv_diff_variables = custom_settings["convection_diffusion_variables"]
-            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "density_variable", default_conv_diff_variables["density_variable"].GetString())
-            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "diffusion_variable", default_conv_diff_variables["diffusion_variable"].GetString())
-            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "unknown_variable", default_conv_diff_variables["unknown_variable"].GetString())
-            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "volume_source_variable", default_conv_diff_variables["volume_source_variable"].GetString())
-            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "surface_source_variable", default_conv_diff_variables["surface_source_variable"].GetString())
-            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "projection_variable", default_conv_diff_variables["projection_variable"].GetString())
-            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "convection_variable", default_conv_diff_variables["convection_variable"].GetString())
-            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "gradient_variable", default_conv_diff_variables["gradient_variable"].GetString())
-            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "mesh_velocity_variable", default_conv_diff_variables["mesh_velocity_variable"].GetString())
-            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "transfer_coefficient_variable", default_conv_diff_variables["transfer_coefficient_variable"].GetString())
-            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "velocity_variable", default_conv_diff_variables["velocity_variable"].GetString())
-            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "specific_heat_variable", default_conv_diff_variables["specific_heat_variable"].GetString())
-            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "reaction_variable", default_conv_diff_variables["reaction_variable"].GetString())
-            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "reaction_gradient_variable", default_conv_diff_variables["reaction_gradient_variable"].GetString())
-
-    def _ConvectionDiffusionSingleVariableCheck(self, custom_conv_diff_variables, variable_entry, variable_name):
-        if not custom_conv_diff_variables.Has(variable_entry):
-            custom_conv_diff_variables.AddEmptyValue(variable_entry).SetString(variable_name)
-            KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "\'{0}\' in \'convection_diffusion_variables\' not defined, taking default \'{1}\'.".format(variable_entry, variable_name))
-
-    #TODO: THIS MUST BE IMPLEMENTED IN A base_convergence_criteria_factory_mpi.py
-    #TODO: THEN WE CAN IMPORT IT AS convergence_criteria_factory TO AVOID DISTINGUISHING THE SERIAL AND THE PARALLEL FACTORIES
-    def __base_convergence_criteria_factory_mpi(self, convergence_criterion_parameters):
-        # Note that all the convergence settings are introduced via a Kratos parameters object.
-        D_RT = convergence_criterion_parameters["solution_relative_tolerance"].GetDouble()
-        D_AT = convergence_criterion_parameters["solution_absolute_tolerance"].GetDouble()
-        R_RT = convergence_criterion_parameters["residual_relative_tolerance"].GetDouble()
-        R_AT = convergence_criterion_parameters["residual_absolute_tolerance"].GetDouble()
-
-        echo_level = convergence_criterion_parameters["echo_level"].GetInt()
-        convergence_crit = convergence_criterion_parameters["convergence_criterion"].GetString()
-
-        if(echo_level >= 1):
-            KratosMultiphysics.Logger.PrintInfo("::[ConvergenceCriterionFactory]:: ", "CONVERGENCE CRITERION : " +
-                convergence_criterion_parameters["convergence_criterion"].GetString())
-
-        if(convergence_crit == "solution_criterion"):
-            convergence_criterion = KratosTrilinos.TrilinosDisplacementCriteria(D_RT, D_AT)
-            convergence_criterion.SetEchoLevel(echo_level)
-
-        elif(convergence_crit == "residual_criterion"):
-            convergence_criterion = KratosTrilinos.TrilinosResidualCriteria(R_RT, R_AT)
-            convergence_criterion.SetEchoLevel(echo_level)
-
-        elif(convergence_crit == "and_criterion"):
-            Displacement = KratosTrilinos.TrilinosDisplacementCriteria(D_RT, D_AT)
-            Displacement.SetEchoLevel(echo_level)
-            Residual = KratosTrilinos.TrilinosResidualCriteria(R_RT, R_AT)
-            Residual.SetEchoLevel(echo_level)
-            convergence_criterion = KratosTrilinos.TrilinosAndCriteria(Residual, Displacement)
-
-        elif(convergence_crit == "or_criterion"):
-            Displacement = KratosTrilinos.TrilinosDisplacementCriteria(D_RT, D_AT)
-            Displacement.SetEchoLevel(echo_level)
-            Residual = KratosTrilinos.TrilinosResidualCriteria(R_RT, R_AT)
-            Residual.SetEchoLevel(echo_level)
-            convergence_criterion = KratosTrilinos.TrilinosOrCriteria(Residual, Displacement)
-        else:
-            err_msg =  "The requested convergence criterion \"" + convergence_crit + "\" is not available!\n"
-            err_msg += "Available options are: \"solution_criterion\", \"residual_criterion\", \"and_criterion\", \"or_criterion\""
-            raise Exception(err_msg)
-
-        return convergence_criterion
-
-    def get_epetra_communicator(self):
-        if not hasattr(self, '_epetra_communicator'):
-            self._epetra_communicator = KratosTrilinos.CreateCommunicator()
-        return self._epetra_communicator
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Auxiliary function to check the parallel type at runtime
+#TODO: Delete this once we come up with the final factory-based design
+def _CheckIsDistributed():
+    if KratosMultiphysics.ParallelEnvironment.HasDataCommunicator("World"):
+        world_data_comm = KratosMultiphysics.ParallelEnvironment.GetDataCommunicator("World")
+        return world_data_comm.IsDistributed()
+    else:
+        return False
+
+# Import applications
+import KratosMultiphysics.ConvectionDiffusionApplication
+
+# If required, import parallel applications and modules
+if _CheckIsDistributed():
+    import KratosMultiphysics.mpi as KratosMPI
+    import KratosMultiphysics.MetisApplication as KratosMetis
+    import KratosMultiphysics.TrilinosApplication as KratosTrilinos
+    import KratosMultiphysics.mpi.distributed_import_model_part_utility as distributed_import_model_part_utility
+
+# Importing factories
+if _CheckIsDistributed():
+    import KratosMultiphysics.TrilinosApplication.trilinos_linear_solver_factory as linear_solver_factory
+else:
+    import KratosMultiphysics.python_linear_solver_factory as linear_solver_factory
+    import KratosMultiphysics.base_convergence_criteria_factory as convergence_criteria_factory
+
+# Importing the base class
+from KratosMultiphysics.python_solver import PythonSolver
+from KratosMultiphysics import auxiliary_solver_utilities
+
+def CreateSolver(model, custom_settings):
+    return ConvectionDiffusionSolver(model, custom_settings)
+
+class ConvectionDiffusionSolver(PythonSolver):
+    """The base class for convection-diffusion solvers.
+
+    This class provides functions for importing and exporting models,
+    adding nodal variables and dofs and solving each solution step.
+
+    Derived classes must override the function _CreateScheme which
+    constructs and returns a solution scheme. Depending on the type of
+    solver, derived classes may also need to override the following functions:
+
+    _CreateScheme
+    _CreateConvergenceCriterion
+    _CreateLinearSolver
+    _CreateBuilderAndSolver
+    _CreateSolutionStrategy
+
+    The convection_diffusion_solution_strategy, builder_and_solver, etc. should alway be retrieved
+    using the getter functions _GetSolutionStrategy, get_builder_and_solver,
+    etc. from this base class.
+
+    Only the member variables listed below should be accessed directly.
+
+    Public member variables:
+    model -- the model containing the modelpart used to construct the solver.
+    settings -- Kratos parameters containing solver settings.
+    """
+
+    def __init__(self, model, custom_settings):
+        super().__init__(model, custom_settings)
+
+        # Convection diffusion variables check
+        self._ConvectionDiffusionVariablesCheck(custom_settings)
+
+        model_part_name = self.settings["model_part_name"].GetString()
+
+        # Set default buffer size
+        self.min_buffer_size = 1
+
+        if model_part_name == "":
+            raise Exception('Please specify a model_part name!')
+
+        # This will be changed once the Model is fully supported!
+        if self.model.HasModelPart(model_part_name):
+            self.main_model_part = self.model[model_part_name]
+            self.solver_imports_model_part = False
+        else:
+            self.main_model_part = self.model.CreateModelPart(model_part_name) # Model.CreateodelPart()
+            domain_size = self.settings["domain_size"].GetInt()
+            if domain_size < 0:
+                raise Exception('Please specify a "domain_size" >= 0!')
+            self.main_model_part.ProcessInfo.SetValue(KratosMultiphysics.DOMAIN_SIZE, domain_size)
+            self.solver_imports_model_part = True
+
+        KratosMultiphysics.Logger.PrintInfo("::[ConvectionDiffusionSolver]:: ", "Construction finished")
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        default_settings = KratosMultiphysics.Parameters("""
+        {
+            "model_part_name" : "ThermalModelPart",
+            "domain_size" : -1,
+            "echo_level": 0,
+            "analysis_type": "linear",
+            "solver_type": "convection_diffusion_solver",
+            "model_import_settings": {
+                "input_type": "mdpa",
+                "input_filename": "unknown_name"
+            },
+            "material_import_settings" :{
+                "materials_filename": ""
+            },
+            "convection_diffusion_variables" : {
+                "density_variable"              : "DENSITY",
+                "diffusion_variable"            : "CONDUCTIVITY",
+                "unknown_variable"              : "TEMPERATURE",
+                "volume_source_variable"        : "HEAT_FLUX",
+                "surface_source_variable"       : "FACE_HEAT_FLUX",
+                "projection_variable"           : "PROJECTED_SCALAR1",
+                "convection_variable"           : "CONVECTION_VELOCITY",
+                "gradient_variable"             : "TEMPERATURE_GRADIENT",
+                "mesh_velocity_variable"        : "MESH_VELOCITY",
+                "transfer_coefficient_variable" : "TRANSFER_COEFFICIENT",
+                "velocity_variable"             : "VELOCITY",
+                "specific_heat_variable"        : "SPECIFIC_HEAT",
+                "reaction_variable"             : "REACTION_FLUX",
+                "reaction_gradient_variable"    : "REACTION"
+            },
+            "time_stepping" : {
+                "time_step": 1.0
+            },
+            "reform_dofs_at_each_step": false,
+            "gradient_dofs" : false,
+            "line_search": false,
+            "compute_reactions": true,
+            "block_builder": true,
+            "clear_storage": false,
+            "move_mesh_flag": false,
+            "convergence_criterion": "residual_criterion",
+            "solution_relative_tolerance": 1.0e-4,
+            "solution_absolute_tolerance": 1.0e-9,
+            "residual_relative_tolerance": 1.0e-4,
+            "residual_absolute_tolerance": 1.0e-9,
+            "max_iteration": 10,
+            "linear_solver_settings":{
+                "solver_type": "amgcl",
+                "smoother_type":"ilu0",
+                "krylov_type":"gmres",
+                "coarsening_type":"aggregation",
+                "max_iteration": 5000,
+                "tolerance": 1e-9,
+                "scaling": false
+            },
+            "element_replace_settings" : {
+                "element_name" : "EulerianConvDiff",
+                "condition_name" : "ThermalFace"
+            },
+            "problem_domain_sub_model_part_list": [""],
+            "processes_sub_model_part_list": [""],
+            "auxiliary_variables_list" : [],
+            "assign_neighbour_elements_to_conditions" : true
+        }
+        """)
+        default_settings.AddMissingParameters(super().GetDefaultParameters())
+        return default_settings
+
+    def AddVariables(self, target_model_part=None):
+
+        if target_model_part == None:
+            target_model_part = self.main_model_part
+
+        ''' Add nodal solution step variables based on provided CONVECTION_DIFFUSION_SETTINGS
+        '''
+        convention_diffusion_settings = KratosMultiphysics.ConvectionDiffusionSettings()
+        density_variable = self.settings["convection_diffusion_variables"]["density_variable"].GetString()
+        if (density_variable != ""):
+            convention_diffusion_settings.SetDensityVariable(KratosMultiphysics.KratosGlobals.GetVariable(density_variable))
+        diffusion_variable = self.settings["convection_diffusion_variables"]["diffusion_variable"].GetString()
+        if (diffusion_variable != ""):
+            convention_diffusion_settings.SetDiffusionVariable(KratosMultiphysics.KratosGlobals.GetVariable(diffusion_variable))
+        unknown_variable = self.settings["convection_diffusion_variables"]["unknown_variable"].GetString()
+        if (unknown_variable != ""):
+            convention_diffusion_settings.SetUnknownVariable(KratosMultiphysics.KratosGlobals.GetVariable(unknown_variable))
+        volume_source_variable = self.settings["convection_diffusion_variables"]["volume_source_variable"].GetString()
+        if (volume_source_variable != ""):
+            convention_diffusion_settings.SetVolumeSourceVariable(KratosMultiphysics.KratosGlobals.GetVariable(volume_source_variable))
+        surface_source_variable = self.settings["convection_diffusion_variables"]["surface_source_variable"].GetString()
+        if (surface_source_variable != ""):
+            convention_diffusion_settings.SetSurfaceSourceVariable(KratosMultiphysics.KratosGlobals.GetVariable(surface_source_variable))
+        projection_variable = self.settings["convection_diffusion_variables"]["projection_variable"].GetString()
+        if (projection_variable != ""):
+            convention_diffusion_settings.SetProjectionVariable(KratosMultiphysics.KratosGlobals.GetVariable(projection_variable))
+        convection_variable = self.settings["convection_diffusion_variables"]["convection_variable"].GetString()
+        if (convection_variable != ""):
+            convention_diffusion_settings.SetConvectionVariable(KratosMultiphysics.KratosGlobals.GetVariable(convection_variable))
+        gradient_variable = self.settings["convection_diffusion_variables"]["gradient_variable"].GetString()
+        if gradient_variable != "":
+            convention_diffusion_settings.SetGradientVariable(KratosMultiphysics.KratosGlobals.GetVariable(gradient_variable))
+        mesh_velocity_variable = self.settings["convection_diffusion_variables"]["mesh_velocity_variable"].GetString()
+        if (mesh_velocity_variable != ""):
+            convention_diffusion_settings.SetMeshVelocityVariable(KratosMultiphysics.KratosGlobals.GetVariable(mesh_velocity_variable))
+        transfer_coefficient_variable = self.settings["convection_diffusion_variables"]["transfer_coefficient_variable"].GetString()
+        if (transfer_coefficient_variable != ""):
+            convention_diffusion_settings.SetTransferCoefficientVariable(KratosMultiphysics.KratosGlobals.GetVariable(transfer_coefficient_variable))
+        velocity_variable = self.settings["convection_diffusion_variables"]["velocity_variable"].GetString()
+        if (velocity_variable != ""):
+            convention_diffusion_settings.SetVelocityVariable(KratosMultiphysics.KratosGlobals.GetVariable(velocity_variable))
+        specific_heat_variable = self.settings["convection_diffusion_variables"]["specific_heat_variable"].GetString()
+        if (specific_heat_variable != ""):
+            convention_diffusion_settings.SetSpecificHeatVariable(KratosMultiphysics.KratosGlobals.GetVariable(specific_heat_variable))
+        reaction_variable = self.settings["convection_diffusion_variables"]["reaction_variable"].GetString()
+        if (reaction_variable != ""):
+            convention_diffusion_settings.SetReactionVariable(KratosMultiphysics.KratosGlobals.GetVariable(reaction_variable))
+        reaction_gradient_variable = self.settings["convection_diffusion_variables"]["reaction_gradient_variable"].GetString()
+        if (reaction_gradient_variable != ""):
+            convention_diffusion_settings.SetReactionGradientVariable(KratosMultiphysics.KratosGlobals.GetVariable(reaction_gradient_variable))
+
+        target_model_part.ProcessInfo.SetValue(KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS, convention_diffusion_settings)
+
+        if target_model_part.ProcessInfo.Has(KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS):
+            if convention_diffusion_settings.IsDefinedDensityVariable():
+                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetDensityVariable())
+            if convention_diffusion_settings.IsDefinedDiffusionVariable():
+                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetDiffusionVariable())
+            if convention_diffusion_settings.IsDefinedUnknownVariable():
+                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetUnknownVariable())
+            if convention_diffusion_settings.IsDefinedVolumeSourceVariable():
+                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetVolumeSourceVariable())
+            if convention_diffusion_settings.IsDefinedSurfaceSourceVariable():
+                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetSurfaceSourceVariable())
+            if convention_diffusion_settings.IsDefinedProjectionVariable():
+                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetProjectionVariable())
+            if convention_diffusion_settings.IsDefinedConvectionVariable():
+                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetConvectionVariable())
+            if convention_diffusion_settings.IsDefinedGradientVariable():
+                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetGradientVariable())
+            if convention_diffusion_settings.IsDefinedMeshVelocityVariable():
+                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetMeshVelocityVariable())
+            if convention_diffusion_settings.IsDefinedTransferCoefficientVariable():
+                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetTransferCoefficientVariable())
+            if convention_diffusion_settings.IsDefinedVelocityVariable():
+                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetVelocityVariable())
+            if convention_diffusion_settings.IsDefinedSpecificHeatVariable():
+                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetSpecificHeatVariable())
+            if convention_diffusion_settings.IsDefinedReactionVariable():
+                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetReactionVariable())
+            if convention_diffusion_settings.IsDefinedReactionGradientVariable():
+                target_model_part.AddNodalSolutionStepVariable(convention_diffusion_settings.GetReactionGradientVariable())
+        else:
+            raise Exception("The provided target_model_part does not have CONVECTION_DIFFUSION_SETTINGS defined.")
+
+        # Adding nodal area variable (some solvers use it. TODO: Ask)
+        #target_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.NODAL_AREA)
+        # If LaplacianElement is used
+        if (self.settings["element_replace_settings"]["element_name"].GetString() == "LaplacianElement"):
+            target_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.NORMAL)
+
+        # If MPI distributed, add the PARTITION_INDEX
+        if _CheckIsDistributed():
+            target_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.PARTITION_INDEX)
+
+        auxiliary_solver_utilities.AddVariables(self.main_model_part, self.settings["auxiliary_variables_list"])
+
+        KratosMultiphysics.Logger.PrintInfo("::[ConvectionDiffusionSolver]:: ", "Variables ADDED")
+
+    def GetMinimumBufferSize(self):
+        return self.min_buffer_size
+
+    def AddDofs(self):
+        # Set DOFs and reaction variables list from Kratos parameters settings
+        dofs_with_reactions_list = []
+        conv_diff_vars = self.settings["convection_diffusion_variables"]
+        dof_var_name = conv_diff_vars["unknown_variable"].GetString()
+        reaction_var_name = conv_diff_vars["reaction_variable"].GetString()
+        dofs_with_reactions_list.append([dof_var_name,reaction_var_name])
+        if self.settings["gradient_dofs"].GetBool():
+            grad_dof_var_name = conv_diff_vars["gradient_variable"].GetString()
+            grad_react_var_name = conv_diff_vars["reaction_gradient_variable"].GetString()
+            comp_list = ["_X","_Y"] if self.settings["domain_size"].GetInt() == 2 else ["_X","_Y","_Z"]
+            for comp in comp_list:
+                dofs_with_reactions_list.append([grad_dof_var_name+comp,grad_react_var_name+comp])
+
+        # Add the DOFs and reaction list to each node
+        KratosMultiphysics.VariableUtils.AddDofsList(dofs_with_reactions_list, self.main_model_part)
+
+        KratosMultiphysics.Logger.PrintInfo("::[ConvectionDiffusionSolver]:: ", "DOF's ADDED")
+
+    def GetDofsList(self):
+        """This function creates and returns a list with the DOFs defined in the Kratos parameters settings
+        Note that element GetSpecifications method cannot be used in this case as DOF variables are a priori unknown
+        """
+
+        dofs_list = []
+        conv_diff_vars = self.settings["convection_diffusion_variables"]
+        dofs_list.append(conv_diff_vars["unknown_variable"].GetString())
+        if self.settings["gradient_dofs"].GetBool():
+            grad_dof_var_name = conv_diff_vars["gradient_variable"].GetString()
+            comp_list = ["_X","_Y"] if self.settings["domain_size"].GetInt() == 2 else ["_X","_Y","_Z"]
+            for comp in comp_list:
+                dofs_list.append(grad_dof_var_name + comp)
+
+        return dofs_list
+
+    def ImportModelPart(self):
+        """This function imports the ModelPart"""
+        if self.solver_imports_model_part:
+            if not _CheckIsDistributed():
+                self._ImportModelPart(self.main_model_part, self.settings["model_import_settings"])
+            else:
+                self.distributed_model_part_importer = distributed_import_model_part_utility.DistributedImportModelPartUtility(
+                    self.main_model_part,
+                    self.settings)
+                self.distributed_model_part_importer.ImportModelPart()
+
+    def PrepareModelPart(self):
+        assign_neighbour_elements = self.settings["assign_neighbour_elements_to_conditions"].GetBool()
+        if not self.is_restarted():
+            # Import material properties
+            materials_imported = self.import_materials()
+            if materials_imported:
+                KratosMultiphysics.Logger.PrintInfo("::[ConvectionDiffusionSolver]:: ", "Materials were successfully imported.")
+            else:
+                KratosMultiphysics.Logger.PrintInfo("::[ConvectionDiffusionSolver]:: ", "Materials were not imported.")
+
+            KratosMultiphysics.ReplaceElementsAndConditionsProcess(self.main_model_part,self._get_element_condition_replace_settings()).Execute()
+
+            tmoc = KratosMultiphysics.TetrahedralMeshOrientationCheck
+            throw_errors = False
+            flags = (tmoc.COMPUTE_NODAL_NORMALS).AsFalse() | (tmoc.COMPUTE_CONDITION_NORMALS).AsFalse()
+            if assign_neighbour_elements:
+                flags |= tmoc.ASSIGN_NEIGHBOUR_ELEMENTS_TO_CONDITIONS
+            else:
+                flags |= (tmoc.ASSIGN_NEIGHBOUR_ELEMENTS_TO_CONDITIONS).AsFalse()
+            tmoc(self.main_model_part,throw_errors, flags).Execute()
+
+            self._set_and_fill_buffer()
+
+        # Create the MPI communicators
+        if _CheckIsDistributed():
+            self.distributed_model_part_importer.CreateCommunicators()
+
+        if (self.settings["echo_level"].GetInt() > 0):
+            KratosMultiphysics.Logger.PrintInfo(self.model)
+
+        KratosMultiphysics.Logger.PrintInfo("::[ConvectionDiffusionSolver]::", "ModelPart prepared for Solver.")
+
+    def Initialize(self):
+        """Perform initialization after adding nodal variables and dofs to the main model part."""
+        KratosMultiphysics.Logger.PrintInfo("::[ConvectionDiffusionSolver]:: ", "Initializing ...")
+        # The convection_diffusion solution strategy is created here if it does not already exist.
+        if self.settings["clear_storage"].GetBool():
+            self.Clear()
+        convection_diffusion_solution_strategy = self._GetSolutionStrategy()
+        convection_diffusion_solution_strategy.SetEchoLevel(self.settings["echo_level"].GetInt())
+        if not self.is_restarted():
+            convection_diffusion_solution_strategy.Initialize()
+        else:
+            # SetInitializePerformedFlag is not a member of ImplicitSolvingStrategy but
+            # is used by ResidualBasedNewtonRaphsonStrategy.
+            try:
+                convection_diffusion_solution_strategy.SetInitializePerformedFlag(True)
+            except AttributeError:
+                pass
+        self.Check()
+        KratosMultiphysics.Logger.PrintInfo("::[ConvectionDiffusionSolver]:: ", "Finished initialization.")
+
+    def GetOutputVariables(self):
+        pass
+
+    def Solve(self):
+        if self.settings["clear_storage"].GetBool():
+            self.Clear()
+        convection_diffusion_solution_strategy = self._GetSolutionStrategy()
+        convection_diffusion_solution_strategy.Solve()
+
+    def InitializeSolutionStep(self):
+        self._GetSolutionStrategy().InitializeSolutionStep()
+
+    def Predict(self):
+        self._GetSolutionStrategy().Predict()
+
+    def SolveSolutionStep(self):
+        is_converged = self._GetSolutionStrategy().SolveSolutionStep()
+        return is_converged
+
+    def FinalizeSolutionStep(self):
+        self._GetSolutionStrategy().FinalizeSolutionStep()
+
+    def AdvanceInTime(self, current_time):
+        dt = self.ComputeDeltaTime()
+        new_time = current_time + dt
+        self.main_model_part.ProcessInfo[KratosMultiphysics.STEP] += 1
+        self.main_model_part.CloneTimeStep(new_time)
+
+        return new_time
+
+    def ComputeDeltaTime(self):
+        return self.settings["time_stepping"]["time_step"].GetDouble()
+
+    def GetComputingModelPart(self):
+        return self.main_model_part
+
+    def ExportModelPart(self):
+        name_out_file = self.settings["model_import_settings"]["input_filename"].GetString()+".out"
+        file = open(name_out_file + ".mdpa","w")
+        file.close()
+        KratosMultiphysics.ModelPartIO(name_out_file, KratosMultiphysics.IO.WRITE).WriteModelPart(self.main_model_part)
+
+    def SetEchoLevel(self, level):
+        self._GetSolutionStrategy().SetEchoLevel(level)
+
+    def Clear(self):
+        self._GetSolutionStrategy().Clear()
+
+    def Check(self):
+        self._GetSolutionStrategy().Check()
+
+    #### Specific internal functions ####
+
+    def _GetScheme(self):
+        if not hasattr(self, '_solution_scheme'):
+            self._solution_scheme = self._CreateScheme()
+        return self._solution_scheme
+
+    def _GetConvergenceCriterion(self):
+        if not hasattr(self, '_convergence_criterion'):
+            self._convergence_criterion = self._CreateConvergenceCriterion()
+        return self._convergence_criterion
+
+    def _GetLinearSolver(self):
+        if not hasattr(self, '_linear_solver'):
+            self._linear_solver = self._CreateLinearSolver()
+        return self._linear_solver
+
+    def _GetBuilderAndSolver(self):
+        if not hasattr(self, '_builder_and_solver'):
+            self._builder_and_solver = self._CreateBuilderAndSolver()
+        return self._builder_and_solver
+
+    def _GetSolutionStrategy(self):
+        if not hasattr(self, '_convection_diffusion_solution_strategy'):
+            self._convection_diffusion_solution_strategy = self._CreateSolutionStrategy()
+        return self._convection_diffusion_solution_strategy
+
+    def import_materials(self):
+        materials_filename = self.settings["material_import_settings"]["materials_filename"].GetString()
+        if (materials_filename != ""):
+            # Add constitutive laws and material properties from json file to model parts.
+            material_settings = KratosMultiphysics.Parameters("""{"Parameters": {"materials_filename": ""}} """)
+            material_settings["Parameters"]["materials_filename"].SetString(materials_filename)
+            KratosMultiphysics.ReadMaterialsUtility(material_settings, self.model)
+
+            # We set the properties that are nodal
+            self._assign_nodally_properties()
+            materials_imported = True
+        else:
+            materials_imported = False
+        return materials_imported
+
+    def is_restarted(self):
+        # this function avoids the long call to ProcessInfo and is also safer
+        # in case the detection of a restart is changed later
+        return self.main_model_part.ProcessInfo[KratosMultiphysics.IS_RESTARTED]
+
+    #### Private functions ####
+
+    def _assign_nodally_properties(self):
+
+        # We transfer the values of the con.diff variables to the nodes
+        with open(self.settings["material_import_settings"]["materials_filename"].GetString(), 'r') as parameter_file:
+            materials = KratosMultiphysics.Parameters(parameter_file.read())
+
+        for i in range(materials["properties"].size()):
+            model_part = self.model.GetModelPart(materials["properties"][i]["model_part_name"].GetString())
+            mat = materials["properties"][i]["Material"]
+
+            for key, value in mat["Variables"].items():
+                var = KratosMultiphysics.KratosGlobals.GetVariable(key)
+                if (self._check_variable_to_set(var)):
+                    if value.IsDouble():
+                        KratosMultiphysics.VariableUtils().SetVariable(var, value.GetDouble(), model_part.Nodes)
+                    elif value.IsVector():
+                        KratosMultiphysics.VariableUtils().SetVariable(var, value.GetVector(), model_part.Nodes)
+                    else:
+                        raise ValueError("Type of value is not available")
+
+    def _check_variable_to_set(self, var):
+        thermal_settings = self.main_model_part.ProcessInfo[KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS]
+        if (thermal_settings.IsDefinedDensityVariable()):
+            if (thermal_settings.GetDensityVariable() == var):
+                return True
+        if (thermal_settings.IsDefinedDiffusionVariable()):
+            if (thermal_settings.GetDiffusionVariable() == var):
+                return True
+        if (thermal_settings.IsDefinedVolumeSourceVariable()):
+            if (thermal_settings.GetVolumeSourceVariable() == var):
+                return True
+        if (thermal_settings.IsDefinedSurfaceSourceVariable()):
+            if (thermal_settings.GetSurfaceSourceVariable() == var):
+                return True
+        if (thermal_settings.IsDefinedProjectionVariable()):
+            if (thermal_settings.GetProjectionVariable() == var):
+                return True
+        if (thermal_settings.IsDefinedConvectionVariable()):
+            if (thermal_settings.GetConvectionVariable() == var):
+                return True
+        if thermal_settings.IsDefinedGradientVariable():
+            if thermal_settings.GetGradientVariable() == var:
+                return True
+        if (thermal_settings.IsDefinedTransferCoefficientVariable()):
+            if (thermal_settings.GetTransferCoefficientVariable() == var):
+                return True
+        if (thermal_settings.IsDefinedSpecificHeatVariable()):
+            if (thermal_settings.GetSpecificHeatVariable() == var):
+                return True
+        else:
+            return False
+
+    def _set_and_fill_buffer(self):
+        """Prepare nodal solution step data containers and time step information."""
+        # Set the buffer size for the nodal solution steps data. Existing nodal
+        # solution step data may be lost.
+        required_buffer_size = self.GetMinimumBufferSize()
+        current_buffer_size = self.main_model_part.GetBufferSize()
+        buffer_size = max(current_buffer_size, required_buffer_size)
+        self.main_model_part.SetBufferSize(buffer_size)
+        # Cycle the buffer. This sets all historical nodal solution step data to
+        # the current value and initializes the time stepping in the process info.
+        delta_time = self.main_model_part.ProcessInfo[KratosMultiphysics.DELTA_TIME]
+        time = self.main_model_part.ProcessInfo[KratosMultiphysics.TIME]
+        step =-buffer_size
+        time = time - delta_time * buffer_size
+        self.main_model_part.ProcessInfo.SetValue(KratosMultiphysics.TIME, time)
+        for _ in range(0, buffer_size):
+            step = step + 1
+            time = time + delta_time
+            self.main_model_part.ProcessInfo.SetValue(KratosMultiphysics.STEP, step)
+            self.main_model_part.CloneTimeStep(time)
+
+    def _get_element_condition_replace_settings(self):
+        ## Get and check domain size
+        domain_size = self.main_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE]
+        if domain_size not in [2,3]:
+            raise Exception("DOMAIN_SIZE is not set in ProcessInfo container.")
+
+        ## Validate the replace settings
+        default_replace_settings = self.GetDefaultParameters()["element_replace_settings"]
+        self.settings["element_replace_settings"].ValidateAndAssignDefaults(default_replace_settings)
+
+        ## Elements
+        ## Note that we check for the elements that require substitution to allow for custom elements
+        element_name = self.settings["element_replace_settings"]["element_name"].GetString()
+        element_list = ["EulerianConvDiff","LaplacianElement","MixedLaplacianElement","AdjointHeatDiffusionElement","QSConvectionDiffusionExplicit","DConvectionDiffusionExplicit","AxisymmetricEulerianConvectionDiffusion"]
+        if element_name in element_list:
+            num_nodes_elements = 0
+            if (len(self.main_model_part.Elements) > 0):
+                for elem in self.main_model_part.Elements:
+                    num_nodes_elements = len(elem.GetNodes())
+                    break
+
+            num_nodes_elements = self.main_model_part.GetCommunicator().GetDataCommunicator().MaxAll(num_nodes_elements)
+            if not num_nodes_elements:
+                num_nodes_elements = domain_size + 1
+
+            name_string = f"{element_name}{domain_size}D{num_nodes_elements}N"
+            self.settings["element_replace_settings"]["element_name"].SetString(name_string)
+
+        ## Conditions
+        condition_name = self.settings["element_replace_settings"]["condition_name"].GetString()
+        condition_list = ["FluxCondition","ThermalFace","AxisymmetricThermalFace","LineCondition","SurfaceCondition"]
+        if condition_name in condition_list:
+            num_nodes_conditions = 0
+            if (len(self.main_model_part.Conditions) > 0):
+                for cond in self.main_model_part.Conditions:
+                    num_nodes_conditions = len(cond.GetNodes())
+                    break
+
+            num_nodes_conditions = self.main_model_part.GetCommunicator().GetDataCommunicator().MaxAll(num_nodes_conditions)
+            if not num_nodes_conditions:
+                num_nodes_conditions = domain_size
+
+            name_string = f"{condition_name}{domain_size}D{num_nodes_conditions}N"
+            self.settings["element_replace_settings"]["condition_name"].SetString(name_string)
+
+        return self.settings["element_replace_settings"]
+
+    def _get_convergence_criterion_settings(self):
+        # Create an auxiliary Kratos parameters object to store the convergence settings.
+        conv_params = KratosMultiphysics.Parameters("{}")
+        conv_params.AddValue("convergence_criterion",self.settings["convergence_criterion"])
+        conv_params.AddValue("echo_level",self.settings["echo_level"])
+        conv_params.AddValue("solution_relative_tolerance",self.settings["solution_relative_tolerance"])
+        conv_params.AddValue("solution_absolute_tolerance",self.settings["solution_absolute_tolerance"])
+        conv_params.AddValue("residual_relative_tolerance",self.settings["residual_relative_tolerance"])
+        conv_params.AddValue("residual_absolute_tolerance",self.settings["residual_absolute_tolerance"])
+
+        return conv_params
+
+    def _CreateConvergenceCriterion(self):
+        if not self.main_model_part.IsDistributed():
+            convergence_criterion = convergence_criteria_factory.ConvergenceCriteriaFactory(self._get_convergence_criterion_settings())
+            return convergence_criterion.convergence_criterion
+        else:
+            convergence_criterion = self.__base_convergence_criteria_factory_mpi(self._get_convergence_criterion_settings())
+            return convergence_criterion
+
+    def _CreateLinearSolver(self):
+        linear_solver = linear_solver_factory.ConstructSolver(self.settings["linear_solver_settings"])
+        return linear_solver
+
+    def _CreateBuilderAndSolver(self):
+        linear_solver = self._GetLinearSolver()
+        if not self.main_model_part.IsDistributed():
+            # Set the serial builder and solver
+            if self.settings["block_builder"].GetBool():
+                builder_and_solver = KratosMultiphysics.ResidualBasedBlockBuilderAndSolver(linear_solver)
+            else:
+                builder_and_solver = KratosMultiphysics.ResidualBasedEliminationBuilderAndSolver(linear_solver)
+        else:
+            # Set the Epetra vectors communicator
+            epetra_communicator = self.get_epetra_communicator()
+
+            # Set the guess_row_size (guess about the number of zero entries) for the Trilinos builder and solver
+            domain_size = self.main_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE]
+            if domain_size == 3:
+                guess_row_size = 20
+            else:
+                guess_row_size = 10
+
+            # Set the parallel builder and solver
+            if self.settings["block_builder"].GetBool():
+                builder_and_solver = KratosTrilinos.TrilinosBlockBuilderAndSolver(
+                    epetra_communicator,
+                    guess_row_size,
+                    linear_solver)
+            else:
+                builder_and_solver = KratosTrilinos.TrilinosEliminationBuilderAndSolver(
+                    epetra_communicator,
+                    guess_row_size,
+                    linear_solver)
+
+        return builder_and_solver
+
+    @classmethod
+    def _CreateScheme(self):
+        """Create the solution scheme for the convection-diffusion problem."""
+        raise Exception("Solution Scheme creation must be implemented in the derived class.")
+
+    def _CreateSolutionStrategy(self):
+        analysis_type = self.settings["analysis_type"].GetString()
+        if analysis_type == "linear":
+            convection_diffusion_solution_strategy = self._create_linear_strategy()
+        elif analysis_type == "non_linear":
+            if(self.settings["line_search"].GetBool() == False):
+                convection_diffusion_solution_strategy = self._create_newton_raphson_strategy()
+            else:
+                convection_diffusion_solution_strategy = self._create_line_search_strategy()
+        else:
+            err_msg =  "The requested analysis type \"" + analysis_type + "\" is not available!\n"
+            err_msg += "Available options are: \"linear\", \"non_linear\""
+            raise Exception(err_msg)
+        return convection_diffusion_solution_strategy
+
+    def _create_linear_strategy(self):
+        computing_model_part = self.GetComputingModelPart()
+        convection_diffusion_scheme = self._GetScheme()
+        builder_and_solver = self._GetBuilderAndSolver()
+        if not computing_model_part.IsDistributed():
+            return KratosMultiphysics.ResidualBasedLinearStrategy(
+                computing_model_part,
+                convection_diffusion_scheme,
+                builder_and_solver,
+                self.settings["compute_reactions"].GetBool(),
+                self.settings["reform_dofs_at_each_step"].GetBool(),
+                False,
+                self.settings["move_mesh_flag"].GetBool())
+        else:
+            return KratosTrilinos.TrilinosLinearStrategy(
+                computing_model_part,
+                convection_diffusion_scheme,
+                builder_and_solver,
+                self.settings["compute_reactions"].GetBool(),
+                self.settings["reform_dofs_at_each_step"].GetBool(),
+                False,
+                self.settings["move_mesh_flag"].GetBool())
+
+    def _create_newton_raphson_strategy(self):
+        computing_model_part = self.GetComputingModelPart()
+        convection_diffusion_scheme = self._GetScheme()
+        convection_diffusion_convergence_criterion = self._GetConvergenceCriterion()
+        builder_and_solver = self._GetBuilderAndSolver()
+        if not computing_model_part.IsDistributed():
+            return KratosMultiphysics.ResidualBasedNewtonRaphsonStrategy(
+                computing_model_part,
+                convection_diffusion_scheme,
+                convection_diffusion_convergence_criterion,
+                builder_and_solver,
+                self.settings["max_iteration"].GetInt(),
+                self.settings["compute_reactions"].GetBool(),
+                self.settings["reform_dofs_at_each_step"].GetBool(),
+                self.settings["move_mesh_flag"].GetBool())
+        else:
+            return KratosTrilinos.TrilinosNewtonRaphsonStrategy(
+                computing_model_part,
+                convection_diffusion_scheme,
+                convection_diffusion_convergence_criterion,
+                builder_and_solver,
+                self.settings["max_iteration"].GetInt(),
+                self.settings["compute_reactions"].GetBool(),
+                self.settings["reform_dofs_at_each_step"].GetBool(),
+                self.settings["move_mesh_flag"].GetBool())
+
+    def _create_line_search_strategy(self):
+        computing_model_part = self.GetComputingModelPart()
+        convection_diffusion_scheme = self._GetScheme()
+        convection_diffusion_convergence_criterion = self._GetConvergenceCriterion()
+        builder_and_solver = self._GetBuilderAndSolver()
+        if not computing_model_part.IsDistributed():
+            return KratosMultiphysics.LineSearchStrategy(
+                computing_model_part,
+                convection_diffusion_scheme,
+                convection_diffusion_convergence_criterion,
+                builder_and_solver,
+                self.settings["max_iteration"].GetInt(),
+                self.settings["compute_reactions"].GetBool(),
+                self.settings["reform_dofs_at_each_step"].GetBool(),
+                self.settings["move_mesh_flag"].GetBool())
+        else:
+            err_msg = "\'line_search\' solution strategy is not MPI compatible."
+            raise Exception(err_msg)
+
+    def _ConvectionDiffusionVariablesCheck(self, custom_settings):
+        """This checks the user provided set of variables.
+        If there are no custom \'convection_diffusion_variables\', the default ones are taken.
+        If these are defined by the user, it checks one by one the provided values. If one is missing, it is taken form the defaults.
+        Note that this ensures that all the historical nodal variables to be used are defined in \'convection_diffusion_settings\' at construction time.
+        """
+
+        default_settings = self.GetDefaultParameters()
+        default_conv_diff_variables = default_settings["convection_diffusion_variables"]
+        if not custom_settings.Has("convection_diffusion_variables"):
+            KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "\'convection_diffusion_variables\' not defined, taking default ", default_conv_diff_variables)
+        else:
+            custom_conv_diff_variables = custom_settings["convection_diffusion_variables"]
+            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "density_variable", default_conv_diff_variables["density_variable"].GetString())
+            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "diffusion_variable", default_conv_diff_variables["diffusion_variable"].GetString())
+            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "unknown_variable", default_conv_diff_variables["unknown_variable"].GetString())
+            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "volume_source_variable", default_conv_diff_variables["volume_source_variable"].GetString())
+            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "surface_source_variable", default_conv_diff_variables["surface_source_variable"].GetString())
+            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "projection_variable", default_conv_diff_variables["projection_variable"].GetString())
+            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "convection_variable", default_conv_diff_variables["convection_variable"].GetString())
+            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "gradient_variable", default_conv_diff_variables["gradient_variable"].GetString())
+            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "mesh_velocity_variable", default_conv_diff_variables["mesh_velocity_variable"].GetString())
+            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "transfer_coefficient_variable", default_conv_diff_variables["transfer_coefficient_variable"].GetString())
+            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "velocity_variable", default_conv_diff_variables["velocity_variable"].GetString())
+            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "specific_heat_variable", default_conv_diff_variables["specific_heat_variable"].GetString())
+            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "reaction_variable", default_conv_diff_variables["reaction_variable"].GetString())
+            self._ConvectionDiffusionSingleVariableCheck(custom_conv_diff_variables, "reaction_gradient_variable", default_conv_diff_variables["reaction_gradient_variable"].GetString())
+
+    def _ConvectionDiffusionSingleVariableCheck(self, custom_conv_diff_variables, variable_entry, variable_name):
+        if not custom_conv_diff_variables.Has(variable_entry):
+            custom_conv_diff_variables.AddEmptyValue(variable_entry).SetString(variable_name)
+            KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "\'{0}\' in \'convection_diffusion_variables\' not defined, taking default \'{1}\'.".format(variable_entry, variable_name))
+
+    #TODO: THIS MUST BE IMPLEMENTED IN A base_convergence_criteria_factory_mpi.py
+    #TODO: THEN WE CAN IMPORT IT AS convergence_criteria_factory TO AVOID DISTINGUISHING THE SERIAL AND THE PARALLEL FACTORIES
+    def __base_convergence_criteria_factory_mpi(self, convergence_criterion_parameters):
+        # Note that all the convergence settings are introduced via a Kratos parameters object.
+        D_RT = convergence_criterion_parameters["solution_relative_tolerance"].GetDouble()
+        D_AT = convergence_criterion_parameters["solution_absolute_tolerance"].GetDouble()
+        R_RT = convergence_criterion_parameters["residual_relative_tolerance"].GetDouble()
+        R_AT = convergence_criterion_parameters["residual_absolute_tolerance"].GetDouble()
+
+        echo_level = convergence_criterion_parameters["echo_level"].GetInt()
+        convergence_crit = convergence_criterion_parameters["convergence_criterion"].GetString()
+
+        if(echo_level >= 1):
+            KratosMultiphysics.Logger.PrintInfo("::[ConvergenceCriterionFactory]:: ", "CONVERGENCE CRITERION : " +
+                convergence_criterion_parameters["convergence_criterion"].GetString())
+
+        if(convergence_crit == "solution_criterion"):
+            convergence_criterion = KratosTrilinos.TrilinosDisplacementCriteria(D_RT, D_AT)
+            convergence_criterion.SetEchoLevel(echo_level)
+
+        elif(convergence_crit == "residual_criterion"):
+            convergence_criterion = KratosTrilinos.TrilinosResidualCriteria(R_RT, R_AT)
+            convergence_criterion.SetEchoLevel(echo_level)
+
+        elif(convergence_crit == "and_criterion"):
+            Displacement = KratosTrilinos.TrilinosDisplacementCriteria(D_RT, D_AT)
+            Displacement.SetEchoLevel(echo_level)
+            Residual = KratosTrilinos.TrilinosResidualCriteria(R_RT, R_AT)
+            Residual.SetEchoLevel(echo_level)
+            convergence_criterion = KratosTrilinos.TrilinosAndCriteria(Residual, Displacement)
+
+        elif(convergence_crit == "or_criterion"):
+            Displacement = KratosTrilinos.TrilinosDisplacementCriteria(D_RT, D_AT)
+            Displacement.SetEchoLevel(echo_level)
+            Residual = KratosTrilinos.TrilinosResidualCriteria(R_RT, R_AT)
+            Residual.SetEchoLevel(echo_level)
+            convergence_criterion = KratosTrilinos.TrilinosOrCriteria(Residual, Displacement)
+        else:
+            err_msg =  "The requested convergence criterion \"" + convergence_crit + "\" is not available!\n"
+            err_msg += "Available options are: \"solution_criterion\", \"residual_criterion\", \"and_criterion\", \"or_criterion\""
+            raise Exception(err_msg)
+
+        return convergence_criterion
+
+    def get_epetra_communicator(self):
+        if not hasattr(self, '_epetra_communicator'):
+            self._epetra_communicator = KratosTrilinos.CreateCommunicator()
+        return self._epetra_communicator
```

## KratosMultiphysics/ConvectionDiffusionApplication/adjoint_diffusion_solver.py

 * *Ordering differences only*

```diff
@@ -1,255 +1,255 @@
-import KratosMultiphysics as kratos
-import KratosMultiphysics.ConvectionDiffusionApplication as convdiff
-
-from KratosMultiphysics.python_solver import PythonSolver
-
-def CreateSolver(model, settings):
-    return AdjointDiffusionSolver(model, settings)
-
-class AdjointDiffusionSolver(PythonSolver):
-
-    def __init__(self, model, custom_settings):
-        super().__init__(model,custom_settings)
-
-        self.min_buffer_size = 1
-
-        model_part_name = self.settings["model_part_name"].GetString()
-        if model_part_name == "":
-            raise Exception("Empty model_part_name provided")
-
-        if self.model.HasModelPart(model_part_name):
-            self.model_part = self.model.GetModelPart(model_part_name)
-            self.solver_imports_model_part = False
-        else:
-            self.model_part = self.model.CreateModelPart(model_part_name)
-
-            domain_size = self.settings["domain_size"].GetInt()
-            if domain_size not in (2,3):
-                raise Exception("Unsupported domain_size: ", domain_size)
-
-            self.model_part.ProcessInfo[kratos.DOMAIN_SIZE] = domain_size
-            self.solver_imports_model_part = True
-
-            self.DefineConvectionDiffusionSettings(self.settings["convection_diffusion_variables"])
-
-        self.primal_model_part_name = self.settings["primal_model_part_name"].GetString()
-        if self.primal_model_part_name == "":
-            raise Exception("No primal_model_part_name provided")
-
-    @classmethod
-    def GetDefaultParameters(cls):
-
-        default_settings = kratos.Parameters(r'''{
-            "solver_type" : "adjoint_stationary",
-            "model_part_name": "",
-            "primal_model_part_name" : "",
-            "domain_size": 0,
-            "model_import_settings" : {
-                "input_type"     : "mdpa",
-                "input_filename" : ""
-            },
-            "convection_diffusion_variables" : {
-                "diffusion_variable"            : "CONDUCTIVITY",
-                "unknown_variable"              : "TEMPERATURE",
-                "volume_source_variable"        : "HEAT_FLUX",
-                "surface_source_variable"       : "FACE_HEAT_FLUX"
-            },
-            "material_import_settings" :{
-                "materials_filename": ""
-            },
-            "linear_solver_settings" : {
-                "solver_type" : "amgcl"
-            },
-            "response_function_settings" : {
-                "response_type" : "point_temperature"
-            },
-            "sensitivity_settings" : {},
-            "element_replace_settings" : {
-                "element_name" : "AdjointDiffusionElement",
-                "condition_name" : "AdjointThermalFace"
-            },
-            "time_stepping" : {
-                "time_step" : 0.0
-            },
-            "time_integration_method": "implicit"
-        }''')
-
-        default_settings.AddMissingParameters(super().GetDefaultParameters())
-        return default_settings
-
-    def AddVariables(self):
-        convection_diffusion_settings = self.model_part.ProcessInfo[kratos.CONVECTION_DIFFUSION_SETTINGS]
-
-        self.model_part.AddNodalSolutionStepVariable(convection_diffusion_settings.GetUnknownVariable())
-        self.model_part.AddNodalSolutionStepVariable(convection_diffusion_settings.GetDiffusionVariable())
-        self.model_part.AddNodalSolutionStepVariable(convection_diffusion_settings.GetVolumeSourceVariable())
-        self.model_part.AddNodalSolutionStepVariable(convection_diffusion_settings.GetSurfaceSourceVariable())
-        self.model_part.AddNodalSolutionStepVariable(convdiff.ADJOINT_HEAT_TRANSFER)
-        self.model_part.AddNodalSolutionStepVariable(kratos.SHAPE_SENSITIVITY)
-
-    def AddDofs(self):
-        variable_utils = kratos.VariableUtils()
-        variable_utils.AddDof(convdiff.ADJOINT_HEAT_TRANSFER, self.model_part)
-
-    def ImportModelPart(self):
-        # we can use the default implementation in the base class
-        if self.solver_imports_model_part:
-            self._ImportModelPart(self.model_part,self.settings["model_import_settings"])
-
-    def PrepareModelPart(self):
-        if self.solver_imports_model_part:
-            # ensure that the element type is the correct one
-            self._set_elements_and_conditions()
-
-            # check mesh orientation (tetrahedral mesh orientation check)
-            throw_errors = False
-            kratos.TetrahedralMeshOrientationCheck(self.model_part, throw_errors).Execute()
-
-            # set the buffer size
-            if self.model_part.GetBufferSize() < self.min_buffer_size:
-                self.model_part.SetBufferSize(self.min_buffer_size)
-
-            # initialize the adjoint model part using primal results
-            primal_model_part = self.model.GetModelPart(self.primal_model_part_name)
-            variable_utils = kratos.VariableUtils()
-            variable_utils.CopyModelPartNodalVar(kratos.CONDUCTIVITY, primal_model_part, self.model_part, 0)
-            variable_utils.CopyModelPartNodalVar(kratos.TEMPERATURE, primal_model_part, self.model_part, 0)
-            variable_utils.CopyModelPartNodalVar(kratos.HEAT_FLUX, primal_model_part, self.model_part, 0)
-            variable_utils.CopyModelPartNodalVar(kratos.FACE_HEAT_FLUX, primal_model_part, self.model_part, 0)
-
-            self.ImportMaterials()
-
-    def ImportMaterials(self):
-        materials_filename = self.settings["material_import_settings"]["materials_filename"].GetString()
-        if (materials_filename != ""):
-            with open(materials_filename, 'r') as parameter_file:
-                materials = kratos.Parameters(parameter_file.read())
-
-            for i in range(materials["properties"].size()):
-                model_part = self.model.GetModelPart(materials["properties"][i]["model_part_name"].GetString())
-                mat = materials["properties"][i]["Material"]
-                var_utils = kratos.VariableUtils()
-                for key, value in mat["Variables"].items():
-                    var = kratos.KratosGlobals.GetVariable(key)
-                    #if not model_part.HasNodalSolutionStepVariable(var):
-                    #     raise Exception("Trying to set variable {0} on nodes, but the variable is not in nodal data.".format(var.Name()))
-                    if model_part.HasNodalSolutionStepVariable(var):
-                        if value.IsDouble():
-                            var_utils.SetScalarVar(var, value.GetDouble(), model_part.Nodes)
-                        elif value.IsVector():
-                            var_utils.SetVectorVar(var, value.GetVector(), model_part.Nodes)
-                        else:
-                            raise ValueError("Type of value is not available")
-                    else:
-                        kratos.Logger.PrintWarning("Ignoring variable {0} given by the materials file, since it is not a nodal variable used by this solver.".format(var.Name()))
-
-    def DefineConvectionDiffusionSettings(self,settings):
-        convection_diffusion_settings = kratos.ConvectionDiffusionSettings()
-
-        convection_diffusion_settings.SetDiffusionVariable(
-            kratos.KratosGlobals.GetVariable(settings["diffusion_variable"].GetString()))
-        convection_diffusion_settings.SetUnknownVariable(
-            kratos.KratosGlobals.GetVariable(settings["unknown_variable"].GetString()))
-        convection_diffusion_settings.SetVolumeSourceVariable(
-            kratos.KratosGlobals.GetVariable(settings["volume_source_variable"].GetString()))
-        convection_diffusion_settings.SetSurfaceSourceVariable(
-            kratos.KratosGlobals.GetVariable(settings["surface_source_variable"].GetString()))
-
-        self.model_part.ProcessInfo.SetValue(kratos.CONVECTION_DIFFUSION_SETTINGS,convection_diffusion_settings)
-
-    def GetComputingModelPart(self):
-        return self.model_part
-
-    def Initialize(self):
-
-        if self.settings["response_function_settings"]["response_type"].GetString() == "point_temperature":
-            self.response_function = convdiff.LocalTemperatureAverageResponseFunction(self.settings["response_function_settings"]["custom_settings"],self.model_part)
-        else:
-            raise Exception("invalid response_type: " + self.settings["response_function_settings"]["response_type"].GetString())
-
-        self.sensitivity_builder = kratos.SensitivityBuilder(self.settings["sensitivity_settings"], self.model_part, self.response_function)
-
-        import KratosMultiphysics.python_linear_solver_factory as linear_solver_factory
-        self.linear_solver = linear_solver_factory.ConstructSolver(self.settings["linear_solver_settings"])
-
-        self.time_scheme = kratos.ResidualBasedAdjointStaticScheme(self.response_function)
-
-        builder_and_solver = kratos.ResidualBasedBlockBuilderAndSolver(self.linear_solver)
-
-        self.solver = kratos.ResidualBasedLinearStrategy(self.model_part,
-                                                         self.time_scheme,
-                                                         builder_and_solver,
-                                                         False,
-                                                         False,
-                                                         False,
-                                                         False)
-
-        self.solver.SetEchoLevel(self.settings["echo_level"].GetInt())
-
-        self.solver.Initialize()
-        self.response_function.Initialize()
-        self.sensitivity_builder.Initialize()
-        kratos.Logger.PrintInfo(self.__class__.__name__, "Solver initialization finished.")
-
-    def InitializeSolutionStep(self):
-        self.solver.InitializeSolutionStep()
-        self.response_function.InitializeSolutionStep()
-
-    def Predict(self):
-        self.solver.Predict()
-
-    def SolveSolutionStep(self):
-        return self.solver.SolveSolutionStep()
-
-    def FinalizeSolutionStep(self):
-        (self.solver).FinalizeSolutionStep()
-        self.response_function.FinalizeSolutionStep()
-        self.sensitivity_builder.UpdateSensitivities()
-
-    def Check(self):
-        (self.solver).Check()
-
-    def Clear(self):
-        (self.solver).Clear()
-
-    def AdvanceInTime(self, current_time):
-        dt = self.ComputeDeltaTime()
-        new_time = current_time + dt
-        self.model_part.ProcessInfo[kratos.STEP] += 1
-        self.model_part.CloneTimeStep(new_time)
-
-        return new_time
-
-    def ComputeDeltaTime(self):
-        return self.settings["time_stepping"]["time_step"].GetDouble()
-
-    def _set_elements_and_conditions(self):
-
-        domain_size = self.model_part.ProcessInfo[kratos.DOMAIN_SIZE]
-        comm = self.model_part.GetCommunicator().GetDataCommunicator()
-
-        element_name = self.settings["element_replace_settings"]["element_name"].GetString()
-        condition_name = self.settings["element_replace_settings"]["condition_name"].GetString()
-
-        num_nodes_elements = 0
-        for elem in self.model_part.Elements:
-            num_nodes_elements = len(elem.GetNodes())
-            break
-        num_nodes_elements = comm.MaxAll(num_nodes_elements)
-
-        if element_name == "AdjointDiffusionElement":
-            name_string = "{0}{1}D{2}N".format(element_name,domain_size, num_nodes_elements)
-            self.settings["element_replace_settings"]["element_name"].SetString(name_string)
-
-        num_nodes_conditions = 0
-        for cond in self.model_part.Conditions:
-            num_nodes_conditions = len(cond.GetNodes())
-            break
-        num_nodes_conditions = comm.MaxAll(num_nodes_conditions)
-
-        if condition_name == "AdjointThermalFace":
-            name_string = "{0}{1}D{2}N".format(condition_name,domain_size, num_nodes_conditions)
-            self.settings["element_replace_settings"]["condition_name"].SetString(name_string)
-
-        ## Call the replace elements and conditions process
-        kratos.ReplaceElementsAndConditionsProcess(self.model_part, self.settings["element_replace_settings"]).Execute()
+import KratosMultiphysics as kratos
+import KratosMultiphysics.ConvectionDiffusionApplication as convdiff
+
+from KratosMultiphysics.python_solver import PythonSolver
+
+def CreateSolver(model, settings):
+    return AdjointDiffusionSolver(model, settings)
+
+class AdjointDiffusionSolver(PythonSolver):
+
+    def __init__(self, model, custom_settings):
+        super().__init__(model,custom_settings)
+
+        self.min_buffer_size = 1
+
+        model_part_name = self.settings["model_part_name"].GetString()
+        if model_part_name == "":
+            raise Exception("Empty model_part_name provided")
+
+        if self.model.HasModelPart(model_part_name):
+            self.model_part = self.model.GetModelPart(model_part_name)
+            self.solver_imports_model_part = False
+        else:
+            self.model_part = self.model.CreateModelPart(model_part_name)
+
+            domain_size = self.settings["domain_size"].GetInt()
+            if domain_size not in (2,3):
+                raise Exception("Unsupported domain_size: ", domain_size)
+
+            self.model_part.ProcessInfo[kratos.DOMAIN_SIZE] = domain_size
+            self.solver_imports_model_part = True
+
+            self.DefineConvectionDiffusionSettings(self.settings["convection_diffusion_variables"])
+
+        self.primal_model_part_name = self.settings["primal_model_part_name"].GetString()
+        if self.primal_model_part_name == "":
+            raise Exception("No primal_model_part_name provided")
+
+    @classmethod
+    def GetDefaultParameters(cls):
+
+        default_settings = kratos.Parameters(r'''{
+            "solver_type" : "adjoint_stationary",
+            "model_part_name": "",
+            "primal_model_part_name" : "",
+            "domain_size": 0,
+            "model_import_settings" : {
+                "input_type"     : "mdpa",
+                "input_filename" : ""
+            },
+            "convection_diffusion_variables" : {
+                "diffusion_variable"            : "CONDUCTIVITY",
+                "unknown_variable"              : "TEMPERATURE",
+                "volume_source_variable"        : "HEAT_FLUX",
+                "surface_source_variable"       : "FACE_HEAT_FLUX"
+            },
+            "material_import_settings" :{
+                "materials_filename": ""
+            },
+            "linear_solver_settings" : {
+                "solver_type" : "amgcl"
+            },
+            "response_function_settings" : {
+                "response_type" : "point_temperature"
+            },
+            "sensitivity_settings" : {},
+            "element_replace_settings" : {
+                "element_name" : "AdjointDiffusionElement",
+                "condition_name" : "AdjointThermalFace"
+            },
+            "time_stepping" : {
+                "time_step" : 0.0
+            },
+            "time_integration_method": "implicit"
+        }''')
+
+        default_settings.AddMissingParameters(super().GetDefaultParameters())
+        return default_settings
+
+    def AddVariables(self):
+        convection_diffusion_settings = self.model_part.ProcessInfo[kratos.CONVECTION_DIFFUSION_SETTINGS]
+
+        self.model_part.AddNodalSolutionStepVariable(convection_diffusion_settings.GetUnknownVariable())
+        self.model_part.AddNodalSolutionStepVariable(convection_diffusion_settings.GetDiffusionVariable())
+        self.model_part.AddNodalSolutionStepVariable(convection_diffusion_settings.GetVolumeSourceVariable())
+        self.model_part.AddNodalSolutionStepVariable(convection_diffusion_settings.GetSurfaceSourceVariable())
+        self.model_part.AddNodalSolutionStepVariable(convdiff.ADJOINT_HEAT_TRANSFER)
+        self.model_part.AddNodalSolutionStepVariable(kratos.SHAPE_SENSITIVITY)
+
+    def AddDofs(self):
+        variable_utils = kratos.VariableUtils()
+        variable_utils.AddDof(convdiff.ADJOINT_HEAT_TRANSFER, self.model_part)
+
+    def ImportModelPart(self):
+        # we can use the default implementation in the base class
+        if self.solver_imports_model_part:
+            self._ImportModelPart(self.model_part,self.settings["model_import_settings"])
+
+    def PrepareModelPart(self):
+        if self.solver_imports_model_part:
+            # ensure that the element type is the correct one
+            self._set_elements_and_conditions()
+
+            # check mesh orientation (tetrahedral mesh orientation check)
+            throw_errors = False
+            kratos.TetrahedralMeshOrientationCheck(self.model_part, throw_errors).Execute()
+
+            # set the buffer size
+            if self.model_part.GetBufferSize() < self.min_buffer_size:
+                self.model_part.SetBufferSize(self.min_buffer_size)
+
+            # initialize the adjoint model part using primal results
+            primal_model_part = self.model.GetModelPart(self.primal_model_part_name)
+            variable_utils = kratos.VariableUtils()
+            variable_utils.CopyModelPartNodalVar(kratos.CONDUCTIVITY, primal_model_part, self.model_part, 0)
+            variable_utils.CopyModelPartNodalVar(kratos.TEMPERATURE, primal_model_part, self.model_part, 0)
+            variable_utils.CopyModelPartNodalVar(kratos.HEAT_FLUX, primal_model_part, self.model_part, 0)
+            variable_utils.CopyModelPartNodalVar(kratos.FACE_HEAT_FLUX, primal_model_part, self.model_part, 0)
+
+            self.ImportMaterials()
+
+    def ImportMaterials(self):
+        materials_filename = self.settings["material_import_settings"]["materials_filename"].GetString()
+        if (materials_filename != ""):
+            with open(materials_filename, 'r') as parameter_file:
+                materials = kratos.Parameters(parameter_file.read())
+
+            for i in range(materials["properties"].size()):
+                model_part = self.model.GetModelPart(materials["properties"][i]["model_part_name"].GetString())
+                mat = materials["properties"][i]["Material"]
+                var_utils = kratos.VariableUtils()
+                for key, value in mat["Variables"].items():
+                    var = kratos.KratosGlobals.GetVariable(key)
+                    #if not model_part.HasNodalSolutionStepVariable(var):
+                    #     raise Exception("Trying to set variable {0} on nodes, but the variable is not in nodal data.".format(var.Name()))
+                    if model_part.HasNodalSolutionStepVariable(var):
+                        if value.IsDouble():
+                            var_utils.SetScalarVar(var, value.GetDouble(), model_part.Nodes)
+                        elif value.IsVector():
+                            var_utils.SetVectorVar(var, value.GetVector(), model_part.Nodes)
+                        else:
+                            raise ValueError("Type of value is not available")
+                    else:
+                        kratos.Logger.PrintWarning("Ignoring variable {0} given by the materials file, since it is not a nodal variable used by this solver.".format(var.Name()))
+
+    def DefineConvectionDiffusionSettings(self,settings):
+        convection_diffusion_settings = kratos.ConvectionDiffusionSettings()
+
+        convection_diffusion_settings.SetDiffusionVariable(
+            kratos.KratosGlobals.GetVariable(settings["diffusion_variable"].GetString()))
+        convection_diffusion_settings.SetUnknownVariable(
+            kratos.KratosGlobals.GetVariable(settings["unknown_variable"].GetString()))
+        convection_diffusion_settings.SetVolumeSourceVariable(
+            kratos.KratosGlobals.GetVariable(settings["volume_source_variable"].GetString()))
+        convection_diffusion_settings.SetSurfaceSourceVariable(
+            kratos.KratosGlobals.GetVariable(settings["surface_source_variable"].GetString()))
+
+        self.model_part.ProcessInfo.SetValue(kratos.CONVECTION_DIFFUSION_SETTINGS,convection_diffusion_settings)
+
+    def GetComputingModelPart(self):
+        return self.model_part
+
+    def Initialize(self):
+
+        if self.settings["response_function_settings"]["response_type"].GetString() == "point_temperature":
+            self.response_function = convdiff.LocalTemperatureAverageResponseFunction(self.settings["response_function_settings"]["custom_settings"],self.model_part)
+        else:
+            raise Exception("invalid response_type: " + self.settings["response_function_settings"]["response_type"].GetString())
+
+        self.sensitivity_builder = kratos.SensitivityBuilder(self.settings["sensitivity_settings"], self.model_part, self.response_function)
+
+        import KratosMultiphysics.python_linear_solver_factory as linear_solver_factory
+        self.linear_solver = linear_solver_factory.ConstructSolver(self.settings["linear_solver_settings"])
+
+        self.time_scheme = kratos.ResidualBasedAdjointStaticScheme(self.response_function)
+
+        builder_and_solver = kratos.ResidualBasedBlockBuilderAndSolver(self.linear_solver)
+
+        self.solver = kratos.ResidualBasedLinearStrategy(self.model_part,
+                                                         self.time_scheme,
+                                                         builder_and_solver,
+                                                         False,
+                                                         False,
+                                                         False,
+                                                         False)
+
+        self.solver.SetEchoLevel(self.settings["echo_level"].GetInt())
+
+        self.solver.Initialize()
+        self.response_function.Initialize()
+        self.sensitivity_builder.Initialize()
+        kratos.Logger.PrintInfo(self.__class__.__name__, "Solver initialization finished.")
+
+    def InitializeSolutionStep(self):
+        self.solver.InitializeSolutionStep()
+        self.response_function.InitializeSolutionStep()
+
+    def Predict(self):
+        self.solver.Predict()
+
+    def SolveSolutionStep(self):
+        return self.solver.SolveSolutionStep()
+
+    def FinalizeSolutionStep(self):
+        (self.solver).FinalizeSolutionStep()
+        self.response_function.FinalizeSolutionStep()
+        self.sensitivity_builder.UpdateSensitivities()
+
+    def Check(self):
+        (self.solver).Check()
+
+    def Clear(self):
+        (self.solver).Clear()
+
+    def AdvanceInTime(self, current_time):
+        dt = self.ComputeDeltaTime()
+        new_time = current_time + dt
+        self.model_part.ProcessInfo[kratos.STEP] += 1
+        self.model_part.CloneTimeStep(new_time)
+
+        return new_time
+
+    def ComputeDeltaTime(self):
+        return self.settings["time_stepping"]["time_step"].GetDouble()
+
+    def _set_elements_and_conditions(self):
+
+        domain_size = self.model_part.ProcessInfo[kratos.DOMAIN_SIZE]
+        comm = self.model_part.GetCommunicator().GetDataCommunicator()
+
+        element_name = self.settings["element_replace_settings"]["element_name"].GetString()
+        condition_name = self.settings["element_replace_settings"]["condition_name"].GetString()
+
+        num_nodes_elements = 0
+        for elem in self.model_part.Elements:
+            num_nodes_elements = len(elem.GetNodes())
+            break
+        num_nodes_elements = comm.MaxAll(num_nodes_elements)
+
+        if element_name == "AdjointDiffusionElement":
+            name_string = "{0}{1}D{2}N".format(element_name,domain_size, num_nodes_elements)
+            self.settings["element_replace_settings"]["element_name"].SetString(name_string)
+
+        num_nodes_conditions = 0
+        for cond in self.model_part.Conditions:
+            num_nodes_conditions = len(cond.GetNodes())
+            break
+        num_nodes_conditions = comm.MaxAll(num_nodes_conditions)
+
+        if condition_name == "AdjointThermalFace":
+            name_string = "{0}{1}D{2}N".format(condition_name,domain_size, num_nodes_conditions)
+            self.settings["element_replace_settings"]["condition_name"].SetString(name_string)
+
+        ## Call the replace elements and conditions process
+        kratos.ReplaceElementsAndConditionsProcess(self.model_part, self.settings["element_replace_settings"]).Execute()
```

## KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_semi_eulerian_solver.py

 * *Ordering differences only*

```diff
@@ -1,157 +1,157 @@
-
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.ConvectionDiffusionApplication as ConvectionDiffusionApplication
-
-# Import base class file
-from KratosMultiphysics.ConvectionDiffusionApplication import convection_diffusion_solver
-
-def CreateSolver(model, custom_settings):
-    return ConvectionDiffusionSemiImplicitSolver(model, custom_settings)
-
-class ConvectionDiffusionSemiImplicitSolver(convection_diffusion_solver.ConvectionDiffusionSolver):
-    """The semi-eulerian class for convection-diffusion solvers.
-
-    See convection_diffusion_solver.py for more information.
-    """
-
-    def __init__(self, model, custom_settings):
-        # Construct the base solver and validate the remaining settings in the base class
-        super().__init__(model, custom_settings)
-
-        # Overwrite the base solver minimum buffer size
-        self.min_buffer_size = 2
-
-        KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "Construction finished")
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        default_settings = KratosMultiphysics.Parameters("""
-        {
-            "analysis_type" : "linear",
-            "time_integration_method" : "semi_implicit",
-            "solver_type" : "transient",
-            "element_replace_settings" : {
-                "element_name" : "EulerianDiffusion",
-                "condition_name" : "ThermalFace"
-            },
-            "pure_convection" : false,
-            "bfecc_substepping": 10
-        }
-        """)
-        default_settings.AddMissingParameters(super().GetDefaultParameters())
-        return default_settings
-
-    def Initialize(self):
-        super().Initialize()
-
-        # Trigger the BFECC convection to create it
-        self._GetBFECCConvection()
-
-    def SolveSolutionStep(self):
-        # Perform the semi-Eulerian convection
-        bfecc_substepping = self.settings["bfecc_substepping"].GetInt()
-        thermal_settings  = self.GetComputingModelPart().ProcessInfo.GetValue(KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS)
-        unknown_variable = thermal_settings.GetUnknownVariable()
-        projection_variable = thermal_settings.GetProjectionVariable()
-        velocity_variable = thermal_settings.GetVelocityVariable()
-
-        KratosMultiphysics.VariableUtils().CopyVariable(unknown_variable, projection_variable, self.GetComputingModelPart().Nodes)
-        self._GetBFECCConvection().CopyScalarVarToPreviousTimeStep(self.GetComputingModelPart(), projection_variable)
-        self._GetBFECCConvection().BFECCconvect(self.GetComputingModelPart(), projection_variable, velocity_variable, bfecc_substepping)
-
-        # Solve diffusion
-        is_converged = True
-        pure_convection = self.settings["pure_convection"].GetBool()
-        if not pure_convection:
-            is_converged = self._GetSolutionStrategy().SolveSolutionStep()
-
-        return is_converged
-
-    #### Private functions ####
-    def _get_element_condition_replace_settings(self):
-        # Get and check domain size
-        domain_size = self.main_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE]
-        if domain_size not in (2,3):
-            raise Exception("DOMAIN_SIZE not set")
-
-        # Set pure diffusion elements
-        num_nodes_elements = 0
-        if (len(self.main_model_part.Elements) > 0):
-            for elem in self.main_model_part.Elements:
-                num_nodes_elements = len(elem.GetNodes())
-                break
-        num_nodes_elements = self.main_model_part.GetCommunicator().GetDataCommunicator().MaxAll(num_nodes_elements)
-
-        if domain_size == 2:
-            if num_nodes_elements == 3:
-                self.settings["element_replace_settings"]["element_name"].SetString("EulerianDiffusion2D3N")
-            else:
-                # TODO: Check that the EulerianDiffusion2D4N works!
-                # self.settings["element_replace_settings"]["element_name"].SetString("EulerianDiffusion2D4N")
-                err_msg = "EulerianDiffusion2D4N not exported yet."
-                raise Exception(err_msg)
-        else:
-            if num_nodes_elements == 4:
-                self.settings["element_replace_settings"]["element_name"].SetString("EulerianDiffusion3D4N")
-            else:
-                # TODO: Check that the EulerianDiffusion3D8N works!
-                # self.settings["element_replace_settings"]["element_name"].SetString("EulerianDiffusion3D8N")
-                err_msg = "EulerianDiffusion3D8N not exported yet."
-                raise Exception(err_msg)
-
-        # TODO: Create an auxiliary method to get this from the base
-        # Set thermal conditions
-        num_conditions = self.main_model_part.GetCommunicator().GetDataCommunicator().SumAll(len(self.main_model_part.Conditions))
-
-        if num_conditions > 0:
-            num_nodes_conditions = 0
-            if (len(self.main_model_part.Conditions) > 0):
-                for cond in self.main_model_part.Conditions:
-                    num_nodes_conditions = len(cond.GetNodes())
-                    break
-
-            num_nodes_conditions = self.main_model_part.GetCommunicator().GetDataCommunicator().MaxAll(num_nodes_conditions)
-
-            condition_name = self.settings["element_replace_settings"]["condition_name"].GetString()
-            if condition_name in ("FluxCondition","ThermalFace","Condition"):
-                name_string = "{0}{1}D{2}N".format(condition_name,domain_size, num_nodes_conditions)
-                self.settings["element_replace_settings"]["condition_name"].SetString(name_string)
-        else:
-            self.settings["element_replace_settings"]["condition_name"].SetString("")
-
-        return self.settings["element_replace_settings"]
-
-    def _GetBFECCConvection(self):
-        if not hasattr(self, '_bfecc_convection'):
-            self._bfecc_convection = self._CreateBFECCConvection()
-        return self._bfecc_convection
-
-    def _CreateScheme(self):
-        # Create a "fake" time scheme to perform the solution update
-        convection_diffusion_scheme = KratosMultiphysics.ResidualBasedIncrementalUpdateStaticScheme()
-        return convection_diffusion_scheme
-
-    def _CreateBFECCConvection(self):
-        # Create the locator for the BFECC convector
-        domain_size = self.GetComputingModelPart().ProcessInfo[KratosMultiphysics.DOMAIN_SIZE]
-        if domain_size == 2:
-            point_locator = KratosMultiphysics.BinBasedFastPointLocator2D(self.GetComputingModelPart())
-        elif domain_size == 3:
-            point_locator = KratosMultiphysics.BinBasedFastPointLocator3D(self.GetComputingModelPart())
-        else:
-            err_msg = "Wrong domain size: {0}".format(domain_size)
-            raise Exception(err_msg)
-
-        # Initialize the locator search database
-        point_locator.UpdateSearchDatabase()
-
-        # Create the BFECC convection utility
-        if domain_size ==2:
-            bfecc_utility = ConvectionDiffusionApplication.BFECCConvection2D(point_locator)
-        else:
-            bfecc_utility = ConvectionDiffusionApplication.BFECCConvection3D(point_locator)
-
-        return bfecc_utility
+
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.ConvectionDiffusionApplication as ConvectionDiffusionApplication
+
+# Import base class file
+from KratosMultiphysics.ConvectionDiffusionApplication import convection_diffusion_solver
+
+def CreateSolver(model, custom_settings):
+    return ConvectionDiffusionSemiImplicitSolver(model, custom_settings)
+
+class ConvectionDiffusionSemiImplicitSolver(convection_diffusion_solver.ConvectionDiffusionSolver):
+    """The semi-eulerian class for convection-diffusion solvers.
+
+    See convection_diffusion_solver.py for more information.
+    """
+
+    def __init__(self, model, custom_settings):
+        # Construct the base solver and validate the remaining settings in the base class
+        super().__init__(model, custom_settings)
+
+        # Overwrite the base solver minimum buffer size
+        self.min_buffer_size = 2
+
+        KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "Construction finished")
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        default_settings = KratosMultiphysics.Parameters("""
+        {
+            "analysis_type" : "linear",
+            "time_integration_method" : "semi_implicit",
+            "solver_type" : "transient",
+            "element_replace_settings" : {
+                "element_name" : "EulerianDiffusion",
+                "condition_name" : "ThermalFace"
+            },
+            "pure_convection" : false,
+            "bfecc_substepping": 10
+        }
+        """)
+        default_settings.AddMissingParameters(super().GetDefaultParameters())
+        return default_settings
+
+    def Initialize(self):
+        super().Initialize()
+
+        # Trigger the BFECC convection to create it
+        self._GetBFECCConvection()
+
+    def SolveSolutionStep(self):
+        # Perform the semi-Eulerian convection
+        bfecc_substepping = self.settings["bfecc_substepping"].GetInt()
+        thermal_settings  = self.GetComputingModelPart().ProcessInfo.GetValue(KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS)
+        unknown_variable = thermal_settings.GetUnknownVariable()
+        projection_variable = thermal_settings.GetProjectionVariable()
+        velocity_variable = thermal_settings.GetVelocityVariable()
+
+        KratosMultiphysics.VariableUtils().CopyVariable(unknown_variable, projection_variable, self.GetComputingModelPart().Nodes)
+        self._GetBFECCConvection().CopyScalarVarToPreviousTimeStep(self.GetComputingModelPart(), projection_variable)
+        self._GetBFECCConvection().BFECCconvect(self.GetComputingModelPart(), projection_variable, velocity_variable, bfecc_substepping)
+
+        # Solve diffusion
+        is_converged = True
+        pure_convection = self.settings["pure_convection"].GetBool()
+        if not pure_convection:
+            is_converged = self._GetSolutionStrategy().SolveSolutionStep()
+
+        return is_converged
+
+    #### Private functions ####
+    def _get_element_condition_replace_settings(self):
+        # Get and check domain size
+        domain_size = self.main_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE]
+        if domain_size not in (2,3):
+            raise Exception("DOMAIN_SIZE not set")
+
+        # Set pure diffusion elements
+        num_nodes_elements = 0
+        if (len(self.main_model_part.Elements) > 0):
+            for elem in self.main_model_part.Elements:
+                num_nodes_elements = len(elem.GetNodes())
+                break
+        num_nodes_elements = self.main_model_part.GetCommunicator().GetDataCommunicator().MaxAll(num_nodes_elements)
+
+        if domain_size == 2:
+            if num_nodes_elements == 3:
+                self.settings["element_replace_settings"]["element_name"].SetString("EulerianDiffusion2D3N")
+            else:
+                # TODO: Check that the EulerianDiffusion2D4N works!
+                # self.settings["element_replace_settings"]["element_name"].SetString("EulerianDiffusion2D4N")
+                err_msg = "EulerianDiffusion2D4N not exported yet."
+                raise Exception(err_msg)
+        else:
+            if num_nodes_elements == 4:
+                self.settings["element_replace_settings"]["element_name"].SetString("EulerianDiffusion3D4N")
+            else:
+                # TODO: Check that the EulerianDiffusion3D8N works!
+                # self.settings["element_replace_settings"]["element_name"].SetString("EulerianDiffusion3D8N")
+                err_msg = "EulerianDiffusion3D8N not exported yet."
+                raise Exception(err_msg)
+
+        # TODO: Create an auxiliary method to get this from the base
+        # Set thermal conditions
+        num_conditions = self.main_model_part.GetCommunicator().GetDataCommunicator().SumAll(len(self.main_model_part.Conditions))
+
+        if num_conditions > 0:
+            num_nodes_conditions = 0
+            if (len(self.main_model_part.Conditions) > 0):
+                for cond in self.main_model_part.Conditions:
+                    num_nodes_conditions = len(cond.GetNodes())
+                    break
+
+            num_nodes_conditions = self.main_model_part.GetCommunicator().GetDataCommunicator().MaxAll(num_nodes_conditions)
+
+            condition_name = self.settings["element_replace_settings"]["condition_name"].GetString()
+            if condition_name in ("FluxCondition","ThermalFace","Condition"):
+                name_string = "{0}{1}D{2}N".format(condition_name,domain_size, num_nodes_conditions)
+                self.settings["element_replace_settings"]["condition_name"].SetString(name_string)
+        else:
+            self.settings["element_replace_settings"]["condition_name"].SetString("")
+
+        return self.settings["element_replace_settings"]
+
+    def _GetBFECCConvection(self):
+        if not hasattr(self, '_bfecc_convection'):
+            self._bfecc_convection = self._CreateBFECCConvection()
+        return self._bfecc_convection
+
+    def _CreateScheme(self):
+        # Create a "fake" time scheme to perform the solution update
+        convection_diffusion_scheme = KratosMultiphysics.ResidualBasedIncrementalUpdateStaticScheme()
+        return convection_diffusion_scheme
+
+    def _CreateBFECCConvection(self):
+        # Create the locator for the BFECC convector
+        domain_size = self.GetComputingModelPart().ProcessInfo[KratosMultiphysics.DOMAIN_SIZE]
+        if domain_size == 2:
+            point_locator = KratosMultiphysics.BinBasedFastPointLocator2D(self.GetComputingModelPart())
+        elif domain_size == 3:
+            point_locator = KratosMultiphysics.BinBasedFastPointLocator3D(self.GetComputingModelPart())
+        else:
+            err_msg = "Wrong domain size: {0}".format(domain_size)
+            raise Exception(err_msg)
+
+        # Initialize the locator search database
+        point_locator.UpdateSearchDatabase()
+
+        # Create the BFECC convection utility
+        if domain_size ==2:
+            bfecc_utility = ConvectionDiffusionApplication.BFECCConvection2D(point_locator)
+        else:
+            bfecc_utility = ConvectionDiffusionApplication.BFECCConvection3D(point_locator)
+
+        return bfecc_utility
```

## KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_solver.py

 * *Ordering differences only*

```diff
@@ -1,53 +1,53 @@
-
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.ConvectionDiffusionApplication as ConvectionDiffusionApplication
-if KratosMultiphysics.ParallelEnvironment.GetDefaultDataCommunicator().IsDistributed():
-    import KratosMultiphysics.mpi as KratosMPI
-    import KratosMultiphysics.MetisApplication as KratosMetis
-    import KratosMultiphysics.TrilinosApplication as KratosTrilinos
-
-# Import base class file
-from KratosMultiphysics.ConvectionDiffusionApplication import convection_diffusion_solver
-
-def CreateSolver(main_model_part, custom_settings):
-    return ConvectionDiffusionStationarySolver(main_model_part, custom_settings)
-
-class ConvectionDiffusionStationarySolver(convection_diffusion_solver.ConvectionDiffusionSolver):
-    """The stationary class for convection-diffusion solvers.
-
-    Public member variables:
-    stationary_settings -- settings for the implicit dynamic solvers.
-
-    See convection_diffusion_solver.py for more information.
-    """
-
-    def __init__(self, main_model_part, custom_settings):
-
-        # Construct the base solver and validate the remaining settings in the base class
-        super(ConvectionDiffusionStationarySolver, self).__init__(main_model_part, custom_settings)
-
-        # Overwrite the base solver minimum buffer size
-        buffer_2_elems = ["EulerianConvDiff","AxisymmetricEulerianConvectionDiffusion2D3N","AxisymmetricEulerianConvectionDiffusion2D4N"] #TODO: Find a better solution
-        if self.settings["element_replace_settings"]["element_name"].GetString() in buffer_2_elems:
-            self.min_buffer_size = 2
-        else:
-            self.min_buffer_size = 1
-
-        KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "Construction finished")
-
-    #### Private functions ####
-    def _CreateScheme(self):
-        #Variable defining the temporal scheme (0: Forward Euler, 1: Backward Euler, 0.5: Crank-Nicolson)
-        self.GetComputingModelPart().ProcessInfo[KratosMultiphysics.TIME_INTEGRATION_THETA] = 1.0
-        self.GetComputingModelPart().ProcessInfo[KratosMultiphysics.DYNAMIC_TAU] = 0.0
-
-        # As the (no) time integration is managed by the element, we set a "fake" scheme to perform the solution update
-        if not self.main_model_part.IsDistributed():
-            convection_diffusion_scheme = KratosMultiphysics.ResidualBasedIncrementalUpdateStaticScheme()
-        else:
-            convection_diffusion_scheme = KratosTrilinos.TrilinosResidualBasedIncrementalUpdateStaticScheme()
-
-        return convection_diffusion_scheme
+
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.ConvectionDiffusionApplication as ConvectionDiffusionApplication
+if KratosMultiphysics.ParallelEnvironment.GetDefaultDataCommunicator().IsDistributed():
+    import KratosMultiphysics.mpi as KratosMPI
+    import KratosMultiphysics.MetisApplication as KratosMetis
+    import KratosMultiphysics.TrilinosApplication as KratosTrilinos
+
+# Import base class file
+from KratosMultiphysics.ConvectionDiffusionApplication import convection_diffusion_solver
+
+def CreateSolver(main_model_part, custom_settings):
+    return ConvectionDiffusionStationarySolver(main_model_part, custom_settings)
+
+class ConvectionDiffusionStationarySolver(convection_diffusion_solver.ConvectionDiffusionSolver):
+    """The stationary class for convection-diffusion solvers.
+
+    Public member variables:
+    stationary_settings -- settings for the implicit dynamic solvers.
+
+    See convection_diffusion_solver.py for more information.
+    """
+
+    def __init__(self, main_model_part, custom_settings):
+
+        # Construct the base solver and validate the remaining settings in the base class
+        super(ConvectionDiffusionStationarySolver, self).__init__(main_model_part, custom_settings)
+
+        # Overwrite the base solver minimum buffer size
+        buffer_2_elems = ["EulerianConvDiff","AxisymmetricEulerianConvectionDiffusion2D3N","AxisymmetricEulerianConvectionDiffusion2D4N"] #TODO: Find a better solution
+        if self.settings["element_replace_settings"]["element_name"].GetString() in buffer_2_elems:
+            self.min_buffer_size = 2
+        else:
+            self.min_buffer_size = 1
+
+        KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "Construction finished")
+
+    #### Private functions ####
+    def _CreateScheme(self):
+        #Variable defining the temporal scheme (0: Forward Euler, 1: Backward Euler, 0.5: Crank-Nicolson)
+        self.GetComputingModelPart().ProcessInfo[KratosMultiphysics.TIME_INTEGRATION_THETA] = 1.0
+        self.GetComputingModelPart().ProcessInfo[KratosMultiphysics.DYNAMIC_TAU] = 0.0
+
+        # As the (no) time integration is managed by the element, we set a "fake" scheme to perform the solution update
+        if not self.main_model_part.IsDistributed():
+            convection_diffusion_scheme = KratosMultiphysics.ResidualBasedIncrementalUpdateStaticScheme()
+        else:
+            convection_diffusion_scheme = KratosTrilinos.TrilinosResidualBasedIncrementalUpdateStaticScheme()
+
+        return convection_diffusion_scheme
```

## KratosMultiphysics/ConvectionDiffusionApplication/move_particle_utility_process.py

 * *Ordering differences only*

```diff
@@ -1,83 +1,83 @@
-import KratosMultiphysics as KM
-import KratosMultiphysics.ConvectionDiffusionApplication as CDA
-
-def Factory(settings, Model):
-    if not isinstance(settings, KM.Parameters):
-        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
-    return MoveParticleUtilityProcess(Model, settings["Parameters"])
-
-
-class MoveParticleUtilityProcess(KM.Process):
-    def __init__(self, model, settings):
-
-        KM.Process.__init__(self)
-
-        default_settings = KM.Parameters("""
-            {
-                "model_part_name"                 : "please_specify_model_part_name",
-                "use_mesh_velocity"               : false,
-                "reset_boundary_conditions"       : true
-            }
-            """
-            )
-
-        settings.ValidateAndAssignDefaults(default_settings)
-
-        self.model_part = model[settings["model_part_name"].GetString()]
-        self.use_mesh_velocity = settings["use_mesh_velocity"].GetBool()
-        self.reset_boundary_conditions = settings["reset_boundary_conditions"].GetBool()
-        KM.VariableUtils().SetNonHistoricalVariableToZero(KM.MEAN_SIZE, self.model_part.Elements)
-        KM.VariableUtils().SetNonHistoricalVariableToZero(KM.MEAN_VEL_OVER_ELEM_SIZE, self.model_part.Elements)
-
-    def Check(self):
-        settings = self.model_part.ProcessInfo[KM.CONVECTION_DIFFUSION_SETTINGS]
-        if not settings.IsDefinedUnknownVariable():
-            raise Exception('Unknown variable not defined in convection diffusion settings')
-        if not settings.IsDefinedProjectionVariable():
-            raise Exception('Projection variable not defined in convection diffusion settings')
-        if not settings.IsDefinedVelocityVariable():
-            raise Exception('Velocity variable not defined in convection diffusion settings')
-        if not settings.IsDefinedMeshVelocityVariable():
-            raise Exception('MeshVelocity variable not defined in convection diffusion settings')
-
-    def ExecuteBeforeSolutionLoop(self):
-        dimension = self.model_part.ProcessInfo[KM.DOMAIN_SIZE]
-        neighbor_search = KM.FindNodalNeighboursProcess(self.model_part)
-        neighbor_search.Execute()
-        neighbor_elements_search = KM.GenericFindElementalNeighboursProcess(self.model_part)
-        neighbor_elements_search.Execute()
-
-        settings = self.model_part.ProcessInfo[KM.CONVECTION_DIFFUSION_SETTINGS]
-        self.unknown_var = settings.GetUnknownVariable()
-        self.projection_var = settings.GetProjectionVariable()
-        self.velocity_var = settings.GetVelocityVariable()
-        self.mesh_velocity_var = settings.GetMeshVelocityVariable()
-
-        max_num_of_particles = 8 * dimension
-        if dimension == 2:
-            self.moveparticles = CDA.MoveParticleUtilityScalarTransport2D(self.model_part, max_num_of_particles)
-        else:
-            self.moveparticles = CDA.MoveParticleUtilityScalarTransport3D(self.model_part, max_num_of_particles)
-        self.moveparticles.MountBin()
-
-    def ExecuteInitializeSolutionStep(self):
-        if not self.use_mesh_velocity:
-            KM.VariableUtils().SetVectorVar(self.mesh_velocity_var, [0.0, 0.0, 0.0], self.model_part.Nodes)
-        self.moveparticles.CalculateVelOverElemSize()
-        self.moveparticles.MoveParticles()
-        dimension = self.model_part.ProcessInfo[KM.DOMAIN_SIZE]
-        pre_minimum_num_of_particles = dimension
-        self.moveparticles.PreReseed(pre_minimum_num_of_particles)
-        self.moveparticles.TransferLagrangianToEulerian()
-        KM.VariableUtils().CopyScalarVar(self.projection_var, self.unknown_var, self.model_part.Nodes)
-        if self.reset_boundary_conditions:
-            self.moveparticles.ResetBoundaryConditions()
-        self.moveparticles.CopyScalarVarToPreviousTimeStep(self.unknown_var, self.model_part.Nodes)
-
-    def ExecuteFinalizeSolutionStep(self):
-        self.moveparticles.CalculateDeltaVariables()
-        self.moveparticles.CorrectParticlesWithoutMovingUsingDeltaVariables()
-        dimension = self.model_part.ProcessInfo[KM.DOMAIN_SIZE]
-        post_minimum_num_of_particles = 2 * dimension
-        self.moveparticles.PostReseed(post_minimum_num_of_particles)
-
+import KratosMultiphysics as KM
+import KratosMultiphysics.ConvectionDiffusionApplication as CDA
+
+def Factory(settings, Model):
+    if not isinstance(settings, KM.Parameters):
+        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
+    return MoveParticleUtilityProcess(Model, settings["Parameters"])
+
+
+class MoveParticleUtilityProcess(KM.Process):
+    def __init__(self, model, settings):
+
+        KM.Process.__init__(self)
+
+        default_settings = KM.Parameters("""
+            {
+                "model_part_name"                 : "please_specify_model_part_name",
+                "use_mesh_velocity"               : false,
+                "reset_boundary_conditions"       : true
+            }
+            """
+            )
+
+        settings.ValidateAndAssignDefaults(default_settings)
+
+        self.model_part = model[settings["model_part_name"].GetString()]
+        self.use_mesh_velocity = settings["use_mesh_velocity"].GetBool()
+        self.reset_boundary_conditions = settings["reset_boundary_conditions"].GetBool()
+        KM.VariableUtils().SetNonHistoricalVariableToZero(KM.MEAN_SIZE, self.model_part.Elements)
+        KM.VariableUtils().SetNonHistoricalVariableToZero(KM.MEAN_VEL_OVER_ELEM_SIZE, self.model_part.Elements)
+
+    def Check(self):
+        settings = self.model_part.ProcessInfo[KM.CONVECTION_DIFFUSION_SETTINGS]
+        if not settings.IsDefinedUnknownVariable():
+            raise Exception('Unknown variable not defined in convection diffusion settings')
+        if not settings.IsDefinedProjectionVariable():
+            raise Exception('Projection variable not defined in convection diffusion settings')
+        if not settings.IsDefinedVelocityVariable():
+            raise Exception('Velocity variable not defined in convection diffusion settings')
+        if not settings.IsDefinedMeshVelocityVariable():
+            raise Exception('MeshVelocity variable not defined in convection diffusion settings')
+
+    def ExecuteBeforeSolutionLoop(self):
+        dimension = self.model_part.ProcessInfo[KM.DOMAIN_SIZE]
+        neighbor_search = KM.FindNodalNeighboursProcess(self.model_part)
+        neighbor_search.Execute()
+        neighbor_elements_search = KM.GenericFindElementalNeighboursProcess(self.model_part)
+        neighbor_elements_search.Execute()
+
+        settings = self.model_part.ProcessInfo[KM.CONVECTION_DIFFUSION_SETTINGS]
+        self.unknown_var = settings.GetUnknownVariable()
+        self.projection_var = settings.GetProjectionVariable()
+        self.velocity_var = settings.GetVelocityVariable()
+        self.mesh_velocity_var = settings.GetMeshVelocityVariable()
+
+        max_num_of_particles = 8 * dimension
+        if dimension == 2:
+            self.moveparticles = CDA.MoveParticleUtilityScalarTransport2D(self.model_part, max_num_of_particles)
+        else:
+            self.moveparticles = CDA.MoveParticleUtilityScalarTransport3D(self.model_part, max_num_of_particles)
+        self.moveparticles.MountBin()
+
+    def ExecuteInitializeSolutionStep(self):
+        if not self.use_mesh_velocity:
+            KM.VariableUtils().SetVectorVar(self.mesh_velocity_var, [0.0, 0.0, 0.0], self.model_part.Nodes)
+        self.moveparticles.CalculateVelOverElemSize()
+        self.moveparticles.MoveParticles()
+        dimension = self.model_part.ProcessInfo[KM.DOMAIN_SIZE]
+        pre_minimum_num_of_particles = dimension
+        self.moveparticles.PreReseed(pre_minimum_num_of_particles)
+        self.moveparticles.TransferLagrangianToEulerian()
+        KM.VariableUtils().CopyScalarVar(self.projection_var, self.unknown_var, self.model_part.Nodes)
+        if self.reset_boundary_conditions:
+            self.moveparticles.ResetBoundaryConditions()
+        self.moveparticles.CopyScalarVarToPreviousTimeStep(self.unknown_var, self.model_part.Nodes)
+
+    def ExecuteFinalizeSolutionStep(self):
+        self.moveparticles.CalculateDeltaVariables()
+        self.moveparticles.CorrectParticlesWithoutMovingUsingDeltaVariables()
+        dimension = self.model_part.ProcessInfo[KM.DOMAIN_SIZE]
+        post_minimum_num_of_particles = 2 * dimension
+        self.moveparticles.PostReseed(post_minimum_num_of_particles)
+
```

## KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_shifted_boundary_solver.py

 * *Ordering differences only*

```diff
@@ -1,115 +1,115 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.ConvectionDiffusionApplication as ConvectionDiffusionApplication
-
-# Import base class file
-from KratosMultiphysics.ConvectionDiffusionApplication import convection_diffusion_stationary_solver
-
-def CreateSolver(main_model_part, custom_settings):
-    return ConvectionDiffusionStationaryShiftedBoundarySolver(main_model_part, custom_settings)
-
-class ConvectionDiffusionStationaryShiftedBoundarySolver(convection_diffusion_stationary_solver.ConvectionDiffusionStationarySolver):
-    """The stationary class for convection-diffusion solvers.
-
-    Public member variables:
-    stationary_settings -- settings for the implicit dynamic solvers.
-
-    See convection_diffusion_solver.py for more information.
-    """
-
-    def __init__(self, main_model_part, custom_settings):
-        # Construct the base solver and validate the remaining settings in the base class
-        super().__init__(main_model_part, custom_settings)
-
-        # Overwrite the base solver minimum buffer size
-        self.min_buffer_size = 1
-
-        KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "Construction finished")
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KratosMultiphysics.Parameters(r"""{
-            "conforming_basis" : true,
-            "extension_operator_type" : "MLS",
-            "mls_extension_operator_order" : 1
-        }""")
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
-
-    def AddVariables(self):
-        # Add heat transfer required variables
-        super().AddVariables()
-
-        # Add distance variable to represent the skin
-        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.DISTANCE)
-
-    def Initialize(self):
-        # Avoid zeros with positive epsilon
-        tol = 1.0e-12
-        for node in self.GetComputingModelPart().Nodes:
-            dist = node.GetSolutionStepValue(KratosMultiphysics.DISTANCE)
-            if abs(dist) < tol:
-                node.SetSolutionStepValue(KratosMultiphysics.DISTANCE, 0, tol)
-
-        # Calculate the required neighbours
-        nodal_neighbours_process = KratosMultiphysics.FindGlobalNodalNeighboursProcess(self.main_model_part)
-        nodal_neighbours_process.Execute()
-        elemental_neighbours_process = KratosMultiphysics.GenericFindElementalNeighboursProcess(self.main_model_part)
-        elemental_neighbours_process.Execute()
-
-        # Create the boundary elements and MLS basis
-        settings = KratosMultiphysics.Parameters("""{}""")
-        settings.AddEmptyValue("model_part_name").SetString(self.main_model_part.Name)
-        settings.AddEmptyValue("boundary_sub_model_part_name").SetString("shifted_boundary")
-        settings.AddEmptyValue("conforming_basis").SetBool(self.settings["conforming_basis"].GetBool())
-        settings.AddEmptyValue("extension_operator_type").SetString(self.settings["extension_operator_type"].GetString())
-        settings.AddEmptyValue("mls_extension_operator_order").SetInt(self.settings["mls_extension_operator_order"].GetInt())
-        element_type = self.settings["element_replace_settings"]["element_name"].GetString()[:-4]
-        if element_type == "LaplacianShiftedBoundaryElement":
-            sbm_interface_condition_name = "LaplacianShiftedBoundaryCondition"
-        elif element_type == "MixedLaplacianShiftedBoundaryElement":
-            sbm_interface_condition_name = "MixedLaplacianShiftedBoundaryCondition"
-        else:
-            raise Exception(f"Unsupported \'element_type\': {element_type}")
-        settings.AddEmptyValue("sbm_interface_condition_name").SetString(sbm_interface_condition_name)
-        sbm_interface_utility = KratosMultiphysics.ShiftedBoundaryMeshlessInterfaceUtility(self.model, settings)
-        sbm_interface_utility.CalculateExtensionOperator()
-
-        # Initialize base solver strategy
-        super().Initialize()
-
-    def _get_element_condition_replace_settings(self):
-        domain_size = self.main_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE]
-        if domain_size not in (2,3):
-            raise Exception("DOMAIN_SIZE not set")
-
-        # Get element data
-        num_nodes_elements = 0
-        if (len(self.main_model_part.Elements) > 0):
-            for elem in self.main_model_part.Elements:
-                num_nodes_elements = len(elem.GetNodes())
-                break
-        num_nodes_elements = self.main_model_part.GetCommunicator().GetDataCommunicator().MaxAll(num_nodes_elements)
-        element_name = self.settings["element_replace_settings"]["element_name"].GetString()
-
-        # Element checks
-        if num_nodes_elements not in (3,4):
-            raise Exception("Only simplex elements are supported so far.")
-        supported_elements = ["LaplacianShiftedBoundaryElement", "MixedLaplacianShiftedBoundaryElement"]
-        if element_name not in supported_elements:
-            raise Exception("Only \'LaplacianShiftedBoundaryElement\' and \'MixedLaplacianShiftedBoundaryElement\' are supported so far.")
-
-        # Set registering element name
-        name_string = "{0}{1}D{2}N".format(element_name, domain_size, num_nodes_elements)
-        self.settings["element_replace_settings"]["element_name"].SetString(name_string)
-
-        # Set default conditions
-        condition_name = self.settings["element_replace_settings"]["condition_name"].GetString()
-        if condition_name != "":
-            KratosMultiphysics.Logger.PrintWarning("ConvectionDiffusionStationaryShiftedBoundarySolver", "Ignoring provided condition \'{}\'.".format(condition_name))
-        name_string = "LineCondition2D2N" if domain_size == 2 else "SurfaceCondition3D3N"
-        self.settings["element_replace_settings"]["condition_name"].SetString(name_string)
-
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.ConvectionDiffusionApplication as ConvectionDiffusionApplication
+
+# Import base class file
+from KratosMultiphysics.ConvectionDiffusionApplication import convection_diffusion_stationary_solver
+
+def CreateSolver(main_model_part, custom_settings):
+    return ConvectionDiffusionStationaryShiftedBoundarySolver(main_model_part, custom_settings)
+
+class ConvectionDiffusionStationaryShiftedBoundarySolver(convection_diffusion_stationary_solver.ConvectionDiffusionStationarySolver):
+    """The stationary class for convection-diffusion solvers.
+
+    Public member variables:
+    stationary_settings -- settings for the implicit dynamic solvers.
+
+    See convection_diffusion_solver.py for more information.
+    """
+
+    def __init__(self, main_model_part, custom_settings):
+        # Construct the base solver and validate the remaining settings in the base class
+        super().__init__(main_model_part, custom_settings)
+
+        # Overwrite the base solver minimum buffer size
+        self.min_buffer_size = 1
+
+        KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "Construction finished")
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KratosMultiphysics.Parameters(r"""{
+            "conforming_basis" : true,
+            "extension_operator_type" : "MLS",
+            "mls_extension_operator_order" : 1
+        }""")
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
+
+    def AddVariables(self):
+        # Add heat transfer required variables
+        super().AddVariables()
+
+        # Add distance variable to represent the skin
+        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.DISTANCE)
+
+    def Initialize(self):
+        # Avoid zeros with positive epsilon
+        tol = 1.0e-12
+        for node in self.GetComputingModelPart().Nodes:
+            dist = node.GetSolutionStepValue(KratosMultiphysics.DISTANCE)
+            if abs(dist) < tol:
+                node.SetSolutionStepValue(KratosMultiphysics.DISTANCE, 0, tol)
+
+        # Calculate the required neighbours
+        nodal_neighbours_process = KratosMultiphysics.FindGlobalNodalNeighboursProcess(self.main_model_part)
+        nodal_neighbours_process.Execute()
+        elemental_neighbours_process = KratosMultiphysics.GenericFindElementalNeighboursProcess(self.main_model_part)
+        elemental_neighbours_process.Execute()
+
+        # Create the boundary elements and MLS basis
+        settings = KratosMultiphysics.Parameters("""{}""")
+        settings.AddEmptyValue("model_part_name").SetString(self.main_model_part.Name)
+        settings.AddEmptyValue("boundary_sub_model_part_name").SetString("shifted_boundary")
+        settings.AddEmptyValue("conforming_basis").SetBool(self.settings["conforming_basis"].GetBool())
+        settings.AddEmptyValue("extension_operator_type").SetString(self.settings["extension_operator_type"].GetString())
+        settings.AddEmptyValue("mls_extension_operator_order").SetInt(self.settings["mls_extension_operator_order"].GetInt())
+        element_type = self.settings["element_replace_settings"]["element_name"].GetString()[:-4]
+        if element_type == "LaplacianShiftedBoundaryElement":
+            sbm_interface_condition_name = "LaplacianShiftedBoundaryCondition"
+        elif element_type == "MixedLaplacianShiftedBoundaryElement":
+            sbm_interface_condition_name = "MixedLaplacianShiftedBoundaryCondition"
+        else:
+            raise Exception(f"Unsupported \'element_type\': {element_type}")
+        settings.AddEmptyValue("sbm_interface_condition_name").SetString(sbm_interface_condition_name)
+        sbm_interface_utility = KratosMultiphysics.ShiftedBoundaryMeshlessInterfaceUtility(self.model, settings)
+        sbm_interface_utility.CalculateExtensionOperator()
+
+        # Initialize base solver strategy
+        super().Initialize()
+
+    def _get_element_condition_replace_settings(self):
+        domain_size = self.main_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE]
+        if domain_size not in (2,3):
+            raise Exception("DOMAIN_SIZE not set")
+
+        # Get element data
+        num_nodes_elements = 0
+        if (len(self.main_model_part.Elements) > 0):
+            for elem in self.main_model_part.Elements:
+                num_nodes_elements = len(elem.GetNodes())
+                break
+        num_nodes_elements = self.main_model_part.GetCommunicator().GetDataCommunicator().MaxAll(num_nodes_elements)
+        element_name = self.settings["element_replace_settings"]["element_name"].GetString()
+
+        # Element checks
+        if num_nodes_elements not in (3,4):
+            raise Exception("Only simplex elements are supported so far.")
+        supported_elements = ["LaplacianShiftedBoundaryElement", "MixedLaplacianShiftedBoundaryElement"]
+        if element_name not in supported_elements:
+            raise Exception("Only \'LaplacianShiftedBoundaryElement\' and \'MixedLaplacianShiftedBoundaryElement\' are supported so far.")
+
+        # Set registering element name
+        name_string = "{0}{1}D{2}N".format(element_name, domain_size, num_nodes_elements)
+        self.settings["element_replace_settings"]["element_name"].SetString(name_string)
+
+        # Set default conditions
+        condition_name = self.settings["element_replace_settings"]["condition_name"].GetString()
+        if condition_name != "":
+            KratosMultiphysics.Logger.PrintWarning("ConvectionDiffusionStationaryShiftedBoundarySolver", "Ignoring provided condition \'{}\'.".format(condition_name))
+        name_string = "LineCondition2D2N" if domain_size == 2 else "SurfaceCondition3D3N"
+        self.settings["element_replace_settings"]["condition_name"].SetString(name_string)
+
         return self.settings["element_replace_settings"]
```

## KratosMultiphysics/ConvectionDiffusionApplication/__init__.py

 * *Ordering differences only*

```diff
@@ -1,8 +1,8 @@
-
-# Application dependent names and paths
-from KratosMultiphysics import _ImportApplication
-from KratosConvectionDiffusionApplication import *
-application = KratosConvectionDiffusionApplication()
-application_name = "KratosConvectionDiffusionApplication"
-
-_ImportApplication(application, application_name)
+
+# Application dependent names and paths
+from KratosMultiphysics import _ImportApplication
+from KratosConvectionDiffusionApplication import *
+application = KratosConvectionDiffusionApplication()
+application_name = "KratosConvectionDiffusionApplication"
+
+_ImportApplication(application, application_name)
```

## KratosMultiphysics/ConvectionDiffusionApplication/apply_thermal_face_process.py

 * *Ordering differences only*

```diff
@@ -1,57 +1,57 @@
-import KratosMultiphysics
-import KratosMultiphysics.ConvectionDiffusionApplication as KratosConvDiff
-
-def Factory(settings, Model):
-    if(type(settings) != KratosMultiphysics.Parameters):
-        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
-    return ApplyThermalFaceProcess(Model, settings["Parameters"])
-
-
-class ApplyThermalFaceProcess(KratosMultiphysics.Process):
-    def __init__(self, Model, settings):
-        KratosMultiphysics.Process.__init__(self)
-
-        # Compare with default settings
-        default_settings = KratosMultiphysics.Parameters(r'''{
-            "model_part_name": "",
-            "ambient_temperature": 0.0,
-            "add_ambient_radiation": false,
-            "emissivity": 0.0,
-            "add_ambient_convection": false,
-            "convection_coefficient": 0.0,
-            "interval": [0.0,1e30]
-        }''')
-
-        settings.ValidateAndAssignDefaults(default_settings)
-
-        # Check input data
-        if (settings["model_part_name"].GetString() == ""):
-            raise Exception("Empty thermal face model part name string. Set a valid model part name.")
-        if not settings["ambient_temperature"].IsDouble():
-            raise Exception("Ambient temperature must be a constant value. Time dependency not implemented yet.")
-
-        # Search for the maximum property id in the current model
-        # Note that this operation is required to be performed after
-        # the properties have been already set by reading the materials.json
-        max_prop_id = -1
-        model_part_names = Model.GetModelPartNames()
-        model_part = Model.GetModelPart(settings["model_part_name"].GetString())
-        for model_part_name in model_part_names:
-            for prop in Model.GetModelPart(model_part_name).Properties:
-                if prop.Id > max_prop_id:
-                    max_prop_id = prop.Id
-        max_prop_id = model_part.GetCommunicator().GetDataCommunicator().MaxAll(max_prop_id)
-
-        # Create a new property with the user defined interface parameters
-        thermal_interface_prop = KratosMultiphysics.Properties(max_prop_id + 1)
-        emissivity = settings["emissivity"].GetDouble() if settings["add_ambient_radiation"].GetBool() else 0.0
-        convection_coefficient = settings["convection_coefficient"].GetDouble() if settings["add_ambient_convection"].GetBool() else 0.0
-        ambient_temperature = settings["ambient_temperature"].GetDouble() if (settings["add_ambient_convection"].GetBool() or settings["add_ambient_radiation"]) else 0.0
-        thermal_interface_prop.SetValue(KratosMultiphysics.EMISSIVITY, emissivity)
-        thermal_interface_prop.SetValue(KratosMultiphysics.CONVECTION_COEFFICIENT, convection_coefficient)
-        thermal_interface_prop.SetValue(KratosMultiphysics.AMBIENT_TEMPERATURE, ambient_temperature)
-
-        # Set the new property in the thermal face model part
-        model_part.AddProperties(thermal_interface_prop)
-        for condition in model_part.Conditions:
+import KratosMultiphysics
+import KratosMultiphysics.ConvectionDiffusionApplication as KratosConvDiff
+
+def Factory(settings, Model):
+    if(type(settings) != KratosMultiphysics.Parameters):
+        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
+    return ApplyThermalFaceProcess(Model, settings["Parameters"])
+
+
+class ApplyThermalFaceProcess(KratosMultiphysics.Process):
+    def __init__(self, Model, settings):
+        KratosMultiphysics.Process.__init__(self)
+
+        # Compare with default settings
+        default_settings = KratosMultiphysics.Parameters(r'''{
+            "model_part_name": "",
+            "ambient_temperature": 0.0,
+            "add_ambient_radiation": false,
+            "emissivity": 0.0,
+            "add_ambient_convection": false,
+            "convection_coefficient": 0.0,
+            "interval": [0.0,1e30]
+        }''')
+
+        settings.ValidateAndAssignDefaults(default_settings)
+
+        # Check input data
+        if (settings["model_part_name"].GetString() == ""):
+            raise Exception("Empty thermal face model part name string. Set a valid model part name.")
+        if not settings["ambient_temperature"].IsDouble():
+            raise Exception("Ambient temperature must be a constant value. Time dependency not implemented yet.")
+
+        # Search for the maximum property id in the current model
+        # Note that this operation is required to be performed after
+        # the properties have been already set by reading the materials.json
+        max_prop_id = -1
+        model_part_names = Model.GetModelPartNames()
+        model_part = Model.GetModelPart(settings["model_part_name"].GetString())
+        for model_part_name in model_part_names:
+            for prop in Model.GetModelPart(model_part_name).Properties:
+                if prop.Id > max_prop_id:
+                    max_prop_id = prop.Id
+        max_prop_id = model_part.GetCommunicator().GetDataCommunicator().MaxAll(max_prop_id)
+
+        # Create a new property with the user defined interface parameters
+        thermal_interface_prop = KratosMultiphysics.Properties(max_prop_id + 1)
+        emissivity = settings["emissivity"].GetDouble() if settings["add_ambient_radiation"].GetBool() else 0.0
+        convection_coefficient = settings["convection_coefficient"].GetDouble() if settings["add_ambient_convection"].GetBool() else 0.0
+        ambient_temperature = settings["ambient_temperature"].GetDouble() if (settings["add_ambient_convection"].GetBool() or settings["add_ambient_radiation"]) else 0.0
+        thermal_interface_prop.SetValue(KratosMultiphysics.EMISSIVITY, emissivity)
+        thermal_interface_prop.SetValue(KratosMultiphysics.CONVECTION_COEFFICIENT, convection_coefficient)
+        thermal_interface_prop.SetValue(KratosMultiphysics.AMBIENT_TEMPERATURE, ambient_temperature)
+
+        # Set the new property in the thermal face model part
+        model_part.AddProperties(thermal_interface_prop)
+        for condition in model_part.Conditions:
             condition.Properties = thermal_interface_prop
```

## KratosMultiphysics/ConvectionDiffusionApplication/coupled_structural_thermal_solver.py

 * *Ordering differences only*

```diff
@@ -1,175 +1,175 @@
-import sys
-
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as KratosSMA
-import KratosMultiphysics.ConvectionDiffusionApplication as ConvDiff
-
-# Importing the base class
-from KratosMultiphysics.python_solver import PythonSolver
-
-def CreateSolver(main_model_part, custom_settings):
-    return CoupledThermoMechanicalSolver(main_model_part, custom_settings)
-
-class CoupledThermoMechanicalSolver(PythonSolver):
-
-    @classmethod
-    def GetDefaultParameters(cls):
-
-        default_settings = KratosMultiphysics.Parameters("""
-        {
-            "solver_type" : "ThermoMechanicallyCoupled",
-            "domain_size" : -1,
-            "echo_level": 0,
-            "structural_solver_settings": {
-                "solver_type": "Static",
-                "model_part_name"                 : "Structure",
-                "domain_size"                     : 2,
-                "echo_level"                      : 1,
-                "analysis_type"                   : "non_linear",
-                "model_import_settings": {
-                    "input_type": "mdpa",
-                    "input_filename": "unknown_name"
-                },
-            "material_import_settings"        : {
-                "materials_filename" : "StructuralMaterials.json"
-            }
-            },
-            "thermal_solver_settings": {
-                "solver_type": "Transient",
-                "analysis_type": "linear",
-                "model_import_settings": {
-                    "input_type": "use_input_model_part"
-                },
-                "material_import_settings": {
-                        "materials_filename": "ThermalMaterials.json"
-                }
-            },
-            "time_integration_method": "implicit"
-        }
-        """)
-
-        default_settings.AddMissingParameters(super().GetDefaultParameters())
-        return default_settings
-
-    def __init__(self, model, custom_settings):
-
-        super(CoupledThermoMechanicalSolver, self).__init__(model, custom_settings)
-
-        ## Get domain size
-        self.domain_size = self.settings["domain_size"].GetInt()
-
-        from KratosMultiphysics.StructuralMechanicsApplication import python_solvers_wrapper_structural
-        self.structural_solver = python_solvers_wrapper_structural.CreateSolverByParameters(self.model, self.settings["structural_solver_settings"],"OpenMP")
-
-        from KratosMultiphysics.ConvectionDiffusionApplication import python_solvers_wrapper_convection_diffusion
-        self.thermal_solver = python_solvers_wrapper_convection_diffusion.CreateSolverByParameters(self.model,self.settings["thermal_solver_settings"],"OpenMP")
-        solver_type = self.settings["structural_solver_settings"]["solver_type"].GetString()
-        self.is_dynamic = solver_type == "dynamic"
-
-    def AddVariables(self):
-        # Import the structural and thermal solver variables. Then merge them to have them in both structural and thermal solvers.
-        self.structural_solver.AddVariables()
-        self.thermal_solver.AddVariables()
-        KratosMultiphysics.MergeVariableListsUtility().Merge(self.structural_solver.main_model_part, self.thermal_solver.main_model_part)
-
-    def ImportModelPart(self):
-        # Call the structural solver to import the model part from the mdpa
-        self.structural_solver.ImportModelPart()
-
-    def PrepareModelPart(self):
-        self.structural_solver.PrepareModelPart()
-
-        # Save the convection diffusion settings
-        convection_diffusion_settings = self.thermal_solver.main_model_part.ProcessInfo.GetValue(KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS)
-
-        # Here the structural model part is cloned to be thermal model part so that the nodes are shared
-        modeler = KratosMultiphysics.ConnectivityPreserveModeler()
-        if self.domain_size == 2:
-            modeler.GenerateModelPart(self.structural_solver.main_model_part,
-                                      self.thermal_solver.main_model_part,
-                                      "EulerianConvDiff2D",
-                                      "ThermalFace2D2N")
-        else:
-            modeler.GenerateModelPart(self.structural_solver.main_model_part,
-                                      self.thermal_solver.main_model_part,
-                                      "EulerianConvDiff3D",
-                                      "ThermalFace3D3N")
-
-        # Set the saved convection diffusion settings to the new thermal model part
-        self.thermal_solver.main_model_part.ProcessInfo.SetValue(KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS, convection_diffusion_settings)
-
-        self.thermal_solver.PrepareModelPart()
-
-    def AddDofs(self):
-        self.structural_solver.AddDofs()
-        self.thermal_solver.AddDofs()
-
-    def AdaptMesh(self):
-        pass
-
-    def GetComputingModelPart(self):
-        return self.structural_solver.GetComputingModelPart()
-
-    def GetOutputVariables(self):
-        pass
-
-    def GetMinimumBufferSize(self):
-        buffer_size_fluid = self.structural_solver.GetMinimumBufferSize()
-        buffer_size_thermal = self.thermal_solver.GetMinimumBufferSize()
-        return max(buffer_size_fluid, buffer_size_thermal)
-
-    def Initialize(self):
-        self.structural_solver.Initialize()
-        self.thermal_solver.Initialize()
-
-    def Clear(self):
-        (self.structural_solver).Clear()
-        (self.thermal_solver).Clear()
-
-    def Check(self):
-        (self.structural_solver).Check()
-        (self.thermal_solver).Check()
-
-    def SetEchoLevel(self, level):
-        (self.structural_solver).SetEchoLevel(level)
-        (self.thermal_solver).SetEchoLevel(level)
-
-    def AdvanceInTime(self, current_time):
-        #NOTE: the cloning is done ONLY ONCE since the nodes are shared
-        new_time = self.structural_solver.AdvanceInTime(current_time)
-        return new_time
-
-    def InitializeSolutionStep(self):
-        pass
-
-    def Predict(self):
-        pass
-
-    def SolveSolutionStep(self):
-        self.thermal_solver.InitializeSolutionStep()
-        self.thermal_solver.Predict()
-
-        KratosMultiphysics.Logger.PrintInfo("\t" + "Solving THERMAL part...")
-        thermal_is_converged = self.thermal_solver.SolveSolutionStep()
-
-        self.structural_solver.InitializeSolutionStep()
-
-        self.structural_solver.Predict()
-
-        KratosMultiphysics.Logger.PrintInfo("\t" + "Solving STRUCTURAL part...")
-        solid_is_converged = self.structural_solver.SolveSolutionStep()
-
-        self.RemoveConvectiveVelocity()
-
-        return solid_is_converged and thermal_is_converged
-
-    def FinalizeSolutionStep(self):
-        self.structural_solver.FinalizeSolutionStep()
-        self.thermal_solver.FinalizeSolutionStep()
-
-    def RemoveConvectiveVelocity(self):
-        if self.is_dynamic:
+import sys
+
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as KratosSMA
+import KratosMultiphysics.ConvectionDiffusionApplication as ConvDiff
+
+# Importing the base class
+from KratosMultiphysics.python_solver import PythonSolver
+
+def CreateSolver(main_model_part, custom_settings):
+    return CoupledThermoMechanicalSolver(main_model_part, custom_settings)
+
+class CoupledThermoMechanicalSolver(PythonSolver):
+
+    @classmethod
+    def GetDefaultParameters(cls):
+
+        default_settings = KratosMultiphysics.Parameters("""
+        {
+            "solver_type" : "ThermoMechanicallyCoupled",
+            "domain_size" : -1,
+            "echo_level": 0,
+            "structural_solver_settings": {
+                "solver_type": "Static",
+                "model_part_name"                 : "Structure",
+                "domain_size"                     : 2,
+                "echo_level"                      : 1,
+                "analysis_type"                   : "non_linear",
+                "model_import_settings": {
+                    "input_type": "mdpa",
+                    "input_filename": "unknown_name"
+                },
+            "material_import_settings"        : {
+                "materials_filename" : "StructuralMaterials.json"
+            }
+            },
+            "thermal_solver_settings": {
+                "solver_type": "Transient",
+                "analysis_type": "linear",
+                "model_import_settings": {
+                    "input_type": "use_input_model_part"
+                },
+                "material_import_settings": {
+                        "materials_filename": "ThermalMaterials.json"
+                }
+            },
+            "time_integration_method": "implicit"
+        }
+        """)
+
+        default_settings.AddMissingParameters(super().GetDefaultParameters())
+        return default_settings
+
+    def __init__(self, model, custom_settings):
+
+        super(CoupledThermoMechanicalSolver, self).__init__(model, custom_settings)
+
+        ## Get domain size
+        self.domain_size = self.settings["domain_size"].GetInt()
+
+        from KratosMultiphysics.StructuralMechanicsApplication import python_solvers_wrapper_structural
+        self.structural_solver = python_solvers_wrapper_structural.CreateSolverByParameters(self.model, self.settings["structural_solver_settings"],"OpenMP")
+
+        from KratosMultiphysics.ConvectionDiffusionApplication import python_solvers_wrapper_convection_diffusion
+        self.thermal_solver = python_solvers_wrapper_convection_diffusion.CreateSolverByParameters(self.model,self.settings["thermal_solver_settings"],"OpenMP")
+        solver_type = self.settings["structural_solver_settings"]["solver_type"].GetString()
+        self.is_dynamic = solver_type == "dynamic"
+
+    def AddVariables(self):
+        # Import the structural and thermal solver variables. Then merge them to have them in both structural and thermal solvers.
+        self.structural_solver.AddVariables()
+        self.thermal_solver.AddVariables()
+        KratosMultiphysics.MergeVariableListsUtility().Merge(self.structural_solver.main_model_part, self.thermal_solver.main_model_part)
+
+    def ImportModelPart(self):
+        # Call the structural solver to import the model part from the mdpa
+        self.structural_solver.ImportModelPart()
+
+    def PrepareModelPart(self):
+        self.structural_solver.PrepareModelPart()
+
+        # Save the convection diffusion settings
+        convection_diffusion_settings = self.thermal_solver.main_model_part.ProcessInfo.GetValue(KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS)
+
+        # Here the structural model part is cloned to be thermal model part so that the nodes are shared
+        modeler = KratosMultiphysics.ConnectivityPreserveModeler()
+        if self.domain_size == 2:
+            modeler.GenerateModelPart(self.structural_solver.main_model_part,
+                                      self.thermal_solver.main_model_part,
+                                      "EulerianConvDiff2D",
+                                      "ThermalFace2D2N")
+        else:
+            modeler.GenerateModelPart(self.structural_solver.main_model_part,
+                                      self.thermal_solver.main_model_part,
+                                      "EulerianConvDiff3D",
+                                      "ThermalFace3D3N")
+
+        # Set the saved convection diffusion settings to the new thermal model part
+        self.thermal_solver.main_model_part.ProcessInfo.SetValue(KratosMultiphysics.CONVECTION_DIFFUSION_SETTINGS, convection_diffusion_settings)
+
+        self.thermal_solver.PrepareModelPart()
+
+    def AddDofs(self):
+        self.structural_solver.AddDofs()
+        self.thermal_solver.AddDofs()
+
+    def AdaptMesh(self):
+        pass
+
+    def GetComputingModelPart(self):
+        return self.structural_solver.GetComputingModelPart()
+
+    def GetOutputVariables(self):
+        pass
+
+    def GetMinimumBufferSize(self):
+        buffer_size_fluid = self.structural_solver.GetMinimumBufferSize()
+        buffer_size_thermal = self.thermal_solver.GetMinimumBufferSize()
+        return max(buffer_size_fluid, buffer_size_thermal)
+
+    def Initialize(self):
+        self.structural_solver.Initialize()
+        self.thermal_solver.Initialize()
+
+    def Clear(self):
+        (self.structural_solver).Clear()
+        (self.thermal_solver).Clear()
+
+    def Check(self):
+        (self.structural_solver).Check()
+        (self.thermal_solver).Check()
+
+    def SetEchoLevel(self, level):
+        (self.structural_solver).SetEchoLevel(level)
+        (self.thermal_solver).SetEchoLevel(level)
+
+    def AdvanceInTime(self, current_time):
+        #NOTE: the cloning is done ONLY ONCE since the nodes are shared
+        new_time = self.structural_solver.AdvanceInTime(current_time)
+        return new_time
+
+    def InitializeSolutionStep(self):
+        pass
+
+    def Predict(self):
+        pass
+
+    def SolveSolutionStep(self):
+        self.thermal_solver.InitializeSolutionStep()
+        self.thermal_solver.Predict()
+
+        KratosMultiphysics.Logger.PrintInfo("\t" + "Solving THERMAL part...")
+        thermal_is_converged = self.thermal_solver.SolveSolutionStep()
+
+        self.structural_solver.InitializeSolutionStep()
+
+        self.structural_solver.Predict()
+
+        KratosMultiphysics.Logger.PrintInfo("\t" + "Solving STRUCTURAL part...")
+        solid_is_converged = self.structural_solver.SolveSolutionStep()
+
+        self.RemoveConvectiveVelocity()
+
+        return solid_is_converged and thermal_is_converged
+
+    def FinalizeSolutionStep(self):
+        self.structural_solver.FinalizeSolutionStep()
+        self.thermal_solver.FinalizeSolutionStep()
+
+    def RemoveConvectiveVelocity(self):
+        if self.is_dynamic:
             KratosMultiphysics.VariableUtils().CopyModelPartNodalVar(KratosMultiphysics.VELOCITY, KratosMultiphysics.MESH_VELOCITY, self.thermal_solver.GetComputingModelPart(), self.thermal_solver.GetComputingModelPart(), 0)
```

## KratosMultiphysics/ConvectionDiffusionApplication/python_solvers_wrapper_convection_diffusion.py

 * *Ordering differences only*

```diff
@@ -1,110 +1,110 @@
-
-import KratosMultiphysics
-from importlib import import_module
-
-def CreateSolverByParameters(model, solver_settings, parallelism):
-
-    if (type(model) != KratosMultiphysics.Model):
-        raise Exception("input is expected to be provided as a Kratos Model object")
-
-    if (type(solver_settings) != KratosMultiphysics.Parameters):
-        raise Exception("input is expected to be provided as a Kratos Parameters object")
-
-    solver_type = solver_settings["solver_type"].GetString()
-
-    # Solvers for OpenMP parallelism
-    if (parallelism == "OpenMP"):
-        # Transient solvers
-        if (solver_type == "transient" or solver_type == "Transient"):
-            # If not provided, set implicit time integration as default
-            if not solver_settings.Has("time_integration_method"):
-                KratosMultiphysics.Logger.PrintWarning("Time integration method was not provided. Setting \'implicit\' as default.")
-                solver_settings.AddEmptyValue("time_integration_method").SetString("implicit")
-            time_integration_method = solver_settings["time_integration_method"].GetString()
-            # Check transient integration method
-            if time_integration_method == "implicit":
-                solver_module_name = "convection_diffusion_transient_solver"
-            elif time_integration_method == "explicit":
-                solver_module_name = "convection_diffusion_explicit_solver"
-            elif time_integration_method == "semi_implicit":
-                solver_module_name = "convection_diffusion_semi_eulerian_solver"
-            else:
-                err_msg =  "The requested time integration method {} is not in the Python solvers wrapper\n".format(time_integration_method)
-                err_msg += "Available options are: \"explicit\", \"implicit\" and \"semi_implicit\""
-                raise Exception(err_msg)
-        # Steady solver
-        elif (solver_type == "stationary" or solver_type == "Stationary"):
-            solver_module_name = "convection_diffusion_stationary_solver"
-        # Steady Shifted Boundary Method (SBM) solver
-        elif solver_type == "stationary_shifted_boundary":
-            solver_module_name = "convection_diffusion_stationary_shifted_boundary_solver"
-        # Steady embedded (CutFEM) solver
-        elif solver_type == "stationary_embedded":
-            solver_module_name = "convection_diffusion_stationary_embedded_solver"
-        # Auxiliary solver to generate the stationary system matrix
-        elif (solver_type == "stationary_matrix"):
-            solver_module_name = "convection_diffusion_stationary_matrix_solver"
-        # Coupled CFD-thermal solvers (volume coupling by Boussinesq approximation)
-        elif (solver_type == "thermally_coupled" or solver_type == "ThermallyCoupled"):
-            solver_module_name = "coupled_fluid_thermal_solver"
-        # Coupled mechanical-thermal solver
-        elif (solver_type == "thermo_mechanically_coupled" or solver_type == "ThermoMechanicallyCoupled"):
-            solver_module_name = "coupled_structural_thermal_solver"
-        # Coupled CHT solver (space thermal - CFD-thermal coupling)
-        elif (solver_type == "conjugate_heat_transfer" or solver_type == "ConjugateHeatTransfer"):
-            solver_module_name = "conjugate_heat_transfer_solver"
-        # Steady adjoints solver
-        elif solver_type == "adjoint_stationary":
-            solver_module_name = "adjoint_diffusion_solver"
-        # Wrong solver check
-        else:
-            err_msg =  "The requested solver type {} is not in the python solvers wrapper\n".format(solver_type)
-            err_msg += "Available options are: \"transient\", \"stationary\", \"thermally_coupled\", \"thermo_mechanically_coupled\", \"conjugate_heat_transfer\" and \"adjoint_stationary\""
-            raise Exception(err_msg)
-
-    # Solvers for MPI parallelism
-    elif (parallelism == "MPI"):
-        # Transient solvers
-        if (solver_type == "transient" or solver_type == "Transient"):
-            # If not provided, set implicit time integration as default
-            if not solver_settings.Has("time_integration_method"):
-                KratosMultiphysics.Logger.PrintWarning("Time integration method was not provided. Setting \'implicit\' as default.")
-                solver_settings.AddEmptyValue("time_integration_method").SetString("implicit")
-            time_integration_method = solver_settings["time_integration_method"].GetString()
-            # Check transient integration method
-            if time_integration_method == "implicit":
-                solver_module_name = "convection_diffusion_transient_solver"
-            else:
-                err_msg =  "The requested time integration method {} is not MPI available yet\n".format(time_integration_method)
-                err_msg += "Available option is \"implicit\""
-                raise Exception(err_msg)
-        # Steady solver
-        elif (solver_type == "stationary" or solver_type == "Stationary"):
-            solver_module_name = "convection_diffusion_stationary_solver"
-        # Wrong solver check
-        else:
-            err_msg =  "The requested solver type {} is not MPI available yet\n".format(solver_type)
-            err_msg += "Available options are: \"transient\" and \"stationary\""
-            raise Exception(err_msg)
-    else:
-        err_msg =  "The requested parallel type \"" + parallelism + "\" is not available!\n"
-        err_msg += "Available options are: \"OpenMP\", \"MPI\""
-        raise Exception(err_msg)
-
-    module_full = 'KratosMultiphysics.ConvectionDiffusionApplication.' + solver_module_name
-    solver = import_module(module_full).CreateSolver(model, solver_settings)
-
-    return solver
-
-def CreateSolver(model, custom_settings):
-
-    if (type(model) != KratosMultiphysics.Model):
-        raise Exception("input is expected to be provided as a Kratos Model object")
-
-    if (type(custom_settings) != KratosMultiphysics.Parameters):
-        raise Exception("input is expected to be provided as a Kratos Parameters object")
-
-    parallelism = custom_settings["problem_data"]["parallel_type"].GetString()
-    solver_settings = custom_settings["solver_settings"]
-
-    return CreateSolverByParameters(model, solver_settings, parallelism)
+
+import KratosMultiphysics
+from importlib import import_module
+
+def CreateSolverByParameters(model, solver_settings, parallelism):
+
+    if (type(model) != KratosMultiphysics.Model):
+        raise Exception("input is expected to be provided as a Kratos Model object")
+
+    if (type(solver_settings) != KratosMultiphysics.Parameters):
+        raise Exception("input is expected to be provided as a Kratos Parameters object")
+
+    solver_type = solver_settings["solver_type"].GetString()
+
+    # Solvers for OpenMP parallelism
+    if (parallelism == "OpenMP"):
+        # Transient solvers
+        if (solver_type == "transient" or solver_type == "Transient"):
+            # If not provided, set implicit time integration as default
+            if not solver_settings.Has("time_integration_method"):
+                KratosMultiphysics.Logger.PrintWarning("Time integration method was not provided. Setting \'implicit\' as default.")
+                solver_settings.AddEmptyValue("time_integration_method").SetString("implicit")
+            time_integration_method = solver_settings["time_integration_method"].GetString()
+            # Check transient integration method
+            if time_integration_method == "implicit":
+                solver_module_name = "convection_diffusion_transient_solver"
+            elif time_integration_method == "explicit":
+                solver_module_name = "convection_diffusion_explicit_solver"
+            elif time_integration_method == "semi_implicit":
+                solver_module_name = "convection_diffusion_semi_eulerian_solver"
+            else:
+                err_msg =  "The requested time integration method {} is not in the Python solvers wrapper\n".format(time_integration_method)
+                err_msg += "Available options are: \"explicit\", \"implicit\" and \"semi_implicit\""
+                raise Exception(err_msg)
+        # Steady solver
+        elif (solver_type == "stationary" or solver_type == "Stationary"):
+            solver_module_name = "convection_diffusion_stationary_solver"
+        # Steady Shifted Boundary Method (SBM) solver
+        elif solver_type == "stationary_shifted_boundary":
+            solver_module_name = "convection_diffusion_stationary_shifted_boundary_solver"
+        # Steady embedded (CutFEM) solver
+        elif solver_type == "stationary_embedded":
+            solver_module_name = "convection_diffusion_stationary_embedded_solver"
+        # Auxiliary solver to generate the stationary system matrix
+        elif (solver_type == "stationary_matrix"):
+            solver_module_name = "convection_diffusion_stationary_matrix_solver"
+        # Coupled CFD-thermal solvers (volume coupling by Boussinesq approximation)
+        elif (solver_type == "thermally_coupled" or solver_type == "ThermallyCoupled"):
+            solver_module_name = "coupled_fluid_thermal_solver"
+        # Coupled mechanical-thermal solver
+        elif (solver_type == "thermo_mechanically_coupled" or solver_type == "ThermoMechanicallyCoupled"):
+            solver_module_name = "coupled_structural_thermal_solver"
+        # Coupled CHT solver (space thermal - CFD-thermal coupling)
+        elif (solver_type == "conjugate_heat_transfer" or solver_type == "ConjugateHeatTransfer"):
+            solver_module_name = "conjugate_heat_transfer_solver"
+        # Steady adjoints solver
+        elif solver_type == "adjoint_stationary":
+            solver_module_name = "adjoint_diffusion_solver"
+        # Wrong solver check
+        else:
+            err_msg =  "The requested solver type {} is not in the python solvers wrapper\n".format(solver_type)
+            err_msg += "Available options are: \"transient\", \"stationary\", \"thermally_coupled\", \"thermo_mechanically_coupled\", \"conjugate_heat_transfer\" and \"adjoint_stationary\""
+            raise Exception(err_msg)
+
+    # Solvers for MPI parallelism
+    elif (parallelism == "MPI"):
+        # Transient solvers
+        if (solver_type == "transient" or solver_type == "Transient"):
+            # If not provided, set implicit time integration as default
+            if not solver_settings.Has("time_integration_method"):
+                KratosMultiphysics.Logger.PrintWarning("Time integration method was not provided. Setting \'implicit\' as default.")
+                solver_settings.AddEmptyValue("time_integration_method").SetString("implicit")
+            time_integration_method = solver_settings["time_integration_method"].GetString()
+            # Check transient integration method
+            if time_integration_method == "implicit":
+                solver_module_name = "convection_diffusion_transient_solver"
+            else:
+                err_msg =  "The requested time integration method {} is not MPI available yet\n".format(time_integration_method)
+                err_msg += "Available option is \"implicit\""
+                raise Exception(err_msg)
+        # Steady solver
+        elif (solver_type == "stationary" or solver_type == "Stationary"):
+            solver_module_name = "convection_diffusion_stationary_solver"
+        # Wrong solver check
+        else:
+            err_msg =  "The requested solver type {} is not MPI available yet\n".format(solver_type)
+            err_msg += "Available options are: \"transient\" and \"stationary\""
+            raise Exception(err_msg)
+    else:
+        err_msg =  "The requested parallel type \"" + parallelism + "\" is not available!\n"
+        err_msg += "Available options are: \"OpenMP\", \"MPI\""
+        raise Exception(err_msg)
+
+    module_full = 'KratosMultiphysics.ConvectionDiffusionApplication.' + solver_module_name
+    solver = import_module(module_full).CreateSolver(model, solver_settings)
+
+    return solver
+
+def CreateSolver(model, custom_settings):
+
+    if (type(model) != KratosMultiphysics.Model):
+        raise Exception("input is expected to be provided as a Kratos Model object")
+
+    if (type(custom_settings) != KratosMultiphysics.Parameters):
+        raise Exception("input is expected to be provided as a Kratos Parameters object")
+
+    parallelism = custom_settings["problem_data"]["parallel_type"].GetString()
+    solver_settings = custom_settings["solver_settings"]
+
+    return CreateSolverByParameters(model, solver_settings, parallelism)
```

## Comparing `KratosConvectionDiffusionApplication-9.5.dist-info/METADATA` & `KratosConvectionDiffusionApplication-9.5.1.dist-info/METADATA`

 * *Files 10% similar despite different names*

```diff
@@ -1,65 +1,66 @@
-Metadata-Version: 2.1
-Name: KratosConvectionDiffusionApplication
-Version: 9.5
-Summary: KRATOS Multiphysics ("Kratos") is a framework for building parallel, multi-disciplinary simulation software, aiming at modularity, extensibility, and high performance. Kratos is written in C++, and counts with an extensive Python interface.
-Home-page: https://github.com/KratosMultiphysics/
-Author: Kratos Team
-Author-email: kratos@listas.cimne.upc.edu
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: C++
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: Topic :: Scientific/Engineering
-Classifier: Topic :: Scientific/Engineering :: Physics
-Classifier: Topic :: Scientific/Engineering :: Mathematics
-Classifier: Natural Language :: English
-Classifier: Intended Audience :: Science/Research
-Classifier: Intended Audience :: Other Audience
-Classifier: Intended Audience :: Developers
-Classifier: Development Status :: 5 - Production/Stable
-Classifier: Environment :: Console
-Classifier: License :: OSI Approved :: BSD License
-Requires-Python: >=3.8
-Description-Content-Type: text/markdown
-Requires-Dist: KratosMultiphysics ==9.5
-
- 
-## Convection Diffusion Application  
-  
-The Convection DIffusion Application contains a series of elements and conditions and the corresponding strategies and solvers within Kratos Multiphysics necesaries in order to simulate a convection-diffusion problem.  
- 
-<p align="center"> 
-  <img src="https://raw.githubusercontent.com/KratosMultiphysics/Documentation/master/Readme_files/ConvectionDiffusionApplication.png" alt="Solution" style="width: 600px;"/> 
-</p> 
-  
-The application includes tests to check the proper functioning of the application 
-  
-### Features:  
-  
-- A set of *Neumann* conditions:
-     * Flux conditions
-     * Thermal conditions
-    
-- Elements:
-    * Laplacian element (both 2D/3D)
-    * Eulerian convection-diffusion (both 2D/3D)
-    * Convection-diffusion (both 2D/3D)
-    * Convection-diffusion with change of phase (2D)
-    * Explicit eulerian convection-diffusion (both 2D/3D)
-       	
-- Strategies:
-	* Non-linear/linear convection-diffusion strategy
-	* Eulerian convection-diffusion strategy
-	* Semi-Eulerian convection-diffusion strategy
-	
-- Utilities and others:
-	* BFECC convection utility
-	* BFECC elemental limiter convection utility
-	* Convection particle
-	* Face-heat utilities
-	* Move particle utility
-	* Pure convection tools
-	* Pure convection (Crank-Nicolson) tools
+Metadata-Version: 2.1
+Name: KratosConvectionDiffusionApplication
+Version: 9.5.1
+Summary: KRATOS Multiphysics ("Kratos") is a framework for building parallel, multi-disciplinary simulation software, aiming at modularity, extensibility, and high performance. Kratos is written in C++, and counts with an extensive Python interface.
+Home-page: https://github.com/KratosMultiphysics/
+Author: Kratos Team
+Author-email: kratos@listas.cimne.upc.edu
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: C++
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
+Classifier: Topic :: Scientific/Engineering
+Classifier: Topic :: Scientific/Engineering :: Physics
+Classifier: Topic :: Scientific/Engineering :: Mathematics
+Classifier: Natural Language :: English
+Classifier: Intended Audience :: Science/Research
+Classifier: Intended Audience :: Other Audience
+Classifier: Intended Audience :: Developers
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: Environment :: Console
+Classifier: License :: OSI Approved :: BSD License
+Requires-Python: >=3.8
+Description-Content-Type: text/markdown
+Requires-Dist: KratosMultiphysics ==9.5.1
+
+ 
+## Convection Diffusion Application  
+  
+The Convection DIffusion Application contains a series of elements and conditions and the corresponding strategies and solvers within Kratos Multiphysics necesaries in order to simulate a convection-diffusion problem.  
+ 
+<p align="center"> 
+  <img src="https://raw.githubusercontent.com/KratosMultiphysics/Documentation/master/Readme_files/ConvectionDiffusionApplication.png" alt="Solution" style="width: 600px;"/> 
+</p> 
+  
+The application includes tests to check the proper functioning of the application 
+  
+### Features:  
+  
+- A set of *Neumann* conditions:
+     * Flux conditions
+     * Thermal conditions
+    
+- Elements:
+    * Laplacian element (both 2D/3D)
+    * Eulerian convection-diffusion (both 2D/3D)
+    * Convection-diffusion (both 2D/3D)
+    * Convection-diffusion with change of phase (2D)
+    * Explicit eulerian convection-diffusion (both 2D/3D)
+       	
+- Strategies:
+	* Non-linear/linear convection-diffusion strategy
+	* Eulerian convection-diffusion strategy
+	* Semi-Eulerian convection-diffusion strategy
+	
+- Utilities and others:
+	* BFECC convection utility
+	* BFECC elemental limiter convection utility
+	* Convection particle
+	* Face-heat utilities
+	* Move particle utility
+	* Pure convection tools
+	* Pure convection (Crank-Nicolson) tools
```

## Comparing `KratosConvectionDiffusionApplication-9.5.dist-info/RECORD` & `KratosConvectionDiffusionApplication-9.5.1.dist-info/RECORD`

 * *Files 12% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-KratosConvectionDiffusionApplication-9.5.dist-info/METADATA,sha256=nivjus5sUJpzoQahnTgQT0TcVDB5YrTXEGfz0L2tSF8,2670
-KratosConvectionDiffusionApplication-9.5.dist-info/WHEEL,sha256=rY0Y6THYM7EImsHfF-zs67o8pQciAsMw9_YuSvftjrQ,148
-KratosConvectionDiffusionApplication-9.5.dist-info/top_level.txt,sha256=8Ov--opRCptLbHStjyiZUVpzN1OUU_F7c7fGmsR5cMc,19
-KratosConvectionDiffusionApplication-9.5.dist-info/RECORD,,
-KratosMultiphysics/.libs/libKratosConvectionDiffusionCore.so,sha256=bVKC-WicxTi6NN9CQlQa7CTvm3_mjwxFm7mlRdPvQRY,7722681
-KratosMultiphysics/.libs/KratosConvectionDiffusionApplication.cpython-39-x86_64-linux-gnu.so,sha256=uJjyI9O49XS_x41RiFAHx_cQHwrcVe3F43-4PuEdKg0,4287857
-KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_explicit_solver.py,sha256=dE1nM6jva7cDabVX2pfKwjf7lwOg5r0aZTIfwJW5k0Q,3461
-KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_matrix_solver.py,sha256=Zw3EslazrdGKaHo5_56ZJ401zuecpCvIV7PV6NzlbKI,3342
-KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_embedded_solver.py,sha256=9P-Wo51h0U5e6k3Gd2sOaPrFpOOZHPC52lHSO5GxsAY,7701
-KratosMultiphysics/ConvectionDiffusionApplication/conjugate_heat_transfer_solver.py,sha256=-16OgsinS1lEIA6B2G3M3XeUBA4Q0AKfPfYl1E53s7c,28624
-KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_analysis.py,sha256=SSKJYKGoUD7jDkzi6ZsRhCo52yYO9KMMSSEEVyZfdb8,2634
-KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_transient_solver.py,sha256=HSPreICR4nf3QwTMgVKkgCl5wlMozQz4hRyEkxPie_c,2671
-KratosMultiphysics/ConvectionDiffusionApplication/coupled_fluid_thermal_solver.py,sha256=CKzVrag5XnspN4tNZ--wtyXgCuRV1r-KhRv9eNkqlJ0,7782
-KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_solver.py,sha256=gu0UAmW66CGNaLAIsrrZqsIrYUqfjQflGfnyA9KIwNQ,45051
-KratosMultiphysics/ConvectionDiffusionApplication/adjoint_diffusion_solver.py,sha256=fahAw6U_u9GLoZVwvvPlkU73soIl6_0FMIVYs1KcVyU,11985
-KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_semi_eulerian_solver.py,sha256=0lFQOvrBFdxcstjCiNPaL18J9-wyWRAzCin9zD6ECMw,7131
-KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_solver.py,sha256=e7PbSumZkanDwixtIzcyPT3hgDAearuLdXpfqdMELgA,2577
-KratosMultiphysics/ConvectionDiffusionApplication/move_particle_utility_process.py,sha256=PZ74hYCUOAmpeTQWy90ZOQwOEPTHsLKDCfz4UO0uZMg,4206
-KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_shifted_boundary_solver.py,sha256=UXHVwXUooDAE8gipGw68l_v1skfjuxQZLY14NTd3iTI,5907
-KratosMultiphysics/ConvectionDiffusionApplication/__init__.py,sha256=zzG4cLAGkc3k8ssVg-MS520z-rKNGQZeg_g9r7eZSCY,304
-KratosMultiphysics/ConvectionDiffusionApplication/apply_thermal_face_process.py,sha256=dxtvUIQE2Pg-rufHYetPLfEi2kgpwI1cls6el80Fxbw,3085
-KratosMultiphysics/ConvectionDiffusionApplication/coupled_structural_thermal_solver.py,sha256=5OwpL8LYdq2cok41NdbfK684KT3aYVU81aihSb8Y5xI,7071
-KratosMultiphysics/ConvectionDiffusionApplication/python_solvers_wrapper_convection_diffusion.py,sha256=LQQ3ItdnunaHPwpYFBMcsxtdiptFS91UVaBvUH6VYiw,6266
-KratosMultiphysics/ConvectionDiffusionApplication/response_functions/convection_diffusion_response_function_factory.py,sha256=8Lzis6lcVOfZSSe4bdpIV1gl83O1esj6smQi0unVQjE,620
-KratosMultiphysics/ConvectionDiffusionApplication/response_functions/convection_diffusion_response.py,sha256=vjn7_gCXA92WR89V8ICt-u1ExZd_98jpj5orQXU6vs8,6796
-KratosMultiphysics/ConvectionDiffusionApplication/response_functions/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-KratosConvectionDiffusionApplication.libs/libKratosConvectionDiffusionCore-775db808.so,sha256=jS6JvZIYtALiEKhF1eoMOOWQfpay2vEMqtURNLHGp3k,8135737
+KratosMultiphysics/.libs/KratosConvectionDiffusionApplication.pyd,sha256=_QWJLLP9NVYPCaokFj5WPMcoloQv2aHndMqDYqe_2cs,2300928
+KratosMultiphysics/.libs/KratosConvectionDiffusionCore.dll,sha256=CMAi48EpkNGjEJaBgumqAt2K3irPHne6sZ5blDy7Pds,2008576
+KratosMultiphysics/.libs/KratosConvectionDiffusionCore.lib,sha256=k-By4HCM1mDQokPRkT_h9-bW4iVvS-9ZprkNXuUARJk,221526
+KratosMultiphysics/ConvectionDiffusionApplication/__init__.py,sha256=vyevImTAbovayHr3D2xmY1q4iOo0HdzhI7jdkU4Ul7M,312
+KratosMultiphysics/ConvectionDiffusionApplication/adjoint_diffusion_solver.py,sha256=zOk5qoDjyr_Gazg5IlfpkRvm-Siz-4CltekBGRybuf0,12240
+KratosMultiphysics/ConvectionDiffusionApplication/apply_thermal_face_process.py,sha256=I1CkDB10Rx1va5gVoe_f25SY4Aod8MzJkvIjnxDDRjo,3141
+KratosMultiphysics/ConvectionDiffusionApplication/conjugate_heat_transfer_solver.py,sha256=IVDGDJ8kPxpAw923QcUDlYDHtXmezM8JbTeCW-U9XQc,29159
+KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_analysis.py,sha256=TkopjQXZ_KgBilrziji8S2bXoYKtPALQOPq5pCporbE,2694
+KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_explicit_solver.py,sha256=lNyJTqW3iVRAlKN7yJDZcex5rpe5E6wx6nZx5Zvh2w4,3552
+KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_semi_eulerian_solver.py,sha256=9UyeAm9_-CCJRcZx1Pn0Nx0WZ6NOARv-ke4U7-Wok2g,7288
+KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_solver.py,sha256=M6A4DwX-alGVPFIEHRfDm09KQA64DWXjFiFL4udVKrU,45858
+KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_embedded_solver.py,sha256=Yp9VyTBq1ivwQB2Bv-mgOPAxXhpZLPy-qCUNX-rsjJo,7854
+KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_matrix_solver.py,sha256=dCFwo8t5ihoqn9OXB2ejEieD7y4XbDxV7loJrvzB3w8,3427
+KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_shifted_boundary_solver.py,sha256=JKwvHj5kXRU3U6GR4dxc5XBLH1AMLqi9tF97VZvcqMk,6021
+KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_stationary_solver.py,sha256=YKWNwrr21UCg0k6KSdfttvhIk03fYwIt25LtLws_70Q,2630
+KratosMultiphysics/ConvectionDiffusionApplication/convection_diffusion_transient_solver.py,sha256=L4sBgV7fmahzf4HEbSxh70PxGz5r_uuaOYMn9wQTK0k,2731
+KratosMultiphysics/ConvectionDiffusionApplication/coupled_fluid_thermal_solver.py,sha256=ZIi_jYeoXO-HZaCX1lImSYyP6jKcOF9xieUTwbwzckU,7970
+KratosMultiphysics/ConvectionDiffusionApplication/coupled_structural_thermal_solver.py,sha256=PGqu-yKkLn4j7xePbKimEAJs31jxrQMXnWQXykv8OpU,7245
+KratosMultiphysics/ConvectionDiffusionApplication/move_particle_utility_process.py,sha256=oLmYXfK4rvJbxHD3gaCsmNBBe1bhR1vfwK09edAKbTU,4289
+KratosMultiphysics/ConvectionDiffusionApplication/python_solvers_wrapper_convection_diffusion.py,sha256=HygJhgc-DfYvO2ibyqwdqmnlJ7HnJ29VdydA8wEPvi4,6376
+KratosMultiphysics/ConvectionDiffusionApplication/response_functions/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+KratosMultiphysics/ConvectionDiffusionApplication/response_functions/convection_diffusion_response.py,sha256=i43TAJVcb18WBzW3uUmSlH2UWDYFjaS2FKmyIzMBJ_s,6941
+KratosMultiphysics/ConvectionDiffusionApplication/response_functions/convection_diffusion_response_function_factory.py,sha256=67ENgsu_uVJqsZ1RpIiBefERyuLj3hblebojk_OKNBg,633
+KratosConvectionDiffusionApplication-9.5.1.dist-info/METADATA,sha256=Z1N6x_dUtOKA96ICMxQanAASvpKiyRTrYR9xZXyTKGo,2791
+KratosConvectionDiffusionApplication-9.5.1.dist-info/WHEEL,sha256=GZFS91_ufm4WrNPBaFVPB9MvOXR6bMZQhPcZRRTN5YM,100
+KratosConvectionDiffusionApplication-9.5.1.dist-info/top_level.txt,sha256=8Ov--opRCptLbHStjyiZUVpzN1OUU_F7c7fGmsR5cMc,19
+KratosConvectionDiffusionApplication-9.5.1.dist-info/RECORD,,
```


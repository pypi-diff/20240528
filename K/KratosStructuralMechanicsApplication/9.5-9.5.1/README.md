# Comparing `tmp/KratosStructuralMechanicsApplication-9.5-cp39-cp39-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip` & `tmp/KratosStructuralMechanicsApplication-9.5.1-cp39-cp39-win_amd64.whl.zip`

## zipinfo -v {}

 * *Differences in extra fields detected; using output from zipinfo -v*

```diff
@@ -1,2414 +1,1728 @@
 There is no zipfile comment.
 
 End-of-central-directory record:
 -------------------------------
 
-  Zip archive file size:                   8844040 (000000000086F308h)
-  Actual end-cent-dir record offset:       8844018 (000000000086F2F2h)
-  Expected end-cent-dir record offset:     8844018 (000000000086F2F2h)
+  Zip archive file size:                   3497077 (0000000000355C75h)
+  Actual end-cent-dir record offset:       3497055 (0000000000355C5Fh)
+  Expected end-cent-dir record offset:     3497055 (0000000000355C5Fh)
   (based on the length of the central directory and its expected offset)
 
   This zipfile constitutes the sole disk of a single-part archive; its
-  central directory contains 65 entries.
-  The central directory is 10035 (0000000000002733h) bytes long,
+  central directory contains 59 entries.
+  The central directory is 7834 (0000000000001E9Ah) bytes long,
   and its (expected) offset in bytes from the beginning of the zipfile
-  is 8833983 (000000000086CBBFh).
+  is 3489221 (0000000000353DC5h).
 
 
 Central directory entry #1:
 ---------------------------
 
-  KratosMultiphysics/
+  KratosMultiphysics/.libs/KratosStructuralMechanicsApplication.pyd
 
   offset of local header from start of archive:   0
                                                   (0000000000000000h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             19 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:44
+  32-bit CRC value (hex):                         d808e076
+  compressed size:                                478707 bytes
+  uncompressed size:                              1643520 bytes
+  length of filename:                             65 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #2:
 ---------------------------
 
-  KratosMultiphysics/.libs/
+  KratosMultiphysics/.libs/KratosStructuralMechanicsCore.dll
 
-  offset of local header from start of archive:   77
-                                                  (000000000000004Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   478802
+                                                  (0000000000074E52h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:22
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:22 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:22 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             25 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:44
+  32-bit CRC value (hex):                         79642cdc
+  compressed size:                                2756900 bytes
+  uncompressed size:                              9037312 bytes
+  length of filename:                             58 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #3:
 ---------------------------
 
-  KratosMultiphysics/.libs/KratosStructuralMechanicsApplication.cpython-39-x86_64-linux-gnu.so
+  KratosMultiphysics/.libs/KratosStructuralMechanicsCore.lib
 
-  offset of local header from start of archive:   160
-                                                  (00000000000000A0h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3235790
+                                                  (0000000000315FCEh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         52317d32
-  compressed size:                                1435911 bytes
-  uncompressed size:                              4440041 bytes
-  length of filename:                             92 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:44
+  32-bit CRC value (hex):                         060205c8
+  compressed size:                                173779 bytes
+  uncompressed size:                              2216930 bytes
+  length of filename:                             58 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100755 octal):            -rwxr-xr-x
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #4:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/
+  KratosMultiphysics/StructuralMechanicsApplication/__init__.py
 
-  offset of local header from start of archive:   1436221
-                                                  (000000000015EA3Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3409657
+                                                  (00000000003406F9h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             50 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         bad3f19f
+  compressed size:                                227 bytes
+  uncompressed size:                              572 bytes
+  length of filename:                             61 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #5:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/postprocess_eigenvalues_process.py
+  KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_analysis.py
 
-  offset of local header from start of archive:   1436329
-                                                  (000000000015EAA9h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3409975
+                                                  (0000000000340837h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         3be59bfc
-  compressed size:                                452 bytes
-  uncompressed size:                              1063 bytes
-  length of filename:                             84 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         1b433389
+  compressed size:                                2687 bytes
+  uncompressed size:                              11353 bytes
+  length of filename:                             103 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #6:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_harmonic_analysis_solver.py
+  KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_implicit_dynamic_solver.py
 
-  offset of local header from start of archive:   1436923
-                                                  (000000000015ECFBh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3412795
+                                                  (000000000034133Bh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         fe211fd1
-  compressed size:                                920 bytes
-  uncompressed size:                              2791 bytes
-  length of filename:                             98 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         18139130
+  compressed size:                                876 bytes
+  uncompressed size:                              3394 bytes
+  length of filename:                             118 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #7:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_analysis.py
+  KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_static_solver.py
 
-  offset of local header from start of archive:   1437999
-                                                  (000000000015F12Fh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3413819
+                                                  (000000000034173Bh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         3e919fdf
-  compressed size:                                2673 bytes
-  uncompressed size:                              11139 bytes
-  length of filename:                             103 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         d6a98d11
+  compressed size:                                866 bytes
+  uncompressed size:                              3344 bytes
+  length of filename:                             108 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #8:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/set_automated_initial_variable_process.py
+  KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_utilities.py
 
-  offset of local header from start of archive:   1440833
-                                                  (000000000015FC41h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3414823
+                                                  (0000000000341B27h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         3a3cedfc
-  compressed size:                                1839 bytes
-  uncompressed size:                              6115 bytes
-  length of filename:                             91 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         382b1b8d
+  compressed size:                                1184 bytes
+  uncompressed size:                              4708 bytes
+  length of filename:                             104 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #9:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_prebuckling_solver.py
+  KratosMultiphysics/StructuralMechanicsApplication/automatic_rayleigh_parameters_computation_process.py
 
-  offset of local header from start of archive:   1442821
-                                                  (0000000000160405h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3416141
+                                                  (000000000034204Dh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         030718a7
-  compressed size:                                1439 bytes
-  uncompressed size:                              5935 bytes
-  length of filename:                             92 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         b6dabf68
+  compressed size:                                2181 bytes
+  uncompressed size:                              9204 bytes
+  length of filename:                             102 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #10:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_static_solver.py
+  KratosMultiphysics/StructuralMechanicsApplication/auxiliary_methods_adaptative_solvers.py
 
-  offset of local header from start of archive:   1444410
-                                                  (0000000000160A3Ah) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3418454
+                                                  (0000000000342956h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         8c011b90
-  compressed size:                                371 bytes
-  uncompressed size:                              870 bytes
-  length of filename:                             87 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         1f16eee2
+  compressed size:                                491 bytes
+  uncompressed size:                              1836 bytes
+  length of filename:                             89 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #11:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/perturb_geometry_subgrid_utility.py
+  KratosMultiphysics/StructuralMechanicsApplication/auxiliary_methods_solvers.py
 
-  offset of local header from start of archive:   1444926
-                                                  (0000000000160C3Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3419064
+                                                  (0000000000342BB8h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         7d3a65e4
-  compressed size:                                899 bytes
-  uncompressed size:                              2477 bytes
-  length of filename:                             85 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         71ae9ae9
+  compressed size:                                434 bytes
+  uncompressed size:                              808 bytes
+  length of filename:                             78 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #12:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_adjoint_static_solver.py
+  KratosMultiphysics/StructuralMechanicsApplication/check_eigenvalues_process.py
 
-  offset of local header from start of archive:   1445968
-                                                  (0000000000161050h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3419606
+                                                  (0000000000342DD6h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         3c90f3d6
-  compressed size:                                2097 bytes
-  uncompressed size:                              10437 bytes
-  length of filename:                             95 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         469367e4
+  compressed size:                                674 bytes
+  uncompressed size:                              1725 bytes
+  length of filename:                             78 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #13:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_solver.py
+  KratosMultiphysics/StructuralMechanicsApplication/convergence_criteria_factory.py
 
-  offset of local header from start of archive:   1448218
-                                                  (000000000016191Ah) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3420388
+                                                  (00000000003430E4h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         1caee85f
-  compressed size:                                1508 bytes
-  uncompressed size:                              6937 bytes
-  length of filename:                             89 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         0bfef7d5
+  compressed size:                                969 bytes
+  uncompressed size:                              8079 bytes
+  length of filename:                             81 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #14:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_implicit_dynamic_solver.py
+  KratosMultiphysics/StructuralMechanicsApplication/displacement_control_with_direction_process.py
 
-  offset of local header from start of archive:   1449873
-                                                  (0000000000161F91h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3421468
+                                                  (000000000034351Ch) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         a77ca08a
-  compressed size:                                863 bytes
-  uncompressed size:                              3325 bytes
-  length of filename:                             118 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         dde148db
+  compressed size:                                1275 bytes
+  uncompressed size:                              4179 bytes
+  length of filename:                             96 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #15:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/auxiliary_methods_solvers.py
+  KratosMultiphysics/StructuralMechanicsApplication/distribute_load_on_surface_process.py
 
-  offset of local header from start of archive:   1450912
-                                                  (00000000001623A0h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3422869
+                                                  (0000000000343A95h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         d9a03f23
-  compressed size:                                428 bytes
-  uncompressed size:                              790 bytes
-  length of filename:                             78 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         f0878643
+  compressed size:                                269 bytes
+  uncompressed size:                              460 bytes
+  length of filename:                             87 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #16:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_formfinding_solver.py
+  KratosMultiphysics/StructuralMechanicsApplication/eigen_solution_input_process.py
 
-  offset of local header from start of archive:   1451476
-                                                  (00000000001625D4h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3423255
+                                                  (0000000000343C17h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         f43d0f75
-  compressed size:                                1076 bytes
-  uncompressed size:                              4139 bytes
-  length of filename:                             92 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         8b220af7
+  compressed size:                                703 bytes
+  uncompressed size:                              1966 bytes
+  length of filename:                             81 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #17:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_eigensolver.py
+  KratosMultiphysics/StructuralMechanicsApplication/eigen_solution_output_process.py
 
-  offset of local header from start of archive:   1452702
-                                                  (0000000000162A9Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3424069
+                                                  (0000000000343F45h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         af7a1012
-  compressed size:                                1473 bytes
-  uncompressed size:                              5096 bytes
-  length of filename:                             85 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         14e5c99b
+  compressed size:                                718 bytes
+  uncompressed size:                              1947 bytes
+  length of filename:                             82 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #18:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/structural_response_function_factory.py
+  KratosMultiphysics/StructuralMechanicsApplication/element_sensitivity_domain_integration_process.py
 
-  offset of local header from start of archive:   1454318
-                                                  (00000000001630EEh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3424899
+                                                  (0000000000344283h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         817ed0f6
-  compressed size:                                410 bytes
-  uncompressed size:                              1776 bytes
-  length of filename:                             89 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         b9692b68
+  compressed size:                                1560 bytes
+  uncompressed size:                              5680 bytes
+  length of filename:                             99 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #19:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/kratos_main_structural.py
+  KratosMultiphysics/StructuralMechanicsApplication/impose_rigid_movement_process.py
 
-  offset of local header from start of archive:   1454875
-                                                  (000000000016331Bh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3426588
+                                                  (000000000034491Ch) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         e77295ff
-  compressed size:                                269 bytes
-  uncompressed size:                              560 bytes
-  length of filename:                             75 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         0588f540
+  compressed size:                                1656 bytes
+  uncompressed size:                              6012 bytes
+  length of filename:                             82 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #20:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_utilities.py
+  KratosMultiphysics/StructuralMechanicsApplication/impose_z_strain_process.py
 
-  offset of local header from start of archive:   1455277
-                                                  (00000000001634ADh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3428356
+                                                  (0000000000345004h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         c0548a4a
-  compressed size:                                1167 bytes
-  uncompressed size:                              4614 bytes
-  length of filename:                             104 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         d8088a44
+  compressed size:                                342 bytes
+  uncompressed size:                              705 bytes
+  length of filename:                             76 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #21:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/impose_rigid_movement_process.py
+  KratosMultiphysics/StructuralMechanicsApplication/kratos_main_structural.py
 
-  offset of local header from start of archive:   1456606
-                                                  (00000000001639DEh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3428804
+                                                  (00000000003451C4h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         caa02b3b
-  compressed size:                                1640 bytes
-  uncompressed size:                              5900 bytes
-  length of filename:                             82 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         00a77b5e
+  compressed size:                                274 bytes
+  uncompressed size:                              576 bytes
+  length of filename:                             75 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #22:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_implicit_dynamic_solver.py
+  KratosMultiphysics/StructuralMechanicsApplication/perturb_geometry_sparse_utility.py
 
-  offset of local header from start of archive:   1458386
-                                                  (00000000001640D2h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3429183
+                                                  (000000000034533Fh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         14727df8
-  compressed size:                                1228 bytes
-  uncompressed size:                              4285 bytes
-  length of filename:                             106 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         8f840ce4
+  compressed size:                                793 bytes
+  uncompressed size:                              2235 bytes
+  length of filename:                             84 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #23:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/perturb_geometry_sparse_utility.py
+  KratosMultiphysics/StructuralMechanicsApplication/perturb_geometry_subgrid_utility.py
 
-  offset of local header from start of archive:   1459778
-                                                  (0000000000164642h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3430090
+                                                  (00000000003456CAh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         c457570c
-  compressed size:                                784 bytes
-  uncompressed size:                              2178 bytes
-  length of filename:                             84 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         c0086303
+  compressed size:                                908 bytes
+  uncompressed size:                              2534 bytes
+  length of filename:                             85 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #24:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/structural_response.py
+  KratosMultiphysics/StructuralMechanicsApplication/postprocess_eigenvalues_process.py
 
-  offset of local header from start of archive:   1460704
-                                                  (00000000001649E0h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3431113
+                                                  (0000000000345AC9h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         666016c3
-  compressed size:                                4077 bytes
-  uncompressed size:                              23100 bytes
-  length of filename:                             72 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         d053a392
+  compressed size:                                460 bytes
+  uncompressed size:                              1086 bytes
+  length of filename:                             84 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #25:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/displacement_control_with_direction_process.py
+  KratosMultiphysics/StructuralMechanicsApplication/project_vector_on_surface_process.py
 
-  offset of local header from start of archive:   1464911
-                                                  (0000000000165A4Fh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3431687
+                                                  (0000000000345D07h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         712f0157
-  compressed size:                                1264 bytes
-  uncompressed size:                              4091 bytes
-  length of filename:                             96 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         d87f1106
+  compressed size:                                912 bytes
+  uncompressed size:                              2463 bytes
+  length of filename:                             86 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #26:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/distribute_load_on_surface_process.py
+  KratosMultiphysics/StructuralMechanicsApplication/python_solvers_wrapper_adaptative_remeshing_structural.py
 
-  offset of local header from start of archive:   1466329
-                                                  (0000000000165FD9h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3432715
+                                                  (000000000034610Bh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         d1be187e
-  compressed size:                                262 bytes
-  uncompressed size:                              450 bytes
-  length of filename:                             87 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         43b3eb1d
+  compressed size:                                551 bytes
+  uncompressed size:                              1630 bytes
+  length of filename:                             107 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #27:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_analysis.py
+  KratosMultiphysics/StructuralMechanicsApplication/python_solvers_wrapper_structural.py
 
-  offset of local header from start of archive:   1466736
-                                                  (0000000000166170h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3433403
+                                                  (00000000003463BBh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         200de648
-  compressed size:                                2033 bytes
-  uncompressed size:                              7254 bytes
-  length of filename:                             82 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         12c0cecb
+  compressed size:                                1181 bytes
+  uncompressed size:                              5568 bytes
+  length of filename:                             86 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #28:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/python_solvers_wrapper_structural.py
+  KratosMultiphysics/StructuralMechanicsApplication/rve_analysis.py
 
-  offset of local header from start of archive:   1468909
-                                                  (00000000001669EDh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3434700
+                                                  (00000000003468CCh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         4368ee6b
-  compressed size:                                1175 bytes
-  uncompressed size:                              5453 bytes
-  length of filename:                             86 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         4a084d72
+  compressed size:                                3722 bytes
+  uncompressed size:                              16824 bytes
+  length of filename:                             65 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #29:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/auxiliary_methods_adaptative_solvers.py
+  KratosMultiphysics/StructuralMechanicsApplication/set_automated_initial_variable_process.py
 
-  offset of local header from start of archive:   1470228
-                                                  (0000000000166F14h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3438517
+                                                  (00000000003477B5h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         e04fa723
-  compressed size:                                481 bytes
-  uncompressed size:                              1799 bytes
-  length of filename:                             89 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         d68ec2f8
+  compressed size:                                1851 bytes
+  uncompressed size:                              6216 bytes
+  length of filename:                             91 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #30:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/check_eigenvalues_process.py
+  KratosMultiphysics/StructuralMechanicsApplication/set_cartesian_local_axes_process.py
 
-  offset of local header from start of archive:   1470856
-                                                  (0000000000167188h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3440489
+                                                  (0000000000347F69h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         52b14414
-  compressed size:                                666 bytes
-  uncompressed size:                              1687 bytes
-  length of filename:                             78 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         3202b336
+  compressed size:                                480 bytes
+  uncompressed size:                              1035 bytes
+  length of filename:                             85 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #31:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/convergence_criteria_factory.py
+  KratosMultiphysics/StructuralMechanicsApplication/set_cylindrical_local_axes_process.py
 
-  offset of local header from start of archive:   1471658
-                                                  (00000000001674AAh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3441084
+                                                  (00000000003481BCh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         93fc1240
-  compressed size:                                964 bytes
-  uncompressed size:                              7950 bytes
-  length of filename:                             81 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         90a79e81
+  compressed size:                                491 bytes
+  uncompressed size:                              1113 bytes
+  length of filename:                             87 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #32:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_custom_scipy_base_solver.py
+  KratosMultiphysics/StructuralMechanicsApplication/set_moving_load_process.py
 
-  offset of local header from start of archive:   1472761
-                                                  (00000000001678F9h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3441692
+                                                  (000000000034841Ch) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         dfe0f98e
-  compressed size:                                2128 bytes
-  uncompressed size:                              8700 bytes
-  length of filename:                             98 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         9f075868
+  compressed size:                                769 bytes
+  uncompressed size:                              1986 bytes
+  length of filename:                             76 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #33:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/set_cylindrical_local_axes_process.py
+  KratosMultiphysics/StructuralMechanicsApplication/set_spherical_local_axes_process.py
 
-  offset of local header from start of archive:   1475045
-                                                  (00000000001681E5h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3442567
+                                                  (0000000000348787h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         407f8628
-  compressed size:                                483 bytes
-  uncompressed size:                              1085 bytes
-  length of filename:                             87 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         28c899e1
+  compressed size:                                495 bytes
+  uncompressed size:                              1092 bytes
+  length of filename:                             85 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #34:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_explicit_dynamic_solver.py
+  KratosMultiphysics/StructuralMechanicsApplication/simplified_nodal_contact_process.py
 
-  offset of local header from start of archive:   1475673
-                                                  (0000000000168459h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3443177
+                                                  (00000000003489E9h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         8ba9fbcd
-  compressed size:                                1576 bytes
-  uncompressed size:                              6830 bytes
-  length of filename:                             97 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         59b9be8b
+  compressed size:                                1920 bytes
+  uncompressed size:                              8491 bytes
+  length of filename:                             85 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #35:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/set_spherical_local_axes_process.py
+  KratosMultiphysics/StructuralMechanicsApplication/sprism_process.py
 
-  offset of local header from start of archive:   1477404
-                                                  (0000000000168B1Ch) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3445212
+                                                  (00000000003491DCh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         91c2d539
-  compressed size:                                485 bytes
-  uncompressed size:                              1067 bytes
-  length of filename:                             85 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         b069866f
+  compressed size:                                1359 bytes
+  uncompressed size:                              4852 bytes
+  length of filename:                             67 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #36:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/symbolic_generation/
+  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_adjoint_static_solver.py
 
-  offset of local header from start of archive:   1478032
-                                                  (0000000000168D90h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3446668
+                                                  (000000000034978Ch) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             70 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         300a56ab
+  compressed size:                                2110 bytes
+  uncompressed size:                              10602 bytes
+  length of filename:                             95 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #37:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/symbolic_generation/total_lagrangian_mixed_volumetric_strain_element/
+  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_analysis.py
 
-  offset of local header from start of archive:   1478160
-                                                  (0000000000168E10h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3448903
+                                                  (000000000034A047h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
+  minimum software version required to extract:   2.0
+  compression method:                             deflated
+  compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             119 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         0d0f3141
+  compressed size:                                2044 bytes
+  uncompressed size:                              7392 bytes
+  length of filename:                             82 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
 Central directory entry #38:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/symbolic_generation/total_lagrangian_mixed_volumetric_strain_element/generate_total_lagrangian_mixed_volumetric_strain_element.py
+  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_custom_scipy_base_solver.py
 
-  offset of local header from start of archive:   1478337
-                                                  (0000000000168EC1h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3451059
+                                                  (000000000034A8B3h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         5b6038fd
-  compressed size:                                3153 bytes
-  uncompressed size:                              10566 bytes
-  length of filename:                             179 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         509cfe67
+  compressed size:                                2144 bytes
+  uncompressed size:                              8892 bytes
+  length of filename:                             98 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #39:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/automatic_rayleigh_parameters_computation_process.py
+  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_eigensolver.py
 
-  offset of local header from start of archive:   1481727
-                                                  (0000000000169BFFh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3453331
+                                                  (000000000034B193h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         5fb2fe89
-  compressed size:                                2166 bytes
-  uncompressed size:                              9013 bytes
-  length of filename:                             102 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         721c29ee
+  compressed size:                                1486 bytes
+  uncompressed size:                              5200 bytes
+  length of filename:                             85 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #40:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/eigen_solution_output_process.py
+  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_explicit_dynamic_solver.py
 
-  offset of local header from start of archive:   1484053
-                                                  (000000000016A515h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3454932
+                                                  (000000000034B7D4h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         3aba795f
-  compressed size:                                709 bytes
-  uncompressed size:                              1902 bytes
-  length of filename:                             82 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         b29b67bb
+  compressed size:                                1593 bytes
+  uncompressed size:                              6959 bytes
+  length of filename:                             97 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #41:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/rve_analysis.py
+  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_formfinding_solver.py
 
-  offset of local header from start of archive:   1484902
-                                                  (000000000016A866h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3456652
+                                                  (000000000034BE8Ch) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         0bfb76a0
-  compressed size:                                3703 bytes
-  uncompressed size:                              16458 bytes
-  length of filename:                             65 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         040436ba
+  compressed size:                                1089 bytes
+  uncompressed size:                              4220 bytes
+  length of filename:                             92 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #42:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_prebuckling_analysis.py
+  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_harmonic_analysis_solver.py
 
-  offset of local header from start of archive:   1488728
-                                                  (000000000016B758h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3457863
+                                                  (000000000034C347h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         80238722
-  compressed size:                                1347 bytes
-  uncompressed size:                              4627 bytes
-  length of filename:                             94 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         18c821df
+  compressed size:                                928 bytes
+  uncompressed size:                              2859 bytes
+  length of filename:                             98 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #43:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/eigen_solution_input_process.py
+  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_implicit_dynamic_solver.py
 
-  offset of local header from start of archive:   1490227
-                                                  (000000000016BD33h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3458919
+                                                  (000000000034C767h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         146e5005
-  compressed size:                                695 bytes
-  uncompressed size:                              1921 bytes
-  length of filename:                             81 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         7ba63805
+  compressed size:                                1595 bytes
+  uncompressed size:                              5703 bytes
+  length of filename:                             97 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #44:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/set_cartesian_local_axes_process.py
+  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_prebuckling_analysis.py
 
-  offset of local header from start of archive:   1491061
-                                                  (000000000016C075h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3460641
+                                                  (000000000034CE21h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         cbdc5509
-  compressed size:                                472 bytes
-  uncompressed size:                              1009 bytes
-  length of filename:                             85 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         9675528b
+  compressed size:                                1355 bytes
+  uncompressed size:                              4725 bytes
+  length of filename:                             94 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #45:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/simplified_nodal_contact_process.py
+  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_prebuckling_solver.py
 
-  offset of local header from start of archive:   1491676
-                                                  (000000000016C2DCh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3462120
+                                                  (000000000034D3E8h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         5c9bc29a
-  compressed size:                                1906 bytes
-  uncompressed size:                              8307 bytes
-  length of filename:                             85 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         bc513720
+  compressed size:                                1453 bytes
+  uncompressed size:                              6053 bytes
+  length of filename:                             92 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #46:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/sprism_process.py
+  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_solver.py
 
-  offset of local header from start of archive:   1493725
-                                                  (000000000016CADDh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3463695
+                                                  (000000000034DA0Fh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         fa56a053
-  compressed size:                                1347 bytes
-  uncompressed size:                              4747 bytes
-  length of filename:                             67 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         dde95d73
+  compressed size:                                5589 bytes
+  uncompressed size:                              30687 bytes
+  length of filename:                             80 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #47:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/__init__.py
+  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_static_shifted_boundary_solver.py
 
-  offset of local header from start of archive:   1495197
-                                                  (000000000016D09Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3469394
+                                                  (000000000034F052h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         f1850af5
-  compressed size:                                220 bytes
-  uncompressed size:                              560 bytes
-  length of filename:                             61 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         37875de0
+  compressed size:                                1027 bytes
+  uncompressed size:                              3311 bytes
+  length of filename:                             104 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #48:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_solver.py
+  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_static_solver.py
 
-  offset of local header from start of archive:   1495536
-                                                  (000000000016D1F0h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3470555
+                                                  (000000000034F4DBh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         d48706af
-  compressed size:                                5567 bytes
-  uncompressed size:                              30147 bytes
-  length of filename:                             80 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         8de9b30e
+  compressed size:                                379 bytes
+  uncompressed size:                              893 bytes
+  length of filename:                             87 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #49:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/impose_z_strain_process.py
+  KratosMultiphysics/StructuralMechanicsApplication/structural_response.py
 
-  offset of local header from start of archive:   1501241
-                                                  (000000000016E839h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3471051
+                                                  (000000000034F6CBh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         d8088a44
-  compressed size:                                342 bytes
-  uncompressed size:                              705 bytes
-  length of filename:                             76 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         27f3b8ec
+  compressed size:                                4099 bytes
+  uncompressed size:                              23537 bytes
+  length of filename:                             72 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #50:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/trilinos_convergence_criteria_factory.py
+  KratosMultiphysics/StructuralMechanicsApplication/structural_response_function_factory.py
 
-  offset of local header from start of archive:   1501717
-                                                  (000000000016EA15h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3475252
+                                                  (0000000000350734h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         fd056fc7
-  compressed size:                                787 bytes
-  uncompressed size:                              3755 bytes
-  length of filename:                             90 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         4c9ee541
+  compressed size:                                416 bytes
+  uncompressed size:                              1809 bytes
+  length of filename:                             89 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #51:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/set_moving_load_process.py
+  KratosMultiphysics/StructuralMechanicsApplication/trilinos_convergence_criteria_factory.py
 
-  offset of local header from start of archive:   1502652
-                                                  (000000000016EDBCh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3475787
+                                                  (000000000035094Bh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         7705a102
-  compressed size:                                763 bytes
-  uncompressed size:                              1950 bytes
-  length of filename:                             76 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         1af77e4d
+  compressed size:                                798 bytes
+  uncompressed size:                              3824 bytes
+  length of filename:                             90 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #52:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_static_shifted_boundary_solver.py
+  KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_implicit_dynamic_solver.py
 
-  offset of local header from start of archive:   1503549
-                                                  (000000000016F13Dh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3476705
+                                                  (0000000000350CE1h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         0768638d
-  compressed size:                                1016 bytes
-  uncompressed size:                              3245 bytes
-  length of filename:                             104 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         b29289d7
+  compressed size:                                1242 bytes
+  uncompressed size:                              4374 bytes
+  length of filename:                             106 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #53:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_static_solver.py
+  KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_solver.py
 
-  offset of local header from start of archive:   1504727
-                                                  (000000000016F5D7h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3478083
+                                                  (0000000000351243h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         0c1690c2
-  compressed size:                                386 bytes
-  uncompressed size:                              1009 bytes
-  length of filename:                             96 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         96e2da98
+  compressed size:                                1519 bytes
+  uncompressed size:                              7068 bytes
+  length of filename:                             89 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #54:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_static_solver.py
+  KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_static_solver.py
 
-  offset of local header from start of archive:   1505267
-                                                  (000000000016F7F3h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3479721
+                                                  (00000000003518A9h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         04e71a5f
-  compressed size:                                853 bytes
-  uncompressed size:                              3275 bytes
-  length of filename:                             108 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         9276380f
+  compressed size:                                396 bytes
+  uncompressed size:                              1035 bytes
+  length of filename:                             96 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #55:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/element_sensitivity_domain_integration_process.py
+  KratosMultiphysics/StructuralMechanicsApplication/symbolic_generation/total_lagrangian_mixed_volumetric_strain_element/generate_total_lagrangian_mixed_volumetric_strain_element.py
 
-  offset of local header from start of archive:   1506286
-                                                  (000000000016FBEEh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3480243
+                                                  (0000000000351AB3h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         ca03e699
-  compressed size:                                1549 bytes
-  uncompressed size:                              5560 bytes
-  length of filename:                             99 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 12:13:58
+  32-bit CRC value (hex):                         1cc5a68f
+  compressed size:                                3172 bytes
+  uncompressed size:                              10780 bytes
+  length of filename:                             179 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #56:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/project_vector_on_surface_process.py
+  KratosStructuralMechanicsApplication-9.5.1.dist-info/METADATA
 
-  offset of local header from start of archive:   1507992
-                                                  (0000000000170298h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3483624
+                                                  (00000000003527E8h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         6f14b4b0
-  compressed size:                                903 bytes
-  uncompressed size:                              2407 bytes
-  length of filename:                             86 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:44
+  32-bit CRC value (hex):                         bae1b3a1
+  compressed size:                                2008 bytes
+  uncompressed size:                              7838 bytes
+  length of filename:                             61 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  apparent file type:                             binary
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
 Central directory entry #57:
 ---------------------------
 
-  KratosMultiphysics/StructuralMechanicsApplication/python_solvers_wrapper_adaptative_remeshing_structural.py
+  KratosStructuralMechanicsApplication-9.5.1.dist-info/WHEEL
 
-  offset of local header from start of archive:   1509039
-                                                  (00000000001706AFh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3485723
+                                                  (000000000035301Bh) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         b5dd07f9
-  compressed size:                                545 bytes
-  uncompressed size:                              1597 bytes
-  length of filename:                             107 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #58:
----------------------------
-
-  KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_implicit_dynamic_solver.py
-
-  offset of local header from start of archive:   1509749
-                                                  (0000000000170975h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         f237b889
-  compressed size:                                1582 bytes
-  uncompressed size:                              5591 bytes
-  length of filename:                             97 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #59:
----------------------------
-
-  KratosStructuralMechanicsApplication-9.5.dist-info/
-
-  offset of local header from start of archive:   1511486
-                                                  (000000000017103Eh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:22
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:22 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:22 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             51 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:44
+  32-bit CRC value (hex):                         86fb6b41
+  compressed size:                                96 bytes
+  uncompressed size:                              100 bytes
+  length of filename:                             58 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #60:
----------------------------
-
-  KratosStructuralMechanicsApplication-9.5.dist-info/METADATA
-
-  offset of local header from start of archive:   1511595
-                                                  (00000000001710ABh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         4cb283ce
-  compressed size:                                1986 bytes
-  uncompressed size:                              7617 bytes
-  length of filename:                             59 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
+  non-MSDOS external file attributes:             81B600 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
 
-Central directory entry #61:
+Central directory entry #58:
 ---------------------------
 
-  KratosStructuralMechanicsApplication-9.5.dist-info/WHEEL
+  KratosStructuralMechanicsApplication-9.5.1.dist-info/top_level.txt
 
-  offset of local header from start of archive:   1513698
-                                                  (00000000001718E2h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3485907
+                                                  (00000000003530D3h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         90d34e0d
-  compressed size:                                116 bytes
-  uncompressed size:                              148 bytes
-  length of filename:                             56 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #62:
----------------------------
-
-  KratosStructuralMechanicsApplication-9.5.dist-info/top_level.txt
-
-  offset of local header from start of archive:   1513928
-                                                  (00000000001719C8h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
+  file last modified on (DOS date/time):          2024 May 27 13:36:44
   32-bit CRC value (hex):                         f32d789f
-  compressed size:                                19 bytes
+  compressed size:                                21 bytes
   uncompressed size:                              19 bytes
-  length of filename:                             64 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100644 octal):            -rw-r--r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #63:
----------------------------
-
-  KratosStructuralMechanicsApplication-9.5.dist-info/RECORD
-
-  offset of local header from start of archive:   1514069
-                                                  (0000000000171A55h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   2.0
-  compression method:                             deflated
-  compression sub-type (deflation):               normal
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:22
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:22 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:22 UTC
-  32-bit CRC value (hex):                         19ad5590
-  compressed size:                                3159 bytes
-  uncompressed size:                              8545 bytes
-  length of filename:                             57 characters
-  length of extra field:                          24 bytes
-  length of file comment:                         0 characters
-  disk number on which file begins:               disk 1
-  apparent file type:                             text
-  Unix file attributes (100664 octal):            -rw-rw-r--
-  MS-DOS file attributes (00 hex):                none
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
-  There is no file comment.
-
-Central directory entry #64:
----------------------------
-
-  KratosStructuralMechanicsApplication.libs/
-
-  offset of local header from start of archive:   1517343
-                                                  (000000000017271Fh) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
-  minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
-  minimum software version required to extract:   1.0
-  compression method:                             none (stored)
-  file security status:                           not encrypted
-  extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:22
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:22 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:22 UTC
-  32-bit CRC value (hex):                         00000000
-  compressed size:                                0 bytes
-  uncompressed size:                              0 bytes
-  length of filename:                             42 characters
-  length of extra field:                          24 bytes
+  length of filename:                             66 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (040755 octal):            drwxr-xr-x
-  MS-DOS file attributes (10 hex):                dir 
-
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
+  non-MSDOS external file attributes:             81B600 hex
+  MS-DOS file attributes (00 hex):                none
 
   There is no file comment.
 
-Central directory entry #65:
+Central directory entry #59:
 ---------------------------
 
-  KratosStructuralMechanicsApplication.libs/libKratosStructuralMechanicsCore-d06c43d3.so
+  KratosStructuralMechanicsApplication-9.5.1.dist-info/RECORD
 
-  offset of local header from start of archive:   1517443
-                                                  (0000000000172783h) bytes
-  file system or operating system of origin:      Unix
-  version of encoding software:                   3.0
+  offset of local header from start of archive:   3486024
+                                                  (0000000000353148h) bytes
+  file system or operating system of origin:      MS-DOS, OS/2 or NT FAT
+  version of encoding software:                   2.0
   minimum file system compatibility required:     MS-DOS, OS/2 or NT FAT
   minimum software version required to extract:   2.0
   compression method:                             deflated
   compression sub-type (deflation):               normal
   file security status:                           not encrypted
   extended local header:                          no
-  file last modified on (DOS date/time):          2024 Apr 25 16:02:14
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 local
-  file last modified on (UT extra field modtime): 2024 Apr 25 16:02:14 UTC
-  32-bit CRC value (hex):                         5595483d
-  compressed size:                                7316396 bytes
-  uncompressed size:                              25336065 bytes
-  length of filename:                             86 characters
-  length of extra field:                          24 bytes
+  file last modified on (DOS date/time):          2024 May 27 13:36:44
+  32-bit CRC value (hex):                         df6a6a01
+  compressed size:                                3108 bytes
+  uncompressed size:                              8435 bytes
+  length of filename:                             59 characters
+  length of extra field:                          0 bytes
   length of file comment:                         0 characters
   disk number on which file begins:               disk 1
   apparent file type:                             binary
-  Unix file attributes (100755 octal):            -rwxr-xr-x
+  non-MSDOS external file attributes:             81B400 hex
   MS-DOS file attributes (00 hex):                none
 
-  The central-directory extra field contains:
-  - A subfield with ID 0x5455 (universal time) and 5 data bytes.
-    The local extra field has UTC/GMT modification/access times.
-  - A subfield with ID 0x7875 (Unix UID/GID (any size)) and 11 data bytes:
-    01 04 00 00 00 00 04 00 00 00 00.
-
   There is no file comment.
```

## zipnote {}

```diff
@@ -1,196 +1,178 @@
-Filename: KratosMultiphysics/
+Filename: KratosMultiphysics/.libs/KratosStructuralMechanicsApplication.pyd
 Comment: 
 
-Filename: KratosMultiphysics/.libs/
+Filename: KratosMultiphysics/.libs/KratosStructuralMechanicsCore.dll
 Comment: 
 
-Filename: KratosMultiphysics/.libs/KratosStructuralMechanicsApplication.cpython-39-x86_64-linux-gnu.so
+Filename: KratosMultiphysics/.libs/KratosStructuralMechanicsCore.lib
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/
-Comment: 
-
-Filename: KratosMultiphysics/StructuralMechanicsApplication/postprocess_eigenvalues_process.py
-Comment: 
-
-Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_harmonic_analysis_solver.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/__init__.py
 Comment: 
 
 Filename: KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_analysis.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/set_automated_initial_variable_process.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_implicit_dynamic_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_prebuckling_solver.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_static_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_static_solver.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_utilities.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/perturb_geometry_subgrid_utility.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/automatic_rayleigh_parameters_computation_process.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_adjoint_static_solver.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/auxiliary_methods_adaptative_solvers.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_solver.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/auxiliary_methods_solvers.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_implicit_dynamic_solver.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/check_eigenvalues_process.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/auxiliary_methods_solvers.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/convergence_criteria_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_formfinding_solver.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/displacement_control_with_direction_process.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_eigensolver.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/distribute_load_on_surface_process.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_response_function_factory.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/eigen_solution_input_process.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/kratos_main_structural.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/eigen_solution_output_process.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_utilities.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/element_sensitivity_domain_integration_process.py
 Comment: 
 
 Filename: KratosMultiphysics/StructuralMechanicsApplication/impose_rigid_movement_process.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_implicit_dynamic_solver.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/impose_z_strain_process.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/perturb_geometry_sparse_utility.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/kratos_main_structural.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_response.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/perturb_geometry_sparse_utility.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/displacement_control_with_direction_process.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/perturb_geometry_subgrid_utility.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/distribute_load_on_surface_process.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/postprocess_eigenvalues_process.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_analysis.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/project_vector_on_surface_process.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/python_solvers_wrapper_structural.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/python_solvers_wrapper_adaptative_remeshing_structural.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/auxiliary_methods_adaptative_solvers.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/python_solvers_wrapper_structural.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/check_eigenvalues_process.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/rve_analysis.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/convergence_criteria_factory.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/set_automated_initial_variable_process.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_custom_scipy_base_solver.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/set_cartesian_local_axes_process.py
 Comment: 
 
 Filename: KratosMultiphysics/StructuralMechanicsApplication/set_cylindrical_local_axes_process.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_explicit_dynamic_solver.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/set_moving_load_process.py
 Comment: 
 
 Filename: KratosMultiphysics/StructuralMechanicsApplication/set_spherical_local_axes_process.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/symbolic_generation/
+Filename: KratosMultiphysics/StructuralMechanicsApplication/simplified_nodal_contact_process.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/symbolic_generation/total_lagrangian_mixed_volumetric_strain_element/
+Filename: KratosMultiphysics/StructuralMechanicsApplication/sprism_process.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/symbolic_generation/total_lagrangian_mixed_volumetric_strain_element/generate_total_lagrangian_mixed_volumetric_strain_element.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_adjoint_static_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/automatic_rayleigh_parameters_computation_process.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_analysis.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/eigen_solution_output_process.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_custom_scipy_base_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/rve_analysis.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_eigensolver.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_prebuckling_analysis.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_explicit_dynamic_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/eigen_solution_input_process.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_formfinding_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/set_cartesian_local_axes_process.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_harmonic_analysis_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/simplified_nodal_contact_process.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_implicit_dynamic_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/sprism_process.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_prebuckling_analysis.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/__init__.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_prebuckling_solver.py
 Comment: 
 
 Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/impose_z_strain_process.py
-Comment: 
-
-Filename: KratosMultiphysics/StructuralMechanicsApplication/trilinos_convergence_criteria_factory.py
-Comment: 
-
-Filename: KratosMultiphysics/StructuralMechanicsApplication/set_moving_load_process.py
-Comment: 
-
 Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_static_shifted_boundary_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_static_solver.py
-Comment: 
-
-Filename: KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_static_solver.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_static_solver.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/element_sensitivity_domain_integration_process.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_response.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/project_vector_on_surface_process.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_response_function_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/python_solvers_wrapper_adaptative_remeshing_structural.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/trilinos_convergence_criteria_factory.py
 Comment: 
 
-Filename: KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_implicit_dynamic_solver.py
+Filename: KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_implicit_dynamic_solver.py
 Comment: 
 
-Filename: KratosStructuralMechanicsApplication-9.5.dist-info/
+Filename: KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_solver.py
 Comment: 
 
-Filename: KratosStructuralMechanicsApplication-9.5.dist-info/METADATA
+Filename: KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_static_solver.py
 Comment: 
 
-Filename: KratosStructuralMechanicsApplication-9.5.dist-info/WHEEL
+Filename: KratosMultiphysics/StructuralMechanicsApplication/symbolic_generation/total_lagrangian_mixed_volumetric_strain_element/generate_total_lagrangian_mixed_volumetric_strain_element.py
 Comment: 
 
-Filename: KratosStructuralMechanicsApplication-9.5.dist-info/top_level.txt
+Filename: KratosStructuralMechanicsApplication-9.5.1.dist-info/METADATA
 Comment: 
 
-Filename: KratosStructuralMechanicsApplication-9.5.dist-info/RECORD
+Filename: KratosStructuralMechanicsApplication-9.5.1.dist-info/WHEEL
 Comment: 
 
-Filename: KratosStructuralMechanicsApplication.libs/
+Filename: KratosStructuralMechanicsApplication-9.5.1.dist-info/top_level.txt
 Comment: 
 
-Filename: KratosStructuralMechanicsApplication.libs/libKratosStructuralMechanicsCore-d06c43d3.so
+Filename: KratosStructuralMechanicsApplication-9.5.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v1.0 to extract, compression method=store
+Zip archive data, at least v2.0 to extract, compression method=deflate
```

## KratosMultiphysics/StructuralMechanicsApplication/postprocess_eigenvalues_process.py

 * *Ordering differences only*

```diff
@@ -1,23 +1,23 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as KSM
-
-def Factory(settings, Model):
-    if(type(settings) != KratosMultiphysics.Parameters):
-        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
-
-    process_settings = settings["Parameters"]
-    __BackwardsCompatibilityHelper(process_settings)
-    return KSM.PostprocessEigenvaluesProcess(Model, process_settings)
-
-def __BackwardsCompatibilityHelper(process_settings):
-    # Check if "computing_model_part_name" is provided
-    if process_settings.Has("computing_model_part_name"):
-        KratosMultiphysics.Logger.PrintWarning("'computing_model_part_name' is deprecated. Use 'model_part_name' instead.")
-        process_settings.AddEmptyValue("model_part_name").SetString(process_settings["computing_model_part_name"].GetString())
-        process_settings.RemoveValue("computing_model_part_name")
-    # Remove the old "help" field
-    process_settings.RemoveValue("help")
-
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as KSM
+
+def Factory(settings, Model):
+    if(type(settings) != KratosMultiphysics.Parameters):
+        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
+
+    process_settings = settings["Parameters"]
+    __BackwardsCompatibilityHelper(process_settings)
+    return KSM.PostprocessEigenvaluesProcess(Model, process_settings)
+
+def __BackwardsCompatibilityHelper(process_settings):
+    # Check if "computing_model_part_name" is provided
+    if process_settings.Has("computing_model_part_name"):
+        KratosMultiphysics.Logger.PrintWarning("'computing_model_part_name' is deprecated. Use 'model_part_name' instead.")
+        process_settings.AddEmptyValue("model_part_name").SetString(process_settings["computing_model_part_name"].GetString())
+        process_settings.RemoveValue("computing_model_part_name")
+    # Remove the old "help" field
+    process_settings.RemoveValue("help")
+
```

## KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_harmonic_analysis_solver.py

 * *Ordering differences only*

```diff
@@ -1,68 +1,68 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-
-# Import base class file
-from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
-
-def CreateSolver(model, custom_settings):
-    return HarmonicAnalysisSolver(model, custom_settings)
-
-class HarmonicAnalysisSolver(MechanicalSolver):
-    """The structural mechanics harmonic analysis solver.
-
-    This class creates the mechanical solvers for the harmonic analysis.
-
-    See structural_mechanics_solver.py for more information.
-    """
-    def __init__(self, model, custom_settings):
-        # Construct the base solver.
-        super().__init__(model, custom_settings)
-        KratosMultiphysics.Logger.PrintInfo("::[HarmonicAnalysisSolver]:: ", "Construction finished")
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KratosMultiphysics.Parameters("""{
-            "scheme_type"   : "dynamic",
-            "harmonic_analysis_settings" : {
-                "use_effective_material_damping" : false
-            }
-        }""")
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
-
-    #### Private functions ####
-
-    def _CreateScheme(self):
-        """Create the scheme to construct the global force vector.
-
-        The scheme determines the initial force vector on all system dofs.
-        """
-        if self.settings["scheme_type"].GetString() == "dynamic":
-            solution_scheme = StructuralMechanicsApplication.EigensolverDynamicScheme()
-        else:
-            err_msg =  "The requested scheme type \"" + scheme_type + "\" is not available!\n"
-            err_msg += "Available options are: \"dynamic\""
-            raise Exception(err_msg)
-
-        return solution_scheme
-
-    def _CreateLinearSolver(self):
-        """Create a dummy linear solver.
-
-        This overrides the base class method and returns an empty linear solver as the harmonic
-        analysis does not need a linear solver.
-        """
-        return KratosMultiphysics.LinearSolver()
-
-    def _CreateSolutionStrategy(self):
-        eigen_scheme = self._GetScheme()
-        builder_and_solver = self._GetBuilderAndSolver()
-        computing_model_part = self.GetComputingModelPart()
-
-        return StructuralMechanicsApplication.HarmonicAnalysisStrategy(computing_model_part,
-                                                                    eigen_scheme,
-                                                                    builder_and_solver,
-                                                                    self.settings["harmonic_analysis_settings"]["use_effective_material_damping"].GetBool())
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+
+# Import base class file
+from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
+
+def CreateSolver(model, custom_settings):
+    return HarmonicAnalysisSolver(model, custom_settings)
+
+class HarmonicAnalysisSolver(MechanicalSolver):
+    """The structural mechanics harmonic analysis solver.
+
+    This class creates the mechanical solvers for the harmonic analysis.
+
+    See structural_mechanics_solver.py for more information.
+    """
+    def __init__(self, model, custom_settings):
+        # Construct the base solver.
+        super().__init__(model, custom_settings)
+        KratosMultiphysics.Logger.PrintInfo("::[HarmonicAnalysisSolver]:: ", "Construction finished")
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KratosMultiphysics.Parameters("""{
+            "scheme_type"   : "dynamic",
+            "harmonic_analysis_settings" : {
+                "use_effective_material_damping" : false
+            }
+        }""")
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
+
+    #### Private functions ####
+
+    def _CreateScheme(self):
+        """Create the scheme to construct the global force vector.
+
+        The scheme determines the initial force vector on all system dofs.
+        """
+        if self.settings["scheme_type"].GetString() == "dynamic":
+            solution_scheme = StructuralMechanicsApplication.EigensolverDynamicScheme()
+        else:
+            err_msg =  "The requested scheme type \"" + scheme_type + "\" is not available!\n"
+            err_msg += "Available options are: \"dynamic\""
+            raise Exception(err_msg)
+
+        return solution_scheme
+
+    def _CreateLinearSolver(self):
+        """Create a dummy linear solver.
+
+        This overrides the base class method and returns an empty linear solver as the harmonic
+        analysis does not need a linear solver.
+        """
+        return KratosMultiphysics.LinearSolver()
+
+    def _CreateSolutionStrategy(self):
+        eigen_scheme = self._GetScheme()
+        builder_and_solver = self._GetBuilderAndSolver()
+        computing_model_part = self.GetComputingModelPart()
+
+        return StructuralMechanicsApplication.HarmonicAnalysisStrategy(computing_model_part,
+                                                                    eigen_scheme,
+                                                                    builder_and_solver,
+                                                                    self.settings["harmonic_analysis_settings"]["use_effective_material_damping"].GetBool())
```

## KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_analysis.py

 * *Ordering differences only*

```diff
@@ -1,214 +1,214 @@
-# Importing Kratos
-import KratosMultiphysics as KM
-import KratosMultiphysics.StructuralMechanicsApplication as SMA
-
-# Other imports
-from KratosMultiphysics.StructuralMechanicsApplication import python_solvers_wrapper_adaptative_remeshing_structural
-
-# Import the base structural analysis
-from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_analysis import StructuralMechanicsAnalysis as BaseClass
-
-class AdaptativeRemeshingStructuralMechanicsAnalysis(BaseClass):
-    """
-    This class is the main-script of the StructuralMechanicsApplication when using adaptative remeshing put in a class
-
-    It can be imported and used as "black-box"
-    """
-    def __init__(self, model, project_parameters):
-
-        # Construct the base analysis.
-        default_params = KM.Parameters("""
-        {
-            "max_iteration" : 1,
-            "analysis_type" : "linear"
-        }
-        """)
-        if project_parameters["solver_settings"].Has("max_iteration"):
-            self.non_linear_iterations = project_parameters["solver_settings"]["max_iteration"].GetInt()
-        else:
-            self.non_linear_iterations = 10
-            project_parameters["solver_settings"].AddValue("max_iteration", default_params["max_iteration"])
-        if project_parameters["solver_settings"].Has("analysis_type"):
-            project_parameters["solver_settings"]["analysis_type"].SetString("linear")
-        else:
-            project_parameters["solver_settings"].AddValue("analysis_type", default_params["analysis_type"])
-        self.process_remesh = False
-        if project_parameters.Has("mesh_adaptivity_processes"):
-            self.process_remesh = True
-        if project_parameters.Has("processes"):
-            if project_parameters["processes"].Has("mesh_adaptivity_processes"):
-                self.process_remesh = True
-        super().__init__(model, project_parameters)
-
-    def Initialize(self):
-        """ Initializing the Analysis """
-        super().Initialize()
-        computing_model_part = self._GetSolver().GetComputingModelPart()
-        if not self.process_remesh:
-            convergence_criteria = self._GetSolver()._GetConvergenceCriterion()
-            convergence_criteria.Initialize(computing_model_part)
-
-        # Ensuring to have conditions on the BC before remesh
-        is_surface = False
-        for elem in computing_model_part.Elements:
-            geom = elem.GetGeometry()
-            if geom.WorkingSpaceDimension() != geom.LocalSpaceDimension():
-                is_surface = True
-            break
-
-        if not is_surface:
-            # We need to detect the conditions in the boundary conditions
-            list_model_parts = []
-            if self.project_parameters.Has("constraints_process_list"):
-                constraints_process_list = self.project_parameters["constraints_process_list"]
-                for i in range(0,constraints_process_list.size()):
-                    item = constraints_process_list[i]
-                    list_model_parts.append(item["Parameters"]["model_part_name"].GetString())
-            skin_detection_parameters = KM.Parameters("""
-            {
-                "list_model_parts_to_assign_conditions" : []
-            }
-            """)
-            for name_mp in list_model_parts:
-                skin_detection_parameters["list_model_parts_to_assign_conditions"].Append(name_mp)
-
-            if computing_model_part.ProcessInfo[KM.DOMAIN_SIZE] == 2:
-                detect_skin = KM.SkinDetectionProcess2D(computing_model_part, skin_detection_parameters)
-            else:
-                detect_skin = KM.SkinDetectionProcess3D(computing_model_part, skin_detection_parameters)
-            detect_skin.Execute()
-        self._GetSolver().SetEchoLevel(self.echo_level)
-
-    def RunSolutionLoop(self):
-        """This function executes the solution loop of the AnalysisStage
-        It can be overridden by derived classes
-        """
-
-        # If we remesh using a process
-        computing_model_part = self._GetSolver().GetComputingModelPart()
-        root_model_part = computing_model_part.GetRootModelPart()
-        if self.process_remesh:
-            while self.time < self.end_time:
-                self.time = self._GetSolver().AdvanceInTime(self.time)
-                # We reinitialize if remeshed previously
-                if root_model_part.Is(KM.MODIFIED):
-                    self._ReInitializeSolver()
-                self.InitializeSolutionStep()
-                # We reinitialize if remeshed on the InitializeSolutionStep
-                if root_model_part.Is(KM.MODIFIED):
-                    self._ReInitializeSolver()
-                    self.InitializeSolutionStep()
-                self._GetSolver().Predict()
-                self._GetSolver().SolveSolutionStep()
-                self.FinalizeSolutionStep()
-                self.OutputSolutionStep()
-        else: # Remeshing adaptively
-            metric_process = self._GetSolver().get_metric_process()
-            remeshing_process = self._GetSolver().get_remeshing_process()
-            convergence_criteria = self._GetSolver()._GetConvergenceCriterion()
-            builder_and_solver = self._GetSolver()._GetBuilderAndSolver()
-            mechanical_solution_strategy = self._GetSolver()._GetSolutionStrategy()
-
-            while self.time < self.end_time:
-                self.time = self._GetSolver().AdvanceInTime(self.time)
-                non_linear_iteration = 1
-                while non_linear_iteration <= self.non_linear_iterations:
-                    if root_model_part.Is(KM.MODIFIED):
-                        self._ReInitializeSolver()
-                    if non_linear_iteration == 1 or root_model_part.Is(KM.MODIFIED):
-                        self.InitializeSolutionStep()
-                        self._GetSolver().Predict()
-                        computing_model_part.Set(KM.MODIFIED, False)
-                    computing_model_part.ProcessInfo.SetValue(KM.NL_ITERATION_NUMBER, non_linear_iteration)
-                    reform_dofs = mechanical_solution_strategy.GetReformDofSetAtEachStepFlag()
-                    mechanical_solution_strategy.SetReformDofSetAtEachStepFlag(True)
-                    is_converged = convergence_criteria.PreCriteria(computing_model_part, builder_and_solver.GetDofSet(), mechanical_solution_strategy.GetSystemMatrix(), mechanical_solution_strategy.GetSolutionVector(), mechanical_solution_strategy.GetSystemVector())
-                    self._GetSolver().SolveSolutionStep()
-                    is_converged = convergence_criteria.PostCriteria(computing_model_part, builder_and_solver.GetDofSet(), mechanical_solution_strategy.GetSystemMatrix(), mechanical_solution_strategy.GetSolutionVector(), mechanical_solution_strategy.GetSystemVector())
-                    self.FinalizeSolutionStep()
-                    mechanical_solution_strategy.SetReformDofSetAtEachStepFlag(reform_dofs)
-                    if is_converged:
-                        KM.Logger.PrintInfo(self._GetSimulationName(), "Adaptative strategy converged in ", non_linear_iteration, "iterations" )
-                        break
-                    elif non_linear_iteration == self.non_linear_iterations:
-                        KM.Logger.PrintInfo(self._GetSimulationName(), "Adaptative strategy not converged after ", non_linear_iteration, "iterations" )
-                        break
-                    else:
-                        metric_process.Execute()
-                        remeshing_process.Execute()
-                        computing_model_part.Set(KM.MODIFIED, True)
-                        non_linear_iteration += 1
-                self.OutputSolutionStep()
-
-    #### Internal functions ####
-    def _CreateSolver(self):
-        """ Create the Solver (and create and import the ModelPart if it is not alread in the model) """
-
-        # To avoid many prints
-        if (self.echo_level == 0):
-            KM.Logger.GetDefaultOutput().SetSeverity(KM.Logger.Severity.WARNING)
-
-        ## Solver construction
-        return python_solvers_wrapper_adaptative_remeshing_structural.CreateSolver(self.model, self.project_parameters)
-
-    def _CreateProcesses(self, parameter_name, initialization_order):
-        """Create a list of Processes
-        This method is TEMPORARY to not break existing code
-        It will be removed in the future
-        """
-        list_of_processes = super()._CreateProcesses(parameter_name, initialization_order)
-
-        if parameter_name == "processes":
-            processes_block_names = ["mesh_adaptivity_processes"]
-            if len(list_of_processes) == 0: # Processes are given in the old format
-                KM.Logger.PrintWarning("AdaptativeRemeshingStructuralMechanicsAnalysis", "Using the old way to create the processes, this will be removed!")
-                from process_factory import KratosProcessFactory
-                factory = KratosProcessFactory(self.model)
-                for process_name in processes_block_names:
-                    if self.project_parameters.Has(process_name):
-                        list_of_processes += factory.ConstructListOfProcesses(self.project_parameters[process_name])
-            else: # Processes are given in the new format
-                for process_name in processes_block_names:
-                    if self.project_parameters.Has(process_name):
-                        raise Exception("Mixing of process initialization is not allowed!")
-        elif parameter_name == "output_processes":
-            pass # Already added
-        else:
-            raise NameError("wrong parameter name")
-
-        return list_of_processes
-
-    def _ReInitializeSolver(self):
-        """ This reinitializes after remesh """
-        self._GetSolver().Clear()
-        # WE INITIALIZE THE SOLVER
-        self._GetSolver().Initialize()
-        # WE RECOMPUTE THE PROCESSES AGAIN
-        ## Processes initialization
-        for process in self._GetListOfProcesses():
-            process.ExecuteInitialize()
-        ## Processes before the loop
-        for process in self._GetListOfProcesses():
-            process.ExecuteBeforeSolutionLoop()
-        ## Processes of initialize the solution step
-        for process in self._GetListOfProcesses():
-            process.ExecuteInitializeSolutionStep()
-
-if __name__ == "__main__":
-    from sys import argv
-
-    if len(argv) > 2:
-        err_msg =  'Too many input arguments!\n'
-        err_msg += 'Use this script in the following way:\n'
-        err_msg += '- With default ProjectParameters (read from "ProjectParameters.json"):\n'
-        err_msg += '    "python3 contact_structural_mechanics_analysis.py"\n'
-        err_msg += '- With custom ProjectParameters:\n'
-        err_msg += '    "python3 contact_structural_mechanics_analysis.py CustomProjectParameters.json"\n'
-        raise Exception(err_msg)
-
-    if len(argv) == 2: # ProjectParameters is being passed from outside
-        project_parameters_file_name = argv[1]
-    else: # using default name
-        project_parameters_file_name = "ProjectParameters.json"
-
-    AdaptativeRemeshingStructuralMechanicsAnalysis(project_parameters_file_name).Run()
+# Importing Kratos
+import KratosMultiphysics as KM
+import KratosMultiphysics.StructuralMechanicsApplication as SMA
+
+# Other imports
+from KratosMultiphysics.StructuralMechanicsApplication import python_solvers_wrapper_adaptative_remeshing_structural
+
+# Import the base structural analysis
+from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_analysis import StructuralMechanicsAnalysis as BaseClass
+
+class AdaptativeRemeshingStructuralMechanicsAnalysis(BaseClass):
+    """
+    This class is the main-script of the StructuralMechanicsApplication when using adaptative remeshing put in a class
+
+    It can be imported and used as "black-box"
+    """
+    def __init__(self, model, project_parameters):
+
+        # Construct the base analysis.
+        default_params = KM.Parameters("""
+        {
+            "max_iteration" : 1,
+            "analysis_type" : "linear"
+        }
+        """)
+        if project_parameters["solver_settings"].Has("max_iteration"):
+            self.non_linear_iterations = project_parameters["solver_settings"]["max_iteration"].GetInt()
+        else:
+            self.non_linear_iterations = 10
+            project_parameters["solver_settings"].AddValue("max_iteration", default_params["max_iteration"])
+        if project_parameters["solver_settings"].Has("analysis_type"):
+            project_parameters["solver_settings"]["analysis_type"].SetString("linear")
+        else:
+            project_parameters["solver_settings"].AddValue("analysis_type", default_params["analysis_type"])
+        self.process_remesh = False
+        if project_parameters.Has("mesh_adaptivity_processes"):
+            self.process_remesh = True
+        if project_parameters.Has("processes"):
+            if project_parameters["processes"].Has("mesh_adaptivity_processes"):
+                self.process_remesh = True
+        super().__init__(model, project_parameters)
+
+    def Initialize(self):
+        """ Initializing the Analysis """
+        super().Initialize()
+        computing_model_part = self._GetSolver().GetComputingModelPart()
+        if not self.process_remesh:
+            convergence_criteria = self._GetSolver()._GetConvergenceCriterion()
+            convergence_criteria.Initialize(computing_model_part)
+
+        # Ensuring to have conditions on the BC before remesh
+        is_surface = False
+        for elem in computing_model_part.Elements:
+            geom = elem.GetGeometry()
+            if geom.WorkingSpaceDimension() != geom.LocalSpaceDimension():
+                is_surface = True
+            break
+
+        if not is_surface:
+            # We need to detect the conditions in the boundary conditions
+            list_model_parts = []
+            if self.project_parameters.Has("constraints_process_list"):
+                constraints_process_list = self.project_parameters["constraints_process_list"]
+                for i in range(0,constraints_process_list.size()):
+                    item = constraints_process_list[i]
+                    list_model_parts.append(item["Parameters"]["model_part_name"].GetString())
+            skin_detection_parameters = KM.Parameters("""
+            {
+                "list_model_parts_to_assign_conditions" : []
+            }
+            """)
+            for name_mp in list_model_parts:
+                skin_detection_parameters["list_model_parts_to_assign_conditions"].Append(name_mp)
+
+            if computing_model_part.ProcessInfo[KM.DOMAIN_SIZE] == 2:
+                detect_skin = KM.SkinDetectionProcess2D(computing_model_part, skin_detection_parameters)
+            else:
+                detect_skin = KM.SkinDetectionProcess3D(computing_model_part, skin_detection_parameters)
+            detect_skin.Execute()
+        self._GetSolver().SetEchoLevel(self.echo_level)
+
+    def RunSolutionLoop(self):
+        """This function executes the solution loop of the AnalysisStage
+        It can be overridden by derived classes
+        """
+
+        # If we remesh using a process
+        computing_model_part = self._GetSolver().GetComputingModelPart()
+        root_model_part = computing_model_part.GetRootModelPart()
+        if self.process_remesh:
+            while self.time < self.end_time:
+                self.time = self._GetSolver().AdvanceInTime(self.time)
+                # We reinitialize if remeshed previously
+                if root_model_part.Is(KM.MODIFIED):
+                    self._ReInitializeSolver()
+                self.InitializeSolutionStep()
+                # We reinitialize if remeshed on the InitializeSolutionStep
+                if root_model_part.Is(KM.MODIFIED):
+                    self._ReInitializeSolver()
+                    self.InitializeSolutionStep()
+                self._GetSolver().Predict()
+                self._GetSolver().SolveSolutionStep()
+                self.FinalizeSolutionStep()
+                self.OutputSolutionStep()
+        else: # Remeshing adaptively
+            metric_process = self._GetSolver().get_metric_process()
+            remeshing_process = self._GetSolver().get_remeshing_process()
+            convergence_criteria = self._GetSolver()._GetConvergenceCriterion()
+            builder_and_solver = self._GetSolver()._GetBuilderAndSolver()
+            mechanical_solution_strategy = self._GetSolver()._GetSolutionStrategy()
+
+            while self.time < self.end_time:
+                self.time = self._GetSolver().AdvanceInTime(self.time)
+                non_linear_iteration = 1
+                while non_linear_iteration <= self.non_linear_iterations:
+                    if root_model_part.Is(KM.MODIFIED):
+                        self._ReInitializeSolver()
+                    if non_linear_iteration == 1 or root_model_part.Is(KM.MODIFIED):
+                        self.InitializeSolutionStep()
+                        self._GetSolver().Predict()
+                        computing_model_part.Set(KM.MODIFIED, False)
+                    computing_model_part.ProcessInfo.SetValue(KM.NL_ITERATION_NUMBER, non_linear_iteration)
+                    reform_dofs = mechanical_solution_strategy.GetReformDofSetAtEachStepFlag()
+                    mechanical_solution_strategy.SetReformDofSetAtEachStepFlag(True)
+                    is_converged = convergence_criteria.PreCriteria(computing_model_part, builder_and_solver.GetDofSet(), mechanical_solution_strategy.GetSystemMatrix(), mechanical_solution_strategy.GetSolutionVector(), mechanical_solution_strategy.GetSystemVector())
+                    self._GetSolver().SolveSolutionStep()
+                    is_converged = convergence_criteria.PostCriteria(computing_model_part, builder_and_solver.GetDofSet(), mechanical_solution_strategy.GetSystemMatrix(), mechanical_solution_strategy.GetSolutionVector(), mechanical_solution_strategy.GetSystemVector())
+                    self.FinalizeSolutionStep()
+                    mechanical_solution_strategy.SetReformDofSetAtEachStepFlag(reform_dofs)
+                    if is_converged:
+                        KM.Logger.PrintInfo(self._GetSimulationName(), "Adaptative strategy converged in ", non_linear_iteration, "iterations" )
+                        break
+                    elif non_linear_iteration == self.non_linear_iterations:
+                        KM.Logger.PrintInfo(self._GetSimulationName(), "Adaptative strategy not converged after ", non_linear_iteration, "iterations" )
+                        break
+                    else:
+                        metric_process.Execute()
+                        remeshing_process.Execute()
+                        computing_model_part.Set(KM.MODIFIED, True)
+                        non_linear_iteration += 1
+                self.OutputSolutionStep()
+
+    #### Internal functions ####
+    def _CreateSolver(self):
+        """ Create the Solver (and create and import the ModelPart if it is not alread in the model) """
+
+        # To avoid many prints
+        if (self.echo_level == 0):
+            KM.Logger.GetDefaultOutput().SetSeverity(KM.Logger.Severity.WARNING)
+
+        ## Solver construction
+        return python_solvers_wrapper_adaptative_remeshing_structural.CreateSolver(self.model, self.project_parameters)
+
+    def _CreateProcesses(self, parameter_name, initialization_order):
+        """Create a list of Processes
+        This method is TEMPORARY to not break existing code
+        It will be removed in the future
+        """
+        list_of_processes = super()._CreateProcesses(parameter_name, initialization_order)
+
+        if parameter_name == "processes":
+            processes_block_names = ["mesh_adaptivity_processes"]
+            if len(list_of_processes) == 0: # Processes are given in the old format
+                KM.Logger.PrintWarning("AdaptativeRemeshingStructuralMechanicsAnalysis", "Using the old way to create the processes, this will be removed!")
+                from process_factory import KratosProcessFactory
+                factory = KratosProcessFactory(self.model)
+                for process_name in processes_block_names:
+                    if self.project_parameters.Has(process_name):
+                        list_of_processes += factory.ConstructListOfProcesses(self.project_parameters[process_name])
+            else: # Processes are given in the new format
+                for process_name in processes_block_names:
+                    if self.project_parameters.Has(process_name):
+                        raise Exception("Mixing of process initialization is not allowed!")
+        elif parameter_name == "output_processes":
+            pass # Already added
+        else:
+            raise NameError("wrong parameter name")
+
+        return list_of_processes
+
+    def _ReInitializeSolver(self):
+        """ This reinitializes after remesh """
+        self._GetSolver().Clear()
+        # WE INITIALIZE THE SOLVER
+        self._GetSolver().Initialize()
+        # WE RECOMPUTE THE PROCESSES AGAIN
+        ## Processes initialization
+        for process in self._GetListOfProcesses():
+            process.ExecuteInitialize()
+        ## Processes before the loop
+        for process in self._GetListOfProcesses():
+            process.ExecuteBeforeSolutionLoop()
+        ## Processes of initialize the solution step
+        for process in self._GetListOfProcesses():
+            process.ExecuteInitializeSolutionStep()
+
+if __name__ == "__main__":
+    from sys import argv
+
+    if len(argv) > 2:
+        err_msg =  'Too many input arguments!\n'
+        err_msg += 'Use this script in the following way:\n'
+        err_msg += '- With default ProjectParameters (read from "ProjectParameters.json"):\n'
+        err_msg += '    "python3 contact_structural_mechanics_analysis.py"\n'
+        err_msg += '- With custom ProjectParameters:\n'
+        err_msg += '    "python3 contact_structural_mechanics_analysis.py CustomProjectParameters.json"\n'
+        raise Exception(err_msg)
+
+    if len(argv) == 2: # ProjectParameters is being passed from outside
+        project_parameters_file_name = argv[1]
+    else: # using default name
+        project_parameters_file_name = "ProjectParameters.json"
+
+    AdaptativeRemeshingStructuralMechanicsAnalysis(project_parameters_file_name).Run()
```

## KratosMultiphysics/StructuralMechanicsApplication/set_automated_initial_variable_process.py

 * *Ordering differences only*

```diff
@@ -1,102 +1,102 @@
-# Importing the Kratos Library
-from pathlib import Path
-import KratosMultiphysics as KM
-import KratosMultiphysics.StructuralMechanicsApplication as SMA
-from KratosMultiphysics import Logger
-from KratosMultiphysics.read_csv_table_utility import ReadCsvTableUtility
-
-def Factory(settings, Model):
-    if not isinstance(settings, KM.Parameters):
-        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
-    
-    """
-    This process reads tables in csv format containing the strain/stress components as function of the spatial radial coordinate from the edge of a given hole.
-    Tables are defined by layers ortogonally to the radial direction (generatrix hole direction). Each layer of elements must be allocated in a modelpart.
-    Stress components provided by the tables (linear picewise tables) are interpolated according to each element centroid. 
-    Interpolated components are transfered to the initial variable (INITIAL_STRAIN_VECTOR/INITIAL_STRESS_VECTOR).
-    A minimum of one table per layer must be provided to the process. 
-    Missing stress component are considered to be zero in the INITIAL_STRAIN_VECTOR/INITIAL_STRESS_VECTOR variables. 
-    Tables corresponding to out of range strain/stress components are neglect (e.g. Layer1_StresComp7, Layer2_StresComp8).
-    """
-
-    default_settings = KM.Parameters(
-        """{
-            "help"                     : "This automates the application of initial strain/stress variables using csv tables",
-            "model_part_name"          : "please_specify_model_part_name",
-            "variable_name"            : "SPECIFY_VARIABLE_NAME",
-            "hole_generatrix_axis"     : [0.0,0.0,1.0],
-            "hole_generatrix_point"    : [0.0,0.0,0.0],
-            "hole_radius_offset"       : 0.0,
-            "initial_variable_table"     : {
-                        "name"             : "csv_table",
-                        "filename"         : "sample.csv",
-                        "delimiter"        : ",",
-                        "skiprows"         : 1,
-                        "first_column_id"  : 0,
-                        "second_column_id" : 1,
-                        "na_replace"       : 0.0
-                    }
-        }""")
-    process_settings = settings["Parameters"]
-    process_settings.ValidateAndAssignDefaults(default_settings)
-    computing_model_part = Model[process_settings["model_part_name"].GetString()]
-
-    default_table_id = KM.Parameters("""{
-    "table_id": 0
-    }""")
-    process_settings["initial_variable_table"].AddValue("table_id", default_table_id)
-
-    file_path = Path(process_settings["initial_variable_table"]["filename"].GetString())
-    layer_name = file_path.name.split("_")[0]
-
-    layer_list = [file for file in file_path.parent.iterdir() if file.name.split("_")[0] == layer_name]
-
-    if not layer_list:
-        ErrorMsg = f"Tables of {layer_name} not found"
-        raise RuntimeError(ErrorMsg)
-    else:
-        component_list = []
-        table_id_list = []
-        out_of_range_component_list = []
-        for i in range (0, len(layer_list)):
-            component_number = int(layer_list[i].stem.split("_")[1][-1])
-            if  0 < component_number < 7:
-                component_list.append(component_number)
-                table_id = int("".join(layer_number for layer_number in layer_name if layer_number.isdigit()) + str(component_number - 1))
-                table_id_list.append(table_id)
-                process_settings["initial_variable_table"]["filename"].SetString(layer_list[i].as_posix())
-                process_settings["initial_variable_table"]["table_id"].SetInt(table_id)
-                ReadCsvTableUtility(process_settings["initial_variable_table"]).Read(computing_model_part)
-            else:
-                out_of_range_component_list.append(component_number)
-
-    raw_variable_name = process_settings["variable_name"].GetString()
-    variable_name = raw_variable_name.split("_")[0] + " " + raw_variable_name.split("_")[1].split("_")[0]
-
-    if len(out_of_range_component_list) != 0:
-        if len(out_of_range_component_list) == 1:
-            Logger.PrintWarning("SetAutomatedInitialVariableProcess:: ", f"{variable_name.capitalize()} component {out_of_range_component_list[0]} of {layer_name} is out of range. The corresponding table will be neglected")
-        else:
-            out_of_range_component_name = ", ".join(str(out_of_range_component) for (out_of_range_component) in out_of_range_component_list)
-            Logger.PrintWarning("SetAutomatedInitialVariableProcess:: ", f"{variable_name.capitalize()} components {out_of_range_component_name} of {layer_name} are out of range. Correspoding tables will be negleted")   
-
-    if len(component_list) < 6:
-        missing_component_list = list(set(range(1,7)).difference(component_list))
-        if len(missing_component_list) == 1:
-            Logger.PrintWarning("SetAutomatedInitialVariableProcess:: ", f"Table correspoding to {variable_name.lower()} component {str(missing_component_list[0])} of {layer_name} not found. A zero entry will be added to the {raw_variable_name} variable")
-        else:
-            missing_component_name = ", ".join(str(missing_component) for (missing_component) in missing_component_list)
-            Logger.PrintWarning("SetAutomatedInitialVariableProcess:: ", f"Tables correspoding to {variable_name.lower()} components {missing_component_name} of {layer_name} not found. Zero entries will be added to the {raw_variable_name} variable")
-    else:
-        Logger.PrintInfo("SetAutomatedInitialVariableProcess:: ", f"{variable_name.capitalize()} tables of {layer_name} were successfully imported")
-    
-    default_table_id_vector = KM.Parameters("""{
-    "table_id_vector": [10,11,12,13,14,15]
-    }""")
-    process_settings.AddEmptyValue("table_id_vector").SetVector(table_id_list)
-
-    process_settings.RemoveValue("help")
-    process_settings.RemoveValue("model_part_name")
-    process_settings.RemoveValue("initial_variable_table")
-
+# Importing the Kratos Library
+from pathlib import Path
+import KratosMultiphysics as KM
+import KratosMultiphysics.StructuralMechanicsApplication as SMA
+from KratosMultiphysics import Logger
+from KratosMultiphysics.read_csv_table_utility import ReadCsvTableUtility
+
+def Factory(settings, Model):
+    if not isinstance(settings, KM.Parameters):
+        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
+    
+    """
+    This process reads tables in csv format containing the strain/stress components as function of the spatial radial coordinate from the edge of a given hole.
+    Tables are defined by layers ortogonally to the radial direction (generatrix hole direction). Each layer of elements must be allocated in a modelpart.
+    Stress components provided by the tables (linear picewise tables) are interpolated according to each element centroid. 
+    Interpolated components are transfered to the initial variable (INITIAL_STRAIN_VECTOR/INITIAL_STRESS_VECTOR).
+    A minimum of one table per layer must be provided to the process. 
+    Missing stress component are considered to be zero in the INITIAL_STRAIN_VECTOR/INITIAL_STRESS_VECTOR variables. 
+    Tables corresponding to out of range strain/stress components are neglect (e.g. Layer1_StresComp7, Layer2_StresComp8).
+    """
+
+    default_settings = KM.Parameters(
+        """{
+            "help"                     : "This automates the application of initial strain/stress variables using csv tables",
+            "model_part_name"          : "please_specify_model_part_name",
+            "variable_name"            : "SPECIFY_VARIABLE_NAME",
+            "hole_generatrix_axis"     : [0.0,0.0,1.0],
+            "hole_generatrix_point"    : [0.0,0.0,0.0],
+            "hole_radius_offset"       : 0.0,
+            "initial_variable_table"     : {
+                        "name"             : "csv_table",
+                        "filename"         : "sample.csv",
+                        "delimiter"        : ",",
+                        "skiprows"         : 1,
+                        "first_column_id"  : 0,
+                        "second_column_id" : 1,
+                        "na_replace"       : 0.0
+                    }
+        }""")
+    process_settings = settings["Parameters"]
+    process_settings.ValidateAndAssignDefaults(default_settings)
+    computing_model_part = Model[process_settings["model_part_name"].GetString()]
+
+    default_table_id = KM.Parameters("""{
+    "table_id": 0
+    }""")
+    process_settings["initial_variable_table"].AddValue("table_id", default_table_id)
+
+    file_path = Path(process_settings["initial_variable_table"]["filename"].GetString())
+    layer_name = file_path.name.split("_")[0]
+
+    layer_list = [file for file in file_path.parent.iterdir() if file.name.split("_")[0] == layer_name]
+
+    if not layer_list:
+        ErrorMsg = f"Tables of {layer_name} not found"
+        raise RuntimeError(ErrorMsg)
+    else:
+        component_list = []
+        table_id_list = []
+        out_of_range_component_list = []
+        for i in range (0, len(layer_list)):
+            component_number = int(layer_list[i].stem.split("_")[1][-1])
+            if  0 < component_number < 7:
+                component_list.append(component_number)
+                table_id = int("".join(layer_number for layer_number in layer_name if layer_number.isdigit()) + str(component_number - 1))
+                table_id_list.append(table_id)
+                process_settings["initial_variable_table"]["filename"].SetString(layer_list[i].as_posix())
+                process_settings["initial_variable_table"]["table_id"].SetInt(table_id)
+                ReadCsvTableUtility(process_settings["initial_variable_table"]).Read(computing_model_part)
+            else:
+                out_of_range_component_list.append(component_number)
+
+    raw_variable_name = process_settings["variable_name"].GetString()
+    variable_name = raw_variable_name.split("_")[0] + " " + raw_variable_name.split("_")[1].split("_")[0]
+
+    if len(out_of_range_component_list) != 0:
+        if len(out_of_range_component_list) == 1:
+            Logger.PrintWarning("SetAutomatedInitialVariableProcess:: ", f"{variable_name.capitalize()} component {out_of_range_component_list[0]} of {layer_name} is out of range. The corresponding table will be neglected")
+        else:
+            out_of_range_component_name = ", ".join(str(out_of_range_component) for (out_of_range_component) in out_of_range_component_list)
+            Logger.PrintWarning("SetAutomatedInitialVariableProcess:: ", f"{variable_name.capitalize()} components {out_of_range_component_name} of {layer_name} are out of range. Correspoding tables will be negleted")   
+
+    if len(component_list) < 6:
+        missing_component_list = list(set(range(1,7)).difference(component_list))
+        if len(missing_component_list) == 1:
+            Logger.PrintWarning("SetAutomatedInitialVariableProcess:: ", f"Table correspoding to {variable_name.lower()} component {str(missing_component_list[0])} of {layer_name} not found. A zero entry will be added to the {raw_variable_name} variable")
+        else:
+            missing_component_name = ", ".join(str(missing_component) for (missing_component) in missing_component_list)
+            Logger.PrintWarning("SetAutomatedInitialVariableProcess:: ", f"Tables correspoding to {variable_name.lower()} components {missing_component_name} of {layer_name} not found. Zero entries will be added to the {raw_variable_name} variable")
+    else:
+        Logger.PrintInfo("SetAutomatedInitialVariableProcess:: ", f"{variable_name.capitalize()} tables of {layer_name} were successfully imported")
+    
+    default_table_id_vector = KM.Parameters("""{
+    "table_id_vector": [10,11,12,13,14,15]
+    }""")
+    process_settings.AddEmptyValue("table_id_vector").SetVector(table_id_list)
+
+    process_settings.RemoveValue("help")
+    process_settings.RemoveValue("model_part_name")
+    process_settings.RemoveValue("initial_variable_table")
+
     return SMA.SetAutomatedInitialVariableProcess(computing_model_part, process_settings)
```

## KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_prebuckling_solver.py

 * *Ordering differences only*

```diff
@@ -1,118 +1,118 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-
-# Import base class file
-from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
-
-from KratosMultiphysics import eigen_solver_factory
-from KratosMultiphysics.StructuralMechanicsApplication import convergence_criteria_factory
-
-def CreateSolver(main_model_part, custom_settings):
-    return PrebucklingSolver(main_model_part, custom_settings)
-
-class PrebucklingSolver(MechanicalSolver):
-    """The structural mechanics prebuckling solver.
-
-    This class creates the mechanical solvers for prebuckling analysis.
-
-    See structural_mechanics_solver.py for more information.
-    """
-    def __init__(self, main_model_part, custom_settings):
-        # Construct the base solver.
-        super().__init__(main_model_part, custom_settings)
-        KratosMultiphysics.Logger.PrintInfo("::[PrebucklingSolver]:: ", "Construction finished")
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KratosMultiphysics.Parameters("""{
-            "buckling_settings"     : {
-                "initial_load_increment"    : 1.0,
-                "small_load_increment"      : 0.0005,
-                "path_following_step"       : 0.5,
-                "convergence_ratio"         : 0.05,
-                "make_matrices_symmetric"   : true
-            },
-            "eigensolver_settings" : {
-                "solver_type"           : "eigen_eigensystem",
-                "max_iteration"         : 1000,
-                "tolerance"             : 1e-6,
-                "number_of_eigenvalues" : 5,
-                "echo_level"            : 1
-            }
-        }""")
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
-
-    #### Private functions ####
-    def AdvanceInTime(self, current_time):
-        new_time = self.main_model_part.ProcessInfo[KratosMultiphysics.TIME]
-        self.main_model_part.ProcessInfo[KratosMultiphysics.STEP] += 1
-        self.main_model_part.CloneTimeStep(new_time)
-
-        return new_time
-
-    def _CreateScheme(self):
-        return KratosMultiphysics.ResidualBasedIncrementalUpdateStaticScheme()
-
-    # Builder and Solver Eigen
-    def _GetBuilderAndSolverEigen(self):
-        if not hasattr(self, '_builder_and_solver_eigen'):
-            self._builder_and_solver_eigen = self._CreateBuilderAndSolverEigen()
-        return self._builder_and_solver_eigen
-
-    def _CreateBuilderAndSolverEigen(self):
-        linear_solver = self._GetLinearSolverEigen()
-        builder_and_solver = KratosMultiphysics.ResidualBasedEliminationBuilderAndSolver(linear_solver)
-        return builder_and_solver
-
-    def _GetLinearSolverEigen(self):
-        if not hasattr(self, '_linear_solver_eigen'):
-            self._linear_solver_eigen = self._CreateLinearSolverEigen()
-        return self._linear_solver_eigen
-
-    def _CreateLinearSolverEigen(self):
-        """Create the eigensolver"""
-        return eigen_solver_factory.ConstructSolver(self.settings["eigensolver_settings"])
-
-    # Builder and Solver Static
-    def _CreateBuilderAndSolver(self):
-        """This method is overridden to make sure it always uses ResidualBasedEliminationBuilderAndSolver"""
-        if self.settings["builder_and_solver_settings"]["use_block_builder"].GetBool():
-            warn_msg = '"Elimination Builder is required. \n'
-            warn_msg += '"use_block_builder" specification will be ignored'
-            KratosMultiphysics.Logger.PrintWarning("StructuralMechanicsPrebucklingAnalysis; Warning", warn_msg)
-        linear_solver = self._GetLinearSolver()
-        builder_and_solver = KratosMultiphysics.ResidualBasedEliminationBuilderAndSolver(linear_solver)
-        return builder_and_solver
-
-    # Convergence Criterion
-    def _CreateConvergenceCriterion(self):
-        """This method is overridden to make sure it always uses "displacement_criterion" """
-        convergence_criterion_setting = self._get_convergence_criterion_settings()
-        if convergence_criterion_setting["convergence_criterion"].GetString() != "displacement_criterion":
-            warn_msg = 'Convergence criterion "displacement_criterion" is required. \n'
-            warn_msg += '"' + convergence_criterion_setting["convergence_criterion"].GetString() + '" specification will be ignored'
-            KratosMultiphysics.Logger.PrintWarning("StructuralMechanicsPrebucklingAnalysis; Warning", warn_msg)
-            convergence_criterion_setting["convergence_criterion"].SetString("displacement_criterion")
-
-        convergence_criterion = convergence_criteria_factory.convergence_criterion(convergence_criterion_setting)
-        return convergence_criterion.mechanical_convergence_criterion
-
-    def _CreateSolutionStrategy(self):
-        solution_scheme = self._GetScheme()
-        eigen_solver = self._GetBuilderAndSolverEigen() # The eigensolver is created here.
-        builder_and_solver = self._GetBuilderAndSolver() # The linear solver is created here.
-        convergence_criteria = self._GetConvergenceCriterion()
-        computing_model_part = self.GetComputingModelPart()
-        buckling_settings = self.settings["buckling_settings"]
-
-        return StructuralMechanicsApplication.PrebucklingStrategy(computing_model_part,
-                                                                  solution_scheme,
-                                                                  eigen_solver,
-                                                                  builder_and_solver,
-                                                                  convergence_criteria,
-                                                                  self.settings["max_iteration"].GetInt(),
-                                                                  buckling_settings )
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+
+# Import base class file
+from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
+
+from KratosMultiphysics import eigen_solver_factory
+from KratosMultiphysics.StructuralMechanicsApplication import convergence_criteria_factory
+
+def CreateSolver(main_model_part, custom_settings):
+    return PrebucklingSolver(main_model_part, custom_settings)
+
+class PrebucklingSolver(MechanicalSolver):
+    """The structural mechanics prebuckling solver.
+
+    This class creates the mechanical solvers for prebuckling analysis.
+
+    See structural_mechanics_solver.py for more information.
+    """
+    def __init__(self, main_model_part, custom_settings):
+        # Construct the base solver.
+        super().__init__(main_model_part, custom_settings)
+        KratosMultiphysics.Logger.PrintInfo("::[PrebucklingSolver]:: ", "Construction finished")
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KratosMultiphysics.Parameters("""{
+            "buckling_settings"     : {
+                "initial_load_increment"    : 1.0,
+                "small_load_increment"      : 0.0005,
+                "path_following_step"       : 0.5,
+                "convergence_ratio"         : 0.05,
+                "make_matrices_symmetric"   : true
+            },
+            "eigensolver_settings" : {
+                "solver_type"           : "eigen_eigensystem",
+                "max_iteration"         : 1000,
+                "tolerance"             : 1e-6,
+                "number_of_eigenvalues" : 5,
+                "echo_level"            : 1
+            }
+        }""")
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
+
+    #### Private functions ####
+    def AdvanceInTime(self, current_time):
+        new_time = self.main_model_part.ProcessInfo[KratosMultiphysics.TIME]
+        self.main_model_part.ProcessInfo[KratosMultiphysics.STEP] += 1
+        self.main_model_part.CloneTimeStep(new_time)
+
+        return new_time
+
+    def _CreateScheme(self):
+        return KratosMultiphysics.ResidualBasedIncrementalUpdateStaticScheme()
+
+    # Builder and Solver Eigen
+    def _GetBuilderAndSolverEigen(self):
+        if not hasattr(self, '_builder_and_solver_eigen'):
+            self._builder_and_solver_eigen = self._CreateBuilderAndSolverEigen()
+        return self._builder_and_solver_eigen
+
+    def _CreateBuilderAndSolverEigen(self):
+        linear_solver = self._GetLinearSolverEigen()
+        builder_and_solver = KratosMultiphysics.ResidualBasedEliminationBuilderAndSolver(linear_solver)
+        return builder_and_solver
+
+    def _GetLinearSolverEigen(self):
+        if not hasattr(self, '_linear_solver_eigen'):
+            self._linear_solver_eigen = self._CreateLinearSolverEigen()
+        return self._linear_solver_eigen
+
+    def _CreateLinearSolverEigen(self):
+        """Create the eigensolver"""
+        return eigen_solver_factory.ConstructSolver(self.settings["eigensolver_settings"])
+
+    # Builder and Solver Static
+    def _CreateBuilderAndSolver(self):
+        """This method is overridden to make sure it always uses ResidualBasedEliminationBuilderAndSolver"""
+        if self.settings["builder_and_solver_settings"]["use_block_builder"].GetBool():
+            warn_msg = '"Elimination Builder is required. \n'
+            warn_msg += '"use_block_builder" specification will be ignored'
+            KratosMultiphysics.Logger.PrintWarning("StructuralMechanicsPrebucklingAnalysis; Warning", warn_msg)
+        linear_solver = self._GetLinearSolver()
+        builder_and_solver = KratosMultiphysics.ResidualBasedEliminationBuilderAndSolver(linear_solver)
+        return builder_and_solver
+
+    # Convergence Criterion
+    def _CreateConvergenceCriterion(self):
+        """This method is overridden to make sure it always uses "displacement_criterion" """
+        convergence_criterion_setting = self._get_convergence_criterion_settings()
+        if convergence_criterion_setting["convergence_criterion"].GetString() != "displacement_criterion":
+            warn_msg = 'Convergence criterion "displacement_criterion" is required. \n'
+            warn_msg += '"' + convergence_criterion_setting["convergence_criterion"].GetString() + '" specification will be ignored'
+            KratosMultiphysics.Logger.PrintWarning("StructuralMechanicsPrebucklingAnalysis; Warning", warn_msg)
+            convergence_criterion_setting["convergence_criterion"].SetString("displacement_criterion")
+
+        convergence_criterion = convergence_criteria_factory.convergence_criterion(convergence_criterion_setting)
+        return convergence_criterion.mechanical_convergence_criterion
+
+    def _CreateSolutionStrategy(self):
+        solution_scheme = self._GetScheme()
+        eigen_solver = self._GetBuilderAndSolverEigen() # The eigensolver is created here.
+        builder_and_solver = self._GetBuilderAndSolver() # The linear solver is created here.
+        convergence_criteria = self._GetConvergenceCriterion()
+        computing_model_part = self.GetComputingModelPart()
+        buckling_settings = self.settings["buckling_settings"]
+
+        return StructuralMechanicsApplication.PrebucklingStrategy(computing_model_part,
+                                                                  solution_scheme,
+                                                                  eigen_solver,
+                                                                  builder_and_solver,
+                                                                  convergence_criteria,
+                                                                  self.settings["max_iteration"].GetInt(),
+                                                                  buckling_settings )
```

## KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_static_solver.py

 * *Ordering differences only*

```diff
@@ -1,23 +1,23 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import base class file
-from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
-
-def CreateSolver(model, custom_settings):
-    return StaticMechanicalSolver(model, custom_settings)
-
-class StaticMechanicalSolver(MechanicalSolver):
-    """The structural mechanics static solver.
-
-    This class creates the mechanical solvers for static analysis.
-
-    See structural_mechanics_solver.py for more information.
-    """
-    def __init__(self, model, custom_settings):
-        # Construct the base solver.
-        super().__init__(model, custom_settings)
-        KratosMultiphysics.Logger.PrintInfo("::[StaticMechanicalSolver]:: ", "Construction finished")
-
-    def _CreateScheme(self):
-        return KratosMultiphysics.ResidualBasedIncrementalUpdateStaticScheme()
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import base class file
+from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
+
+def CreateSolver(model, custom_settings):
+    return StaticMechanicalSolver(model, custom_settings)
+
+class StaticMechanicalSolver(MechanicalSolver):
+    """The structural mechanics static solver.
+
+    This class creates the mechanical solvers for static analysis.
+
+    See structural_mechanics_solver.py for more information.
+    """
+    def __init__(self, model, custom_settings):
+        # Construct the base solver.
+        super().__init__(model, custom_settings)
+        KratosMultiphysics.Logger.PrintInfo("::[StaticMechanicalSolver]:: ", "Construction finished")
+
+    def _CreateScheme(self):
+        return KratosMultiphysics.ResidualBasedIncrementalUpdateStaticScheme()
```

## KratosMultiphysics/StructuralMechanicsApplication/perturb_geometry_subgrid_utility.py

 * *Ordering differences only*

```diff
@@ -1,57 +1,57 @@
-
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-from KratosMultiphysics import eigen_solver_factory
-
-import random
-
-class PerturbGeometrySubgridUtility():
-    """An utility to perturb the initial geometry of a structure
-    based on a reduced correlation matrix.
-    """
-    def __init__(self, mp, settings ):
-        """Constructor of Utility-Object
-
-        Checks parameter settings and initializes the utility.
-        """
-        default_settings = KratosMultiphysics.Parameters("""{
-            "eigensolver_settings"  : {
-                "solver_type"               : "dense_eigensolver",
-                "ascending_order"           : false
-                },
-            "perturbation_settings" : {
-                "min_distance_subgrid"      : 10,
-                "max_displacement"          : 1,
-                "correlation_length"        : 100,
-                "truncation_error"          : 1e-3,
-                "echo_level"                : 0
-            }
-        }""")
-
-        settings.ValidateAndAssignDefaults(default_settings)
-        eigensolver_settings = settings["eigensolver_settings"]
-
-        if( eigensolver_settings["ascending_order"].GetBool() ):
-            warn_msg = 'Eigenvalues must be sorted in descending order. \n'
-            warn_msg += '''Parameter: '"ascending_order" : true' specification is ignored.'''
-            KratosMultiphysics.Logger.PrintWarning("PerturbGeometrySubgridUtility", warn_msg)
-            eigensolver_settings["ascending_order"].SetBool(False)
-
-        eigen_solver = eigen_solver_factory.ConstructSolver(eigensolver_settings)
-        mp.AddNodalSolutionStepVariable(KratosMultiphysics.NORMAL)
-        perturbation_settings = settings["perturbation_settings"]
-        # Initialize utility
-        self.utility = StructuralMechanicsApplication.PerturbGeometrySubgridUtility(mp, eigen_solver, perturbation_settings)
-        # Generate perturbation matrix
-        self.number_random_variables = self.utility.CreateRandomFieldVectors()
-
-
-    def PerturbGeometry(self, mp ):
-        """Apply perturbation matrix to geometry.
-        Random field approach requires normal distributed random numbers (mean=0, sigma=1)
-        """
-        random_numbers = [random.gauss(0, 1) for i in range(self.number_random_variables)]
-        self.utility.ApplyRandomFieldVectorsToGeometry(mp, random_numbers)
+
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+from KratosMultiphysics import eigen_solver_factory
+
+import random
+
+class PerturbGeometrySubgridUtility():
+    """An utility to perturb the initial geometry of a structure
+    based on a reduced correlation matrix.
+    """
+    def __init__(self, mp, settings ):
+        """Constructor of Utility-Object
+
+        Checks parameter settings and initializes the utility.
+        """
+        default_settings = KratosMultiphysics.Parameters("""{
+            "eigensolver_settings"  : {
+                "solver_type"               : "dense_eigensolver",
+                "ascending_order"           : false
+                },
+            "perturbation_settings" : {
+                "min_distance_subgrid"      : 10,
+                "max_displacement"          : 1,
+                "correlation_length"        : 100,
+                "truncation_error"          : 1e-3,
+                "echo_level"                : 0
+            }
+        }""")
+
+        settings.ValidateAndAssignDefaults(default_settings)
+        eigensolver_settings = settings["eigensolver_settings"]
+
+        if( eigensolver_settings["ascending_order"].GetBool() ):
+            warn_msg = 'Eigenvalues must be sorted in descending order. \n'
+            warn_msg += '''Parameter: '"ascending_order" : true' specification is ignored.'''
+            KratosMultiphysics.Logger.PrintWarning("PerturbGeometrySubgridUtility", warn_msg)
+            eigensolver_settings["ascending_order"].SetBool(False)
+
+        eigen_solver = eigen_solver_factory.ConstructSolver(eigensolver_settings)
+        mp.AddNodalSolutionStepVariable(KratosMultiphysics.NORMAL)
+        perturbation_settings = settings["perturbation_settings"]
+        # Initialize utility
+        self.utility = StructuralMechanicsApplication.PerturbGeometrySubgridUtility(mp, eigen_solver, perturbation_settings)
+        # Generate perturbation matrix
+        self.number_random_variables = self.utility.CreateRandomFieldVectors()
+
+
+    def PerturbGeometry(self, mp ):
+        """Apply perturbation matrix to geometry.
+        Random field approach requires normal distributed random numbers (mean=0, sigma=1)
+        """
+        random_numbers = [random.gauss(0, 1) for i in range(self.number_random_variables)]
+        self.utility.ApplyRandomFieldVectorsToGeometry(mp, random_numbers)
```

## KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_adjoint_static_solver.py

 * *Ordering differences only*

```diff
@@ -1,165 +1,165 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-
-from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
-
-def CreateSolver(model, custom_settings):
-    return StructuralMechanicsAdjointStaticSolver(model, custom_settings)
-
-class StructuralMechanicsAdjointStaticSolver(MechanicalSolver):
-
-    def __init__(self, model, custom_settings):
-        # Construct the base solver.
-        super().__init__(model, custom_settings)
-        KratosMultiphysics.Logger.PrintInfo("::[AdjointMechanicalSolver]:: ", "Construction finished")
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KratosMultiphysics.Parameters("""{
-            "response_function_settings" : {},
-            "sensitivity_settings" : {}
-        }""")
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
-
-    def AddVariables(self):
-        super().AddVariables()
-        self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.ADJOINT_DISPLACEMENT)
-        if self.settings["rotation_dofs"].GetBool():
-            self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.ADJOINT_ROTATION)
-        # TODO evaluate if these variables should be historical
-        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.SHAPE_SENSITIVITY)
-        KratosMultiphysics.Logger.PrintInfo("::[AdjointMechanicalSolver]:: ", "Variables ADDED")
-
-    def PrepareModelPart(self):
-        if(self.main_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE]!= 3):
-            raise Exception("there are currently only 3D adjoint elements available")
-        super().PrepareModelPart()
-        # TODO Why does replacement need to happen after reading materials?
-
-        process_info = self.main_model_part.ProcessInfo
-        if (process_info.Has(StructuralMechanicsApplication.IS_ADJOINT) and
-            process_info.GetValue(StructuralMechanicsApplication.IS_ADJOINT)):
-            raise RuntimeError("Modelpart '{}' is already adjoint modelpart!".format(self.main_model_part.Name))
-
-        # defines how the primal elements should be replaced with their adjoint counterparts
-        replacement_settings = KratosMultiphysics.Parameters("""
-            {
-                "element_name_table" :
-                {
-                    "ShellThinElement3D3N"           : "AdjointFiniteDifferencingShellThinElement3D3N",
-                    "CrLinearBeamElement3D2N"        : "AdjointFiniteDifferenceCrBeamElementLinear3D2N",
-                    "TrussLinearElement3D2N"         : "AdjointFiniteDifferenceTrussLinearElement3D2N",
-                    "TrussElement3D2N"               : "AdjointFiniteDifferenceTrussElement3D2N",
-                    "TotalLagrangianElement2D3N"     : "TotalLagrangianAdjointElement2D3N",
-                    "TotalLagrangianElement2D4N"     : "TotalLagrangianAdjointElement2D4N",
-                    "TotalLagrangianElement2D6N"     : "TotalLagrangianAdjointElement2D6N",
-                    "TotalLagrangianElement3D4N"     : "TotalLagrangianAdjointElement3D4N",
-                    "TotalLagrangianElement3D8N"     : "TotalLagrangianAdjointElement3D8N",
-                    "SmallDisplacementElement3D4N"   : "AdjointFiniteDifferencingSmallDisplacementElement3D4N",
-                    "SmallDisplacementElement3D6N"   : "AdjointFiniteDifferencingSmallDisplacementElement3D6N",
-                    "SmallDisplacementElement3D8N"   : "AdjointFiniteDifferencingSmallDisplacementElement3D8N",
-                    "SpringDamperElement3D"          : "AdjointFiniteDifferenceSpringDamperElement3D2N",
-                    "SpringDamperElement3D2N"        : "AdjointFiniteDifferenceSpringDamperElement3D2N" 
-                },
-                "condition_name_table" :
-                {
-                    "PointLoadCondition2D1N"         : "AdjointSemiAnalyticPointLoadCondition2D1N",
-                    "PointLoadCondition3D1N"         : "AdjointSemiAnalyticPointLoadCondition3D1N",
-                    "SurfaceLoadCondition3D3N"       : "AdjointSemiAnalyticSurfaceLoadCondition3D3N",
-                    "SurfaceLoadCondition3D4N"       : "AdjointSemiAnalyticSurfaceLoadCondition3D4N",
-                    "SmallDisplacementSurfaceLoadCondition3D3N" : "AdjointSemiAnalyticSmallDisplacementSurfaceLoadCondition3D3N",
-                    "SmallDisplacementSurfaceLoadCondition3D4N" : "AdjointSemiAnalyticSmallDisplacementSurfaceLoadCondition3D4N",
-                    "LineLoadCondition3D2N"                     : "AdjointSemiAnalyticLineLoadCondition3D2N",
-                    "SmallDisplacementLineLoadCondition3D2N"    : "AdjointSemiAnalyticSmallDisplacementLineLoadCondition3D2N"
-                },
-                "ignore_conditions" : [
-                    "SurfaceCondition3D3N",
-                    "SurfaceCondition3D4N",
-                    "PointCondition3D1N"
-                ]
-            }
-        """) # TODO remove "Condition3D" after issue#4439 is resolved; remove SpringDamperElement3D2N, it is deprecated
-
-        StructuralMechanicsApplication.ReplaceMultipleElementsAndConditionsProcess(self.main_model_part, replacement_settings).Execute()
-        process_info.SetValue(StructuralMechanicsApplication.IS_ADJOINT, True)
-
-        KratosMultiphysics.Logger.PrintInfo("::[AdjointMechanicalSolver]:: ", "ModelPart prepared for Solver.")
-
-    def AddDofs(self):
-        KratosMultiphysics.VariableUtils().AddDof(StructuralMechanicsApplication.ADJOINT_DISPLACEMENT_X, self.main_model_part)
-        KratosMultiphysics.VariableUtils().AddDof(StructuralMechanicsApplication.ADJOINT_DISPLACEMENT_Y, self.main_model_part)
-        KratosMultiphysics.VariableUtils().AddDof(StructuralMechanicsApplication.ADJOINT_DISPLACEMENT_Z, self.main_model_part)
-        if self.settings["rotation_dofs"].GetBool():
-            KratosMultiphysics.VariableUtils().AddDof(StructuralMechanicsApplication.ADJOINT_ROTATION_X, self.main_model_part)
-            KratosMultiphysics.VariableUtils().AddDof(StructuralMechanicsApplication.ADJOINT_ROTATION_Y, self.main_model_part)
-            KratosMultiphysics.VariableUtils().AddDof(StructuralMechanicsApplication.ADJOINT_ROTATION_Z, self.main_model_part)
-        KratosMultiphysics.Logger.PrintInfo("::[AdjointMechanicalSolver]:: ", "DOF's ADDED.")
-
-    def Initialize(self):
-        """Perform initialization after adding nodal variables and dofs to the main model part. """
-        response_type = self.settings["response_function_settings"]["response_type"].GetString()
-        if response_type == "adjoint_local_stress":
-            self.response_function = StructuralMechanicsApplication.AdjointLocalStressResponseFunction(self.main_model_part, self.settings["response_function_settings"])
-        elif response_type == "adjoint_max_stress":
-            self.response_function = StructuralMechanicsApplication.AdjointMaxStressResponseFunction(self.main_model_part, self.settings["response_function_settings"])
-        elif response_type == "adjoint_nodal_displacement":
-            self.response_function = StructuralMechanicsApplication.AdjointNodalDisplacementResponseFunction(self.main_model_part, self.settings["response_function_settings"])
-        elif response_type == "adjoint_linear_strain_energy":
-            self.response_function = StructuralMechanicsApplication.AdjointLinearStrainEnergyResponseFunction(self.main_model_part, self.settings["response_function_settings"])
-        elif response_type == "adjoint_nodal_reaction":
-            self.response_function = StructuralMechanicsApplication.AdjointNodalReactionResponseFunction(self.main_model_part, self.settings["response_function_settings"])
-        else:
-            raise Exception("invalid response_type: " + response_type)
-
-        self.sensitivity_builder = KratosMultiphysics.SensitivityBuilder(self.settings["sensitivity_settings"], self.main_model_part, self.response_function)
-        self.sensitivity_builder.Initialize()
-
-        super().Initialize()
-        self.response_function.Initialize()
-
-        KratosMultiphysics.Logger.PrintInfo("::[AdjointMechanicalSolver]:: ", "Finished initialization.")
-
-    def InitializeSolutionStep(self):
-        super().InitializeSolutionStep()
-        self.response_function.InitializeSolutionStep()
-
-    def FinalizeSolutionStep(self):
-        super().FinalizeSolutionStep()
-        self.response_function.FinalizeSolutionStep()
-        self.sensitivity_builder.UpdateSensitivities()
-
-    def SolveSolutionStep(self):
-        if self.settings["response_function_settings"]["response_type"].GetString() == "adjoint_linear_strain_energy":
-            self._SolveSolutionStepSpecialLinearStrainEnergy()
-            return True
-        else:
-            return super().SolveSolutionStep()
-
-    def _SolveSolutionStepSpecialLinearStrainEnergy(self):
-        for node in self.main_model_part.Nodes:
-            adjoint_displacement = 0.5 * node.GetSolutionStepValue(KratosMultiphysics.DISPLACEMENT)
-            node.SetSolutionStepValue(StructuralMechanicsApplication.ADJOINT_DISPLACEMENT, adjoint_displacement )
-            if self.settings["rotation_dofs"].GetBool():
-                adjoint_rotation = 0.5 * node.GetSolutionStepValue(KratosMultiphysics.ROTATION)
-                node.SetSolutionStepValue(StructuralMechanicsApplication.ADJOINT_ROTATION, adjoint_rotation )
-
-    def _CreateSolutionStrategy(self):
-        analysis_type = self.settings["analysis_type"].GetString()
-        if analysis_type == "linear":
-            if self.settings["compute_reactions"].GetBool():
-                raise Exception("\"compute_reactions\" is not possible for adjoint models parts")
-            if self.settings["move_mesh_flag"].GetBool():
-                raise Exception("\"move_mesh_flag\" is not allowed for adjoint models parts")
-            mechanical_solution_strategy = self._create_linear_strategy()
-        else:
-            err_msg =  "The requested analysis type \"" + analysis_type + "\" is not available for adjoints!\n"
-            err_msg += "Available options are: \"linear\""
-            raise Exception(err_msg)
-        return mechanical_solution_strategy
-
-    def _CreateScheme(self):
-        return KratosMultiphysics.ResidualBasedAdjointStaticScheme(self.response_function)
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+
+from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
+
+def CreateSolver(model, custom_settings):
+    return StructuralMechanicsAdjointStaticSolver(model, custom_settings)
+
+class StructuralMechanicsAdjointStaticSolver(MechanicalSolver):
+
+    def __init__(self, model, custom_settings):
+        # Construct the base solver.
+        super().__init__(model, custom_settings)
+        KratosMultiphysics.Logger.PrintInfo("::[AdjointMechanicalSolver]:: ", "Construction finished")
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KratosMultiphysics.Parameters("""{
+            "response_function_settings" : {},
+            "sensitivity_settings" : {}
+        }""")
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
+
+    def AddVariables(self):
+        super().AddVariables()
+        self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.ADJOINT_DISPLACEMENT)
+        if self.settings["rotation_dofs"].GetBool():
+            self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.ADJOINT_ROTATION)
+        # TODO evaluate if these variables should be historical
+        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.SHAPE_SENSITIVITY)
+        KratosMultiphysics.Logger.PrintInfo("::[AdjointMechanicalSolver]:: ", "Variables ADDED")
+
+    def PrepareModelPart(self):
+        if(self.main_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE]!= 3):
+            raise Exception("there are currently only 3D adjoint elements available")
+        super().PrepareModelPart()
+        # TODO Why does replacement need to happen after reading materials?
+
+        process_info = self.main_model_part.ProcessInfo
+        if (process_info.Has(StructuralMechanicsApplication.IS_ADJOINT) and
+            process_info.GetValue(StructuralMechanicsApplication.IS_ADJOINT)):
+            raise RuntimeError("Modelpart '{}' is already adjoint modelpart!".format(self.main_model_part.Name))
+
+        # defines how the primal elements should be replaced with their adjoint counterparts
+        replacement_settings = KratosMultiphysics.Parameters("""
+            {
+                "element_name_table" :
+                {
+                    "ShellThinElement3D3N"           : "AdjointFiniteDifferencingShellThinElement3D3N",
+                    "CrLinearBeamElement3D2N"        : "AdjointFiniteDifferenceCrBeamElementLinear3D2N",
+                    "TrussLinearElement3D2N"         : "AdjointFiniteDifferenceTrussLinearElement3D2N",
+                    "TrussElement3D2N"               : "AdjointFiniteDifferenceTrussElement3D2N",
+                    "TotalLagrangianElement2D3N"     : "TotalLagrangianAdjointElement2D3N",
+                    "TotalLagrangianElement2D4N"     : "TotalLagrangianAdjointElement2D4N",
+                    "TotalLagrangianElement2D6N"     : "TotalLagrangianAdjointElement2D6N",
+                    "TotalLagrangianElement3D4N"     : "TotalLagrangianAdjointElement3D4N",
+                    "TotalLagrangianElement3D8N"     : "TotalLagrangianAdjointElement3D8N",
+                    "SmallDisplacementElement3D4N"   : "AdjointFiniteDifferencingSmallDisplacementElement3D4N",
+                    "SmallDisplacementElement3D6N"   : "AdjointFiniteDifferencingSmallDisplacementElement3D6N",
+                    "SmallDisplacementElement3D8N"   : "AdjointFiniteDifferencingSmallDisplacementElement3D8N",
+                    "SpringDamperElement3D"          : "AdjointFiniteDifferenceSpringDamperElement3D2N",
+                    "SpringDamperElement3D2N"        : "AdjointFiniteDifferenceSpringDamperElement3D2N" 
+                },
+                "condition_name_table" :
+                {
+                    "PointLoadCondition2D1N"         : "AdjointSemiAnalyticPointLoadCondition2D1N",
+                    "PointLoadCondition3D1N"         : "AdjointSemiAnalyticPointLoadCondition3D1N",
+                    "SurfaceLoadCondition3D3N"       : "AdjointSemiAnalyticSurfaceLoadCondition3D3N",
+                    "SurfaceLoadCondition3D4N"       : "AdjointSemiAnalyticSurfaceLoadCondition3D4N",
+                    "SmallDisplacementSurfaceLoadCondition3D3N" : "AdjointSemiAnalyticSmallDisplacementSurfaceLoadCondition3D3N",
+                    "SmallDisplacementSurfaceLoadCondition3D4N" : "AdjointSemiAnalyticSmallDisplacementSurfaceLoadCondition3D4N",
+                    "LineLoadCondition3D2N"                     : "AdjointSemiAnalyticLineLoadCondition3D2N",
+                    "SmallDisplacementLineLoadCondition3D2N"    : "AdjointSemiAnalyticSmallDisplacementLineLoadCondition3D2N"
+                },
+                "ignore_conditions" : [
+                    "SurfaceCondition3D3N",
+                    "SurfaceCondition3D4N",
+                    "PointCondition3D1N"
+                ]
+            }
+        """) # TODO remove "Condition3D" after issue#4439 is resolved; remove SpringDamperElement3D2N, it is deprecated
+
+        StructuralMechanicsApplication.ReplaceMultipleElementsAndConditionsProcess(self.main_model_part, replacement_settings).Execute()
+        process_info.SetValue(StructuralMechanicsApplication.IS_ADJOINT, True)
+
+        KratosMultiphysics.Logger.PrintInfo("::[AdjointMechanicalSolver]:: ", "ModelPart prepared for Solver.")
+
+    def AddDofs(self):
+        KratosMultiphysics.VariableUtils().AddDof(StructuralMechanicsApplication.ADJOINT_DISPLACEMENT_X, self.main_model_part)
+        KratosMultiphysics.VariableUtils().AddDof(StructuralMechanicsApplication.ADJOINT_DISPLACEMENT_Y, self.main_model_part)
+        KratosMultiphysics.VariableUtils().AddDof(StructuralMechanicsApplication.ADJOINT_DISPLACEMENT_Z, self.main_model_part)
+        if self.settings["rotation_dofs"].GetBool():
+            KratosMultiphysics.VariableUtils().AddDof(StructuralMechanicsApplication.ADJOINT_ROTATION_X, self.main_model_part)
+            KratosMultiphysics.VariableUtils().AddDof(StructuralMechanicsApplication.ADJOINT_ROTATION_Y, self.main_model_part)
+            KratosMultiphysics.VariableUtils().AddDof(StructuralMechanicsApplication.ADJOINT_ROTATION_Z, self.main_model_part)
+        KratosMultiphysics.Logger.PrintInfo("::[AdjointMechanicalSolver]:: ", "DOF's ADDED.")
+
+    def Initialize(self):
+        """Perform initialization after adding nodal variables and dofs to the main model part. """
+        response_type = self.settings["response_function_settings"]["response_type"].GetString()
+        if response_type == "adjoint_local_stress":
+            self.response_function = StructuralMechanicsApplication.AdjointLocalStressResponseFunction(self.main_model_part, self.settings["response_function_settings"])
+        elif response_type == "adjoint_max_stress":
+            self.response_function = StructuralMechanicsApplication.AdjointMaxStressResponseFunction(self.main_model_part, self.settings["response_function_settings"])
+        elif response_type == "adjoint_nodal_displacement":
+            self.response_function = StructuralMechanicsApplication.AdjointNodalDisplacementResponseFunction(self.main_model_part, self.settings["response_function_settings"])
+        elif response_type == "adjoint_linear_strain_energy":
+            self.response_function = StructuralMechanicsApplication.AdjointLinearStrainEnergyResponseFunction(self.main_model_part, self.settings["response_function_settings"])
+        elif response_type == "adjoint_nodal_reaction":
+            self.response_function = StructuralMechanicsApplication.AdjointNodalReactionResponseFunction(self.main_model_part, self.settings["response_function_settings"])
+        else:
+            raise Exception("invalid response_type: " + response_type)
+
+        self.sensitivity_builder = KratosMultiphysics.SensitivityBuilder(self.settings["sensitivity_settings"], self.main_model_part, self.response_function)
+        self.sensitivity_builder.Initialize()
+
+        super().Initialize()
+        self.response_function.Initialize()
+
+        KratosMultiphysics.Logger.PrintInfo("::[AdjointMechanicalSolver]:: ", "Finished initialization.")
+
+    def InitializeSolutionStep(self):
+        super().InitializeSolutionStep()
+        self.response_function.InitializeSolutionStep()
+
+    def FinalizeSolutionStep(self):
+        super().FinalizeSolutionStep()
+        self.response_function.FinalizeSolutionStep()
+        self.sensitivity_builder.UpdateSensitivities()
+
+    def SolveSolutionStep(self):
+        if self.settings["response_function_settings"]["response_type"].GetString() == "adjoint_linear_strain_energy":
+            self._SolveSolutionStepSpecialLinearStrainEnergy()
+            return True
+        else:
+            return super().SolveSolutionStep()
+
+    def _SolveSolutionStepSpecialLinearStrainEnergy(self):
+        for node in self.main_model_part.Nodes:
+            adjoint_displacement = 0.5 * node.GetSolutionStepValue(KratosMultiphysics.DISPLACEMENT)
+            node.SetSolutionStepValue(StructuralMechanicsApplication.ADJOINT_DISPLACEMENT, adjoint_displacement )
+            if self.settings["rotation_dofs"].GetBool():
+                adjoint_rotation = 0.5 * node.GetSolutionStepValue(KratosMultiphysics.ROTATION)
+                node.SetSolutionStepValue(StructuralMechanicsApplication.ADJOINT_ROTATION, adjoint_rotation )
+
+    def _CreateSolutionStrategy(self):
+        analysis_type = self.settings["analysis_type"].GetString()
+        if analysis_type == "linear":
+            if self.settings["compute_reactions"].GetBool():
+                raise Exception("\"compute_reactions\" is not possible for adjoint models parts")
+            if self.settings["move_mesh_flag"].GetBool():
+                raise Exception("\"move_mesh_flag\" is not allowed for adjoint models parts")
+            mechanical_solution_strategy = self._create_linear_strategy()
+        else:
+            err_msg =  "The requested analysis type \"" + analysis_type + "\" is not available for adjoints!\n"
+            err_msg += "Available options are: \"linear\""
+            raise Exception(err_msg)
+        return mechanical_solution_strategy
+
+    def _CreateScheme(self):
+        return KratosMultiphysics.ResidualBasedAdjointStaticScheme(self.response_function)
```

## KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_solver.py

 * *Ordering differences only*

```diff
@@ -1,131 +1,131 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Importing MPI extensions to Kratos
-from KratosMultiphysics.mpi.distributed_import_model_part_utility import DistributedImportModelPartUtility
-
-# Import applications
-import KratosMultiphysics.TrilinosApplication as TrilinosApplication
-from KratosMultiphysics.TrilinosApplication import trilinos_linear_solver_factory
-
-# Import base class file
-from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
-
-# Other imports
-from KratosMultiphysics.StructuralMechanicsApplication import trilinos_convergence_criteria_factory as convergence_criteria_factory
-
-def CreateSolver(model, custom_settings):
-    return TrilinosMechanicalSolver(model, custom_settings)
-
-class TrilinosMechanicalSolver(MechanicalSolver):
-    """The base class for trilinos structural mechanics solver.
-
-    See structural_mechanics_solver.py for more information.
-    """
-    def __init__(self, model, custom_settings):
-        # Construct the base solver.
-        super().__init__(model, custom_settings)
-        KratosMultiphysics.Logger.PrintInfo("::[TrilinosMechanicalSolver]:: ", "Construction finished")
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KratosMultiphysics.Parameters("""{
-            "multi_point_constraints_used": false,
-            "linear_solver_settings" : {
-                "solver_type" : "amesos",
-                "amesos_solver_type" : "Amesos_Klu"
-            }
-        }""")
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
-
-    def AddVariables(self):
-        super().AddVariables()
-        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.PARTITION_INDEX)
-        KratosMultiphysics.Logger.PrintInfo("::[TrilinosMechanicalSolver]:: ", "Variables ADDED")
-
-    def ImportModelPart(self):
-        KratosMultiphysics.Logger.PrintInfo("::[TrilinosMechanicalSolver]:: ", "Importing model part.")
-        self.distributed_model_part_importer = DistributedImportModelPartUtility(self.main_model_part, self.settings)
-        self.distributed_model_part_importer.ImportModelPart()
-        KratosMultiphysics.Logger.PrintInfo("::[TrilinosMechanicalSolver]:: ", "Finished importing model part.")
-
-    def PrepareModelPart(self):
-        super().PrepareModelPart()
-        # Construct the mpi-communicator
-        self.distributed_model_part_importer.CreateCommunicators()
-        KratosMultiphysics.Logger.PrintInfo("::[TrilinosMechanicalSolver]::", "ModelPart prepared for Solver.")
-
-    def Finalize(self):
-        super().Finalize()
-        self._GetSolutionStrategy().Clear() # needed for proper finalization of MPI
-
-    #### Specific internal functions ####
-
-    def _GetEpetraCommunicator(self):
-        if not hasattr(self, '_epetra_communicator'):
-            self._epetra_communicator = self._create_epetra_communicator()
-        return self._epetra_communicator
-
-    #### Private functions ####
-
-    def _create_epetra_communicator(self):
-        return TrilinosApplication.CreateEpetraCommunicator(self.main_model_part.GetCommunicator().GetDataCommunicator())
-
-    def _CreateConvergenceCriterion(self):
-        convergence_criterion = convergence_criteria_factory.convergence_criterion(self._get_convergence_criterion_settings())
-        return convergence_criterion.mechanical_convergence_criterion
-
-    def _CreateLinearSolver(self):
-        return trilinos_linear_solver_factory.ConstructSolver(self.settings["linear_solver_settings"])
-
-    def _CreateBuilderAndSolver(self):
-        if self.settings["multi_point_constraints_used"].GetBool():
-            raise Exception("MPCs not yet implemented in MPI")
-
-        if (self.GetComputingModelPart().NumberOfMasterSlaveConstraints() > 0):
-            KratosMultiphysics.Logger.PrintWarning("Constraints are not yet implemented in MPI and will therefore not be considered!")
-
-        linear_solver = self._GetLinearSolver()
-        epetra_communicator = self._GetEpetraCommunicator()
-        if(self.main_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE] == 2):
-            guess_row_size = 15
-        else:
-            guess_row_size = 45
-        if self.settings["builder_and_solver_settings"]["use_block_builder"].GetBool():
-            builder_and_solver = TrilinosApplication.TrilinosBlockBuilderAndSolver(epetra_communicator,
-                                                                                   guess_row_size,
-                                                                                   linear_solver)
-        else:
-            builder_and_solver = TrilinosApplication.TrilinosEliminationBuilderAndSolver(epetra_communicator,
-                                                                                         guess_row_size,
-                                                                                         linear_solver)
-        return builder_and_solver
-
-    def _create_linear_strategy(self):
-        computing_model_part = self.GetComputingModelPart()
-        mechanical_scheme = self._GetScheme()
-        linear_solver = self._GetLinearSolver()
-        builder_and_solver = self._GetBuilderAndSolver()
-        return TrilinosApplication.TrilinosLinearStrategy(computing_model_part,
-                                                          mechanical_scheme,
-                                                          builder_and_solver,
-                                                          self.settings["compute_reactions"].GetBool(),
-                                                          self.settings["reform_dofs_at_each_step"].GetBool(),
-                                                          False,
-                                                          self.settings["move_mesh_flag"].GetBool())
-
-    def _create_newton_raphson_strategy(self):
-        computing_model_part = self.GetComputingModelPart()
-        solution_scheme = self._GetScheme()
-        linear_solver = self._GetLinearSolver()
-        convergence_criterion = self._GetConvergenceCriterion()
-        builder_and_solver = self._GetBuilderAndSolver()
-        return TrilinosApplication.TrilinosNewtonRaphsonStrategy(computing_model_part,
-                                                                 solution_scheme,
-                                                                 convergence_criterion,
-                                                                 builder_and_solver,
-                                                                 self.settings["max_iteration"].GetInt(),
-                                                                 self.settings["compute_reactions"].GetBool(),
-                                                                 self.settings["reform_dofs_at_each_step"].GetBool(),
-                                                                 self.settings["move_mesh_flag"].GetBool())
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Importing MPI extensions to Kratos
+from KratosMultiphysics.mpi.distributed_import_model_part_utility import DistributedImportModelPartUtility
+
+# Import applications
+import KratosMultiphysics.TrilinosApplication as TrilinosApplication
+from KratosMultiphysics.TrilinosApplication import trilinos_linear_solver_factory
+
+# Import base class file
+from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
+
+# Other imports
+from KratosMultiphysics.StructuralMechanicsApplication import trilinos_convergence_criteria_factory as convergence_criteria_factory
+
+def CreateSolver(model, custom_settings):
+    return TrilinosMechanicalSolver(model, custom_settings)
+
+class TrilinosMechanicalSolver(MechanicalSolver):
+    """The base class for trilinos structural mechanics solver.
+
+    See structural_mechanics_solver.py for more information.
+    """
+    def __init__(self, model, custom_settings):
+        # Construct the base solver.
+        super().__init__(model, custom_settings)
+        KratosMultiphysics.Logger.PrintInfo("::[TrilinosMechanicalSolver]:: ", "Construction finished")
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KratosMultiphysics.Parameters("""{
+            "multi_point_constraints_used": false,
+            "linear_solver_settings" : {
+                "solver_type" : "amesos",
+                "amesos_solver_type" : "Amesos_Klu"
+            }
+        }""")
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
+
+    def AddVariables(self):
+        super().AddVariables()
+        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.PARTITION_INDEX)
+        KratosMultiphysics.Logger.PrintInfo("::[TrilinosMechanicalSolver]:: ", "Variables ADDED")
+
+    def ImportModelPart(self):
+        KratosMultiphysics.Logger.PrintInfo("::[TrilinosMechanicalSolver]:: ", "Importing model part.")
+        self.distributed_model_part_importer = DistributedImportModelPartUtility(self.main_model_part, self.settings)
+        self.distributed_model_part_importer.ImportModelPart()
+        KratosMultiphysics.Logger.PrintInfo("::[TrilinosMechanicalSolver]:: ", "Finished importing model part.")
+
+    def PrepareModelPart(self):
+        super().PrepareModelPart()
+        # Construct the mpi-communicator
+        self.distributed_model_part_importer.CreateCommunicators()
+        KratosMultiphysics.Logger.PrintInfo("::[TrilinosMechanicalSolver]::", "ModelPart prepared for Solver.")
+
+    def Finalize(self):
+        super().Finalize()
+        self._GetSolutionStrategy().Clear() # needed for proper finalization of MPI
+
+    #### Specific internal functions ####
+
+    def _GetEpetraCommunicator(self):
+        if not hasattr(self, '_epetra_communicator'):
+            self._epetra_communicator = self._create_epetra_communicator()
+        return self._epetra_communicator
+
+    #### Private functions ####
+
+    def _create_epetra_communicator(self):
+        return TrilinosApplication.CreateEpetraCommunicator(self.main_model_part.GetCommunicator().GetDataCommunicator())
+
+    def _CreateConvergenceCriterion(self):
+        convergence_criterion = convergence_criteria_factory.convergence_criterion(self._get_convergence_criterion_settings())
+        return convergence_criterion.mechanical_convergence_criterion
+
+    def _CreateLinearSolver(self):
+        return trilinos_linear_solver_factory.ConstructSolver(self.settings["linear_solver_settings"])
+
+    def _CreateBuilderAndSolver(self):
+        if self.settings["multi_point_constraints_used"].GetBool():
+            raise Exception("MPCs not yet implemented in MPI")
+
+        if (self.GetComputingModelPart().NumberOfMasterSlaveConstraints() > 0):
+            KratosMultiphysics.Logger.PrintWarning("Constraints are not yet implemented in MPI and will therefore not be considered!")
+
+        linear_solver = self._GetLinearSolver()
+        epetra_communicator = self._GetEpetraCommunicator()
+        if(self.main_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE] == 2):
+            guess_row_size = 15
+        else:
+            guess_row_size = 45
+        if self.settings["builder_and_solver_settings"]["use_block_builder"].GetBool():
+            builder_and_solver = TrilinosApplication.TrilinosBlockBuilderAndSolver(epetra_communicator,
+                                                                                   guess_row_size,
+                                                                                   linear_solver)
+        else:
+            builder_and_solver = TrilinosApplication.TrilinosEliminationBuilderAndSolver(epetra_communicator,
+                                                                                         guess_row_size,
+                                                                                         linear_solver)
+        return builder_and_solver
+
+    def _create_linear_strategy(self):
+        computing_model_part = self.GetComputingModelPart()
+        mechanical_scheme = self._GetScheme()
+        linear_solver = self._GetLinearSolver()
+        builder_and_solver = self._GetBuilderAndSolver()
+        return TrilinosApplication.TrilinosLinearStrategy(computing_model_part,
+                                                          mechanical_scheme,
+                                                          builder_and_solver,
+                                                          self.settings["compute_reactions"].GetBool(),
+                                                          self.settings["reform_dofs_at_each_step"].GetBool(),
+                                                          False,
+                                                          self.settings["move_mesh_flag"].GetBool())
+
+    def _create_newton_raphson_strategy(self):
+        computing_model_part = self.GetComputingModelPart()
+        solution_scheme = self._GetScheme()
+        linear_solver = self._GetLinearSolver()
+        convergence_criterion = self._GetConvergenceCriterion()
+        builder_and_solver = self._GetBuilderAndSolver()
+        return TrilinosApplication.TrilinosNewtonRaphsonStrategy(computing_model_part,
+                                                                 solution_scheme,
+                                                                 convergence_criterion,
+                                                                 builder_and_solver,
+                                                                 self.settings["max_iteration"].GetInt(),
+                                                                 self.settings["compute_reactions"].GetBool(),
+                                                                 self.settings["reform_dofs_at_each_step"].GetBool(),
+                                                                 self.settings["move_mesh_flag"].GetBool())
```

## KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_implicit_dynamic_solver.py

 * *Ordering differences only*

```diff
@@ -1,69 +1,69 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-
-import KratosMultiphysics.kratos_utilities as kratos_utilities
-if kratos_utilities.CheckIfApplicationsAvailable("MeshingApplication"):
-    import KratosMultiphysics.MeshingApplication as MeshingApplication
-    missing_meshing_dependencies = True
-else:
-    missing_meshing_dependencies = False
-
-# Import base class file
-from KratosMultiphysics.StructuralMechanicsApplication import structural_mechanics_implicit_dynamic_solver
-
-# Import auxiliary methods
-from KratosMultiphysics.StructuralMechanicsApplication import auxiliary_methods_adaptative_solvers
-from KratosMultiphysics.StructuralMechanicsApplication import adaptative_remeshing_structural_mechanics_utilities
-
-def CreateSolver(model, custom_settings):
-    return AdaptativeRemeshingImplicitMechanicalSolver(model, custom_settings)
-
-class AdaptativeRemeshingImplicitMechanicalSolver(structural_mechanics_implicit_dynamic_solver.ImplicitMechanicalSolver):
-    """The structural mechanics implicit dynamic solver. (Fot adaptative remeshing)
-    See structural_mechanics_implicit_dynamic_solver.py for more information.
-    """
-    def __init__(self, model, custom_settings):
-        # Set defaults and validate custom settings.
-        self.adaptative_remeshing_utilities = adaptative_remeshing_structural_mechanics_utilities.AdaptativeRemeshingMechanicalUtilities()
-
-        # Construct the base solver.
-        super().__init__(model, custom_settings)
-        KratosMultiphysics.Logger.PrintInfo("::[AdaptativeRemeshingImplicitMechanicalSolver]:: ", "Construction finished")
-
-    #### Private functions ####
-
-    def AddVariables(self):
-        super().AddVariables()
-        if not missing_meshing_dependencies:
-            self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.NODAL_H)
-        KratosMultiphysics.Logger.PrintInfo("::[AdaptativeRemeshingImplicitMechanicalSolver]:: ", "Variables ADDED")
-
-    def get_remeshing_process(self):
-        if not hasattr(self, '_remeshing_process'):
-            self._remeshing_process = self._create_remeshing_process()
-        return self._remeshing_process
-
-    def _create_remeshing_process(self):
-        return auxiliary_methods_adaptative_solvers.CreateRemeshingProcess(self.main_model_part, self.settings)
-
-    def get_metric_process(self):
-        if not hasattr(self, '_metric_process'):
-            self._metric_process = self._create_metric_process()
-        return self._metric_process
-
-    def _create_metric_process(self):
-        return auxiliary_methods_adaptative_solvers.CreateMetricProcess(self.main_model_part, self.settings)
-
-    def _CreateConvergenceCriterion(self):
-        error_criteria = self.settings["convergence_criterion"].GetString()
-        conv_settings = self._get_convergence_criterion_settings()
-        return self.adaptative_remeshing_utilities.GetConvergenceCriteria(error_criteria, conv_settings)
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = adaptative_remeshing_structural_mechanics_utilities.AdaptativeRemeshingMechanicalUtilities().GetDefaultParameters()
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+
+import KratosMultiphysics.kratos_utilities as kratos_utilities
+if kratos_utilities.CheckIfApplicationsAvailable("MeshingApplication"):
+    import KratosMultiphysics.MeshingApplication as MeshingApplication
+    missing_meshing_dependencies = True
+else:
+    missing_meshing_dependencies = False
+
+# Import base class file
+from KratosMultiphysics.StructuralMechanicsApplication import structural_mechanics_implicit_dynamic_solver
+
+# Import auxiliary methods
+from KratosMultiphysics.StructuralMechanicsApplication import auxiliary_methods_adaptative_solvers
+from KratosMultiphysics.StructuralMechanicsApplication import adaptative_remeshing_structural_mechanics_utilities
+
+def CreateSolver(model, custom_settings):
+    return AdaptativeRemeshingImplicitMechanicalSolver(model, custom_settings)
+
+class AdaptativeRemeshingImplicitMechanicalSolver(structural_mechanics_implicit_dynamic_solver.ImplicitMechanicalSolver):
+    """The structural mechanics implicit dynamic solver. (Fot adaptative remeshing)
+    See structural_mechanics_implicit_dynamic_solver.py for more information.
+    """
+    def __init__(self, model, custom_settings):
+        # Set defaults and validate custom settings.
+        self.adaptative_remeshing_utilities = adaptative_remeshing_structural_mechanics_utilities.AdaptativeRemeshingMechanicalUtilities()
+
+        # Construct the base solver.
+        super().__init__(model, custom_settings)
+        KratosMultiphysics.Logger.PrintInfo("::[AdaptativeRemeshingImplicitMechanicalSolver]:: ", "Construction finished")
+
+    #### Private functions ####
+
+    def AddVariables(self):
+        super().AddVariables()
+        if not missing_meshing_dependencies:
+            self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.NODAL_H)
+        KratosMultiphysics.Logger.PrintInfo("::[AdaptativeRemeshingImplicitMechanicalSolver]:: ", "Variables ADDED")
+
+    def get_remeshing_process(self):
+        if not hasattr(self, '_remeshing_process'):
+            self._remeshing_process = self._create_remeshing_process()
+        return self._remeshing_process
+
+    def _create_remeshing_process(self):
+        return auxiliary_methods_adaptative_solvers.CreateRemeshingProcess(self.main_model_part, self.settings)
+
+    def get_metric_process(self):
+        if not hasattr(self, '_metric_process'):
+            self._metric_process = self._create_metric_process()
+        return self._metric_process
+
+    def _create_metric_process(self):
+        return auxiliary_methods_adaptative_solvers.CreateMetricProcess(self.main_model_part, self.settings)
+
+    def _CreateConvergenceCriterion(self):
+        error_criteria = self.settings["convergence_criterion"].GetString()
+        conv_settings = self._get_convergence_criterion_settings()
+        return self.adaptative_remeshing_utilities.GetConvergenceCriteria(error_criteria, conv_settings)
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = adaptative_remeshing_structural_mechanics_utilities.AdaptativeRemeshingMechanicalUtilities().GetDefaultParameters()
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
```

## KratosMultiphysics/StructuralMechanicsApplication/auxiliary_methods_solvers.py

 * *Ordering differences only*

```diff
@@ -1,18 +1,18 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-
-def GetBDFIntegrationOrder(scheme_type):
-    if scheme_type == "backward_euler":
-        order = 1
-    else:
-        if scheme_type == "bdf":
-            raise Exception('Wrong input for scheme type: "bdf"! Please append the order to the bdf-scheme, e.g. "bdf2"')
-        # BDF schemes can be from 1 to 5 order, so in order to detect the integration order from the scheme_type we remove the "bdf" string, that is, if the user tells bdf3 only 3 will remain when we remove bdf which corresponds to the method of choice
-        order = int(scheme_type.replace("bdf", ""))
-
-    # Warning
-    if (order > 2):
-        KM.Logger.PrintWarning("BDF", "Order {}; constant time step must be considered".format(order))
-
-    return order
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+
+def GetBDFIntegrationOrder(scheme_type):
+    if scheme_type == "backward_euler":
+        order = 1
+    else:
+        if scheme_type == "bdf":
+            raise Exception('Wrong input for scheme type: "bdf"! Please append the order to the bdf-scheme, e.g. "bdf2"')
+        # BDF schemes can be from 1 to 5 order, so in order to detect the integration order from the scheme_type we remove the "bdf" string, that is, if the user tells bdf3 only 3 will remain when we remove bdf which corresponds to the method of choice
+        order = int(scheme_type.replace("bdf", ""))
+
+    # Warning
+    if (order > 2):
+        KM.Logger.PrintWarning("BDF", "Order {}; constant time step must be considered".format(order))
+
+    return order
```

## KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_formfinding_solver.py

 * *Ordering differences only*

```diff
@@ -1,81 +1,81 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-
-# Import base class file
-from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
-
-def CreateSolver(main_model_part, custom_settings):
-    return FormfindingMechanicalSolver(main_model_part, custom_settings)
-
-class FormfindingMechanicalSolver(MechanicalSolver):
-    """The structural mechanics formfinding solver.
-
-    This class creates the mechanical solver for formfinding.
-
-    See structural_mechanics_solver.py for more information.
-    """
-    def __init__(self, main_model_part, custom_settings):
-        # Construct the base solver.
-        super().__init__(main_model_part, custom_settings)
-        custom_settings["projection_settings"].ValidateAndAssignDefaults(self.GetDefaultParameters()["projection_settings"])
-
-        KratosMultiphysics.Logger.PrintInfo("::[FormfindingMechanicalSolver]:: ", "Construction finished")
-
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KratosMultiphysics.Parameters("""{
-            "printing_format"             : "all",
-            "write_formfound_geometry_file"    : true,
-            "formfinding_model_part_name" : "",
-            "projection_settings": {
-                "model_part_name"  : "Structure",
-                "echo_level"       : 0,
-                "projection_type"  : "planar",
-                "global_direction" : [1,0,0],
-                "variable_name"    : "PLEASE_SPECIFY",
-                "visualize_in_vtk" : false,
-                "method_specific_settings" : { },
-                "check_local_space_dimension" : false
-            }
-        }""")
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
-
-
-
-    def Finalize(self):
-        super().Finalize()
-        if (self.settings["write_formfound_geometry_file"].GetBool()):
-            StructuralMechanicsApplication.FormfindingStrategy.WriteFormFoundMdpa(self.GetComputingModelPart())
-
-    def _CreateScheme(self):
-        return KratosMultiphysics.ResidualBasedIncrementalUpdateStaticScheme()
-
-    def _CreateSolutionStrategy(self):
-        computing_model_part = self.GetComputingModelPart()
-        mechanical_scheme = self._GetScheme()
-        mechanical_convergence_criterion = self._GetConvergenceCriterion()
-        builder_and_solver = self._GetBuilderAndSolver()
-
-
-        # in some cases not all elements need to be reset by the formfinding strategy
-        formfinding_model_part = self.GetComputingModelPart()
-        if len(self.settings["formfinding_model_part_name"].GetString())>0:
-            formfinding_model_part = computing_model_part.GetSubModelPart(self.settings["formfinding_model_part_name"].GetString())
-        return StructuralMechanicsApplication.FormfindingStrategy(
-                                                                computing_model_part,
-                                                                mechanical_scheme,
-                                                                mechanical_convergence_criterion,
-                                                                builder_and_solver,
-                                                                formfinding_model_part,
-                                                                self.settings["write_formfound_geometry_file"].GetBool(),
-                                                                self.settings["printing_format"].GetString(),
-                                                                self.settings["projection_settings"],
-                                                                self.settings["max_iteration"].GetInt(),
-                                                                self.settings["compute_reactions"].GetBool(),
-                                                                self.settings["reform_dofs_at_each_step"].GetBool(),
-                                                                self.settings["move_mesh_flag"].GetBool())
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+
+# Import base class file
+from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
+
+def CreateSolver(main_model_part, custom_settings):
+    return FormfindingMechanicalSolver(main_model_part, custom_settings)
+
+class FormfindingMechanicalSolver(MechanicalSolver):
+    """The structural mechanics formfinding solver.
+
+    This class creates the mechanical solver for formfinding.
+
+    See structural_mechanics_solver.py for more information.
+    """
+    def __init__(self, main_model_part, custom_settings):
+        # Construct the base solver.
+        super().__init__(main_model_part, custom_settings)
+        custom_settings["projection_settings"].ValidateAndAssignDefaults(self.GetDefaultParameters()["projection_settings"])
+
+        KratosMultiphysics.Logger.PrintInfo("::[FormfindingMechanicalSolver]:: ", "Construction finished")
+
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KratosMultiphysics.Parameters("""{
+            "printing_format"             : "all",
+            "write_formfound_geometry_file"    : true,
+            "formfinding_model_part_name" : "",
+            "projection_settings": {
+                "model_part_name"  : "Structure",
+                "echo_level"       : 0,
+                "projection_type"  : "planar",
+                "global_direction" : [1,0,0],
+                "variable_name"    : "PLEASE_SPECIFY",
+                "visualize_in_vtk" : false,
+                "method_specific_settings" : { },
+                "check_local_space_dimension" : false
+            }
+        }""")
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
+
+
+
+    def Finalize(self):
+        super().Finalize()
+        if (self.settings["write_formfound_geometry_file"].GetBool()):
+            StructuralMechanicsApplication.FormfindingStrategy.WriteFormFoundMdpa(self.GetComputingModelPart())
+
+    def _CreateScheme(self):
+        return KratosMultiphysics.ResidualBasedIncrementalUpdateStaticScheme()
+
+    def _CreateSolutionStrategy(self):
+        computing_model_part = self.GetComputingModelPart()
+        mechanical_scheme = self._GetScheme()
+        mechanical_convergence_criterion = self._GetConvergenceCriterion()
+        builder_and_solver = self._GetBuilderAndSolver()
+
+
+        # in some cases not all elements need to be reset by the formfinding strategy
+        formfinding_model_part = self.GetComputingModelPart()
+        if len(self.settings["formfinding_model_part_name"].GetString())>0:
+            formfinding_model_part = computing_model_part.GetSubModelPart(self.settings["formfinding_model_part_name"].GetString())
+        return StructuralMechanicsApplication.FormfindingStrategy(
+                                                                computing_model_part,
+                                                                mechanical_scheme,
+                                                                mechanical_convergence_criterion,
+                                                                builder_and_solver,
+                                                                formfinding_model_part,
+                                                                self.settings["write_formfound_geometry_file"].GetBool(),
+                                                                self.settings["printing_format"].GetString(),
+                                                                self.settings["projection_settings"],
+                                                                self.settings["max_iteration"].GetInt(),
+                                                                self.settings["compute_reactions"].GetBool(),
+                                                                self.settings["reform_dofs_at_each_step"].GetBool(),
+                                                                self.settings["move_mesh_flag"].GetBool())
```

## KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_eigensolver.py

 * *Ordering differences only*

```diff
@@ -1,104 +1,104 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-
-# Import base class file
-from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
-
-from KratosMultiphysics import eigen_solver_factory
-from KratosMultiphysics.kratos_utilities import IssueDeprecationWarning
-
-def CreateSolver(main_model_part, custom_settings):
-    return EigenSolver(main_model_part, custom_settings)
-
-class EigenSolver(MechanicalSolver):
-    """The structural mechanics eigen solver.
-
-    This class creates the mechanical solvers for eigenvalue analysis.
-
-    See structural_mechanics_solver.py for more information.
-    """
-    def __init__(self, main_model_part, custom_settings):
-        if custom_settings.Has("linear_solver_settings"):
-            IssueDeprecationWarning('EigenSolver', '"linear_solver_settings" was specified which is not used in the EigenSolver. Use "eigensolver_settings"!')
-            custom_settings.RemoveValue("linear_solver_settings")
-
-        # Construct the base solver.
-        super().__init__(main_model_part, custom_settings)
-        KratosMultiphysics.Logger.PrintInfo("::[EigenSolver]:: ", "Construction finished")
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KratosMultiphysics.Parameters("""{
-            "scheme_type"         : "dynamic",
-            "compute_modal_decomposition": false,
-            "eigensolver_settings" : {
-                "solver_type"           : "spectra_sym_g_eigs_shift",
-                "max_iteration"         : 1000,
-                "number_of_eigenvalues" : 5,
-                "echo_level"            : 1
-            },
-            "eigensolver_diagonal_values" : { }
-        }""")
-        base_parameters = super().GetDefaultParameters()
-        base_parameters.RemoveValue("linear_solver_settings")
-        this_defaults.AddMissingParameters(base_parameters)
-        return this_defaults
-
-    #### Private functions ####
-
-    def _CreateScheme(self):
-        """Create the scheme for the eigenvalue problem.
-
-        The scheme determines the left- and right-hand side matrices in the
-        generalized eigenvalue problem.
-        """
-        scheme_type = self.settings["scheme_type"].GetString()
-        if scheme_type == "dynamic":
-            solution_scheme = StructuralMechanicsApplication.EigensolverDynamicScheme()
-        else: # here e.g. a stability scheme could be added
-            err_msg =  "The requested scheme type \"" + scheme_type + "\" is not available!\n"
-            err_msg += "Available options are: \"dynamic\""
-            raise Exception(err_msg)
-
-        return solution_scheme
-
-    def _CreateLinearSolver(self):
-        """Create the eigensolver.
-
-        This overrides the base class method and replaces the usual linear solver
-        with an eigenvalue problem solver.
-        """
-        return eigen_solver_factory.ConstructSolver(self.settings["eigensolver_settings"])
-
-    def _CreateSolutionStrategy(self):
-        eigen_scheme = self._GetScheme() # The scheme defines the matrices of the eigenvalue problem.
-        builder_and_solver = self._GetBuilderAndSolver() # The eigensolver is created here.
-        computing_model_part = self.GetComputingModelPart()
-
-        solver_type = self.settings["eigensolver_settings"]["solver_type"].GetString()
-        if solver_type in ["eigen_eigensystem", "spectra_sym_g_eigs_shift"]: # TODO evaluate what has to be used for spectra
-            mass_matrix_diagonal_value = 0.0
-            stiffness_matrix_diagonal_value = 1.0
-        elif solver_type == "feast":
-            mass_matrix_diagonal_value = 1.0
-            stiffness_matrix_diagonal_value = -1.0
-        else:
-            diag_values = self.settings["eigensolver_diagonal_values"]
-            if not diag_values.Has("mass_matrix_diagonal_value") or not diag_values.Has("stiffness_matrix_diagonal_value"):
-                err_msg  = 'For the used eigensolver "{}" no defaults for '.format(solver_type)
-                err_msg += '"mass_matrix_diagonal_value" and "stiffness_matrix_diagonal_value" exist, '
-                err_msg += 'please specify them under "eigensolver_diagonal_values"'
-                raise Exception(err_msg)
-
-            mass_matrix_diagonal_value = diag_values["mass_matrix_diagonal_value"].GetDouble()
-            stiffness_matrix_diagonal_value = diag_values["stiffness_matrix_diagonal_value"].GetDouble()
-
-        return StructuralMechanicsApplication.EigensolverStrategy(computing_model_part,
-                                                                  eigen_scheme,
-                                                                  builder_and_solver,
-                                                                  mass_matrix_diagonal_value,
-                                                                  stiffness_matrix_diagonal_value,
-                                                                  self.settings["compute_modal_decomposition"].GetBool())
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+
+# Import base class file
+from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
+
+from KratosMultiphysics import eigen_solver_factory
+from KratosMultiphysics.kratos_utilities import IssueDeprecationWarning
+
+def CreateSolver(main_model_part, custom_settings):
+    return EigenSolver(main_model_part, custom_settings)
+
+class EigenSolver(MechanicalSolver):
+    """The structural mechanics eigen solver.
+
+    This class creates the mechanical solvers for eigenvalue analysis.
+
+    See structural_mechanics_solver.py for more information.
+    """
+    def __init__(self, main_model_part, custom_settings):
+        if custom_settings.Has("linear_solver_settings"):
+            IssueDeprecationWarning('EigenSolver', '"linear_solver_settings" was specified which is not used in the EigenSolver. Use "eigensolver_settings"!')
+            custom_settings.RemoveValue("linear_solver_settings")
+
+        # Construct the base solver.
+        super().__init__(main_model_part, custom_settings)
+        KratosMultiphysics.Logger.PrintInfo("::[EigenSolver]:: ", "Construction finished")
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KratosMultiphysics.Parameters("""{
+            "scheme_type"         : "dynamic",
+            "compute_modal_decomposition": false,
+            "eigensolver_settings" : {
+                "solver_type"           : "spectra_sym_g_eigs_shift",
+                "max_iteration"         : 1000,
+                "number_of_eigenvalues" : 5,
+                "echo_level"            : 1
+            },
+            "eigensolver_diagonal_values" : { }
+        }""")
+        base_parameters = super().GetDefaultParameters()
+        base_parameters.RemoveValue("linear_solver_settings")
+        this_defaults.AddMissingParameters(base_parameters)
+        return this_defaults
+
+    #### Private functions ####
+
+    def _CreateScheme(self):
+        """Create the scheme for the eigenvalue problem.
+
+        The scheme determines the left- and right-hand side matrices in the
+        generalized eigenvalue problem.
+        """
+        scheme_type = self.settings["scheme_type"].GetString()
+        if scheme_type == "dynamic":
+            solution_scheme = StructuralMechanicsApplication.EigensolverDynamicScheme()
+        else: # here e.g. a stability scheme could be added
+            err_msg =  "The requested scheme type \"" + scheme_type + "\" is not available!\n"
+            err_msg += "Available options are: \"dynamic\""
+            raise Exception(err_msg)
+
+        return solution_scheme
+
+    def _CreateLinearSolver(self):
+        """Create the eigensolver.
+
+        This overrides the base class method and replaces the usual linear solver
+        with an eigenvalue problem solver.
+        """
+        return eigen_solver_factory.ConstructSolver(self.settings["eigensolver_settings"])
+
+    def _CreateSolutionStrategy(self):
+        eigen_scheme = self._GetScheme() # The scheme defines the matrices of the eigenvalue problem.
+        builder_and_solver = self._GetBuilderAndSolver() # The eigensolver is created here.
+        computing_model_part = self.GetComputingModelPart()
+
+        solver_type = self.settings["eigensolver_settings"]["solver_type"].GetString()
+        if solver_type in ["eigen_eigensystem", "spectra_sym_g_eigs_shift"]: # TODO evaluate what has to be used for spectra
+            mass_matrix_diagonal_value = 0.0
+            stiffness_matrix_diagonal_value = 1.0
+        elif solver_type == "feast":
+            mass_matrix_diagonal_value = 1.0
+            stiffness_matrix_diagonal_value = -1.0
+        else:
+            diag_values = self.settings["eigensolver_diagonal_values"]
+            if not diag_values.Has("mass_matrix_diagonal_value") or not diag_values.Has("stiffness_matrix_diagonal_value"):
+                err_msg  = 'For the used eigensolver "{}" no defaults for '.format(solver_type)
+                err_msg += '"mass_matrix_diagonal_value" and "stiffness_matrix_diagonal_value" exist, '
+                err_msg += 'please specify them under "eigensolver_diagonal_values"'
+                raise Exception(err_msg)
+
+            mass_matrix_diagonal_value = diag_values["mass_matrix_diagonal_value"].GetDouble()
+            stiffness_matrix_diagonal_value = diag_values["stiffness_matrix_diagonal_value"].GetDouble()
+
+        return StructuralMechanicsApplication.EigensolverStrategy(computing_model_part,
+                                                                  eigen_scheme,
+                                                                  builder_and_solver,
+                                                                  mass_matrix_diagonal_value,
+                                                                  stiffness_matrix_diagonal_value,
+                                                                  self.settings["compute_modal_decomposition"].GetBool())
```

## KratosMultiphysics/StructuralMechanicsApplication/structural_response_function_factory.py

 * *Ordering differences only*

```diff
@@ -1,33 +1,33 @@
-# importing the Kratos Library
-from KratosMultiphysics.StructuralMechanicsApplication import structural_response
-
-def CreateResponseFunction(response_id, response_settings, model):
-    response_type = response_settings["response_type"].GetString()
-
-    if response_type == "strain_energy":
-        return structural_response.StrainEnergyResponseFunction(response_id, response_settings, model)
-
-    elif response_type == "mass":
-        return structural_response.MassResponseFunction(response_id, response_settings, model)
-
-    elif response_type == "eigenfrequency":
-        return structural_response.EigenFrequencyResponseFunction(response_id, response_settings, model)
-
-    elif response_type == "adjoint_nodal_displacement":
-        return structural_response.AdjointResponseFunction(response_id, response_settings, model)
-
-    elif response_type == "adjoint_linear_strain_energy":
-        return structural_response.AdjointResponseFunction(response_id, response_settings, model)
-
-    elif response_type == "adjoint_local_stress":
-        return structural_response.AdjointResponseFunction(response_id, response_settings, model)
-
-    elif response_type == "adjoint_max_stress":
-        return structural_response.AdjointResponseFunction(response_id, response_settings, model)
-
-    elif response_type == "adjoint_nodal_reaction":
-        return structural_response.AdjointResponseFunction(response_id, response_settings, model)
-
-    else:
-        raise NameError("The type of the following response function is not specified: "+ response_id +
-                        ".\nAvailable types are: 'mass', 'strain_energy', 'eigenfrequency', 'adjoint_nodal_displacement', 'adjoint_linear_strain_energy', 'adjoint_local_stress', 'adjoint_max_stress', 'adjoint_nodal_reaction'." )
+# importing the Kratos Library
+from KratosMultiphysics.StructuralMechanicsApplication import structural_response
+
+def CreateResponseFunction(response_id, response_settings, model):
+    response_type = response_settings["response_type"].GetString()
+
+    if response_type == "strain_energy":
+        return structural_response.StrainEnergyResponseFunction(response_id, response_settings, model)
+
+    elif response_type == "mass":
+        return structural_response.MassResponseFunction(response_id, response_settings, model)
+
+    elif response_type == "eigenfrequency":
+        return structural_response.EigenFrequencyResponseFunction(response_id, response_settings, model)
+
+    elif response_type == "adjoint_nodal_displacement":
+        return structural_response.AdjointResponseFunction(response_id, response_settings, model)
+
+    elif response_type == "adjoint_linear_strain_energy":
+        return structural_response.AdjointResponseFunction(response_id, response_settings, model)
+
+    elif response_type == "adjoint_local_stress":
+        return structural_response.AdjointResponseFunction(response_id, response_settings, model)
+
+    elif response_type == "adjoint_max_stress":
+        return structural_response.AdjointResponseFunction(response_id, response_settings, model)
+
+    elif response_type == "adjoint_nodal_reaction":
+        return structural_response.AdjointResponseFunction(response_id, response_settings, model)
+
+    else:
+        raise NameError("The type of the following response function is not specified: "+ response_id +
+                        ".\nAvailable types are: 'mass', 'strain_energy', 'eigenfrequency', 'adjoint_nodal_displacement', 'adjoint_linear_strain_energy', 'adjoint_local_stress', 'adjoint_max_stress', 'adjoint_nodal_reaction'." )
```

## KratosMultiphysics/StructuralMechanicsApplication/kratos_main_structural.py

 * *Ordering differences only*

```diff
@@ -1,16 +1,16 @@
-import KratosMultiphysics
-from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_analysis import StructuralMechanicsAnalysis
-
-"""
-For user-scripting it is intended that a new class is derived
-from StructuralMechanicsAnalysis to do modifications
-"""
-
-if __name__ == "__main__":
-
-    with open("ProjectParameters.json",'r') as parameter_file:
-        parameters = KratosMultiphysics.Parameters(parameter_file.read())
-
-    model = KratosMultiphysics.Model()
-    simulation = StructuralMechanicsAnalysis(model,parameters)
-    simulation.Run()
+import KratosMultiphysics
+from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_analysis import StructuralMechanicsAnalysis
+
+"""
+For user-scripting it is intended that a new class is derived
+from StructuralMechanicsAnalysis to do modifications
+"""
+
+if __name__ == "__main__":
+
+    with open("ProjectParameters.json",'r') as parameter_file:
+        parameters = KratosMultiphysics.Parameters(parameter_file.read())
+
+    model = KratosMultiphysics.Model()
+    simulation = StructuralMechanicsAnalysis(model,parameters)
+    simulation.Run()
```

## KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_utilities.py

 * *Ordering differences only*

```diff
@@ -1,94 +1,94 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-from KratosMultiphysics.StructuralMechanicsApplication import convergence_criteria_factory
-
-try:
-    import KratosMultiphysics.MeshingApplication as MeshingApplication
-    missing_meshing_dependencies = False
-    missing_application = ''
-except ImportError as e:
-    missing_meshing_dependencies = True
-    # extract name of the missing application from the error message
-    import re
-    missing_application = re.search(r'''.*'KratosMultiphysics\.(.*)'.*''','{0}'.format(e)).group(1)
-
-class AdaptativeRemeshingMechanicalUtilities(object):
-    """These are common utilities for adaptative remeshing
-    """
-
-    def __init__(self):
-        self.adaptative_remesh_parameters = KratosMultiphysics.Parameters("""
-        {
-            "compute_error_settings" : {
-                "error_mesh_tolerance" : 5.0e-3,
-                "error_mesh_constant"  : 5.0e-3,
-                "compute_error_extra_parameters":
-                {
-                    "stress_vector_variable"              : "CAUCHY_STRESS_VECTOR",
-                    "echo_level"                          : 0
-                }
-            },
-            "metric_error_parameters" :
-            {
-                "minimal_size"                        : 0.01,
-                "maximal_size"                        : 1.0,
-                "error_strategy_parameters":
-                {
-                    "target_error"                        : 0.01,
-                    "set_target_number_of_elements"       : false,
-                    "target_number_of_elements"           : 1000,
-                    "perform_nodal_h_averaging"           : false
-                },
-                "echo_level"                          : 0
-            },
-            "remeshing_parameters":
-            {
-                "filename"                             : "out",
-                "framework"                            : "Lagrangian",
-                "internal_variables_parameters"        :
-                {
-                    "allocation_size"                      : 1000,
-                    "bucket_size"                          : 4,
-                    "search_factor"                        : 2,
-                    "interpolation_type"                   : "LST",
-                    "internal_variable_interpolation_list" :[]
-                },
-                "save_external_files"              : false,
-                "max_number_of_searchs"            : 1000,
-                "echo_level"                       : 0
-            }
-        }
-        """)
-
-    def GetDefaultParameters(self):
-        return self.adaptative_remesh_parameters
-
-    def SetDefaultParameters(self, settings):
-        self.adaptative_remesh_parameters = settings
-
-    def GetConvergenceCriteria(self, error_criteria, conv_settings):
-        if ("_with_adaptative_remesh" in error_criteria):
-            conv_settings["convergence_criterion"].SetString(error_criteria.replace("_with_adaptative_remesh", ""))
-        # If we just use the adaptative convergence criteria
-        if (missing_meshing_dependencies is True):
-            if ("adaptative_remesh" in error_criteria):
-                raise NameError('The AdaptativeErrorCriteria can not be used without compiling the MeshingApplication')
-        else:
-            if (error_criteria == "adaptative_remesh_criteria"):
-                adaptative_error_criteria = StructuralMechanicsApplication.ErrorMeshCriteria(self.adaptative_remesh_parameters["compute_error_settings"])
-                adaptative_error_criteria.SetEchoLevel(conv_settings["echo_level"].GetInt())
-                return adaptative_error_criteria
-
-        # Regular convergence criteria
-        convergence_criterion = convergence_criteria_factory.convergence_criterion(conv_settings)
-
-        # If we combine the regular convergence criteria with adaptative
-        if (missing_meshing_dependencies is False):
-            if ("_with_adaptative_remesh" in error_criteria):
-                adaptative_error_criteria = StructuralMechanicsApplication.ErrorMeshCriteria(self.adaptative_remesh_parameters["compute_error_settings"])
-                adaptative_error_criteria.SetEchoLevel(conv_settings["echo_level"].GetInt())
-                convergence_criterion.mechanical_convergence_criterion = KratosMultiphysics.AndCriteria(convergence_criterion.mechanical_convergence_criterion, adaptative_error_criteria)
-        return convergence_criterion.mechanical_convergence_criterion
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+from KratosMultiphysics.StructuralMechanicsApplication import convergence_criteria_factory
+
+try:
+    import KratosMultiphysics.MeshingApplication as MeshingApplication
+    missing_meshing_dependencies = False
+    missing_application = ''
+except ImportError as e:
+    missing_meshing_dependencies = True
+    # extract name of the missing application from the error message
+    import re
+    missing_application = re.search(r'''.*'KratosMultiphysics\.(.*)'.*''','{0}'.format(e)).group(1)
+
+class AdaptativeRemeshingMechanicalUtilities(object):
+    """These are common utilities for adaptative remeshing
+    """
+
+    def __init__(self):
+        self.adaptative_remesh_parameters = KratosMultiphysics.Parameters("""
+        {
+            "compute_error_settings" : {
+                "error_mesh_tolerance" : 5.0e-3,
+                "error_mesh_constant"  : 5.0e-3,
+                "compute_error_extra_parameters":
+                {
+                    "stress_vector_variable"              : "CAUCHY_STRESS_VECTOR",
+                    "echo_level"                          : 0
+                }
+            },
+            "metric_error_parameters" :
+            {
+                "minimal_size"                        : 0.01,
+                "maximal_size"                        : 1.0,
+                "error_strategy_parameters":
+                {
+                    "target_error"                        : 0.01,
+                    "set_target_number_of_elements"       : false,
+                    "target_number_of_elements"           : 1000,
+                    "perform_nodal_h_averaging"           : false
+                },
+                "echo_level"                          : 0
+            },
+            "remeshing_parameters":
+            {
+                "filename"                             : "out",
+                "framework"                            : "Lagrangian",
+                "internal_variables_parameters"        :
+                {
+                    "allocation_size"                      : 1000,
+                    "bucket_size"                          : 4,
+                    "search_factor"                        : 2,
+                    "interpolation_type"                   : "LST",
+                    "internal_variable_interpolation_list" :[]
+                },
+                "save_external_files"              : false,
+                "max_number_of_searchs"            : 1000,
+                "echo_level"                       : 0
+            }
+        }
+        """)
+
+    def GetDefaultParameters(self):
+        return self.adaptative_remesh_parameters
+
+    def SetDefaultParameters(self, settings):
+        self.adaptative_remesh_parameters = settings
+
+    def GetConvergenceCriteria(self, error_criteria, conv_settings):
+        if ("_with_adaptative_remesh" in error_criteria):
+            conv_settings["convergence_criterion"].SetString(error_criteria.replace("_with_adaptative_remesh", ""))
+        # If we just use the adaptative convergence criteria
+        if (missing_meshing_dependencies is True):
+            if ("adaptative_remesh" in error_criteria):
+                raise NameError('The AdaptativeErrorCriteria can not be used without compiling the MeshingApplication')
+        else:
+            if (error_criteria == "adaptative_remesh_criteria"):
+                adaptative_error_criteria = StructuralMechanicsApplication.ErrorMeshCriteria(self.adaptative_remesh_parameters["compute_error_settings"])
+                adaptative_error_criteria.SetEchoLevel(conv_settings["echo_level"].GetInt())
+                return adaptative_error_criteria
+
+        # Regular convergence criteria
+        convergence_criterion = convergence_criteria_factory.convergence_criterion(conv_settings)
+
+        # If we combine the regular convergence criteria with adaptative
+        if (missing_meshing_dependencies is False):
+            if ("_with_adaptative_remesh" in error_criteria):
+                adaptative_error_criteria = StructuralMechanicsApplication.ErrorMeshCriteria(self.adaptative_remesh_parameters["compute_error_settings"])
+                adaptative_error_criteria.SetEchoLevel(conv_settings["echo_level"].GetInt())
+                convergence_criterion.mechanical_convergence_criterion = KratosMultiphysics.AndCriteria(convergence_criterion.mechanical_convergence_criterion, adaptative_error_criteria)
+        return convergence_criterion.mechanical_convergence_criterion
```

## KratosMultiphysics/StructuralMechanicsApplication/impose_rigid_movement_process.py

 * *Ordering differences only*

```diff
@@ -1,112 +1,112 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-
-def Factory(settings, Model):
-    if not isinstance(settings, KratosMultiphysics.Parameters):
-        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
-    return ImposeRigidMovementProcess(Model, settings["Parameters"])
-
-## All the processes python should be derived from "Process"
-class ImposeRigidMovementProcess(KratosMultiphysics.Process):
-    """This class is used in order to impose a rigid body movement in a certain region of the problem
-
-    This class constructs the model parts containing the constrains that enforce the rigid body movement
-    Only the member variables listed below should be accessed directly.
-
-    Public member variables:
-    Model -- the container of the different model parts.
-    settings -- Kratos parameters containing solver settings.
-    """
-
-    def __init__(self, Model, settings ):
-        """ The default constructor of the class
-
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        Model -- the container of the different model parts.
-        settings -- Kratos parameters containing solver settings.
-        """
-        KratosMultiphysics.Process.__init__(self)
-
-        default_settings = KratosMultiphysics.Parameters("""
-        {
-            "help"                        : "This process uses LinearMasterSlaveConstraint in order to impose an unified movement in the given submodelpart. The process takes the first node from the submodelpart if no node's ID is provided. The default variable is DISPLACEMENT, and in case no variable is considered for the slave the same variable will be considered",
-            "main_model_part_name"        : "Structure",
-            "model_part_name"             : "please_specify_model_part_name",
-            "new_model_part_name"         : "",
-            "interval"                    : [0.0, 1e30],
-            "master_variable_name"        : "DISPLACEMENT",
-            "slave_variable_name"         : "",
-            "relation"                    : 1.0,
-            "constant"                    : 0.0,
-            "master_node_id"              : 0
-        }
-        """)
-
-        # Detect "End" as a tag and replace it by a large number
-        if settings.Has("interval"):
-            if settings["interval"][1].IsString():
-                if settings["interval"][1].GetString() == "End":
-                    settings["interval"][1].SetDouble(1e30) # = default_settings["interval"][1]
-                else:
-                    raise Exception("The second value of interval can be \"End\" or a number, interval currently:"+settings["interval"].PrettyPrintJsonString())
-
-        settings.ValidateAndAssignDefaults(default_settings)
-
-        # The main model part
-        self.main_model_part = Model[settings["main_model_part_name"].GetString()]
-
-        # Assign this here since it will change the "interval" prior to validation
-        self.interval = KratosMultiphysics.IntervalUtility(settings)
-
-        # We get the corresponding model parts
-        self.model_part = self.main_model_part.GetSubModelPart(settings["model_part_name"].GetString())
-        new_model_part_name = settings["new_model_part_name"].GetString()
-        if new_model_part_name != "":
-            if self.model_part.HasSubModelPart(new_model_part_name):
-                self.rigid_model_part = self.model_part.GetSubModelPart(new_model_part_name)
-            else:
-                self.rigid_model_part = self.model_part.CreateSubModelPart(new_model_part_name)
-        else:
-            settings["new_model_part_name"].SetString(settings["model_part_name"].GetString())
-            self.rigid_model_part = self.model_part
-
-        # Create the process
-        rigid_parameters = KratosMultiphysics.Parameters("""{}""")
-        rigid_parameters.AddValue("model_part_name", settings["model_part_name"])
-        rigid_parameters.AddValue("new_model_part_name", settings["new_model_part_name"])
-        rigid_parameters.AddValue("master_variable_name", settings["master_variable_name"])
-        rigid_parameters.AddValue("slave_variable_name", settings["slave_variable_name"])
-        rigid_parameters.AddValue("relation", settings["relation"])
-        rigid_parameters.AddValue("constant", settings["constant"])
-        rigid_parameters.AddValue("master_node_id", settings["master_node_id"])
-        self.rigid_movement_process = StructuralMechanicsApplication.ImposeRigidMovementProcess(self.main_model_part, rigid_parameters)
-
-        # Trasfering the entities
-        if new_model_part_name != "":
-            transfer_process = KratosMultiphysics.FastTransferBetweenModelPartsProcess(self.rigid_model_part, self.model_part, KratosMultiphysics.FastTransferBetweenModelPartsProcess.EntityTransfered.NODES)
-            transfer_process.Execute()
-
-    def ExecuteInitialize(self):
-        """ This method is executed at the begining to initialize the process
-
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        """
-        self.rigid_movement_process.ExecuteInitialize()
-
-    def ExecuteInitializeSolutionStep(self):
-        """ This method is executed in order to initialize the current step
-
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        """
-
-        current_time = self.model_part.ProcessInfo[KratosMultiphysics.TIME]
-
-        # We activate/deactivate conditions dependeding of interval
-        if self.interval.IsInInterval(current_time):
-            KratosMultiphysics.VariableUtils().SetFlag(KratosMultiphysics.ACTIVE, True, self.rigid_model_part.MasterSlaveConstraints)
-        else:
-            KratosMultiphysics.VariableUtils().SetFlag(KratosMultiphysics.ACTIVE, False, self.rigid_model_part.MasterSlaveConstraints)
+# Importing the Kratos Library
+import KratosMultiphysics
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+
+def Factory(settings, Model):
+    if not isinstance(settings, KratosMultiphysics.Parameters):
+        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
+    return ImposeRigidMovementProcess(Model, settings["Parameters"])
+
+## All the processes python should be derived from "Process"
+class ImposeRigidMovementProcess(KratosMultiphysics.Process):
+    """This class is used in order to impose a rigid body movement in a certain region of the problem
+
+    This class constructs the model parts containing the constrains that enforce the rigid body movement
+    Only the member variables listed below should be accessed directly.
+
+    Public member variables:
+    Model -- the container of the different model parts.
+    settings -- Kratos parameters containing solver settings.
+    """
+
+    def __init__(self, Model, settings ):
+        """ The default constructor of the class
+
+        Keyword arguments:
+        self -- It signifies an instance of a class.
+        Model -- the container of the different model parts.
+        settings -- Kratos parameters containing solver settings.
+        """
+        KratosMultiphysics.Process.__init__(self)
+
+        default_settings = KratosMultiphysics.Parameters("""
+        {
+            "help"                        : "This process uses LinearMasterSlaveConstraint in order to impose an unified movement in the given submodelpart. The process takes the first node from the submodelpart if no node's ID is provided. The default variable is DISPLACEMENT, and in case no variable is considered for the slave the same variable will be considered",
+            "main_model_part_name"        : "Structure",
+            "model_part_name"             : "please_specify_model_part_name",
+            "new_model_part_name"         : "",
+            "interval"                    : [0.0, 1e30],
+            "master_variable_name"        : "DISPLACEMENT",
+            "slave_variable_name"         : "",
+            "relation"                    : 1.0,
+            "constant"                    : 0.0,
+            "master_node_id"              : 0
+        }
+        """)
+
+        # Detect "End" as a tag and replace it by a large number
+        if settings.Has("interval"):
+            if settings["interval"][1].IsString():
+                if settings["interval"][1].GetString() == "End":
+                    settings["interval"][1].SetDouble(1e30) # = default_settings["interval"][1]
+                else:
+                    raise Exception("The second value of interval can be \"End\" or a number, interval currently:"+settings["interval"].PrettyPrintJsonString())
+
+        settings.ValidateAndAssignDefaults(default_settings)
+
+        # The main model part
+        self.main_model_part = Model[settings["main_model_part_name"].GetString()]
+
+        # Assign this here since it will change the "interval" prior to validation
+        self.interval = KratosMultiphysics.IntervalUtility(settings)
+
+        # We get the corresponding model parts
+        self.model_part = self.main_model_part.GetSubModelPart(settings["model_part_name"].GetString())
+        new_model_part_name = settings["new_model_part_name"].GetString()
+        if new_model_part_name != "":
+            if self.model_part.HasSubModelPart(new_model_part_name):
+                self.rigid_model_part = self.model_part.GetSubModelPart(new_model_part_name)
+            else:
+                self.rigid_model_part = self.model_part.CreateSubModelPart(new_model_part_name)
+        else:
+            settings["new_model_part_name"].SetString(settings["model_part_name"].GetString())
+            self.rigid_model_part = self.model_part
+
+        # Create the process
+        rigid_parameters = KratosMultiphysics.Parameters("""{}""")
+        rigid_parameters.AddValue("model_part_name", settings["model_part_name"])
+        rigid_parameters.AddValue("new_model_part_name", settings["new_model_part_name"])
+        rigid_parameters.AddValue("master_variable_name", settings["master_variable_name"])
+        rigid_parameters.AddValue("slave_variable_name", settings["slave_variable_name"])
+        rigid_parameters.AddValue("relation", settings["relation"])
+        rigid_parameters.AddValue("constant", settings["constant"])
+        rigid_parameters.AddValue("master_node_id", settings["master_node_id"])
+        self.rigid_movement_process = StructuralMechanicsApplication.ImposeRigidMovementProcess(self.main_model_part, rigid_parameters)
+
+        # Trasfering the entities
+        if new_model_part_name != "":
+            transfer_process = KratosMultiphysics.FastTransferBetweenModelPartsProcess(self.rigid_model_part, self.model_part, KratosMultiphysics.FastTransferBetweenModelPartsProcess.EntityTransfered.NODES)
+            transfer_process.Execute()
+
+    def ExecuteInitialize(self):
+        """ This method is executed at the begining to initialize the process
+
+        Keyword arguments:
+        self -- It signifies an instance of a class.
+        """
+        self.rigid_movement_process.ExecuteInitialize()
+
+    def ExecuteInitializeSolutionStep(self):
+        """ This method is executed in order to initialize the current step
+
+        Keyword arguments:
+        self -- It signifies an instance of a class.
+        """
+
+        current_time = self.model_part.ProcessInfo[KratosMultiphysics.TIME]
+
+        # We activate/deactivate conditions dependeding of interval
+        if self.interval.IsInInterval(current_time):
+            KratosMultiphysics.VariableUtils().SetFlag(KratosMultiphysics.ACTIVE, True, self.rigid_model_part.MasterSlaveConstraints)
+        else:
+            KratosMultiphysics.VariableUtils().SetFlag(KratosMultiphysics.ACTIVE, False, self.rigid_model_part.MasterSlaveConstraints)
```

## KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_implicit_dynamic_solver.py

 * *Ordering differences only*

```diff
@@ -1,89 +1,89 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-import KratosMultiphysics.TrilinosApplication as TrilinosApplication
-
-# Import base class file
-from KratosMultiphysics.StructuralMechanicsApplication.trilinos_structural_mechanics_solver import TrilinosMechanicalSolver
-
-from KratosMultiphysics.StructuralMechanicsApplication import auxiliary_methods_solvers
-
-def CreateSolver(model, custom_settings):
-    return TrilinosImplicitMechanicalSolver(model, custom_settings)
-
-class TrilinosImplicitMechanicalSolver(TrilinosMechanicalSolver):
-    """The trilinos structural mechanics implicit dynamic solver.
-
-    For more information see:
-    structural_mechanics_solver.py
-    trilinos_structural_mechanics_solver.py
-    """
-    def __init__(self, model, custom_settings):
-        # Construct the base solver.
-        super().__init__(model, custom_settings)
-        KratosMultiphysics.Logger.PrintInfo("::[TrilinosImplicitMechanicalSolver]:: ", "Construction finished")
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KratosMultiphysics.Parameters("""{
-            "time_integration_method" : "implicit",
-            "scheme_type"             : "bossak",
-            "damp_factor_m"           :-0.3,
-            "rayleigh_alpha"          : 0.0,
-            "rayleigh_beta"           : 0.0
-        }""")
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
-
-    def AddVariables(self):
-        super().AddVariables()
-        self._add_dynamic_variables()
-        KratosMultiphysics.Logger.PrintInfo("::[TrilinosImplicitMechanicalSolver]:: Variables ADDED")
-
-    def AddDofs(self):
-        super().AddDofs()
-        self._add_dynamic_dofs()
-        KratosMultiphysics.Logger.PrintInfo("::[TrilinosImplicitMechanicalSolver]:: DOF's ADDED")
-
-    def GetMinimumBufferSize(self):
-        base_min_buffer_size = super().GetMinimumBufferSize()
-
-        scheme_type = self.settings["scheme_type"].GetString()
-        if "bdf" in scheme_type or scheme_type == "backward_euler":
-            return max(base_min_buffer_size, auxiliary_methods_solvers.GetBDFIntegrationOrder(scheme_type)+1)
-        else:
-            return base_min_buffer_size
-
-    #### Private functions ####
-
-    def _CreateScheme(self):
-        scheme_type = self.settings["scheme_type"].GetString()
-        process_info = self.main_model_part.ProcessInfo
-        process_info[StructuralMechanicsApplication.RAYLEIGH_ALPHA] = self.settings["rayleigh_alpha"].GetDouble()
-        process_info[StructuralMechanicsApplication.RAYLEIGH_BETA] = self.settings["rayleigh_beta"].GetDouble()
-        if scheme_type == "newmark":
-            damp_factor_m = 0.0
-            mechanical_scheme = TrilinosApplication.TrilinosResidualBasedBossakDisplacementScheme(damp_factor_m)
-        elif scheme_type == "bossak":
-            damp_factor_m = self.settings["damp_factor_m"].GetDouble()
-            mechanical_scheme = TrilinosApplication.TrilinosResidualBasedBossakDisplacementScheme(damp_factor_m)
-        elif scheme_type.startswith("bdf") or scheme_type == "backward_euler" :
-            order = auxiliary_methods_solvers.GetBDFIntegrationOrder(scheme_type)
-            # In case of rotation dof we declare the dynamic variables
-            if self.settings["rotation_dofs"].GetBool():
-                bdf_parameters = KratosMultiphysics.Parameters(""" {
-                    "domain_size"           : 3,
-                    "integration_order"     : 2,
-                    "solution_variables"    : ["DISPLACEMENT","ROTATION"]
-                } """)
-                bdf_parameters["domain_size"].SetInt(process_info[KratosMultiphysics.DOMAIN_SIZE])
-                mechanical_scheme = TrilinosApplication.TrilinosResidualBasedBDFCustomScheme(order, bdf_parameters)
-            else:
-                mechanical_scheme = TrilinosApplication.TrilinosResidualBasedBDFDisplacementScheme(order)
-        else:
-            err_msg =  "The requested scheme type \"" + scheme_type + "\" is not available!\n"
-            err_msg += "Available options are: \"newmark\", \"bossak\""
-            raise Exception(err_msg)
-        return mechanical_scheme
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+import KratosMultiphysics.TrilinosApplication as TrilinosApplication
+
+# Import base class file
+from KratosMultiphysics.StructuralMechanicsApplication.trilinos_structural_mechanics_solver import TrilinosMechanicalSolver
+
+from KratosMultiphysics.StructuralMechanicsApplication import auxiliary_methods_solvers
+
+def CreateSolver(model, custom_settings):
+    return TrilinosImplicitMechanicalSolver(model, custom_settings)
+
+class TrilinosImplicitMechanicalSolver(TrilinosMechanicalSolver):
+    """The trilinos structural mechanics implicit dynamic solver.
+
+    For more information see:
+    structural_mechanics_solver.py
+    trilinos_structural_mechanics_solver.py
+    """
+    def __init__(self, model, custom_settings):
+        # Construct the base solver.
+        super().__init__(model, custom_settings)
+        KratosMultiphysics.Logger.PrintInfo("::[TrilinosImplicitMechanicalSolver]:: ", "Construction finished")
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KratosMultiphysics.Parameters("""{
+            "time_integration_method" : "implicit",
+            "scheme_type"             : "bossak",
+            "damp_factor_m"           :-0.3,
+            "rayleigh_alpha"          : 0.0,
+            "rayleigh_beta"           : 0.0
+        }""")
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
+
+    def AddVariables(self):
+        super().AddVariables()
+        self._add_dynamic_variables()
+        KratosMultiphysics.Logger.PrintInfo("::[TrilinosImplicitMechanicalSolver]:: Variables ADDED")
+
+    def AddDofs(self):
+        super().AddDofs()
+        self._add_dynamic_dofs()
+        KratosMultiphysics.Logger.PrintInfo("::[TrilinosImplicitMechanicalSolver]:: DOF's ADDED")
+
+    def GetMinimumBufferSize(self):
+        base_min_buffer_size = super().GetMinimumBufferSize()
+
+        scheme_type = self.settings["scheme_type"].GetString()
+        if "bdf" in scheme_type or scheme_type == "backward_euler":
+            return max(base_min_buffer_size, auxiliary_methods_solvers.GetBDFIntegrationOrder(scheme_type)+1)
+        else:
+            return base_min_buffer_size
+
+    #### Private functions ####
+
+    def _CreateScheme(self):
+        scheme_type = self.settings["scheme_type"].GetString()
+        process_info = self.main_model_part.ProcessInfo
+        process_info[StructuralMechanicsApplication.RAYLEIGH_ALPHA] = self.settings["rayleigh_alpha"].GetDouble()
+        process_info[StructuralMechanicsApplication.RAYLEIGH_BETA] = self.settings["rayleigh_beta"].GetDouble()
+        if scheme_type == "newmark":
+            damp_factor_m = 0.0
+            mechanical_scheme = TrilinosApplication.TrilinosResidualBasedBossakDisplacementScheme(damp_factor_m)
+        elif scheme_type == "bossak":
+            damp_factor_m = self.settings["damp_factor_m"].GetDouble()
+            mechanical_scheme = TrilinosApplication.TrilinosResidualBasedBossakDisplacementScheme(damp_factor_m)
+        elif scheme_type.startswith("bdf") or scheme_type == "backward_euler" :
+            order = auxiliary_methods_solvers.GetBDFIntegrationOrder(scheme_type)
+            # In case of rotation dof we declare the dynamic variables
+            if self.settings["rotation_dofs"].GetBool():
+                bdf_parameters = KratosMultiphysics.Parameters(""" {
+                    "domain_size"           : 3,
+                    "integration_order"     : 2,
+                    "solution_variables"    : ["DISPLACEMENT","ROTATION"]
+                } """)
+                bdf_parameters["domain_size"].SetInt(process_info[KratosMultiphysics.DOMAIN_SIZE])
+                mechanical_scheme = TrilinosApplication.TrilinosResidualBasedBDFCustomScheme(order, bdf_parameters)
+            else:
+                mechanical_scheme = TrilinosApplication.TrilinosResidualBasedBDFDisplacementScheme(order)
+        else:
+            err_msg =  "The requested scheme type \"" + scheme_type + "\" is not available!\n"
+            err_msg += "Available options are: \"newmark\", \"bossak\""
+            raise Exception(err_msg)
+        return mechanical_scheme
```

## KratosMultiphysics/StructuralMechanicsApplication/perturb_geometry_sparse_utility.py

 * *Ordering differences only*

```diff
@@ -1,57 +1,57 @@
-
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-from KratosMultiphysics import eigen_solver_factory
-
-import random
-
-class PerturbGeometrySparseUtility():
-    """An utility to perturb the initial geometry of a structure
-    based on a sparse correlation matrix.
-    """
-    def __init__(self, mp, settings ):
-        """Constructor of Utility-Object
-
-        Checks parameter settings and initializes the utility.
-        """
-        default_settings = KratosMultiphysics.Parameters("""{
-            "eigensolver_settings"  : {
-                "solver_type"               : "eigen_eigensystem",
-                "max_iteration"             : 1000,
-                "tolerance"                 : 1e-4,
-                "number_of_eigenvalues"     : 100,
-		        "normalize_eigenvectors"    : false,
-                "echo_level"                : 0
-                },
-            "perturbation_settings" : {
-                "max_displacement"          : 1,
-                "correlation_length"        : 100,
-                "truncation_error"          : 1e-3,
-                "echo_level"                : 0
-            }
-        }""")
-
-        settings.ValidateAndAssignDefaults(default_settings)
-
-        eigen_solver = eigen_solver_factory.ConstructSolver(settings["eigensolver_settings"])
-        mp.AddNodalSolutionStepVariable(KratosMultiphysics.NORMAL)
-        perturbation_settings = settings["perturbation_settings"]
-        # Initialize utility
-        self.utility = StructuralMechanicsApplication.PerturbGeometrySparseUtility(mp, eigen_solver, perturbation_settings)
-        # Generate perturbation matrix
-        self.number_random_variables = self.utility.CreateRandomFieldVectors()
-
-    def PerturbGeometry(self, mp ):
-        """ Apply perturbation matrix to geometry.
-        Random field approach requires normal distributed random numbers (mean=0, sigma=1)
-        """
-        random_numbers = [random.gauss(0, 1) for i in range(self.number_random_variables)]
-        self.utility.ApplyRandomFieldVectorsToGeometry(mp, random_numbers)
-
-
-
-
-
+
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+from KratosMultiphysics import eigen_solver_factory
+
+import random
+
+class PerturbGeometrySparseUtility():
+    """An utility to perturb the initial geometry of a structure
+    based on a sparse correlation matrix.
+    """
+    def __init__(self, mp, settings ):
+        """Constructor of Utility-Object
+
+        Checks parameter settings and initializes the utility.
+        """
+        default_settings = KratosMultiphysics.Parameters("""{
+            "eigensolver_settings"  : {
+                "solver_type"               : "eigen_eigensystem",
+                "max_iteration"             : 1000,
+                "tolerance"                 : 1e-4,
+                "number_of_eigenvalues"     : 100,
+		        "normalize_eigenvectors"    : false,
+                "echo_level"                : 0
+                },
+            "perturbation_settings" : {
+                "max_displacement"          : 1,
+                "correlation_length"        : 100,
+                "truncation_error"          : 1e-3,
+                "echo_level"                : 0
+            }
+        }""")
+
+        settings.ValidateAndAssignDefaults(default_settings)
+
+        eigen_solver = eigen_solver_factory.ConstructSolver(settings["eigensolver_settings"])
+        mp.AddNodalSolutionStepVariable(KratosMultiphysics.NORMAL)
+        perturbation_settings = settings["perturbation_settings"]
+        # Initialize utility
+        self.utility = StructuralMechanicsApplication.PerturbGeometrySparseUtility(mp, eigen_solver, perturbation_settings)
+        # Generate perturbation matrix
+        self.number_random_variables = self.utility.CreateRandomFieldVectors()
+
+    def PerturbGeometry(self, mp ):
+        """ Apply perturbation matrix to geometry.
+        Random field approach requires normal distributed random numbers (mean=0, sigma=1)
+        """
+        random_numbers = [random.gauss(0, 1) for i in range(self.number_random_variables)]
+        self.utility.ApplyRandomFieldVectorsToGeometry(mp, random_numbers)
+
+
+
+
+
```

## KratosMultiphysics/StructuralMechanicsApplication/structural_response.py

 * *Ordering differences only*

```diff
@@ -1,437 +1,437 @@
-# importing the Kratos Library
-import KratosMultiphysics
-from KratosMultiphysics import Parameters, Logger
-from KratosMultiphysics.response_functions.response_function_interface import ResponseFunctionInterface
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_analysis import StructuralMechanicsAnalysis
-
-import time as timer
-
-def _GetModelPart(model, solver_settings):
-    #TODO can be removed once model is fully available
-    model_part_name = solver_settings["model_part_name"].GetString()
-    if not model.HasModelPart(model_part_name):
-        model_part = model.CreateModelPart(model_part_name, 2)
-        domain_size = solver_settings["domain_size"].GetInt()
-        if domain_size < 0:
-            raise Exception('Please specify a "domain_size" >= 0!')
-        model_part.ProcessInfo.SetValue(KratosMultiphysics.DOMAIN_SIZE, domain_size)
-    else:
-        model_part = model.GetModelPart(model_part_name)
-
-    return model_part
-
-# ==============================================================================
-class StrainEnergyResponseFunction(ResponseFunctionInterface):
-    """Linear strain energy response function. It triggers the primal analysis and
-    uses the primal analysis results to calculate response value and gradient.
-
-    Attributes
-    ----------
-    primal_model_part : Model part of the primal analysis object
-    primal_analysis : Primal analysis object of the response function
-    response_function_utility: Cpp utilities object doing the actual computation of response value and gradient.
-    """
-
-    def __init__(self, identifier, response_settings, model):
-        self.identifier = identifier
-
-        with open(response_settings["primal_settings"].GetString()) as parameters_file:
-            ProjectParametersPrimal = Parameters(parameters_file.read())
-
-        self.primal_model_part = _GetModelPart(model, ProjectParametersPrimal["solver_settings"])
-
-        self.primal_analysis = StructuralMechanicsAnalysis(model, ProjectParametersPrimal)
-        self.primal_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.SHAPE_SENSITIVITY)
-
-        self.response_function_utility = StructuralMechanicsApplication.StrainEnergyResponseFunctionUtility(self.primal_model_part, response_settings)
-
-    def Initialize(self):
-        self.primal_analysis.Initialize()
-        self.response_function_utility.Initialize()
-
-    def InitializeSolutionStep(self):
-        self.primal_analysis.time = self.primal_analysis._GetSolver().AdvanceInTime(self.primal_analysis.time)
-        self.primal_analysis.InitializeSolutionStep()
-
-    def CalculateValue(self):
-        Logger.PrintInfo("StrainEnergyResponse", "Starting primal analysis for response", self.identifier)
-
-        startTime = timer.time()
-        self.primal_analysis._GetSolver().Predict()
-        self.primal_analysis._GetSolver().SolveSolutionStep()
-        Logger.PrintInfo("StrainEnergyResponse", "Time needed for solving the primal analysis",round(timer.time() - startTime,2),"s")
-
-        startTime = timer.time()
-        value = self.response_function_utility.CalculateValue()
-        self.primal_model_part.ProcessInfo[StructuralMechanicsApplication.RESPONSE_VALUE] = value
-        Logger.PrintInfo("StrainEnergyResponse", "Time needed for calculating the response value",round(timer.time() - startTime,2),"s")
-
-    def CalculateGradient(self):
-        Logger.PrintInfo("StrainEnergyResponse", "Starting gradient calculation for response", self.identifier)
-
-        startTime = timer.time()
-        self.response_function_utility.CalculateGradient()
-        Logger.PrintInfo("StrainEnergyResponse", "Time needed for calculating gradients",round(timer.time() - startTime,2),"s")
-
-    def FinalizeSolutionStep(self):
-        self.primal_analysis.FinalizeSolutionStep()
-        self.primal_analysis.OutputSolutionStep()
-
-    def Finalize(self):
-        self.primal_analysis.Finalize()
-
-    def GetValue(self):
-        return self.primal_model_part.ProcessInfo[StructuralMechanicsApplication.RESPONSE_VALUE]
-
-    def GetNodalGradient(self, variable):
-        if variable != KratosMultiphysics.SHAPE_SENSITIVITY:
-            raise RuntimeError("GetNodalGradient: No gradient for {}!".format(variable.Name))
-        gradient = {}
-        for node in self.primal_model_part.Nodes:
-            gradient[node.Id] = node.GetSolutionStepValue(variable)
-        return gradient
-
-    def GetElementalGradient(self, variable):
-        raise NotImplementedError("GetElementalGradient needs to be implemented for StrainEnergyResponseFunction")
-
-# ==============================================================================
-class EigenFrequencyResponseFunction(StrainEnergyResponseFunction):
-    """Eigenfrequency response function. The internal procedure is the same as
-    for the StrainEnergyResponseFunction. It triggers the primal analysis and
-    uses the primal analysis results to calculate response value and gradient.
-    Only the response_function_utility is a different object.
-
-    Attributes
-    ----------
-    primal_model_part : Model part of the primal analysis object
-    primal_analysis : Primal analysis object of the response function
-    response_function_utility: Cpp utilities object doing the actual computation of response value and gradient.
-    """
-
-    def __init__(self, identifier, response_settings, model):
-        self.identifier = identifier
-
-        with open(response_settings["primal_settings"].GetString()) as parameters_file:
-            ProjectParametersPrimal = Parameters(parameters_file.read())
-
-        eigen_solver_settings = ProjectParametersPrimal["solver_settings"]["eigensolver_settings"]
-
-        max_required_eigenfrequency = int(max(response_settings["traced_eigenfrequencies"].GetVector()))
-        if max_required_eigenfrequency is not eigen_solver_settings["number_of_eigenvalues"].GetInt():
-            Logger.PrintWarning("EigenFrequencyResponse", "Specified number of eigenvalues in the primal analysis and the max required eigenvalue according the response settings do not match!!!")
-            Logger.PrintWarning("EigenFrequencyResponse", "Primal parameters were adjusted accordingly!\n")
-            eigen_solver_settings["number_of_eigenvalues"].SetInt(max_required_eigenfrequency)
-
-        if not eigen_solver_settings.Has("normalize_eigenvectors"):
-            eigen_solver_settings.AddEmptyValue("normalize_eigenvectors")
-            eigen_solver_settings["normalize_eigenvectors"].SetBool(True)
-            Logger.PrintWarning("EigenFrequencyResponse", "Eigenfrequency response function requires mass normalization of eigenvectors!")
-            Logger.PrintWarning("EigenFrequencyResponse", "Primal parameters were adjusted accordingly!\n")
-
-        if not eigen_solver_settings["normalize_eigenvectors"].GetBool():
-            eigen_solver_settings["normalize_eigenvectors"].SetBool(True)
-            Logger.PrintWarning("EigenFrequencyResponse", "Eigenfrequency response function requires mass normalization of eigenvectors!")
-            Logger.PrintWarning("EigenFrequencyResponse", "Primal parameters were adjusted accordingly!\n")
-
-        self.primal_model_part = _GetModelPart(model, ProjectParametersPrimal["solver_settings"])
-
-        self.primal_analysis = StructuralMechanicsAnalysis(model, ProjectParametersPrimal)
-        self.primal_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.SHAPE_SENSITIVITY)
-
-
-        self.response_function_utility = StructuralMechanicsApplication.EigenfrequencyResponseFunctionUtility(self.primal_model_part, response_settings)
-
-# ==============================================================================
-class MassResponseFunction(ResponseFunctionInterface):
-    """Mass response function. It reads the materials for the model part and
-    calculates response value and gradient.
-
-    Attributes
-    ----------
-    model_part : Model part object of the response function
-    response_function_utility: Cpp utilities object doing the actual computation of response value and gradient.
-    """
-
-    def __init__(self, identifier, response_settings, model):
-        self.identifier = identifier
-
-        self.response_settings = response_settings
-        self.model = model
-        self.model_part_needs_to_be_imported = False
-
-        model_part_name = response_settings["model_part_name"].GetString()
-        input_type = response_settings["model_import_settings"]["input_type"].GetString()
-        if input_type == "mdpa":
-            self.model_part = self.model.CreateModelPart(model_part_name, 2)
-            domain_size = response_settings["domain_size"].GetInt()
-            if domain_size not in [2, 3]:
-                raise Exception("MassResponseFunction: Invalid 'domain_size': {}".format(domain_size))
-            self.model_part.ProcessInfo.SetValue(KratosMultiphysics.DOMAIN_SIZE, domain_size)
-            self.model_part_needs_to_be_imported = True
-        elif input_type == "use_input_model_part":
-            self.model_part = self.model.GetModelPart(model_part_name)
-        else:
-            raise Exception("Other model part input options are not yet implemented.")
-
-        self.response_function_utility = StructuralMechanicsApplication.MassResponseFunctionUtility(self.model_part, response_settings)
-
-        self.model_part.AddNodalSolutionStepVariable(KratosMultiphysics.SHAPE_SENSITIVITY)
-
-    def Initialize(self):
-        if self.model_part_needs_to_be_imported:
-            # import model part
-            model_part_io = KratosMultiphysics.ModelPartIO(self.response_settings["model_import_settings"]["input_filename"].GetString())
-            model_part_io.ReadModelPart(self.model_part)
-
-        # Add constitutive laws and material properties from json file to model parts.
-        material_settings = KratosMultiphysics.Parameters("""{"Parameters": {} }""")
-        materials_file_name = self.response_settings["material_import_settings"]["materials_filename"]
-        material_settings["Parameters"].AddValue("materials_filename", materials_file_name)
-        KratosMultiphysics.ReadMaterialsUtility(material_settings, self.model)
-        self.response_function_utility.Initialize()
-
-    def CalculateValue(self):
-        Logger.PrintInfo("MassResponse", "Starting primal analysis for response", self.identifier)
-
-        startTime = timer.time()
-        value = self.response_function_utility.CalculateValue()
-        self.model_part.ProcessInfo[StructuralMechanicsApplication.RESPONSE_VALUE] = value
-        Logger.PrintInfo("MassResponse", "Time needed for calculating the response value = ",round(timer.time() - startTime,2),"s")
-
-    def CalculateGradient(self):
-        Logger.PrintInfo("MassResponse", "Starting gradient calculation for response", self.identifier)
-
-        startTime = timer.time()
-        self.response_function_utility.CalculateGradient()
-        Logger.PrintInfo("MassResponse", "Time needed for calculating gradients",round(timer.time() - startTime,2),"s")
-
-    def GetValue(self):
-        return self.model_part.ProcessInfo[StructuralMechanicsApplication.RESPONSE_VALUE]
-
-    def GetNodalGradient(self, variable):
-        if variable != KratosMultiphysics.SHAPE_SENSITIVITY:
-            raise RuntimeError("GetNodalGradient: No gradient for {}!".format(variable.Name))
-        gradient = {}
-        for node in self.model_part.Nodes:
-            gradient[node.Id] = node.GetSolutionStepValue(variable)
-        return gradient
-
-    def GetElementalGradient(self, variable):
-        raise NotImplementedError("GetElementalGradient needs to be implemented for MassResponseFunction")
-
-# ==============================================================================
-class AdjointResponseFunction(ResponseFunctionInterface):
-    """Linear static adjoint strain energy response function.
-    - runs the primal analysis (writes the primal results to an .h5 file)
-    - reads the primal results from the .h5 file into the adjoint model part
-    - uses primal results to calculate value
-    - uses primal results to calculate gradient by running the adjoint analysis
-
-    Attributes
-    ----------
-    primal_analysis : Primal analysis object of the response function
-    adjoint_analysis : Adjoint analysis object of the response function
-    """
-    def __init__(self, identifier, response_settings, model):
-        self.identifier = identifier
-        self.response_settings = response_settings
-
-        # Create the primal solver
-        with open(self.response_settings["primal_settings"].GetString(),'r') as parameter_file:
-            primal_parameters = Parameters( parameter_file.read() )
-
-        self.primal_model_part = _GetModelPart(model, primal_parameters["solver_settings"])
-
-        self.primal_analysis = StructuralMechanicsAnalysis(model, primal_parameters)
-
-        self.primal_data_transfer_with_python = self.response_settings["primal_data_transfer_with_python"].GetBool()
-
-        # Create the adjoint solver
-        adjoint_parameters = self._GetAdjointParameters()
-        adjoint_model = KratosMultiphysics.Model()
-        self.adjoint_model_part = _GetModelPart(adjoint_model, adjoint_parameters["solver_settings"])
-
-        # TODO find out why it is not possible to use the same model_part
-        self.adjoint_analysis = StructuralMechanicsAnalysis(adjoint_model, adjoint_parameters)
-
-        self.primal_state_variables = [KratosMultiphysics.DISPLACEMENT]
-        if primal_parameters["solver_settings"].Has("rotation_dofs"):
-            if primal_parameters["solver_settings"]["rotation_dofs"].GetBool():
-                self.primal_state_variables.append(KratosMultiphysics.ROTATION)
-
-    def Initialize(self):
-        self.primal_analysis.Initialize()
-        self.adjoint_analysis.Initialize()
-
-    def InitializeSolutionStep(self):
-        # Run the primal analysis.
-        # TODO if primal_analysis.status==solved: return
-        Logger.PrintInfo(self._GetLabel(), "Starting primal analysis for response:", self.identifier)
-        startTime = timer.time()
-        if not self.primal_analysis.time < self.primal_analysis.end_time:
-            self.primal_analysis.end_time += 1
-        self.primal_analysis.RunSolutionLoop()
-        Logger.PrintInfo(self._GetLabel(), "Time needed for solving the primal analysis = ",round(timer.time() - startTime,2),"s")
-
-    def CalculateValue(self):
-        startTime = timer.time()
-        value = self._GetResponseFunctionUtility().CalculateValue(self.primal_model_part)
-        Logger.PrintInfo(self._GetLabel(), "Time needed for calculating the response value = ",round(timer.time() - startTime,2),"s")
-
-        self.primal_model_part.ProcessInfo[StructuralMechanicsApplication.RESPONSE_VALUE] = value
-
-    def CalculateGradient(self):
-        # synchronize the modelparts
-        self._SynchronizeAdjointFromPrimal()
-        startTime = timer.time()
-        Logger.PrintInfo(self._GetLabel(), "Starting adjoint analysis for response:", self.identifier)
-        if not self.adjoint_analysis.time < self.adjoint_analysis.end_time:
-            self.adjoint_analysis.end_time += 1
-        self.adjoint_analysis.RunSolutionLoop()
-        Logger.PrintInfo(self._GetLabel(), "Time needed for solving the adjoint analysis = ",round(timer.time() - startTime,2),"s")
-
-    def GetValue(self):
-        return self.primal_model_part.ProcessInfo[StructuralMechanicsApplication.RESPONSE_VALUE]
-
-    def GetNodalGradient(self, variable):
-        if variable != KratosMultiphysics.SHAPE_SENSITIVITY:
-            raise RuntimeError("GetNodalGradient: No gradient for {}!".format(variable.Name))
-        gradient = {}
-        for node in self.adjoint_model_part.Nodes:
-            gradient[node.Id] = node.GetSolutionStepValue(variable)
-        return gradient
-
-    def GetElementalGradient(self, variable):
-        if variable not in [
-                            StructuralMechanicsApplication.YOUNG_MODULUS_SENSITIVITY,
-                            StructuralMechanicsApplication.THICKNESS_SENSITIVITY,
-                            StructuralMechanicsApplication.I22_SENSITIVITY,
-                            StructuralMechanicsApplication.I33_SENSITIVITY,
-                            ]:
-            raise RuntimeError("GetElementalGradient: No gradient for {}!".format(variable.Name))
-        gradient = {}
-        for element in self.adjoint_model_part.Elements:
-            gradient[element.Id] = element.GetValue(variable)
-        return gradient
-
-
-    def Finalize(self):
-        self.primal_analysis.Finalize()
-        self.adjoint_analysis.Finalize()
-
-    def _GetResponseFunctionUtility(self):
-        return self.adjoint_analysis._GetSolver().response_function
-
-    def _SynchronizeAdjointFromPrimal(self):
-        Logger.PrintInfo(self._GetLabel(), "Synchronize primal and adjoint modelpart for response:", self.identifier)
-
-        if len(self.primal_model_part.Nodes) != len(self.adjoint_model_part.Nodes):
-            raise RuntimeError("_SynchronizeAdjointFromPrimal: Model parts have a different number of nodes!")
-
-        # TODO this should happen automatically
-        for primal_node, adjoint_node in zip(self.primal_model_part.Nodes, self.adjoint_model_part.Nodes):
-            adjoint_node.X0 = primal_node.X0
-            adjoint_node.Y0 = primal_node.Y0
-            adjoint_node.Z0 = primal_node.Z0
-            adjoint_node.X = primal_node.X
-            adjoint_node.Y = primal_node.Y
-            adjoint_node.Z = primal_node.Z
-
-        # Put primal solution on adjoint model
-        if self.primal_data_transfer_with_python:
-            Logger.PrintInfo(self._GetLabel(), "Transfer primal state to adjoint model part.")
-            variable_utils = KratosMultiphysics.VariableUtils()
-            for variable in self.primal_state_variables:
-                variable_utils.CopyModelPartNodalVar(variable, self.primal_model_part, self.adjoint_model_part, 0)
-
-
-    def _GetAdjointParameters(self):
-
-        adjoint_settings = self.response_settings["adjoint_settings"].GetString()
-
-        if adjoint_settings == "auto":
-            Logger.PrintInfo(self._GetLabel(), "Automatic set up adjoint parameters for response:", self.identifier)
-
-            if not self.primal_data_transfer_with_python:
-                raise Exception("Auto setup of adjoint parameters does only support primal data transfer with python.")
-
-            with open(self.response_settings["primal_settings"].GetString(),'r') as parameter_file:
-                primal_parameters = Parameters( parameter_file.read() )
-
-            # check that HDF5 process is not there
-            if primal_parameters["processes"].Has("list_other_processes"):
-                for i in range(0,primal_parameters["processes"]["list_other_processes"].size()):
-                    process = primal_parameters["processes"]["list_other_processes"][i]
-                    raise Exception("Auto setup of adjoint parameters does not support {} in list_other_processes".format(process["python_module"].GetString()))
-
-            # clone primal settings as base for adjoint
-            adjoint_parameters = primal_parameters.Clone()
-
-            # analysis settings
-            solver_settings = adjoint_parameters["solver_settings"]
-            primal_solver_type = solver_settings["solver_type"].GetString()
-            if primal_solver_type != "static":
-                raise Exception("Auto setup of adjoint parameters does not support {} solver_type. Only available for 'static'".format(primal_solver_type))
-            solver_settings["solver_type"].SetString("adjoint_"+primal_solver_type)
-
-            if not solver_settings.Has("compute_reactions"):
-                solver_settings.AddEmptyValue("compute_reactions")
-            solver_settings["compute_reactions"].SetBool(False)
-
-            if not solver_settings.Has("move_mesh_flag"):
-                solver_settings.AddEmptyValue("move_mesh_flag")
-            solver_settings["move_mesh_flag"].SetBool(False)
-
-            if solver_settings.Has("scheme_settings"):
-                depr_msg = '\nDEPRECATION-WARNING: "scheme_settings" is deprecated, please remove it from your json parameters.\n'
-                Logger.PrintWarning(__name__, depr_msg)
-                solver_settings.RemoveValue("scheme_settings")
-
-            if solver_settings["model_import_settings"]["input_type"].GetString() == "use_input_model_part":
-                solver_settings["model_import_settings"]["input_type"].SetString("mdpa")
-                if solver_settings["model_import_settings"].Has("input_filename"):
-                    file_name = solver_settings["model_import_settings"]["input_filename"].GetString()
-                else:
-                    Logger.PrintWarning(self._GetLabel(), "Automatic adjoint settings creator assumes the model_part_name as input_filename.")
-                    solver_settings["model_import_settings"].AddEmptyValue("input_filename")
-                    file_name = solver_settings["model_part_name"].GetString()
-                solver_settings["model_import_settings"]["input_filename"].SetString(file_name)
-
-            # Dirichlet conditions: change variables
-            for i in range(0,primal_parameters["processes"]["constraints_process_list"].size()):
-                process = adjoint_parameters["processes"]["constraints_process_list"][i]
-                variable_name = process["Parameters"]["variable_name"].GetString()
-                process["Parameters"]["variable_name"].SetString("ADJOINT_"+variable_name)
-
-            # Neumann conditions - do not modify to read the same load values as in primal:
-
-            # Output process:
-            # TODO how to add the output process? How find out about the variables?
-            if adjoint_parameters.Has("output_processes"):
-                Logger.PrintInfo(self._GetLabel(), "Output process is removed for adjoint analysis. To enable it define adjoint_parameters yourself.")
-                adjoint_parameters.RemoveValue("output_processes")
-
-            # sensitivity settings
-            adjoint_parameters["solver_settings"].AddValue("sensitivity_settings", self.response_settings["sensitivity_settings"])
-
-            # response settings
-            adjoint_parameters["solver_settings"].AddValue("response_function_settings", self.response_settings)
-
-        else: # adjoint parameters file is explicitely given - do not change it.
-            with open(self.response_settings["adjoint_settings"].GetString(),'r') as parameter_file:
-                adjoint_parameters = Parameters( parameter_file.read() )
-
-        return adjoint_parameters
-
-
-    def _GetLabel(self):
-        type_labels = {
-            "adjoint_nodal_displacement" : "NodalDisplacement",
-            "adjoint_linear_strain_energy" : "StrainEnergy",
-            "adjoint_local_stress" : "LocalStress",
-            "adjoint_max_stress" : "MaxStress",
-            "adjoint_nodal_reaction" : "NodalReaction"
-        }
-        response_type = self.response_settings["response_type"].GetString()
-        return "Adjoint" + type_labels[response_type] + "Response"
+# importing the Kratos Library
+import KratosMultiphysics
+from KratosMultiphysics import Parameters, Logger
+from KratosMultiphysics.response_functions.response_function_interface import ResponseFunctionInterface
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_analysis import StructuralMechanicsAnalysis
+
+import time as timer
+
+def _GetModelPart(model, solver_settings):
+    #TODO can be removed once model is fully available
+    model_part_name = solver_settings["model_part_name"].GetString()
+    if not model.HasModelPart(model_part_name):
+        model_part = model.CreateModelPart(model_part_name, 2)
+        domain_size = solver_settings["domain_size"].GetInt()
+        if domain_size < 0:
+            raise Exception('Please specify a "domain_size" >= 0!')
+        model_part.ProcessInfo.SetValue(KratosMultiphysics.DOMAIN_SIZE, domain_size)
+    else:
+        model_part = model.GetModelPart(model_part_name)
+
+    return model_part
+
+# ==============================================================================
+class StrainEnergyResponseFunction(ResponseFunctionInterface):
+    """Linear strain energy response function. It triggers the primal analysis and
+    uses the primal analysis results to calculate response value and gradient.
+
+    Attributes
+    ----------
+    primal_model_part : Model part of the primal analysis object
+    primal_analysis : Primal analysis object of the response function
+    response_function_utility: Cpp utilities object doing the actual computation of response value and gradient.
+    """
+
+    def __init__(self, identifier, response_settings, model):
+        self.identifier = identifier
+
+        with open(response_settings["primal_settings"].GetString()) as parameters_file:
+            ProjectParametersPrimal = Parameters(parameters_file.read())
+
+        self.primal_model_part = _GetModelPart(model, ProjectParametersPrimal["solver_settings"])
+
+        self.primal_analysis = StructuralMechanicsAnalysis(model, ProjectParametersPrimal)
+        self.primal_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.SHAPE_SENSITIVITY)
+
+        self.response_function_utility = StructuralMechanicsApplication.StrainEnergyResponseFunctionUtility(self.primal_model_part, response_settings)
+
+    def Initialize(self):
+        self.primal_analysis.Initialize()
+        self.response_function_utility.Initialize()
+
+    def InitializeSolutionStep(self):
+        self.primal_analysis.time = self.primal_analysis._GetSolver().AdvanceInTime(self.primal_analysis.time)
+        self.primal_analysis.InitializeSolutionStep()
+
+    def CalculateValue(self):
+        Logger.PrintInfo("StrainEnergyResponse", "Starting primal analysis for response", self.identifier)
+
+        startTime = timer.time()
+        self.primal_analysis._GetSolver().Predict()
+        self.primal_analysis._GetSolver().SolveSolutionStep()
+        Logger.PrintInfo("StrainEnergyResponse", "Time needed for solving the primal analysis",round(timer.time() - startTime,2),"s")
+
+        startTime = timer.time()
+        value = self.response_function_utility.CalculateValue()
+        self.primal_model_part.ProcessInfo[StructuralMechanicsApplication.RESPONSE_VALUE] = value
+        Logger.PrintInfo("StrainEnergyResponse", "Time needed for calculating the response value",round(timer.time() - startTime,2),"s")
+
+    def CalculateGradient(self):
+        Logger.PrintInfo("StrainEnergyResponse", "Starting gradient calculation for response", self.identifier)
+
+        startTime = timer.time()
+        self.response_function_utility.CalculateGradient()
+        Logger.PrintInfo("StrainEnergyResponse", "Time needed for calculating gradients",round(timer.time() - startTime,2),"s")
+
+    def FinalizeSolutionStep(self):
+        self.primal_analysis.FinalizeSolutionStep()
+        self.primal_analysis.OutputSolutionStep()
+
+    def Finalize(self):
+        self.primal_analysis.Finalize()
+
+    def GetValue(self):
+        return self.primal_model_part.ProcessInfo[StructuralMechanicsApplication.RESPONSE_VALUE]
+
+    def GetNodalGradient(self, variable):
+        if variable != KratosMultiphysics.SHAPE_SENSITIVITY:
+            raise RuntimeError("GetNodalGradient: No gradient for {}!".format(variable.Name))
+        gradient = {}
+        for node in self.primal_model_part.Nodes:
+            gradient[node.Id] = node.GetSolutionStepValue(variable)
+        return gradient
+
+    def GetElementalGradient(self, variable):
+        raise NotImplementedError("GetElementalGradient needs to be implemented for StrainEnergyResponseFunction")
+
+# ==============================================================================
+class EigenFrequencyResponseFunction(StrainEnergyResponseFunction):
+    """Eigenfrequency response function. The internal procedure is the same as
+    for the StrainEnergyResponseFunction. It triggers the primal analysis and
+    uses the primal analysis results to calculate response value and gradient.
+    Only the response_function_utility is a different object.
+
+    Attributes
+    ----------
+    primal_model_part : Model part of the primal analysis object
+    primal_analysis : Primal analysis object of the response function
+    response_function_utility: Cpp utilities object doing the actual computation of response value and gradient.
+    """
+
+    def __init__(self, identifier, response_settings, model):
+        self.identifier = identifier
+
+        with open(response_settings["primal_settings"].GetString()) as parameters_file:
+            ProjectParametersPrimal = Parameters(parameters_file.read())
+
+        eigen_solver_settings = ProjectParametersPrimal["solver_settings"]["eigensolver_settings"]
+
+        max_required_eigenfrequency = int(max(response_settings["traced_eigenfrequencies"].GetVector()))
+        if max_required_eigenfrequency is not eigen_solver_settings["number_of_eigenvalues"].GetInt():
+            Logger.PrintWarning("EigenFrequencyResponse", "Specified number of eigenvalues in the primal analysis and the max required eigenvalue according the response settings do not match!!!")
+            Logger.PrintWarning("EigenFrequencyResponse", "Primal parameters were adjusted accordingly!\n")
+            eigen_solver_settings["number_of_eigenvalues"].SetInt(max_required_eigenfrequency)
+
+        if not eigen_solver_settings.Has("normalize_eigenvectors"):
+            eigen_solver_settings.AddEmptyValue("normalize_eigenvectors")
+            eigen_solver_settings["normalize_eigenvectors"].SetBool(True)
+            Logger.PrintWarning("EigenFrequencyResponse", "Eigenfrequency response function requires mass normalization of eigenvectors!")
+            Logger.PrintWarning("EigenFrequencyResponse", "Primal parameters were adjusted accordingly!\n")
+
+        if not eigen_solver_settings["normalize_eigenvectors"].GetBool():
+            eigen_solver_settings["normalize_eigenvectors"].SetBool(True)
+            Logger.PrintWarning("EigenFrequencyResponse", "Eigenfrequency response function requires mass normalization of eigenvectors!")
+            Logger.PrintWarning("EigenFrequencyResponse", "Primal parameters were adjusted accordingly!\n")
+
+        self.primal_model_part = _GetModelPart(model, ProjectParametersPrimal["solver_settings"])
+
+        self.primal_analysis = StructuralMechanicsAnalysis(model, ProjectParametersPrimal)
+        self.primal_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.SHAPE_SENSITIVITY)
+
+
+        self.response_function_utility = StructuralMechanicsApplication.EigenfrequencyResponseFunctionUtility(self.primal_model_part, response_settings)
+
+# ==============================================================================
+class MassResponseFunction(ResponseFunctionInterface):
+    """Mass response function. It reads the materials for the model part and
+    calculates response value and gradient.
+
+    Attributes
+    ----------
+    model_part : Model part object of the response function
+    response_function_utility: Cpp utilities object doing the actual computation of response value and gradient.
+    """
+
+    def __init__(self, identifier, response_settings, model):
+        self.identifier = identifier
+
+        self.response_settings = response_settings
+        self.model = model
+        self.model_part_needs_to_be_imported = False
+
+        model_part_name = response_settings["model_part_name"].GetString()
+        input_type = response_settings["model_import_settings"]["input_type"].GetString()
+        if input_type == "mdpa":
+            self.model_part = self.model.CreateModelPart(model_part_name, 2)
+            domain_size = response_settings["domain_size"].GetInt()
+            if domain_size not in [2, 3]:
+                raise Exception("MassResponseFunction: Invalid 'domain_size': {}".format(domain_size))
+            self.model_part.ProcessInfo.SetValue(KratosMultiphysics.DOMAIN_SIZE, domain_size)
+            self.model_part_needs_to_be_imported = True
+        elif input_type == "use_input_model_part":
+            self.model_part = self.model.GetModelPart(model_part_name)
+        else:
+            raise Exception("Other model part input options are not yet implemented.")
+
+        self.response_function_utility = StructuralMechanicsApplication.MassResponseFunctionUtility(self.model_part, response_settings)
+
+        self.model_part.AddNodalSolutionStepVariable(KratosMultiphysics.SHAPE_SENSITIVITY)
+
+    def Initialize(self):
+        if self.model_part_needs_to_be_imported:
+            # import model part
+            model_part_io = KratosMultiphysics.ModelPartIO(self.response_settings["model_import_settings"]["input_filename"].GetString())
+            model_part_io.ReadModelPart(self.model_part)
+
+        # Add constitutive laws and material properties from json file to model parts.
+        material_settings = KratosMultiphysics.Parameters("""{"Parameters": {} }""")
+        materials_file_name = self.response_settings["material_import_settings"]["materials_filename"]
+        material_settings["Parameters"].AddValue("materials_filename", materials_file_name)
+        KratosMultiphysics.ReadMaterialsUtility(material_settings, self.model)
+        self.response_function_utility.Initialize()
+
+    def CalculateValue(self):
+        Logger.PrintInfo("MassResponse", "Starting primal analysis for response", self.identifier)
+
+        startTime = timer.time()
+        value = self.response_function_utility.CalculateValue()
+        self.model_part.ProcessInfo[StructuralMechanicsApplication.RESPONSE_VALUE] = value
+        Logger.PrintInfo("MassResponse", "Time needed for calculating the response value = ",round(timer.time() - startTime,2),"s")
+
+    def CalculateGradient(self):
+        Logger.PrintInfo("MassResponse", "Starting gradient calculation for response", self.identifier)
+
+        startTime = timer.time()
+        self.response_function_utility.CalculateGradient()
+        Logger.PrintInfo("MassResponse", "Time needed for calculating gradients",round(timer.time() - startTime,2),"s")
+
+    def GetValue(self):
+        return self.model_part.ProcessInfo[StructuralMechanicsApplication.RESPONSE_VALUE]
+
+    def GetNodalGradient(self, variable):
+        if variable != KratosMultiphysics.SHAPE_SENSITIVITY:
+            raise RuntimeError("GetNodalGradient: No gradient for {}!".format(variable.Name))
+        gradient = {}
+        for node in self.model_part.Nodes:
+            gradient[node.Id] = node.GetSolutionStepValue(variable)
+        return gradient
+
+    def GetElementalGradient(self, variable):
+        raise NotImplementedError("GetElementalGradient needs to be implemented for MassResponseFunction")
+
+# ==============================================================================
+class AdjointResponseFunction(ResponseFunctionInterface):
+    """Linear static adjoint strain energy response function.
+    - runs the primal analysis (writes the primal results to an .h5 file)
+    - reads the primal results from the .h5 file into the adjoint model part
+    - uses primal results to calculate value
+    - uses primal results to calculate gradient by running the adjoint analysis
+
+    Attributes
+    ----------
+    primal_analysis : Primal analysis object of the response function
+    adjoint_analysis : Adjoint analysis object of the response function
+    """
+    def __init__(self, identifier, response_settings, model):
+        self.identifier = identifier
+        self.response_settings = response_settings
+
+        # Create the primal solver
+        with open(self.response_settings["primal_settings"].GetString(),'r') as parameter_file:
+            primal_parameters = Parameters( parameter_file.read() )
+
+        self.primal_model_part = _GetModelPart(model, primal_parameters["solver_settings"])
+
+        self.primal_analysis = StructuralMechanicsAnalysis(model, primal_parameters)
+
+        self.primal_data_transfer_with_python = self.response_settings["primal_data_transfer_with_python"].GetBool()
+
+        # Create the adjoint solver
+        adjoint_parameters = self._GetAdjointParameters()
+        adjoint_model = KratosMultiphysics.Model()
+        self.adjoint_model_part = _GetModelPart(adjoint_model, adjoint_parameters["solver_settings"])
+
+        # TODO find out why it is not possible to use the same model_part
+        self.adjoint_analysis = StructuralMechanicsAnalysis(adjoint_model, adjoint_parameters)
+
+        self.primal_state_variables = [KratosMultiphysics.DISPLACEMENT]
+        if primal_parameters["solver_settings"].Has("rotation_dofs"):
+            if primal_parameters["solver_settings"]["rotation_dofs"].GetBool():
+                self.primal_state_variables.append(KratosMultiphysics.ROTATION)
+
+    def Initialize(self):
+        self.primal_analysis.Initialize()
+        self.adjoint_analysis.Initialize()
+
+    def InitializeSolutionStep(self):
+        # Run the primal analysis.
+        # TODO if primal_analysis.status==solved: return
+        Logger.PrintInfo(self._GetLabel(), "Starting primal analysis for response:", self.identifier)
+        startTime = timer.time()
+        if not self.primal_analysis.time < self.primal_analysis.end_time:
+            self.primal_analysis.end_time += 1
+        self.primal_analysis.RunSolutionLoop()
+        Logger.PrintInfo(self._GetLabel(), "Time needed for solving the primal analysis = ",round(timer.time() - startTime,2),"s")
+
+    def CalculateValue(self):
+        startTime = timer.time()
+        value = self._GetResponseFunctionUtility().CalculateValue(self.primal_model_part)
+        Logger.PrintInfo(self._GetLabel(), "Time needed for calculating the response value = ",round(timer.time() - startTime,2),"s")
+
+        self.primal_model_part.ProcessInfo[StructuralMechanicsApplication.RESPONSE_VALUE] = value
+
+    def CalculateGradient(self):
+        # synchronize the modelparts
+        self._SynchronizeAdjointFromPrimal()
+        startTime = timer.time()
+        Logger.PrintInfo(self._GetLabel(), "Starting adjoint analysis for response:", self.identifier)
+        if not self.adjoint_analysis.time < self.adjoint_analysis.end_time:
+            self.adjoint_analysis.end_time += 1
+        self.adjoint_analysis.RunSolutionLoop()
+        Logger.PrintInfo(self._GetLabel(), "Time needed for solving the adjoint analysis = ",round(timer.time() - startTime,2),"s")
+
+    def GetValue(self):
+        return self.primal_model_part.ProcessInfo[StructuralMechanicsApplication.RESPONSE_VALUE]
+
+    def GetNodalGradient(self, variable):
+        if variable != KratosMultiphysics.SHAPE_SENSITIVITY:
+            raise RuntimeError("GetNodalGradient: No gradient for {}!".format(variable.Name))
+        gradient = {}
+        for node in self.adjoint_model_part.Nodes:
+            gradient[node.Id] = node.GetSolutionStepValue(variable)
+        return gradient
+
+    def GetElementalGradient(self, variable):
+        if variable not in [
+                            StructuralMechanicsApplication.YOUNG_MODULUS_SENSITIVITY,
+                            StructuralMechanicsApplication.THICKNESS_SENSITIVITY,
+                            StructuralMechanicsApplication.I22_SENSITIVITY,
+                            StructuralMechanicsApplication.I33_SENSITIVITY,
+                            ]:
+            raise RuntimeError("GetElementalGradient: No gradient for {}!".format(variable.Name))
+        gradient = {}
+        for element in self.adjoint_model_part.Elements:
+            gradient[element.Id] = element.GetValue(variable)
+        return gradient
+
+
+    def Finalize(self):
+        self.primal_analysis.Finalize()
+        self.adjoint_analysis.Finalize()
+
+    def _GetResponseFunctionUtility(self):
+        return self.adjoint_analysis._GetSolver().response_function
+
+    def _SynchronizeAdjointFromPrimal(self):
+        Logger.PrintInfo(self._GetLabel(), "Synchronize primal and adjoint modelpart for response:", self.identifier)
+
+        if len(self.primal_model_part.Nodes) != len(self.adjoint_model_part.Nodes):
+            raise RuntimeError("_SynchronizeAdjointFromPrimal: Model parts have a different number of nodes!")
+
+        # TODO this should happen automatically
+        for primal_node, adjoint_node in zip(self.primal_model_part.Nodes, self.adjoint_model_part.Nodes):
+            adjoint_node.X0 = primal_node.X0
+            adjoint_node.Y0 = primal_node.Y0
+            adjoint_node.Z0 = primal_node.Z0
+            adjoint_node.X = primal_node.X
+            adjoint_node.Y = primal_node.Y
+            adjoint_node.Z = primal_node.Z
+
+        # Put primal solution on adjoint model
+        if self.primal_data_transfer_with_python:
+            Logger.PrintInfo(self._GetLabel(), "Transfer primal state to adjoint model part.")
+            variable_utils = KratosMultiphysics.VariableUtils()
+            for variable in self.primal_state_variables:
+                variable_utils.CopyModelPartNodalVar(variable, self.primal_model_part, self.adjoint_model_part, 0)
+
+
+    def _GetAdjointParameters(self):
+
+        adjoint_settings = self.response_settings["adjoint_settings"].GetString()
+
+        if adjoint_settings == "auto":
+            Logger.PrintInfo(self._GetLabel(), "Automatic set up adjoint parameters for response:", self.identifier)
+
+            if not self.primal_data_transfer_with_python:
+                raise Exception("Auto setup of adjoint parameters does only support primal data transfer with python.")
+
+            with open(self.response_settings["primal_settings"].GetString(),'r') as parameter_file:
+                primal_parameters = Parameters( parameter_file.read() )
+
+            # check that HDF5 process is not there
+            if primal_parameters["processes"].Has("list_other_processes"):
+                for i in range(0,primal_parameters["processes"]["list_other_processes"].size()):
+                    process = primal_parameters["processes"]["list_other_processes"][i]
+                    raise Exception("Auto setup of adjoint parameters does not support {} in list_other_processes".format(process["python_module"].GetString()))
+
+            # clone primal settings as base for adjoint
+            adjoint_parameters = primal_parameters.Clone()
+
+            # analysis settings
+            solver_settings = adjoint_parameters["solver_settings"]
+            primal_solver_type = solver_settings["solver_type"].GetString()
+            if primal_solver_type != "static":
+                raise Exception("Auto setup of adjoint parameters does not support {} solver_type. Only available for 'static'".format(primal_solver_type))
+            solver_settings["solver_type"].SetString("adjoint_"+primal_solver_type)
+
+            if not solver_settings.Has("compute_reactions"):
+                solver_settings.AddEmptyValue("compute_reactions")
+            solver_settings["compute_reactions"].SetBool(False)
+
+            if not solver_settings.Has("move_mesh_flag"):
+                solver_settings.AddEmptyValue("move_mesh_flag")
+            solver_settings["move_mesh_flag"].SetBool(False)
+
+            if solver_settings.Has("scheme_settings"):
+                depr_msg = '\nDEPRECATION-WARNING: "scheme_settings" is deprecated, please remove it from your json parameters.\n'
+                Logger.PrintWarning(__name__, depr_msg)
+                solver_settings.RemoveValue("scheme_settings")
+
+            if solver_settings["model_import_settings"]["input_type"].GetString() == "use_input_model_part":
+                solver_settings["model_import_settings"]["input_type"].SetString("mdpa")
+                if solver_settings["model_import_settings"].Has("input_filename"):
+                    file_name = solver_settings["model_import_settings"]["input_filename"].GetString()
+                else:
+                    Logger.PrintWarning(self._GetLabel(), "Automatic adjoint settings creator assumes the model_part_name as input_filename.")
+                    solver_settings["model_import_settings"].AddEmptyValue("input_filename")
+                    file_name = solver_settings["model_part_name"].GetString()
+                solver_settings["model_import_settings"]["input_filename"].SetString(file_name)
+
+            # Dirichlet conditions: change variables
+            for i in range(0,primal_parameters["processes"]["constraints_process_list"].size()):
+                process = adjoint_parameters["processes"]["constraints_process_list"][i]
+                variable_name = process["Parameters"]["variable_name"].GetString()
+                process["Parameters"]["variable_name"].SetString("ADJOINT_"+variable_name)
+
+            # Neumann conditions - do not modify to read the same load values as in primal:
+
+            # Output process:
+            # TODO how to add the output process? How find out about the variables?
+            if adjoint_parameters.Has("output_processes"):
+                Logger.PrintInfo(self._GetLabel(), "Output process is removed for adjoint analysis. To enable it define adjoint_parameters yourself.")
+                adjoint_parameters.RemoveValue("output_processes")
+
+            # sensitivity settings
+            adjoint_parameters["solver_settings"].AddValue("sensitivity_settings", self.response_settings["sensitivity_settings"])
+
+            # response settings
+            adjoint_parameters["solver_settings"].AddValue("response_function_settings", self.response_settings)
+
+        else: # adjoint parameters file is explicitely given - do not change it.
+            with open(self.response_settings["adjoint_settings"].GetString(),'r') as parameter_file:
+                adjoint_parameters = Parameters( parameter_file.read() )
+
+        return adjoint_parameters
+
+
+    def _GetLabel(self):
+        type_labels = {
+            "adjoint_nodal_displacement" : "NodalDisplacement",
+            "adjoint_linear_strain_energy" : "StrainEnergy",
+            "adjoint_local_stress" : "LocalStress",
+            "adjoint_max_stress" : "MaxStress",
+            "adjoint_nodal_reaction" : "NodalReaction"
+        }
+        response_type = self.response_settings["response_type"].GetString()
+        return "Adjoint" + type_labels[response_type] + "Response"
```

## KratosMultiphysics/StructuralMechanicsApplication/displacement_control_with_direction_process.py

 * *Ordering differences only*

```diff
@@ -1,88 +1,88 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-def Factory(settings, Model):
-    if not isinstance(settings, KratosMultiphysics.Parameters):
-        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
-    return AssignDisplacementControlProcess(Model, settings["Parameters"])
-
-from KratosMultiphysics import assign_scalar_variable_to_entities_process as asvtep
-
-## All the processes python should be derived from "Process"
-class AssignDisplacementControlProcess(asvtep.AssignScalarVariableToEntitiesProcess):
-    """This process assigns given POINT_LOAD and PRESCRIBED_DISPLACEMENT values
-    (scalar) to the DisplacementControl belonging a certain submodelpart.
-    Currently, it is restricted to one node and one global direction.
-
-    Only the member variables listed below should be accessed directly.
-
-    Public member variables:
-    Model -- the container of the different model parts.
-    settings -- Kratos parameters containing solver settings.
-    """
-
-    def __init__(self, Model, settings ):
-        """ The default constructor of the class
-
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        Model -- the container of the different model parts.
-        settings -- Kratos parameters containing solver settings.
-        """
-
-        KratosMultiphysics.Process.__init__(self)
-
-        #The value can be a double or a string (function)
-        default_settings = KratosMultiphysics.Parameters("""
-        {
-            "help"            : "This process assigns given POINT_LOAD and PRESCRIBED_DISPLACEMENT values (scalar) to the DisplacementControl belonging a certain submodelpart",
-            "model_part_name" : "please_specify_model_part_name",
-            "direction"       : "x, y, or z",
-            "interval"        : [0.0, 1e30],
-            "point_load_value"              : 1.0,
-            "prescribed_displacement_value" : "please give an expression in terms of the variable x, y, z, t"
-        }
-        """
-        )
-
-        settings.ValidateAndAssignDefaults(default_settings)
-        if settings["direction"].GetString().lower() == "x":
-            direction = "_X"
-        elif settings["direction"].GetString().lower() == "y":
-            direction = "_Y"
-        elif settings["direction"].GetString().lower() == "z":
-            direction = "_Z"
-        else:
-            raise NotImplementedError("Direction can be x, y, or z. Given is: " + settings["direction"].GetString())
-
-        tmp = KratosMultiphysics.Parameters('{"variable_name_load": "POINT_LOAD' +direction+'", "entities": ["conditions"], "variable_name_disp" : "PRESCRIBED_DISPLACEMENT"}')
-
-        params_load = KratosMultiphysics.Parameters("{}")
-        params_load.AddValue("model_part_name", settings["model_part_name"])
-        params_load.AddValue("interval", settings["interval"])
-        params_load.AddValue("value", settings["point_load_value"])
-        params_load.AddValue("variable_name", tmp["variable_name_load"])
-        params_load.AddValue("entities", tmp["entities"])
-
-        params_disp = KratosMultiphysics.Parameters("{}")
-        params_disp.AddValue("model_part_name", settings["model_part_name"])
-        params_disp.AddValue("interval", settings["interval"])
-        params_disp.AddValue("value", settings["prescribed_displacement_value"])
-        params_disp.AddValue("variable_name", tmp["variable_name_disp"])
-        params_disp.AddValue("entities", tmp["entities"])
-
-        # Set processes
-        self.aux_processes = []
-        self.aux_processes.append(asvtep.AssignScalarVariableToEntitiesProcess(Model, params_load))
-        self.aux_processes.append(asvtep.AssignScalarVariableToEntitiesProcess(Model, params_disp))
-
-        self.step_is_active = False
-
-    def ExecuteInitializeSolutionStep(self):
-        """ This method is executed in order to initialize the current step
-
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        """
-        for process in self.aux_processes:
-            process.ExecuteInitializeSolutionStep()
+# Importing the Kratos Library
+import KratosMultiphysics
+
+def Factory(settings, Model):
+    if not isinstance(settings, KratosMultiphysics.Parameters):
+        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
+    return AssignDisplacementControlProcess(Model, settings["Parameters"])
+
+from KratosMultiphysics import assign_scalar_variable_to_entities_process as asvtep
+
+## All the processes python should be derived from "Process"
+class AssignDisplacementControlProcess(asvtep.AssignScalarVariableToEntitiesProcess):
+    """This process assigns given POINT_LOAD and PRESCRIBED_DISPLACEMENT values
+    (scalar) to the DisplacementControl belonging a certain submodelpart.
+    Currently, it is restricted to one node and one global direction.
+
+    Only the member variables listed below should be accessed directly.
+
+    Public member variables:
+    Model -- the container of the different model parts.
+    settings -- Kratos parameters containing solver settings.
+    """
+
+    def __init__(self, Model, settings ):
+        """ The default constructor of the class
+
+        Keyword arguments:
+        self -- It signifies an instance of a class.
+        Model -- the container of the different model parts.
+        settings -- Kratos parameters containing solver settings.
+        """
+
+        KratosMultiphysics.Process.__init__(self)
+
+        #The value can be a double or a string (function)
+        default_settings = KratosMultiphysics.Parameters("""
+        {
+            "help"            : "This process assigns given POINT_LOAD and PRESCRIBED_DISPLACEMENT values (scalar) to the DisplacementControl belonging a certain submodelpart",
+            "model_part_name" : "please_specify_model_part_name",
+            "direction"       : "x, y, or z",
+            "interval"        : [0.0, 1e30],
+            "point_load_value"              : 1.0,
+            "prescribed_displacement_value" : "please give an expression in terms of the variable x, y, z, t"
+        }
+        """
+        )
+
+        settings.ValidateAndAssignDefaults(default_settings)
+        if settings["direction"].GetString().lower() == "x":
+            direction = "_X"
+        elif settings["direction"].GetString().lower() == "y":
+            direction = "_Y"
+        elif settings["direction"].GetString().lower() == "z":
+            direction = "_Z"
+        else:
+            raise NotImplementedError("Direction can be x, y, or z. Given is: " + settings["direction"].GetString())
+
+        tmp = KratosMultiphysics.Parameters('{"variable_name_load": "POINT_LOAD' +direction+'", "entities": ["conditions"], "variable_name_disp" : "PRESCRIBED_DISPLACEMENT"}')
+
+        params_load = KratosMultiphysics.Parameters("{}")
+        params_load.AddValue("model_part_name", settings["model_part_name"])
+        params_load.AddValue("interval", settings["interval"])
+        params_load.AddValue("value", settings["point_load_value"])
+        params_load.AddValue("variable_name", tmp["variable_name_load"])
+        params_load.AddValue("entities", tmp["entities"])
+
+        params_disp = KratosMultiphysics.Parameters("{}")
+        params_disp.AddValue("model_part_name", settings["model_part_name"])
+        params_disp.AddValue("interval", settings["interval"])
+        params_disp.AddValue("value", settings["prescribed_displacement_value"])
+        params_disp.AddValue("variable_name", tmp["variable_name_disp"])
+        params_disp.AddValue("entities", tmp["entities"])
+
+        # Set processes
+        self.aux_processes = []
+        self.aux_processes.append(asvtep.AssignScalarVariableToEntitiesProcess(Model, params_load))
+        self.aux_processes.append(asvtep.AssignScalarVariableToEntitiesProcess(Model, params_disp))
+
+        self.step_is_active = False
+
+    def ExecuteInitializeSolutionStep(self):
+        """ This method is executed in order to initialize the current step
+
+        Keyword arguments:
+        self -- It signifies an instance of a class.
+        """
+        for process in self.aux_processes:
+            process.ExecuteInitializeSolutionStep()
```

## KratosMultiphysics/StructuralMechanicsApplication/distribute_load_on_surface_process.py

 * *Ordering differences only*

```diff
@@ -1,10 +1,10 @@
-import KratosMultiphysics as KM
-import KratosMultiphysics.StructuralMechanicsApplication as KSM
-
-
-def Factory(settings, Model):
-    if not isinstance(settings, KM.Parameters):
-        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
-
-    model_part = Model.GetModelPart(settings["Parameters"]["model_part_name"].GetString())
-    return KSM.DistributeLoadOnSurfaceProcess(model_part, settings["Parameters"])
+import KratosMultiphysics as KM
+import KratosMultiphysics.StructuralMechanicsApplication as KSM
+
+
+def Factory(settings, Model):
+    if not isinstance(settings, KM.Parameters):
+        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
+
+    model_part = Model.GetModelPart(settings["Parameters"]["model_part_name"].GetString())
+    return KSM.DistributeLoadOnSurfaceProcess(model_part, settings["Parameters"])
```

## KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_analysis.py

 * *Ordering differences only*

```diff
@@ -1,138 +1,138 @@
-# Importing Kratos
-import KratosMultiphysics
-from KratosMultiphysics.StructuralMechanicsApplication import python_solvers_wrapper_structural as structural_solvers
-
-# Importing the base class
-from KratosMultiphysics.analysis_stage import AnalysisStage
-
-class StructuralMechanicsAnalysis(AnalysisStage):
-    """
-    This class is the main-script of the StructuralMechanicsApplication put in a class
-
-    It can be imported and used as "black-box"
-    """
-    def __init__(self, model, project_parameters):
-        # Making sure that older cases still work by properly initalizing the parameters
-        solver_settings = project_parameters["solver_settings"]
-
-        if solver_settings.Has("domain_size") and project_parameters["problem_data"].Has("domain_size"):
-            raise Exception("StructuralMechanicsAnalysis: " + '"domain_size" defined both in "problem_data" and "solver_settings"!')
-
-        if solver_settings.Has("model_part_name") and project_parameters["problem_data"].Has("model_part_name"):
-            raise Exception("StructuralMechanicsAnalysis: " + '"model_part_name" defined both in problem_data" and "solver_settings"!')
-
-        if solver_settings.Has("time_stepping") and project_parameters["problem_data"].Has("time_Step"):
-            raise Exception("StructuralMechanicsAnalysis: " + '"time_stepping" defined both in "problem_data" and "solver_settings"!')
-
-        if not solver_settings.Has("time_stepping"):
-            raise Exception("StructuralMechanicsAnalysis: Using the old way to pass the time_step, this was removed!")
-
-        if not solver_settings.Has("domain_size"):
-            raise Exception("StructuralMechanicsAnalysis: Using the old way to pass the domain_size, this was removed!")
-
-        # Detect is a contact problem
-        # NOTE: We have a special treatment for contact problems due to the way the convergence info is printed (in a table). Not doing this will provoque that the table is discontinous (and not fancy and eye-candy)
-        solver_settings = project_parameters["solver_settings"]
-        self.contact_problem = solver_settings.Has("contact_settings") or solver_settings.Has("mpc_contact_settings")
-
-        super().__init__(model, project_parameters)
-
-    def Initialize(self):
-        """ Initializing the Analysis """
-        super().Initialize()
-
-        # In case of contact problem
-        if self.contact_problem:
-            self._GetSolver().SetEchoLevel(self.echo_level)
-            # To avoid many prints
-            if self.echo_level == 0:
-                KratosMultiphysics.Logger.GetDefaultOutput().SetSeverity(KratosMultiphysics.Logger.Severity.WARNING)
-
-    def OutputSolutionStep(self):
-        """This function printed / writes output files after the solution of a step
-        """
-
-        # In case of contact problem
-        if self.contact_problem:
-            # First we check if one of the output processes will print output in this step this is done to save computation in case none of them will print
-            is_output_step = False
-            for output_process in self._GetListOfOutputProcesses():
-                if output_process.IsOutputStep():
-                    is_output_step = True
-                    break
-
-            if is_output_step:
-                # Informing the output will be created
-                KratosMultiphysics.Logger.PrintWarning("StructuralMechanicsAnalysis", "STEP: ", self._GetSolver().GetComputingModelPart().ProcessInfo[KratosMultiphysics.STEP])
-                KratosMultiphysics.Logger.PrintWarning("StructuralMechanicsAnalysis", "TIME: ", self.time)
-
-        # Creating output
-        super().OutputSolutionStep()
-
-    #### Internal functions ####
-    def _CreateSolver(self):
-        """ Create the Solver (and create and import the ModelPart if it is not alread in the model) """
-        ## Solver construction
-        return structural_solvers.CreateSolver(self.model, self.project_parameters)
-
-    def _CreateProcesses(self, parameter_name, initialization_order):
-        """Create a list of Processes
-        This method is TEMPORARY to not break existing code
-        It will be removed in the future
-        """
-        list_of_processes = super()._CreateProcesses(parameter_name, initialization_order)
-
-        if parameter_name == "processes":
-            processes_block_names = ["constraints_process_list", "loads_process_list", "list_other_processes", "json_output_process",
-                "json_check_process", "check_analytic_results_process", "contact_process_list"]
-            if len(list_of_processes) == 0: # Processes are given in the old format (or no processes are specified)
-                for process_name in processes_block_names:
-                    if self.project_parameters.Has(process_name):
-                        info_msg  = "Using the old way to create the processes, this was removed!\n"
-                        info_msg += "Refer to \"https://github.com/KratosMultiphysics/Kratos/wiki/Common-"
-                        info_msg += "Python-Interface-of-Applications-for-Users#analysisstage-usage\" "
-                        info_msg += "for a description of the new format"
-                        raise Exception("StructuralMechanicsAnalysis: " + info_msg)
-
-            else: # Processes are given in the new format
-                for process_name in processes_block_names:
-                    if self.project_parameters.Has(process_name):
-                        raise Exception("Mixing of process initialization is not allowed!")
-        elif parameter_name == "output_processes":
-            if self.project_parameters.Has("output_configuration"):
-                info_msg  = "Using the old way to create the gid-output, this was removed!\n"
-                info_msg += "Refer to \"https://github.com/KratosMultiphysics/Kratos/wiki/Common-"
-                info_msg += "Python-Interface-of-Applications-for-Users#analysisstage-usage\" "
-                info_msg += "for a description of the new format"
-                raise Exception("StructuralMechanicsAnalysis: " + info_msg)
-        else:
-            raise NameError("wrong parameter name")
-
-        return list_of_processes
-
-    def _GetSimulationName(self):
-        return "::[KSM Simulation]:: "
-
-if __name__ == "__main__":
-    from sys import argv
-
-    if len(argv) > 2:
-        err_msg =  'Too many input arguments!\n'
-        err_msg += 'Use this script in the following way:\n'
-        err_msg += '- With default ProjectParameters (read from "ProjectParameters.json"):\n'
-        err_msg += '    "python3 structural_mechanics_analysis.py"\n'
-        err_msg += '- With custom ProjectParameters:\n'
-        err_msg += '    "python3 structural_mechanics_analysis.py CustomProjectParameters.json"\n'
-        raise Exception(err_msg)
-
-    if len(argv) == 2: # ProjectParameters is being passed from outside
-        project_parameters_file_name = argv[1]
-    else: # using default name
-        project_parameters_file_name = "ProjectParameters.json"
-
-    with open(project_parameters_file_name,'r') as parameter_file:
-        parameters = KratosMultiphysics.Parameters(parameter_file.read())
-
-    model = KratosMultiphysics.Model()
-    simulation = StructuralMechanicsAnalysis(model, parameters)
-    simulation.Run()
+# Importing Kratos
+import KratosMultiphysics
+from KratosMultiphysics.StructuralMechanicsApplication import python_solvers_wrapper_structural as structural_solvers
+
+# Importing the base class
+from KratosMultiphysics.analysis_stage import AnalysisStage
+
+class StructuralMechanicsAnalysis(AnalysisStage):
+    """
+    This class is the main-script of the StructuralMechanicsApplication put in a class
+
+    It can be imported and used as "black-box"
+    """
+    def __init__(self, model, project_parameters):
+        # Making sure that older cases still work by properly initalizing the parameters
+        solver_settings = project_parameters["solver_settings"]
+
+        if solver_settings.Has("domain_size") and project_parameters["problem_data"].Has("domain_size"):
+            raise Exception("StructuralMechanicsAnalysis: " + '"domain_size" defined both in "problem_data" and "solver_settings"!')
+
+        if solver_settings.Has("model_part_name") and project_parameters["problem_data"].Has("model_part_name"):
+            raise Exception("StructuralMechanicsAnalysis: " + '"model_part_name" defined both in problem_data" and "solver_settings"!')
+
+        if solver_settings.Has("time_stepping") and project_parameters["problem_data"].Has("time_Step"):
+            raise Exception("StructuralMechanicsAnalysis: " + '"time_stepping" defined both in "problem_data" and "solver_settings"!')
+
+        if not solver_settings.Has("time_stepping"):
+            raise Exception("StructuralMechanicsAnalysis: Using the old way to pass the time_step, this was removed!")
+
+        if not solver_settings.Has("domain_size"):
+            raise Exception("StructuralMechanicsAnalysis: Using the old way to pass the domain_size, this was removed!")
+
+        # Detect is a contact problem
+        # NOTE: We have a special treatment for contact problems due to the way the convergence info is printed (in a table). Not doing this will provoque that the table is discontinous (and not fancy and eye-candy)
+        solver_settings = project_parameters["solver_settings"]
+        self.contact_problem = solver_settings.Has("contact_settings") or solver_settings.Has("mpc_contact_settings")
+
+        super().__init__(model, project_parameters)
+
+    def Initialize(self):
+        """ Initializing the Analysis """
+        super().Initialize()
+
+        # In case of contact problem
+        if self.contact_problem:
+            self._GetSolver().SetEchoLevel(self.echo_level)
+            # To avoid many prints
+            if self.echo_level == 0:
+                KratosMultiphysics.Logger.GetDefaultOutput().SetSeverity(KratosMultiphysics.Logger.Severity.WARNING)
+
+    def OutputSolutionStep(self):
+        """This function printed / writes output files after the solution of a step
+        """
+
+        # In case of contact problem
+        if self.contact_problem:
+            # First we check if one of the output processes will print output in this step this is done to save computation in case none of them will print
+            is_output_step = False
+            for output_process in self._GetListOfOutputProcesses():
+                if output_process.IsOutputStep():
+                    is_output_step = True
+                    break
+
+            if is_output_step:
+                # Informing the output will be created
+                KratosMultiphysics.Logger.PrintWarning("StructuralMechanicsAnalysis", "STEP: ", self._GetSolver().GetComputingModelPart().ProcessInfo[KratosMultiphysics.STEP])
+                KratosMultiphysics.Logger.PrintWarning("StructuralMechanicsAnalysis", "TIME: ", self.time)
+
+        # Creating output
+        super().OutputSolutionStep()
+
+    #### Internal functions ####
+    def _CreateSolver(self):
+        """ Create the Solver (and create and import the ModelPart if it is not alread in the model) """
+        ## Solver construction
+        return structural_solvers.CreateSolver(self.model, self.project_parameters)
+
+    def _CreateProcesses(self, parameter_name, initialization_order):
+        """Create a list of Processes
+        This method is TEMPORARY to not break existing code
+        It will be removed in the future
+        """
+        list_of_processes = super()._CreateProcesses(parameter_name, initialization_order)
+
+        if parameter_name == "processes":
+            processes_block_names = ["constraints_process_list", "loads_process_list", "list_other_processes", "json_output_process",
+                "json_check_process", "check_analytic_results_process", "contact_process_list"]
+            if len(list_of_processes) == 0: # Processes are given in the old format (or no processes are specified)
+                for process_name in processes_block_names:
+                    if self.project_parameters.Has(process_name):
+                        info_msg  = "Using the old way to create the processes, this was removed!\n"
+                        info_msg += "Refer to \"https://github.com/KratosMultiphysics/Kratos/wiki/Common-"
+                        info_msg += "Python-Interface-of-Applications-for-Users#analysisstage-usage\" "
+                        info_msg += "for a description of the new format"
+                        raise Exception("StructuralMechanicsAnalysis: " + info_msg)
+
+            else: # Processes are given in the new format
+                for process_name in processes_block_names:
+                    if self.project_parameters.Has(process_name):
+                        raise Exception("Mixing of process initialization is not allowed!")
+        elif parameter_name == "output_processes":
+            if self.project_parameters.Has("output_configuration"):
+                info_msg  = "Using the old way to create the gid-output, this was removed!\n"
+                info_msg += "Refer to \"https://github.com/KratosMultiphysics/Kratos/wiki/Common-"
+                info_msg += "Python-Interface-of-Applications-for-Users#analysisstage-usage\" "
+                info_msg += "for a description of the new format"
+                raise Exception("StructuralMechanicsAnalysis: " + info_msg)
+        else:
+            raise NameError("wrong parameter name")
+
+        return list_of_processes
+
+    def _GetSimulationName(self):
+        return "::[KSM Simulation]:: "
+
+if __name__ == "__main__":
+    from sys import argv
+
+    if len(argv) > 2:
+        err_msg =  'Too many input arguments!\n'
+        err_msg += 'Use this script in the following way:\n'
+        err_msg += '- With default ProjectParameters (read from "ProjectParameters.json"):\n'
+        err_msg += '    "python3 structural_mechanics_analysis.py"\n'
+        err_msg += '- With custom ProjectParameters:\n'
+        err_msg += '    "python3 structural_mechanics_analysis.py CustomProjectParameters.json"\n'
+        raise Exception(err_msg)
+
+    if len(argv) == 2: # ProjectParameters is being passed from outside
+        project_parameters_file_name = argv[1]
+    else: # using default name
+        project_parameters_file_name = "ProjectParameters.json"
+
+    with open(project_parameters_file_name,'r') as parameter_file:
+        parameters = KratosMultiphysics.Parameters(parameter_file.read())
+
+    model = KratosMultiphysics.Model()
+    simulation = StructuralMechanicsAnalysis(model, parameters)
+    simulation.Run()
```

## KratosMultiphysics/StructuralMechanicsApplication/python_solvers_wrapper_structural.py

 * *Ordering differences only*

```diff
@@ -1,115 +1,115 @@
-# Importing Kratos
-import KratosMultiphysics
-
-# Other imports
-from importlib import import_module
-
-def CreateSolverByParameters(model, solver_settings, parallelism):
-
-    solver_type = solver_settings["solver_type"].GetString()
-
-    if solver_settings.Has("time_integration_method"):
-        time_integration_method = solver_settings["time_integration_method"].GetString()
-    else:
-        time_integration_method = "implicit" # defaulting to implicit time-integration
-
-    try_import_custom_solver = False
-
-    # Solvers for OpenMP parallelism
-    if parallelism == "OpenMP":
-        if solver_type == "dynamic" or solver_type == "Dynamic":
-            if time_integration_method == "implicit":
-                solver_module_name = "structural_mechanics_implicit_dynamic_solver"
-            elif time_integration_method == "explicit":
-                solver_module_name = "structural_mechanics_explicit_dynamic_solver"
-            else:
-                err_msg =  "The requested time integration method \"" + time_integration_method + "\" is not in the python solvers wrapper\n"
-                err_msg += "Available options are: \"implicit\", \"explicit\""
-                raise Exception(err_msg)
-
-        elif solver_type == "static" or solver_type == "Static":
-            solver_module_name = "structural_mechanics_static_solver"
-
-        elif solver_type == "static_shifted_boundary":
-            solver_module_name = "structural_mechanics_static_shifted_boundary_solver"
-
-        elif solver_type == "eigen_value":
-            solver_module_name = "structural_mechanics_eigensolver"
-
-        elif solver_type == "harmonic_analysis":
-            solver_module_name = "structural_mechanics_harmonic_analysis_solver"
-
-        elif solver_type == "formfinding":
-            solver_module_name = "structural_mechanics_formfinding_solver"
-
-        elif solver_type == "adjoint_static":
-            solver_module_name = "structural_mechanics_adjoint_static_solver"
-
-        elif solver_type == "prebuckling":
-            solver_module_name = "structural_mechanics_prebuckling_solver"
-
-        else:
-            available_solver_types = ["static", "dynamic", "eigen_value", "harmonic_analysis", "formfinding", "adjoint_static","prebuckling"]
-            try_import_custom_solver = True
-
-    # Solvers for MPI parallelism
-    elif parallelism == "MPI":
-        if solver_type == "dynamic" or solver_type == "Dynamic":
-            if time_integration_method == "implicit":
-                solver_module_name = "trilinos_structural_mechanics_implicit_dynamic_solver"
-            else:
-                err_msg =  "The requested time integration method \"" + time_integration_method + "\" is not in the python solvers wrapper\n"
-                err_msg += "Available options are: \"implicit\""
-                raise Exception(err_msg)
-
-        elif solver_type == "static" or solver_type == "Static":
-            solver_module_name = "trilinos_structural_mechanics_static_solver"
-
-        else:
-            available_solver_types = ["static", "dynamic"]
-            try_import_custom_solver = True
-    else:
-        err_msg =  "The requested parallel type \"" + parallelism + "\" is not available!\n"
-        err_msg += "Available options are: \"OpenMP\", \"MPI\""
-        raise Exception(err_msg)
-
-    if try_import_custom_solver:
-        KratosMultiphysics.Logger.PrintInfo("MechanicalSolversWrapper", 'Selected "solver_type" "{0}" not available in the python solvers wrapper, attempting to import custom solver from module "{0}"'.format(solver_type))
-        try:
-            solver = import_module(solver_type).CreateSolver(model, solver_settings)
-            KratosMultiphysics.Logger.PrintInfo("MechanicalSolversWrapper", 'Using custom solver "{}", defined in module "{}"'.format(solver.__class__.__name__, solver.__class__.__module__))
-            return solver
-        except:
-            err_msg =  'Importing custom solver from module "{}" failed.\n'.format(solver_type)
-            err_msg += 'The requested solver type "{}" is not in the python solvers wrapper\n'.format(solver_type)
-            err_msg += "Available options are: {}".format(', '.join(available_solver_types))
-            raise Exception(err_msg)
-
-    if solver_settings.Has("contact_settings"):  # This is a contact problem
-        kratos_module = "KratosMultiphysics.ContactStructuralMechanicsApplication"
-        solver_module_name = "contact_" + solver_module_name
-
-    elif solver_settings.Has("mpc_contact_settings"):  # This is a mpc contact problem
-        kratos_module = "KratosMultiphysics.ContactStructuralMechanicsApplication"
-        solver_module_name = "mpc_contact_" + solver_module_name
-
-    else:
-        kratos_module = "KratosMultiphysics.StructuralMechanicsApplication"
-
-    solver = import_module(kratos_module + "." + solver_module_name).CreateSolver(model, solver_settings)
-
-    return solver
-
-
-def CreateSolver(model, custom_settings):
-
-    if not isinstance(model, KratosMultiphysics.Model):
-        raise Exception("input is expected to be provided as a Kratos Model object")#
-
-    if not isinstance(custom_settings, KratosMultiphysics.Parameters):
-        raise Exception("input is expected to be provided as a Kratos Parameters object")
-
-    solver_settings = custom_settings["solver_settings"]
-    parallelism = custom_settings["problem_data"]["parallel_type"].GetString()
-
-    return CreateSolverByParameters(model, solver_settings, parallelism)
+# Importing Kratos
+import KratosMultiphysics
+
+# Other imports
+from importlib import import_module
+
+def CreateSolverByParameters(model, solver_settings, parallelism):
+
+    solver_type = solver_settings["solver_type"].GetString()
+
+    if solver_settings.Has("time_integration_method"):
+        time_integration_method = solver_settings["time_integration_method"].GetString()
+    else:
+        time_integration_method = "implicit" # defaulting to implicit time-integration
+
+    try_import_custom_solver = False
+
+    # Solvers for OpenMP parallelism
+    if parallelism == "OpenMP":
+        if solver_type == "dynamic" or solver_type == "Dynamic":
+            if time_integration_method == "implicit":
+                solver_module_name = "structural_mechanics_implicit_dynamic_solver"
+            elif time_integration_method == "explicit":
+                solver_module_name = "structural_mechanics_explicit_dynamic_solver"
+            else:
+                err_msg =  "The requested time integration method \"" + time_integration_method + "\" is not in the python solvers wrapper\n"
+                err_msg += "Available options are: \"implicit\", \"explicit\""
+                raise Exception(err_msg)
+
+        elif solver_type == "static" or solver_type == "Static":
+            solver_module_name = "structural_mechanics_static_solver"
+
+        elif solver_type == "static_shifted_boundary":
+            solver_module_name = "structural_mechanics_static_shifted_boundary_solver"
+
+        elif solver_type == "eigen_value":
+            solver_module_name = "structural_mechanics_eigensolver"
+
+        elif solver_type == "harmonic_analysis":
+            solver_module_name = "structural_mechanics_harmonic_analysis_solver"
+
+        elif solver_type == "formfinding":
+            solver_module_name = "structural_mechanics_formfinding_solver"
+
+        elif solver_type == "adjoint_static":
+            solver_module_name = "structural_mechanics_adjoint_static_solver"
+
+        elif solver_type == "prebuckling":
+            solver_module_name = "structural_mechanics_prebuckling_solver"
+
+        else:
+            available_solver_types = ["static", "dynamic", "eigen_value", "harmonic_analysis", "formfinding", "adjoint_static","prebuckling"]
+            try_import_custom_solver = True
+
+    # Solvers for MPI parallelism
+    elif parallelism == "MPI":
+        if solver_type == "dynamic" or solver_type == "Dynamic":
+            if time_integration_method == "implicit":
+                solver_module_name = "trilinos_structural_mechanics_implicit_dynamic_solver"
+            else:
+                err_msg =  "The requested time integration method \"" + time_integration_method + "\" is not in the python solvers wrapper\n"
+                err_msg += "Available options are: \"implicit\""
+                raise Exception(err_msg)
+
+        elif solver_type == "static" or solver_type == "Static":
+            solver_module_name = "trilinos_structural_mechanics_static_solver"
+
+        else:
+            available_solver_types = ["static", "dynamic"]
+            try_import_custom_solver = True
+    else:
+        err_msg =  "The requested parallel type \"" + parallelism + "\" is not available!\n"
+        err_msg += "Available options are: \"OpenMP\", \"MPI\""
+        raise Exception(err_msg)
+
+    if try_import_custom_solver:
+        KratosMultiphysics.Logger.PrintInfo("MechanicalSolversWrapper", 'Selected "solver_type" "{0}" not available in the python solvers wrapper, attempting to import custom solver from module "{0}"'.format(solver_type))
+        try:
+            solver = import_module(solver_type).CreateSolver(model, solver_settings)
+            KratosMultiphysics.Logger.PrintInfo("MechanicalSolversWrapper", 'Using custom solver "{}", defined in module "{}"'.format(solver.__class__.__name__, solver.__class__.__module__))
+            return solver
+        except:
+            err_msg =  'Importing custom solver from module "{}" failed.\n'.format(solver_type)
+            err_msg += 'The requested solver type "{}" is not in the python solvers wrapper\n'.format(solver_type)
+            err_msg += "Available options are: {}".format(', '.join(available_solver_types))
+            raise Exception(err_msg)
+
+    if solver_settings.Has("contact_settings"):  # This is a contact problem
+        kratos_module = "KratosMultiphysics.ContactStructuralMechanicsApplication"
+        solver_module_name = "contact_" + solver_module_name
+
+    elif solver_settings.Has("mpc_contact_settings"):  # This is a mpc contact problem
+        kratos_module = "KratosMultiphysics.ContactStructuralMechanicsApplication"
+        solver_module_name = "mpc_contact_" + solver_module_name
+
+    else:
+        kratos_module = "KratosMultiphysics.StructuralMechanicsApplication"
+
+    solver = import_module(kratos_module + "." + solver_module_name).CreateSolver(model, solver_settings)
+
+    return solver
+
+
+def CreateSolver(model, custom_settings):
+
+    if not isinstance(model, KratosMultiphysics.Model):
+        raise Exception("input is expected to be provided as a Kratos Model object")#
+
+    if not isinstance(custom_settings, KratosMultiphysics.Parameters):
+        raise Exception("input is expected to be provided as a Kratos Parameters object")
+
+    solver_settings = custom_settings["solver_settings"]
+    parallelism = custom_settings["problem_data"]["parallel_type"].GetString()
+
+    return CreateSolverByParameters(model, solver_settings, parallelism)
```

## KratosMultiphysics/StructuralMechanicsApplication/auxiliary_methods_adaptative_solvers.py

 * *Ordering differences only*

```diff
@@ -1,37 +1,37 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-
-import KratosMultiphysics.kratos_utilities as kratos_utilities
-if kratos_utilities.CheckIfApplicationsAvailable("MeshingApplication"):
-    import KratosMultiphysics.MeshingApplication as MeshingApplication
-    missing_meshing_dependencies = True
-else:
-    missing_meshing_dependencies = False
-
-def CreateRemeshingProcess(main_model_part, adaptative_remesh_parameters):
-    if main_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE] == 2:
-        remeshing_process = MeshingApplication.MmgProcess2D(main_model_part, adaptative_remesh_parameters["remeshing_parameters"])
-    else:
-        is_surface = False
-        for elem in main_model_part.Elements:
-            geom = elem.GetGeometry()
-            if geom.WorkingSpaceDimension() != geom.LocalSpaceDimension():
-                is_surface = True
-            break
-        if is_surface:
-            remeshing_process = MeshingApplication.MmgProcess3DSurfaces(main_model_part, adaptative_remesh_parameters["remeshing_parameters"])
-        else:
-            remeshing_process = MeshingApplication.MmgProcess3D(main_model_part, adaptative_remesh_parameters["remeshing_parameters"])
-
-    return remeshing_process
-
-def CreateMetricProcess(main_model_part, adaptative_remesh_parameters):
-    if main_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE] == 2:
-        metric_process = MeshingApplication.MetricErrorProcess2D(main_model_part, adaptative_remesh_parameters["metric_error_parameters"])
-    else:
-        metric_process = MeshingApplication.MetricErrorProcess3D(main_model_part, adaptative_remesh_parameters["metric_error_parameters"])
-
-    return metric_process
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+
+import KratosMultiphysics.kratos_utilities as kratos_utilities
+if kratos_utilities.CheckIfApplicationsAvailable("MeshingApplication"):
+    import KratosMultiphysics.MeshingApplication as MeshingApplication
+    missing_meshing_dependencies = True
+else:
+    missing_meshing_dependencies = False
+
+def CreateRemeshingProcess(main_model_part, adaptative_remesh_parameters):
+    if main_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE] == 2:
+        remeshing_process = MeshingApplication.MmgProcess2D(main_model_part, adaptative_remesh_parameters["remeshing_parameters"])
+    else:
+        is_surface = False
+        for elem in main_model_part.Elements:
+            geom = elem.GetGeometry()
+            if geom.WorkingSpaceDimension() != geom.LocalSpaceDimension():
+                is_surface = True
+            break
+        if is_surface:
+            remeshing_process = MeshingApplication.MmgProcess3DSurfaces(main_model_part, adaptative_remesh_parameters["remeshing_parameters"])
+        else:
+            remeshing_process = MeshingApplication.MmgProcess3D(main_model_part, adaptative_remesh_parameters["remeshing_parameters"])
+
+    return remeshing_process
+
+def CreateMetricProcess(main_model_part, adaptative_remesh_parameters):
+    if main_model_part.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE] == 2:
+        metric_process = MeshingApplication.MetricErrorProcess2D(main_model_part, adaptative_remesh_parameters["metric_error_parameters"])
+    else:
+        metric_process = MeshingApplication.MetricErrorProcess3D(main_model_part, adaptative_remesh_parameters["metric_error_parameters"])
+
+    return metric_process
```

## KratosMultiphysics/StructuralMechanicsApplication/check_eigenvalues_process.py

 * *Ordering differences only*

```diff
@@ -1,38 +1,38 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-# Import KratosUnittest
-import KratosMultiphysics.KratosUnittest as KratosUnittest
-
-def Factory(settings, Model):
-    if(type(settings) != KratosMultiphysics.Parameters):
-        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
-    return CheckEigenvaluesProcess(Model, settings["Parameters"])
-
-class CheckEigenvaluesProcess(KratosMultiphysics.Process, KratosUnittest.TestCase):
-    def __init__(self, Model, settings):
-
-        default_settings = KratosMultiphysics.Parameters(
-            """
-            {
-                "help"            :"This process checks the solution obtained in a eigenvalue problem. Can be used to create tests",
-                "model_part_name" : "Structure",
-                "variable_name"   : "EIGENVALUE_VECTOR",
-                "reference_values": "[1.,2.,3.]"
-            }
-            """
-        );
-
-        settings.ValidateAndAssignDefaults(default_settings)
-
-        KratosMultiphysics.Process.__init__(self)
-        self.model_part = Model[settings["model_part_name"].GetString()]
-        self.variable = KratosMultiphysics.KratosGlobals.GetVariable(settings["variable_name"].GetString())
-        self.reference_values = []
-        reference_values = settings["reference_values"].GetString()
-        for ev in reference_values.strip('[]').split(','):
-            self.reference_values.append(float(ev))
-
-    def ExecuteFinalizeSolutionStep(self):
-        current_values = [ev for ev in self.model_part.ProcessInfo[self.variable]]
-        for evs in zip(current_values,self.reference_values):
-            self.assertAlmostEqual(evs[0],evs[1],5)
+# Importing the Kratos Library
+import KratosMultiphysics
+# Import KratosUnittest
+import KratosMultiphysics.KratosUnittest as KratosUnittest
+
+def Factory(settings, Model):
+    if(type(settings) != KratosMultiphysics.Parameters):
+        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
+    return CheckEigenvaluesProcess(Model, settings["Parameters"])
+
+class CheckEigenvaluesProcess(KratosMultiphysics.Process, KratosUnittest.TestCase):
+    def __init__(self, Model, settings):
+
+        default_settings = KratosMultiphysics.Parameters(
+            """
+            {
+                "help"            :"This process checks the solution obtained in a eigenvalue problem. Can be used to create tests",
+                "model_part_name" : "Structure",
+                "variable_name"   : "EIGENVALUE_VECTOR",
+                "reference_values": "[1.,2.,3.]"
+            }
+            """
+        );
+
+        settings.ValidateAndAssignDefaults(default_settings)
+
+        KratosMultiphysics.Process.__init__(self)
+        self.model_part = Model[settings["model_part_name"].GetString()]
+        self.variable = KratosMultiphysics.KratosGlobals.GetVariable(settings["variable_name"].GetString())
+        self.reference_values = []
+        reference_values = settings["reference_values"].GetString()
+        for ev in reference_values.strip('[]').split(','):
+            self.reference_values.append(float(ev))
+
+    def ExecuteFinalizeSolutionStep(self):
+        current_values = [ev for ev in self.model_part.ProcessInfo[self.variable]]
+        for evs in zip(current_values,self.reference_values):
+            self.assertAlmostEqual(evs[0],evs[1],5)
```

## KratosMultiphysics/StructuralMechanicsApplication/convergence_criteria_factory.py

 * *Ordering differences only*

```diff
@@ -1,129 +1,129 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-
-# Convergence criteria class
-class convergence_criterion:
-    def __init__(self, convergence_criterion_parameters):
-        # Note that all the convergence settings are introduced via a Kratos parameters object.
-
-        D_RT = convergence_criterion_parameters["displacement_relative_tolerance"].GetDouble()
-        D_AT = convergence_criterion_parameters["displacement_absolute_tolerance"].GetDouble()
-        R_RT = convergence_criterion_parameters["residual_relative_tolerance"].GetDouble()
-        R_AT = convergence_criterion_parameters["residual_absolute_tolerance"].GetDouble()
-
-        echo_level = convergence_criterion_parameters["echo_level"].GetInt()
-        convergence_crit = convergence_criterion_parameters["convergence_criterion"].GetString()
-
-        if(echo_level >= 1):
-            KratosMultiphysics.Logger.PrintInfo("::[Mechanical Solver]:: ", "CONVERGENCE CRITERION : " +
-                  convergence_criterion_parameters["convergence_criterion"].GetString())
-
-        rotation_dofs = False
-        if(convergence_criterion_parameters.Has("rotation_dofs")):
-            if(convergence_criterion_parameters["rotation_dofs"].GetBool()):
-                rotation_dofs = True
-
-        volumetric_strain_dofs = False
-        if convergence_criterion_parameters.Has("volumetric_strain_dofs"):
-            if convergence_criterion_parameters["volumetric_strain_dofs"].GetBool():
-                volumetric_strain_dofs = True
-
-        # Convergence criteria if there are rotation DOFs in the problem
-        if(rotation_dofs):
-            if(convergence_crit == "displacement_criterion"):
-                self.mechanical_convergence_criterion = KratosMultiphysics.MixedGenericCriteria(
-                    [(KratosMultiphysics.DISPLACEMENT, D_RT, D_AT),
-                    (KratosMultiphysics.ROTATION, D_RT, D_AT)])
-                self.mechanical_convergence_criterion.SetEchoLevel(echo_level)
-
-            elif(convergence_crit == "residual_criterion"):
-                self.mechanical_convergence_criterion = StructuralMechanicsApplication.ResidualDisplacementAndOtherDoFCriteria(R_RT, R_AT)
-                self.mechanical_convergence_criterion.SetEchoLevel(echo_level)
-
-            elif(convergence_crit == "and_criterion"):
-                Displacement = KratosMultiphysics.MixedGenericCriteria(
-                    [(KratosMultiphysics.DISPLACEMENT, D_RT, D_AT),
-                    (KratosMultiphysics.ROTATION, D_RT, D_AT)])
-                Displacement.SetEchoLevel(echo_level)
-                Residual = StructuralMechanicsApplication.ResidualDisplacementAndOtherDoFCriteria(R_RT, R_AT)
-                Residual.SetEchoLevel(echo_level)
-                self.mechanical_convergence_criterion = KratosMultiphysics.AndCriteria(Residual, Displacement)
-
-            elif(convergence_crit == "or_criterion"):
-                Displacement = KratosMultiphysics.MixedGenericCriteria(
-                    [(KratosMultiphysics.DISPLACEMENT, D_RT, D_AT),
-                    (KratosMultiphysics.ROTATION, D_RT, D_AT)])
-                Displacement.SetEchoLevel(echo_level)
-                Residual = StructuralMechanicsApplication.ResidualDisplacementAndOtherDoFCriteria(R_RT, R_AT)
-                Residual.SetEchoLevel(echo_level)
-                self.mechanical_convergence_criterion = KratosMultiphysics.OrCriteria(Residual, Displacement)
-            else:
-                err_msg =  "The requested convergence criterion \"" + convergence_crit + "\" is not available!\n"
-                err_msg += "Available options are: \"displacement_criterion\", \"residual_criterion\", \"and_criterion\", \"or_criterion\""
-                raise Exception(err_msg)
-
-        # Convergence criteria if there are volumetric strain DOFs in the problem
-        elif(volumetric_strain_dofs):
-            other_dof_name = "VOLUMETRIC_STRAIN"
-            if(convergence_crit == "displacement_criterion"):
-                self.mechanical_convergence_criterion = KratosMultiphysics.MixedGenericCriteria(
-                    [(KratosMultiphysics.DISPLACEMENT, D_RT, D_AT),
-                    (KratosMultiphysics.VOLUMETRIC_STRAIN, D_RT, D_AT)])
-                self.mechanical_convergence_criterion.SetEchoLevel(echo_level)
-
-            elif(convergence_crit == "residual_criterion"):
-                self.mechanical_convergence_criterion = StructuralMechanicsApplication.ResidualDisplacementAndOtherDoFCriteria(R_RT, R_AT, other_dof_name)
-                self.mechanical_convergence_criterion.SetEchoLevel(echo_level)
-
-            elif(convergence_crit == "and_criterion"):
-                Displacement = KratosMultiphysics.MixedGenericCriteria(
-                    [(KratosMultiphysics.DISPLACEMENT, D_RT, D_AT),
-                    (KratosMultiphysics.VOLUMETRIC_STRAIN, D_RT, D_AT)])
-                Displacement.SetEchoLevel(echo_level)
-                Residual = StructuralMechanicsApplication.ResidualDisplacementAndOtherDoFCriteria(R_RT, R_AT, other_dof_name)
-                Residual.SetEchoLevel(echo_level)
-                self.mechanical_convergence_criterion = KratosMultiphysics.AndCriteria(Residual, Displacement)
-
-            elif(convergence_crit == "or_criterion"):
-                Displacement = KratosMultiphysics.MixedGenericCriteria(
-                    [(KratosMultiphysics.DISPLACEMENT, D_RT, D_AT),
-                    (KratosMultiphysics.VOLUMETRIC_STRAIN, D_RT, D_AT)])
-                Displacement.SetEchoLevel(echo_level)
-                Residual = StructuralMechanicsApplication.ResidualDisplacementAndOtherDoFCriteria(R_RT, R_AT, other_dof_name)
-                Residual.SetEchoLevel(echo_level)
-                self.mechanical_convergence_criterion = KratosMultiphysics.OrCriteria(Residual, Displacement)
-            else:
-                err_msg =  "The requested convergence criterion \"" + convergence_crit + "\" is not available!\n"
-                err_msg += "Available options are: \"displacement_criterion\", \"residual_criterion\", \"and_criterion\", \"or_criterion\""
-                raise Exception(err_msg)
-
-        # Convergence criteria without rotation DOFs
-        else:
-            if(convergence_crit == "displacement_criterion"):
-                self.mechanical_convergence_criterion = KratosMultiphysics.DisplacementCriteria(D_RT, D_AT)
-                self.mechanical_convergence_criterion.SetEchoLevel(echo_level)
-
-            elif(convergence_crit == "residual_criterion"):
-                self.mechanical_convergence_criterion = KratosMultiphysics.ResidualCriteria(R_RT, R_AT)
-                self.mechanical_convergence_criterion.SetEchoLevel(echo_level)
-
-            elif(convergence_crit == "and_criterion"):
-                Displacement = KratosMultiphysics.DisplacementCriteria(D_RT, D_AT)
-                Displacement.SetEchoLevel(echo_level)
-                Residual = KratosMultiphysics.ResidualCriteria(R_RT, R_AT)
-                Residual.SetEchoLevel(echo_level)
-                self.mechanical_convergence_criterion = KratosMultiphysics.AndCriteria(Residual, Displacement)
-
-            elif(convergence_crit == "or_criterion"):
-                Displacement = KratosMultiphysics.DisplacementCriteria(D_RT, D_AT)
-                Displacement.SetEchoLevel(echo_level)
-                Residual = KratosMultiphysics.ResidualCriteria(R_RT, R_AT)
-                Residual.SetEchoLevel(echo_level)
-                self.mechanical_convergence_criterion = KratosMultiphysics.OrCriteria(Residual, Displacement)
-            else:
-                err_msg =  "The requested convergence criterion \"" + convergence_crit + "\" is not available!\n"
-                err_msg += "Available options are: \"displacement_criterion\", \"residual_criterion\", \"and_criterion\", \"or_criterion\""
-                raise Exception(err_msg)
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+
+# Convergence criteria class
+class convergence_criterion:
+    def __init__(self, convergence_criterion_parameters):
+        # Note that all the convergence settings are introduced via a Kratos parameters object.
+
+        D_RT = convergence_criterion_parameters["displacement_relative_tolerance"].GetDouble()
+        D_AT = convergence_criterion_parameters["displacement_absolute_tolerance"].GetDouble()
+        R_RT = convergence_criterion_parameters["residual_relative_tolerance"].GetDouble()
+        R_AT = convergence_criterion_parameters["residual_absolute_tolerance"].GetDouble()
+
+        echo_level = convergence_criterion_parameters["echo_level"].GetInt()
+        convergence_crit = convergence_criterion_parameters["convergence_criterion"].GetString()
+
+        if(echo_level >= 1):
+            KratosMultiphysics.Logger.PrintInfo("::[Mechanical Solver]:: ", "CONVERGENCE CRITERION : " +
+                  convergence_criterion_parameters["convergence_criterion"].GetString())
+
+        rotation_dofs = False
+        if(convergence_criterion_parameters.Has("rotation_dofs")):
+            if(convergence_criterion_parameters["rotation_dofs"].GetBool()):
+                rotation_dofs = True
+
+        volumetric_strain_dofs = False
+        if convergence_criterion_parameters.Has("volumetric_strain_dofs"):
+            if convergence_criterion_parameters["volumetric_strain_dofs"].GetBool():
+                volumetric_strain_dofs = True
+
+        # Convergence criteria if there are rotation DOFs in the problem
+        if(rotation_dofs):
+            if(convergence_crit == "displacement_criterion"):
+                self.mechanical_convergence_criterion = KratosMultiphysics.MixedGenericCriteria(
+                    [(KratosMultiphysics.DISPLACEMENT, D_RT, D_AT),
+                    (KratosMultiphysics.ROTATION, D_RT, D_AT)])
+                self.mechanical_convergence_criterion.SetEchoLevel(echo_level)
+
+            elif(convergence_crit == "residual_criterion"):
+                self.mechanical_convergence_criterion = StructuralMechanicsApplication.ResidualDisplacementAndOtherDoFCriteria(R_RT, R_AT)
+                self.mechanical_convergence_criterion.SetEchoLevel(echo_level)
+
+            elif(convergence_crit == "and_criterion"):
+                Displacement = KratosMultiphysics.MixedGenericCriteria(
+                    [(KratosMultiphysics.DISPLACEMENT, D_RT, D_AT),
+                    (KratosMultiphysics.ROTATION, D_RT, D_AT)])
+                Displacement.SetEchoLevel(echo_level)
+                Residual = StructuralMechanicsApplication.ResidualDisplacementAndOtherDoFCriteria(R_RT, R_AT)
+                Residual.SetEchoLevel(echo_level)
+                self.mechanical_convergence_criterion = KratosMultiphysics.AndCriteria(Residual, Displacement)
+
+            elif(convergence_crit == "or_criterion"):
+                Displacement = KratosMultiphysics.MixedGenericCriteria(
+                    [(KratosMultiphysics.DISPLACEMENT, D_RT, D_AT),
+                    (KratosMultiphysics.ROTATION, D_RT, D_AT)])
+                Displacement.SetEchoLevel(echo_level)
+                Residual = StructuralMechanicsApplication.ResidualDisplacementAndOtherDoFCriteria(R_RT, R_AT)
+                Residual.SetEchoLevel(echo_level)
+                self.mechanical_convergence_criterion = KratosMultiphysics.OrCriteria(Residual, Displacement)
+            else:
+                err_msg =  "The requested convergence criterion \"" + convergence_crit + "\" is not available!\n"
+                err_msg += "Available options are: \"displacement_criterion\", \"residual_criterion\", \"and_criterion\", \"or_criterion\""
+                raise Exception(err_msg)
+
+        # Convergence criteria if there are volumetric strain DOFs in the problem
+        elif(volumetric_strain_dofs):
+            other_dof_name = "VOLUMETRIC_STRAIN"
+            if(convergence_crit == "displacement_criterion"):
+                self.mechanical_convergence_criterion = KratosMultiphysics.MixedGenericCriteria(
+                    [(KratosMultiphysics.DISPLACEMENT, D_RT, D_AT),
+                    (KratosMultiphysics.VOLUMETRIC_STRAIN, D_RT, D_AT)])
+                self.mechanical_convergence_criterion.SetEchoLevel(echo_level)
+
+            elif(convergence_crit == "residual_criterion"):
+                self.mechanical_convergence_criterion = StructuralMechanicsApplication.ResidualDisplacementAndOtherDoFCriteria(R_RT, R_AT, other_dof_name)
+                self.mechanical_convergence_criterion.SetEchoLevel(echo_level)
+
+            elif(convergence_crit == "and_criterion"):
+                Displacement = KratosMultiphysics.MixedGenericCriteria(
+                    [(KratosMultiphysics.DISPLACEMENT, D_RT, D_AT),
+                    (KratosMultiphysics.VOLUMETRIC_STRAIN, D_RT, D_AT)])
+                Displacement.SetEchoLevel(echo_level)
+                Residual = StructuralMechanicsApplication.ResidualDisplacementAndOtherDoFCriteria(R_RT, R_AT, other_dof_name)
+                Residual.SetEchoLevel(echo_level)
+                self.mechanical_convergence_criterion = KratosMultiphysics.AndCriteria(Residual, Displacement)
+
+            elif(convergence_crit == "or_criterion"):
+                Displacement = KratosMultiphysics.MixedGenericCriteria(
+                    [(KratosMultiphysics.DISPLACEMENT, D_RT, D_AT),
+                    (KratosMultiphysics.VOLUMETRIC_STRAIN, D_RT, D_AT)])
+                Displacement.SetEchoLevel(echo_level)
+                Residual = StructuralMechanicsApplication.ResidualDisplacementAndOtherDoFCriteria(R_RT, R_AT, other_dof_name)
+                Residual.SetEchoLevel(echo_level)
+                self.mechanical_convergence_criterion = KratosMultiphysics.OrCriteria(Residual, Displacement)
+            else:
+                err_msg =  "The requested convergence criterion \"" + convergence_crit + "\" is not available!\n"
+                err_msg += "Available options are: \"displacement_criterion\", \"residual_criterion\", \"and_criterion\", \"or_criterion\""
+                raise Exception(err_msg)
+
+        # Convergence criteria without rotation DOFs
+        else:
+            if(convergence_crit == "displacement_criterion"):
+                self.mechanical_convergence_criterion = KratosMultiphysics.DisplacementCriteria(D_RT, D_AT)
+                self.mechanical_convergence_criterion.SetEchoLevel(echo_level)
+
+            elif(convergence_crit == "residual_criterion"):
+                self.mechanical_convergence_criterion = KratosMultiphysics.ResidualCriteria(R_RT, R_AT)
+                self.mechanical_convergence_criterion.SetEchoLevel(echo_level)
+
+            elif(convergence_crit == "and_criterion"):
+                Displacement = KratosMultiphysics.DisplacementCriteria(D_RT, D_AT)
+                Displacement.SetEchoLevel(echo_level)
+                Residual = KratosMultiphysics.ResidualCriteria(R_RT, R_AT)
+                Residual.SetEchoLevel(echo_level)
+                self.mechanical_convergence_criterion = KratosMultiphysics.AndCriteria(Residual, Displacement)
+
+            elif(convergence_crit == "or_criterion"):
+                Displacement = KratosMultiphysics.DisplacementCriteria(D_RT, D_AT)
+                Displacement.SetEchoLevel(echo_level)
+                Residual = KratosMultiphysics.ResidualCriteria(R_RT, R_AT)
+                Residual.SetEchoLevel(echo_level)
+                self.mechanical_convergence_criterion = KratosMultiphysics.OrCriteria(Residual, Displacement)
+            else:
+                err_msg =  "The requested convergence criterion \"" + convergence_crit + "\" is not available!\n"
+                err_msg += "Available options are: \"displacement_criterion\", \"residual_criterion\", \"and_criterion\", \"or_criterion\""
+                raise Exception(err_msg)
```

## KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_custom_scipy_base_solver.py

 * *Ordering differences only*

```diff
@@ -1,192 +1,192 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-
-# Import base class file
-from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
-
-# Import scipy modules
-import KratosMultiphysics.scipy_conversion_tools
-from scipy.sparse.linalg import eigsh
-
-def CreateSolver(main_model_part, custom_settings):
-    return CustomScipyBaseSolver(main_model_part, custom_settings)
-
-class CustomScipyBaseSolver(MechanicalSolver):
-    """The structural mechanics custom scipy base solver.
-
-    This class creates the mechanical solvers to provide mass and stiffness matrices as scipy matrices.
-
-    Derived class must override the function SolveSolutionStep. In there the Mass and Stiffness matrices
-    can be obtained as scipy matrices.
-    The computation of the eigenvalue problem in this implementation is only an example how this solver is to be used.
-
-    See structural_mechanics_solver.py for more information.
-    """
-    def __init__(self, main_model_part, custom_settings):
-        # Construct the base solver.
-        super().__init__(main_model_part, custom_settings)
-        KratosMultiphysics.Logger.PrintInfo("::[CustomScipyBaseSolver]:: ", "Construction finished")
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KratosMultiphysics.Parameters("""{
-            "scheme_type"         : "dynamic"
-        }""")
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
-
-    #### Private functions ####
-    def _CreateScheme(self):
-        """Create the scheme for the scipy solver.
-
-        The scheme determines the mass and stiffness matrices
-        """
-        scheme_type = self.settings["scheme_type"].GetString()
-        if scheme_type == "dynamic":
-            solution_scheme = StructuralMechanicsApplication.EigensolverDynamicScheme()
-        else: # here e.g. a stability scheme could be added
-            err_msg =  "The requested scheme type \"" + scheme_type + "\" is not available!\n"
-            err_msg += "Available options are: \"dynamic\""
-            raise Exception(err_msg)
-
-        return solution_scheme
-
-    def _CreateLinearSolver(self):
-        ''' Linear solver will not be used. But eventually the solution strategy calls the solver's clear function.
-        To avoid crashing linear solver is provided here'''
-        return KratosMultiphysics.LinearSolver()
-
-    def _CreateSolutionStrategy(self):
-        if self.settings["builder_and_solver_settings"]["use_block_builder"].GetBool():
-            warn_msg = "In case an eigenvalue problem is computed an elimantion builder shall be used to ensure boundary conditions are applied correctly!"
-            KratosMultiphysics.Logger.PrintWarning("CustomScipyBaseSolver", warn_msg)
-
-        eigen_scheme = self._GetScheme() # The scheme defines the matrices
-        computing_model_part = self.GetComputingModelPart()
-        builder_and_solver = self._GetBuilderAndSolver()
-
-        return KratosMultiphysics.ResidualBasedLinearStrategy(computing_model_part,
-                                                              eigen_scheme,
-                                                              builder_and_solver,
-                                                              False,
-                                                              False,
-                                                              False,
-                                                              False )
-
-    def _MassMatrixComputation(self):
-        space = KratosMultiphysics.UblasSparseSpace()
-        self.GetComputingModelPart().ProcessInfo.SetValue(StructuralMechanicsApplication.BUILD_LEVEL,1) #Mass Matrix
-        scheme = self._GetSolutionStrategy().GetScheme()
-
-        aux = self._GetSolutionStrategy().GetSystemMatrix()
-        space.SetToZeroMatrix(aux)
-
-        # Create dummy vectors
-        b = space.CreateEmptyVectorPointer()
-        space.ResizeVector( b, space.Size1(aux) )
-        space.SetToZeroVector(b)
-
-        xD = space.CreateEmptyVectorPointer()
-        space.ResizeVector( xD, space.Size1(aux) )
-        space.SetToZeroVector(xD)
-
-        # Build matrix
-        builder_and_solver = self._GetBuilderAndSolver()
-        builder_and_solver.Build(scheme, self.GetComputingModelPart(), aux, b)
-        # Apply Constraints
-        builder_and_solver.ApplyConstraints(scheme, self.GetComputingModelPart(), aux, b)
-        # Apply Boundary Conditions
-        builder_and_solver.ApplyDirichletConditions(scheme, self.GetComputingModelPart(), aux, xD, b)
-        # Convert Mass matrix to scipy
-        M = KratosMultiphysics.scipy_conversion_tools.to_csr(aux)
-
-        return M
-
-    def _StiffnessMatrixComputation(self):
-        space = KratosMultiphysics.UblasSparseSpace()
-        self.GetComputingModelPart().ProcessInfo.SetValue(StructuralMechanicsApplication.BUILD_LEVEL,2) #Stiffness Matrix
-        scheme = self._GetSolutionStrategy().GetScheme()
-
-        aux = self._GetSolutionStrategy().GetSystemMatrix()
-        space.SetToZeroMatrix(aux)
-
-        # Create dummy vectors
-        b = space.CreateEmptyVectorPointer()
-        space.ResizeVector( b, space.Size1(aux) )
-        space.SetToZeroVector(b)
-
-        xD = space.CreateEmptyVectorPointer()
-        space.ResizeVector( xD, space.Size1(aux) )
-        space.SetToZeroVector(xD)
-
-        # Build matrix
-        builder_and_solver = self._GetBuilderAndSolver()
-        builder_and_solver.Build(scheme, self.GetComputingModelPart(), aux, b)
-        # Apply constraints
-        builder_and_solver.ApplyConstraints(scheme, self.GetComputingModelPart(), aux, b)
-        # Apply boundary conditions
-        builder_and_solver.ApplyDirichletConditions(scheme, self.GetComputingModelPart(), aux, xD, b)
-        # Convert stiffness matrix to scipy
-        K = KratosMultiphysics.scipy_conversion_tools.to_csr(aux)
-
-        return K
-
-    def _AssignVariables(self, eigenvalues, eigenvectors):
-        num_eigenvalues = eigenvalues.size
-        # Store eigenvalues in process info
-        eigenvalue_vector = self.GetComputingModelPart().ProcessInfo.GetValue(StructuralMechanicsApplication.EIGENVALUE_VECTOR)
-        eigenvalue_vector.Resize(num_eigenvalues)
-        for i in range(num_eigenvalues):
-            eigenvalue_vector[i] = eigenvalues[i]
-        self.GetComputingModelPart().ProcessInfo.SetValue(StructuralMechanicsApplication.EIGENVALUE_VECTOR, eigenvalue_vector)
-
-        # Store eigenvectors in nodes
-        for node in self.GetComputingModelPart().Nodes:
-            node_eigenvectors = node.GetValue(StructuralMechanicsApplication.EIGENVECTOR_MATRIX)
-            if self.settings["rotation_dofs"].GetBool() == True:
-                dofs = [node.GetDof(KratosMultiphysics.ROTATION_X),
-                        node.GetDof(KratosMultiphysics.ROTATION_Y),
-                        node.GetDof(KratosMultiphysics.ROTATION_Z),
-                        node.GetDof(KratosMultiphysics.DISPLACEMENT_X),
-                        node.GetDof(KratosMultiphysics.DISPLACEMENT_Y),
-                        node.GetDof(KratosMultiphysics.DISPLACEMENT_Z)]
-
-                node_eigenvectors.Resize(num_eigenvalues, 6 )
-            else:
-                dofs = [node.GetDof(KratosMultiphysics.DISPLACEMENT_X),
-                        node.GetDof(KratosMultiphysics.DISPLACEMENT_Y),
-                        node.GetDof(KratosMultiphysics.DISPLACEMENT_Z)]
-                node_eigenvectors.Resize(num_eigenvalues, 3 )
-
-            # Fill the eigenvector matrix
-            for i in range(num_eigenvalues):
-                j = -1
-                for dof in dofs:
-                    j = j + 1
-                    if dof.IsFixed():
-                        node_eigenvectors[i,j] = 0.0
-                    else:
-                        node_eigenvectors[i,j] = eigenvectors[dof.EquationId,i]
-            node.SetValue(StructuralMechanicsApplication.EIGENVECTOR_MATRIX, node_eigenvectors)
-
-    def SolveSolutionStep(self):
-        """This method must be overriden in derived class.
-
-        The computation of the egenvalue problem is only an example how this solver is to be used.
-        """
-        ## Obtain scipy matrices
-        M = self._MassMatrixComputation()
-        K = self._StiffnessMatrixComputation()
-
-        ## Compute eigenvalues and eigenvectors
-        tolerance = 1e-6
-        iteration = M.size*100
-        vals, vecs = eigsh(K, 5, M, which='SM', tol=tolerance, maxiter = iteration)
-
-        ## Assign results to Kratos variables
-        self._AssignVariables(vals,vecs)
-
-        return True #converged
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+
+# Import base class file
+from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
+
+# Import scipy modules
+import KratosMultiphysics.scipy_conversion_tools
+from scipy.sparse.linalg import eigsh
+
+def CreateSolver(main_model_part, custom_settings):
+    return CustomScipyBaseSolver(main_model_part, custom_settings)
+
+class CustomScipyBaseSolver(MechanicalSolver):
+    """The structural mechanics custom scipy base solver.
+
+    This class creates the mechanical solvers to provide mass and stiffness matrices as scipy matrices.
+
+    Derived class must override the function SolveSolutionStep. In there the Mass and Stiffness matrices
+    can be obtained as scipy matrices.
+    The computation of the eigenvalue problem in this implementation is only an example how this solver is to be used.
+
+    See structural_mechanics_solver.py for more information.
+    """
+    def __init__(self, main_model_part, custom_settings):
+        # Construct the base solver.
+        super().__init__(main_model_part, custom_settings)
+        KratosMultiphysics.Logger.PrintInfo("::[CustomScipyBaseSolver]:: ", "Construction finished")
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KratosMultiphysics.Parameters("""{
+            "scheme_type"         : "dynamic"
+        }""")
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
+
+    #### Private functions ####
+    def _CreateScheme(self):
+        """Create the scheme for the scipy solver.
+
+        The scheme determines the mass and stiffness matrices
+        """
+        scheme_type = self.settings["scheme_type"].GetString()
+        if scheme_type == "dynamic":
+            solution_scheme = StructuralMechanicsApplication.EigensolverDynamicScheme()
+        else: # here e.g. a stability scheme could be added
+            err_msg =  "The requested scheme type \"" + scheme_type + "\" is not available!\n"
+            err_msg += "Available options are: \"dynamic\""
+            raise Exception(err_msg)
+
+        return solution_scheme
+
+    def _CreateLinearSolver(self):
+        ''' Linear solver will not be used. But eventually the solution strategy calls the solver's clear function.
+        To avoid crashing linear solver is provided here'''
+        return KratosMultiphysics.LinearSolver()
+
+    def _CreateSolutionStrategy(self):
+        if self.settings["builder_and_solver_settings"]["use_block_builder"].GetBool():
+            warn_msg = "In case an eigenvalue problem is computed an elimantion builder shall be used to ensure boundary conditions are applied correctly!"
+            KratosMultiphysics.Logger.PrintWarning("CustomScipyBaseSolver", warn_msg)
+
+        eigen_scheme = self._GetScheme() # The scheme defines the matrices
+        computing_model_part = self.GetComputingModelPart()
+        builder_and_solver = self._GetBuilderAndSolver()
+
+        return KratosMultiphysics.ResidualBasedLinearStrategy(computing_model_part,
+                                                              eigen_scheme,
+                                                              builder_and_solver,
+                                                              False,
+                                                              False,
+                                                              False,
+                                                              False )
+
+    def _MassMatrixComputation(self):
+        space = KratosMultiphysics.UblasSparseSpace()
+        self.GetComputingModelPart().ProcessInfo.SetValue(StructuralMechanicsApplication.BUILD_LEVEL,1) #Mass Matrix
+        scheme = self._GetSolutionStrategy().GetScheme()
+
+        aux = self._GetSolutionStrategy().GetSystemMatrix()
+        space.SetToZeroMatrix(aux)
+
+        # Create dummy vectors
+        b = space.CreateEmptyVectorPointer()
+        space.ResizeVector( b, space.Size1(aux) )
+        space.SetToZeroVector(b)
+
+        xD = space.CreateEmptyVectorPointer()
+        space.ResizeVector( xD, space.Size1(aux) )
+        space.SetToZeroVector(xD)
+
+        # Build matrix
+        builder_and_solver = self._GetBuilderAndSolver()
+        builder_and_solver.Build(scheme, self.GetComputingModelPart(), aux, b)
+        # Apply Constraints
+        builder_and_solver.ApplyConstraints(scheme, self.GetComputingModelPart(), aux, b)
+        # Apply Boundary Conditions
+        builder_and_solver.ApplyDirichletConditions(scheme, self.GetComputingModelPart(), aux, xD, b)
+        # Convert Mass matrix to scipy
+        M = KratosMultiphysics.scipy_conversion_tools.to_csr(aux)
+
+        return M
+
+    def _StiffnessMatrixComputation(self):
+        space = KratosMultiphysics.UblasSparseSpace()
+        self.GetComputingModelPart().ProcessInfo.SetValue(StructuralMechanicsApplication.BUILD_LEVEL,2) #Stiffness Matrix
+        scheme = self._GetSolutionStrategy().GetScheme()
+
+        aux = self._GetSolutionStrategy().GetSystemMatrix()
+        space.SetToZeroMatrix(aux)
+
+        # Create dummy vectors
+        b = space.CreateEmptyVectorPointer()
+        space.ResizeVector( b, space.Size1(aux) )
+        space.SetToZeroVector(b)
+
+        xD = space.CreateEmptyVectorPointer()
+        space.ResizeVector( xD, space.Size1(aux) )
+        space.SetToZeroVector(xD)
+
+        # Build matrix
+        builder_and_solver = self._GetBuilderAndSolver()
+        builder_and_solver.Build(scheme, self.GetComputingModelPart(), aux, b)
+        # Apply constraints
+        builder_and_solver.ApplyConstraints(scheme, self.GetComputingModelPart(), aux, b)
+        # Apply boundary conditions
+        builder_and_solver.ApplyDirichletConditions(scheme, self.GetComputingModelPart(), aux, xD, b)
+        # Convert stiffness matrix to scipy
+        K = KratosMultiphysics.scipy_conversion_tools.to_csr(aux)
+
+        return K
+
+    def _AssignVariables(self, eigenvalues, eigenvectors):
+        num_eigenvalues = eigenvalues.size
+        # Store eigenvalues in process info
+        eigenvalue_vector = self.GetComputingModelPart().ProcessInfo.GetValue(StructuralMechanicsApplication.EIGENVALUE_VECTOR)
+        eigenvalue_vector.Resize(num_eigenvalues)
+        for i in range(num_eigenvalues):
+            eigenvalue_vector[i] = eigenvalues[i]
+        self.GetComputingModelPart().ProcessInfo.SetValue(StructuralMechanicsApplication.EIGENVALUE_VECTOR, eigenvalue_vector)
+
+        # Store eigenvectors in nodes
+        for node in self.GetComputingModelPart().Nodes:
+            node_eigenvectors = node.GetValue(StructuralMechanicsApplication.EIGENVECTOR_MATRIX)
+            if self.settings["rotation_dofs"].GetBool() == True:
+                dofs = [node.GetDof(KratosMultiphysics.ROTATION_X),
+                        node.GetDof(KratosMultiphysics.ROTATION_Y),
+                        node.GetDof(KratosMultiphysics.ROTATION_Z),
+                        node.GetDof(KratosMultiphysics.DISPLACEMENT_X),
+                        node.GetDof(KratosMultiphysics.DISPLACEMENT_Y),
+                        node.GetDof(KratosMultiphysics.DISPLACEMENT_Z)]
+
+                node_eigenvectors.Resize(num_eigenvalues, 6 )
+            else:
+                dofs = [node.GetDof(KratosMultiphysics.DISPLACEMENT_X),
+                        node.GetDof(KratosMultiphysics.DISPLACEMENT_Y),
+                        node.GetDof(KratosMultiphysics.DISPLACEMENT_Z)]
+                node_eigenvectors.Resize(num_eigenvalues, 3 )
+
+            # Fill the eigenvector matrix
+            for i in range(num_eigenvalues):
+                j = -1
+                for dof in dofs:
+                    j = j + 1
+                    if dof.IsFixed():
+                        node_eigenvectors[i,j] = 0.0
+                    else:
+                        node_eigenvectors[i,j] = eigenvectors[dof.EquationId,i]
+            node.SetValue(StructuralMechanicsApplication.EIGENVECTOR_MATRIX, node_eigenvectors)
+
+    def SolveSolutionStep(self):
+        """This method must be overriden in derived class.
+
+        The computation of the egenvalue problem is only an example how this solver is to be used.
+        """
+        ## Obtain scipy matrices
+        M = self._MassMatrixComputation()
+        K = self._StiffnessMatrixComputation()
+
+        ## Compute eigenvalues and eigenvectors
+        tolerance = 1e-6
+        iteration = M.size*100
+        vals, vecs = eigsh(K, 5, M, which='SM', tol=tolerance, maxiter = iteration)
+
+        ## Assign results to Kratos variables
+        self._AssignVariables(vals,vecs)
+
+        return True #converged
```

## KratosMultiphysics/StructuralMechanicsApplication/set_cylindrical_local_axes_process.py

 * *Ordering differences only*

```diff
@@ -1,28 +1,28 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-import KratosMultiphysics.StructuralMechanicsApplication as SMA
-from KratosMultiphysics import Logger
-
-
-def Factory(settings, Model):
-    if not isinstance(settings, KM.Parameters):
-        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
-
-    default_settings = KM.Parameters(
-        """{
-            "model_part_name"               : "set_model_part_name",
-            "cylindrical_generatrix_axis"   : [0.0,0.0,1.0],
-            "cylindrical_generatrix_point"  : [0.0,0.0,0.0],
-            "update_at_each_step"           : false
-        }""")
-    process_settings = settings["Parameters"]
-    process_settings.ValidateAndAssignDefaults(default_settings)
-    computing_model_part = Model[process_settings["model_part_name"].GetString()]
-
-    Logger.PrintInfo("SetCylindricalLocalAxesProcess:: ","Setting the oriented local axes...")
-    process_settings.RemoveValue("model_part_name")
-    return SMA.SetCylindricalLocalAxesProcess(computing_model_part, process_settings)
-
-
-
-
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+import KratosMultiphysics.StructuralMechanicsApplication as SMA
+from KratosMultiphysics import Logger
+
+
+def Factory(settings, Model):
+    if not isinstance(settings, KM.Parameters):
+        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
+
+    default_settings = KM.Parameters(
+        """{
+            "model_part_name"               : "set_model_part_name",
+            "cylindrical_generatrix_axis"   : [0.0,0.0,1.0],
+            "cylindrical_generatrix_point"  : [0.0,0.0,0.0],
+            "update_at_each_step"           : false
+        }""")
+    process_settings = settings["Parameters"]
+    process_settings.ValidateAndAssignDefaults(default_settings)
+    computing_model_part = Model[process_settings["model_part_name"].GetString()]
+
+    Logger.PrintInfo("SetCylindricalLocalAxesProcess:: ","Setting the oriented local axes...")
+    process_settings.RemoveValue("model_part_name")
+    return SMA.SetCylindricalLocalAxesProcess(computing_model_part, process_settings)
+
+
+
+
```

## KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_explicit_dynamic_solver.py

 * *Ordering differences only*

```diff
@@ -1,129 +1,129 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-
-# Import base class file
-from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
-
-def CreateSolver(model, custom_settings):
-    return ExplicitMechanicalSolver(model, custom_settings)
-
-class ExplicitMechanicalSolver(MechanicalSolver):
-    """The structural mechanics explicit dynamic solver.
-
-    This class creates the mechanical solvers for explicit dynamic analysis.
-
-    See structural_mechanics_solver.py for more information.
-    """
-    def __init__(self, model, custom_settings):
-        # Construct the base solver.
-        super().__init__(model, custom_settings)
-        # Lumped mass-matrix is necessary for explicit analysis
-        self.main_model_part.ProcessInfo[KratosMultiphysics.COMPUTE_LUMPED_MASS_MATRIX] = True
-        self.delta_time_refresh_counter = self.settings["delta_time_refresh"].GetInt()
-        KratosMultiphysics.Logger.PrintInfo("::[ExplicitMechanicalSolver]:: Construction finished")
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KratosMultiphysics.Parameters("""{
-            "time_integration_method"    : "explicit",
-            "scheme_type"                : "central_differences",
-            "time_step_prediction_level" : 0,
-            "delta_time_refresh"         : 1000,
-            "max_delta_time"             : 1.0e0,
-            "fraction_delta_time"        : 0.333333333333333333333333333333333333,
-            "rayleigh_alpha"             : 0.0,
-            "rayleigh_beta"              : 0.0
-        }""")
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
-
-    def AddVariables(self):
-        super().AddVariables()
-        self._add_dynamic_variables()
-
-        scheme_type = self.settings["scheme_type"].GetString()
-        if scheme_type == "central_differences":
-            self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.MIDDLE_VELOCITY)
-            if self.settings["rotation_dofs"].GetBool():
-                self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.MIDDLE_ANGULAR_VELOCITY)
-        if scheme_type == "multi_stage":
-            self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.FRACTIONAL_ACCELERATION)
-            if self.settings["rotation_dofs"].GetBool():
-                self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.FRACTIONAL_ANGULAR_ACCELERATION)
-
-        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.NODAL_MASS)
-        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.FORCE_RESIDUAL)
-        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.RESIDUAL_VECTOR)
-
-        if self.settings["rotation_dofs"].GetBool():
-            self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.NODAL_INERTIA)
-            self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.MOMENT_RESIDUAL)
-
-        KratosMultiphysics.Logger.PrintInfo("::[ExplicitMechanicalSolver]:: Variables ADDED")
-
-    def AddDofs(self):
-        super().AddDofs()
-        self._add_dynamic_dofs()
-        KratosMultiphysics.Logger.PrintInfo("::[ExplicitMechanicalSolver]:: DOF's ADDED")
-
-    def ComputeDeltaTime(self):
-        if self.settings["time_step_prediction_level"].GetInt() > 1:
-            if self.delta_time_refresh_counter >= self.settings["delta_time_refresh"].GetInt():
-                self.delta_time = StructuralMechanicsApplication.CalculateDeltaTime(self.GetComputingModelPart(), self.delta_time_settings)
-                self.delta_time_refresh_counter = 0
-            else:
-                self.delta_time_refresh_counter += 1
-        return self.delta_time
-
-    def Initialize(self):
-        # Using the base Initialize
-        super().Initialize()
-
-        # Initilize delta_time
-        self.delta_time_settings = KratosMultiphysics.Parameters("""{}""")
-        self.delta_time_settings.AddValue("time_step_prediction_level", self.settings["time_step_prediction_level"])
-        self.delta_time_settings.AddValue("max_delta_time", self.settings["max_delta_time"])
-        if self.settings["time_step_prediction_level"].GetInt() > 0:
-            self.delta_time = StructuralMechanicsApplication.CalculateDeltaTime(self.GetComputingModelPart(), self.delta_time_settings)
-        else:
-            self.delta_time = self.settings["time_stepping"]["time_step"].GetDouble()
-
-    #### Specific internal functions ####
-    def _CreateScheme(self):
-        scheme_type = self.settings["scheme_type"].GetString()
-
-        # Setting the Rayleigh damping parameters
-        process_info = self.main_model_part.ProcessInfo
-        process_info[StructuralMechanicsApplication.RAYLEIGH_ALPHA] = self.settings["rayleigh_alpha"].GetDouble()
-        process_info[StructuralMechanicsApplication.RAYLEIGH_BETA] = self.settings["rayleigh_beta"].GetDouble()
-
-        # Setting the time integration schemes
-        if scheme_type == "central_differences":
-            mechanical_scheme = StructuralMechanicsApplication.ExplicitCentralDifferencesScheme(self.settings["max_delta_time"].GetDouble(),
-                                                                             self.settings["fraction_delta_time"].GetDouble(),
-                                                                             self.settings["time_step_prediction_level"].GetDouble())
-        elif scheme_type == "multi_stage":
-            mechanical_scheme = StructuralMechanicsApplication.ExplicitMultiStageKimScheme(self.settings["fraction_delta_time"].GetDouble())
-        else:
-            err_msg =  "The requested scheme type \"" + scheme_type + "\" is not available!\n"
-            err_msg += "Available options are: \"central_differences\", \"multi_stage\""
-            raise Exception(err_msg)
-        return mechanical_scheme
-
-    def _CreateSolutionStrategy(self):
-        computing_model_part = self.GetComputingModelPart()
-        mechanical_scheme = self._GetScheme()
-
-        mechanical_solution_strategy = StructuralMechanicsApplication.MechanicalExplicitStrategy(computing_model_part,
-                                            mechanical_scheme,
-                                            self.settings["compute_reactions"].GetBool(),
-                                            self.settings["reform_dofs_at_each_step"].GetBool(),
-                                            self.settings["move_mesh_flag"].GetBool())
-
-        mechanical_solution_strategy.SetRebuildLevel(0)
-        return mechanical_solution_strategy
-
-    #### Private functions ####
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+
+# Import base class file
+from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
+
+def CreateSolver(model, custom_settings):
+    return ExplicitMechanicalSolver(model, custom_settings)
+
+class ExplicitMechanicalSolver(MechanicalSolver):
+    """The structural mechanics explicit dynamic solver.
+
+    This class creates the mechanical solvers for explicit dynamic analysis.
+
+    See structural_mechanics_solver.py for more information.
+    """
+    def __init__(self, model, custom_settings):
+        # Construct the base solver.
+        super().__init__(model, custom_settings)
+        # Lumped mass-matrix is necessary for explicit analysis
+        self.main_model_part.ProcessInfo[KratosMultiphysics.COMPUTE_LUMPED_MASS_MATRIX] = True
+        self.delta_time_refresh_counter = self.settings["delta_time_refresh"].GetInt()
+        KratosMultiphysics.Logger.PrintInfo("::[ExplicitMechanicalSolver]:: Construction finished")
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KratosMultiphysics.Parameters("""{
+            "time_integration_method"    : "explicit",
+            "scheme_type"                : "central_differences",
+            "time_step_prediction_level" : 0,
+            "delta_time_refresh"         : 1000,
+            "max_delta_time"             : 1.0e0,
+            "fraction_delta_time"        : 0.333333333333333333333333333333333333,
+            "rayleigh_alpha"             : 0.0,
+            "rayleigh_beta"              : 0.0
+        }""")
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
+
+    def AddVariables(self):
+        super().AddVariables()
+        self._add_dynamic_variables()
+
+        scheme_type = self.settings["scheme_type"].GetString()
+        if scheme_type == "central_differences":
+            self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.MIDDLE_VELOCITY)
+            if self.settings["rotation_dofs"].GetBool():
+                self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.MIDDLE_ANGULAR_VELOCITY)
+        if scheme_type == "multi_stage":
+            self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.FRACTIONAL_ACCELERATION)
+            if self.settings["rotation_dofs"].GetBool():
+                self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.FRACTIONAL_ANGULAR_ACCELERATION)
+
+        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.NODAL_MASS)
+        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.FORCE_RESIDUAL)
+        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.RESIDUAL_VECTOR)
+
+        if self.settings["rotation_dofs"].GetBool():
+            self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.NODAL_INERTIA)
+            self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.MOMENT_RESIDUAL)
+
+        KratosMultiphysics.Logger.PrintInfo("::[ExplicitMechanicalSolver]:: Variables ADDED")
+
+    def AddDofs(self):
+        super().AddDofs()
+        self._add_dynamic_dofs()
+        KratosMultiphysics.Logger.PrintInfo("::[ExplicitMechanicalSolver]:: DOF's ADDED")
+
+    def ComputeDeltaTime(self):
+        if self.settings["time_step_prediction_level"].GetInt() > 1:
+            if self.delta_time_refresh_counter >= self.settings["delta_time_refresh"].GetInt():
+                self.delta_time = StructuralMechanicsApplication.CalculateDeltaTime(self.GetComputingModelPart(), self.delta_time_settings)
+                self.delta_time_refresh_counter = 0
+            else:
+                self.delta_time_refresh_counter += 1
+        return self.delta_time
+
+    def Initialize(self):
+        # Using the base Initialize
+        super().Initialize()
+
+        # Initilize delta_time
+        self.delta_time_settings = KratosMultiphysics.Parameters("""{}""")
+        self.delta_time_settings.AddValue("time_step_prediction_level", self.settings["time_step_prediction_level"])
+        self.delta_time_settings.AddValue("max_delta_time", self.settings["max_delta_time"])
+        if self.settings["time_step_prediction_level"].GetInt() > 0:
+            self.delta_time = StructuralMechanicsApplication.CalculateDeltaTime(self.GetComputingModelPart(), self.delta_time_settings)
+        else:
+            self.delta_time = self.settings["time_stepping"]["time_step"].GetDouble()
+
+    #### Specific internal functions ####
+    def _CreateScheme(self):
+        scheme_type = self.settings["scheme_type"].GetString()
+
+        # Setting the Rayleigh damping parameters
+        process_info = self.main_model_part.ProcessInfo
+        process_info[StructuralMechanicsApplication.RAYLEIGH_ALPHA] = self.settings["rayleigh_alpha"].GetDouble()
+        process_info[StructuralMechanicsApplication.RAYLEIGH_BETA] = self.settings["rayleigh_beta"].GetDouble()
+
+        # Setting the time integration schemes
+        if scheme_type == "central_differences":
+            mechanical_scheme = StructuralMechanicsApplication.ExplicitCentralDifferencesScheme(self.settings["max_delta_time"].GetDouble(),
+                                                                             self.settings["fraction_delta_time"].GetDouble(),
+                                                                             self.settings["time_step_prediction_level"].GetDouble())
+        elif scheme_type == "multi_stage":
+            mechanical_scheme = StructuralMechanicsApplication.ExplicitMultiStageKimScheme(self.settings["fraction_delta_time"].GetDouble())
+        else:
+            err_msg =  "The requested scheme type \"" + scheme_type + "\" is not available!\n"
+            err_msg += "Available options are: \"central_differences\", \"multi_stage\""
+            raise Exception(err_msg)
+        return mechanical_scheme
+
+    def _CreateSolutionStrategy(self):
+        computing_model_part = self.GetComputingModelPart()
+        mechanical_scheme = self._GetScheme()
+
+        mechanical_solution_strategy = StructuralMechanicsApplication.MechanicalExplicitStrategy(computing_model_part,
+                                            mechanical_scheme,
+                                            self.settings["compute_reactions"].GetBool(),
+                                            self.settings["reform_dofs_at_each_step"].GetBool(),
+                                            self.settings["move_mesh_flag"].GetBool())
+
+        mechanical_solution_strategy.SetRebuildLevel(0)
+        return mechanical_solution_strategy
+
+    #### Private functions ####
```

## KratosMultiphysics/StructuralMechanicsApplication/set_spherical_local_axes_process.py

 * *Ordering differences only*

```diff
@@ -1,25 +1,25 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-import KratosMultiphysics.StructuralMechanicsApplication as SMA
-from KratosMultiphysics import Logger
-
-def Factory(settings, Model):
-    if not isinstance(settings, KM.Parameters):
-        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
-
-    default_settings = KM.Parameters(
-        """{
-            "model_part_name"            : "set_model_part_name",
-            "spherical_reference_axis"   : [0.0,0.0,1.0],
-            "spherical_central_point"    : [0.0,0.0,0.0],
-            "update_at_each_step"        : false
-        }""");
-    process_settings = settings["Parameters"]
-    process_settings.ValidateAndAssignDefaults(default_settings)
-    computing_model_part = Model[process_settings["model_part_name"].GetString()]
-
-    Logger.PrintInfo("SetSphericalLocalAxesProcess:: ","Setting the oriented local axes...")
-    process_settings.RemoveValue("model_part_name")
-    return SMA.SetSphericalLocalAxesProcess(computing_model_part, process_settings)
-
-
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+import KratosMultiphysics.StructuralMechanicsApplication as SMA
+from KratosMultiphysics import Logger
+
+def Factory(settings, Model):
+    if not isinstance(settings, KM.Parameters):
+        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
+
+    default_settings = KM.Parameters(
+        """{
+            "model_part_name"            : "set_model_part_name",
+            "spherical_reference_axis"   : [0.0,0.0,1.0],
+            "spherical_central_point"    : [0.0,0.0,0.0],
+            "update_at_each_step"        : false
+        }""");
+    process_settings = settings["Parameters"]
+    process_settings.ValidateAndAssignDefaults(default_settings)
+    computing_model_part = Model[process_settings["model_part_name"].GetString()]
+
+    Logger.PrintInfo("SetSphericalLocalAxesProcess:: ","Setting the oriented local axes...")
+    process_settings.RemoveValue("model_part_name")
+    return SMA.SetSphericalLocalAxesProcess(computing_model_part, process_settings)
+
+
```

## KratosMultiphysics/StructuralMechanicsApplication/symbolic_generation/total_lagrangian_mixed_volumetric_strain_element/generate_total_lagrangian_mixed_volumetric_strain_element.py

 * *Ordering differences only*

```diff
@@ -1,214 +1,214 @@
-import sympy
-from KratosMultiphysics import *
-from KratosMultiphysics import kratos_utilities
-from KratosMultiphysics.sympy_fe_utilities import *
-
-# Symbolic generation settings
-mode = "c"
-dim_vect = [2, 3]
-do_simplifications = False
-output_filename = "total_lagrangian_mixed_volumetric_strain_element.cpp"
-template_filename = "total_lagrangian_mixed_volumetric_strain_element_template.cpp"
-tokens_filenames = []
-
-for dim in dim_vect:
-    n_nodes = dim + 1  # So far only simplex elements are considered
-    block_size = dim + 1
-    local_size = n_nodes * block_size
-
-    if dim == 2:
-        strain_size = 3
-    elif dim == 3:
-        strain_size = 6
-    else:
-        raise ValueError("Wrong dimension {}.".format(dim))
-
-    impose_partion_of_unity = False
-    N,DN = DefineShapeFunctions(n_nodes, dim, impose_partion_of_unity)
-
-    # Symbols definition
-    u = DefineMatrix('u',n_nodes,dim) # Displacement (u(i,k) refers to the displacement of node i component k)
-    b = DefineMatrix('b',n_nodes,dim) # Body force (u(i,k) refers to the body force of node i component k)
-    th = DefineVector('th',n_nodes) # Variable representing the nodal det(J) - 1 (volumetric deformation increment)
-    w = DefineMatrix('w',n_nodes,dim) # Displacement test function
-    q = DefineVector('q',n_nodes) # Deformation Jacobian test function
-    w_g = sympy.Symbol("w_g", positive=True) # Gauss point integration weight
-    tau_u = sympy.Symbol("tau_u",positive=True) # Displacement stabilization constant
-    tau_th = sympy.Symbol("tau_th",positive=True) # Deformation Jacobian stabilization constant
-
-    S = DefineVector('S',strain_size) # Stress in Voigt notation (this will be returned by the constitutive law)
-    if dim == 2:
-        S = sympy.Matrix([
-            [S[0],S[2]],
-            [S[2],S[1]]]) # Definition of the stress tensor from the previous definition symbols
-    else:
-        S = sympy.Matrix([
-            [S[0],S[3],S[5]],
-            [S[3],S[1],S[4]],
-            [S[5],S[4],S[2]]]) # Definition of the stress tensor from the previous definition symbols
-
-    C = DefineSymmetricMatrix("C",strain_size,strain_size) # Constitutive matrix in Voigt notation (this will be returned by the constitutive law)
-    C = ConvertVoigtMatrixToTensor(C) # Definition of the 4th order constitutive tensor from the previous definition symbols
-
-    # Define the tetha interpolations at the Gauss point
-    th_gauss = 0
-    for n in range(n_nodes):
-        th_gauss += N[n]*th[n]
-        grad_th_gauss = DN.transpose()*th
-
-    # Define the body force interpolation at the Gauss point
-    b_gauss = DefineVector('b_gauss',dim)
-
-    # Shape functions evaluation at the Gauss point
-    grad_w_gauss = w.transpose()*DN
-    grad_q_gauss = q.transpose()*DN
-    w_gauss = w.transpose()*N
-    q_gauss = q.transpose()*N
-
-    # Define the deformation gradient tensor at the Gauss point
-    # Note that this is defined only in terms of the displacement (not enriched). See article Remark 1
-    # F[i,j] = delta_ij + Du_i/Dx_j = delta_ij + sum_n DN_n*u_ni/Dx_j
-    F_gauss = sympy.Matrix(sympy.eye(dim,dim))
-    for i in range(dim):
-        for j in range(dim):
-            for n in range(n_nodes):
-                F_gauss[i,j] += DN[n,j]*u[n,i]
-
-    # Define the Jacobian determinant at the Gauss point
-    j_gauss = sympy.det(F_gauss)
-
-    # Calculate the cofactor of the deformation gradient
-    # cof(F) = det(J)*F^{-T}
-    invF_gauss = F_gauss.inv(method="LU")
-    cofF_gauss = j_gauss*(invF_gauss.transpose())
-
-    # Calculate the strain tensors
-    # Note that for the multiplicative decomposition of the strain we assume the dimension to be the volumetric deformation exponent
-    # As a consequence, current implementation is valid for the general 3D case and the 2D plain strain one (not valid for the 2D plane stress)
-    Fbar_gauss = (1/j_gauss**sympy.Rational(1,dim))*F_gauss # Deviatoric deformation gradient tensor
-    Cbar_gauss = Fbar_gauss.transpose() * Fbar_gauss # Deviatoric right Cauchy-Green strain tensor
-    Ebar_gauss = 0.5*(Cbar_gauss - sympy.eye(dim,dim)) # Deviatoric Green-Lagrange strain tensor
-
-    # Calculate the equivalent strain tensors
-    Fmod_gauss = ((1.0 + th_gauss)**sympy.Rational(1,dim))*Fbar_gauss # Equivalent (enriched) deformation gradient tensor
-    Cmod_gauss = Fmod_gauss.transpose() * Fmod_gauss # Equivalent (enriched) right Cauchy-Green strain tensor
-    Emod_gauss = 0.5*(Cmod_gauss - sympy.eye(dim,dim)) # Equivalent (enriched) Green-Lagrange strain tensor
-
-    # Variational form
-    tmp = (DoubleContraction(C, F_gauss.transpose()*F_gauss)).tomatrix()
-
-    mom_first = DoubleContraction(grad_w_gauss, F_gauss* S)
-    mom_second = (w_gauss.transpose() * b_gauss)[0]
-    mom_aux_scalar = (tau_th / dim) * ((1+th_gauss)**sympy.Rational(2-dim,dim)) * (1.0/j_gauss**sympy.Rational(2,dim))
-    mom_stab = DoubleContraction(grad_w_gauss, mom_aux_scalar * (1 + th_gauss - j_gauss) * tmp)
-
-    mass_first = (1.0 - tau_th) * q_gauss[0] * (1.0+th_gauss - j_gauss)
-    mass_aux_scalar = (tau_u / dim) * ((j_gauss / (1.0+th_gauss))**sympy.Rational(dim-2,dim))
-    mass_stab_1 = (mass_aux_scalar * grad_q_gauss * tmp * grad_th_gauss)[0]
-    mass_stab_2 = (tau_u * grad_q_gauss * cofF_gauss.transpose() * b_gauss)[0]
-
-    functional = mom_second - mom_first + mom_stab + mass_first + mass_stab_1 + mass_stab_2
-    functional_array = sympy.Matrix([functional])
-
-    # Define DOFs and test function vectors
-    dofs = sympy.zeros(local_size, 1)
-    testfunc = sympy.zeros(local_size, 1)
-    for i in range(n_nodes):
-        # Displacement DOFs and test functions
-        for k in range(dim):
-            dofs[i*block_size + k] = u[i,k]
-            testfunc[i*block_size + k] = w[i,k]
-        # Jacobian determinant DOFs and test functions
-        dofs[i*block_size + dim] = th[i,0]
-        testfunc[i*block_size + dim] = q[i,0]
-
-    # Compute RHS (functional differentiation w.r.t. the shape functions)
-    # Note that the stress is included as a symbolic variable, which is assumed to computed by the constitutive law module
-    rhs = Compute_RHS(functional_array.copy(), testfunc, do_simplifications)
-    rhs_out = OutputVector_CollectingFactors(w_g*rhs, "rRightHandSideVector", mode, indentation_level=2, assignment_op="+=")
-
-    # Compute LHS (RHS(residual) differentiation w.r.t. the DOFs)
-    # Note that 'S' (stress symbolic variable) is substituted by a definition of a function in terms of E for the LHS differentiation
-    # Otherwise the displacement terms inside the modified Green strain would not be considered in the differentiation
-    # Also note that a direct substitution by C:E is not valid in this case as this would imply a wrong differentiation of the LHS terms involving S (e.g. geometric stiffness)
-
-    # Create an auxiliary symbol for the Green-Lagrange strain as a function such that E(u,tetha)
-    E = sympy.MatrixSymbol("E", dim, dim).as_mutable()
-    for i in range(dim):
-        for j in range(dim):
-            E[i,j] = sympy.Function(f"E_{i}_{j}")(*dofs)
-
-    # Create an auxiliary symbol for the PK2 stress as a function depending on E(u,tetha)
-    S_func = sympy.MatrixSymbol("S", dim, dim).as_mutable()
-    for i in range(dim):
-        for j in range(dim):
-            S_func[i,j] = sympy.Function(f"S_{i}_{j}")(*(E.values()))
-
-    # Substitute the previous auxiliary definition of the stress by S(E(u,tetha))
-    SubstituteMatrixValue(rhs, S, S_func)
-
-    # Set the substitution list to be applied after the differentiation
-    n_dofs = rhs.shape[0]
-    substitution_list = {}
-    for i in range(dim):
-        for j in range(dim):
-            # First, for the dS/dE differentiation from the constitutive tensor symbols
-            for k in range(dim):
-                for l in range(dim):
-                    t = sympy.diff(S_func[i, j], E[k, l])
-                    substitution_list[t] = C[i, j, k, l]
-
-            # Secondly, for the dE/dDOFs differentiation (note that we used the enriched strain)
-            for i_dof in range(n_dofs):
-                t = sympy.diff(E[i,j], dofs[i_dof])
-                substitution_list[t] = sympy.diff(Emod_gauss[i,j], dofs[i_dof])
-
-            # Finally, set the remaining E and S symbols as the enriched strain and the CL stress
-            substitution_list[E[i,j]] = Emod_gauss[i,j]
-            substitution_list[S_func[i,j]] = S[i,j]
-
-    # Calculate the LHS from the previous derivatives
-    n_dofs = rhs.shape[0]
-    lhs = sympy.zeros(n_dofs, n_dofs)
-    for i in range(n_dofs):
-        for j in range(n_dofs):
-                lhs[i,j] -= sympy.diff(rhs[i], dofs[j])
-                lhs[i,j] = lhs[i,j].subs(substitution_list)
-                if do_simplifications:
-                    lhs[i, j] = sympy.simplify(lhs[i, j])
-    lhs_out = OutputMatrix_CollectingFactors(w_g*lhs, "rLeftHandSideMatrix", mode, indentation_level=2, assignment_op="+=")
-
-    # Calculate the output equivalent deformation gradient
-    Fmod_gauss_out = OutputMatrix_CollectingFactors(Fmod_gauss, "r_eq_def_gradient", mode, indentation_level=1)
-    det_Fmod_gauss_out = OutputScalar_CollectingFactors(Fmod_gauss.det(), "r_det_eq_def_gradient", mode, indentation_level=0)
-
-    # Calculate the output equivalent strain
-    Emod_gauss_out = OutputVector_CollectingFactors(StrainToVoigt(Emod_gauss), "r_eq_green_strain", mode, indentation_level=1)
-
-    # Temporary save the automatic differentiation outputs
-    tokens_dict = {
-        f"substitute_rhs_{dim}D_{n_nodes}N" : rhs_out,
-        f"substitute_lhs_{dim}D_{n_nodes}N" : lhs_out,
-        f"substitute_def_gradient_{dim}D_{n_nodes}N" : Fmod_gauss_out,
-        f"substitute_det_def_gradient_{dim}D_{n_nodes}N" : det_Fmod_gauss_out,
-        f"substitute_green_strain_{dim}D_{n_nodes}N" : Emod_gauss_out}
-    for token_key, token_val in tokens_dict.items():
-        tokens_filenames.append(token_key)
-        with open(f"{token_key}.sym",'w+') as token_file:
-            token_file.write(token_val)
-
-# Write the modified template
-with open(template_filename, 'r') as template_file:
-    with open(output_filename, 'w') as output_file:
-        for line in template_file:
-            has_token = False
-            for token_key in tokens_filenames:
-                if token_key in line:
-                    has_token = True
-                    with open(f"{token_key}.sym", 'r') as token_file:
-                        output_file.writelines(token_file.readlines())
-            if not has_token:
-                output_file.write(line)
-
-for token_key in tokens_filenames:
-    kratos_utilities.DeleteFileIfExisting(f"{token_key}.sym")
+import sympy
+from KratosMultiphysics import *
+from KratosMultiphysics import kratos_utilities
+from KratosMultiphysics.sympy_fe_utilities import *
+
+# Symbolic generation settings
+mode = "c"
+dim_vect = [2, 3]
+do_simplifications = False
+output_filename = "total_lagrangian_mixed_volumetric_strain_element.cpp"
+template_filename = "total_lagrangian_mixed_volumetric_strain_element_template.cpp"
+tokens_filenames = []
+
+for dim in dim_vect:
+    n_nodes = dim + 1  # So far only simplex elements are considered
+    block_size = dim + 1
+    local_size = n_nodes * block_size
+
+    if dim == 2:
+        strain_size = 3
+    elif dim == 3:
+        strain_size = 6
+    else:
+        raise ValueError("Wrong dimension {}.".format(dim))
+
+    impose_partion_of_unity = False
+    N,DN = DefineShapeFunctions(n_nodes, dim, impose_partion_of_unity)
+
+    # Symbols definition
+    u = DefineMatrix('u',n_nodes,dim) # Displacement (u(i,k) refers to the displacement of node i component k)
+    b = DefineMatrix('b',n_nodes,dim) # Body force (u(i,k) refers to the body force of node i component k)
+    th = DefineVector('th',n_nodes) # Variable representing the nodal det(J) - 1 (volumetric deformation increment)
+    w = DefineMatrix('w',n_nodes,dim) # Displacement test function
+    q = DefineVector('q',n_nodes) # Deformation Jacobian test function
+    w_g = sympy.Symbol("w_g", positive=True) # Gauss point integration weight
+    tau_u = sympy.Symbol("tau_u",positive=True) # Displacement stabilization constant
+    tau_th = sympy.Symbol("tau_th",positive=True) # Deformation Jacobian stabilization constant
+
+    S = DefineVector('S',strain_size) # Stress in Voigt notation (this will be returned by the constitutive law)
+    if dim == 2:
+        S = sympy.Matrix([
+            [S[0],S[2]],
+            [S[2],S[1]]]) # Definition of the stress tensor from the previous definition symbols
+    else:
+        S = sympy.Matrix([
+            [S[0],S[3],S[5]],
+            [S[3],S[1],S[4]],
+            [S[5],S[4],S[2]]]) # Definition of the stress tensor from the previous definition symbols
+
+    C = DefineSymmetricMatrix("C",strain_size,strain_size) # Constitutive matrix in Voigt notation (this will be returned by the constitutive law)
+    C = ConvertVoigtMatrixToTensor(C) # Definition of the 4th order constitutive tensor from the previous definition symbols
+
+    # Define the tetha interpolations at the Gauss point
+    th_gauss = 0
+    for n in range(n_nodes):
+        th_gauss += N[n]*th[n]
+        grad_th_gauss = DN.transpose()*th
+
+    # Define the body force interpolation at the Gauss point
+    b_gauss = DefineVector('b_gauss',dim)
+
+    # Shape functions evaluation at the Gauss point
+    grad_w_gauss = w.transpose()*DN
+    grad_q_gauss = q.transpose()*DN
+    w_gauss = w.transpose()*N
+    q_gauss = q.transpose()*N
+
+    # Define the deformation gradient tensor at the Gauss point
+    # Note that this is defined only in terms of the displacement (not enriched). See article Remark 1
+    # F[i,j] = delta_ij + Du_i/Dx_j = delta_ij + sum_n DN_n*u_ni/Dx_j
+    F_gauss = sympy.Matrix(sympy.eye(dim,dim))
+    for i in range(dim):
+        for j in range(dim):
+            for n in range(n_nodes):
+                F_gauss[i,j] += DN[n,j]*u[n,i]
+
+    # Define the Jacobian determinant at the Gauss point
+    j_gauss = sympy.det(F_gauss)
+
+    # Calculate the cofactor of the deformation gradient
+    # cof(F) = det(J)*F^{-T}
+    invF_gauss = F_gauss.inv(method="LU")
+    cofF_gauss = j_gauss*(invF_gauss.transpose())
+
+    # Calculate the strain tensors
+    # Note that for the multiplicative decomposition of the strain we assume the dimension to be the volumetric deformation exponent
+    # As a consequence, current implementation is valid for the general 3D case and the 2D plain strain one (not valid for the 2D plane stress)
+    Fbar_gauss = (1/j_gauss**sympy.Rational(1,dim))*F_gauss # Deviatoric deformation gradient tensor
+    Cbar_gauss = Fbar_gauss.transpose() * Fbar_gauss # Deviatoric right Cauchy-Green strain tensor
+    Ebar_gauss = 0.5*(Cbar_gauss - sympy.eye(dim,dim)) # Deviatoric Green-Lagrange strain tensor
+
+    # Calculate the equivalent strain tensors
+    Fmod_gauss = ((1.0 + th_gauss)**sympy.Rational(1,dim))*Fbar_gauss # Equivalent (enriched) deformation gradient tensor
+    Cmod_gauss = Fmod_gauss.transpose() * Fmod_gauss # Equivalent (enriched) right Cauchy-Green strain tensor
+    Emod_gauss = 0.5*(Cmod_gauss - sympy.eye(dim,dim)) # Equivalent (enriched) Green-Lagrange strain tensor
+
+    # Variational form
+    tmp = (DoubleContraction(C, F_gauss.transpose()*F_gauss)).tomatrix()
+
+    mom_first = DoubleContraction(grad_w_gauss, F_gauss* S)
+    mom_second = (w_gauss.transpose() * b_gauss)[0]
+    mom_aux_scalar = (tau_th / dim) * ((1+th_gauss)**sympy.Rational(2-dim,dim)) * (1.0/j_gauss**sympy.Rational(2,dim))
+    mom_stab = DoubleContraction(grad_w_gauss, mom_aux_scalar * (1 + th_gauss - j_gauss) * tmp)
+
+    mass_first = (1.0 - tau_th) * q_gauss[0] * (1.0+th_gauss - j_gauss)
+    mass_aux_scalar = (tau_u / dim) * ((j_gauss / (1.0+th_gauss))**sympy.Rational(dim-2,dim))
+    mass_stab_1 = (mass_aux_scalar * grad_q_gauss * tmp * grad_th_gauss)[0]
+    mass_stab_2 = (tau_u * grad_q_gauss * cofF_gauss.transpose() * b_gauss)[0]
+
+    functional = mom_second - mom_first + mom_stab + mass_first + mass_stab_1 + mass_stab_2
+    functional_array = sympy.Matrix([functional])
+
+    # Define DOFs and test function vectors
+    dofs = sympy.zeros(local_size, 1)
+    testfunc = sympy.zeros(local_size, 1)
+    for i in range(n_nodes):
+        # Displacement DOFs and test functions
+        for k in range(dim):
+            dofs[i*block_size + k] = u[i,k]
+            testfunc[i*block_size + k] = w[i,k]
+        # Jacobian determinant DOFs and test functions
+        dofs[i*block_size + dim] = th[i,0]
+        testfunc[i*block_size + dim] = q[i,0]
+
+    # Compute RHS (functional differentiation w.r.t. the shape functions)
+    # Note that the stress is included as a symbolic variable, which is assumed to computed by the constitutive law module
+    rhs = Compute_RHS(functional_array.copy(), testfunc, do_simplifications)
+    rhs_out = OutputVector_CollectingFactors(w_g*rhs, "rRightHandSideVector", mode, indentation_level=2, assignment_op="+=")
+
+    # Compute LHS (RHS(residual) differentiation w.r.t. the DOFs)
+    # Note that 'S' (stress symbolic variable) is substituted by a definition of a function in terms of E for the LHS differentiation
+    # Otherwise the displacement terms inside the modified Green strain would not be considered in the differentiation
+    # Also note that a direct substitution by C:E is not valid in this case as this would imply a wrong differentiation of the LHS terms involving S (e.g. geometric stiffness)
+
+    # Create an auxiliary symbol for the Green-Lagrange strain as a function such that E(u,tetha)
+    E = sympy.MatrixSymbol("E", dim, dim).as_mutable()
+    for i in range(dim):
+        for j in range(dim):
+            E[i,j] = sympy.Function(f"E_{i}_{j}")(*dofs)
+
+    # Create an auxiliary symbol for the PK2 stress as a function depending on E(u,tetha)
+    S_func = sympy.MatrixSymbol("S", dim, dim).as_mutable()
+    for i in range(dim):
+        for j in range(dim):
+            S_func[i,j] = sympy.Function(f"S_{i}_{j}")(*(E.values()))
+
+    # Substitute the previous auxiliary definition of the stress by S(E(u,tetha))
+    SubstituteMatrixValue(rhs, S, S_func)
+
+    # Set the substitution list to be applied after the differentiation
+    n_dofs = rhs.shape[0]
+    substitution_list = {}
+    for i in range(dim):
+        for j in range(dim):
+            # First, for the dS/dE differentiation from the constitutive tensor symbols
+            for k in range(dim):
+                for l in range(dim):
+                    t = sympy.diff(S_func[i, j], E[k, l])
+                    substitution_list[t] = C[i, j, k, l]
+
+            # Secondly, for the dE/dDOFs differentiation (note that we used the enriched strain)
+            for i_dof in range(n_dofs):
+                t = sympy.diff(E[i,j], dofs[i_dof])
+                substitution_list[t] = sympy.diff(Emod_gauss[i,j], dofs[i_dof])
+
+            # Finally, set the remaining E and S symbols as the enriched strain and the CL stress
+            substitution_list[E[i,j]] = Emod_gauss[i,j]
+            substitution_list[S_func[i,j]] = S[i,j]
+
+    # Calculate the LHS from the previous derivatives
+    n_dofs = rhs.shape[0]
+    lhs = sympy.zeros(n_dofs, n_dofs)
+    for i in range(n_dofs):
+        for j in range(n_dofs):
+                lhs[i,j] -= sympy.diff(rhs[i], dofs[j])
+                lhs[i,j] = lhs[i,j].subs(substitution_list)
+                if do_simplifications:
+                    lhs[i, j] = sympy.simplify(lhs[i, j])
+    lhs_out = OutputMatrix_CollectingFactors(w_g*lhs, "rLeftHandSideMatrix", mode, indentation_level=2, assignment_op="+=")
+
+    # Calculate the output equivalent deformation gradient
+    Fmod_gauss_out = OutputMatrix_CollectingFactors(Fmod_gauss, "r_eq_def_gradient", mode, indentation_level=1)
+    det_Fmod_gauss_out = OutputScalar_CollectingFactors(Fmod_gauss.det(), "r_det_eq_def_gradient", mode, indentation_level=0)
+
+    # Calculate the output equivalent strain
+    Emod_gauss_out = OutputVector_CollectingFactors(StrainToVoigt(Emod_gauss), "r_eq_green_strain", mode, indentation_level=1)
+
+    # Temporary save the automatic differentiation outputs
+    tokens_dict = {
+        f"substitute_rhs_{dim}D_{n_nodes}N" : rhs_out,
+        f"substitute_lhs_{dim}D_{n_nodes}N" : lhs_out,
+        f"substitute_def_gradient_{dim}D_{n_nodes}N" : Fmod_gauss_out,
+        f"substitute_det_def_gradient_{dim}D_{n_nodes}N" : det_Fmod_gauss_out,
+        f"substitute_green_strain_{dim}D_{n_nodes}N" : Emod_gauss_out}
+    for token_key, token_val in tokens_dict.items():
+        tokens_filenames.append(token_key)
+        with open(f"{token_key}.sym",'w+') as token_file:
+            token_file.write(token_val)
+
+# Write the modified template
+with open(template_filename, 'r') as template_file:
+    with open(output_filename, 'w') as output_file:
+        for line in template_file:
+            has_token = False
+            for token_key in tokens_filenames:
+                if token_key in line:
+                    has_token = True
+                    with open(f"{token_key}.sym", 'r') as token_file:
+                        output_file.writelines(token_file.readlines())
+            if not has_token:
+                output_file.write(line)
+
+for token_key in tokens_filenames:
+    kratos_utilities.DeleteFileIfExisting(f"{token_key}.sym")
```

## KratosMultiphysics/StructuralMechanicsApplication/automatic_rayleigh_parameters_computation_process.py

 * *Ordering differences only*

```diff
@@ -1,191 +1,191 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-from KratosMultiphysics import eigen_solver_factory
-
-import KratosMultiphysics.StructuralMechanicsApplication as SMA
-
-def Factory(settings, Model):
-    if not isinstance(settings, KM.Parameters):
-        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
-    return AutomaticRayleighComputationProcess(Model, settings["Parameters"])
-
-# All the processes python processes should be derived from "Process"
-
-class AutomaticRayleighComputationProcess(KM.Process):
-    """This class is used in order to compute automatically the Rayleigh damping parameters computing in first place the eigenvalues of the system
-
-    Only the member variables listed below should be accessed directly.
-
-    Public member variables:
-    Model -- the container of the different model parts.
-    settings -- Kratos parameters containing the settings.
-    """
-
-    def __init__(self, Model, settings):
-        """ The default constructor of the class
-
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        Model -- the container of the different model parts.
-        settings -- Kratos parameters containing solver settings.
-        """
-        KM.Process.__init__(self)
-
-        # Settings string in json format
-        default_parameters = KM.Parameters("""
-        {
-            "help"                           :"This class is used in order to compute automatically the Rayleigh damping parameters computing in first place the eigenvalues of the system",
-            "mesh_id"                        : 0,
-            "model_part_name"                : "Structure",
-            "echo_level"                     : 0,
-            "write_on_properties"            : true,
-            "damping_ratio_0"                : 0.0,
-            "damping_ratio_1"                : -1.0,
-            "eigen_values_vector"            : [0.0],
-            "eigen_system_settings" : {
-                "solver_type"       : "eigen_eigensystem"
-            }
-        }
-        """)
-
-        # Setting solver settings
-        if settings.Has("eigen_system_settings"):
-            if not settings["eigen_system_settings"].Has("solver_type"):
-              settings["eigen_system_settings"].AddValue("solver_type", default_parameters["eigen_system_settings"]["solver_type"])
-        else:
-            settings.AddValue("eigen_system_settings", default_parameters["eigen_system_settings"])
-        solver_type = settings["eigen_system_settings"]["solver_type"].GetString()
-        eigen_system_settings = self._auxiliary_eigen_settings(solver_type)
-        default_parameters["eigen_system_settings"] = eigen_system_settings["eigen_system_settings"]
-
-        # Overwrite the default settings with user-provided parameters
-        self.settings = settings
-        self.settings.RecursivelyValidateAndAssignDefaults(default_parameters)
-
-        # We define the model parts
-        self.model = Model
-        self.main_model_part = self.model[self.settings["model_part_name"].GetString()]
-
-    def ExecuteBeforeSolutionLoop(self):
-        """ This method is executed before starting the time loop
-
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        """
-
-        # The general damping ratios
-        damping_ratio_0 = self.settings["damping_ratio_0"].GetDouble()
-        damping_ratio_1 = self.settings["damping_ratio_1"].GetDouble()
-
-        # We get the model parts which divide the problem
-        current_process_info = self.main_model_part.ProcessInfo
-        existing_computation = current_process_info.Has(SMA.EIGENVALUE_VECTOR)
-
-        # Create auxiliary parameters
-        compute_damping_coefficients_settings = KM.Parameters("""
-        {
-            "echo_level"          : 0,
-            "damping_ratio_0"     : 0.0,
-            "damping_ratio_1"     : -1.0,
-            "eigen_values_vector" : [0.0]
-        }
-        """)
-
-        # Setting custom parameters
-        compute_damping_coefficients_settings["echo_level"].SetInt(self.settings["echo_level"].GetInt())
-        compute_damping_coefficients_settings["damping_ratio_0"].SetDouble(damping_ratio_0)
-        compute_damping_coefficients_settings["damping_ratio_1"].SetDouble(damping_ratio_1)
-
-        # We check if the values are previously defined
-        properties = self.main_model_part.GetProperties()
-        for prop in properties:
-            if prop.Has(SMA.SYSTEM_DAMPING_RATIO):
-                self.settings["damping_ratio_0"].SetDouble(prop.GetValue(SMA.SYSTEM_DAMPING_RATIO))
-                break
-        for prop in properties:
-            if prop.Has(SMA.SECOND_SYSTEM_DAMPING_RATIO):
-                self.settings["damping_ratio_1"].SetDouble(prop.GetValue(SMA.SECOND_SYSTEM_DAMPING_RATIO))
-                break
-
-        # We have computed already the eigen values
-        current_process_info = self.main_model_part.ProcessInfo
-        precomputed_eigen_values = self.settings["eigen_values_vector"].GetVector()
-        if len(precomputed_eigen_values) > 1:
-            compute_damping_coefficients_settings["eigen_values_vector"].SetVector(precomputed_eigen_values)
-        else:
-            # If not computed eigen values already
-            if not existing_computation:
-                KM.Logger.PrintInfo("::[MechanicalSolver]::", "EIGENVALUE_VECTOR not previously computed. Computing automatically, take care")
-                eigen_linear_solver = eigen_solver_factory.ConstructSolver(self.settings["eigen_system_settings"])
-                builder_and_solver = KM.ResidualBasedBlockBuilderAndSolver(eigen_linear_solver)
-                eigen_scheme = SMA.EigensolverDynamicScheme()
-                eigen_solver = SMA.EigensolverStrategy(self.main_model_part, eigen_scheme, builder_and_solver,
-                    self.mass_matrix_diagonal_value,
-                    self.stiffness_matrix_diagonal_value)
-                eigen_solver.Solve()
-
-                # Setting the variable RESET_EQUATION_IDS
-                current_process_info[SMA.RESET_EQUATION_IDS] = True
-
-            eigenvalue_vector = current_process_info.GetValue(SMA.EIGENVALUE_VECTOR)
-            compute_damping_coefficients_settings["eigen_values_vector"].SetVector(eigenvalue_vector)
-
-        # We compute the coefficients
-        coefficients_vector = SMA.ComputeDampingCoefficients(compute_damping_coefficients_settings)
-
-        # We set the values
-        if self.settings["write_on_properties"].GetBool():
-            for prop in self.main_model_part.Properties:
-                prop.SetValue(SMA.RAYLEIGH_ALPHA, coefficients_vector[0])
-                if current_process_info.Has(KM.COMPUTE_LUMPED_MASS_MATRIX):
-                    if current_process_info[KM.COMPUTE_LUMPED_MASS_MATRIX]:
-                        prop.SetValue(SMA.RAYLEIGH_BETA, 0.0)
-                    else:
-                        prop.SetValue(SMA.RAYLEIGH_BETA, coefficients_vector[1])
-                else:
-                    prop.SetValue(SMA.RAYLEIGH_BETA, coefficients_vector[1])
-        else:
-            current_process_info.SetValue(SMA.RAYLEIGH_ALPHA, coefficients_vector[0])
-            if current_process_info.Has(KM.COMPUTE_LUMPED_MASS_MATRIX):
-                if current_process_info[KM.COMPUTE_LUMPED_MASS_MATRIX]:
-                    current_process_info.SetValue(SMA.RAYLEIGH_BETA, 0.0)
-                else:
-                    current_process_info.SetValue(SMA.RAYLEIGH_BETA, coefficients_vector[1])
-            else:
-                current_process_info.SetValue(SMA.RAYLEIGH_BETA, coefficients_vector[1])
-
-    def _auxiliary_eigen_settings(self, solver_type):
-        """ This method returns the settings for the eigenvalues computations
-
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        """
-        if solver_type == "feast":
-            eigen_system_settings = KM.Parameters("""
-            {
-                "eigen_system_settings" : {
-                    "solver_type"           : "feast",
-                    "echo_level"            : 0,
-                    "tolerance"             : 1e-10,
-                    "symmetric"             : true,
-                    "e_min"                 : 0.0,
-                    "e_max"                 : 4.0e5,
-                    "number_of_eigenvalues" : 2,
-                    "subspace_size"         : 15
-                }
-            }
-            """)
-            self.mass_matrix_diagonal_value = 1.0
-            self.stiffness_matrix_diagonal_value = -1.0
-        else:
-            eigen_system_settings = KM.Parameters("""
-            {
-                "eigen_system_settings" : {
-                    "solver_type"       : "eigen_eigensystem"
-                }
-            }
-            """)
-            eigen_system_settings["eigen_system_settings"]["solver_type"].SetString(solver_type)
-            self.mass_matrix_diagonal_value = 0.0
-            self.stiffness_matrix_diagonal_value = 1.0
-        return eigen_system_settings
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+from KratosMultiphysics import eigen_solver_factory
+
+import KratosMultiphysics.StructuralMechanicsApplication as SMA
+
+def Factory(settings, Model):
+    if not isinstance(settings, KM.Parameters):
+        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
+    return AutomaticRayleighComputationProcess(Model, settings["Parameters"])
+
+# All the processes python processes should be derived from "Process"
+
+class AutomaticRayleighComputationProcess(KM.Process):
+    """This class is used in order to compute automatically the Rayleigh damping parameters computing in first place the eigenvalues of the system
+
+    Only the member variables listed below should be accessed directly.
+
+    Public member variables:
+    Model -- the container of the different model parts.
+    settings -- Kratos parameters containing the settings.
+    """
+
+    def __init__(self, Model, settings):
+        """ The default constructor of the class
+
+        Keyword arguments:
+        self -- It signifies an instance of a class.
+        Model -- the container of the different model parts.
+        settings -- Kratos parameters containing solver settings.
+        """
+        KM.Process.__init__(self)
+
+        # Settings string in json format
+        default_parameters = KM.Parameters("""
+        {
+            "help"                           :"This class is used in order to compute automatically the Rayleigh damping parameters computing in first place the eigenvalues of the system",
+            "mesh_id"                        : 0,
+            "model_part_name"                : "Structure",
+            "echo_level"                     : 0,
+            "write_on_properties"            : true,
+            "damping_ratio_0"                : 0.0,
+            "damping_ratio_1"                : -1.0,
+            "eigen_values_vector"            : [0.0],
+            "eigen_system_settings" : {
+                "solver_type"       : "eigen_eigensystem"
+            }
+        }
+        """)
+
+        # Setting solver settings
+        if settings.Has("eigen_system_settings"):
+            if not settings["eigen_system_settings"].Has("solver_type"):
+              settings["eigen_system_settings"].AddValue("solver_type", default_parameters["eigen_system_settings"]["solver_type"])
+        else:
+            settings.AddValue("eigen_system_settings", default_parameters["eigen_system_settings"])
+        solver_type = settings["eigen_system_settings"]["solver_type"].GetString()
+        eigen_system_settings = self._auxiliary_eigen_settings(solver_type)
+        default_parameters["eigen_system_settings"] = eigen_system_settings["eigen_system_settings"]
+
+        # Overwrite the default settings with user-provided parameters
+        self.settings = settings
+        self.settings.RecursivelyValidateAndAssignDefaults(default_parameters)
+
+        # We define the model parts
+        self.model = Model
+        self.main_model_part = self.model[self.settings["model_part_name"].GetString()]
+
+    def ExecuteBeforeSolutionLoop(self):
+        """ This method is executed before starting the time loop
+
+        Keyword arguments:
+        self -- It signifies an instance of a class.
+        """
+
+        # The general damping ratios
+        damping_ratio_0 = self.settings["damping_ratio_0"].GetDouble()
+        damping_ratio_1 = self.settings["damping_ratio_1"].GetDouble()
+
+        # We get the model parts which divide the problem
+        current_process_info = self.main_model_part.ProcessInfo
+        existing_computation = current_process_info.Has(SMA.EIGENVALUE_VECTOR)
+
+        # Create auxiliary parameters
+        compute_damping_coefficients_settings = KM.Parameters("""
+        {
+            "echo_level"          : 0,
+            "damping_ratio_0"     : 0.0,
+            "damping_ratio_1"     : -1.0,
+            "eigen_values_vector" : [0.0]
+        }
+        """)
+
+        # Setting custom parameters
+        compute_damping_coefficients_settings["echo_level"].SetInt(self.settings["echo_level"].GetInt())
+        compute_damping_coefficients_settings["damping_ratio_0"].SetDouble(damping_ratio_0)
+        compute_damping_coefficients_settings["damping_ratio_1"].SetDouble(damping_ratio_1)
+
+        # We check if the values are previously defined
+        properties = self.main_model_part.GetProperties()
+        for prop in properties:
+            if prop.Has(SMA.SYSTEM_DAMPING_RATIO):
+                self.settings["damping_ratio_0"].SetDouble(prop.GetValue(SMA.SYSTEM_DAMPING_RATIO))
+                break
+        for prop in properties:
+            if prop.Has(SMA.SECOND_SYSTEM_DAMPING_RATIO):
+                self.settings["damping_ratio_1"].SetDouble(prop.GetValue(SMA.SECOND_SYSTEM_DAMPING_RATIO))
+                break
+
+        # We have computed already the eigen values
+        current_process_info = self.main_model_part.ProcessInfo
+        precomputed_eigen_values = self.settings["eigen_values_vector"].GetVector()
+        if len(precomputed_eigen_values) > 1:
+            compute_damping_coefficients_settings["eigen_values_vector"].SetVector(precomputed_eigen_values)
+        else:
+            # If not computed eigen values already
+            if not existing_computation:
+                KM.Logger.PrintInfo("::[MechanicalSolver]::", "EIGENVALUE_VECTOR not previously computed. Computing automatically, take care")
+                eigen_linear_solver = eigen_solver_factory.ConstructSolver(self.settings["eigen_system_settings"])
+                builder_and_solver = KM.ResidualBasedBlockBuilderAndSolver(eigen_linear_solver)
+                eigen_scheme = SMA.EigensolverDynamicScheme()
+                eigen_solver = SMA.EigensolverStrategy(self.main_model_part, eigen_scheme, builder_and_solver,
+                    self.mass_matrix_diagonal_value,
+                    self.stiffness_matrix_diagonal_value)
+                eigen_solver.Solve()
+
+                # Setting the variable RESET_EQUATION_IDS
+                current_process_info[SMA.RESET_EQUATION_IDS] = True
+
+            eigenvalue_vector = current_process_info.GetValue(SMA.EIGENVALUE_VECTOR)
+            compute_damping_coefficients_settings["eigen_values_vector"].SetVector(eigenvalue_vector)
+
+        # We compute the coefficients
+        coefficients_vector = SMA.ComputeDampingCoefficients(compute_damping_coefficients_settings)
+
+        # We set the values
+        if self.settings["write_on_properties"].GetBool():
+            for prop in self.main_model_part.Properties:
+                prop.SetValue(SMA.RAYLEIGH_ALPHA, coefficients_vector[0])
+                if current_process_info.Has(KM.COMPUTE_LUMPED_MASS_MATRIX):
+                    if current_process_info[KM.COMPUTE_LUMPED_MASS_MATRIX]:
+                        prop.SetValue(SMA.RAYLEIGH_BETA, 0.0)
+                    else:
+                        prop.SetValue(SMA.RAYLEIGH_BETA, coefficients_vector[1])
+                else:
+                    prop.SetValue(SMA.RAYLEIGH_BETA, coefficients_vector[1])
+        else:
+            current_process_info.SetValue(SMA.RAYLEIGH_ALPHA, coefficients_vector[0])
+            if current_process_info.Has(KM.COMPUTE_LUMPED_MASS_MATRIX):
+                if current_process_info[KM.COMPUTE_LUMPED_MASS_MATRIX]:
+                    current_process_info.SetValue(SMA.RAYLEIGH_BETA, 0.0)
+                else:
+                    current_process_info.SetValue(SMA.RAYLEIGH_BETA, coefficients_vector[1])
+            else:
+                current_process_info.SetValue(SMA.RAYLEIGH_BETA, coefficients_vector[1])
+
+    def _auxiliary_eigen_settings(self, solver_type):
+        """ This method returns the settings for the eigenvalues computations
+
+        Keyword arguments:
+        self -- It signifies an instance of a class.
+        """
+        if solver_type == "feast":
+            eigen_system_settings = KM.Parameters("""
+            {
+                "eigen_system_settings" : {
+                    "solver_type"           : "feast",
+                    "echo_level"            : 0,
+                    "tolerance"             : 1e-10,
+                    "symmetric"             : true,
+                    "e_min"                 : 0.0,
+                    "e_max"                 : 4.0e5,
+                    "number_of_eigenvalues" : 2,
+                    "subspace_size"         : 15
+                }
+            }
+            """)
+            self.mass_matrix_diagonal_value = 1.0
+            self.stiffness_matrix_diagonal_value = -1.0
+        else:
+            eigen_system_settings = KM.Parameters("""
+            {
+                "eigen_system_settings" : {
+                    "solver_type"       : "eigen_eigensystem"
+                }
+            }
+            """)
+            eigen_system_settings["eigen_system_settings"]["solver_type"].SetString(solver_type)
+            self.mass_matrix_diagonal_value = 0.0
+            self.stiffness_matrix_diagonal_value = 1.0
+        return eigen_system_settings
```

## KratosMultiphysics/StructuralMechanicsApplication/eigen_solution_output_process.py

 * *Ordering differences only*

```diff
@@ -1,45 +1,45 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.HDF5Application as KratosHDF5
-
-def Factory(settings, Model):
-    if(type(settings) != KratosMultiphysics.Parameters):
-        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
-    return EigenSolutionOutputProcess(Model, settings["Parameters"])
-
-class EigenSolutionOutputProcess(KratosMultiphysics.Process):
-    """A process for writing eigenvalue and eigenvector results."""
-
-    def __init__(self, Model, settings):
-        KratosMultiphysics.Process.__init__(self)
-        default_settings = KratosMultiphysics.Parameters("""
-            {
-                "help"            : "This process generates a postprocess file in a HDF5 file for eigenvalues",
-                "model_part_name" : "PLEASE_SPECIFY_MODEL_PART",
-                "file_settings" : {
-                },
-                "prefix" : "/EigenResults"
-            }
-            """)
-        self.settings = settings.Clone()
-        self.settings.ValidateAndAssignDefaults(default_settings)
-        self._model_part = Model[self.settings["model_part_name"].GetString()]
-
-    def ExecuteFinalize(self):
-        hdf5_file = self._GetFile()
-        prefix = self.settings["prefix"].GetString()
-        KratosHDF5.WriteDataValueContainer(hdf5_file, prefix, self._model_part.ProcessInfo)
-        nodal_io_settings = KratosMultiphysics.Parameters("""
-            {
-                "list_of_variables": ["EIGENVECTOR_MATRIX"],
-                "prefix" : ""
-            }
-            """)
-        nodal_io_settings["prefix"].SetString(prefix)
-        nodal_data_value_io = KratosHDF5.HDF5NodalDataValueIO(nodal_io_settings, hdf5_file)
-        nodal_data_value_io.WriteNodalResults(self._model_part.Nodes)
-
-    def _GetFile(self):
-        return KratosHDF5.HDF5File(self.settings["file_settings"])
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.HDF5Application as KratosHDF5
+
+def Factory(settings, Model):
+    if(type(settings) != KratosMultiphysics.Parameters):
+        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
+    return EigenSolutionOutputProcess(Model, settings["Parameters"])
+
+class EigenSolutionOutputProcess(KratosMultiphysics.Process):
+    """A process for writing eigenvalue and eigenvector results."""
+
+    def __init__(self, Model, settings):
+        KratosMultiphysics.Process.__init__(self)
+        default_settings = KratosMultiphysics.Parameters("""
+            {
+                "help"            : "This process generates a postprocess file in a HDF5 file for eigenvalues",
+                "model_part_name" : "PLEASE_SPECIFY_MODEL_PART",
+                "file_settings" : {
+                },
+                "prefix" : "/EigenResults"
+            }
+            """)
+        self.settings = settings.Clone()
+        self.settings.ValidateAndAssignDefaults(default_settings)
+        self._model_part = Model[self.settings["model_part_name"].GetString()]
+
+    def ExecuteFinalize(self):
+        hdf5_file = self._GetFile()
+        prefix = self.settings["prefix"].GetString()
+        KratosHDF5.WriteDataValueContainer(hdf5_file, prefix, self._model_part.ProcessInfo)
+        nodal_io_settings = KratosMultiphysics.Parameters("""
+            {
+                "list_of_variables": ["EIGENVECTOR_MATRIX"],
+                "prefix" : ""
+            }
+            """)
+        nodal_io_settings["prefix"].SetString(prefix)
+        nodal_data_value_io = KratosHDF5.HDF5NodalDataValueIO(nodal_io_settings, hdf5_file)
+        nodal_data_value_io.WriteNodalResults(self._model_part.Nodes)
+
+    def _GetFile(self):
+        return KratosHDF5.HDF5File(self.settings["file_settings"])
```

## KratosMultiphysics/StructuralMechanicsApplication/rve_analysis.py

 * *Ordering differences only*

```diff
@@ -1,366 +1,366 @@
-import KratosMultiphysics
-import KratosMultiphysics.StructuralMechanicsApplication
-from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_analysis import StructuralMechanicsAnalysis
-
-# Importing other libraries
-import math
-
-class RVEAnalysis(StructuralMechanicsAnalysis):
-    def __init__(self, model, project_parameters):
-
-        # input parameters of the analysis
-        self.boundary_mp_name = project_parameters["rve_settings"]["boundary_mp_name"].GetString()
-        self.averaging_mp_name = project_parameters["rve_settings"]["averaging_mp_name"].GetString()
-        self.print_rve_post = project_parameters["rve_settings"]["print_rve_post"].GetBool()
-        self.perturbation = project_parameters["rve_settings"]["perturbation"].GetDouble()
-
-        self.averaging_volume = -1.0  # it will be computed in initialize
-        self.domain_size = project_parameters["solver_settings"]["domain_size"].GetInt()
-        if self.domain_size == 2:
-            self.strain_size = 3
-        elif self.domain_size == 3:
-            self.strain_size = 6
-        else:
-            err_msg = "Wrong 'domain_size' value {}. Expected 2 or 3.".format(self.domain_size)
-            raise ValueError(err_msg)
-
-        # Pseudo time to be used for output
-        self.time = 0.0
-
-        self.populate_search_eps = 1e-4 ##tolerance in finding which conditions belong to the surface (will be multiplied by the lenght of the diagonal)
-        self.geometrical_search_tolerance = 1e-4 #tolerance to be used in the search of the condition it falls into
-
-        super().__init__(model, project_parameters)
-
-    # Here populate the submodelparts to be used for periodicity
-    def ModifyInitialGeometry(self):
-        super().ModifyInitialGeometry()
-
-        boundary_mp = self.model[self.boundary_mp_name]
-        averaging_mp = self.model[self.averaging_mp_name]
-
-        # Construct auxiliary modelparts
-        self.min_corner, self.max_corner = self._DetectBoundingBox(averaging_mp)
-        self._ConstructFaceModelParts(self.min_corner, self.max_corner, boundary_mp)
-
-        self.averaging_volume = 1.0
-        for i in range(self.domain_size):
-            self.averaging_volume *= self.max_corner[i]-self.min_corner[i]
-        KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "RVE undeformed averaging volume = ", self.averaging_volume)
-
-    def InitializeSolutionStep(self):
-        raise Exception("Should use the _CustomInitializeSolutionStep instead of this")
-
-    def __CustomInitializeSolutionStep(self, strain, boundary_mp, averaging_mp):
-        #reset position
-        KratosMultiphysics.VariableUtils().UpdateCurrentToInitialConfiguration(averaging_mp.Nodes)
-
-        self.ApplyBoundaryConditions()  # here the processes are called
-
-        # construct MPCs according to the provided strain
-        self._ApplyPeriodicity(strain, averaging_mp, boundary_mp)
-
-        # apply BCs for RVE according to the provided strain
-        self._ApplyMinimalConstraints(
-            averaging_mp, strain, self.min_corner, self.max_corner)
-
-        self.ChangeMaterialProperties()  # this is normally empty
-
-        self._GetSolver().InitializeSolutionStep()
-
-        KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "STEP: ", self._GetSolver().GetComputingModelPart().ProcessInfo[KratosMultiphysics.STEP])
-        KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "TIME: ", self.time)
-
-    def RunSolutionLoop(self):
-
-        perturbation = self.perturbation
-
-        boundary_mp = self.model[self.boundary_mp_name]
-        averaging_mp = self.model[self.averaging_mp_name]
-
-        stress_and_strain = []
-        if(self.strain_size == 3):  # 2D case - ordering s00 s11 s01
-            stress_and_strain.append(self._ComputeEquivalentStress(0, 0, perturbation, boundary_mp, averaging_mp))
-            stress_and_strain.append(self._ComputeEquivalentStress(1, 1, perturbation, boundary_mp, averaging_mp))
-            stress_and_strain.append(self._ComputeEquivalentStress(0, 1, perturbation, boundary_mp, averaging_mp))
-        elif(self.strain_size == 6):  # 3D case - ordering:  s00 s11 s22 s01 s12 s02
-            stress_and_strain.append(self._ComputeEquivalentStress(0, 0, perturbation, boundary_mp, averaging_mp))
-            stress_and_strain.append(self._ComputeEquivalentStress(1, 1, perturbation, boundary_mp, averaging_mp))
-            stress_and_strain.append(self._ComputeEquivalentStress(2, 2, perturbation, boundary_mp, averaging_mp))
-            stress_and_strain.append(self._ComputeEquivalentStress(0, 1, perturbation, boundary_mp, averaging_mp))
-            stress_and_strain.append(self._ComputeEquivalentStress(1, 2, perturbation, boundary_mp, averaging_mp))
-            stress_and_strain.append(self._ComputeEquivalentStress(0, 2, perturbation, boundary_mp, averaging_mp))
-
-        C = self._ComputeEquivalentElasticTensor(stress_and_strain, perturbation)
-        averaging_mp.SetValue(KratosMultiphysics.StructuralMechanicsApplication.ELASTICITY_TENSOR, C)
-        self._MatrixOutput(C)
-
-    def _DetectBoundingBox(self, mp):
-        min_corner = KratosMultiphysics.Array3()
-        min_corner[0] = 1e20
-        min_corner[1] = 1e20
-        min_corner[2] = 1e20
-
-        max_corner = KratosMultiphysics.Array3()
-        max_corner[0] = -1e20
-        max_corner[1] = -1e20
-        max_corner[2] = -1e20
-
-        for node in mp.Nodes:
-            x = node.X
-            min_corner[0] = min(min_corner[0], x)
-            max_corner[0] = max(max_corner[0], x)
-
-            y = node.Y
-            min_corner[1] = min(min_corner[1], y)
-            max_corner[1] = max(max_corner[1], y)
-
-            z = node.Z
-            min_corner[2] = min(min_corner[2], z)
-            max_corner[2] = max(max_corner[2], z)
-
-        KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "Boundng box detected")
-        KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "Min. corner = ", min_corner)
-        KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "Max. corner = ", max_corner)
-
-        return min_corner, max_corner
-
-    def __PopulateMp(self, face_name, coordinate, component, eps, mp):
-        if mp.NumberOfConditions() == 0:
-            raise Exception("Boundary_mp is expected to have conditions and has none")
-
-        mp = mp.GetRootModelPart()
-
-        if not mp.HasSubModelPart(face_name):
-            mp.CreateSubModelPart(face_name)
-        face_mp = mp.GetSubModelPart(face_name)
-
-        for cond in mp.Conditions:
-            xc = cond.GetGeometry().Center()
-            if abs(xc[component]-coordinate) < eps:
-                face_mp.AddCondition(cond)
-
-        node_ids = set()
-        for cond in face_mp.Conditions:
-            for node in cond.GetNodes():
-                if(not node.Is(KratosMultiphysics.SLAVE)):
-                    node_ids.add(node.Id)
-                    node.Set(KratosMultiphysics.SLAVE)
-
-        face_mp.AddNodes(list(node_ids))
-        return face_mp
-
-    def _ConstructFaceModelParts(self, min_corner, max_corner, mp):
-
-        diag_vect = max_corner - min_corner
-        diag_lenght = math.sqrt(diag_vect[0]**2+diag_vect[1]**2+diag_vect[2]**2 )
-        eps = self.populate_search_eps*diag_lenght
-
-        KratosMultiphysics.VariableUtils().SetFlag(KratosMultiphysics.SLAVE, False, mp.Nodes)
-        KratosMultiphysics.VariableUtils().SetFlag(KratosMultiphysics.MASTER, False, mp.Nodes)
-
-        # Populate the slave faces
-        self.max_x_face = self.__PopulateMp("max_x_face", max_corner[0], 0, eps, mp)
-        self.max_y_face = self.__PopulateMp("max_y_face", max_corner[1], 1, eps, mp)
-        if self.domain_size == 3:
-            self.max_z_face = self.__PopulateMp("max_z_face", max_corner[2], 2, eps, mp)
-
-        # First populate the master faces (min)
-        self.min_x_face = self.__PopulateMp("min_x_face", min_corner[0], 0, eps, mp)
-        self.min_y_face = self.__PopulateMp("min_y_face", min_corner[1], 1, eps, mp)
-        if self.domain_size == 3:
-            self.min_z_face = self.__PopulateMp("min_z_face", min_corner[2], 2, eps, mp)
-
-        if self.min_x_face.NumberOfConditions() == 0:
-            raise Exception("min_x_face has 0 conditions")
-        if self.min_y_face.NumberOfConditions() == 0:
-            raise Exception("min_y_face has 0 conditions")
-        if self.domain_size == 3 and self.min_z_face.NumberOfConditions() == 0:
-            raise Exception("min_z_face has 0 conditions")
-
-    def _SelectClosestNode(self, mp, coords):
-        min_distance = 1e30
-        selected_node = 0
-        for node in mp.Nodes:
-            dx = node.X0 - coords[0]
-            dy = node.Y0 - coords[1]
-            dz = node.Z0 - coords[2]
-            d = dx**2 + dy**2 + dz**2
-
-            if(d < min_distance):
-                selected_node = node
-                min_distance = d
-
-        return selected_node
-
-    # prescribed conditions to avoid rigid body motions
-    def _ApplyMinimalConstraints(self, mp, strain, min_corner, max_corner):
-        # point coinciding with the min_corner
-        node = self._SelectClosestNode(mp, min_corner)
-        node.Fix(KratosMultiphysics.DISPLACEMENT_X)
-        node.Fix(KratosMultiphysics.DISPLACEMENT_Y)
-        node.Fix(KratosMultiphysics.DISPLACEMENT_Z)
-
-        aux_orig_coords = [node.X0, node.Y0, node.Z0]
-        coords_min_corner = KratosMultiphysics.Vector(self.domain_size)
-        for i in range(self.domain_size):
-            coords_min_corner[i] = aux_orig_coords[i]
-
-        aux_disp_min_corner = strain*coords_min_corner
-
-        disp_min_corner = KratosMultiphysics.Array3(0.0)
-        for i in range(self.domain_size):
-            disp_min_corner[i] = aux_disp_min_corner[i]
-        node.SetSolutionStepValue(
-            KratosMultiphysics.DISPLACEMENT, 0, disp_min_corner)
-
-    def _ComputeEquivalentElasticTensor(self, stress_and_strain, perturbation):
-        C = KratosMultiphysics.Matrix(self.strain_size, self.strain_size)
-
-        for j in range(len(stress_and_strain)):
-            stress = stress_and_strain[j][0]
-            for i in range(self.strain_size):
-                C[i, j] = stress[i]
-
-        inverse_perturbation = KratosMultiphysics.Matrix(self.strain_size, self.strain_size)
-        inverse_perturbation.fill(0.0)
-        if(self.strain_size == 3):
-            inverse_perturbation[0, 0] = 1.0/perturbation
-            inverse_perturbation[1, 1] = 1.0/perturbation
-            inverse_perturbation[2, 2] = 0.5/perturbation
-        else:
-            inverse_perturbation[0, 0] = 1.0/perturbation
-            inverse_perturbation[1, 1] = 1.0/perturbation
-            inverse_perturbation[2, 2] = 1.0/perturbation
-            inverse_perturbation[3, 3] = 0.5/perturbation
-            inverse_perturbation[4, 4] = 0.5/perturbation
-            inverse_perturbation[5, 5] = 0.5/perturbation
-
-        C = C*inverse_perturbation
-
-        return C
-
-    def _MatrixOutput(self, C, filename=None):
-        if filename == None:
-            filename = "rve_elasticity_tensor_{}D.txt".format(self.domain_size)
-        f = open(filename, 'w')
-
-        if(self.strain_size == 3):  # 2D
-            f.write(str(C[0, 0]) + " " + str(C[0, 1]) +
-                    " " + str(C[0, 2]) + "\n")
-            f.write(str(C[1, 0]) + " " + str(C[1, 1]) +
-                    " " + str(C[1, 2]) + "\n")
-            f.write(str(C[2, 0]) + " " + str(C[2, 1]) +
-                    " " + str(C[2, 2]) + "\n")
-
-        elif(self.strain_size == 6):
-            for i in range(6):
-                f.write(str(C[i, 0]) + " " + str(C[i, 1]) + " " + str(C[i, 2]) +
-                        " " + str(C[i, 3]) + " " + str(C[i, 4]) + " " + str(C[i, 5]) + "\n")
-
-        f.close()
-
-    def _ComputeEquivalentStress(self, i, j, perturbation, boundary_mp, averaging_mp):
-        # Here use a pseudotime for output
-        self.time = self.time + 1.0
-        averaging_mp.GetRootModelPart().CloneTimeStep(self.time)
-
-        strain = KratosMultiphysics.Matrix(self.domain_size, self.domain_size)
-        strain.fill(0.0)
-
-        strain[i, j] = perturbation
-        strain[j, i] = perturbation
-
-        strain_vector = KratosMultiphysics.Vector(self.strain_size)
-        if self.strain_size == 3:
-            strain_vector[0] = strain[0, 0]
-            strain_vector[1] = strain[1, 1]
-            strain_vector[2] = 2.0*strain[0, 1]
-        elif self.strain_size == 6:
-            strain_vector[0] = strain[0, 0]
-            strain_vector[1] = strain[1, 1]
-            strain_vector[2] = strain[2, 2]
-            strain_vector[3] = 2.0*strain[0, 1]
-            strain_vector[4] = 2.0*strain[1, 2]
-            strain_vector[5] = 2.0*strain[0, 2]
-
-        self.__CustomInitializeSolutionStep(strain, boundary_mp, averaging_mp)
-
-        self._GetSolver().Predict()
-
-        self._GetSolver().SolveSolutionStep()
-        process_info = averaging_mp.ProcessInfo
-        avg_stress = KratosMultiphysics.Vector(self.strain_size)
-        avg_stress.fill(0.0)
-        measured_volume = 0.0
-
-        for elem in averaging_mp.Elements:
-            tmp = elem.CalculateOnIntegrationPoints(KratosMultiphysics.PK2_STRESS_VECTOR, process_info)
-            ngauss = len(tmp)
-            A = elem.GetGeometry().Area()
-            measured_volume += A
-            # TODO: this is only valid for gauss points with the same weight. should be generalized
-            Agauss = A/ngauss
-            for item in tmp:
-                avg_stress = avg_stress + item*Agauss
-
-        self._GetSolver().Clear()
-
-        KratosMultiphysics.Logger.PrintInfo(
-            self._GetSimulationName(), "Measured volume = ", measured_volume)
-
-        avg_stress /= self.averaging_volume
-
-        KratosMultiphysics.Logger.PrintInfo(
-            self._GetSimulationName(), "Applied strain = ", strain_vector)
-        KratosMultiphysics.Logger.PrintInfo(
-            self._GetSimulationName(), "Average stress = ", avg_stress)
-
-        if self.print_rve_post:
-            self.OutputSolutionStep()
-
-        # Reset position of nodes
-        KratosMultiphysics.VariableUtils().UpdateCurrentToInitialConfiguration(averaging_mp.Nodes)
-        zero = KratosMultiphysics.Vector(3)
-        zero[0] = 0.0
-        zero[1] = 0.0
-        zero[2] = 0.0
-        KratosMultiphysics.VariableUtils().SetNonHistoricalVariable(KratosMultiphysics.DISPLACEMENT, zero, averaging_mp.Nodes)
-        return avg_stress, strain_vector
-
-    def _ApplyPeriodicity(self, strain, volume_mp, boundary_mp):
-        # clear
-        for constraint in volume_mp.GetRootModelPart().MasterSlaveConstraints:
-            constraint.Set(KratosMultiphysics.TO_ERASE)
-        volume_mp.GetRootModelPart().RemoveMasterSlaveConstraintsFromAllLevels(
-            KratosMultiphysics.TO_ERASE)
-
-        dx = self.max_corner[0] - self.min_corner[0]
-        dy = self.max_corner[1] - self.min_corner[1]
-        if self.strain_size == 6:
-            dz = self.max_corner[2] - self.min_corner[2]
-
-        periodicity_utility = KratosMultiphysics.RVEPeriodicityUtility(self._GetSolver().GetComputingModelPart())
-
-        # assign periodicity to faces
-        direction_x = KratosMultiphysics.Vector([dx, 0.0, 0.0]) if self.strain_size == 6 else KratosMultiphysics.Vector([dx, 0.0])
-        periodicity_utility.AssignPeriodicity(self.min_x_face, self.max_x_face, strain, direction_x, self.geometrical_search_tolerance)
-        direction_y = KratosMultiphysics.Vector([0.0, dy, 0.0]) if self.strain_size == 6 else KratosMultiphysics.Vector([0.0, dy])
-        periodicity_utility.AssignPeriodicity(self.min_y_face, self.max_y_face, strain, direction_y, self.geometrical_search_tolerance)
-        if self.strain_size == 6:
-            direction_z = KratosMultiphysics.Vector([0.0, 0.0, dz])
-            periodicity_utility.AssignPeriodicity(self.min_z_face, self.max_z_face, strain, direction_z, self.geometrical_search_tolerance)
-
-        periodicity_utility.Finalize(KratosMultiphysics.DISPLACEMENT)
-
-        # start from the exact solution in the case of a constant strain
-        d = KratosMultiphysics.Array3(0.0)
-        x = KratosMultiphysics.Vector(self.domain_size)
-        for node in volume_mp.Nodes:
-            orig_coords = [node.X0, node.Y0, node.Z0]
-            for i in range(self.domain_size):
-                x[i] = orig_coords[i]
-            aux_d = strain*x
-            for i in range(self.domain_size):
-                d[i] = aux_d[i]
-            node.SetSolutionStepValue(KratosMultiphysics.DISPLACEMENT, 0, d)
+import KratosMultiphysics
+import KratosMultiphysics.StructuralMechanicsApplication
+from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_analysis import StructuralMechanicsAnalysis
+
+# Importing other libraries
+import math
+
+class RVEAnalysis(StructuralMechanicsAnalysis):
+    def __init__(self, model, project_parameters):
+
+        # input parameters of the analysis
+        self.boundary_mp_name = project_parameters["rve_settings"]["boundary_mp_name"].GetString()
+        self.averaging_mp_name = project_parameters["rve_settings"]["averaging_mp_name"].GetString()
+        self.print_rve_post = project_parameters["rve_settings"]["print_rve_post"].GetBool()
+        self.perturbation = project_parameters["rve_settings"]["perturbation"].GetDouble()
+
+        self.averaging_volume = -1.0  # it will be computed in initialize
+        self.domain_size = project_parameters["solver_settings"]["domain_size"].GetInt()
+        if self.domain_size == 2:
+            self.strain_size = 3
+        elif self.domain_size == 3:
+            self.strain_size = 6
+        else:
+            err_msg = "Wrong 'domain_size' value {}. Expected 2 or 3.".format(self.domain_size)
+            raise ValueError(err_msg)
+
+        # Pseudo time to be used for output
+        self.time = 0.0
+
+        self.populate_search_eps = 1e-4 ##tolerance in finding which conditions belong to the surface (will be multiplied by the lenght of the diagonal)
+        self.geometrical_search_tolerance = 1e-4 #tolerance to be used in the search of the condition it falls into
+
+        super().__init__(model, project_parameters)
+
+    # Here populate the submodelparts to be used for periodicity
+    def ModifyInitialGeometry(self):
+        super().ModifyInitialGeometry()
+
+        boundary_mp = self.model[self.boundary_mp_name]
+        averaging_mp = self.model[self.averaging_mp_name]
+
+        # Construct auxiliary modelparts
+        self.min_corner, self.max_corner = self._DetectBoundingBox(averaging_mp)
+        self._ConstructFaceModelParts(self.min_corner, self.max_corner, boundary_mp)
+
+        self.averaging_volume = 1.0
+        for i in range(self.domain_size):
+            self.averaging_volume *= self.max_corner[i]-self.min_corner[i]
+        KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "RVE undeformed averaging volume = ", self.averaging_volume)
+
+    def InitializeSolutionStep(self):
+        raise Exception("Should use the _CustomInitializeSolutionStep instead of this")
+
+    def __CustomInitializeSolutionStep(self, strain, boundary_mp, averaging_mp):
+        #reset position
+        KratosMultiphysics.VariableUtils().UpdateCurrentToInitialConfiguration(averaging_mp.Nodes)
+
+        self.ApplyBoundaryConditions()  # here the processes are called
+
+        # construct MPCs according to the provided strain
+        self._ApplyPeriodicity(strain, averaging_mp, boundary_mp)
+
+        # apply BCs for RVE according to the provided strain
+        self._ApplyMinimalConstraints(
+            averaging_mp, strain, self.min_corner, self.max_corner)
+
+        self.ChangeMaterialProperties()  # this is normally empty
+
+        self._GetSolver().InitializeSolutionStep()
+
+        KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "STEP: ", self._GetSolver().GetComputingModelPart().ProcessInfo[KratosMultiphysics.STEP])
+        KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "TIME: ", self.time)
+
+    def RunSolutionLoop(self):
+
+        perturbation = self.perturbation
+
+        boundary_mp = self.model[self.boundary_mp_name]
+        averaging_mp = self.model[self.averaging_mp_name]
+
+        stress_and_strain = []
+        if(self.strain_size == 3):  # 2D case - ordering s00 s11 s01
+            stress_and_strain.append(self._ComputeEquivalentStress(0, 0, perturbation, boundary_mp, averaging_mp))
+            stress_and_strain.append(self._ComputeEquivalentStress(1, 1, perturbation, boundary_mp, averaging_mp))
+            stress_and_strain.append(self._ComputeEquivalentStress(0, 1, perturbation, boundary_mp, averaging_mp))
+        elif(self.strain_size == 6):  # 3D case - ordering:  s00 s11 s22 s01 s12 s02
+            stress_and_strain.append(self._ComputeEquivalentStress(0, 0, perturbation, boundary_mp, averaging_mp))
+            stress_and_strain.append(self._ComputeEquivalentStress(1, 1, perturbation, boundary_mp, averaging_mp))
+            stress_and_strain.append(self._ComputeEquivalentStress(2, 2, perturbation, boundary_mp, averaging_mp))
+            stress_and_strain.append(self._ComputeEquivalentStress(0, 1, perturbation, boundary_mp, averaging_mp))
+            stress_and_strain.append(self._ComputeEquivalentStress(1, 2, perturbation, boundary_mp, averaging_mp))
+            stress_and_strain.append(self._ComputeEquivalentStress(0, 2, perturbation, boundary_mp, averaging_mp))
+
+        C = self._ComputeEquivalentElasticTensor(stress_and_strain, perturbation)
+        averaging_mp.SetValue(KratosMultiphysics.StructuralMechanicsApplication.ELASTICITY_TENSOR, C)
+        self._MatrixOutput(C)
+
+    def _DetectBoundingBox(self, mp):
+        min_corner = KratosMultiphysics.Array3()
+        min_corner[0] = 1e20
+        min_corner[1] = 1e20
+        min_corner[2] = 1e20
+
+        max_corner = KratosMultiphysics.Array3()
+        max_corner[0] = -1e20
+        max_corner[1] = -1e20
+        max_corner[2] = -1e20
+
+        for node in mp.Nodes:
+            x = node.X
+            min_corner[0] = min(min_corner[0], x)
+            max_corner[0] = max(max_corner[0], x)
+
+            y = node.Y
+            min_corner[1] = min(min_corner[1], y)
+            max_corner[1] = max(max_corner[1], y)
+
+            z = node.Z
+            min_corner[2] = min(min_corner[2], z)
+            max_corner[2] = max(max_corner[2], z)
+
+        KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "Boundng box detected")
+        KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "Min. corner = ", min_corner)
+        KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "Max. corner = ", max_corner)
+
+        return min_corner, max_corner
+
+    def __PopulateMp(self, face_name, coordinate, component, eps, mp):
+        if mp.NumberOfConditions() == 0:
+            raise Exception("Boundary_mp is expected to have conditions and has none")
+
+        mp = mp.GetRootModelPart()
+
+        if not mp.HasSubModelPart(face_name):
+            mp.CreateSubModelPart(face_name)
+        face_mp = mp.GetSubModelPart(face_name)
+
+        for cond in mp.Conditions:
+            xc = cond.GetGeometry().Center()
+            if abs(xc[component]-coordinate) < eps:
+                face_mp.AddCondition(cond)
+
+        node_ids = set()
+        for cond in face_mp.Conditions:
+            for node in cond.GetNodes():
+                if(not node.Is(KratosMultiphysics.SLAVE)):
+                    node_ids.add(node.Id)
+                    node.Set(KratosMultiphysics.SLAVE)
+
+        face_mp.AddNodes(list(node_ids))
+        return face_mp
+
+    def _ConstructFaceModelParts(self, min_corner, max_corner, mp):
+
+        diag_vect = max_corner - min_corner
+        diag_lenght = math.sqrt(diag_vect[0]**2+diag_vect[1]**2+diag_vect[2]**2 )
+        eps = self.populate_search_eps*diag_lenght
+
+        KratosMultiphysics.VariableUtils().SetFlag(KratosMultiphysics.SLAVE, False, mp.Nodes)
+        KratosMultiphysics.VariableUtils().SetFlag(KratosMultiphysics.MASTER, False, mp.Nodes)
+
+        # Populate the slave faces
+        self.max_x_face = self.__PopulateMp("max_x_face", max_corner[0], 0, eps, mp)
+        self.max_y_face = self.__PopulateMp("max_y_face", max_corner[1], 1, eps, mp)
+        if self.domain_size == 3:
+            self.max_z_face = self.__PopulateMp("max_z_face", max_corner[2], 2, eps, mp)
+
+        # First populate the master faces (min)
+        self.min_x_face = self.__PopulateMp("min_x_face", min_corner[0], 0, eps, mp)
+        self.min_y_face = self.__PopulateMp("min_y_face", min_corner[1], 1, eps, mp)
+        if self.domain_size == 3:
+            self.min_z_face = self.__PopulateMp("min_z_face", min_corner[2], 2, eps, mp)
+
+        if self.min_x_face.NumberOfConditions() == 0:
+            raise Exception("min_x_face has 0 conditions")
+        if self.min_y_face.NumberOfConditions() == 0:
+            raise Exception("min_y_face has 0 conditions")
+        if self.domain_size == 3 and self.min_z_face.NumberOfConditions() == 0:
+            raise Exception("min_z_face has 0 conditions")
+
+    def _SelectClosestNode(self, mp, coords):
+        min_distance = 1e30
+        selected_node = 0
+        for node in mp.Nodes:
+            dx = node.X0 - coords[0]
+            dy = node.Y0 - coords[1]
+            dz = node.Z0 - coords[2]
+            d = dx**2 + dy**2 + dz**2
+
+            if(d < min_distance):
+                selected_node = node
+                min_distance = d
+
+        return selected_node
+
+    # prescribed conditions to avoid rigid body motions
+    def _ApplyMinimalConstraints(self, mp, strain, min_corner, max_corner):
+        # point coinciding with the min_corner
+        node = self._SelectClosestNode(mp, min_corner)
+        node.Fix(KratosMultiphysics.DISPLACEMENT_X)
+        node.Fix(KratosMultiphysics.DISPLACEMENT_Y)
+        node.Fix(KratosMultiphysics.DISPLACEMENT_Z)
+
+        aux_orig_coords = [node.X0, node.Y0, node.Z0]
+        coords_min_corner = KratosMultiphysics.Vector(self.domain_size)
+        for i in range(self.domain_size):
+            coords_min_corner[i] = aux_orig_coords[i]
+
+        aux_disp_min_corner = strain*coords_min_corner
+
+        disp_min_corner = KratosMultiphysics.Array3(0.0)
+        for i in range(self.domain_size):
+            disp_min_corner[i] = aux_disp_min_corner[i]
+        node.SetSolutionStepValue(
+            KratosMultiphysics.DISPLACEMENT, 0, disp_min_corner)
+
+    def _ComputeEquivalentElasticTensor(self, stress_and_strain, perturbation):
+        C = KratosMultiphysics.Matrix(self.strain_size, self.strain_size)
+
+        for j in range(len(stress_and_strain)):
+            stress = stress_and_strain[j][0]
+            for i in range(self.strain_size):
+                C[i, j] = stress[i]
+
+        inverse_perturbation = KratosMultiphysics.Matrix(self.strain_size, self.strain_size)
+        inverse_perturbation.fill(0.0)
+        if(self.strain_size == 3):
+            inverse_perturbation[0, 0] = 1.0/perturbation
+            inverse_perturbation[1, 1] = 1.0/perturbation
+            inverse_perturbation[2, 2] = 0.5/perturbation
+        else:
+            inverse_perturbation[0, 0] = 1.0/perturbation
+            inverse_perturbation[1, 1] = 1.0/perturbation
+            inverse_perturbation[2, 2] = 1.0/perturbation
+            inverse_perturbation[3, 3] = 0.5/perturbation
+            inverse_perturbation[4, 4] = 0.5/perturbation
+            inverse_perturbation[5, 5] = 0.5/perturbation
+
+        C = C*inverse_perturbation
+
+        return C
+
+    def _MatrixOutput(self, C, filename=None):
+        if filename == None:
+            filename = "rve_elasticity_tensor_{}D.txt".format(self.domain_size)
+        f = open(filename, 'w')
+
+        if(self.strain_size == 3):  # 2D
+            f.write(str(C[0, 0]) + " " + str(C[0, 1]) +
+                    " " + str(C[0, 2]) + "\n")
+            f.write(str(C[1, 0]) + " " + str(C[1, 1]) +
+                    " " + str(C[1, 2]) + "\n")
+            f.write(str(C[2, 0]) + " " + str(C[2, 1]) +
+                    " " + str(C[2, 2]) + "\n")
+
+        elif(self.strain_size == 6):
+            for i in range(6):
+                f.write(str(C[i, 0]) + " " + str(C[i, 1]) + " " + str(C[i, 2]) +
+                        " " + str(C[i, 3]) + " " + str(C[i, 4]) + " " + str(C[i, 5]) + "\n")
+
+        f.close()
+
+    def _ComputeEquivalentStress(self, i, j, perturbation, boundary_mp, averaging_mp):
+        # Here use a pseudotime for output
+        self.time = self.time + 1.0
+        averaging_mp.GetRootModelPart().CloneTimeStep(self.time)
+
+        strain = KratosMultiphysics.Matrix(self.domain_size, self.domain_size)
+        strain.fill(0.0)
+
+        strain[i, j] = perturbation
+        strain[j, i] = perturbation
+
+        strain_vector = KratosMultiphysics.Vector(self.strain_size)
+        if self.strain_size == 3:
+            strain_vector[0] = strain[0, 0]
+            strain_vector[1] = strain[1, 1]
+            strain_vector[2] = 2.0*strain[0, 1]
+        elif self.strain_size == 6:
+            strain_vector[0] = strain[0, 0]
+            strain_vector[1] = strain[1, 1]
+            strain_vector[2] = strain[2, 2]
+            strain_vector[3] = 2.0*strain[0, 1]
+            strain_vector[4] = 2.0*strain[1, 2]
+            strain_vector[5] = 2.0*strain[0, 2]
+
+        self.__CustomInitializeSolutionStep(strain, boundary_mp, averaging_mp)
+
+        self._GetSolver().Predict()
+
+        self._GetSolver().SolveSolutionStep()
+        process_info = averaging_mp.ProcessInfo
+        avg_stress = KratosMultiphysics.Vector(self.strain_size)
+        avg_stress.fill(0.0)
+        measured_volume = 0.0
+
+        for elem in averaging_mp.Elements:
+            tmp = elem.CalculateOnIntegrationPoints(KratosMultiphysics.PK2_STRESS_VECTOR, process_info)
+            ngauss = len(tmp)
+            A = elem.GetGeometry().Area()
+            measured_volume += A
+            # TODO: this is only valid for gauss points with the same weight. should be generalized
+            Agauss = A/ngauss
+            for item in tmp:
+                avg_stress = avg_stress + item*Agauss
+
+        self._GetSolver().Clear()
+
+        KratosMultiphysics.Logger.PrintInfo(
+            self._GetSimulationName(), "Measured volume = ", measured_volume)
+
+        avg_stress /= self.averaging_volume
+
+        KratosMultiphysics.Logger.PrintInfo(
+            self._GetSimulationName(), "Applied strain = ", strain_vector)
+        KratosMultiphysics.Logger.PrintInfo(
+            self._GetSimulationName(), "Average stress = ", avg_stress)
+
+        if self.print_rve_post:
+            self.OutputSolutionStep()
+
+        # Reset position of nodes
+        KratosMultiphysics.VariableUtils().UpdateCurrentToInitialConfiguration(averaging_mp.Nodes)
+        zero = KratosMultiphysics.Vector(3)
+        zero[0] = 0.0
+        zero[1] = 0.0
+        zero[2] = 0.0
+        KratosMultiphysics.VariableUtils().SetNonHistoricalVariable(KratosMultiphysics.DISPLACEMENT, zero, averaging_mp.Nodes)
+        return avg_stress, strain_vector
+
+    def _ApplyPeriodicity(self, strain, volume_mp, boundary_mp):
+        # clear
+        for constraint in volume_mp.GetRootModelPart().MasterSlaveConstraints:
+            constraint.Set(KratosMultiphysics.TO_ERASE)
+        volume_mp.GetRootModelPart().RemoveMasterSlaveConstraintsFromAllLevels(
+            KratosMultiphysics.TO_ERASE)
+
+        dx = self.max_corner[0] - self.min_corner[0]
+        dy = self.max_corner[1] - self.min_corner[1]
+        if self.strain_size == 6:
+            dz = self.max_corner[2] - self.min_corner[2]
+
+        periodicity_utility = KratosMultiphysics.RVEPeriodicityUtility(self._GetSolver().GetComputingModelPart())
+
+        # assign periodicity to faces
+        direction_x = KratosMultiphysics.Vector([dx, 0.0, 0.0]) if self.strain_size == 6 else KratosMultiphysics.Vector([dx, 0.0])
+        periodicity_utility.AssignPeriodicity(self.min_x_face, self.max_x_face, strain, direction_x, self.geometrical_search_tolerance)
+        direction_y = KratosMultiphysics.Vector([0.0, dy, 0.0]) if self.strain_size == 6 else KratosMultiphysics.Vector([0.0, dy])
+        periodicity_utility.AssignPeriodicity(self.min_y_face, self.max_y_face, strain, direction_y, self.geometrical_search_tolerance)
+        if self.strain_size == 6:
+            direction_z = KratosMultiphysics.Vector([0.0, 0.0, dz])
+            periodicity_utility.AssignPeriodicity(self.min_z_face, self.max_z_face, strain, direction_z, self.geometrical_search_tolerance)
+
+        periodicity_utility.Finalize(KratosMultiphysics.DISPLACEMENT)
+
+        # start from the exact solution in the case of a constant strain
+        d = KratosMultiphysics.Array3(0.0)
+        x = KratosMultiphysics.Vector(self.domain_size)
+        for node in volume_mp.Nodes:
+            orig_coords = [node.X0, node.Y0, node.Z0]
+            for i in range(self.domain_size):
+                x[i] = orig_coords[i]
+            aux_d = strain*x
+            for i in range(self.domain_size):
+                d[i] = aux_d[i]
+            node.SetSolutionStepValue(KratosMultiphysics.DISPLACEMENT, 0, d)
```

## KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_prebuckling_analysis.py

 * *Ordering differences only*

```diff
@@ -1,98 +1,98 @@
-# Importing Kratos
-import KratosMultiphysics
-# Importing the base class
-from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_analysis import StructuralMechanicsAnalysis
-
-class StructuralMechanicsPrebucklingAnalysis(StructuralMechanicsAnalysis):
-    def __init__(self, model, project_parameters):
-        super().__init__(model, project_parameters)
-
-    def Initialize(self):
-        """This function initializes the StructuralMechanicsPrebucklingAnalysis
-        Usage: It is designed to be called ONCE, BEFORE the execution of the solution-loop
-        """
-        problem_data = self.project_parameters["problem_data"]
-        if problem_data.Has("start_time"):
-            warn_msg = 'Parameter TIME is used as load factor. \n'
-            warn_msg += 'Parameter "start_time" will be ignored!'
-            KratosMultiphysics.Logger.PrintWarning("StructuralMechanicsPrebucklingAnalysis; Warning", warn_msg)
-        else:
-            # Create dummy parameter
-            aux_settings = KratosMultiphysics.Parameters(r"""{ "start_time" : 1.0 }""")
-            problem_data.AddMissingParameters(aux_settings)
-
-        if problem_data.Has("end_time"):
-            warn_msg = 'Parameter TIME is used as load factor. \n'
-            warn_msg += 'Parameter "end_time" will be ignored!'
-            KratosMultiphysics.Logger.PrintWarning("StructuralMechanicsPrebucklingAnalysis; Warning", warn_msg)
-        else:
-            # Create dummy paramter
-            aux_settings = KratosMultiphysics.Parameters(r"""{ "end_time" : 1.0 }""")
-            problem_data.AddMissingParameters(aux_settings)
-
-        # Initialize super class
-        super().Initialize()
-
-        # Initialize solution stepping
-        self.step = 0
-        self.time = 1
-        if not problem_data.Has("nsteps"):
-            raise Exception("StructuralMechanicsPrebucklingAnalysis: " + 'Maximum number of steps "nsteps" must be provided"!')
-        else:
-            self.nsteps = problem_data["nsteps"].GetInt()
-
-        ## If the echo level is high enough, print the complete list of settings used to run the simualtion
-        if self.echo_level > 1:
-            with open("ProjectParametersOutput.json", 'w') as parameter_output_file:
-                parameter_output_file.write(self.project_parameters.PrettyPrintJsonString())
-
-        KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "Analysis -START- ")
-
-    def RunSolutionLoop(self):
-        '''Break Solution Loop when Buckling Analysis is converged,
-           or maximum step number is reached
-        '''
-        while self.KeepAdvancingSolutionLoop():
-            self.time = self._GetSolver().AdvanceInTime(self.time)
-            self.step += 1
-            self.InitializeSolutionStep()
-            self._GetSolver().Predict()
-            is_converged = self._GetSolver().SolveSolutionStep()
-            self.FinalizeSolutionStep()
-            self.OutputSolutionStep()
-            if self._GetSolver()._GetSolutionStrategy().GetSolutionFoundFlag():
-                break
-
-    def KeepAdvancingSolutionLoop(self):
-        """This function specifies the stopping criteria for breaking the solution loop"""
-        return self.step < self.nsteps
-
-    def FinalizeSolutionStep(self):
-        ''' This function is overriden to postprocess eigenvalues only every second load step.
-        Print eigenvalues after every small load increment'''
-        self._GetSolver().FinalizeSolutionStep()
-        for process in self._GetListOfProcesses():
-            if( process.__class__.__name__ != "PostprocessEigenvaluesProcess" ):
-                process.ExecuteFinalizeSolutionStep()
-            elif ( (self.step % 2 == 0) & (self.step > 0 ) ):
-                process.ExecuteFinalizeSolutionStep()
-
-    def OutputSolutionStep(self):
-        ''' This function is overriden to print output only every second load step.
-        Print output after every path following load step'''
-        is_output_step = False
-        for output_process in self._GetListOfOutputProcesses():
-            if output_process.IsOutputStep():
-                is_output_step = True
-                break
-
-        if is_output_step: # at least one of the output processes will print output
-            for process in self._GetListOfProcesses():
-                process.ExecuteBeforeOutputStep()
-
-            for output_process in self._GetListOfOutputProcesses():
-                if( output_process.IsOutputStep() & (self.step % 2 == 1) ):
-                    output_process.PrintOutput()
-
-            for process in self._GetListOfProcesses():
-                process.ExecuteAfterOutputStep()
+# Importing Kratos
+import KratosMultiphysics
+# Importing the base class
+from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_analysis import StructuralMechanicsAnalysis
+
+class StructuralMechanicsPrebucklingAnalysis(StructuralMechanicsAnalysis):
+    def __init__(self, model, project_parameters):
+        super().__init__(model, project_parameters)
+
+    def Initialize(self):
+        """This function initializes the StructuralMechanicsPrebucklingAnalysis
+        Usage: It is designed to be called ONCE, BEFORE the execution of the solution-loop
+        """
+        problem_data = self.project_parameters["problem_data"]
+        if problem_data.Has("start_time"):
+            warn_msg = 'Parameter TIME is used as load factor. \n'
+            warn_msg += 'Parameter "start_time" will be ignored!'
+            KratosMultiphysics.Logger.PrintWarning("StructuralMechanicsPrebucklingAnalysis; Warning", warn_msg)
+        else:
+            # Create dummy parameter
+            aux_settings = KratosMultiphysics.Parameters(r"""{ "start_time" : 1.0 }""")
+            problem_data.AddMissingParameters(aux_settings)
+
+        if problem_data.Has("end_time"):
+            warn_msg = 'Parameter TIME is used as load factor. \n'
+            warn_msg += 'Parameter "end_time" will be ignored!'
+            KratosMultiphysics.Logger.PrintWarning("StructuralMechanicsPrebucklingAnalysis; Warning", warn_msg)
+        else:
+            # Create dummy paramter
+            aux_settings = KratosMultiphysics.Parameters(r"""{ "end_time" : 1.0 }""")
+            problem_data.AddMissingParameters(aux_settings)
+
+        # Initialize super class
+        super().Initialize()
+
+        # Initialize solution stepping
+        self.step = 0
+        self.time = 1
+        if not problem_data.Has("nsteps"):
+            raise Exception("StructuralMechanicsPrebucklingAnalysis: " + 'Maximum number of steps "nsteps" must be provided"!')
+        else:
+            self.nsteps = problem_data["nsteps"].GetInt()
+
+        ## If the echo level is high enough, print the complete list of settings used to run the simualtion
+        if self.echo_level > 1:
+            with open("ProjectParametersOutput.json", 'w') as parameter_output_file:
+                parameter_output_file.write(self.project_parameters.PrettyPrintJsonString())
+
+        KratosMultiphysics.Logger.PrintInfo(self._GetSimulationName(), "Analysis -START- ")
+
+    def RunSolutionLoop(self):
+        '''Break Solution Loop when Buckling Analysis is converged,
+           or maximum step number is reached
+        '''
+        while self.KeepAdvancingSolutionLoop():
+            self.time = self._GetSolver().AdvanceInTime(self.time)
+            self.step += 1
+            self.InitializeSolutionStep()
+            self._GetSolver().Predict()
+            is_converged = self._GetSolver().SolveSolutionStep()
+            self.FinalizeSolutionStep()
+            self.OutputSolutionStep()
+            if self._GetSolver()._GetSolutionStrategy().GetSolutionFoundFlag():
+                break
+
+    def KeepAdvancingSolutionLoop(self):
+        """This function specifies the stopping criteria for breaking the solution loop"""
+        return self.step < self.nsteps
+
+    def FinalizeSolutionStep(self):
+        ''' This function is overriden to postprocess eigenvalues only every second load step.
+        Print eigenvalues after every small load increment'''
+        self._GetSolver().FinalizeSolutionStep()
+        for process in self._GetListOfProcesses():
+            if( process.__class__.__name__ != "PostprocessEigenvaluesProcess" ):
+                process.ExecuteFinalizeSolutionStep()
+            elif ( (self.step % 2 == 0) & (self.step > 0 ) ):
+                process.ExecuteFinalizeSolutionStep()
+
+    def OutputSolutionStep(self):
+        ''' This function is overriden to print output only every second load step.
+        Print output after every path following load step'''
+        is_output_step = False
+        for output_process in self._GetListOfOutputProcesses():
+            if output_process.IsOutputStep():
+                is_output_step = True
+                break
+
+        if is_output_step: # at least one of the output processes will print output
+            for process in self._GetListOfProcesses():
+                process.ExecuteBeforeOutputStep()
+
+            for output_process in self._GetListOfOutputProcesses():
+                if( output_process.IsOutputStep() & (self.step % 2 == 1) ):
+                    output_process.PrintOutput()
+
+            for process in self._GetListOfProcesses():
+                process.ExecuteAfterOutputStep()
```

## KratosMultiphysics/StructuralMechanicsApplication/eigen_solution_input_process.py

 * *Ordering differences only*

```diff
@@ -1,45 +1,45 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.HDF5Application as KratosHDF5
-
-def Factory(settings, Model):
-    if(type(settings) != KratosMultiphysics.Parameters):
-        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
-    return EigenSolutionInputProcess(Model, settings["Parameters"])
-
-class EigenSolutionInputProcess(KratosMultiphysics.Process):
-    """A process for reading eigenvalue and eigenvector results."""
-
-    def __init__(self, Model, settings):
-        KratosMultiphysics.Process.__init__(self)
-        default_settings = KratosMultiphysics.Parameters("""
-            {
-                "help"            : "A process for reading eigenvalue and eigenvector results.",
-                "model_part_name" : "PLEASE_SPECIFY_MODEL_PART",
-                "file_settings" : {
-                },
-                "prefix" : "/EigenResults"
-            }
-            """)
-        self.settings = settings.Clone()
-        self.settings.ValidateAndAssignDefaults(default_settings)
-        self._model_part = Model[self.settings["model_part_name"].GetString()]
-
-    def ExecuteInitialize(self):
-        hdf5_file = self._GetFile()
-        prefix = self.settings["prefix"].GetString()
-        KratosHDF5.ReadDataValueContainer(hdf5_file, prefix, self._model_part.ProcessInfo)
-        nodal_io_settings = KratosMultiphysics.Parameters("""
-            {
-                "list_of_variables": ["EIGENVECTOR_MATRIX"],
-                "prefix" : ""
-            }
-            """)
-        nodal_io_settings["prefix"].SetString(prefix)
-        nodal_data_value_io = KratosHDF5.HDF5NodalDataValueIO(nodal_io_settings, hdf5_file)
-        nodal_data_value_io.ReadNodalResults(self._model_part.Nodes, self._model_part.GetCommunicator())
-
-    def _GetFile(self):
-        return KratosHDF5.HDF5File(self.settings["file_settings"])
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.HDF5Application as KratosHDF5
+
+def Factory(settings, Model):
+    if(type(settings) != KratosMultiphysics.Parameters):
+        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
+    return EigenSolutionInputProcess(Model, settings["Parameters"])
+
+class EigenSolutionInputProcess(KratosMultiphysics.Process):
+    """A process for reading eigenvalue and eigenvector results."""
+
+    def __init__(self, Model, settings):
+        KratosMultiphysics.Process.__init__(self)
+        default_settings = KratosMultiphysics.Parameters("""
+            {
+                "help"            : "A process for reading eigenvalue and eigenvector results.",
+                "model_part_name" : "PLEASE_SPECIFY_MODEL_PART",
+                "file_settings" : {
+                },
+                "prefix" : "/EigenResults"
+            }
+            """)
+        self.settings = settings.Clone()
+        self.settings.ValidateAndAssignDefaults(default_settings)
+        self._model_part = Model[self.settings["model_part_name"].GetString()]
+
+    def ExecuteInitialize(self):
+        hdf5_file = self._GetFile()
+        prefix = self.settings["prefix"].GetString()
+        KratosHDF5.ReadDataValueContainer(hdf5_file, prefix, self._model_part.ProcessInfo)
+        nodal_io_settings = KratosMultiphysics.Parameters("""
+            {
+                "list_of_variables": ["EIGENVECTOR_MATRIX"],
+                "prefix" : ""
+            }
+            """)
+        nodal_io_settings["prefix"].SetString(prefix)
+        nodal_data_value_io = KratosHDF5.HDF5NodalDataValueIO(nodal_io_settings, hdf5_file)
+        nodal_data_value_io.ReadNodalResults(self._model_part.Nodes, self._model_part.GetCommunicator())
+
+    def _GetFile(self):
+        return KratosHDF5.HDF5File(self.settings["file_settings"])
```

## KratosMultiphysics/StructuralMechanicsApplication/set_cartesian_local_axes_process.py

 * *Ordering differences only*

```diff
@@ -1,26 +1,26 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-import KratosMultiphysics.StructuralMechanicsApplication as SMA
-from KratosMultiphysics import Logger
-
-def Factory(settings, Model):
-    if not isinstance(settings, KM.Parameters):
-        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
-
-    default_settings = KM.Parameters(
-        """{
-            "model_part_name"      : "set_model_part_name",
-            "cartesian_local_axis" : [[1.0,0.0,0.0],[0.0,1.0,0.0]],
-            "update_at_each_step"  : false
-        }""");
-    process_settings = settings["Parameters"]
-    process_settings.ValidateAndAssignDefaults(default_settings)
-    computing_model_part = Model[process_settings["model_part_name"].GetString()]
-
-    Logger.PrintInfo("SetCartesianLocalAxesProcess:: ","Setting the oriented local axes...")
-    process_settings.RemoveValue("model_part_name")
-    return SMA.SetCartesianLocalAxesProcess(computing_model_part, process_settings)
-
-
-
-
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+import KratosMultiphysics.StructuralMechanicsApplication as SMA
+from KratosMultiphysics import Logger
+
+def Factory(settings, Model):
+    if not isinstance(settings, KM.Parameters):
+        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
+
+    default_settings = KM.Parameters(
+        """{
+            "model_part_name"      : "set_model_part_name",
+            "cartesian_local_axis" : [[1.0,0.0,0.0],[0.0,1.0,0.0]],
+            "update_at_each_step"  : false
+        }""");
+    process_settings = settings["Parameters"]
+    process_settings.ValidateAndAssignDefaults(default_settings)
+    computing_model_part = Model[process_settings["model_part_name"].GetString()]
+
+    Logger.PrintInfo("SetCartesianLocalAxesProcess:: ","Setting the oriented local axes...")
+    process_settings.RemoveValue("model_part_name")
+    return SMA.SetCartesianLocalAxesProcess(computing_model_part, process_settings)
+
+
+
+
```

## KratosMultiphysics/StructuralMechanicsApplication/simplified_nodal_contact_process.py

 * *Ordering differences only*

```diff
@@ -1,184 +1,184 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-import KratosMultiphysics.python_linear_solver_factory as linear_solver_factory
-
-def Factory(settings, Model):
-    if not isinstance(settings, KratosMultiphysics.Parameters):
-        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
-    return SimplifiedNodalContactProcess(Model, settings["Parameters"])
-
-class SimplifiedNodalContactProcess(KratosMultiphysics.Process):
-    def __init__(self, Model, settings):
-        KratosMultiphysics.Process.__init__(self)
-        self.settings = settings;
-        self.Model = Model
-
-
-    def ExecuteInitialize(self):
-        default_settings = KratosMultiphysics.Parameters(
-            """
-            {
-                "help"                       :"This process computes a simplified contact problem nodally using the distance to define the penalty value",
-                "background_domain"          : "name_of_background_model_part",
-                "background_contact_surface" : "name_of_surface_of_contact",
-                "background_contact_volume"  : "inside_of_the_contact_volume",
-                "active_contact_surface"     : "active_contact_surface",
-                "active_contact_body"        : "active_contact_body",
-                "contact_property_id"        : 1
-            }
-            """
-        );
-
-        self.settings.ValidateAndAssignDefaults(default_settings)
-
-        KratosMultiphysics.Process.__init__(self)
-
-        #modelparts in the background (to be used in detecting contact and computing distances to the wall)
-        self.background_domain                = self.Model[self.settings["background_domain"].GetString()]
-        self.background_contact_surface       = self.Model[self.settings["background_contact_surface"].GetString()]
-        self.background_contact_volume        = self.Model[self.settings["background_contact_volume"].GetString()]
-        self.background_all = self.background_domain
-
-        #modelparts on the structure
-        self.active_contact_body            = self.Model[self.settings["active_contact_body"].GetString()]
-        self.active_contact_surface       = self.Model[self.settings["active_contact_surface"].GetString()]
-
-        self.domain_size = self.background_domain.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE]
-
-        zero = KratosMultiphysics.Vector(3)
-        zero[0] = 0.0
-        zero[1] = 0.0
-        zero[2] = 0.0
-
-        ################## STRUCTURAL SIDE
-        #compute the normals for the structure
-        KratosMultiphysics.BodyNormalCalculationUtils().CalculateBodyNormals(self.active_contact_body,self.domain_size)
-
-        max_cond_id = 1
-        for cond in self.active_contact_body.Conditions:
-            if(cond.Id > max_cond_id):
-                max_cond_id = cond.Id
-
-        prop_id = self.settings["contact_property_id"].GetInt()
-        prop = self.active_contact_body.Properties[prop_id]
-
-        if not prop.Has(KratosMultiphysics.YOUNG_MODULUS):
-            raise Exception("property with Id ",prop_id," does not define YOUNG_MODULUS and cannot be used in contact")
-
-
-        if(self.domain_size == 2):
-            self.locate_on_background = KratosMultiphysics.BinBasedFastPointLocator2D(self.background_all)
-            contact_condition_type = "PointContactCondition2D1N"
-        else:
-            self.locate_on_background = KratosMultiphysics.BinBasedFastPointLocator3D(self.background_all)
-            contact_condition_type = "PointContactCondition3D1N"
-        self.locate_on_background.UpdateSearchDatabase()
-
-        i = max_cond_id + 1
-        for node in self.active_contact_surface.Nodes: #nodes on the skin of the rotor
-            self.active_contact_surface.GetRootModelPart().GetSubModelPart("computing_domain").CreateNewCondition(contact_condition_type,i,[node.Id], prop)
-            i+=1
-            node.Fix(KratosMultiphysics.DISTANCE)
-            node.SetSolutionStepValue(KratosMultiphysics.DISTANCE,0,0.0)
-            node.SetValue(KratosMultiphysics.DISTANCE,0.0)
-            node.SetValue(KratosMultiphysics.DISPLACEMENT,zero)
-
-
-        for node in self.active_contact_body.Nodes:
-            if(not node.IsFixed(KratosMultiphysics.DISTANCE)):
-                node.SetSolutionStepValue(KratosMultiphysics.DISTANCE,0,-1.0)
-                print(node.Id)
-
-
-
-        ################## BACKGROUND SIDE
-
-        ##assigning the distances
-        for node in self.background_contact_surface.Nodes: #nodes on the contact surface
-            node.Fix(KratosMultiphysics.DISTANCE)
-            node.SetSolutionStepValue(KratosMultiphysics.DISTANCE,0,0.0)
-
-        for node in self.background_domain.Nodes:
-            if(node.IsFixed(KratosMultiphysics.DISTANCE) == False):
-                node.SetSolutionStepValue(KratosMultiphysics.DISTANCE,0,-1.0)
-
-        for node in self.background_contact_volume.Nodes: #nodes inside the "air"
-            if(node.IsFixed(KratosMultiphysics.DISTANCE) == False):
-                node.SetSolutionStepValue(KratosMultiphysics.DISTANCE,0,1.0)
-
-
-
-
-        #computing distance from the contact surface on the background mesh
-        distance_linear_solver_settings = KratosMultiphysics.Parameters( """{
-                                       "solver_type" : "amgcl"
-                                   } """)
-        distance_linear_solver = linear_solver_factory.ConstructSolver(distance_linear_solver_settings)
-
-        max_iterations=30
-        if(self.domain_size == 2):
-            self.distance_calculator = KratosMultiphysics.VariationalDistanceCalculationProcess2D(self.background_all, distance_linear_solver, max_iterations)
-        else:
-            self.distance_calculator = KratosMultiphysics.VariationalDistanceCalculationProcess3D(self.background_all, distance_linear_solver, max_iterations)
-        self.distance_calculator.Execute()
-
-        for node in self.background_all.Nodes:
-            node.SetValue(KratosMultiphysics.DISTANCE, node.GetSolutionStepValue(KratosMultiphysics.DISTANCE))
-
-        if(self.domain_size == 2):
-            KratosMultiphysics.ComputeNonHistoricalNodalGradientProcess2D(self.background_all, KratosMultiphysics.DISTANCE, KratosMultiphysics.DISTANCE_GRADIENT, KratosMultiphysics.NODAL_AREA).Execute()
-        else:
-            KratosMultiphysics.ComputeNonHistoricalNodalGradientProcess3D(self.background_all, KratosMultiphysics.DISTANCE, KratosMultiphysics.DISTANCE_GRADIENT, KratosMultiphysics.NODAL_AREA).Execute()
-        print("finished initialize")
-
-    def ExecuteInitializeSolutionStep(self):
-        KratosMultiphysics.BodyNormalCalculationUtils().CalculateBodyNormals(self.active_contact_body,self.domain_size)
-
-        zero = KratosMultiphysics.Vector(3)
-        zero[0] = 0.0
-        zero[1] = 0.0
-        zero[2] = 0.0
-
-        N = KratosMultiphysics.Vector(self.domain_size+1)
-        coords =  KratosMultiphysics.Array3()
-        pelem =  KratosMultiphysics.Element(-1) #UGLY! here i create an empty pointer
-        grad =  KratosMultiphysics.Vector(3)
-
-        for node in self.active_contact_surface.Nodes: #nodes on the skin of the rotor
-
-            #save the displacement
-            disp = node.GetSolutionStepValue(KratosMultiphysics.DISPLACEMENT)
-            node.SetValue(KratosMultiphysics.DISPLACEMENT,disp)
-
-            #now find if inside
-            coords[0] = node.X
-            coords[1] = node.Y
-            coords[2] = node.Z
-            found = self.locate_on_background.FindPointOnMesh(coords, N, pelem, 1000, 1e-9)
-
-            if(found):
-                d = 0.0
-                grad[0] = 0.0
-                grad[1] = 0.0
-                grad[2] = 0.0
-                k = 0
-                for p in pelem.GetNodes():
-                    d += N[k]*p.GetSolutionStepValue(KratosMultiphysics.DISTANCE)
-
-                    g = p.GetValue(KratosMultiphysics.DISTANCE_GRADIENT)
-                    grad[0] += N[k]*g[0]
-                    grad[1] += N[k]*g[1]
-                    grad[2] += N[k]*g[2]
-
-                    k+=1
-                node.SetValue(KratosMultiphysics.DISTANCE,d)
-                node.SetValue(KratosMultiphysics.DISTANCE_GRADIENT,grad)
-            else:
-                node.SetValue(KratosMultiphysics.DISTANCE,0.0)
-                node.SetValue(KratosMultiphysics.DISTANCE_GRADIENT,zero)
-
-
-
-
-
+# Importing the Kratos Library
+import KratosMultiphysics
+
+import KratosMultiphysics.python_linear_solver_factory as linear_solver_factory
+
+def Factory(settings, Model):
+    if not isinstance(settings, KratosMultiphysics.Parameters):
+        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
+    return SimplifiedNodalContactProcess(Model, settings["Parameters"])
+
+class SimplifiedNodalContactProcess(KratosMultiphysics.Process):
+    def __init__(self, Model, settings):
+        KratosMultiphysics.Process.__init__(self)
+        self.settings = settings;
+        self.Model = Model
+
+
+    def ExecuteInitialize(self):
+        default_settings = KratosMultiphysics.Parameters(
+            """
+            {
+                "help"                       :"This process computes a simplified contact problem nodally using the distance to define the penalty value",
+                "background_domain"          : "name_of_background_model_part",
+                "background_contact_surface" : "name_of_surface_of_contact",
+                "background_contact_volume"  : "inside_of_the_contact_volume",
+                "active_contact_surface"     : "active_contact_surface",
+                "active_contact_body"        : "active_contact_body",
+                "contact_property_id"        : 1
+            }
+            """
+        );
+
+        self.settings.ValidateAndAssignDefaults(default_settings)
+
+        KratosMultiphysics.Process.__init__(self)
+
+        #modelparts in the background (to be used in detecting contact and computing distances to the wall)
+        self.background_domain                = self.Model[self.settings["background_domain"].GetString()]
+        self.background_contact_surface       = self.Model[self.settings["background_contact_surface"].GetString()]
+        self.background_contact_volume        = self.Model[self.settings["background_contact_volume"].GetString()]
+        self.background_all = self.background_domain
+
+        #modelparts on the structure
+        self.active_contact_body            = self.Model[self.settings["active_contact_body"].GetString()]
+        self.active_contact_surface       = self.Model[self.settings["active_contact_surface"].GetString()]
+
+        self.domain_size = self.background_domain.ProcessInfo[KratosMultiphysics.DOMAIN_SIZE]
+
+        zero = KratosMultiphysics.Vector(3)
+        zero[0] = 0.0
+        zero[1] = 0.0
+        zero[2] = 0.0
+
+        ################## STRUCTURAL SIDE
+        #compute the normals for the structure
+        KratosMultiphysics.BodyNormalCalculationUtils().CalculateBodyNormals(self.active_contact_body,self.domain_size)
+
+        max_cond_id = 1
+        for cond in self.active_contact_body.Conditions:
+            if(cond.Id > max_cond_id):
+                max_cond_id = cond.Id
+
+        prop_id = self.settings["contact_property_id"].GetInt()
+        prop = self.active_contact_body.Properties[prop_id]
+
+        if not prop.Has(KratosMultiphysics.YOUNG_MODULUS):
+            raise Exception("property with Id ",prop_id," does not define YOUNG_MODULUS and cannot be used in contact")
+
+
+        if(self.domain_size == 2):
+            self.locate_on_background = KratosMultiphysics.BinBasedFastPointLocator2D(self.background_all)
+            contact_condition_type = "PointContactCondition2D1N"
+        else:
+            self.locate_on_background = KratosMultiphysics.BinBasedFastPointLocator3D(self.background_all)
+            contact_condition_type = "PointContactCondition3D1N"
+        self.locate_on_background.UpdateSearchDatabase()
+
+        i = max_cond_id + 1
+        for node in self.active_contact_surface.Nodes: #nodes on the skin of the rotor
+            self.active_contact_surface.GetRootModelPart().GetSubModelPart("computing_domain").CreateNewCondition(contact_condition_type,i,[node.Id], prop)
+            i+=1
+            node.Fix(KratosMultiphysics.DISTANCE)
+            node.SetSolutionStepValue(KratosMultiphysics.DISTANCE,0,0.0)
+            node.SetValue(KratosMultiphysics.DISTANCE,0.0)
+            node.SetValue(KratosMultiphysics.DISPLACEMENT,zero)
+
+
+        for node in self.active_contact_body.Nodes:
+            if(not node.IsFixed(KratosMultiphysics.DISTANCE)):
+                node.SetSolutionStepValue(KratosMultiphysics.DISTANCE,0,-1.0)
+                print(node.Id)
+
+
+
+        ################## BACKGROUND SIDE
+
+        ##assigning the distances
+        for node in self.background_contact_surface.Nodes: #nodes on the contact surface
+            node.Fix(KratosMultiphysics.DISTANCE)
+            node.SetSolutionStepValue(KratosMultiphysics.DISTANCE,0,0.0)
+
+        for node in self.background_domain.Nodes:
+            if(node.IsFixed(KratosMultiphysics.DISTANCE) == False):
+                node.SetSolutionStepValue(KratosMultiphysics.DISTANCE,0,-1.0)
+
+        for node in self.background_contact_volume.Nodes: #nodes inside the "air"
+            if(node.IsFixed(KratosMultiphysics.DISTANCE) == False):
+                node.SetSolutionStepValue(KratosMultiphysics.DISTANCE,0,1.0)
+
+
+
+
+        #computing distance from the contact surface on the background mesh
+        distance_linear_solver_settings = KratosMultiphysics.Parameters( """{
+                                       "solver_type" : "amgcl"
+                                   } """)
+        distance_linear_solver = linear_solver_factory.ConstructSolver(distance_linear_solver_settings)
+
+        max_iterations=30
+        if(self.domain_size == 2):
+            self.distance_calculator = KratosMultiphysics.VariationalDistanceCalculationProcess2D(self.background_all, distance_linear_solver, max_iterations)
+        else:
+            self.distance_calculator = KratosMultiphysics.VariationalDistanceCalculationProcess3D(self.background_all, distance_linear_solver, max_iterations)
+        self.distance_calculator.Execute()
+
+        for node in self.background_all.Nodes:
+            node.SetValue(KratosMultiphysics.DISTANCE, node.GetSolutionStepValue(KratosMultiphysics.DISTANCE))
+
+        if(self.domain_size == 2):
+            KratosMultiphysics.ComputeNonHistoricalNodalGradientProcess2D(self.background_all, KratosMultiphysics.DISTANCE, KratosMultiphysics.DISTANCE_GRADIENT, KratosMultiphysics.NODAL_AREA).Execute()
+        else:
+            KratosMultiphysics.ComputeNonHistoricalNodalGradientProcess3D(self.background_all, KratosMultiphysics.DISTANCE, KratosMultiphysics.DISTANCE_GRADIENT, KratosMultiphysics.NODAL_AREA).Execute()
+        print("finished initialize")
+
+    def ExecuteInitializeSolutionStep(self):
+        KratosMultiphysics.BodyNormalCalculationUtils().CalculateBodyNormals(self.active_contact_body,self.domain_size)
+
+        zero = KratosMultiphysics.Vector(3)
+        zero[0] = 0.0
+        zero[1] = 0.0
+        zero[2] = 0.0
+
+        N = KratosMultiphysics.Vector(self.domain_size+1)
+        coords =  KratosMultiphysics.Array3()
+        pelem =  KratosMultiphysics.Element(-1) #UGLY! here i create an empty pointer
+        grad =  KratosMultiphysics.Vector(3)
+
+        for node in self.active_contact_surface.Nodes: #nodes on the skin of the rotor
+
+            #save the displacement
+            disp = node.GetSolutionStepValue(KratosMultiphysics.DISPLACEMENT)
+            node.SetValue(KratosMultiphysics.DISPLACEMENT,disp)
+
+            #now find if inside
+            coords[0] = node.X
+            coords[1] = node.Y
+            coords[2] = node.Z
+            found = self.locate_on_background.FindPointOnMesh(coords, N, pelem, 1000, 1e-9)
+
+            if(found):
+                d = 0.0
+                grad[0] = 0.0
+                grad[1] = 0.0
+                grad[2] = 0.0
+                k = 0
+                for p in pelem.GetNodes():
+                    d += N[k]*p.GetSolutionStepValue(KratosMultiphysics.DISTANCE)
+
+                    g = p.GetValue(KratosMultiphysics.DISTANCE_GRADIENT)
+                    grad[0] += N[k]*g[0]
+                    grad[1] += N[k]*g[1]
+                    grad[2] += N[k]*g[2]
+
+                    k+=1
+                node.SetValue(KratosMultiphysics.DISTANCE,d)
+                node.SetValue(KratosMultiphysics.DISTANCE_GRADIENT,grad)
+            else:
+                node.SetValue(KratosMultiphysics.DISTANCE,0.0)
+                node.SetValue(KratosMultiphysics.DISTANCE_GRADIENT,zero)
+
+
+
+
+
```

## KratosMultiphysics/StructuralMechanicsApplication/sprism_process.py

 * *Ordering differences only*

```diff
@@ -1,105 +1,105 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-
-import KratosMultiphysics.StructuralMechanicsApplication as SMA
-
-def Factory(settings, Model):
-    if not isinstance(settings, KM.Parameters):
-        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
-    return SPRISMProcess(Model, settings["Parameters"])
-
-# All the processes python processes should be derived from "Process"
-
-class SPRISMProcess(KM.Process):
-    """This class is used in order to compute some pre and post process on the SPRISM solid shell elements
-
-    Only the member variables listed below should be accessed directly.
-
-    Public member variables:
-    Model -- the container of the different model parts.
-    settings -- Kratos parameters containing the settings.
-    """
-
-    def __init__(self, Model, settings):
-        """ The default constructor of the class
-
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        Model -- the container of the different model parts.
-        settings -- Kratos parameters containing solver settings.
-        """
-        KM.Process.__init__(self)
-
-        # Settings string in json format
-        default_parameters = KM.Parameters("""
-        {
-            "help"                           :"This class is used in order to compute some pre and post process on the SPRISM solid shell elements",
-            "mesh_id"                        : 0,
-            "model_part_name"                : "Structure",
-            "explicit_simulation"            : false,
-            "preprocess_shell_to_solidshell" : false,
-            "parameters_shell_to_solidshell" : {
-                "element_name"                         : "SolidShellElementSprism3D6N",
-                "new_constitutive_law_name"            : "LinearElastic3DLaw",
-                "number_of_layers"                     : 1,
-                "export_to_mdpa"                       : false,
-                "output_name"                          : "output",
-                "computing_model_part_name"            : "",
-                "create_submodelparts_external_layers" : false,
-                "append_submodelparts_external_layers" : false,
-                "initialize_elements"                  : false
-            }
-        }
-        """)
-
-        # Overwrite the default settings with user-provided parameters
-        self.settings = settings
-        self.settings.RecursivelyValidateAndAssignDefaults(default_parameters)
-
-        # We define the model parts
-        self.solid_shell_model_part = Model[self.settings["model_part_name"].GetString()]
-        self.main_model_part = self.solid_shell_model_part.GetRootModelPart()
-
-        # We create the process to compute the neighbours (should be run each time we recompute connectivity)
-        self.sprism_neighbour_search = SMA.PrismNeighboursProcess(self.solid_shell_model_part)
-
-        # We create the process to compute the thickness of the solid shell (post-process info)
-        self.thickness_compute_process = SMA.SolidShellThickComputeProcess(self.solid_shell_model_part)
-
-    def ExecuteInitialize(self):
-        """ This method is executed at the begining to initialize the process
-
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        """
-
-        # We preprocess from triangle shells to SPRISM solid-shells
-        if self.settings["preprocess_shell_to_solidshell"].GetBool():
-            parameters_shell_to_solidshell = KM.Parameters(self.settings["parameters_shell_to_solidshell"])
-            parameters_shell_to_solidshell.AddValue("model_part_name", self.settings["model_part_name"])
-            parameters_shell_to_solidshell["model_part_name"].SetString(self.solid_shell_model_part.Name)
-
-            preprocess_shell_to_solidshell = SMA.TriangleShellToSolidShellProcess(self.main_model_part, parameters_shell_to_solidshell)
-            preprocess_shell_to_solidshell.Execute()
-
-        # We compute the neighbours
-        self.sprism_neighbour_search.Execute()
-
-    def ExecuteInitializeSolutionStep(self):
-        """ This method is executed in order to initialize the current step
-
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        """
-        # We compute the neighbours if we have remeshed the problem
-        if self.main_model_part.Is(KM.MODIFIED):
-            self.sprism_neighbour_search.Execute()
-
-    def ExecuteFinalizeSolutionStep(self):
-        """ This method is executed in order to finalize the current step
-
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        """
-        # We compute the thickness of the solid shell element
-        self.thickness_compute_process.Execute()
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+
+import KratosMultiphysics.StructuralMechanicsApplication as SMA
+
+def Factory(settings, Model):
+    if not isinstance(settings, KM.Parameters):
+        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
+    return SPRISMProcess(Model, settings["Parameters"])
+
+# All the processes python processes should be derived from "Process"
+
+class SPRISMProcess(KM.Process):
+    """This class is used in order to compute some pre and post process on the SPRISM solid shell elements
+
+    Only the member variables listed below should be accessed directly.
+
+    Public member variables:
+    Model -- the container of the different model parts.
+    settings -- Kratos parameters containing the settings.
+    """
+
+    def __init__(self, Model, settings):
+        """ The default constructor of the class
+
+        Keyword arguments:
+        self -- It signifies an instance of a class.
+        Model -- the container of the different model parts.
+        settings -- Kratos parameters containing solver settings.
+        """
+        KM.Process.__init__(self)
+
+        # Settings string in json format
+        default_parameters = KM.Parameters("""
+        {
+            "help"                           :"This class is used in order to compute some pre and post process on the SPRISM solid shell elements",
+            "mesh_id"                        : 0,
+            "model_part_name"                : "Structure",
+            "explicit_simulation"            : false,
+            "preprocess_shell_to_solidshell" : false,
+            "parameters_shell_to_solidshell" : {
+                "element_name"                         : "SolidShellElementSprism3D6N",
+                "new_constitutive_law_name"            : "LinearElastic3DLaw",
+                "number_of_layers"                     : 1,
+                "export_to_mdpa"                       : false,
+                "output_name"                          : "output",
+                "computing_model_part_name"            : "",
+                "create_submodelparts_external_layers" : false,
+                "append_submodelparts_external_layers" : false,
+                "initialize_elements"                  : false
+            }
+        }
+        """)
+
+        # Overwrite the default settings with user-provided parameters
+        self.settings = settings
+        self.settings.RecursivelyValidateAndAssignDefaults(default_parameters)
+
+        # We define the model parts
+        self.solid_shell_model_part = Model[self.settings["model_part_name"].GetString()]
+        self.main_model_part = self.solid_shell_model_part.GetRootModelPart()
+
+        # We create the process to compute the neighbours (should be run each time we recompute connectivity)
+        self.sprism_neighbour_search = SMA.PrismNeighboursProcess(self.solid_shell_model_part)
+
+        # We create the process to compute the thickness of the solid shell (post-process info)
+        self.thickness_compute_process = SMA.SolidShellThickComputeProcess(self.solid_shell_model_part)
+
+    def ExecuteInitialize(self):
+        """ This method is executed at the begining to initialize the process
+
+        Keyword arguments:
+        self -- It signifies an instance of a class.
+        """
+
+        # We preprocess from triangle shells to SPRISM solid-shells
+        if self.settings["preprocess_shell_to_solidshell"].GetBool():
+            parameters_shell_to_solidshell = KM.Parameters(self.settings["parameters_shell_to_solidshell"])
+            parameters_shell_to_solidshell.AddValue("model_part_name", self.settings["model_part_name"])
+            parameters_shell_to_solidshell["model_part_name"].SetString(self.solid_shell_model_part.Name)
+
+            preprocess_shell_to_solidshell = SMA.TriangleShellToSolidShellProcess(self.main_model_part, parameters_shell_to_solidshell)
+            preprocess_shell_to_solidshell.Execute()
+
+        # We compute the neighbours
+        self.sprism_neighbour_search.Execute()
+
+    def ExecuteInitializeSolutionStep(self):
+        """ This method is executed in order to initialize the current step
+
+        Keyword arguments:
+        self -- It signifies an instance of a class.
+        """
+        # We compute the neighbours if we have remeshed the problem
+        if self.main_model_part.Is(KM.MODIFIED):
+            self.sprism_neighbour_search.Execute()
+
+    def ExecuteFinalizeSolutionStep(self):
+        """ This method is executed in order to finalize the current step
+
+        Keyword arguments:
+        self -- It signifies an instance of a class.
+        """
+        # We compute the thickness of the solid shell element
+        self.thickness_compute_process.Execute()
```

## KratosMultiphysics/StructuralMechanicsApplication/__init__.py

 * *Ordering differences only*

```diff
@@ -1,12 +1,12 @@
-# Application dependent names and paths
-from KratosMultiphysics import _ImportApplication
-from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
-from KratosStructuralMechanicsApplication import *
-application = KratosStructuralMechanicsApplication()
-application_name = "KratosStructuralMechanicsApplication"
-
-_ImportApplication(application, application_name)
-
-if CheckIfApplicationsAvailable("ConstitutiveLawsApplication"):
-    # if available import the advanced constitutive laws
-    import KratosMultiphysics.ConstitutiveLawsApplication
+# Application dependent names and paths
+from KratosMultiphysics import _ImportApplication
+from KratosMultiphysics.kratos_utilities import CheckIfApplicationsAvailable
+from KratosStructuralMechanicsApplication import *
+application = KratosStructuralMechanicsApplication()
+application_name = "KratosStructuralMechanicsApplication"
+
+_ImportApplication(application, application_name)
+
+if CheckIfApplicationsAvailable("ConstitutiveLawsApplication"):
+    # if available import the advanced constitutive laws
+    import KratosMultiphysics.ConstitutiveLawsApplication
```

## KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_solver.py

 * *Ordering differences only*

```diff
@@ -1,540 +1,540 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-
-# Importing the base class
-from KratosMultiphysics.python_solver import PythonSolver
-
-# Other imports
-from KratosMultiphysics.StructuralMechanicsApplication import convergence_criteria_factory
-from KratosMultiphysics import python_linear_solver_factory as linear_solver_factory
-from KratosMultiphysics import auxiliary_solver_utilities
-from KratosMultiphysics import kratos_utilities
-
-# Other imports
-from importlib import import_module
-
-class MechanicalSolver(PythonSolver):
-    """The base class for structural mechanics solvers.
-
-    This class provides functions for importing and exporting models,
-    adding nodal variables and dofs and solving each solution step.
-
-    Derived classes must override the function _CreateScheme which
-    constructs and returns a solution scheme. Depending on the type of
-    solver, derived classes may also need to override the following functions:
-
-    _CreateScheme
-    _CreateConvergenceCriterion
-    _CreateLinearSolver
-    _CreateBuilderAndSolver
-    _CreateSolutionStrategy
-
-    The mechanical_solution_strategy, builder_and_solver, etc. should alway be retrieved
-    using the getter functions _GetSolutionStrategy, get_builder_and_solver,
-    etc. from this base class.
-
-    Only the member variables listed below should be accessed directly.
-
-    Public member variables:
-    model -- the model containing the modelpart used to construct the solver.
-    settings -- Kratos parameters containing solver settings.
-    """
-    def __init__(self, model, custom_settings):
-        old_unused_settings = [
-            "use_computing_model_part",
-            "computing_model_part_name",
-            "problem_domain_sub_model_part_list",
-            "processes_sub_model_part_list"
-        ]
-
-        for old_setting in old_unused_settings:
-            if custom_settings.Has(old_setting):
-                KratosMultiphysics.Logger.PrintWarning("::[MechanicalSolver]:: ", 'Settings contain no longer used setting, please remove it: "{}"'.format(old_setting))
-                custom_settings.RemoveValue(old_setting)
-
-
-        settings_have_use_block_builder = custom_settings.Has("block_builder")
-        if settings_have_use_block_builder:
-            kratos_utilities.IssueDeprecationWarning('MechanicalSolver', 'Using "block_builder", please move it to "builder_and_solver_settings" as "use_block_builder"')
-            if not custom_settings.Has("builder_and_solver_settings"):
-                custom_settings.AddEmptyValue("builder_and_solver_settings")
-
-            custom_settings["builder_and_solver_settings"].AddValue("use_block_builder", custom_settings["block_builder"])
-            custom_settings.RemoveValue("block_builder")
-
-        settings_have_line_search = custom_settings.Has("line_search")
-        if settings_have_line_search:
-            kratos_utilities.IssueDeprecationWarning('MechanicalSolver', 'Using "line_search", please move it to "solving_strategy_settings" as "type"')
-            if custom_settings["line_search"].GetBool():
-                if not custom_settings.Has("solving_strategy_settings"):
-                    custom_settings.AddEmptyValue("solving_strategy_settings")
-
-                custom_settings["solving_strategy_settings"].AddEmptyValue("type")
-                custom_settings["solving_strategy_settings"]["type"].SetString("line_search")
-            custom_settings.RemoveValue("line_search")
-
-        self._validate_settings_in_baseclass=True # To be removed eventually
-        super().__init__(model, custom_settings)
-
-        model_part_name = self.settings["model_part_name"].GetString()
-
-        if model_part_name == "":
-            raise Exception('Please specify a model_part name!')
-
-        if self.model.HasModelPart(model_part_name):
-            self.main_model_part = self.model[model_part_name]
-        else:
-            self.main_model_part = self.model.CreateModelPart(model_part_name)
-            domain_size = self.settings["domain_size"].GetInt()
-            if domain_size < 0:
-                raise Exception('Please specify a "domain_size" >= 0!')
-            self.main_model_part.ProcessInfo.SetValue(KratosMultiphysics.DOMAIN_SIZE, domain_size)
-
-        # Some variables initialization
-        self.mpc_block_builder_initialized = False
-
-        # Printing message
-        KratosMultiphysics.Logger.PrintInfo("::[MechanicalSolver]:: ", "Construction finished")
-
-        # Set if the analysis is restarted
-        if self.settings["model_import_settings"]["input_type"].GetString() == "rest":
-            self.main_model_part.ProcessInfo[KratosMultiphysics.IS_RESTARTED] = True
-        else:
-            self.main_model_part.ProcessInfo[KratosMultiphysics.IS_RESTARTED] = False
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KratosMultiphysics.Parameters("""{
-            "solver_type" : "mechanical_solver",
-            "model_part_name" : "",
-            "computing_sub_model_part_name" : "",
-            "domain_size" : -1,
-            "echo_level": 0,
-            "buffer_size": 2,
-            "analysis_type": "non_linear",
-            "model_import_settings": {
-                "input_type": "mdpa"
-            },
-            "material_import_settings" :{
-                "materials_filename": ""
-            },
-            "time_stepping" : { },
-            "volumetric_strain_dofs": false,
-            "rotation_dofs": false,
-            "pressure_dofs": false,
-            "displacement_control": false,
-            "reform_dofs_at_each_step": false,
-            "use_old_stiffness_in_first_iteration": false,
-            "compute_reactions": true,
-            "solving_strategy_settings": {
-                "type" : "newton_raphson",
-                "advanced_settings" : { }
-            },
-            "builder_and_solver_settings" : {
-                "use_block_builder" : true,
-                "use_lagrange_BS"   : false,
-                "advanced_settings" : { }
-            },
-            "clear_storage": false,
-            "move_mesh_flag": true,
-            "multi_point_constraints_used": true,
-            "convergence_criterion": "residual_criterion",
-            "displacement_relative_tolerance": 1.0e-4,
-            "displacement_absolute_tolerance": 1.0e-9,
-            "residual_relative_tolerance": 1.0e-4,
-            "residual_absolute_tolerance": 1.0e-9,
-            "max_iteration": 10,
-            "linear_solver_settings": { },
-            "auxiliary_variables_list" : [],
-            "auxiliary_dofs_list" : [],
-            "auxiliary_reaction_list" : []
-        }""")
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
-
-    def ValidateSettings(self):
-        """This function validates the settings of the solver
-        """
-        super().ValidateSettings()
-
-        # Validate some subparameters
-        self.settings["builder_and_solver_settings"].ValidateAndAssignDefaults(self.GetDefaultParameters()["builder_and_solver_settings"])
-
-    def AddVariables(self):
-        # this can safely be called also for restarts, it is internally checked if the variables exist already
-        # Add displacements.
-        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.DISPLACEMENT)
-        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.REACTION)
-        # Add specific variables for the problem conditions.
-        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.POSITIVE_FACE_PRESSURE)
-        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.NEGATIVE_FACE_PRESSURE)
-        self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.POINT_LOAD)
-        self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.LINE_LOAD)
-        self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.SURFACE_LOAD)
-        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.VOLUME_ACCELERATION)
-        if self.settings["rotation_dofs"].GetBool():
-            # Add specific variables for the problem (rotation dofs).
-            self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.ROTATION)
-            self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.REACTION_MOMENT)
-            self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.POINT_MOMENT)
-        if self.settings["volumetric_strain_dofs"].GetBool():
-            # Add specific variables for the problem (rotation dofs).
-            self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.VOLUMETRIC_STRAIN)
-            self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.REACTION_STRAIN)
-        if self.settings["displacement_control"].GetBool():
-            # Add displacement-control variables
-            self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.LOAD_FACTOR)
-            self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.PRESCRIBED_DISPLACEMENT)
-        # Add variables that the user defined in the ProjectParameters
-        auxiliary_solver_utilities.AddVariables(self.main_model_part, self.settings["auxiliary_variables_list"])
-        KratosMultiphysics.Logger.PrintInfo("::[MechanicalSolver]:: ", "Variables ADDED")
-
-    def GetMinimumBufferSize(self):
-        return 2
-
-    def AddDofs(self):
-        # Append formulation-related DOFs and reactions
-        dofs_and_reactions_to_add = []
-        dofs_and_reactions_to_add.append(["DISPLACEMENT_X", "REACTION_X"])
-        dofs_and_reactions_to_add.append(["DISPLACEMENT_Y", "REACTION_Y"])
-        dofs_and_reactions_to_add.append(["DISPLACEMENT_Z", "REACTION_Z"])
-        if self.settings["rotation_dofs"].GetBool():
-            dofs_and_reactions_to_add.append(["ROTATION_X", "REACTION_MOMENT_X"])
-            dofs_and_reactions_to_add.append(["ROTATION_Y", "REACTION_MOMENT_Y"])
-            dofs_and_reactions_to_add.append(["ROTATION_Z", "REACTION_MOMENT_Z"])
-        if self.settings["volumetric_strain_dofs"].GetBool():
-            dofs_and_reactions_to_add.append(["VOLUMETRIC_STRAIN", "REACTION_STRAIN"])
-        if self.settings["displacement_control"].GetBool():
-            dofs_and_reactions_to_add.append(["LOAD_FACTOR", "PRESCRIBED_DISPLACEMENT"])
-
-        # Append user-defined DOFs and reactions in the ProjectParameters
-        auxiliary_solver_utilities.AddAuxiliaryDofsToDofsWithReactionsList(
-            self.settings["auxiliary_dofs_list"],
-            self.settings["auxiliary_reaction_list"],
-            dofs_and_reactions_to_add)
-
-        KratosMultiphysics.VariableUtils.AddDofsList(dofs_and_reactions_to_add, self.main_model_part)
-        KratosMultiphysics.Logger.PrintInfo("::[MechanicalSolver]:: ", "DOF's ADDED")
-
-    def GetDofsList(self):
-        """This function creates and returns a list with the DOFs defined in the conditions and elements specifications
-        """
-        return KratosMultiphysics.SpecificationsUtilities.GetDofsListFromSpecifications(self.main_model_part)
-
-    def ImportModelPart(self):
-        """This function imports the ModelPart
-        """
-        self._ImportModelPart(self.main_model_part, self.settings["model_import_settings"])
-
-    def PrepareModelPart(self):
-        if not self.is_restarted():
-            # Check and prepare computing model part and import constitutive laws.
-            self._execute_after_reading()
-            self._set_and_fill_buffer()
-
-        KratosMultiphysics.Logger.PrintInfo("::[MechanicalSolver]::", "ModelPart prepared for Solver.")
-
-    def Initialize(self):
-        """Perform initialization after adding nodal variables and dofs to the main model part. """
-        KratosMultiphysics.Logger.PrintInfo("::[MechanicalSolver]:: ", "Initializing ...")
-        
-        # The mechanical solution strategy is created here if it does not already exist.
-        if self.settings["clear_storage"].GetBool():
-            self.Clear()
-        mechanical_solution_strategy = self._GetSolutionStrategy()
-        mechanical_solution_strategy.SetEchoLevel(self.settings["echo_level"].GetInt())
-        mechanical_solution_strategy.Initialize()
-
-        # Printing that inialization is finished
-        KratosMultiphysics.Logger.PrintInfo("::[MechanicalSolver]:: ", "Finished initialization.")
-
-    def InitializeSolutionStep(self):
-        if self.settings["clear_storage"].GetBool():
-            self.Clear()
-            self.Initialize() #required after clearing
-        self._GetSolutionStrategy().InitializeSolutionStep()
-
-    def Predict(self):
-        self._GetSolutionStrategy().Predict()
-
-    def SolveSolutionStep(self):
-        is_converged = self._GetSolutionStrategy().SolveSolutionStep()
-        if not is_converged:
-            msg  = "Solver did not converge for step " + str(self.main_model_part.ProcessInfo[KratosMultiphysics.STEP]) + "\n"
-            msg += "corresponding to time " + str(self.main_model_part.ProcessInfo[KratosMultiphysics.TIME]) + "\n"
-            KratosMultiphysics.Logger.PrintWarning("::[MechanicalSolver]:: ",msg)
-        return is_converged
-
-    def FinalizeSolutionStep(self):
-        self._GetSolutionStrategy().FinalizeSolutionStep()
-
-    def AdvanceInTime(self, current_time):
-        dt = self.ComputeDeltaTime()
-        new_time = current_time + dt
-        self.main_model_part.ProcessInfo[KratosMultiphysics.STEP] += 1
-        self.main_model_part.CloneTimeStep(new_time)
-
-        return new_time
-
-    def ComputeDeltaTime(self):
-        if self.settings["time_stepping"].Has("time_step"):
-            return self.settings["time_stepping"]["time_step"].GetDouble()
-        elif self.settings["time_stepping"].Has("time_step_table"):
-            current_time = self.main_model_part.ProcessInfo[KratosMultiphysics.TIME]
-            time_step_table = self.settings["time_stepping"]["time_step_table"].GetMatrix()
-            tb = KratosMultiphysics.PiecewiseLinearTable()
-            for interval in range(time_step_table.Size1()):
-                tb.AddRow(time_step_table[interval, 0], time_step_table[interval, 1])
-            return tb.GetValue(current_time)
-        else:
-            raise Exception("::[MechanicalSolver]:: Time stepping not defined!")
-
-    def GetComputingModelPart(self):
-        computing_sub_model_part_name = self.settings["computing_sub_model_part_name"].GetString()
-        if computing_sub_model_part_name == "":
-            # if the user didn't specify a SubModelPart, then use the MainModelPart
-            return self.main_model_part
-        else:
-            computing_model_part_name = self.main_model_part.Name + "." + computing_sub_model_part_name
-            return self.model[computing_model_part_name]
-
-    def ExportModelPart(self):
-        name_out_file = self.settings["model_import_settings"]["input_filename"].GetString()+".out"
-        file = open(name_out_file + ".mdpa","w")
-        file.close()
-        KratosMultiphysics.ModelPartIO(name_out_file, KratosMultiphysics.IO.WRITE).WriteModelPart(self.main_model_part)
-
-    def SetEchoLevel(self, level):
-        self._GetSolutionStrategy().SetEchoLevel(level)
-
-    def Clear(self):
-        self._GetSolutionStrategy().Clear()
-
-    def Check(self):
-        self._GetSolutionStrategy().Check()
-
-    #### Specific internal functions ####
-
-    def _GetScheme(self):
-        if not hasattr(self, '_solution_scheme'):
-            self._solution_scheme = self._CreateScheme()
-        return self._solution_scheme
-
-    def _GetConvergenceCriterion(self):
-        if not hasattr(self, '_convergence_criterion'):
-            self._convergence_criterion = self._CreateConvergenceCriterion()
-        return self._convergence_criterion
-
-    def _GetLinearSolver(self):
-        if not hasattr(self, '_linear_solver'):
-            self._linear_solver = self._CreateLinearSolver()
-        return self._linear_solver
-
-    def _GetBuilderAndSolver(self):
-        if not hasattr(self, '_builder_and_solver'):
-            self._builder_and_solver = self._CreateBuilderAndSolver()
-        elif not self.settings["builder_and_solver_settings"]["use_block_builder"].GetBool(): # Block builder and solver are unified with MPC and without. In the case of the elimination this could be a problem
-            if self.GetComputingModelPart().NumberOfMasterSlaveConstraints() > 0 and not self.mpc_block_builder_initialized:
-                self.settings["multi_point_constraints_used"].SetBool(True)
-                self._builder_and_solver = self._CreateBuilderAndSolver()
-                self.mpc_block_builder_initialized = True
-        return self._builder_and_solver
-
-    def _GetSolutionStrategy(self):
-        if not hasattr(self, '_mechanical_solution_strategy'):
-            self._mechanical_solution_strategy = self._CreateSolutionStrategy()
-        elif not self.settings["builder_and_solver_settings"]["use_block_builder"].GetBool(): # Block builder and solver are unified with MPC and without. In the case of the elimination this could be a problem
-            if self.GetComputingModelPart().NumberOfMasterSlaveConstraints() > 0 and not self.mpc_block_builder_initialized:
-                self._mechanical_solution_strategy = self._CreateSolutionStrategy()
-        return self._mechanical_solution_strategy
-
-    def import_constitutive_laws(self):
-        if self.settings["material_import_settings"].Has("custom_reader"): # We use our own file for reading
-            custom_reader = import_module(self.settings["material_import_settings"]["custom_reader"].GetString())
-            custom_reader.ReadMaterials(self.model, self.settings["material_import_settings"])
-            materials_imported = True
-        else: # We follow the normal path
-            materials_filename = self.settings["material_import_settings"]["materials_filename"].GetString()
-            if materials_filename != "":
-                # Add constitutive laws and material properties from json file to model parts.
-                material_settings = KratosMultiphysics.Parameters("""{"Parameters": {"materials_filename": ""}} """)
-                material_settings["Parameters"]["materials_filename"].SetString(materials_filename)
-                KratosMultiphysics.ReadMaterialsUtility(material_settings, self.model)
-                materials_imported = True
-            else:
-                materials_imported = False
-        return materials_imported
-
-    def is_restarted(self):
-        # this function avoids the long call to ProcessInfo and is also safer
-        # in case the detection of a restart is changed later
-        return self.main_model_part.ProcessInfo[KratosMultiphysics.IS_RESTARTED]
-
-    #### Private functions ####
-
-    def _execute_after_reading(self):
-        """Import constitutive laws."""
-        # Import constitutive laws.
-        materials_imported = self.import_constitutive_laws()
-        if materials_imported:
-            KratosMultiphysics.Logger.PrintInfo("::[MechanicalSolver]:: ", "Constitutive law was successfully imported.")
-        else:
-            KratosMultiphysics.Logger.PrintInfo("::[MechanicalSolver]:: ", "Constitutive law was not imported.")
-
-    def _set_and_fill_buffer(self):
-        required_buffer_size = self.settings["buffer_size"].GetInt()
-        if required_buffer_size < self.GetMinimumBufferSize():
-            required_buffer_size = self.GetMinimumBufferSize()
-        delta_time = self.main_model_part.ProcessInfo[KratosMultiphysics.DELTA_TIME]
-        auxiliary_solver_utilities.SetAndFillBuffer(self.main_model_part, required_buffer_size, delta_time)
-
-    def _add_dynamic_variables(self):
-        # For being consistent for Serial and Trilinos
-        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.VELOCITY)
-        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.ACCELERATION)
-        if self.settings["rotation_dofs"].GetBool():
-            self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.ANGULAR_VELOCITY)
-            self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.ANGULAR_ACCELERATION)
-
-    def _add_dynamic_dofs(self):
-        # For being consistent for Serial and Trilinos
-        KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.VELOCITY_X,self.main_model_part)
-        KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.VELOCITY_Y,self.main_model_part)
-        KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.VELOCITY_Z,self.main_model_part)
-        KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.ACCELERATION_X,self.main_model_part)
-        KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.ACCELERATION_Y,self.main_model_part)
-        KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.ACCELERATION_Z,self.main_model_part)
-        if self.settings["rotation_dofs"].GetBool():
-            KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.ANGULAR_VELOCITY_X,self.main_model_part)
-            KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.ANGULAR_VELOCITY_Y,self.main_model_part)
-            KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.ANGULAR_VELOCITY_Z,self.main_model_part)
-            KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.ANGULAR_ACCELERATION_X,self.main_model_part)
-            KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.ANGULAR_ACCELERATION_Y,self.main_model_part)
-            KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.ANGULAR_ACCELERATION_Z,self.main_model_part)
-
-    def _get_convergence_criterion_settings(self):
-        # Create an auxiliary Kratos parameters object to store the convergence settings.
-        conv_params = KratosMultiphysics.Parameters("{}")
-        conv_params.AddValue("convergence_criterion",self.settings["convergence_criterion"])
-        conv_params.AddValue("volumetric_strain_dofs",self.settings["volumetric_strain_dofs"])
-        conv_params.AddValue("rotation_dofs",self.settings["rotation_dofs"])
-        conv_params.AddValue("echo_level",self.settings["echo_level"])
-        conv_params.AddValue("displacement_relative_tolerance",self.settings["displacement_relative_tolerance"])
-        conv_params.AddValue("displacement_absolute_tolerance",self.settings["displacement_absolute_tolerance"])
-        conv_params.AddValue("residual_relative_tolerance",self.settings["residual_relative_tolerance"])
-        conv_params.AddValue("residual_absolute_tolerance",self.settings["residual_absolute_tolerance"])
-
-        return conv_params
-
-    def _CreateConvergenceCriterion(self):
-        convergence_criterion = convergence_criteria_factory.convergence_criterion(self._get_convergence_criterion_settings())
-        return convergence_criterion.mechanical_convergence_criterion
-
-    def _CreateLinearSolver(self):
-        linear_solver_configuration = self.settings["linear_solver_settings"]
-        if linear_solver_configuration.Has("solver_type"): # user specified a linear solver
-            return linear_solver_factory.ConstructSolver(linear_solver_configuration)
-        else:
-            KratosMultiphysics.Logger.PrintInfo('::[MechanicalSolver]:: No linear solver was specified, using fastest available solver')
-            return linear_solver_factory.CreateFastestAvailableDirectLinearSolver()
-
-    def _CreateBuilderAndSolver(self):
-        linear_solver = self._GetLinearSolver()
-        if self.settings["builder_and_solver_settings"]["use_block_builder"].GetBool():
-            bs_params = self.settings["builder_and_solver_settings"]["advanced_settings"]
-            if not self.settings["builder_and_solver_settings"]["use_lagrange_BS"].GetBool():
-                builder_and_solver = KratosMultiphysics.ResidualBasedBlockBuilderAndSolver(linear_solver, bs_params)
-            else:
-                builder_and_solver = KratosMultiphysics.ResidualBasedBlockBuilderAndSolverWithLagrangeMultiplier(linear_solver, bs_params)
-        else:
-            if self.settings["multi_point_constraints_used"].GetBool():
-                builder_and_solver = KratosMultiphysics.ResidualBasedEliminationBuilderAndSolverWithConstraints(linear_solver)
-            else:
-                builder_and_solver = KratosMultiphysics.ResidualBasedEliminationBuilderAndSolver(linear_solver)
-        return builder_and_solver
-
-    def _CreateScheme(self):
-        """Create the solution scheme for the structural problem.
-        """
-        raise Exception("Solution Scheme creation must be implemented in the derived class.")
-
-    def _CreateSolutionStrategy(self):
-        analysis_type = self.settings["analysis_type"].GetString()
-        if analysis_type == "linear":
-            mechanical_solution_strategy = self._create_linear_strategy()
-        elif analysis_type == "non_linear":
-            # Create strategy
-            if self.settings["solving_strategy_settings"]["type"].GetString() == "newton_raphson":
-                mechanical_solution_strategy = self._create_newton_raphson_strategy()
-            elif self.settings["solving_strategy_settings"]["type"].GetString() == "line_search":
-                mechanical_solution_strategy = self._create_line_search_strategy()
-            elif self.settings["solving_strategy_settings"]["type"].GetString() == "arc_length":
-                mechanical_solution_strategy = self._create_arc_length_strategy()
-
-        else:
-            err_msg =  "The requested analysis type \"" + analysis_type + "\" is not available!\n"
-            err_msg += "Available options are: \"linear\", \"non_linear\""
-            raise Exception(err_msg)
-        return mechanical_solution_strategy
-
-    def _create_linear_strategy(self):
-        computing_model_part = self.GetComputingModelPart()
-        mechanical_scheme = self._GetScheme()
-        builder_and_solver = self._GetBuilderAndSolver()
-        return KratosMultiphysics.ResidualBasedLinearStrategy(computing_model_part,
-                                                              mechanical_scheme,
-                                                              builder_and_solver,
-                                                              self.settings["compute_reactions"].GetBool(),
-                                                              self.settings["reform_dofs_at_each_step"].GetBool(),
-                                                              False,
-                                                              self.settings["move_mesh_flag"].GetBool())
-
-    def _create_newton_raphson_strategy(self):
-        computing_model_part = self.GetComputingModelPart()
-        mechanical_scheme = self._GetScheme()
-        mechanical_convergence_criterion = self._GetConvergenceCriterion()
-        builder_and_solver = self._GetBuilderAndSolver()
-        strategy = KratosMultiphysics.ResidualBasedNewtonRaphsonStrategy(computing_model_part,
-                                                                     mechanical_scheme,
-                                                                     mechanical_convergence_criterion,
-                                                                     builder_and_solver,
-                                                                     self.settings["max_iteration"].GetInt(),
-                                                                     self.settings["compute_reactions"].GetBool(),
-                                                                     self.settings["reform_dofs_at_each_step"].GetBool(),
-                                                                     self.settings["move_mesh_flag"].GetBool())
-        strategy.SetUseOldStiffnessInFirstIterationFlag(self.settings["use_old_stiffness_in_first_iteration"].GetBool())
-        return strategy
-
-    def _create_line_search_strategy(self):
-        computing_model_part = self.GetComputingModelPart()
-        mechanical_scheme = self._GetScheme()
-        linear_solver = self._GetLinearSolver()
-        mechanical_convergence_criterion = self._GetConvergenceCriterion()
-        builder_and_solver = self._GetBuilderAndSolver()
-        strategy = KratosMultiphysics.LineSearchStrategy(computing_model_part,
-                                                     mechanical_scheme,
-                                                     linear_solver,
-                                                     mechanical_convergence_criterion,
-                                                     builder_and_solver,
-                                                     self.settings["max_iteration"].GetInt(),
-                                                     self.settings["compute_reactions"].GetBool(),
-                                                     self.settings["reform_dofs_at_each_step"].GetBool(),
-                                                     self.settings["move_mesh_flag"].GetBool())
-        strategy.SetUseOldStiffnessInFirstIterationFlag(self.settings["use_old_stiffness_in_first_iteration"].GetBool())
-        return strategy
-
-    def _create_arc_length_strategy(self):
-        settings = self.settings["solving_strategy_settings"]["advanced_settings"]
-        settings.AddValue("max_iteration", self.settings["max_iteration"])
-        settings.AddValue("compute_reactions", self.settings["compute_reactions"])
-        settings.AddValue("reform_dofs_at_each_step", self.settings["reform_dofs_at_each_step"])
-        settings.AddValue("move_mesh_flag", self.settings["move_mesh_flag"])
-        solving_strategy = KratosMultiphysics.ArcLengthStrategy(self.GetComputingModelPart(),
-                                                                self._GetScheme(),
-                                                                self._GetConvergenceCriterion(),
-                                                                self._GetBuilderAndSolver(),
-                                                                settings)
-        return solving_strategy
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+
+# Importing the base class
+from KratosMultiphysics.python_solver import PythonSolver
+
+# Other imports
+from KratosMultiphysics.StructuralMechanicsApplication import convergence_criteria_factory
+from KratosMultiphysics import python_linear_solver_factory as linear_solver_factory
+from KratosMultiphysics import auxiliary_solver_utilities
+from KratosMultiphysics import kratos_utilities
+
+# Other imports
+from importlib import import_module
+
+class MechanicalSolver(PythonSolver):
+    """The base class for structural mechanics solvers.
+
+    This class provides functions for importing and exporting models,
+    adding nodal variables and dofs and solving each solution step.
+
+    Derived classes must override the function _CreateScheme which
+    constructs and returns a solution scheme. Depending on the type of
+    solver, derived classes may also need to override the following functions:
+
+    _CreateScheme
+    _CreateConvergenceCriterion
+    _CreateLinearSolver
+    _CreateBuilderAndSolver
+    _CreateSolutionStrategy
+
+    The mechanical_solution_strategy, builder_and_solver, etc. should alway be retrieved
+    using the getter functions _GetSolutionStrategy, get_builder_and_solver,
+    etc. from this base class.
+
+    Only the member variables listed below should be accessed directly.
+
+    Public member variables:
+    model -- the model containing the modelpart used to construct the solver.
+    settings -- Kratos parameters containing solver settings.
+    """
+    def __init__(self, model, custom_settings):
+        old_unused_settings = [
+            "use_computing_model_part",
+            "computing_model_part_name",
+            "problem_domain_sub_model_part_list",
+            "processes_sub_model_part_list"
+        ]
+
+        for old_setting in old_unused_settings:
+            if custom_settings.Has(old_setting):
+                KratosMultiphysics.Logger.PrintWarning("::[MechanicalSolver]:: ", 'Settings contain no longer used setting, please remove it: "{}"'.format(old_setting))
+                custom_settings.RemoveValue(old_setting)
+
+
+        settings_have_use_block_builder = custom_settings.Has("block_builder")
+        if settings_have_use_block_builder:
+            kratos_utilities.IssueDeprecationWarning('MechanicalSolver', 'Using "block_builder", please move it to "builder_and_solver_settings" as "use_block_builder"')
+            if not custom_settings.Has("builder_and_solver_settings"):
+                custom_settings.AddEmptyValue("builder_and_solver_settings")
+
+            custom_settings["builder_and_solver_settings"].AddValue("use_block_builder", custom_settings["block_builder"])
+            custom_settings.RemoveValue("block_builder")
+
+        settings_have_line_search = custom_settings.Has("line_search")
+        if settings_have_line_search:
+            kratos_utilities.IssueDeprecationWarning('MechanicalSolver', 'Using "line_search", please move it to "solving_strategy_settings" as "type"')
+            if custom_settings["line_search"].GetBool():
+                if not custom_settings.Has("solving_strategy_settings"):
+                    custom_settings.AddEmptyValue("solving_strategy_settings")
+
+                custom_settings["solving_strategy_settings"].AddEmptyValue("type")
+                custom_settings["solving_strategy_settings"]["type"].SetString("line_search")
+            custom_settings.RemoveValue("line_search")
+
+        self._validate_settings_in_baseclass=True # To be removed eventually
+        super().__init__(model, custom_settings)
+
+        model_part_name = self.settings["model_part_name"].GetString()
+
+        if model_part_name == "":
+            raise Exception('Please specify a model_part name!')
+
+        if self.model.HasModelPart(model_part_name):
+            self.main_model_part = self.model[model_part_name]
+        else:
+            self.main_model_part = self.model.CreateModelPart(model_part_name)
+            domain_size = self.settings["domain_size"].GetInt()
+            if domain_size < 0:
+                raise Exception('Please specify a "domain_size" >= 0!')
+            self.main_model_part.ProcessInfo.SetValue(KratosMultiphysics.DOMAIN_SIZE, domain_size)
+
+        # Some variables initialization
+        self.mpc_block_builder_initialized = False
+
+        # Printing message
+        KratosMultiphysics.Logger.PrintInfo("::[MechanicalSolver]:: ", "Construction finished")
+
+        # Set if the analysis is restarted
+        if self.settings["model_import_settings"]["input_type"].GetString() == "rest":
+            self.main_model_part.ProcessInfo[KratosMultiphysics.IS_RESTARTED] = True
+        else:
+            self.main_model_part.ProcessInfo[KratosMultiphysics.IS_RESTARTED] = False
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KratosMultiphysics.Parameters("""{
+            "solver_type" : "mechanical_solver",
+            "model_part_name" : "",
+            "computing_sub_model_part_name" : "",
+            "domain_size" : -1,
+            "echo_level": 0,
+            "buffer_size": 2,
+            "analysis_type": "non_linear",
+            "model_import_settings": {
+                "input_type": "mdpa"
+            },
+            "material_import_settings" :{
+                "materials_filename": ""
+            },
+            "time_stepping" : { },
+            "volumetric_strain_dofs": false,
+            "rotation_dofs": false,
+            "pressure_dofs": false,
+            "displacement_control": false,
+            "reform_dofs_at_each_step": false,
+            "use_old_stiffness_in_first_iteration": false,
+            "compute_reactions": true,
+            "solving_strategy_settings": {
+                "type" : "newton_raphson",
+                "advanced_settings" : { }
+            },
+            "builder_and_solver_settings" : {
+                "use_block_builder" : true,
+                "use_lagrange_BS"   : false,
+                "advanced_settings" : { }
+            },
+            "clear_storage": false,
+            "move_mesh_flag": true,
+            "multi_point_constraints_used": true,
+            "convergence_criterion": "residual_criterion",
+            "displacement_relative_tolerance": 1.0e-4,
+            "displacement_absolute_tolerance": 1.0e-9,
+            "residual_relative_tolerance": 1.0e-4,
+            "residual_absolute_tolerance": 1.0e-9,
+            "max_iteration": 10,
+            "linear_solver_settings": { },
+            "auxiliary_variables_list" : [],
+            "auxiliary_dofs_list" : [],
+            "auxiliary_reaction_list" : []
+        }""")
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
+
+    def ValidateSettings(self):
+        """This function validates the settings of the solver
+        """
+        super().ValidateSettings()
+
+        # Validate some subparameters
+        self.settings["builder_and_solver_settings"].ValidateAndAssignDefaults(self.GetDefaultParameters()["builder_and_solver_settings"])
+
+    def AddVariables(self):
+        # this can safely be called also for restarts, it is internally checked if the variables exist already
+        # Add displacements.
+        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.DISPLACEMENT)
+        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.REACTION)
+        # Add specific variables for the problem conditions.
+        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.POSITIVE_FACE_PRESSURE)
+        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.NEGATIVE_FACE_PRESSURE)
+        self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.POINT_LOAD)
+        self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.LINE_LOAD)
+        self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.SURFACE_LOAD)
+        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.VOLUME_ACCELERATION)
+        if self.settings["rotation_dofs"].GetBool():
+            # Add specific variables for the problem (rotation dofs).
+            self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.ROTATION)
+            self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.REACTION_MOMENT)
+            self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.POINT_MOMENT)
+        if self.settings["volumetric_strain_dofs"].GetBool():
+            # Add specific variables for the problem (rotation dofs).
+            self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.VOLUMETRIC_STRAIN)
+            self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.REACTION_STRAIN)
+        if self.settings["displacement_control"].GetBool():
+            # Add displacement-control variables
+            self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.LOAD_FACTOR)
+            self.main_model_part.AddNodalSolutionStepVariable(StructuralMechanicsApplication.PRESCRIBED_DISPLACEMENT)
+        # Add variables that the user defined in the ProjectParameters
+        auxiliary_solver_utilities.AddVariables(self.main_model_part, self.settings["auxiliary_variables_list"])
+        KratosMultiphysics.Logger.PrintInfo("::[MechanicalSolver]:: ", "Variables ADDED")
+
+    def GetMinimumBufferSize(self):
+        return 2
+
+    def AddDofs(self):
+        # Append formulation-related DOFs and reactions
+        dofs_and_reactions_to_add = []
+        dofs_and_reactions_to_add.append(["DISPLACEMENT_X", "REACTION_X"])
+        dofs_and_reactions_to_add.append(["DISPLACEMENT_Y", "REACTION_Y"])
+        dofs_and_reactions_to_add.append(["DISPLACEMENT_Z", "REACTION_Z"])
+        if self.settings["rotation_dofs"].GetBool():
+            dofs_and_reactions_to_add.append(["ROTATION_X", "REACTION_MOMENT_X"])
+            dofs_and_reactions_to_add.append(["ROTATION_Y", "REACTION_MOMENT_Y"])
+            dofs_and_reactions_to_add.append(["ROTATION_Z", "REACTION_MOMENT_Z"])
+        if self.settings["volumetric_strain_dofs"].GetBool():
+            dofs_and_reactions_to_add.append(["VOLUMETRIC_STRAIN", "REACTION_STRAIN"])
+        if self.settings["displacement_control"].GetBool():
+            dofs_and_reactions_to_add.append(["LOAD_FACTOR", "PRESCRIBED_DISPLACEMENT"])
+
+        # Append user-defined DOFs and reactions in the ProjectParameters
+        auxiliary_solver_utilities.AddAuxiliaryDofsToDofsWithReactionsList(
+            self.settings["auxiliary_dofs_list"],
+            self.settings["auxiliary_reaction_list"],
+            dofs_and_reactions_to_add)
+
+        KratosMultiphysics.VariableUtils.AddDofsList(dofs_and_reactions_to_add, self.main_model_part)
+        KratosMultiphysics.Logger.PrintInfo("::[MechanicalSolver]:: ", "DOF's ADDED")
+
+    def GetDofsList(self):
+        """This function creates and returns a list with the DOFs defined in the conditions and elements specifications
+        """
+        return KratosMultiphysics.SpecificationsUtilities.GetDofsListFromSpecifications(self.main_model_part)
+
+    def ImportModelPart(self):
+        """This function imports the ModelPart
+        """
+        self._ImportModelPart(self.main_model_part, self.settings["model_import_settings"])
+
+    def PrepareModelPart(self):
+        if not self.is_restarted():
+            # Check and prepare computing model part and import constitutive laws.
+            self._execute_after_reading()
+            self._set_and_fill_buffer()
+
+        KratosMultiphysics.Logger.PrintInfo("::[MechanicalSolver]::", "ModelPart prepared for Solver.")
+
+    def Initialize(self):
+        """Perform initialization after adding nodal variables and dofs to the main model part. """
+        KratosMultiphysics.Logger.PrintInfo("::[MechanicalSolver]:: ", "Initializing ...")
+        
+        # The mechanical solution strategy is created here if it does not already exist.
+        if self.settings["clear_storage"].GetBool():
+            self.Clear()
+        mechanical_solution_strategy = self._GetSolutionStrategy()
+        mechanical_solution_strategy.SetEchoLevel(self.settings["echo_level"].GetInt())
+        mechanical_solution_strategy.Initialize()
+
+        # Printing that inialization is finished
+        KratosMultiphysics.Logger.PrintInfo("::[MechanicalSolver]:: ", "Finished initialization.")
+
+    def InitializeSolutionStep(self):
+        if self.settings["clear_storage"].GetBool():
+            self.Clear()
+            self.Initialize() #required after clearing
+        self._GetSolutionStrategy().InitializeSolutionStep()
+
+    def Predict(self):
+        self._GetSolutionStrategy().Predict()
+
+    def SolveSolutionStep(self):
+        is_converged = self._GetSolutionStrategy().SolveSolutionStep()
+        if not is_converged:
+            msg  = "Solver did not converge for step " + str(self.main_model_part.ProcessInfo[KratosMultiphysics.STEP]) + "\n"
+            msg += "corresponding to time " + str(self.main_model_part.ProcessInfo[KratosMultiphysics.TIME]) + "\n"
+            KratosMultiphysics.Logger.PrintWarning("::[MechanicalSolver]:: ",msg)
+        return is_converged
+
+    def FinalizeSolutionStep(self):
+        self._GetSolutionStrategy().FinalizeSolutionStep()
+
+    def AdvanceInTime(self, current_time):
+        dt = self.ComputeDeltaTime()
+        new_time = current_time + dt
+        self.main_model_part.ProcessInfo[KratosMultiphysics.STEP] += 1
+        self.main_model_part.CloneTimeStep(new_time)
+
+        return new_time
+
+    def ComputeDeltaTime(self):
+        if self.settings["time_stepping"].Has("time_step"):
+            return self.settings["time_stepping"]["time_step"].GetDouble()
+        elif self.settings["time_stepping"].Has("time_step_table"):
+            current_time = self.main_model_part.ProcessInfo[KratosMultiphysics.TIME]
+            time_step_table = self.settings["time_stepping"]["time_step_table"].GetMatrix()
+            tb = KratosMultiphysics.PiecewiseLinearTable()
+            for interval in range(time_step_table.Size1()):
+                tb.AddRow(time_step_table[interval, 0], time_step_table[interval, 1])
+            return tb.GetValue(current_time)
+        else:
+            raise Exception("::[MechanicalSolver]:: Time stepping not defined!")
+
+    def GetComputingModelPart(self):
+        computing_sub_model_part_name = self.settings["computing_sub_model_part_name"].GetString()
+        if computing_sub_model_part_name == "":
+            # if the user didn't specify a SubModelPart, then use the MainModelPart
+            return self.main_model_part
+        else:
+            computing_model_part_name = self.main_model_part.Name + "." + computing_sub_model_part_name
+            return self.model[computing_model_part_name]
+
+    def ExportModelPart(self):
+        name_out_file = self.settings["model_import_settings"]["input_filename"].GetString()+".out"
+        file = open(name_out_file + ".mdpa","w")
+        file.close()
+        KratosMultiphysics.ModelPartIO(name_out_file, KratosMultiphysics.IO.WRITE).WriteModelPart(self.main_model_part)
+
+    def SetEchoLevel(self, level):
+        self._GetSolutionStrategy().SetEchoLevel(level)
+
+    def Clear(self):
+        self._GetSolutionStrategy().Clear()
+
+    def Check(self):
+        self._GetSolutionStrategy().Check()
+
+    #### Specific internal functions ####
+
+    def _GetScheme(self):
+        if not hasattr(self, '_solution_scheme'):
+            self._solution_scheme = self._CreateScheme()
+        return self._solution_scheme
+
+    def _GetConvergenceCriterion(self):
+        if not hasattr(self, '_convergence_criterion'):
+            self._convergence_criterion = self._CreateConvergenceCriterion()
+        return self._convergence_criterion
+
+    def _GetLinearSolver(self):
+        if not hasattr(self, '_linear_solver'):
+            self._linear_solver = self._CreateLinearSolver()
+        return self._linear_solver
+
+    def _GetBuilderAndSolver(self):
+        if not hasattr(self, '_builder_and_solver'):
+            self._builder_and_solver = self._CreateBuilderAndSolver()
+        elif not self.settings["builder_and_solver_settings"]["use_block_builder"].GetBool(): # Block builder and solver are unified with MPC and without. In the case of the elimination this could be a problem
+            if self.GetComputingModelPart().NumberOfMasterSlaveConstraints() > 0 and not self.mpc_block_builder_initialized:
+                self.settings["multi_point_constraints_used"].SetBool(True)
+                self._builder_and_solver = self._CreateBuilderAndSolver()
+                self.mpc_block_builder_initialized = True
+        return self._builder_and_solver
+
+    def _GetSolutionStrategy(self):
+        if not hasattr(self, '_mechanical_solution_strategy'):
+            self._mechanical_solution_strategy = self._CreateSolutionStrategy()
+        elif not self.settings["builder_and_solver_settings"]["use_block_builder"].GetBool(): # Block builder and solver are unified with MPC and without. In the case of the elimination this could be a problem
+            if self.GetComputingModelPart().NumberOfMasterSlaveConstraints() > 0 and not self.mpc_block_builder_initialized:
+                self._mechanical_solution_strategy = self._CreateSolutionStrategy()
+        return self._mechanical_solution_strategy
+
+    def import_constitutive_laws(self):
+        if self.settings["material_import_settings"].Has("custom_reader"): # We use our own file for reading
+            custom_reader = import_module(self.settings["material_import_settings"]["custom_reader"].GetString())
+            custom_reader.ReadMaterials(self.model, self.settings["material_import_settings"])
+            materials_imported = True
+        else: # We follow the normal path
+            materials_filename = self.settings["material_import_settings"]["materials_filename"].GetString()
+            if materials_filename != "":
+                # Add constitutive laws and material properties from json file to model parts.
+                material_settings = KratosMultiphysics.Parameters("""{"Parameters": {"materials_filename": ""}} """)
+                material_settings["Parameters"]["materials_filename"].SetString(materials_filename)
+                KratosMultiphysics.ReadMaterialsUtility(material_settings, self.model)
+                materials_imported = True
+            else:
+                materials_imported = False
+        return materials_imported
+
+    def is_restarted(self):
+        # this function avoids the long call to ProcessInfo and is also safer
+        # in case the detection of a restart is changed later
+        return self.main_model_part.ProcessInfo[KratosMultiphysics.IS_RESTARTED]
+
+    #### Private functions ####
+
+    def _execute_after_reading(self):
+        """Import constitutive laws."""
+        # Import constitutive laws.
+        materials_imported = self.import_constitutive_laws()
+        if materials_imported:
+            KratosMultiphysics.Logger.PrintInfo("::[MechanicalSolver]:: ", "Constitutive law was successfully imported.")
+        else:
+            KratosMultiphysics.Logger.PrintInfo("::[MechanicalSolver]:: ", "Constitutive law was not imported.")
+
+    def _set_and_fill_buffer(self):
+        required_buffer_size = self.settings["buffer_size"].GetInt()
+        if required_buffer_size < self.GetMinimumBufferSize():
+            required_buffer_size = self.GetMinimumBufferSize()
+        delta_time = self.main_model_part.ProcessInfo[KratosMultiphysics.DELTA_TIME]
+        auxiliary_solver_utilities.SetAndFillBuffer(self.main_model_part, required_buffer_size, delta_time)
+
+    def _add_dynamic_variables(self):
+        # For being consistent for Serial and Trilinos
+        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.VELOCITY)
+        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.ACCELERATION)
+        if self.settings["rotation_dofs"].GetBool():
+            self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.ANGULAR_VELOCITY)
+            self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.ANGULAR_ACCELERATION)
+
+    def _add_dynamic_dofs(self):
+        # For being consistent for Serial and Trilinos
+        KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.VELOCITY_X,self.main_model_part)
+        KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.VELOCITY_Y,self.main_model_part)
+        KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.VELOCITY_Z,self.main_model_part)
+        KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.ACCELERATION_X,self.main_model_part)
+        KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.ACCELERATION_Y,self.main_model_part)
+        KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.ACCELERATION_Z,self.main_model_part)
+        if self.settings["rotation_dofs"].GetBool():
+            KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.ANGULAR_VELOCITY_X,self.main_model_part)
+            KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.ANGULAR_VELOCITY_Y,self.main_model_part)
+            KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.ANGULAR_VELOCITY_Z,self.main_model_part)
+            KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.ANGULAR_ACCELERATION_X,self.main_model_part)
+            KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.ANGULAR_ACCELERATION_Y,self.main_model_part)
+            KratosMultiphysics.VariableUtils().AddDof(KratosMultiphysics.ANGULAR_ACCELERATION_Z,self.main_model_part)
+
+    def _get_convergence_criterion_settings(self):
+        # Create an auxiliary Kratos parameters object to store the convergence settings.
+        conv_params = KratosMultiphysics.Parameters("{}")
+        conv_params.AddValue("convergence_criterion",self.settings["convergence_criterion"])
+        conv_params.AddValue("volumetric_strain_dofs",self.settings["volumetric_strain_dofs"])
+        conv_params.AddValue("rotation_dofs",self.settings["rotation_dofs"])
+        conv_params.AddValue("echo_level",self.settings["echo_level"])
+        conv_params.AddValue("displacement_relative_tolerance",self.settings["displacement_relative_tolerance"])
+        conv_params.AddValue("displacement_absolute_tolerance",self.settings["displacement_absolute_tolerance"])
+        conv_params.AddValue("residual_relative_tolerance",self.settings["residual_relative_tolerance"])
+        conv_params.AddValue("residual_absolute_tolerance",self.settings["residual_absolute_tolerance"])
+
+        return conv_params
+
+    def _CreateConvergenceCriterion(self):
+        convergence_criterion = convergence_criteria_factory.convergence_criterion(self._get_convergence_criterion_settings())
+        return convergence_criterion.mechanical_convergence_criterion
+
+    def _CreateLinearSolver(self):
+        linear_solver_configuration = self.settings["linear_solver_settings"]
+        if linear_solver_configuration.Has("solver_type"): # user specified a linear solver
+            return linear_solver_factory.ConstructSolver(linear_solver_configuration)
+        else:
+            KratosMultiphysics.Logger.PrintInfo('::[MechanicalSolver]:: No linear solver was specified, using fastest available solver')
+            return linear_solver_factory.CreateFastestAvailableDirectLinearSolver()
+
+    def _CreateBuilderAndSolver(self):
+        linear_solver = self._GetLinearSolver()
+        if self.settings["builder_and_solver_settings"]["use_block_builder"].GetBool():
+            bs_params = self.settings["builder_and_solver_settings"]["advanced_settings"]
+            if not self.settings["builder_and_solver_settings"]["use_lagrange_BS"].GetBool():
+                builder_and_solver = KratosMultiphysics.ResidualBasedBlockBuilderAndSolver(linear_solver, bs_params)
+            else:
+                builder_and_solver = KratosMultiphysics.ResidualBasedBlockBuilderAndSolverWithLagrangeMultiplier(linear_solver, bs_params)
+        else:
+            if self.settings["multi_point_constraints_used"].GetBool():
+                builder_and_solver = KratosMultiphysics.ResidualBasedEliminationBuilderAndSolverWithConstraints(linear_solver)
+            else:
+                builder_and_solver = KratosMultiphysics.ResidualBasedEliminationBuilderAndSolver(linear_solver)
+        return builder_and_solver
+
+    def _CreateScheme(self):
+        """Create the solution scheme for the structural problem.
+        """
+        raise Exception("Solution Scheme creation must be implemented in the derived class.")
+
+    def _CreateSolutionStrategy(self):
+        analysis_type = self.settings["analysis_type"].GetString()
+        if analysis_type == "linear":
+            mechanical_solution_strategy = self._create_linear_strategy()
+        elif analysis_type == "non_linear":
+            # Create strategy
+            if self.settings["solving_strategy_settings"]["type"].GetString() == "newton_raphson":
+                mechanical_solution_strategy = self._create_newton_raphson_strategy()
+            elif self.settings["solving_strategy_settings"]["type"].GetString() == "line_search":
+                mechanical_solution_strategy = self._create_line_search_strategy()
+            elif self.settings["solving_strategy_settings"]["type"].GetString() == "arc_length":
+                mechanical_solution_strategy = self._create_arc_length_strategy()
+
+        else:
+            err_msg =  "The requested analysis type \"" + analysis_type + "\" is not available!\n"
+            err_msg += "Available options are: \"linear\", \"non_linear\""
+            raise Exception(err_msg)
+        return mechanical_solution_strategy
+
+    def _create_linear_strategy(self):
+        computing_model_part = self.GetComputingModelPart()
+        mechanical_scheme = self._GetScheme()
+        builder_and_solver = self._GetBuilderAndSolver()
+        return KratosMultiphysics.ResidualBasedLinearStrategy(computing_model_part,
+                                                              mechanical_scheme,
+                                                              builder_and_solver,
+                                                              self.settings["compute_reactions"].GetBool(),
+                                                              self.settings["reform_dofs_at_each_step"].GetBool(),
+                                                              False,
+                                                              self.settings["move_mesh_flag"].GetBool())
+
+    def _create_newton_raphson_strategy(self):
+        computing_model_part = self.GetComputingModelPart()
+        mechanical_scheme = self._GetScheme()
+        mechanical_convergence_criterion = self._GetConvergenceCriterion()
+        builder_and_solver = self._GetBuilderAndSolver()
+        strategy = KratosMultiphysics.ResidualBasedNewtonRaphsonStrategy(computing_model_part,
+                                                                     mechanical_scheme,
+                                                                     mechanical_convergence_criterion,
+                                                                     builder_and_solver,
+                                                                     self.settings["max_iteration"].GetInt(),
+                                                                     self.settings["compute_reactions"].GetBool(),
+                                                                     self.settings["reform_dofs_at_each_step"].GetBool(),
+                                                                     self.settings["move_mesh_flag"].GetBool())
+        strategy.SetUseOldStiffnessInFirstIterationFlag(self.settings["use_old_stiffness_in_first_iteration"].GetBool())
+        return strategy
+
+    def _create_line_search_strategy(self):
+        computing_model_part = self.GetComputingModelPart()
+        mechanical_scheme = self._GetScheme()
+        linear_solver = self._GetLinearSolver()
+        mechanical_convergence_criterion = self._GetConvergenceCriterion()
+        builder_and_solver = self._GetBuilderAndSolver()
+        strategy = KratosMultiphysics.LineSearchStrategy(computing_model_part,
+                                                     mechanical_scheme,
+                                                     linear_solver,
+                                                     mechanical_convergence_criterion,
+                                                     builder_and_solver,
+                                                     self.settings["max_iteration"].GetInt(),
+                                                     self.settings["compute_reactions"].GetBool(),
+                                                     self.settings["reform_dofs_at_each_step"].GetBool(),
+                                                     self.settings["move_mesh_flag"].GetBool())
+        strategy.SetUseOldStiffnessInFirstIterationFlag(self.settings["use_old_stiffness_in_first_iteration"].GetBool())
+        return strategy
+
+    def _create_arc_length_strategy(self):
+        settings = self.settings["solving_strategy_settings"]["advanced_settings"]
+        settings.AddValue("max_iteration", self.settings["max_iteration"])
+        settings.AddValue("compute_reactions", self.settings["compute_reactions"])
+        settings.AddValue("reform_dofs_at_each_step", self.settings["reform_dofs_at_each_step"])
+        settings.AddValue("move_mesh_flag", self.settings["move_mesh_flag"])
+        solving_strategy = KratosMultiphysics.ArcLengthStrategy(self.GetComputingModelPart(),
+                                                                self._GetScheme(),
+                                                                self._GetConvergenceCriterion(),
+                                                                self._GetBuilderAndSolver(),
+                                                                settings)
+        return solving_strategy
```

## KratosMultiphysics/StructuralMechanicsApplication/trilinos_convergence_criteria_factory.py

 * *Ordering differences only*

```diff
@@ -1,69 +1,69 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.TrilinosApplication as TrilinosApplication
-
-
-# Convergence criteria class
-class convergence_criterion:
-    def __init__(self, convergence_criterion_parameters):
-        # Note that all the convergence settings are introduced via a Kratos parameters object.
-
-        D_RT = convergence_criterion_parameters["displacement_relative_tolerance"].GetDouble()
-        D_AT = convergence_criterion_parameters["displacement_absolute_tolerance"].GetDouble()
-        R_RT = convergence_criterion_parameters["residual_relative_tolerance"].GetDouble()
-        R_AT = convergence_criterion_parameters["residual_absolute_tolerance"].GetDouble()
-
-        convergence_crit = convergence_criterion_parameters["convergence_criterion"].GetString()
-
-        echo_level = convergence_criterion_parameters["echo_level"].GetInt()
-
-        rotation_dofs = False
-        if convergence_criterion_parameters.Has("rotation_dofs"):
-            rotation_dofs = convergence_criterion_parameters["rotation_dofs"].GetBool()
-
-        volumetric_strain_dofs = False
-        if convergence_criterion_parameters.Has("volumetric_strain_dofs"):
-            volumetric_strain_dofs = convergence_criterion_parameters["volumetric_strain_dofs"].GetBool()
-
-        if(echo_level >= 1):
-            KratosMultiphysics.Logger.PrintInfo("::[Mechanical Solver]::", "MPI CONVERGENCE CRITERION : " + convergence_criterion_parameters["convergence_criterion"].GetString())
-
-        if(convergence_crit == "displacement_criterion"):
-            if rotation_dofs:
-                self.mechanical_convergence_criterion = TrilinosApplication.TrilinosMixedGenericCriteria(
-                    [(KratosMultiphysics.DISPLACEMENT, D_RT, D_AT),
-                    (KratosMultiphysics.ROTATION, D_RT, D_AT)])
-            elif volumetric_strain_dofs:
-                self.mechanical_convergence_criterion = TrilinosApplication.TrilinosMixedGenericCriteria(
-                    [(KratosMultiphysics.DISPLACEMENT, D_RT, D_AT),
-                    (KratosMultiphysics.VOLUMETRIC_STRAIN, D_RT, D_AT)])
-            else:
-                self.mechanical_convergence_criterion = TrilinosApplication.TrilinosDisplacementCriteria(D_RT, D_AT)
-            self.mechanical_convergence_criterion.SetEchoLevel(echo_level)
-
-        elif(convergence_crit == "residual_criterion"):
-            self.mechanical_convergence_criterion = TrilinosApplication.TrilinosResidualCriteria(R_RT, R_AT)
-            self.mechanical_convergence_criterion.SetEchoLevel(echo_level)
-
-        elif(convergence_crit == "and_criterion"):
-            Displacement = TrilinosApplication.TrilinosDisplacementCriteria(D_RT, D_AT)
-            Displacement.SetEchoLevel(echo_level)
-
-            Residual = TrilinosApplication.TrilinosResidualCriteria(R_RT, R_AT)
-            Residual.SetEchoLevel(echo_level)
-            self.mechanical_convergence_criterion = TrilinosApplication.TrilinosAndCriteria(Residual, Displacement)
-
-        elif(convergence_crit == "or_criterion"):
-            Displacement = TrilinosApplication.TrilinosDisplacementCriteria(D_RT, D_AT)
-            Displacement.SetEchoLevel(echo_level)
-
-            Residual = TrilinosApplication.TrilinosResidualCriteria(R_RT, R_AT)
-            Residual.SetEchoLevel(echo_level)
-            self.mechanical_convergence_criterion = TrilinosApplication.TrilinosOrCriteria(Residual, Displacement)
-
-        else:
-            err_msg =  "The requested convergence criterion \"" + convergence_crit + "\" is not available!\n"
-            err_msg += "Available options are: \"displacement_criterion\", \"residual_criterion\", \"and_criterion\", \"or_criterion\""
-            raise Exception(err_msg)
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.TrilinosApplication as TrilinosApplication
+
+
+# Convergence criteria class
+class convergence_criterion:
+    def __init__(self, convergence_criterion_parameters):
+        # Note that all the convergence settings are introduced via a Kratos parameters object.
+
+        D_RT = convergence_criterion_parameters["displacement_relative_tolerance"].GetDouble()
+        D_AT = convergence_criterion_parameters["displacement_absolute_tolerance"].GetDouble()
+        R_RT = convergence_criterion_parameters["residual_relative_tolerance"].GetDouble()
+        R_AT = convergence_criterion_parameters["residual_absolute_tolerance"].GetDouble()
+
+        convergence_crit = convergence_criterion_parameters["convergence_criterion"].GetString()
+
+        echo_level = convergence_criterion_parameters["echo_level"].GetInt()
+
+        rotation_dofs = False
+        if convergence_criterion_parameters.Has("rotation_dofs"):
+            rotation_dofs = convergence_criterion_parameters["rotation_dofs"].GetBool()
+
+        volumetric_strain_dofs = False
+        if convergence_criterion_parameters.Has("volumetric_strain_dofs"):
+            volumetric_strain_dofs = convergence_criterion_parameters["volumetric_strain_dofs"].GetBool()
+
+        if(echo_level >= 1):
+            KratosMultiphysics.Logger.PrintInfo("::[Mechanical Solver]::", "MPI CONVERGENCE CRITERION : " + convergence_criterion_parameters["convergence_criterion"].GetString())
+
+        if(convergence_crit == "displacement_criterion"):
+            if rotation_dofs:
+                self.mechanical_convergence_criterion = TrilinosApplication.TrilinosMixedGenericCriteria(
+                    [(KratosMultiphysics.DISPLACEMENT, D_RT, D_AT),
+                    (KratosMultiphysics.ROTATION, D_RT, D_AT)])
+            elif volumetric_strain_dofs:
+                self.mechanical_convergence_criterion = TrilinosApplication.TrilinosMixedGenericCriteria(
+                    [(KratosMultiphysics.DISPLACEMENT, D_RT, D_AT),
+                    (KratosMultiphysics.VOLUMETRIC_STRAIN, D_RT, D_AT)])
+            else:
+                self.mechanical_convergence_criterion = TrilinosApplication.TrilinosDisplacementCriteria(D_RT, D_AT)
+            self.mechanical_convergence_criterion.SetEchoLevel(echo_level)
+
+        elif(convergence_crit == "residual_criterion"):
+            self.mechanical_convergence_criterion = TrilinosApplication.TrilinosResidualCriteria(R_RT, R_AT)
+            self.mechanical_convergence_criterion.SetEchoLevel(echo_level)
+
+        elif(convergence_crit == "and_criterion"):
+            Displacement = TrilinosApplication.TrilinosDisplacementCriteria(D_RT, D_AT)
+            Displacement.SetEchoLevel(echo_level)
+
+            Residual = TrilinosApplication.TrilinosResidualCriteria(R_RT, R_AT)
+            Residual.SetEchoLevel(echo_level)
+            self.mechanical_convergence_criterion = TrilinosApplication.TrilinosAndCriteria(Residual, Displacement)
+
+        elif(convergence_crit == "or_criterion"):
+            Displacement = TrilinosApplication.TrilinosDisplacementCriteria(D_RT, D_AT)
+            Displacement.SetEchoLevel(echo_level)
+
+            Residual = TrilinosApplication.TrilinosResidualCriteria(R_RT, R_AT)
+            Residual.SetEchoLevel(echo_level)
+            self.mechanical_convergence_criterion = TrilinosApplication.TrilinosOrCriteria(Residual, Displacement)
+
+        else:
+            err_msg =  "The requested convergence criterion \"" + convergence_crit + "\" is not available!\n"
+            err_msg += "Available options are: \"displacement_criterion\", \"residual_criterion\", \"and_criterion\", \"or_criterion\""
+            raise Exception(err_msg)
```

## KratosMultiphysics/StructuralMechanicsApplication/set_moving_load_process.py

 * *Ordering differences only*

```diff
@@ -1,36 +1,36 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-import KratosMultiphysics.StructuralMechanicsApplication as KSM
-
-
-def Factory(settings, Model):
-    """
-    This process sets the moving load condition. The 'load' is to be filled in in x,y and z direction. The 'direction'
-    parameter indicates the direction of the movement of the load in x,y and z direction, this parameter is either a
-    positive or a negative integer; note that the load follows a given line, thus the 'direction' parameter is not a
-    normalised direction vector. The 'velocity' parameter indicates the velocity of the load in the given direction,
-    this parameter can be either a double or a function of time, written as a string. The 'origin' parameter indicates
-    the origin point of the moving load, note that this point needs to be located within the line condition.
-    """
-    if not isinstance(settings, KratosMultiphysics.Parameters):
-        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
-
-    default_settings = KratosMultiphysics.Parameters("""
-            {
-                "help"            : "This process applies a moving load condition belonging to a modelpart. The load moves over line elements.",
-                "model_part_name" : "please_specify_model_part_name",
-                "variable_name"   : "POINT_LOAD",
-                "load"            : [0.0, 1.0, 0.0],
-                "direction"       : [1,1,1],
-                "velocity"        : 1,
-                "origin"          : [0.0,0.0,0.0],
-                "offset"          : 0.0
-            }
-            """
-                                                     )
-    load_settings = settings["Parameters"]
-    load_settings.ValidateAndAssignDefaults(default_settings)
-
-    # Set process
-    model_part = Model.GetModelPart(load_settings["model_part_name"].GetString())
-    return KSM.SetMovingLoadProcess(model_part, load_settings)
+# Importing the Kratos Library
+import KratosMultiphysics
+import KratosMultiphysics.StructuralMechanicsApplication as KSM
+
+
+def Factory(settings, Model):
+    """
+    This process sets the moving load condition. The 'load' is to be filled in in x,y and z direction. The 'direction'
+    parameter indicates the direction of the movement of the load in x,y and z direction, this parameter is either a
+    positive or a negative integer; note that the load follows a given line, thus the 'direction' parameter is not a
+    normalised direction vector. The 'velocity' parameter indicates the velocity of the load in the given direction,
+    this parameter can be either a double or a function of time, written as a string. The 'origin' parameter indicates
+    the origin point of the moving load, note that this point needs to be located within the line condition.
+    """
+    if not isinstance(settings, KratosMultiphysics.Parameters):
+        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
+
+    default_settings = KratosMultiphysics.Parameters("""
+            {
+                "help"            : "This process applies a moving load condition belonging to a modelpart. The load moves over line elements.",
+                "model_part_name" : "please_specify_model_part_name",
+                "variable_name"   : "POINT_LOAD",
+                "load"            : [0.0, 1.0, 0.0],
+                "direction"       : [1,1,1],
+                "velocity"        : 1,
+                "origin"          : [0.0,0.0,0.0],
+                "offset"          : 0.0
+            }
+            """
+                                                     )
+    load_settings = settings["Parameters"]
+    load_settings.ValidateAndAssignDefaults(default_settings)
+
+    # Set process
+    model_part = Model.GetModelPart(load_settings["model_part_name"].GetString())
+    return KSM.SetMovingLoadProcess(model_part, load_settings)
```

## KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_static_shifted_boundary_solver.py

 * *Ordering differences only*

```diff
@@ -1,67 +1,67 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-
-# Import base class file
-from KratosMultiphysics.StructuralMechanicsApplication import structural_mechanics_static_solver
-
-def CreateSolver(main_model_part, custom_settings):
-    return StaticMechanicalShiftedBoundarySolver(main_model_part, custom_settings)
-
-class StaticMechanicalShiftedBoundarySolver(structural_mechanics_static_solver.StaticMechanicalSolver):
-
-    def __init__(self, main_model_part, custom_settings):
-        # Construct the base solver and validate the remaining settings in the base class
-        super().__init__(main_model_part, custom_settings)
-
-        # Overwrite the base solver minimum buffer size
-        self.min_buffer_size = 1
-
-        KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "Construction finished")
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KratosMultiphysics.Parameters(r"""{
-            "conforming_basis" : true,
-            "extension_operator_type" : "MLS",
-            "mls_extension_operator_order" : 1
-        }""")
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
-
-    def AddVariables(self):
-        # Add structural mechanics required variables
-        super().AddVariables()
-
-        # Add DISTANCE variable to represent the skin
-        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.DISTANCE)
-
-    def Initialize(self):
-        # Avoid zeros with positive epsilon
-        tol = 1.0e-12
-        for node in self.GetComputingModelPart().Nodes:
-            dist = node.GetSolutionStepValue(KratosMultiphysics.DISTANCE)
-            if abs(dist) < tol:
-                node.SetSolutionStepValue(KratosMultiphysics.DISTANCE, 0, tol)
-
-        # Calculate the required neighbours
-        nodal_neighbours_process = KratosMultiphysics.FindGlobalNodalNeighboursProcess(self.main_model_part)
-        nodal_neighbours_process.Execute()
-        elemental_neighbours_process = KratosMultiphysics.GenericFindElementalNeighboursProcess(self.main_model_part)
-        elemental_neighbours_process.Execute()
-
-        # Create the boundary elements and MLS basis
-        settings = KratosMultiphysics.Parameters("""{}""")
-        settings.AddEmptyValue("model_part_name").SetString(self.main_model_part.Name)
-        settings.AddEmptyValue("boundary_sub_model_part_name").SetString("shifted_boundary")
-        settings.AddEmptyValue("conforming_basis").SetBool(self.settings["conforming_basis"].GetBool())
-        settings.AddEmptyValue("extension_operator_type").SetString(self.settings["extension_operator_type"].GetString())
-        settings.AddEmptyValue("mls_extension_operator_order").SetInt(self.settings["mls_extension_operator_order"].GetInt())
-        settings.AddEmptyValue("sbm_interface_condition_name").SetString("DisplacementShiftedBoundaryCondition")
-        sbm_interface_utility = KratosMultiphysics.ShiftedBoundaryMeshlessInterfaceUtility(self.model, settings)
-        sbm_interface_utility.CalculateExtensionOperator()
-
-        # Initialize base solver strategy
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+
+# Import base class file
+from KratosMultiphysics.StructuralMechanicsApplication import structural_mechanics_static_solver
+
+def CreateSolver(main_model_part, custom_settings):
+    return StaticMechanicalShiftedBoundarySolver(main_model_part, custom_settings)
+
+class StaticMechanicalShiftedBoundarySolver(structural_mechanics_static_solver.StaticMechanicalSolver):
+
+    def __init__(self, main_model_part, custom_settings):
+        # Construct the base solver and validate the remaining settings in the base class
+        super().__init__(main_model_part, custom_settings)
+
+        # Overwrite the base solver minimum buffer size
+        self.min_buffer_size = 1
+
+        KratosMultiphysics.Logger.PrintInfo(self.__class__.__name__, "Construction finished")
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KratosMultiphysics.Parameters(r"""{
+            "conforming_basis" : true,
+            "extension_operator_type" : "MLS",
+            "mls_extension_operator_order" : 1
+        }""")
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
+
+    def AddVariables(self):
+        # Add structural mechanics required variables
+        super().AddVariables()
+
+        # Add DISTANCE variable to represent the skin
+        self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.DISTANCE)
+
+    def Initialize(self):
+        # Avoid zeros with positive epsilon
+        tol = 1.0e-12
+        for node in self.GetComputingModelPart().Nodes:
+            dist = node.GetSolutionStepValue(KratosMultiphysics.DISTANCE)
+            if abs(dist) < tol:
+                node.SetSolutionStepValue(KratosMultiphysics.DISTANCE, 0, tol)
+
+        # Calculate the required neighbours
+        nodal_neighbours_process = KratosMultiphysics.FindGlobalNodalNeighboursProcess(self.main_model_part)
+        nodal_neighbours_process.Execute()
+        elemental_neighbours_process = KratosMultiphysics.GenericFindElementalNeighboursProcess(self.main_model_part)
+        elemental_neighbours_process.Execute()
+
+        # Create the boundary elements and MLS basis
+        settings = KratosMultiphysics.Parameters("""{}""")
+        settings.AddEmptyValue("model_part_name").SetString(self.main_model_part.Name)
+        settings.AddEmptyValue("boundary_sub_model_part_name").SetString("shifted_boundary")
+        settings.AddEmptyValue("conforming_basis").SetBool(self.settings["conforming_basis"].GetBool())
+        settings.AddEmptyValue("extension_operator_type").SetString(self.settings["extension_operator_type"].GetString())
+        settings.AddEmptyValue("mls_extension_operator_order").SetInt(self.settings["mls_extension_operator_order"].GetInt())
+        settings.AddEmptyValue("sbm_interface_condition_name").SetString("DisplacementShiftedBoundaryCondition")
+        sbm_interface_utility = KratosMultiphysics.ShiftedBoundaryMeshlessInterfaceUtility(self.model, settings)
+        sbm_interface_utility.CalculateExtensionOperator()
+
+        # Initialize base solver strategy
         super().Initialize()
```

## KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_static_solver.py

 * *Ordering differences only*

```diff
@@ -1,26 +1,26 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.TrilinosApplication as TrilinosApplication
-
-# Import base class file
-from KratosMultiphysics.StructuralMechanicsApplication.trilinos_structural_mechanics_solver import TrilinosMechanicalSolver
-
-def CreateSolver(model, custom_settings):
-    return TrilinosStaticMechanicalSolver(model, custom_settings)
-
-class TrilinosStaticMechanicalSolver(TrilinosMechanicalSolver):
-    """The trilinos structural mechanics static solver.
-
-    For more information see:
-    structural_mechanics_solver.py
-    trilinos_structural_mechanics_solver.py
-    """
-    def __init__(self, model, custom_settings):
-        # Construct the base solver.
-        super().__init__(model, custom_settings)
-        KratosMultiphysics.Logger.PrintInfo("::[TrilinosStaticMechanicalSolver]:: ", "Construction finished")
-
-    def _CreateScheme(self):
-        return TrilinosApplication.TrilinosResidualBasedIncrementalUpdateStaticScheme()
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.TrilinosApplication as TrilinosApplication
+
+# Import base class file
+from KratosMultiphysics.StructuralMechanicsApplication.trilinos_structural_mechanics_solver import TrilinosMechanicalSolver
+
+def CreateSolver(model, custom_settings):
+    return TrilinosStaticMechanicalSolver(model, custom_settings)
+
+class TrilinosStaticMechanicalSolver(TrilinosMechanicalSolver):
+    """The trilinos structural mechanics static solver.
+
+    For more information see:
+    structural_mechanics_solver.py
+    trilinos_structural_mechanics_solver.py
+    """
+    def __init__(self, model, custom_settings):
+        # Construct the base solver.
+        super().__init__(model, custom_settings)
+        KratosMultiphysics.Logger.PrintInfo("::[TrilinosStaticMechanicalSolver]:: ", "Construction finished")
+
+    def _CreateScheme(self):
+        return TrilinosApplication.TrilinosResidualBasedIncrementalUpdateStaticScheme()
```

## KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_static_solver.py

 * *Ordering differences only*

```diff
@@ -1,69 +1,69 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-
-import KratosMultiphysics.kratos_utilities as kratos_utilities
-if kratos_utilities.CheckIfApplicationsAvailable("MeshingApplication"):
-    import KratosMultiphysics.MeshingApplication as MeshingApplication
-    missing_meshing_dependencies = True
-else:
-    missing_meshing_dependencies = False
-
-# Import base class file
-from KratosMultiphysics.StructuralMechanicsApplication import structural_mechanics_static_solver
-
-# Import auxiliary methods
-from KratosMultiphysics.StructuralMechanicsApplication import auxiliary_methods_adaptative_solvers
-from KratosMultiphysics.StructuralMechanicsApplication import adaptative_remeshing_structural_mechanics_utilities
-
-def CreateSolver(model, custom_settings):
-    return AdaptativeRemeshingStaticMechanicalSolver(model, custom_settings)
-
-class AdaptativeRemeshingStaticMechanicalSolver(structural_mechanics_static_solver.StaticMechanicalSolver):
-    """The structural mechanics static solver. (Fot adaptative remeshing)
-    See structural_mechanics_static_solver.py for more information.
-    """
-    def __init__(self, model, custom_settings):
-        # Set defaults and validate custom settings.
-        self.adaptative_remeshing_utilities = adaptative_remeshing_structural_mechanics_utilities.AdaptativeRemeshingMechanicalUtilities()
-
-        # Construct the base solver.
-        super().__init__(model, custom_settings)
-        KratosMultiphysics.Logger.PrintInfo("::[AdaptativeRemeshingStaticMechanicalSolver]:: ", "Construction finished")
-
-    #### Private functions ####
-
-    def AddVariables(self):
-        super().AddVariables()
-        if not missing_meshing_dependencies:
-            self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.NODAL_H)
-        KratosMultiphysics.Logger.PrintInfo("::[AdaptativeRemeshingStaticMechanicalSolver]:: ", "Variables ADDED")
-
-    def get_remeshing_process(self):
-        if not hasattr(self, '_remeshing_process'):
-            self._remeshing_process = self._create_remeshing_process()
-        return self._remeshing_process
-
-    def _create_remeshing_process(self):
-        return auxiliary_methods_adaptative_solvers.CreateRemeshingProcess(self.main_model_part, self.settings)
-
-    def get_metric_process(self):
-        if not hasattr(self, '_metric_process'):
-            self._metric_process = self._create_metric_process()
-        return self._metric_process
-
-    def _create_metric_process(self):
-        return auxiliary_methods_adaptative_solvers.CreateMetricProcess(self.main_model_part, self.settings)
-
-    def _CreateConvergenceCriterion(self):
-        error_criteria = self.settings["convergence_criterion"].GetString()
-        conv_settings = self._get_convergence_criterion_settings()
-        return self.adaptative_remeshing_utilities.GetConvergenceCriteria(error_criteria, conv_settings)
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = adaptative_remeshing_structural_mechanics_utilities.AdaptativeRemeshingMechanicalUtilities().GetDefaultParameters()
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+
+import KratosMultiphysics.kratos_utilities as kratos_utilities
+if kratos_utilities.CheckIfApplicationsAvailable("MeshingApplication"):
+    import KratosMultiphysics.MeshingApplication as MeshingApplication
+    missing_meshing_dependencies = True
+else:
+    missing_meshing_dependencies = False
+
+# Import base class file
+from KratosMultiphysics.StructuralMechanicsApplication import structural_mechanics_static_solver
+
+# Import auxiliary methods
+from KratosMultiphysics.StructuralMechanicsApplication import auxiliary_methods_adaptative_solvers
+from KratosMultiphysics.StructuralMechanicsApplication import adaptative_remeshing_structural_mechanics_utilities
+
+def CreateSolver(model, custom_settings):
+    return AdaptativeRemeshingStaticMechanicalSolver(model, custom_settings)
+
+class AdaptativeRemeshingStaticMechanicalSolver(structural_mechanics_static_solver.StaticMechanicalSolver):
+    """The structural mechanics static solver. (Fot adaptative remeshing)
+    See structural_mechanics_static_solver.py for more information.
+    """
+    def __init__(self, model, custom_settings):
+        # Set defaults and validate custom settings.
+        self.adaptative_remeshing_utilities = adaptative_remeshing_structural_mechanics_utilities.AdaptativeRemeshingMechanicalUtilities()
+
+        # Construct the base solver.
+        super().__init__(model, custom_settings)
+        KratosMultiphysics.Logger.PrintInfo("::[AdaptativeRemeshingStaticMechanicalSolver]:: ", "Construction finished")
+
+    #### Private functions ####
+
+    def AddVariables(self):
+        super().AddVariables()
+        if not missing_meshing_dependencies:
+            self.main_model_part.AddNodalSolutionStepVariable(KratosMultiphysics.NODAL_H)
+        KratosMultiphysics.Logger.PrintInfo("::[AdaptativeRemeshingStaticMechanicalSolver]:: ", "Variables ADDED")
+
+    def get_remeshing_process(self):
+        if not hasattr(self, '_remeshing_process'):
+            self._remeshing_process = self._create_remeshing_process()
+        return self._remeshing_process
+
+    def _create_remeshing_process(self):
+        return auxiliary_methods_adaptative_solvers.CreateRemeshingProcess(self.main_model_part, self.settings)
+
+    def get_metric_process(self):
+        if not hasattr(self, '_metric_process'):
+            self._metric_process = self._create_metric_process()
+        return self._metric_process
+
+    def _create_metric_process(self):
+        return auxiliary_methods_adaptative_solvers.CreateMetricProcess(self.main_model_part, self.settings)
+
+    def _CreateConvergenceCriterion(self):
+        error_criteria = self.settings["convergence_criterion"].GetString()
+        conv_settings = self._get_convergence_criterion_settings()
+        return self.adaptative_remeshing_utilities.GetConvergenceCriteria(error_criteria, conv_settings)
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = adaptative_remeshing_structural_mechanics_utilities.AdaptativeRemeshingMechanicalUtilities().GetDefaultParameters()
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
```

## KratosMultiphysics/StructuralMechanicsApplication/element_sensitivity_domain_integration_process.py

 * *Ordering differences only*

```diff
@@ -1,120 +1,120 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-def Factory(settings, model):
-    if not isinstance(settings, KratosMultiphysics.Parameters):
-        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
-    return ElementSensitivityDomainIntegrationProcess(model, settings["Parameters"])
-
-def CheckAvailabilityOfSensitivities(variable, model_part):
-    """ Check if element sensitivities w.r.t. given variable are available.
-    Keyword arguments:
-    variable -- traced variable within sensitivity analysis.
-    model_part -- sub model part of the sensitivity model part.
-    """
-    return model_part.Elements.__iter__().__next__().Has(variable)
-
-class ElementSensitivityDomainIntegrationProcess(KratosMultiphysics.Process):
-    """
-        This class integrates scalar element sensitivities (material and cross-section
-        properties like CROSS_AREA or YOUNGS_MODULUS) within defined domains.
-        The integration domains are defined by sub model parts of the sensitivity model part.
-    """
-
-    def __init__(self, model, parameter):
-        """ The default constructor of the class
-
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        model -- the model contaning the model_parts
-        parameter -- Kratos parameters containing process settings.
-        """
-        KratosMultiphysics.Process.__init__(self)
-
-        ## Settings string in json format
-        default_parameters = KratosMultiphysics.Parameters("""{
-            "help"                             : "This class integrates element sensitivities within domains defined by sub model parts",
-            "element_sensitivity_variables"    : [],
-            "model_part_name"                  : "",
-            "sensitivity_model_part_name"      : "",
-            "sensitivity_sub_model_part_list"  : []
-        }""")
-
-        ## Overwrite the default settings with user-provided parameters
-        parameter.ValidateAndAssignDefaults(default_parameters)
-
-        model_part_name = parameter["model_part_name"].GetString()
-        sensitivity_model_part_name = parameter["sensitivity_model_part_name"].GetString()
-        sensitivity_sub_model_part_names = [ parameter["sensitivity_sub_model_part_list"][i].GetString() for i in range( 0, parameter["sensitivity_sub_model_part_list"].size() ) ]
-
-        # Get sensitivity model part
-        if (sensitivity_model_part_name != ""):
-            self.sensitivity_model_part = model[model_part_name].GetSubModelPart(sensitivity_model_part_name)
-        else:
-            self.sensitivity_model_part = model[model_part_name]
-
-        # Get defined sub model parts of sensitivity model part as integration domains
-        self.sensitivity_sub_model_parts = []
-        if not sensitivity_sub_model_part_names:
-            self.sensitivity_sub_model_parts.append(self.sensitivity_model_part)
-        else:
-            for mp_name in sensitivity_sub_model_part_names:
-                self.sensitivity_sub_model_parts.append(self.sensitivity_model_part.GetSubModelPart(mp_name))
-
-        self.element_sensitivity_variables = self.__GenerateVariableListFromInput(parameter["element_sensitivity_variables"])
-
-
-    def Check(self):
-        """ This method is executed at the begining to verify that the input is correct.
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        """
-        # Check integration domains
-        for sub_mp_i in self.sensitivity_sub_model_parts:
-            if sub_mp_i.NumberOfElements() < 1:
-                raise Exception("sensitivity sub model part has no elements!")
-        return 0
-
-
-    def ExecuteFinalizeSolutionStep(self):
-        """ This method is executed in order to finalize the current step
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        """
-
-        # loop over sensitivty variables for which integration should performed
-        for variable_i in self.element_sensitivity_variables:
-            if CheckAvailabilityOfSensitivities(variable_i, self.sensitivity_model_part):
-                # loop over integration domains
-                for sub_mp_i in self.sensitivity_sub_model_parts:
-                    domain_sensitivity = KratosMultiphysics.VariableUtils().SumElementScalarVariable(variable_i, sub_mp_i)
-                    KratosMultiphysics.VariableUtils().SetNonHistoricalVariable(variable_i, domain_sensitivity, sub_mp_i.Elements)
-            else:
-                raise Exception(variable_i.Name() + " is not available for domain integration!")
-
-
-    def __GenerateVariableListFromInput(self, parameter):
-        """ Parse a list of variables from input.
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        parameter -- Kratos parameters containing process settings.
-        """
-
-        if not parameter.IsArray():
-            raise Exception("{0} Error: Variable list is unreadable".format(self.__class__.__name__))
-
-        variable_list = []
-        for i in range(0, parameter.size()):
-            variable_type = KratosMultiphysics.KratosGlobals.GetVariableType(parameter[i].GetString())
-            if (variable_type == "Double"):
-                variable_list.append(KratosMultiphysics.KratosGlobals.GetVariable( parameter[i].GetString() ))
-            else:
-                raise Exception("sensitivity domain integration is only available for variables of data type 'Double' but " + parameter[i].GetString() + " is of type '" + variable_type + "'.")
-
-        return variable_list
-
-
-
-
-
-
+# Importing the Kratos Library
+import KratosMultiphysics
+
+def Factory(settings, model):
+    if not isinstance(settings, KratosMultiphysics.Parameters):
+        raise Exception("Expected input shall be a Parameters object, encapsulating a json string")
+    return ElementSensitivityDomainIntegrationProcess(model, settings["Parameters"])
+
+def CheckAvailabilityOfSensitivities(variable, model_part):
+    """ Check if element sensitivities w.r.t. given variable are available.
+    Keyword arguments:
+    variable -- traced variable within sensitivity analysis.
+    model_part -- sub model part of the sensitivity model part.
+    """
+    return model_part.Elements.__iter__().__next__().Has(variable)
+
+class ElementSensitivityDomainIntegrationProcess(KratosMultiphysics.Process):
+    """
+        This class integrates scalar element sensitivities (material and cross-section
+        properties like CROSS_AREA or YOUNGS_MODULUS) within defined domains.
+        The integration domains are defined by sub model parts of the sensitivity model part.
+    """
+
+    def __init__(self, model, parameter):
+        """ The default constructor of the class
+
+        Keyword arguments:
+        self -- It signifies an instance of a class.
+        model -- the model contaning the model_parts
+        parameter -- Kratos parameters containing process settings.
+        """
+        KratosMultiphysics.Process.__init__(self)
+
+        ## Settings string in json format
+        default_parameters = KratosMultiphysics.Parameters("""{
+            "help"                             : "This class integrates element sensitivities within domains defined by sub model parts",
+            "element_sensitivity_variables"    : [],
+            "model_part_name"                  : "",
+            "sensitivity_model_part_name"      : "",
+            "sensitivity_sub_model_part_list"  : []
+        }""")
+
+        ## Overwrite the default settings with user-provided parameters
+        parameter.ValidateAndAssignDefaults(default_parameters)
+
+        model_part_name = parameter["model_part_name"].GetString()
+        sensitivity_model_part_name = parameter["sensitivity_model_part_name"].GetString()
+        sensitivity_sub_model_part_names = [ parameter["sensitivity_sub_model_part_list"][i].GetString() for i in range( 0, parameter["sensitivity_sub_model_part_list"].size() ) ]
+
+        # Get sensitivity model part
+        if (sensitivity_model_part_name != ""):
+            self.sensitivity_model_part = model[model_part_name].GetSubModelPart(sensitivity_model_part_name)
+        else:
+            self.sensitivity_model_part = model[model_part_name]
+
+        # Get defined sub model parts of sensitivity model part as integration domains
+        self.sensitivity_sub_model_parts = []
+        if not sensitivity_sub_model_part_names:
+            self.sensitivity_sub_model_parts.append(self.sensitivity_model_part)
+        else:
+            for mp_name in sensitivity_sub_model_part_names:
+                self.sensitivity_sub_model_parts.append(self.sensitivity_model_part.GetSubModelPart(mp_name))
+
+        self.element_sensitivity_variables = self.__GenerateVariableListFromInput(parameter["element_sensitivity_variables"])
+
+
+    def Check(self):
+        """ This method is executed at the begining to verify that the input is correct.
+        Keyword arguments:
+        self -- It signifies an instance of a class.
+        """
+        # Check integration domains
+        for sub_mp_i in self.sensitivity_sub_model_parts:
+            if sub_mp_i.NumberOfElements() < 1:
+                raise Exception("sensitivity sub model part has no elements!")
+        return 0
+
+
+    def ExecuteFinalizeSolutionStep(self):
+        """ This method is executed in order to finalize the current step
+        Keyword arguments:
+        self -- It signifies an instance of a class.
+        """
+
+        # loop over sensitivty variables for which integration should performed
+        for variable_i in self.element_sensitivity_variables:
+            if CheckAvailabilityOfSensitivities(variable_i, self.sensitivity_model_part):
+                # loop over integration domains
+                for sub_mp_i in self.sensitivity_sub_model_parts:
+                    domain_sensitivity = KratosMultiphysics.VariableUtils().SumElementScalarVariable(variable_i, sub_mp_i)
+                    KratosMultiphysics.VariableUtils().SetNonHistoricalVariable(variable_i, domain_sensitivity, sub_mp_i.Elements)
+            else:
+                raise Exception(variable_i.Name() + " is not available for domain integration!")
+
+
+    def __GenerateVariableListFromInput(self, parameter):
+        """ Parse a list of variables from input.
+        Keyword arguments:
+        self -- It signifies an instance of a class.
+        parameter -- Kratos parameters containing process settings.
+        """
+
+        if not parameter.IsArray():
+            raise Exception("{0} Error: Variable list is unreadable".format(self.__class__.__name__))
+
+        variable_list = []
+        for i in range(0, parameter.size()):
+            variable_type = KratosMultiphysics.KratosGlobals.GetVariableType(parameter[i].GetString())
+            if (variable_type == "Double"):
+                variable_list.append(KratosMultiphysics.KratosGlobals.GetVariable( parameter[i].GetString() ))
+            else:
+                raise Exception("sensitivity domain integration is only available for variables of data type 'Double' but " + parameter[i].GetString() + " is of type '" + variable_type + "'.")
+
+        return variable_list
+
+
+
+
+
+
```

## KratosMultiphysics/StructuralMechanicsApplication/project_vector_on_surface_process.py

 * *Ordering differences only*

```diff
@@ -1,56 +1,56 @@
-# Importing the Kratos Library
-import KratosMultiphysics as KM
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-
-def Factory(settings, Model):
-    if not isinstance(settings, KM.Parameters):
-        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
-    return ProjectVectorOnSurfaceProcess(Model, settings["Parameters"])
-
-## All the processes python should be derived from "Process"
-class ProjectVectorOnSurfaceProcess(KM.Process):
-
-    def __init__(self, Model, settings):
-        """ The default constructor of the class
-
-        Keyword arguments:
-        self -- It signifies an instance of a class.
-        Model -- the container of the different model parts.
-        settings -- Kratos parameters containing solver settings.
-        """
-        KM.Process.__init__(self)
-
-        default_settings = KM.Parameters("""{
-            "model_part_name"  : "Structure",
-            "echo_level"       : 0,
-            "projection_type"  : "planar",
-            "global_direction" : [1,0,0],
-            "variable_name"    : "PLEASE_SPECIFY",
-            "visualize_in_vtk" : false,
-            "method_specific_settings" : { },
-            "check_local_space_dimension" : true
-        }""")
-
-        settings.ValidateAndAssignDefaults(default_settings)
-
-        model_part = Model[settings["model_part_name"].GetString()]
-        StructuralMechanicsApplication.ProjectVectorOnSurfaceUtility.Execute(model_part, settings)
-
-        if settings["visualize_in_vtk"].GetBool():
-            vtk_parameters = KM.Parameters("""{
-                "file_format"                  : "binary",
-                "output_precision"             : 7,
-                "output_control_type"          : "step",
-                "output_sub_model_parts"       : false,
-                "save_output_files_in_folder"  : false,
-                "custom_name_prefix"           : "ProjectVectorOnSurface_",
-                "custom_name_postfix"          : "",
-                "element_data_value_variables" : []
-            }""")
-
-            variable_name = settings["variable_name"].GetString()
-            vtk_parameters["custom_name_postfix"].SetString("_"+variable_name)
-            vtk_parameters["element_data_value_variables"].Append(variable_name)
-
-            vtk_io = KM.VtkOutput(model_part, vtk_parameters)
-            vtk_io.PrintOutput()
+# Importing the Kratos Library
+import KratosMultiphysics as KM
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+
+def Factory(settings, Model):
+    if not isinstance(settings, KM.Parameters):
+        raise Exception("expected input shall be a Parameters object, encapsulating a json string")
+    return ProjectVectorOnSurfaceProcess(Model, settings["Parameters"])
+
+## All the processes python should be derived from "Process"
+class ProjectVectorOnSurfaceProcess(KM.Process):
+
+    def __init__(self, Model, settings):
+        """ The default constructor of the class
+
+        Keyword arguments:
+        self -- It signifies an instance of a class.
+        Model -- the container of the different model parts.
+        settings -- Kratos parameters containing solver settings.
+        """
+        KM.Process.__init__(self)
+
+        default_settings = KM.Parameters("""{
+            "model_part_name"  : "Structure",
+            "echo_level"       : 0,
+            "projection_type"  : "planar",
+            "global_direction" : [1,0,0],
+            "variable_name"    : "PLEASE_SPECIFY",
+            "visualize_in_vtk" : false,
+            "method_specific_settings" : { },
+            "check_local_space_dimension" : true
+        }""")
+
+        settings.ValidateAndAssignDefaults(default_settings)
+
+        model_part = Model[settings["model_part_name"].GetString()]
+        StructuralMechanicsApplication.ProjectVectorOnSurfaceUtility.Execute(model_part, settings)
+
+        if settings["visualize_in_vtk"].GetBool():
+            vtk_parameters = KM.Parameters("""{
+                "file_format"                  : "binary",
+                "output_precision"             : 7,
+                "output_control_type"          : "step",
+                "output_sub_model_parts"       : false,
+                "save_output_files_in_folder"  : false,
+                "custom_name_prefix"           : "ProjectVectorOnSurface_",
+                "custom_name_postfix"          : "",
+                "element_data_value_variables" : []
+            }""")
+
+            variable_name = settings["variable_name"].GetString()
+            vtk_parameters["custom_name_postfix"].SetString("_"+variable_name)
+            vtk_parameters["element_data_value_variables"].Append(variable_name)
+
+            vtk_io = KM.VtkOutput(model_part, vtk_parameters)
+            vtk_io.PrintOutput()
```

## KratosMultiphysics/StructuralMechanicsApplication/python_solvers_wrapper_adaptative_remeshing_structural.py

 * *Ordering differences only*

```diff
@@ -1,33 +1,33 @@
-import KratosMultiphysics
-from importlib import import_module
-
-def CreateSolver(model, custom_settings):
-
-    if not isinstance(model, KratosMultiphysics.Model):
-        raise Exception("input is expected to be provided as a Kratos Model object")
-
-    if not isinstance(custom_settings, KratosMultiphysics.Parameters):
-        raise Exception("input is expected to be provided as a Kratos Parameters object")
-
-    parallelism = custom_settings["problem_data"]["parallel_type"].GetString()
-    solver_type = custom_settings["solver_settings"]["solver_type"].GetString()
-
-    # Solvers for OpenMP parallelism
-    if parallelism == "OpenMP":
-        if solver_type == "static" or solver_type == "Static":
-            solver_module_name = "adaptative_remeshing_structural_mechanics_static_solver"
-        elif solver_type == "dynamic" or solver_type == "Dynamic":
-            solver_module_name = "adaptative_remeshing_structural_mechanics_implicit_dynamic_solver"
-        else:
-            err_msg =  "The requested solver type \"" + solver_type + "\" is not in the python solvers wrapper\n"
-            err_msg += "Available options are: \"static\", \"dynamic\""
-            raise Exception(err_msg)
-    else:
-        err_msg =  "The requested parallel type \"" + parallelism + "\" is not available!\n"
-        err_msg += "Available options are: \"OpenMP\""
-        raise Exception(err_msg)
-
-    module_full = 'KratosMultiphysics.StructuralMechanicsApplication.' + solver_module_name
-    solver = import_module(module_full).CreateSolver(model, custom_settings["solver_settings"])
-
-    return solver
+import KratosMultiphysics
+from importlib import import_module
+
+def CreateSolver(model, custom_settings):
+
+    if not isinstance(model, KratosMultiphysics.Model):
+        raise Exception("input is expected to be provided as a Kratos Model object")
+
+    if not isinstance(custom_settings, KratosMultiphysics.Parameters):
+        raise Exception("input is expected to be provided as a Kratos Parameters object")
+
+    parallelism = custom_settings["problem_data"]["parallel_type"].GetString()
+    solver_type = custom_settings["solver_settings"]["solver_type"].GetString()
+
+    # Solvers for OpenMP parallelism
+    if parallelism == "OpenMP":
+        if solver_type == "static" or solver_type == "Static":
+            solver_module_name = "adaptative_remeshing_structural_mechanics_static_solver"
+        elif solver_type == "dynamic" or solver_type == "Dynamic":
+            solver_module_name = "adaptative_remeshing_structural_mechanics_implicit_dynamic_solver"
+        else:
+            err_msg =  "The requested solver type \"" + solver_type + "\" is not in the python solvers wrapper\n"
+            err_msg += "Available options are: \"static\", \"dynamic\""
+            raise Exception(err_msg)
+    else:
+        err_msg =  "The requested parallel type \"" + parallelism + "\" is not available!\n"
+        err_msg += "Available options are: \"OpenMP\""
+        raise Exception(err_msg)
+
+    module_full = 'KratosMultiphysics.StructuralMechanicsApplication.' + solver_module_name
+    solver = import_module(module_full).CreateSolver(model, custom_settings["solver_settings"])
+
+    return solver
```

## KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_implicit_dynamic_solver.py

 * *Ordering differences only*

```diff
@@ -1,112 +1,112 @@
-# Importing the Kratos Library
-import KratosMultiphysics
-
-# Import applications
-import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
-
-# Import base class file
-from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
-
-from KratosMultiphysics.StructuralMechanicsApplication import auxiliary_methods_solvers
-
-def CreateSolver(model, custom_settings):
-    return ImplicitMechanicalSolver(model, custom_settings)
-
-class ImplicitMechanicalSolver(MechanicalSolver):
-    """The structural mechanics implicit dynamic solver.
-
-    This class creates the mechanical solvers for implicit dynamic analysis.
-    It currently supports Newmark, Bossak and dynamic relaxation schemes.
-
-    See structural_mechanics_solver.py for more information.
-    """
-    def __init__(self, model, custom_settings):
-        # Construct the base solver.
-        super().__init__(model, custom_settings)
-        KratosMultiphysics.Logger.PrintInfo("::[ImplicitMechanicalSolver]:: ", "Construction finished")
-
-    @classmethod
-    def GetDefaultParameters(cls):
-        this_defaults = KratosMultiphysics.Parameters("""{
-            "time_integration_method" : "implicit",
-            "scheme_type"             : "bossak",
-            "damp_factor_m"           :-0.3,
-            "newmark_beta"            : 0.25,
-            "rayleigh_alpha"          : 0.0,
-            "rayleigh_beta"           : 0.0
-        }""")
-        this_defaults.AddMissingParameters(super().GetDefaultParameters())
-        return this_defaults
-
-    def GetMinimumBufferSize(self):
-        base_min_buffer_size = super().GetMinimumBufferSize()
-
-        scheme_type = self.settings["scheme_type"].GetString()
-        if "bdf" in scheme_type or scheme_type == "backward_euler":
-            return max(base_min_buffer_size, auxiliary_methods_solvers.GetBDFIntegrationOrder(scheme_type)+1)
-        else:
-            return base_min_buffer_size
-
-    def AddVariables(self):
-        super().AddVariables()
-        self._add_dynamic_variables()
-        KratosMultiphysics.Logger.PrintInfo("::[ImplicitMechanicalSolver]:: ", "Variables ADDED")
-
-    def AddDofs(self):
-        super().AddDofs()
-        self._add_dynamic_dofs()
-        KratosMultiphysics.Logger.PrintInfo("::[ImplicitMechanicalSolver]:: ", "DOF's ADDED")
-
-    def InitializeSolutionStep(self):
-        # Using the base InitializeSolutionStep
-        super().InitializeSolutionStep()
-
-        # Some pre-processes may affect the system of equations, we rebuild the equation ids
-        process_info = self.main_model_part.ProcessInfo
-        if process_info[KratosMultiphysics.STEP] == 1 and process_info[StructuralMechanicsApplication.RESET_EQUATION_IDS]:
-            # Resetting the global equations ids
-            self._GetBuilderAndSolver().SetUpSystem(self.GetComputingModelPart())
-
-    #### Private functions ####
-
-    def _CreateScheme(self):
-        scheme_type = self.settings["scheme_type"].GetString()
-
-        # Setting the Rayleigh damping parameters
-        process_info = self.main_model_part.ProcessInfo
-        process_info[StructuralMechanicsApplication.RAYLEIGH_ALPHA] = self.settings["rayleigh_alpha"].GetDouble()
-        process_info[StructuralMechanicsApplication.RAYLEIGH_BETA] = self.settings["rayleigh_beta"].GetDouble()
-
-        # Setting the time integration schemes
-        if(scheme_type == "newmark"):
-            damp_factor_m = 0.0
-            newmark_beta = self.settings["newmark_beta"].GetDouble()
-            mechanical_scheme = KratosMultiphysics.ResidualBasedBossakDisplacementScheme(damp_factor_m, newmark_beta)
-        elif(scheme_type == "bossak"):
-            damp_factor_m = self.settings["damp_factor_m"].GetDouble()
-            newmark_beta = self.settings["newmark_beta"].GetDouble()
-            mechanical_scheme = KratosMultiphysics.ResidualBasedBossakDisplacementScheme(damp_factor_m, newmark_beta)
-        elif(scheme_type == "pseudo_static"):
-            mechanical_scheme = KratosMultiphysics.ResidualBasedPseudoStaticDisplacementScheme(StructuralMechanicsApplication.RAYLEIGH_BETA)
-        elif(scheme_type.startswith("bdf") or scheme_type == "backward_euler"):
-            order = auxiliary_methods_solvers.GetBDFIntegrationOrder(scheme_type)
-            # In case of rotation dof we declare the dynamic variables
-            if self.settings["rotation_dofs"].GetBool():
-                bdf_parameters = KratosMultiphysics.Parameters(""" {
-                    "domain_size"           : 3,
-                    "integration_order"     : 2,
-                    "solution_variables"    : ["DISPLACEMENT","ROTATION"]
-                } """)
-                bdf_parameters["domain_size"].SetInt(process_info[KratosMultiphysics.DOMAIN_SIZE])
-                mechanical_scheme = KratosMultiphysics.ResidualBasedBDFCustomScheme(order, bdf_parameters)
-            else:
-                mechanical_scheme = KratosMultiphysics.ResidualBasedBDFDisplacementScheme(order)
-        elif(scheme_type == "relaxation"):
-            damp_factor_f =-0.3
-            dynamic_factor_m = 10.0
-            mechanical_scheme = StructuralMechanicsApplication.ResidualBasedRelaxationScheme(damp_factor_f, dynamic_factor_m)
-        else:
-            err_msg = "The requested scheme type \"" + scheme_type + "\" is not available!\n"
-            err_msg += "Available options are: \"newmark\", \"bossak\", \"pseudo_static\", \"backward_euler\", \"bdf1\", \"bdf2\", \"bdf3\", \"bdf4\", \"bdf5\", \"relaxation\""
-            raise Exception(err_msg)
-        return mechanical_scheme
+# Importing the Kratos Library
+import KratosMultiphysics
+
+# Import applications
+import KratosMultiphysics.StructuralMechanicsApplication as StructuralMechanicsApplication
+
+# Import base class file
+from KratosMultiphysics.StructuralMechanicsApplication.structural_mechanics_solver import MechanicalSolver
+
+from KratosMultiphysics.StructuralMechanicsApplication import auxiliary_methods_solvers
+
+def CreateSolver(model, custom_settings):
+    return ImplicitMechanicalSolver(model, custom_settings)
+
+class ImplicitMechanicalSolver(MechanicalSolver):
+    """The structural mechanics implicit dynamic solver.
+
+    This class creates the mechanical solvers for implicit dynamic analysis.
+    It currently supports Newmark, Bossak and dynamic relaxation schemes.
+
+    See structural_mechanics_solver.py for more information.
+    """
+    def __init__(self, model, custom_settings):
+        # Construct the base solver.
+        super().__init__(model, custom_settings)
+        KratosMultiphysics.Logger.PrintInfo("::[ImplicitMechanicalSolver]:: ", "Construction finished")
+
+    @classmethod
+    def GetDefaultParameters(cls):
+        this_defaults = KratosMultiphysics.Parameters("""{
+            "time_integration_method" : "implicit",
+            "scheme_type"             : "bossak",
+            "damp_factor_m"           :-0.3,
+            "newmark_beta"            : 0.25,
+            "rayleigh_alpha"          : 0.0,
+            "rayleigh_beta"           : 0.0
+        }""")
+        this_defaults.AddMissingParameters(super().GetDefaultParameters())
+        return this_defaults
+
+    def GetMinimumBufferSize(self):
+        base_min_buffer_size = super().GetMinimumBufferSize()
+
+        scheme_type = self.settings["scheme_type"].GetString()
+        if "bdf" in scheme_type or scheme_type == "backward_euler":
+            return max(base_min_buffer_size, auxiliary_methods_solvers.GetBDFIntegrationOrder(scheme_type)+1)
+        else:
+            return base_min_buffer_size
+
+    def AddVariables(self):
+        super().AddVariables()
+        self._add_dynamic_variables()
+        KratosMultiphysics.Logger.PrintInfo("::[ImplicitMechanicalSolver]:: ", "Variables ADDED")
+
+    def AddDofs(self):
+        super().AddDofs()
+        self._add_dynamic_dofs()
+        KratosMultiphysics.Logger.PrintInfo("::[ImplicitMechanicalSolver]:: ", "DOF's ADDED")
+
+    def InitializeSolutionStep(self):
+        # Using the base InitializeSolutionStep
+        super().InitializeSolutionStep()
+
+        # Some pre-processes may affect the system of equations, we rebuild the equation ids
+        process_info = self.main_model_part.ProcessInfo
+        if process_info[KratosMultiphysics.STEP] == 1 and process_info[StructuralMechanicsApplication.RESET_EQUATION_IDS]:
+            # Resetting the global equations ids
+            self._GetBuilderAndSolver().SetUpSystem(self.GetComputingModelPart())
+
+    #### Private functions ####
+
+    def _CreateScheme(self):
+        scheme_type = self.settings["scheme_type"].GetString()
+
+        # Setting the Rayleigh damping parameters
+        process_info = self.main_model_part.ProcessInfo
+        process_info[StructuralMechanicsApplication.RAYLEIGH_ALPHA] = self.settings["rayleigh_alpha"].GetDouble()
+        process_info[StructuralMechanicsApplication.RAYLEIGH_BETA] = self.settings["rayleigh_beta"].GetDouble()
+
+        # Setting the time integration schemes
+        if(scheme_type == "newmark"):
+            damp_factor_m = 0.0
+            newmark_beta = self.settings["newmark_beta"].GetDouble()
+            mechanical_scheme = KratosMultiphysics.ResidualBasedBossakDisplacementScheme(damp_factor_m, newmark_beta)
+        elif(scheme_type == "bossak"):
+            damp_factor_m = self.settings["damp_factor_m"].GetDouble()
+            newmark_beta = self.settings["newmark_beta"].GetDouble()
+            mechanical_scheme = KratosMultiphysics.ResidualBasedBossakDisplacementScheme(damp_factor_m, newmark_beta)
+        elif(scheme_type == "pseudo_static"):
+            mechanical_scheme = KratosMultiphysics.ResidualBasedPseudoStaticDisplacementScheme(StructuralMechanicsApplication.RAYLEIGH_BETA)
+        elif(scheme_type.startswith("bdf") or scheme_type == "backward_euler"):
+            order = auxiliary_methods_solvers.GetBDFIntegrationOrder(scheme_type)
+            # In case of rotation dof we declare the dynamic variables
+            if self.settings["rotation_dofs"].GetBool():
+                bdf_parameters = KratosMultiphysics.Parameters(""" {
+                    "domain_size"           : 3,
+                    "integration_order"     : 2,
+                    "solution_variables"    : ["DISPLACEMENT","ROTATION"]
+                } """)
+                bdf_parameters["domain_size"].SetInt(process_info[KratosMultiphysics.DOMAIN_SIZE])
+                mechanical_scheme = KratosMultiphysics.ResidualBasedBDFCustomScheme(order, bdf_parameters)
+            else:
+                mechanical_scheme = KratosMultiphysics.ResidualBasedBDFDisplacementScheme(order)
+        elif(scheme_type == "relaxation"):
+            damp_factor_f =-0.3
+            dynamic_factor_m = 10.0
+            mechanical_scheme = StructuralMechanicsApplication.ResidualBasedRelaxationScheme(damp_factor_f, dynamic_factor_m)
+        else:
+            err_msg = "The requested scheme type \"" + scheme_type + "\" is not available!\n"
+            err_msg += "Available options are: \"newmark\", \"bossak\", \"pseudo_static\", \"backward_euler\", \"bdf1\", \"bdf2\", \"bdf3\", \"bdf4\", \"bdf5\", \"relaxation\""
+            raise Exception(err_msg)
+        return mechanical_scheme
```

## Comparing `KratosStructuralMechanicsApplication-9.5.dist-info/METADATA` & `KratosStructuralMechanicsApplication-9.5.1.dist-info/METADATA`

 * *Files 8% similar despite different names*

```diff
@@ -1,165 +1,166 @@
-Metadata-Version: 2.1
-Name: KratosStructuralMechanicsApplication
-Version: 9.5
-Summary: KRATOS Multiphysics ("Kratos") is a framework for building parallel, multi-disciplinary simulation software, aiming at modularity, extensibility, and high performance. Kratos is written in C++, and counts with an extensive Python interface.
-Home-page: https://github.com/KratosMultiphysics/
-Author: Kratos Team
-Author-email: kratos@listas.cimne.upc.edu
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: C++
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Programming Language :: Python :: 3.9
-Classifier: Programming Language :: Python :: 3.10
-Classifier: Programming Language :: Python :: 3.11
-Classifier: Topic :: Scientific/Engineering
-Classifier: Topic :: Scientific/Engineering :: Physics
-Classifier: Topic :: Scientific/Engineering :: Mathematics
-Classifier: Natural Language :: English
-Classifier: Intended Audience :: Science/Research
-Classifier: Intended Audience :: Other Audience
-Classifier: Intended Audience :: Developers
-Classifier: Development Status :: 5 - Production/Stable
-Classifier: Environment :: Console
-Classifier: License :: OSI Approved :: BSD License
-Requires-Python: >=3.8
-Description-Content-Type: text/markdown
-Requires-Dist: KratosMultiphysics ==9.5
-
-
-## Structural Mechanics Application
-
-The Structural Mechanics Application contains a series of structural elements, as well as solid elements, constitutive laws and the corresponding strategies and solvers within Kratos Multiphysics.
-
-<p align="center">
-  <img src="https://github.com/KratosMultiphysics/Examples/raw/master/structural_mechanics/validation/beam_roll_up/data/rollup.gif" alt="Solution" style="width: 600px;"/>
-</p>
-
-The application includes tests to check the proper functioning of the application
-
-### Features:
-
-- A set of *Neumann* conditions:
-     * Point loads (loads applied directly on the nodes)
-     * Point moment (a discret moment applied directly on the nodes)
-     * Line load (a distributed load applied over a line)
-     * Surface load (a distributed load applied over a face)
-     * A simple point contact conditions based on the distance
-
-- Solid elements:
-    * Small displacement elements
-    * Total Lagrangian elements
-    * Updated Lagrangian elements
-    * Total Lagrangian prismatic solid-shell element (SPrism)
-
-- Structural elements:
-    * Zero-dimensional elements :
-        * Nodal concentrated element (both 2D/3D). Includes nodal damping, nodal mass and nodal stiffness
-    * Uni-dimensional elements :
-        * Spring-damper element (3D)
-        * Cable element (3D)
-        * Truss element (3D)
-        * Corrotational beam element (both 2D/3D)
-    * Two-dimensional elements :
-        * Membrane (pre-stressed)
-        * Isotropic shell element
-        * Thin shell (Quadrilateral and triangular)
-        * Thick shell (Quadrilateral and triangular)
-
-- Constitutive laws:
-    * Isotropic laws (Plane strain, plane stress and 3D)
-    * Orthotropic law (Plane stress)
-    * Hyperelastic laws:
-        * Neo-Hookean
-        * Kirchhoff
-    * Small displacement isotropic plasticity laws (just 3D):
-        * Combining:
-            * Yield surfaces:
-                * VonMises
-                * ModifiedMohrCoulomb
-                * Tresca
-                * DruckerPrager
-            * Plastic potential:
-                * VonMises
-                * ModifiedMohrCoulomb
-                * Tresca
-                * DruckerPrager
-        * Complete list:
-            * SmallStrainIsotropicPlasticity3DVonMisesVonMises
-            * SmallStrainIsotropicPlasticity3DVonMisesModifiedMohrCoulomb
-            * SmallStrainIsotropicPlasticity3DVonMisesDruckerPrager
-            * SmallStrainIsotropicPlasticity3DVonMisesTresca
-            * SmallStrainIsotropicPlasticity3DModifiedMohrCoulombVonMises
-            * SmallStrainIsotropicPlasticity3DModifiedMohrCoulombModifiedMohrCoulomb
-            * SmallStrainIsotropicPlasticity3DModifiedMohrCoulombDruckerPrager
-            * SmallStrainIsotropicPlasticity3DModifiedMohrCoulombTresca
-            * SmallStrainIsotropicPlasticity3DTrescaVonMises
-            * SmallStrainIsotropicPlasticity3DTrescaModifiedMohrCoulomb
-            * SmallStrainIsotropicPlasticity3DTrescaDruckerPrager
-            * SmallStrainIsotropicPlasticity3DTrescaTresca
-            * SmallStrainIsotropicPlasticity3DDruckerPragerVonMises
-            * SmallStrainIsotropicPlasticity3DDruckerPragerModifiedMohrCoulomb
-            * SmallStrainIsotropicPlasticity3DDruckerPragerDruckerPrager
-            * SmallStrainIsotropicPlasticity3DDruckerPragerTresca
-    * Small displacement isotropic damage laws (just 3D):
-        * Combining:
-            * Yield surfaces:
-                * VonMises
-                * ModifiedMohrCoulomb
-                * Tresca
-                * DruckerPrager
-                * Rankine
-                * SimoJu
-            * Damage potential:
-                * VonMises
-                * ModifiedMohrCoulomb
-                * Tresca
-                * DruckerPrager
-        * Complete list:
-            * SmallStrainIsotropicDamage3DVonMisesVonMises
-            * SmallStrainIsotropicDamage3DVonMisesModifiedMohrCoulomb
-            * SmallStrainIsotropicDamage3DVonMisesDruckerPrager
-            * SmallStrainIsotropicDamage3DVonMisesTresca
-            * SmallStrainIsotropicDamage3DModifiedMohrCoulombVonMises
-            * SmallStrainIsotropicDamage3DModifiedMohrCoulombModifiedMohrCoulomb
-            * SmallStrainIsotropicDamage3DModifiedMohrCoulombDruckerPrager
-            * SmallStrainIsotropicDamage3DModifiedMohrCoulombTresca
-            * SmallStrainIsotropicDamage3DTrescaVonMises
-            * SmallStrainIsotropicDamage3DTrescaModifiedMohrCoulomb
-            * SmallStrainIsotropicDamage3DTrescaDruckerPrager
-            * SmallStrainIsotropicDamage3DTrescaTresca
-            * SmallStrainIsotropicDamage3DDruckerPragerVonMises
-            * SmallStrainIsotropicDamage3DDruckerPragerModifiedMohrCoulomb
-            * SmallStrainIsotropicDamage3DDruckerPragerDruckerPrager
-            * SmallStrainIsotropicDamage3DDruckerPragerTresca
-            * SmallStrainIsotropicDamage3DRankineVonMises
-            * SmallStrainIsotropicDamage3DRankineModifiedMohrCoulomb
-            * SmallStrainIsotropicDamage3DRankineDruckerPrager
-            * SmallStrainIsotropicDamage3DRankineTresca
-            * SmallStrainIsotropicDamage3DSimoJuVonMises
-            * SmallStrainIsotropicDamage3DSimoJuModifiedMohrCoulomb
-            * SmallStrainIsotropicDamage3DSimoJuDruckerPrager
-            * SmallStrainIsotropicDamage3DSimoJuTresca
-
-- Adjoint Sensitivity Analysis:
-    * This feature provides the framework to compute sensitivities of structural responses (e.g. displacements, strain energy or stresses) with respect to different types of design variables (e.g. nodal coordinates, material or cross-sectional properties or load intensity) with the adjoint approach
-
-- Strategies:
-    * Formfinding strategies
-    * Eigensolver strategy
-    * Harmonic analysis strategies
-
-- Schemes:
-    * Relaxation scheme
-    * Eigen solver scheme
-
-- Convergence criteria:
-    * For displacement and other DoF
-    * For displacement and rotation
-
-- Utilities and processe:
-    * A process to post-process eigenvalues
-    * A GiDIO utility for eigen values
-    * Process to compute the global mass of the system
-    * Process to identify the neighbours in a prismatic mesh
-    * Process to transform a pure shell mesh (local dimension equal to 2), to solid-shell mesh (pure 3D mesh)
+Metadata-Version: 2.1
+Name: KratosStructuralMechanicsApplication
+Version: 9.5.1
+Summary: KRATOS Multiphysics ("Kratos") is a framework for building parallel, multi-disciplinary simulation software, aiming at modularity, extensibility, and high performance. Kratos is written in C++, and counts with an extensive Python interface.
+Home-page: https://github.com/KratosMultiphysics/
+Author: Kratos Team
+Author-email: kratos@listas.cimne.upc.edu
+Classifier: Programming Language :: Python :: 3
+Classifier: Programming Language :: C++
+Classifier: Programming Language :: Python
+Classifier: Programming Language :: Python :: 3.8
+Classifier: Programming Language :: Python :: 3.9
+Classifier: Programming Language :: Python :: 3.10
+Classifier: Programming Language :: Python :: 3.11
+Classifier: Programming Language :: Python :: 3.12
+Classifier: Topic :: Scientific/Engineering
+Classifier: Topic :: Scientific/Engineering :: Physics
+Classifier: Topic :: Scientific/Engineering :: Mathematics
+Classifier: Natural Language :: English
+Classifier: Intended Audience :: Science/Research
+Classifier: Intended Audience :: Other Audience
+Classifier: Intended Audience :: Developers
+Classifier: Development Status :: 5 - Production/Stable
+Classifier: Environment :: Console
+Classifier: License :: OSI Approved :: BSD License
+Requires-Python: >=3.8
+Description-Content-Type: text/markdown
+Requires-Dist: KratosMultiphysics ==9.5.1
+
+
+## Structural Mechanics Application
+
+The Structural Mechanics Application contains a series of structural elements, as well as solid elements, constitutive laws and the corresponding strategies and solvers within Kratos Multiphysics.
+
+<p align="center">
+  <img src="https://github.com/KratosMultiphysics/Examples/raw/master/structural_mechanics/validation/beam_roll_up/data/rollup.gif" alt="Solution" style="width: 600px;"/>
+</p>
+
+The application includes tests to check the proper functioning of the application
+
+### Features:
+
+- A set of *Neumann* conditions:
+     * Point loads (loads applied directly on the nodes)
+     * Point moment (a discret moment applied directly on the nodes)
+     * Line load (a distributed load applied over a line)
+     * Surface load (a distributed load applied over a face)
+     * A simple point contact conditions based on the distance
+
+- Solid elements:
+    * Small displacement elements
+    * Total Lagrangian elements
+    * Updated Lagrangian elements
+    * Total Lagrangian prismatic solid-shell element (SPrism)
+
+- Structural elements:
+    * Zero-dimensional elements :
+        * Nodal concentrated element (both 2D/3D). Includes nodal damping, nodal mass and nodal stiffness
+    * Uni-dimensional elements :
+        * Spring-damper element (3D)
+        * Cable element (3D)
+        * Truss element (3D)
+        * Corrotational beam element (both 2D/3D)
+    * Two-dimensional elements :
+        * Membrane (pre-stressed)
+        * Isotropic shell element
+        * Thin shell (Quadrilateral and triangular)
+        * Thick shell (Quadrilateral and triangular)
+
+- Constitutive laws:
+    * Isotropic laws (Plane strain, plane stress and 3D)
+    * Orthotropic law (Plane stress)
+    * Hyperelastic laws:
+        * Neo-Hookean
+        * Kirchhoff
+    * Small displacement isotropic plasticity laws (just 3D):
+        * Combining:
+            * Yield surfaces:
+                * VonMises
+                * ModifiedMohrCoulomb
+                * Tresca
+                * DruckerPrager
+            * Plastic potential:
+                * VonMises
+                * ModifiedMohrCoulomb
+                * Tresca
+                * DruckerPrager
+        * Complete list:
+            * SmallStrainIsotropicPlasticity3DVonMisesVonMises
+            * SmallStrainIsotropicPlasticity3DVonMisesModifiedMohrCoulomb
+            * SmallStrainIsotropicPlasticity3DVonMisesDruckerPrager
+            * SmallStrainIsotropicPlasticity3DVonMisesTresca
+            * SmallStrainIsotropicPlasticity3DModifiedMohrCoulombVonMises
+            * SmallStrainIsotropicPlasticity3DModifiedMohrCoulombModifiedMohrCoulomb
+            * SmallStrainIsotropicPlasticity3DModifiedMohrCoulombDruckerPrager
+            * SmallStrainIsotropicPlasticity3DModifiedMohrCoulombTresca
+            * SmallStrainIsotropicPlasticity3DTrescaVonMises
+            * SmallStrainIsotropicPlasticity3DTrescaModifiedMohrCoulomb
+            * SmallStrainIsotropicPlasticity3DTrescaDruckerPrager
+            * SmallStrainIsotropicPlasticity3DTrescaTresca
+            * SmallStrainIsotropicPlasticity3DDruckerPragerVonMises
+            * SmallStrainIsotropicPlasticity3DDruckerPragerModifiedMohrCoulomb
+            * SmallStrainIsotropicPlasticity3DDruckerPragerDruckerPrager
+            * SmallStrainIsotropicPlasticity3DDruckerPragerTresca
+    * Small displacement isotropic damage laws (just 3D):
+        * Combining:
+            * Yield surfaces:
+                * VonMises
+                * ModifiedMohrCoulomb
+                * Tresca
+                * DruckerPrager
+                * Rankine
+                * SimoJu
+            * Damage potential:
+                * VonMises
+                * ModifiedMohrCoulomb
+                * Tresca
+                * DruckerPrager
+        * Complete list:
+            * SmallStrainIsotropicDamage3DVonMisesVonMises
+            * SmallStrainIsotropicDamage3DVonMisesModifiedMohrCoulomb
+            * SmallStrainIsotropicDamage3DVonMisesDruckerPrager
+            * SmallStrainIsotropicDamage3DVonMisesTresca
+            * SmallStrainIsotropicDamage3DModifiedMohrCoulombVonMises
+            * SmallStrainIsotropicDamage3DModifiedMohrCoulombModifiedMohrCoulomb
+            * SmallStrainIsotropicDamage3DModifiedMohrCoulombDruckerPrager
+            * SmallStrainIsotropicDamage3DModifiedMohrCoulombTresca
+            * SmallStrainIsotropicDamage3DTrescaVonMises
+            * SmallStrainIsotropicDamage3DTrescaModifiedMohrCoulomb
+            * SmallStrainIsotropicDamage3DTrescaDruckerPrager
+            * SmallStrainIsotropicDamage3DTrescaTresca
+            * SmallStrainIsotropicDamage3DDruckerPragerVonMises
+            * SmallStrainIsotropicDamage3DDruckerPragerModifiedMohrCoulomb
+            * SmallStrainIsotropicDamage3DDruckerPragerDruckerPrager
+            * SmallStrainIsotropicDamage3DDruckerPragerTresca
+            * SmallStrainIsotropicDamage3DRankineVonMises
+            * SmallStrainIsotropicDamage3DRankineModifiedMohrCoulomb
+            * SmallStrainIsotropicDamage3DRankineDruckerPrager
+            * SmallStrainIsotropicDamage3DRankineTresca
+            * SmallStrainIsotropicDamage3DSimoJuVonMises
+            * SmallStrainIsotropicDamage3DSimoJuModifiedMohrCoulomb
+            * SmallStrainIsotropicDamage3DSimoJuDruckerPrager
+            * SmallStrainIsotropicDamage3DSimoJuTresca
+
+- Adjoint Sensitivity Analysis:
+    * This feature provides the framework to compute sensitivities of structural responses (e.g. displacements, strain energy or stresses) with respect to different types of design variables (e.g. nodal coordinates, material or cross-sectional properties or load intensity) with the adjoint approach
+
+- Strategies:
+    * Formfinding strategies
+    * Eigensolver strategy
+    * Harmonic analysis strategies
+
+- Schemes:
+    * Relaxation scheme
+    * Eigen solver scheme
+
+- Convergence criteria:
+    * For displacement and other DoF
+    * For displacement and rotation
+
+- Utilities and processe:
+    * A process to post-process eigenvalues
+    * A GiDIO utility for eigen values
+    * Process to compute the global mass of the system
+    * Process to identify the neighbours in a prismatic mesh
+    * Process to transform a pure shell mesh (local dimension equal to 2), to solid-shell mesh (pure 3D mesh)
```

## Comparing `KratosStructuralMechanicsApplication-9.5.dist-info/RECORD` & `KratosStructuralMechanicsApplication-9.5.1.dist-info/RECORD`

 * *Files 9% similar despite different names*

```diff
@@ -1,59 +1,59 @@
-KratosStructuralMechanicsApplication-9.5.dist-info/METADATA,sha256=B2MRv2XbT7E-Xo5npAASyZ4auH8uQzW9Pxp-_S06aIM,7617
-KratosStructuralMechanicsApplication-9.5.dist-info/WHEEL,sha256=rY0Y6THYM7EImsHfF-zs67o8pQciAsMw9_YuSvftjrQ,148
-KratosStructuralMechanicsApplication-9.5.dist-info/top_level.txt,sha256=8Ov--opRCptLbHStjyiZUVpzN1OUU_F7c7fGmsR5cMc,19
-KratosStructuralMechanicsApplication-9.5.dist-info/RECORD,,
-KratosMultiphysics/.libs/KratosStructuralMechanicsApplication.cpython-39-x86_64-linux-gnu.so,sha256=7ZMBurrcWTqfBDkiFZ-raXbFYA0yl07zvZMK0IgbDow,4440041
-KratosMultiphysics/.libs/libKratosStructuralMechanicsCore.so,sha256=HgpXC-mYeUfqKybyR4LX8IvrBmu87Tbo7yDa_6WZQj8,24079233
-KratosMultiphysics/StructuralMechanicsApplication/postprocess_eigenvalues_process.py,sha256=xoWenUB0OXMEpDsdENM5_UH6N9jjOKY67BcteYNkTLU,1063
-KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_harmonic_analysis_solver.py,sha256=QasWPMYNsdaz9Ax9D9TKNN3buRDRVGmfjftEt2j0l9g,2791
-KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_analysis.py,sha256=5Gpx0xXuQblN_j9p1A3RpbnTdUQrxqmUVow3-piIEt4,11139
-KratosMultiphysics/StructuralMechanicsApplication/set_automated_initial_variable_process.py,sha256=3YzCeprJGRXCASeLz-q3948H5SL8uNCB5ot0NecSdO0,6115
-KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_prebuckling_solver.py,sha256=boQnC_ezNKSIEOY2AP89dkjcanIq9mvbRJodAtJQPeA,5935
-KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_static_solver.py,sha256=J_lb2obnic3BKWXx6OzUmT7yvJ1-WPRLQ6rxnOILkNk,870
-KratosMultiphysics/StructuralMechanicsApplication/perturb_geometry_subgrid_utility.py,sha256=XzLgjWvkoB5fjrVcTRqyw9xL3-8RIM9nDHqOAJHUe3Y,2477
-KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_adjoint_static_solver.py,sha256=Kz9tEgT_do_NoPZ9CLD1SYpjVYEszrzmYXw-riNxmvk,10437
-KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_solver.py,sha256=sgIlxCccsIEfXuKaePPMm_gMufyyyJbb4V4qHKAqv44,6937
-KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_implicit_dynamic_solver.py,sha256=M2-7OOdY28Q8ahbM_xTvNG53E9bqr5lIQK0a_i9PsVk,3325
-KratosMultiphysics/StructuralMechanicsApplication/auxiliary_methods_solvers.py,sha256=tHmhymNwrrKUF8tn8l5xdM6i95BNLcOw6qIvRKr1PJU,790
-KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_formfinding_solver.py,sha256=rJZudN0TV1-XmXXOeJ6twz7eN67OsWH1V2z0Yhxbe70,4139
-KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_eigensolver.py,sha256=Pt7M_sxLUFLesGPO2NuFMbSFiq_XnkhzCDxnFKkS00E,5096
-KratosMultiphysics/StructuralMechanicsApplication/structural_response_function_factory.py,sha256=tRu1a9rBErWTK2QsQMDh-FVAJqj0IOVRECHq_KL2hY0,1776
-KratosMultiphysics/StructuralMechanicsApplication/kratos_main_structural.py,sha256=Jql71MMpN31Qg2Xk_0VZlf3gFxjafzgXxP2jhZm2oBk,560
-KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_utilities.py,sha256=8OgyOGXvXFH7yvy2pjFuTlLc_xqi1T3eAGXTrS-MZFw,4614
-KratosMultiphysics/StructuralMechanicsApplication/impose_rigid_movement_process.py,sha256=G1X8vssOLqE5mFVcc0kiJ7MLwUBoeGazvegWVoFNcyQ,5900
-KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_implicit_dynamic_solver.py,sha256=__KlmN0gVJ9iEAn8mZlXNlfKGprkpsO3ugbziqqXr-U,4285
-KratosMultiphysics/StructuralMechanicsApplication/perturb_geometry_sparse_utility.py,sha256=ySA86K0EDVCEvctv1bLzeaGqOYj9jFvPoabCZtSI-B0,2178
-KratosMultiphysics/StructuralMechanicsApplication/structural_response.py,sha256=16oZB9q921Ub34qmm_9Vg_YB4SP5r_bu714eXfujiXU,23100
-KratosMultiphysics/StructuralMechanicsApplication/displacement_control_with_direction_process.py,sha256=MzQF9Us8Bmp0Jq6XY4wFWbJpMScx6g1hVk3NCIabwQA,4091
-KratosMultiphysics/StructuralMechanicsApplication/distribute_load_on_surface_process.py,sha256=Jr6XA7HN_LUJs_d99caZdyxOYI4LixFeP655ETCy3bw,450
-KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_analysis.py,sha256=WYTYbWWcGYhqY1kWWDb8TDgsaUmoWfdKJPJCyyZUcro,7254
-KratosMultiphysics/StructuralMechanicsApplication/python_solvers_wrapper_structural.py,sha256=fsgIt8fMn5hUm1OmTKoi8wokLlxjHEAhW7yq3mVZHhs,5453
-KratosMultiphysics/StructuralMechanicsApplication/auxiliary_methods_adaptative_solvers.py,sha256=N7lHy7AtedFfqryevldw2iMYrldoH5RNqK4OiB4JXr8,1799
-KratosMultiphysics/StructuralMechanicsApplication/check_eigenvalues_process.py,sha256=Nf5ETq6IhIicMm1aSylwcjRG8CNyoQGXeC1fuL_RyHM,1687
-KratosMultiphysics/StructuralMechanicsApplication/convergence_criteria_factory.py,sha256=dgPvljAJOPRkSc5fpzkD4fDXpN7m5WClH1RLQmDFqhM,7950
-KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_custom_scipy_base_solver.py,sha256=41GmIDuDZaW3xrwuaXku4L047F4r_m5hzlPT_3Wkiw4,8700
-KratosMultiphysics/StructuralMechanicsApplication/set_cylindrical_local_axes_process.py,sha256=OUg45mCGYl0DFbVzjHmOGtReqPftmpY4uzfDnOoyBwI,1085
-KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_explicit_dynamic_solver.py,sha256=hcKdevGPE50L-RRkdk9t_0xwhub78wr6O91v3JLuPg0,6830
-KratosMultiphysics/StructuralMechanicsApplication/set_spherical_local_axes_process.py,sha256=hexl3etjxLH4lsysP95M6d2JcfqR8_Zeg3atTti1gJQ,1067
-KratosMultiphysics/StructuralMechanicsApplication/automatic_rayleigh_parameters_computation_process.py,sha256=gspOJjV7je3HJ-eonSUtdmZJICW0m-D36MQNqKLEsRk,9013
-KratosMultiphysics/StructuralMechanicsApplication/eigen_solution_output_process.py,sha256=2Su6JLDDjJjMqyRVCniwrHS4u8GrZBpbyYzkIkuOoko,1902
-KratosMultiphysics/StructuralMechanicsApplication/rve_analysis.py,sha256=zf1yRGWJSZg8kbLTqFfCiwy-QCIIyxKNb1Mzmn-D_ws,16458
-KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_prebuckling_analysis.py,sha256=vlFYwoVFbD6yuLjIdvXjtM3KAiiAdHdczRRISwn07po,4627
-KratosMultiphysics/StructuralMechanicsApplication/eigen_solution_input_process.py,sha256=V6k2Rc8HmGvlVQdyq8yG324Ca3_c22sZ9e-rI8US6SY,1921
-KratosMultiphysics/StructuralMechanicsApplication/set_cartesian_local_axes_process.py,sha256=WOUJkdpPzl6hC9iKgIR1z2yR5-EoEOTYS6tA22o5wfc,1009
-KratosMultiphysics/StructuralMechanicsApplication/simplified_nodal_contact_process.py,sha256=1ItR1dCygfUxohfE9CPd36Ct00kBLLzy3sv5fSk6VR0,8307
-KratosMultiphysics/StructuralMechanicsApplication/sprism_process.py,sha256=VOEILTYbjQE86HSZ_9hpXy9Eb9SOVKXPywGWLD_rf9U,4747
-KratosMultiphysics/StructuralMechanicsApplication/__init__.py,sha256=H4K7EPjljXew-iJw9kgFzru9pjHlGJW-Zgi5R7XSefE,560
-KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_solver.py,sha256=hynhqEz3za_AqFlXpbYruU3s9UH7z4UM5njXMvxtxXs,30147
-KratosMultiphysics/StructuralMechanicsApplication/impose_z_strain_process.py,sha256=yFVOJqENVcGsUVVXk_ZJUkCXPmlvjp2MWCJ1iLphs3c,705
-KratosMultiphysics/StructuralMechanicsApplication/trilinos_convergence_criteria_factory.py,sha256=6eOqo_EIA-Iz5o3PfE2lw4XgR4OVwnw4_7QT_S78O4s,3755
-KratosMultiphysics/StructuralMechanicsApplication/set_moving_load_process.py,sha256=GDBNjFMi_UsVVUU79aWulzJYA-YO28ZBMpCqUEdM65M,1950
-KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_static_shifted_boundary_solver.py,sha256=4IzS-XWNTp8zaKfbBo8PyZsLLU7CBDKPqoqTiRxoH80,3245
-KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_static_solver.py,sha256=M7eZu-w0qDMP7kV3dewYzKAVSaavyATgs6eoF8ShuGo,1009
-KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_static_solver.py,sha256=LoSTsasEM1zbumo618tIXAKza9T5XuH9tOePECUDMJQ,3275
-KratosMultiphysics/StructuralMechanicsApplication/element_sensitivity_domain_integration_process.py,sha256=9LMP-EGLDvWmZrptTUF7jtHLpKXV7wjy07RV2itScWU,5560
-KratosMultiphysics/StructuralMechanicsApplication/project_vector_on_surface_process.py,sha256=7wsACDLKh6CO_OUQGjM9cVz997Z_kJQpQbQWnJR0tXM,2407
-KratosMultiphysics/StructuralMechanicsApplication/python_solvers_wrapper_adaptative_remeshing_structural.py,sha256=Wvih44gEiXtSA9BN71WzoA2RxDhnfaJZ6Vq1ea80E8k,1597
-KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_implicit_dynamic_solver.py,sha256=TY-W7nCTQA_HUXtlsBuwqu6Mb9KHZ82ttu7SuI1ALng,5591
-KratosMultiphysics/StructuralMechanicsApplication/symbolic_generation/total_lagrangian_mixed_volumetric_strain_element/generate_total_lagrangian_mixed_volumetric_strain_element.py,sha256=JKB08cyIDjNHcMZ4pW_DWbKjXgVmhzWC9W9DGzFaFm0,10566
-KratosStructuralMechanicsApplication.libs/libKratosStructuralMechanicsCore-d06c43d3.so,sha256=kNNiTF23PiVxUu9fFewusHGA6gRiSZAAuDgtvIThy0U,25336065
+KratosMultiphysics/.libs/KratosStructuralMechanicsApplication.pyd,sha256=1wkQQSP5oTbLDv2qxyVVyDBHHgUkdC9x6EGhU2hSNq8,1643520
+KratosMultiphysics/.libs/KratosStructuralMechanicsCore.dll,sha256=QkOUTb6nveIQgLn8Ti4s9i4xS7MRTi8kNNwvvGm-XVk,9037312
+KratosMultiphysics/.libs/KratosStructuralMechanicsCore.lib,sha256=S2fYO_qG7OAdmM32ZaIRdmWqtXhGtVbQqVXQ-gFdn60,2216930
+KratosMultiphysics/StructuralMechanicsApplication/__init__.py,sha256=Bz1gnrl6bdE65oivAPDUdm0FvJrpwP0rWG8Azd9ULLQ,572
+KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_analysis.py,sha256=P-tp7Aia9ARu2q-1a1k6y6lP3LydW2ewkW87biUyoAI,11353
+KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_implicit_dynamic_solver.py,sha256=ezZZXQgHCchpPoZeUfC7wc8NJS3tWQs8KbduzNo_GQk,3394
+KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_static_solver.py,sha256=BFXpXEAKDN09Zlre4wnQe3h4Nz5bs7Q9Gv2my3dwLxQ,3344
+KratosMultiphysics/StructuralMechanicsApplication/adaptative_remeshing_structural_mechanics_utilities.py,sha256=2aosxnEHz_9hsF0vdOQLIey3cMld26fKkOBmA3hpf70,4708
+KratosMultiphysics/StructuralMechanicsApplication/automatic_rayleigh_parameters_computation_process.py,sha256=QVbeEstuoO1KYSh-1iSZ9PleNf6CMSvshaDISUwyAU4,9204
+KratosMultiphysics/StructuralMechanicsApplication/auxiliary_methods_adaptative_solvers.py,sha256=gAPCMV3pImNr2_5bNoV7NYFcSSqJmNlotswlr8UXp6s,1836
+KratosMultiphysics/StructuralMechanicsApplication/auxiliary_methods_solvers.py,sha256=7c5nx5S6vVUuE5mSqvYrpoBf_7S_szrJjC-m-hrJrR4,808
+KratosMultiphysics/StructuralMechanicsApplication/check_eigenvalues_process.py,sha256=zPgSW2OZpt94vVeEeoZCX4pTWDBR8A5w-fPQMoztPbA,1725
+KratosMultiphysics/StructuralMechanicsApplication/convergence_criteria_factory.py,sha256=7j6zUtJN_ihIdVzoh71ByPPKF7_KHqXiWccECj_qRLY,8079
+KratosMultiphysics/StructuralMechanicsApplication/displacement_control_with_direction_process.py,sha256=skHmJin4yjKWsbtmgPHFaCoZlM65_QwVT2PdNXlPRms,4179
+KratosMultiphysics/StructuralMechanicsApplication/distribute_load_on_surface_process.py,sha256=7tkP9-p1Nb7MhNf4PdOOpECaeMfRp2sAFhSaCNndhpw,460
+KratosMultiphysics/StructuralMechanicsApplication/eigen_solution_input_process.py,sha256=bQP6cgf7bhJ8bHkwn_F4EnQfLYByRrI39hMMZPr2npo,1966
+KratosMultiphysics/StructuralMechanicsApplication/eigen_solution_output_process.py,sha256=onchYJ2mGqa8BhYN20tka1XHx_bQqj34VYq8QZI2qUQ,1947
+KratosMultiphysics/StructuralMechanicsApplication/element_sensitivity_domain_integration_process.py,sha256=RO5gDvcZCymgxhdksfGQOgVjed2ioMsKVZA6FA0CcU0,5680
+KratosMultiphysics/StructuralMechanicsApplication/impose_rigid_movement_process.py,sha256=zEozEgW431pyNvf8NWHmPuYbo7sA8hfY26mZXxVDsK8,6012
+KratosMultiphysics/StructuralMechanicsApplication/impose_z_strain_process.py,sha256=yFVOJqENVcGsUVVXk_ZJUkCXPmlvjp2MWCJ1iLphs3c,705
+KratosMultiphysics/StructuralMechanicsApplication/kratos_main_structural.py,sha256=G7FXsI0zjt-NxsvThX9PYhFdr29e9T3wglnlvx2NI8w,576
+KratosMultiphysics/StructuralMechanicsApplication/perturb_geometry_sparse_utility.py,sha256=Y50QrlgiEgukkOyl4q2Cw2YT-gcbXQsWpnq5Xq6pGoc,2235
+KratosMultiphysics/StructuralMechanicsApplication/perturb_geometry_subgrid_utility.py,sha256=ADX7Se-GcdZzLUtKN5_G_6lMm0dhCEBVC3y-1SGzd8A,2534
+KratosMultiphysics/StructuralMechanicsApplication/postprocess_eigenvalues_process.py,sha256=Ff0Uzu_BEvR0G2DVK1qV95Fp7SC8C8GfuLDFrmOSPv4,1086
+KratosMultiphysics/StructuralMechanicsApplication/project_vector_on_surface_process.py,sha256=JPIvLbH3Qk8Nt5mLDnUqBqH762kSMuALhZ8CPl_3RZk,2463
+KratosMultiphysics/StructuralMechanicsApplication/python_solvers_wrapper_adaptative_remeshing_structural.py,sha256=J73wwadR7udN4a_7zLDGXaxFAZi0_peevdcA0SVidxU,1630
+KratosMultiphysics/StructuralMechanicsApplication/python_solvers_wrapper_structural.py,sha256=rqBsVOVzB171PvY4aVR-Vy30k3QZvPM-VhZXb7Lg_ao,5568
+KratosMultiphysics/StructuralMechanicsApplication/rve_analysis.py,sha256=H4--3ioDZsbHC3suOIAStEBkStOPpMsms2kYlssU4c8,16824
+KratosMultiphysics/StructuralMechanicsApplication/set_automated_initial_variable_process.py,sha256=zlIMUg7EcZ1MiTz4lJ3qISpFkhjlFrQNvhJeYDNlksU,6216
+KratosMultiphysics/StructuralMechanicsApplication/set_cartesian_local_axes_process.py,sha256=vtumeJYxY79wF12bT5vFRfdLs6jCmKxy6xhAZplr_g4,1035
+KratosMultiphysics/StructuralMechanicsApplication/set_cylindrical_local_axes_process.py,sha256=Um-XAuMovU_7vdOZAgCu-UN8erCdjYmyaRUDJ-eGD6M,1113
+KratosMultiphysics/StructuralMechanicsApplication/set_moving_load_process.py,sha256=NoLaZsTjKtUC_mMGDrQ7fms_QV7DBbv-55D_qzC8dnM,1986
+KratosMultiphysics/StructuralMechanicsApplication/set_spherical_local_axes_process.py,sha256=k0C3G9cug7homA-GWj9kLwqRbb35AWYon4DemYHkW2Y,1092
+KratosMultiphysics/StructuralMechanicsApplication/simplified_nodal_contact_process.py,sha256=2bVG_nbifgwSxyBjIz-vSyVotjQWZLBRllQLHylKu5Q,8491
+KratosMultiphysics/StructuralMechanicsApplication/sprism_process.py,sha256=stKMyWiLvkvYBsGfCfSCRTT5DDYUCyl4mI2CTbTCRn4,4852
+KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_adjoint_static_solver.py,sha256=EK-VlL7qj6EZTHf98Ph6KDeRt6w5hBWT9ZrEU4MKZ8U,10602
+KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_analysis.py,sha256=tx6DQ4WSx7OEKmWCaT3OTyAU-5_FnKzS1VyzZnib0lU,7392
+KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_custom_scipy_base_solver.py,sha256=bIvRI5IiPVAEV649AVqeZI_2XfD12jWWzYoYGmhjx8s,8892
+KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_eigensolver.py,sha256=pDuarqpNnLYA2_3bTUyr04f25hzs2meejFI4zyj6nM4,5200
+KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_explicit_dynamic_solver.py,sha256=5UUiCNZcEW8HrLhCQy652Hhh-gjz7MqCdvIq2Y3kWFo,6959
+KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_formfinding_solver.py,sha256=-UFVFaBF1QpJCIMoREThz-qZZ2hNj9of2NP4N2x-e7Y,4220
+KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_harmonic_analysis_solver.py,sha256=VJgXXBfGAaOl3B3kNncgmwD3bEp5AwGYTQAMNOyU9vo,2859
+KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_implicit_dynamic_solver.py,sha256=vmV_eckGmOOhfAWoaC7feaNCZsIrJC-wuETF5eNTzws,5703
+KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_prebuckling_analysis.py,sha256=sJ8-IXp2LCFRqY4ceriNDIfUv9qB7GGSvl3XAR13Mac,4725
+KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_prebuckling_solver.py,sha256=cVpeCF8MiB1HImw26sw-0PBm-IvZyLNIK5Ys-WX7hEg,6053
+KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_solver.py,sha256=7rO3ZuGGt614jSxxLDNusxgBtIy1Rg9djBLiS98F7MQ,30687
+KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_static_shifted_boundary_solver.py,sha256=jcDcfeJEEDoh8W7pK9A3YYrSuocaIbePqdASlisslGo,3311
+KratosMultiphysics/StructuralMechanicsApplication/structural_mechanics_static_solver.py,sha256=e06Qd-rVTYiUM4uMFFKEZmD2DeFOfqWaEkxyxu4M--4,893
+KratosMultiphysics/StructuralMechanicsApplication/structural_response.py,sha256=7BTBk9t6ZjCPNDJhOo7qAH6BQMWP_TP0TT6EigKOAG4,23537
+KratosMultiphysics/StructuralMechanicsApplication/structural_response_function_factory.py,sha256=ZOOYMOtSbGyVnxtNOeW1t0fD-SqN0GJZ8rOtlJsO77Y,1809
+KratosMultiphysics/StructuralMechanicsApplication/trilinos_convergence_criteria_factory.py,sha256=RA8OQRwSvvgMrdFs8lcQ939ZP7LjOkx6hadHM33KzNQ,3824
+KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_implicit_dynamic_solver.py,sha256=TocaC4TRGbYvOA0ti-CMZg2dM235vbG_ZPNv4NXDYtE,4374
+KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_solver.py,sha256=z_-a50lv7IT7QonbpnX8h-mAoPX0TOI0MXt1fDmuVM4,7068
+KratosMultiphysics/StructuralMechanicsApplication/trilinos_structural_mechanics_static_solver.py,sha256=jYWFyL3hHjFfwxVF7e8Uo0_wjd962xVTxai92Ci9DqQ,1035
+KratosMultiphysics/StructuralMechanicsApplication/symbolic_generation/total_lagrangian_mixed_volumetric_strain_element/generate_total_lagrangian_mixed_volumetric_strain_element.py,sha256=0frYxn0PnZL_pe-WoZaaClLC_ET4DSgBeEjRj3W-RRc,10780
+KratosStructuralMechanicsApplication-9.5.1.dist-info/METADATA,sha256=vZWAcXrG--ghxA60bNgpIrznHR0FYHVorP7C-QR3Vx8,7838
+KratosStructuralMechanicsApplication-9.5.1.dist-info/WHEEL,sha256=GZFS91_ufm4WrNPBaFVPB9MvOXR6bMZQhPcZRRTN5YM,100
+KratosStructuralMechanicsApplication-9.5.1.dist-info/top_level.txt,sha256=8Ov--opRCptLbHStjyiZUVpzN1OUU_F7c7fGmsR5cMc,19
+KratosStructuralMechanicsApplication-9.5.1.dist-info/RECORD,,
```


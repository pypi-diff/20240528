# Comparing `tmp/qiskit_pqcee_provider-0.1.2-py2.py3-none-any.whl.zip` & `tmp/qiskit_pqcee_provider-0.1.3-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,21 +1,23 @@
-Zip file size: 22586 bytes, number of entries: 19
--rw-r--r--  2.0 unx     1165 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider/__init__.py
--rw-r--r--  2.0 unx     4529 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider/backend.py
--rw-r--r--  2.0 unx     5004 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider/job.py
--rw-r--r--  2.0 unx       72 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider/mumbai_testnet_config.ini
--rw-r--r--  2.0 unx     7879 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider/provider.py
--rw-r--r--  2.0 unx    14222 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider/setup_mumbai_testnet.py
--rw-r--r--  2.0 unx    16886 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider/contracts/QuantumBackendContract.sol
--rw-r--r--  2.0 unx      700 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider/contracts/QuantumBackendInterface.sol
--rw-r--r--  2.0 unx     1605 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider/contracts/QuantumProviderContract.sol
--rw-r--r--  2.0 unx      351 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider/contracts/QuantumProviderInterface.sol
--rw-r--r--  2.0 unx      157 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider/quic/__init__.py
--rw-r--r--  2.0 unx    11066 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider/quic/backend.py
--rw-r--r--  2.0 unx     4298 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider/quic/gate.py
--rw-r--r--  2.0 unx     3577 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider/quic/target.py
--rw-r--r--  2.0 unx     1062 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider-0.1.2.dist-info/LICENSE.txt
--rw-r--r--  2.0 unx     1426 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider-0.1.2.dist-info/METADATA
--rw-r--r--  2.0 unx      110 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider-0.1.2.dist-info/WHEEL
--rw-r--r--  2.0 unx       22 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider-0.1.2.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     1856 b- defN 24-Feb-29 01:36 qiskit_pqcee_provider-0.1.2.dist-info/RECORD
-19 files, 75987 bytes uncompressed, 19456 bytes compressed:  74.4%
+Zip file size: 28031 bytes, number of entries: 21
+-rw-r--r--  2.0 unx     1145 b- defN 24-May-28 02:59 qiskit_pqcee_provider/__init__.py
+-rw-r--r--  2.0 unx      132 b- defN 24-May-28 02:59 qiskit_pqcee_provider/amoy_testnet_config.ini
+-rw-r--r--  2.0 unx    20248 b- defN 24-May-28 02:59 qiskit_pqcee_provider/backend.py
+-rw-r--r--  2.0 unx     5004 b- defN 24-May-28 02:59 qiskit_pqcee_provider/job.py
+-rw-r--r--  2.0 unx     8348 b- defN 24-May-28 02:59 qiskit_pqcee_provider/provider.py
+-rw-r--r--  2.0 unx    13419 b- defN 24-May-28 02:59 qiskit_pqcee_provider/setup_amoy_testnet.py
+-rw-r--r--  2.0 unx    14222 b- defN 24-May-28 02:59 qiskit_pqcee_provider/setup_mumbai_testnet.py
+-rw-r--r--  2.0 unx      379 b- defN 24-May-28 02:59 qiskit_pqcee_provider/test_provider.py
+-rw-r--r--  2.0 unx    16894 b- defN 24-May-28 02:59 qiskit_pqcee_provider/contracts/QuantumBackendContract.sol
+-rw-r--r--  2.0 unx      700 b- defN 24-May-28 02:59 qiskit_pqcee_provider/contracts/QuantumBackendInterface.sol
+-rw-r--r--  2.0 unx     1605 b- defN 24-May-28 02:59 qiskit_pqcee_provider/contracts/QuantumProviderContract.sol
+-rw-r--r--  2.0 unx      351 b- defN 24-May-28 02:59 qiskit_pqcee_provider/contracts/QuantumProviderInterface.sol
+-rw-r--r--  2.0 unx      157 b- defN 24-May-28 02:59 qiskit_pqcee_provider/quic/__init__.py
+-rw-r--r--  2.0 unx    11066 b- defN 24-May-28 02:59 qiskit_pqcee_provider/quic/backend.py
+-rw-r--r--  2.0 unx     4298 b- defN 24-May-28 02:59 qiskit_pqcee_provider/quic/gate.py
+-rw-r--r--  2.0 unx     3577 b- defN 24-May-28 02:59 qiskit_pqcee_provider/quic/target.py
+-rw-r--r--  2.0 unx     1062 b- defN 24-May-28 02:59 qiskit_pqcee_provider-0.1.3.dist-info/LICENSE.txt
+-rw-r--r--  2.0 unx     1581 b- defN 24-May-28 02:59 qiskit_pqcee_provider-0.1.3.dist-info/METADATA
+-rw-r--r--  2.0 unx      110 b- defN 24-May-28 02:59 qiskit_pqcee_provider-0.1.3.dist-info/WHEEL
+-rw-r--r--  2.0 unx       22 b- defN 24-May-28 02:59 qiskit_pqcee_provider-0.1.3.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     2051 b- defN 24-May-28 02:59 qiskit_pqcee_provider-0.1.3.dist-info/RECORD
+21 files, 106371 bytes uncompressed, 24591 bytes compressed:  76.9%
```

## zipnote {}

```diff
@@ -1,25 +1,31 @@
 Filename: qiskit_pqcee_provider/__init__.py
 Comment: 
 
+Filename: qiskit_pqcee_provider/amoy_testnet_config.ini
+Comment: 
+
 Filename: qiskit_pqcee_provider/backend.py
 Comment: 
 
 Filename: qiskit_pqcee_provider/job.py
 Comment: 
 
-Filename: qiskit_pqcee_provider/mumbai_testnet_config.ini
+Filename: qiskit_pqcee_provider/provider.py
 Comment: 
 
-Filename: qiskit_pqcee_provider/provider.py
+Filename: qiskit_pqcee_provider/setup_amoy_testnet.py
 Comment: 
 
 Filename: qiskit_pqcee_provider/setup_mumbai_testnet.py
 Comment: 
 
+Filename: qiskit_pqcee_provider/test_provider.py
+Comment: 
+
 Filename: qiskit_pqcee_provider/contracts/QuantumBackendContract.sol
 Comment: 
 
 Filename: qiskit_pqcee_provider/contracts/QuantumBackendInterface.sol
 Comment: 
 
 Filename: qiskit_pqcee_provider/contracts/QuantumProviderContract.sol
@@ -36,23 +42,23 @@
 
 Filename: qiskit_pqcee_provider/quic/gate.py
 Comment: 
 
 Filename: qiskit_pqcee_provider/quic/target.py
 Comment: 
 
-Filename: qiskit_pqcee_provider-0.1.2.dist-info/LICENSE.txt
+Filename: qiskit_pqcee_provider-0.1.3.dist-info/LICENSE.txt
 Comment: 
 
-Filename: qiskit_pqcee_provider-0.1.2.dist-info/METADATA
+Filename: qiskit_pqcee_provider-0.1.3.dist-info/METADATA
 Comment: 
 
-Filename: qiskit_pqcee_provider-0.1.2.dist-info/WHEEL
+Filename: qiskit_pqcee_provider-0.1.3.dist-info/WHEEL
 Comment: 
 
-Filename: qiskit_pqcee_provider-0.1.2.dist-info/top_level.txt
+Filename: qiskit_pqcee_provider-0.1.3.dist-info/top_level.txt
 Comment: 
 
-Filename: qiskit_pqcee_provider-0.1.2.dist-info/RECORD
+Filename: qiskit_pqcee_provider-0.1.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## qiskit_pqcee_provider/__init__.py

```diff
@@ -1,29 +1,27 @@
 from .provider import BlockchainProvider
 from .provider import LocalPqceeProvider
 from .provider import PqceeProvider
 from .backend import BlockchainBackend
 from .job import BlockcahinJob
 
-__author__ = "Stefan-Dan Ciocirlan (sdcioc)"
+__author__ = "pQCee Product Team"
 __copyright__ = "Copyright 2023, Singapore Blockchain Innovation Programme"
-__credits__ = ["Teik Guan Tan", "Sian (Jonathan) Liu"]
+__credits__ = ["Teik Guan Tan", "Sian (Jonathan) Liu", "Stefan-Dan Ciocirlan"]
 __license__ = "MIT"
-__maintainer__ = "Stefan-Dan Ciocirlan"
-__email__ = "stefan_dan@xn--ciocrlan-o2a.ro"
+__maintainer__ = "Jonathan Liu"
+__email__ = "jonathan@pqcee.com"
 __status__ = "Production"
 
 __all__ = [
-    "quic",
     "BlockchainProvider",
     "BlockchainBackend",
     "BlockcahinJob",
     "LocalPqceeProvider",
-    "PqceeProvider",
-
+    "PqceeProvider"
 ]
 
 # read the verison from the file
 import pathlib
 
 # the current directory
 ROOT_DIR = pathlib.Path(__file__).absolute().parent
@@ -32,14 +30,15 @@
 VERSION_FILE = (ROOT_DIR / "VERSION.txt").resolve()
 
 # read the version
 with open(VERSION_FILE, "r") as version_file:
     VERSION = version_file.read().strip()
 
 __version__ = VERSION
+
 # install solc if not already installed
 import solcx
 
 try:
     solcx.install.get_executable(version='0.8.21')
 except solcx.exceptions.SolcNotInstalled:
     solcx.install_solc(version='0.8.21')
```

## qiskit_pqcee_provider/backend.py

```diff
@@ -1,57 +1,74 @@
-from typing_extensions import override
+from qiskit.providers import BackendV2 as Backend
 from qiskit.providers import ProviderV1 as Provider
+from qiskit.transpiler import Target
 from qiskit.providers import Options
+from qiskit.circuit import Measure
+from qiskit.circuit.library import CXGate, IGate, ZGate
+from qiskit.circuit.library import XGate, HGate, CCXGate, YGate
+from qiskit.circuit.library import SGate, SdgGate, TGate, TdgGate
+from qiskit.circuit.library import CSGate, CSdgGate
+# from qiskit.circuit.library import PhaseGate, RXGate
+# from qiskit.circuit.library import ZGate, CPhaseGate, RGate, CRXGate
+from qiskit.circuit.equivalence_library import SessionEquivalenceLibrary
+from qiskit.synthesis import generate_basic_approximations
+from qiskit.transpiler.passes.synthesis import SolovayKitaev
+from qiskit.transpiler.preset_passmanagers import generate_preset_pass_manager
+from qiskit.transpiler import PassManager
 # from qiskit.circuit.gate import Gate
 import numpy as np
 import logging
+import qiskit
 
 import web3
 import pathlib
 from solcx import compile_source
 
 from .job import BlockcahinJob
-from .quic import QuiCBackend
 
 logger = logging.getLogger(__name__)
 
 
-class BlockchainBackend(QuiCBackend):
+class BlockchainBackend(Backend):
     r"""
     The quantum backend on the blockchain.
     """
 
     web3_contract: web3.contract.Contract = None
     r"""
     The backend smart contract.
     """
     state_seed: np.random.RandomState = None
     r"""
     The seed random state
     """
+    skd_pass_manager: PassManager = None
+    r"""
+    The pass manager for the Solovay-Kitaev algorithm.
+    """
 
     def __init__(
             self,
             provider: Provider,
             web3_provider: web3.Web3,
             backend_address: str,
             is_local: bool = False,
             backend_seed: int = 0,
-            approximation_depth: int = 0,
-            approximation_recursion_degree: int = 0,
+            basic_approx_depth: int = 3,
+            skd_recursion_degree: int = 3,
     ):
         r"""
         Args:
             provider: The qiskit provider of the backend.
             web3_provider: The web3 provider for the blockchain.
             backend_address: The address of the backend smart contract.
             is_local: If the backend is local or not.
             backend_seed: The seed for the backend.
-            approximation_depth: The depth of the basic approximation.
-            approximation_recursion_degree: The recursion degree for the Solovay-Kitaev
+            basic_approx_depth: The depth of the basic approximation.
+            skd_recursion_degree: The recursion degree for the Solovay-Kitaev
         """
         # get the backend interface for the abi
         mod_path = pathlib.Path(__file__).parent.absolute()
         absolute_path = (
             mod_path / "contracts" / "QuantumBackendInterface.sol"
         ).resolve()
         sc_interface_code = absolute_path.read_text()
@@ -66,45 +83,235 @@
         # getting the backend information from the backend contract
         name = self.web3_contract.functions.getName().call()
         num_qubits = self.web3_contract.functions.getNumberOfQubits().call()
         # is_simulator = self.web3_contract.functions.isSimulator().call()
         gates_names = self.web3_contract.functions.getGatesNames().call()
 
         super().__init__(
-            quic_basis_gates=gates_names,
-            num_qubits=num_qubits,
-            approximation_depth=approximation_depth,
-            approximation_recursion_degree=approximation_recursion_degree,
             provider=provider,
             name=name,
-            description='quantum backend on blockchain'
+            description='qunatum backend on blockchain',
+            # simulator=is_simulator,
+            # local=is_local,
         )
 
         # self._configuration.simulator = is_simulator
 
         # create the random seed
         self.state_seed = np.random.RandomState(
             np.random.MT19937(
                 np.random.SeedSequence(backend_seed)
             )
         )
 
+        # Create Target
+        self._target = Target(
+            description="Target for quantum backend on blockchain",
+            num_qubits=num_qubits
+        )
+
+        aprox_basis_gates = []
+
+        # depending on the gates names, add the gates to the target
+        for gate_name in gates_names:
+            match gate_name:
+                case "I":
+                    self._target.add_instruction(
+                        IGate(),
+                        {(qubit,): None for qubit in range(num_qubits)}
+                    )
+                case "X":
+                    self._target.add_instruction(
+                        XGate(),
+                        {(qubit,): None for qubit in range(num_qubits)}
+                    )
+                    aprox_basis_gates.append("x")
+                case "H":
+                    self._target.add_instruction(
+                        HGate(),
+                        {(qubit,): None for qubit in range(num_qubits)}
+                    )
+                    aprox_basis_gates.append("h")
+                case "CN":
+                    self._target.add_instruction(
+                        CXGate(),
+                        {
+                            edge: None for edge in [
+                                (x, y)
+                                for x in range(num_qubits)
+                                for y in range(num_qubits)
+                                if x != y
+                            ]
+                        }
+                    )
+                case "CCN":
+                    self._target.add_instruction(
+                        CCXGate(),
+                        {edge: None for edge in [
+                            (x, y, z)
+                            for x in range(num_qubits)
+                            for y in range(num_qubits)
+                            for z in range(num_qubits)
+                            if x != y and x != z and y != z
+                        ]}
+                    )
+                case "P45":
+                    # p45 = PhaseGate(np.pi/4, label='p45')
+                    qc = qiskit.QuantumCircuit(1, name='p45')
+                    qc.p(np.pi/4, 0)
+                    p45_instruction = qc.to_instruction()
+                    self._target.add_instruction(
+                        p45_instruction,
+                        {(qubit,): None for qubit in range(num_qubits)}
+                    )
+                case "p45":
+                    # p45 = PhaseGate(np.pi/4, label='p45')
+                    qc = qiskit.QuantumCircuit(1, name='pdg45')
+                    qc.p(-np.pi/4, 0)
+                    pdg45_instruction = qc.to_instruction()
+                    self._target.add_instruction(
+                        pdg45_instruction,
+                        {(qubit,): None for qubit in range(num_qubits)}
+                    )
+                case "S":
+                    self._target.add_instruction(
+                        SGate(),
+                        {(qubit,): None for qubit in range(num_qubits)}
+                    )
+                    aprox_basis_gates.append("s")
+                case "s":
+                    self._target.add_instruction(
+                        SdgGate(),
+                        {(qubit,): None for qubit in range(num_qubits)}
+                    )
+                    aprox_basis_gates.append("sdg")
+                case "T":
+                    self._target.add_instruction(
+                        TGate(),
+                        {(qubit,): None for qubit in range(num_qubits)}
+                    )
+                    aprox_basis_gates.append("t")
+                case "t":
+                    self._target.add_instruction(
+                        TdgGate(),
+                        {(qubit,): None for qubit in range(num_qubits)}
+                    )
+                    aprox_basis_gates.append("tdg")
+                case "Y":
+                    self._target.add_instruction(
+                        YGate(),
+                        {(qubit,): None for qubit in range(num_qubits)}
+                    )
+                    aprox_basis_gates.append("y")
+                case "Z":
+                    self._target.add_instruction(
+                        ZGate(),
+                        {(qubit,): None for qubit in range(num_qubits)}
+                    )
+                    aprox_basis_gates.append("z")
+                case "CS":
+                    self._target.add_instruction(
+                        CSGate(),
+                        {edge: None for edge in [
+                            (x, y)
+                            for x in range(num_qubits)
+                            for y in range(num_qubits)
+                            if x != y
+                        ]}
+                    )
+                case "Cs":
+                    self._target.add_instruction(
+                        CSdgGate(),
+                        {edge: None for edge in [
+                            (x, y)
+                            for x in range(num_qubits)
+                            for y in range(num_qubits)
+                            if x != y
+                        ]}
+                    )
+                case "CP45":
+                    qc = qiskit.QuantumCircuit(2, name='cp45')
+                    qc.cp(np.pi/4, 0, 1)
+                    cp45_instruction = qc.to_instruction()
+                    self._target.add_instruction(
+                        cp45_instruction,
+                        {
+                            edge: None for edge in [
+                                (x, y)
+                                for x in range(num_qubits)
+                                for y in range(num_qubits)
+                                if x != y
+                            ]
+                        }
+                    )
+                case "Cp45":
+                    qc = qiskit.QuantumCircuit(2, name='cpdg45')
+                    qc.cp(-np.pi/4, 0, 1)
+                    cp45_instruction = qc.to_instruction()
+                    self._target.add_instruction(
+                        cp45_instruction,
+                        {
+                            edge: None for edge in [
+                                (x, y)
+                                for x in range(num_qubits)
+                                for y in range(num_qubits)
+                                if x != y
+                            ]
+                        }
+                    )
+                case "m":
+                    self._target.add_instruction(
+                        Measure(),
+                        {(qubit,): None for qubit in range(num_qubits)}
+                    )
+
+        if ("P45" in gates_names) and ("S" not in gates_names):
+            q = qiskit.QuantumRegister(1, "q")
+            def_p_s = qiskit.QuantumCircuit(q)
+            def_p_s.append(p45_instruction, [q[0]], [])
+            def_p_s.append(p45_instruction, [q[0]], [])
+            SessionEquivalenceLibrary.add_equivalence(
+                SGate(), def_p_s)
+            aprox_basis_gates.append("s")
+        if ("p45" in gates_names) and ("s" not in gates_names):
+            q = qiskit.QuantumRegister(1, "q")
+            def_p_sdg = qiskit.QuantumCircuit(q)
+            def_p_sdg.append(pdg45_instruction, [q[0]], [])
+            def_p_sdg.append(pdg45_instruction, [q[0]], [])
+            SessionEquivalenceLibrary.add_equivalence(
+                SdgGate(), def_p_sdg)
+            aprox_basis_gates.append("sdg")
+        # Set option validators
+        self.options.set_validator("shots", (1, 4096))
+
+        # make the basic aproximation given the depth
+        # for the given 1-qubit gates, except identity and
+        # measure.
+        aprox = generate_basic_approximations(
+            basis_gates=aprox_basis_gates, depth=basic_approx_depth
+        )
+        # generate the pass manager for the Solovay-Kitaev algorithm
+        skd = SolovayKitaev(
+            recursion_degree=skd_recursion_degree,
+            basic_approximations=aprox
+        )
+        self.skd_pass_manager = PassManager([skd])
+
     @property
     def target(self):
         return self._target
 
     @property
     def max_circuits(self):
         return 1
 
     @classmethod
     def _default_options(cls):
         return Options(shots=10)
 
-    @override
     def run(self, circuits, **kwargs):
         # serialize circuits submit to backend and create a job
         for kwarg in kwargs:
             if not hasattr(self.options, kwarg):
                 logger.warn(
                     "Option %s is not used by this backend" % kwarg,
                     UserWarning, stacklevel=2)
@@ -112,22 +319,220 @@
             'shots': kwargs.get('shots', self.options.shots)
         }
         # make a list of circuits
         if type(circuits) is not list:
             circuits = [circuits]
         # job_json = convert_to_wire_format(circuits, options)
         # job_handle = submit_to_backend(job_jsonb)
-        circuit_str: str = self.get_quic_circuit_string(circuits[0])
+        circuit_str: str = self.convert_circuit_to_string(circuits[0])
         first_index = circuit_str.find(",")
         if first_index == -1:
             first_index = circuit_str.find(".")
         if first_index <= 0:
             raise ValueError("Invalid circuit string")
         num_qubits: int = first_index
         job_json = dict(
             circuit_str=circuit_str,
             shots=options['shots'],
             num_qubits=num_qubits,
             random_seed=self.state_seed.randint(low=0, high=65535)
         )
         job_handle = self.web3_contract
         return BlockcahinJob(self, job_handle, job_json, circuits)
+
+    def get_transpiled_circuit(
+            self,
+            circuit: qiskit.QuantumCircuit,
+    ) -> qiskit.QuantumCircuit:
+        r"""
+        Transpile a circuit.
+
+        Args:
+            circuit: The circuit to transpile.
+
+        Returns:
+            The transpiled circuit.
+        """
+        # delete measure gates
+        circuit = circuit.copy()
+        circuit.data = [
+            gate for gate in circuit.data
+            if gate.operation.name != "measure"]
+        # get the pass manager
+        pass_manager = generate_preset_pass_manager(0, self)
+        pass_manager.pre_layout = self.skd_pass_manager
+        circuit = pass_manager.run(circuit)
+        return circuit
+
+    def convert_circuit_to_string(
+            self,
+            circuit: qiskit.QuantumCircuit,
+    ) -> str:
+        r"""
+        Convert a circuit to a string.
+
+        Args:
+            circuit: The circuit to convert.
+
+        Returns:
+            The circuit as a string.
+        """
+        circuit = self.get_transpiled_circuit(circuit)
+
+        # compute the maximum num qubits
+        circuit_num_qubits = max(
+            [
+                circuit.find_bit(qubit).index
+                for gate in circuit.data
+                for qubit in gate.qubits
+            ]) + 1
+        # convert circuit to json
+        # return json
+        circuit_string: str = ""
+        for gate in circuit.data:
+            # get gate name
+            gate_name = gate.operation.name
+            # get the number of qubits
+            gate_num_qubits = gate.operation.num_qubits
+            # get gate qubits
+            gate_qubits = gate.qubits
+            # string to add
+            # initialise with identity gates
+            gate_string = "I" * circuit_num_qubits
+
+            if gate_name == "barrier":
+                continue
+            # if only 1 qubit gate
+            match gate_num_qubits:
+                case 1:
+                    if gate_name == "S":
+                        gate_name = "S"
+                    elif gate_name == "sdg":
+                        gate_name = "s"
+                    elif gate_name == "T":
+                        gate_name = "T"
+                    elif gate_name == "tdg":
+                        gate_name = "t"
+                    elif gate_name == "p45":
+                        gate_name = "P"
+                    elif gate_name == "pdg45":
+                        gate_name = "p"
+                    else:
+                        gate_name = gate_name.upper()
+                    if gate_name == "MEASURE":
+                        gate_name = "m"
+                    index = circuit.find_bit(gate_qubits[0]).index
+                    # print(index)
+                    gate_string = string_replact_at(
+                        gate_string,
+                        index,
+                        gate_name
+                    )
+                case 2:
+                    if gate_name == "cx":
+                        gate_name = "CN"
+                    elif gate_name == "cs":
+                        gate_name = "CS"
+                    elif gate_name == "csdg":
+                        gate_name = "Cs"
+                    elif gate_name == "cp45":
+                        gate_name = "CP"
+                    elif gate_name == "cpdg45":
+                        gate_name = "Cp"
+                    else:
+                        raise NotImplementedError("Gate not supported")
+                    c_index = circuit.find_bit(gate_qubits[0]).index
+                    t_index = circuit.find_bit(gate_qubits[1]).index
+                    gate_string = string_replact_at(
+                        gate_string,
+                        c_index,
+                        "C"
+                    )
+                    if gate_name == "CS":
+                        gate_string = string_replact_at(
+                            gate_string,
+                            t_index,
+                            "S"
+                        )
+                    elif gate_name == "Cs":
+                        gate_string = string_replact_at(
+                            gate_string,
+                            t_index,
+                            "s"
+                        )
+                    elif gate_name == "CP":
+                        gate_string = string_replact_at(
+                            gate_string,
+                            t_index,
+                            "P"
+                        )
+                    elif gate_name == "Cp":
+                        gate_string = string_replact_at(
+                            gate_string,
+                            t_index,
+                            "p"
+                        )
+                    elif gate_name == "CN":
+                        gate_string = string_replact_at(
+                            gate_string,
+                            t_index,
+                            "N"
+                        )
+                    else:
+                        raise NotImplementedError("Gate not supported")
+                case 3:
+                    if gate_name == "ccx":
+                        gate_name = "CCN"
+                    else:
+                        raise NotImplementedError("Gate not supported")
+                    c1_index = (
+                        circuit.find_bit(gate_qubits[0]).index
+                    )
+                    c2_index = (
+                        circuit.find_bit(gate_qubits[1]).index
+                    )
+                    t_index = circuit.find_bit(gate_qubits[2]).index
+                    gate_string = string_replact_at(
+                        gate_string,
+                        c1_index,
+                        "C"
+                    )
+                    gate_string = string_replact_at(
+                        gate_string,
+                        c2_index,
+                        "C"
+                    )
+                    if gate_name == "CCN":
+                        gate_string = string_replact_at(
+                            gate_string,
+                            t_index,
+                            "N"
+                        )
+                    else:
+                        raise NotImplementedError("Gate not supported")
+                case _:
+                    raise NotImplementedError("Gate not supported")
+            circuit_string += gate_string + ','
+        # finish the circuit string
+        circuit_string = string_replact_at(
+            circuit_string,
+            len(circuit_string)-1,
+            "."
+        )
+
+        logger.debug(circuit_string)
+        return circuit_string
+
+
+def string_replact_at(source: str, index: int, value: str) -> str:
+    r"""
+    Replace a character at a given index in a string.
+
+    Args:
+        source: The source string.
+        index: The index to replace.
+        value: The value to replace with.
+
+    Returns:
+        The string with the character replaced.
+    """
+    return source[:index] + value + source[(index+1):]
```

## qiskit_pqcee_provider/provider.py

```diff
@@ -1,12 +1,13 @@
 from qiskit.providers import ProviderV1 as Provider
 from qiskit.providers.providerutils import filter_backends
 
 from .backend import BlockchainBackend
 
+import os 
 import web3
 import pathlib
 from solcx import compile_source
 import configparser
 from web3.middleware import geth_poa_middleware
 
 
@@ -25,24 +26,24 @@
     """
 
     def __init__(
         self,
         web3_provider: web3.Web3,
         provider_address: str,
         is_local: bool = False,
-        approximation_depth: int = 0,
-        approximation_recursion_degree: int = 0
+        basic_approx_depth: int = 3,
+        skd_recursion_degree: int = 3
     ):
         r"""
         Args:
             web3_provider: The web3 provider for the blockchain.
             provider_address: The address of the provider smart contract.
             is_local: If the provider is local or not.
-            approximation_depth: The basic approximation depth.
-            approximation_recursion_degree: The skd recursion degree.
+            basic_approx_depth: The basic approximation depth.
+            skd_recursion_degree: The skd recursion degree.
         """
         super().__init__()
         self.web3_provider = web3_provider
         # compile the provider interface for the abi
         mod_path = pathlib.Path(__file__).parent.absolute()
         absolute_path = (
             mod_path / "contracts" / "QuantumProviderInterface.sol"
@@ -62,16 +63,16 @@
         self._backends = [
             BlockchainBackend(
                 provider=self,
                 web3_provider=web3_provider,
                 backend_address=backend_address,
                 is_local=is_local,
                 backend_seed=0,
-                approximation_depth=approximation_depth,
-                approximation_recursion_degree=approximation_recursion_degree
+                basic_approx_depth=basic_approx_depth,
+                skd_recursion_degree=skd_recursion_degree
             )
             for backend_address in web3_backends
         ]
 
     def backends(self, name=None, **kwargs):
         backends = self._backends
         if name:
@@ -83,21 +84,21 @@
 class LocalPqceeProvider(BlockchainProvider):
     r"""
     The local quantum provider on the blockchain usyng pyevm.
     """
 
     def __init__(
         self,
-        approximation_depth: int = 0,
-        approximation_recursion_degree: int = 0
+        basic_approx_depth: int = 3,
+        skd_recursion_degree: int = 3
     ):
         """
         Args:
-            approximation_depth: The basic approximation depth.
-            approximation_recursion_degree: The skd recursion degree.
+            basic_approx_depth: The basic approximation depth.
+            skd_recursion_degree: The skd recursion degree.
         """
         web3_provider = web3.Web3(web3.Web3.EthereumTesterProvider())
         web3_account = web3_provider.eth.accounts[0]
         web3_provider.eth.default_account = web3_account
 
         # register the provider smart contract
         mod_path = pathlib.Path(__file__).parent.absolute()
@@ -164,60 +165,81 @@
         )
         tx_receipt = web3_provider.eth.wait_for_transaction_receipt(tx_hash)
 
         super().__init__(
             web3_provider=web3_provider,
             provider_address=provider_address,
             is_local=True,
-            approximation_depth=approximation_depth,
-            approximation_recursion_degree=approximation_recursion_degree
+            basic_approx_depth=basic_approx_depth,
+            skd_recursion_degree=skd_recursion_degree
         )
 
 
 class PqceeProvider(BlockchainProvider):
     r"""
     The quantum provider from pQCee on the blockchain using mumbai testnet.
     """
 
     def __init__(
         self,
-        approximation_depth: int = 0,
-        approximation_recursion_degree: int = 0
+        basic_approx_depth: int = 3,
+        skd_recursion_degree: int = 3
     ):
         """
         Args:
-            approximation_depth: The basic approximation depth.
-            approximation_recursion_degree: The skd recursion degree.
+            basic_approx_depth: The basic approximation depth.
+            skd_recursion_degree: The skd recursion degree.
         """
         # read the config file
         config = configparser.ConfigParser(allow_no_value=True)
         mod_path = pathlib.Path(__file__).parent.absolute()
         absolute_path = (
-            mod_path / "mumbai_testnet_config.ini"
+            mod_path / "amoy_testnet_config.ini"
         ).resolve()
         config.read(absolute_path)
         # verify if there are contracts already deployed
         provider_address = None
         if 'mumbai' in config:
             if 'provider_address' in config['mumbai']:
                 provider_address = config['mumbai']['provider_address']
             else:
                 raise Exception("No provider address in config file")
         else:
             raise Exception("No mumbai in config file")
 
         # working connection on web3 https://rpc-mumbai.maticvigil.com/
+        # os.environ['TESTNET_RPC_URL']
+        # web3_provider = web3.Web3(
+        #     web3.Web3.HTTPProvider(
+        #         endpoint_uri=os.environ['TESTNET_RPC_URL']
+        #     )
+        # )
+        rpc_url = None
+        if 'RPC_URL' in config:
+            if 'TESTNET_RPC' in config['RPC_URL']:
+                rpc_url = (
+                    config['RPC_URL']['TESTNET_RPC']
+                )
+        else:
+            config['RPC_URL'] = {}
+    
+    
+        if rpc_url is None:
+            raise ValueError("No RPC URL found")
+    
+        # working address for qeb3 https://rpc-mumbai.maticvigil.com/
         web3_provider = web3.Web3(
             web3.Web3.HTTPProvider(
-                endpoint_uri='https://rpc-mumbai.maticvigil.com/'
+                endpoint_uri=rpc_url
             )
         )
+
         # setup poa
         web3_provider.middleware_onion.inject(geth_poa_middleware, layer=0)
 
         super().__init__(
             web3_provider=web3_provider,
             provider_address=provider_address,
             is_local=False,
-            approximation_depth=approximation_depth,
-            approximation_recursion_degree=approximation_recursion_degree
+            basic_approx_depth=basic_approx_depth,
+            skd_recursion_degree=skd_recursion_degree
         )
```

## qiskit_pqcee_provider/contracts/QuantumBackendContract.sol

```diff
@@ -76,15 +76,15 @@
 	bytes1 constant GATE_T      = 'T';
 	bytes1 constant GATE_t      = 't'; // conjugate T gate tdg
 	bytes1 constant GATE_m      = 'm';
 	bytes1 constant DELIM_NEXT  = ',';
 	bytes1 constant DELIM_END   = '.';
 
 	// "S","s","CS","Cs"
-	string[] public gatesNames = ["H","I","CN","CCN","X","Y","Z","P","p","T","t","CP","Cp","CT","Ct","m"];
+	string[] public gatesNames = ["H","I","CN","CCN","X","Y","Z","P45","p45","T","t","CP45","Cp45","CT","Ct","m"];
 	
 	struct Qubit
 	{
 		int256[2][MAX_IDX] rQubits;  // instance count in real 
 		int256[2][MAX_IDX] iQubits;  // instance count in imaginary 
 	}
```

## Comparing `qiskit_pqcee_provider-0.1.2.dist-info/LICENSE.txt` & `qiskit_pqcee_provider-0.1.3.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `qiskit_pqcee_provider-0.1.2.dist-info/METADATA` & `qiskit_pqcee_provider-0.1.3.dist-info/METADATA`

 * *Files 15% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 Metadata-Version: 2.1
 Name: qiskit-pqcee-provider
-Version: 0.1.2
-Summary: A qiskit provider on the blockchain.
-Home-page: https://github.com/sbip-sg/qiskit-pqcee-provider
-Author: Stefan-Dan Ciocirlan (sdcioc)
-Author-email: stefan_dan@xn--ciocirlan-o2a.ro
+Version: 0.1.3
+Summary: An 8-qubit universal quantum emulator adapted for web3 platforms, originally presented at IEEE QCE 20. This package takes Qiskit code and converts it to QuICScript, a language developed by pQCee to write quantum circuits.
+Home-page: https://github.com/pqcee/qiskit-pqcee-provider
+Author: pQCee Product Team
+Author-email: info@pqcee.com
 License: MIT
 Platform: UNKNOWN
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: Microsoft :: Windows
 Classifier: Operating System :: MacOS
```

## Comparing `qiskit_pqcee_provider-0.1.2.dist-info/RECORD` & `qiskit_pqcee_provider-0.1.3.dist-info/RECORD`

 * *Files 10% similar despite different names*

```diff
@@ -1,19 +1,21 @@
-qiskit_pqcee_provider/__init__.py,sha256=WRK6nSbhajRtR9lzP21oir7T8Ip4GfYKCeGvdCop_OQ,1165
-qiskit_pqcee_provider/backend.py,sha256=gX-qVG1oS_mfIGzUan5C69TJgbrExheufsNAZGLt5X0,4529
+qiskit_pqcee_provider/__init__.py,sha256=ZN_EHtGsysyj7PoLbz0DgmaEy1N8WxSt8hFXAW44WFM,1145
+qiskit_pqcee_provider/amoy_testnet_config.ini,sha256=pB9ouDhslfl-waGalhTeNIdfXt3ujFJMfIHBjpjVanU,132
+qiskit_pqcee_provider/backend.py,sha256=oh1TkEWw3oDv1eDAoYMPJXjtvB0n1TaAmZ4RKEHbVPU,20248
 qiskit_pqcee_provider/job.py,sha256=JOb_NC9gSDNy9Tep-rUQ4FejX0XTHLFSGh2TU5-d-Is,5004
-qiskit_pqcee_provider/mumbai_testnet_config.ini,sha256=vQQvdGEMfbPm6CA3_n_UpQopyEEe79rmZQDs-tGP-PQ,72
-qiskit_pqcee_provider/provider.py,sha256=6DIbTiwM8Ul4TZ6Zx9r-eSNqt6VSB2RbEwISLjaweOU,7879
+qiskit_pqcee_provider/provider.py,sha256=-Un5WYRULMEimTin8pVTHfjqWF30GklDl3SkbLr6xdU,8348
+qiskit_pqcee_provider/setup_amoy_testnet.py,sha256=0XIJoS6la5rdPURDhIK-efKdGuVbI1BeTLeG58YfBWY,13419
 qiskit_pqcee_provider/setup_mumbai_testnet.py,sha256=X8y-QAZkoqedh1VPf-zBb4rhgzck3Oq5cEMmffQOcj8,14222
-qiskit_pqcee_provider/contracts/QuantumBackendContract.sol,sha256=o4RXip30Ivccwdbd16Cuya4vUKZM0U5zS_zO5fvZdFQ,16886
+qiskit_pqcee_provider/test_provider.py,sha256=3ydg29ozfUIUBkFRNbzDsG3r18hIMkqtqHiQRTZFjfw,379
+qiskit_pqcee_provider/contracts/QuantumBackendContract.sol,sha256=3Zs0jIiAE02r3bkXLEvgBhytlvjKo6WWAonVgF5QTgc,16894
 qiskit_pqcee_provider/contracts/QuantumBackendInterface.sol,sha256=K-YzDMBWuQBfPKDmCQ0bzfzvSCmvx7XTHorRzKs3Zyo,700
 qiskit_pqcee_provider/contracts/QuantumProviderContract.sol,sha256=CuFRQ_APYMmWt5NeyDnqu6cyeGrs_vzG5Ka1IEDfF7g,1605
 qiskit_pqcee_provider/contracts/QuantumProviderInterface.sol,sha256=8ryRaWEF-oyHV-2XHkl9c4ypq6SCN-s-CumG-mHyUkE,351
 qiskit_pqcee_provider/quic/__init__.py,sha256=LYtOC9A7xb37WjmunvHXZCu-8tumcn47-lQDeV3d2-k,157
 qiskit_pqcee_provider/quic/backend.py,sha256=UCuxttCuVDmObrRdrP0Jcc6U0yKZ53SWXDB5MGwvcBo,11066
 qiskit_pqcee_provider/quic/gate.py,sha256=BqeGNQ75_KwOyvwZOHkE85rIK9U_rYpmrI1FlWdWjQU,4298
 qiskit_pqcee_provider/quic/target.py,sha256=RrDxeCiAySQCkxolzq6yRhhIckXuX7nSVANL0yFfSBw,3577
-qiskit_pqcee_provider-0.1.2.dist-info/LICENSE.txt,sha256=HF2WytrdNap3fdw7nJkIME9wucSuiGEdz4R3e9aRqBg,1062
-qiskit_pqcee_provider-0.1.2.dist-info/METADATA,sha256=HGI2HU7LKnRXn0aDH8wMz82wYc2uqTe5Su6PSxfumgg,1426
-qiskit_pqcee_provider-0.1.2.dist-info/WHEEL,sha256=z9j0xAa_JmUKMpmz72K0ZGALSM_n-wQVmGbleXx2VHg,110
-qiskit_pqcee_provider-0.1.2.dist-info/top_level.txt,sha256=CnkbnCocG_OOj6yT51r_grgi1TasdozI2q4rqesRtkk,22
-qiskit_pqcee_provider-0.1.2.dist-info/RECORD,,
+qiskit_pqcee_provider-0.1.3.dist-info/LICENSE.txt,sha256=HF2WytrdNap3fdw7nJkIME9wucSuiGEdz4R3e9aRqBg,1062
+qiskit_pqcee_provider-0.1.3.dist-info/METADATA,sha256=TwAP259qk04MzP2LcOyP2-tFfah9sTnNovzhgc9bBdA,1581
+qiskit_pqcee_provider-0.1.3.dist-info/WHEEL,sha256=z9j0xAa_JmUKMpmz72K0ZGALSM_n-wQVmGbleXx2VHg,110
+qiskit_pqcee_provider-0.1.3.dist-info/top_level.txt,sha256=CnkbnCocG_OOj6yT51r_grgi1TasdozI2q4rqesRtkk,22
+qiskit_pqcee_provider-0.1.3.dist-info/RECORD,,
```


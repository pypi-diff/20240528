# Comparing `tmp/pybrops-1.0.2.tar.gz` & `tmp/pybrops-1.0.3.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "pybrops-1.0.2.tar", last modified: Thu Feb 29 17:48:51 2024, max compression
+gzip compressed data, was "pybrops-1.0.3.tar", last modified: Tue May 28 20:33:12 2024, max compression
```

## Comparing `pybrops-1.0.2.tar` & `pybrops-1.0.3.tar`

### file list

```diff
@@ -1,394 +1,417 @@
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.990354 pybrops-1.0.2/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1075 2023-09-17 21:28:53.000000 pybrops-1.0.2/LICENSE
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3133 2024-02-29 17:48:51.989354 pybrops-1.0.2/PKG-INFO
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2393 2023-10-16 21:05:32.000000 pybrops-1.0.2/README.md
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.929354 pybrops-1.0.2/pybrops/
--rw-r--r--   0 rs14      (1000) rs14      (1000)      544 2024-02-29 17:04:09.000000 pybrops-1.0.2/pybrops/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.929354 pybrops-1.0.2/pybrops/breed/
--rw-r--r--   0 rs14      (1000) rs14      (1000)      224 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.931354 pybrops-1.0.2/pybrops/breed/arch/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1242 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/arch/BreedingEdge.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1984 2024-02-28 21:12:46.000000 pybrops-1.0.2/pybrops/breed/arch/BreedingGraph.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     4393 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/arch/BreedingNode.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     9033 2024-02-28 21:14:45.000000 pybrops-1.0.2/pybrops/breed/arch/BreedingProgram.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1886 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/arch/EmigrationOperator.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1278 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/arch/GermplasmBank.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2012 2024-02-28 21:15:45.000000 pybrops-1.0.2/pybrops/breed/arch/ImmigrationOperator.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    19318 2023-09-29 20:57:49.000000 pybrops-1.0.2/pybrops/breed/arch/RecurrentSelectionBreedingProgram.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      797 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/arch/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.931354 pybrops-1.0.2/pybrops/breed/op/
--rw-r--r--   0 rs14      (1000) rs14      (1000)      500 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/op/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.931354 pybrops-1.0.2/pybrops/breed/op/eval/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3129 2023-10-03 18:06:44.000000 pybrops-1.0.2/pybrops/breed/op/eval/EvaluationOperator.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      208 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/op/eval/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.932354 pybrops-1.0.2/pybrops/breed/op/init/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2411 2024-02-28 21:09:49.000000 pybrops-1.0.2/pybrops/breed/op/init/InitializationOperator.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      237 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/op/init/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.932354 pybrops-1.0.2/pybrops/breed/op/log/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     8085 2023-10-03 18:06:44.000000 pybrops-1.0.2/pybrops/breed/op/log/Logbook.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      182 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/op/log/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.932354 pybrops-1.0.2/pybrops/breed/op/mate/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3228 2023-10-03 18:06:44.000000 pybrops-1.0.2/pybrops/breed/op/mate/MatingOperator.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      213 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/op/mate/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.933354 pybrops-1.0.2/pybrops/breed/op/psel/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3270 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/op/psel/ParentSelectionOperator.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      241 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/op/psel/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.933354 pybrops-1.0.2/pybrops/breed/op/ssel/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3214 2023-10-03 18:06:44.000000 pybrops-1.0.2/pybrops/breed/op/ssel/SurvivorSelectionOperator.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      247 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/op/ssel/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.933354 pybrops-1.0.2/pybrops/breed/prot/
--rw-r--r--   0 rs14      (1000) rs14      (1000)      288 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.935354 pybrops-1.0.2/pybrops/breed/prot/bv/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2332 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/bv/BreedingValueProtocol.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     7176 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/breed/prot/bv/MeanPhenotypicBreedingValue.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2924 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/bv/TrueBreedingValue.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      469 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/bv/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.935354 pybrops-1.0.2/pybrops/breed/prot/gt/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2841 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/gt/DenseUnphasedGenotyping.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2130 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/gt/GenotypingProtocol.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      298 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/gt/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.938354 pybrops-1.0.2/pybrops/breed/prot/mate/
--rw-r--r--   0 rs14      (1000) rs14      (1000)    11552 2024-02-28 18:47:49.000000 pybrops-1.0.2/pybrops/breed/prot/mate/FourWayCross.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    13105 2024-02-28 18:47:54.000000 pybrops-1.0.2/pybrops/breed/prot/mate/FourWayDHCross.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3210 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/mate/MatingProtocol.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    10893 2024-02-28 18:48:01.000000 pybrops-1.0.2/pybrops/breed/prot/mate/SelfCross.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    10880 2024-02-28 18:48:13.000000 pybrops-1.0.2/pybrops/breed/prot/mate/ThreeWayCross.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    12854 2024-02-28 18:48:19.000000 pybrops-1.0.2/pybrops/breed/prot/mate/ThreeWayDHCross.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    11404 2024-02-28 18:48:25.000000 pybrops-1.0.2/pybrops/breed/prot/mate/TwoWayCross.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    12321 2024-02-28 18:48:31.000000 pybrops-1.0.2/pybrops/breed/prot/mate/TwoWayDHCross.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      821 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/mate/__init__.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     4002 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/mate/util.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.939354 pybrops-1.0.2/pybrops/breed/prot/pt/
--rw-r--r--   0 rs14      (1000) rs14      (1000)    16467 2024-02-28 18:50:48.000000 pybrops-1.0.2/pybrops/breed/prot/pt/G_E_Phenotyping.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     4358 2023-10-03 18:06:44.000000 pybrops-1.0.2/pybrops/breed/prot/pt/PhenotypingProtocol.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     5533 2023-09-29 20:57:49.000000 pybrops-1.0.2/pybrops/breed/prot/pt/TruePhenotyping.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      319 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/pt/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.946354 pybrops-1.0.2/pybrops/breed/prot/sel/
--rw-r--r--   0 rs14      (1000) rs14      (1000)    14292 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/sel/BinaryMateSelectionProtocol.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    28689 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/sel/BinarySelectionProtocol.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    70589 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/breed/prot/sel/EstimatedBreedingValueSelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    75376 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/sel/ExpectedMaximumBreedingValueSelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    69217 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/sel/FamilyEstimatedBreedingValueSelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    71524 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/sel/GeneralizedWeightedGenomicEstimatedBreedingValueSelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    70569 2023-10-13 21:27:18.000000 pybrops-1.0.2/pybrops/breed/prot/sel/GenomicEstimatedBreedingValueSelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    20224 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/sel/GenotypeBuilderSelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    13819 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/sel/IntegerMateSelectionProtocol.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    28743 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/sel/IntegerSelectionProtocol.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)        0 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/sel/L1NormGenomicSelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    68847 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/sel/L2NormGenomicSelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     8525 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/sel/MateSelectionProtocol.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    68858 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/sel/MeanExpectedHeterozygositySelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    69695 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/sel/MeanGenomicRelationshipSelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    19895 2023-09-17 21:28:53.000000 pybrops-1.0.2/pybrops/breed/prot/sel/MultiObjectiveGenomicSelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    74276 2023-09-29 20:57:49.000000 pybrops-1.0.2/pybrops/breed/prot/sel/OptimalContributionSelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    72419 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/OptimalHaploidValueSelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    19212 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/OptimalPopulationValueSelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    68099 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/RandomSelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    14230 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/RealMateSelectionProtocol.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    28600 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/RealSelectionProtocol.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    34630 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/SelectionProtocol.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    13786 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/SubsetMateSelectionProtocol.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    28797 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/SubsetSelectionProtocol.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    25589 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/UnconstrainedGeneralized1NormGenomicSelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    72183 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/UnconstrainedMultiObjectiveGenomicMating.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    42310 2023-09-29 20:57:49.000000 pybrops-1.0.2/pybrops/breed/prot/sel/UnconstrainedPopulationAlleleFrequencyDistanceSelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    42765 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/UnconstrainedPopulationAlleleUnavailabilitySelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     8862 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/UnconstrainedSelectionProtocol.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    79595 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/UsefulnessCriterionSelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    55955 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/WeightedGenomicSelection.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3339 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.949354 pybrops-1.0.2/pybrops/breed/prot/sel/cfg/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     4949 2024-02-28 19:28:39.000000 pybrops-1.0.2/pybrops/breed/prot/sel/cfg/BinaryMateSelectionConfiguration.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     5258 2024-02-28 19:18:57.000000 pybrops-1.0.2/pybrops/breed/prot/sel/cfg/BinarySelectionConfiguration.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     4929 2024-02-28 19:45:17.000000 pybrops-1.0.2/pybrops/breed/prot/sel/cfg/IntegerMateSelectionConfiguration.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     5164 2024-02-28 19:45:46.000000 pybrops-1.0.2/pybrops/breed/prot/sel/cfg/IntegerSelectionConfiguration.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2242 2024-02-28 19:13:05.000000 pybrops-1.0.2/pybrops/breed/prot/sel/cfg/MateSelectionConfiguration.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     4785 2024-02-28 19:45:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/cfg/RealMateSelectionConfiguration.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     5085 2024-02-28 19:47:41.000000 pybrops-1.0.2/pybrops/breed/prot/sel/cfg/RealSelectionConfiguration.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2458 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/cfg/SampledSelectionConfigurationMixin.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     5398 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/cfg/SelectionConfiguration.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3303 2024-02-28 19:49:14.000000 pybrops-1.0.2/pybrops/breed/prot/sel/cfg/SimpleMateSelectionConfiguration.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2869 2024-02-28 19:48:52.000000 pybrops-1.0.2/pybrops/breed/prot/sel/cfg/SimpleSelectionConfiguration.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     4728 2024-02-28 19:46:23.000000 pybrops-1.0.2/pybrops/breed/prot/sel/cfg/SubsetMateSelectionConfiguration.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     5018 2024-02-28 19:47:16.000000 pybrops-1.0.2/pybrops/breed/prot/sel/cfg/SubsetSelectionConfiguration.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1605 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/cfg/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.954354 pybrops-1.0.2/pybrops/breed/prot/sel/prob/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     7770 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/BinaryMateSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     8793 2024-02-28 19:56:25.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/BinarySelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    41238 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/EstimatedBreedingValueSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    46393 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/ExpectedMaximumBreedingValueSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    43876 2024-02-28 20:38:16.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/FamilyEstimatedBreedingValueSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    49393 2024-02-28 20:43:16.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    48483 2023-10-13 21:27:18.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/GenomicEstimatedBreedingValueSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    14830 2024-02-28 20:49:02.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/GenotypeBuilderSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     7778 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/IntegerMateSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     8807 2024-02-28 20:50:39.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/IntegerSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    48138 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/L1NormGenomicSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    47454 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/L2NormGenomicSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1183 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/MateSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    42837 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/MeanExpectedHeterozygositySelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    42325 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/MeanGenomicRelationshipSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    20570 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/MultiObjectiveGenomicMatingProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    19859 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/MultiObjectiveGenomicSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    47963 2023-09-29 20:57:49.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/OptimalContributionSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    48426 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/OptimalHaploidValueSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    15397 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/OptimalPopulationValueSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    41290 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/RandomSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     8877 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/RealLookAheadGeneralizedWeightedGenomicSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     7754 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/RealMateSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     8765 2024-02-28 20:50:51.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/RealSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    11178 2024-02-21 20:29:38.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/SelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     7770 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/SubsetMateSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     8868 2024-02-28 20:50:59.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/SubsetSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    66648 2024-02-28 21:02:01.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/UsefulnessCriterionSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    40496 2024-02-28 21:06:17.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/WeightedGenomicSelectionProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2791 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/__init__.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     6738 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/prob/trans.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.956354 pybrops-1.0.2/pybrops/breed/prot/sel/soln/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2859 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/soln/BinaryMateSelectionSolution.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      976 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/soln/BinarySelectionSolution.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2869 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/soln/IntegerMateSelectionSolution.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      986 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/soln/IntegerSelectionSolution.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1722 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/soln/MateSelectionSolution.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2839 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/soln/RealMateSelectionSolution.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      956 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/soln/RealSelectionSolution.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      924 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/soln/SelectionSolution.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2859 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/soln/SubsetMateSelectionSolution.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      976 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/soln/SubsetSelectionSolution.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1101 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/soln/__init__.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1668 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/targetfn.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     8329 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/transfn.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      984 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/breed/prot/sel/weightfn.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.956354 pybrops-1.0.2/pybrops/core/
--rw-r--r--   0 rs14      (1000) rs14      (1000)      797 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.957354 pybrops-1.0.2/pybrops/core/error/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1174 2023-10-12 15:02:58.000000 pybrops-1.0.2/pybrops/core/error/__init__.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1726 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/error/error_attr_python.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     4781 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/error/error_generic_numpy.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1293 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/error/error_generic_python.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1376 2023-10-12 15:02:58.000000 pybrops-1.0.2/pybrops/core/error/error_io_python.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      593 2023-10-12 15:02:58.000000 pybrops-1.0.2/pybrops/core/error/error_type_h5py.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    17521 2023-09-29 20:57:49.000000 pybrops-1.0.2/pybrops/core/error/error_type_numpy.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1220 2023-09-29 20:57:49.000000 pybrops-1.0.2/pybrops/core/error/error_type_pandas.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    17710 2023-09-29 20:57:49.000000 pybrops-1.0.2/pybrops/core/error/error_type_python.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1652 2023-10-12 15:02:58.000000 pybrops-1.0.2/pybrops/core/error/error_value_h5py.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    16321 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/core/error/error_value_numpy.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     4984 2023-10-12 15:02:58.000000 pybrops-1.0.2/pybrops/core/error/error_value_pandas.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    13649 2023-09-29 20:57:49.000000 pybrops-1.0.2/pybrops/core/error/error_value_python.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.959354 pybrops-1.0.2/pybrops/core/io/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2743 2023-09-29 20:57:49.000000 pybrops-1.0.2/pybrops/core/io/CSVDictInputOutput.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2516 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/io/CSVInputOutput.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2646 2023-09-29 20:57:49.000000 pybrops-1.0.2/pybrops/core/io/DictInputOutput.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2674 2023-09-29 20:57:49.000000 pybrops-1.0.2/pybrops/core/io/HDF5InputOutput.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     6410 2023-09-29 20:37:11.000000 pybrops-1.0.2/pybrops/core/io/NPYInputOutput.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     5008 2023-09-29 20:37:11.000000 pybrops-1.0.2/pybrops/core/io/NPZInputOutput.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2690 2023-09-29 20:57:49.000000 pybrops-1.0.2/pybrops/core/io/NumPyInputOutput.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3029 2023-09-29 20:57:49.000000 pybrops-1.0.2/pybrops/core/io/PandasDictInputOutput.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2711 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/io/PandasInputOutput.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      389 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/io/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.964354 pybrops-1.0.2/pybrops/core/mat/
--rw-r--r--   0 rs14      (1000) rs14      (1000)    34404 2024-02-25 19:58:48.000000 pybrops-1.0.2/pybrops/core/mat/DenseMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     4918 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/mat/DenseMutableMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    23168 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/core/mat/DensePhasedMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    32326 2024-02-25 19:58:48.000000 pybrops-1.0.2/pybrops/core/mat/DensePhasedTaxaVariantMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     7149 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/core/mat/DenseSquareMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    48498 2024-02-25 19:58:48.000000 pybrops-1.0.2/pybrops/core/mat/DenseSquareTaxaMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    35017 2024-02-25 23:39:10.000000 pybrops-1.0.2/pybrops/core/mat/DenseSquareTaxaSquareTraitMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    31487 2024-02-25 19:58:48.000000 pybrops-1.0.2/pybrops/core/mat/DenseSquareTaxaTraitMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    40813 2024-02-25 23:52:49.000000 pybrops-1.0.2/pybrops/core/mat/DenseSquareTraitMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    52393 2024-02-25 19:58:48.000000 pybrops-1.0.2/pybrops/core/mat/DenseTaxaMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    36888 2024-02-25 22:26:10.000000 pybrops-1.0.2/pybrops/core/mat/DenseTaxaTraitMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    59329 2024-02-26 00:11:42.000000 pybrops-1.0.2/pybrops/core/mat/DenseTaxaVariantMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    34102 2024-02-25 19:58:48.000000 pybrops-1.0.2/pybrops/core/mat/DenseTraitMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    91679 2024-02-26 00:39:11.000000 pybrops-1.0.2/pybrops/core/mat/DenseVariantMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3047 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/mat/GroupableMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    30017 2024-02-25 19:58:48.000000 pybrops-1.0.2/pybrops/core/mat/Matrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3348 2024-02-25 19:58:48.000000 pybrops-1.0.2/pybrops/core/mat/MutableMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     7979 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/core/mat/PhasedMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1379 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/mat/PhasedTaxaVariantMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2028 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/mat/PrunableMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3762 2024-02-25 19:58:48.000000 pybrops-1.0.2/pybrops/core/mat/SortableMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2921 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/core/mat/SquareMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2641 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/core/mat/SquareTaxaMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1402 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/core/mat/SquareTaxaSquareTraitMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1382 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/core/mat/SquareTaxaTraitMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2672 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/core/mat/SquareTraitMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    14645 2024-02-25 19:58:48.000000 pybrops-1.0.2/pybrops/core/mat/TaxaMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1260 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/mat/TaxaTraitMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1286 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/mat/TaxaVariantMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    10974 2024-02-25 19:58:48.000000 pybrops-1.0.2/pybrops/core/mat/TraitMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    21047 2024-02-25 19:58:48.000000 pybrops-1.0.2/pybrops/core/mat/VariantMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2990 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/core/mat/__init__.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      890 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/mat/util.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.965354 pybrops-1.0.2/pybrops/core/random/
--rw-r--r--   0 rs14      (1000) rs14      (1000)      127 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/random/__init__.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     5131 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/random/prng.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     9344 2024-02-28 19:07:42.000000 pybrops-1.0.2/pybrops/core/random/sampling.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.966354 pybrops-1.0.2/pybrops/core/util/
--rw-r--r--   0 rs14      (1000) rs14      (1000)      307 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/util/__init__.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     5114 2023-10-12 15:02:58.000000 pybrops-1.0.2/pybrops/core/util/arrayix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2518 2023-10-12 15:02:58.000000 pybrops-1.0.2/pybrops/core/util/h5py.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    11434 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/util/haplo.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      459 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/util/iterator.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1866 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/util/pareto.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     4260 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/core/util/subroutines.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.966354 pybrops-1.0.2/pybrops/model/
--rw-r--r--   0 rs14      (1000) rs14      (1000)      368 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/model/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.969354 pybrops-1.0.2/pybrops/model/gmod/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     4736 2023-10-12 15:02:58.000000 pybrops-1.0.2/pybrops/model/gmod/AdditiveDominanceEpistaticLinearGenomicModel.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     4326 2023-10-12 15:02:58.000000 pybrops-1.0.2/pybrops/model/gmod/AdditiveDominanceLinearGenomicModel.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     4755 2023-10-12 15:02:58.000000 pybrops-1.0.2/pybrops/model/gmod/AdditiveLinearGenomicModel.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3783 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/model/gmod/CoancestryLinearGenomicModel.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    49040 2024-02-25 19:58:48.000000 pybrops-1.0.2/pybrops/model/gmod/DenseAdditiveDominanceLinearGenomicModel.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    75669 2024-02-28 21:25:15.000000 pybrops-1.0.2/pybrops/model/gmod/DenseAdditiveLinearGenomicModel.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    52498 2024-02-28 21:28:22.000000 pybrops-1.0.2/pybrops/model/gmod/DenseLinearGenomicModel.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    30266 2024-02-28 21:31:25.000000 pybrops-1.0.2/pybrops/model/gmod/GenomicModel.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3951 2023-10-12 15:02:58.000000 pybrops-1.0.2/pybrops/model/gmod/LinearGenomicModel.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1150 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/model/gmod/NonlinearGenomicModel.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1040 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/model/gmod/__init__.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    29539 2024-02-28 21:34:12.000000 pybrops-1.0.2/pybrops/model/gmod/rrBLUPModel0.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.972354 pybrops-1.0.2/pybrops/model/pcvmat/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3479 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/model/pcvmat/AdditiveProgenyGeneticCovarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2695 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/model/pcvmat/AdditiveProgenyGenicCovarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3326 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/model/pcvmat/DenseAdditiveProgenyGeneticCovarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3321 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/model/pcvmat/DenseAdditiveProgenyGenicCovarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    43263 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/model/pcvmat/DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    32299 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/model/pcvmat/DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    53931 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/model/pcvmat/DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    41400 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/model/pcvmat/DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     5775 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/model/pcvmat/DenseProgenyGeneticCovarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     4545 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/model/pcvmat/DenseProgenyGenicCovarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    46681 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/model/pcvmat/DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    36740 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/model/pcvmat/DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    39964 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/model/pcvmat/DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    32328 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/model/pcvmat/DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3726 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/model/pcvmat/ProgenyGeneticCovarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3190 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/model/pcvmat/ProgenyGenicCovarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)       83 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/model/pcvmat/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.975354 pybrops-1.0.2/pybrops/model/vmat/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3404 2024-02-29 15:17:44.000000 pybrops-1.0.2/pybrops/model/vmat/AdditiveGeneticVarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2562 2024-02-29 15:20:03.000000 pybrops-1.0.2/pybrops/model/vmat/AdditiveGenicVarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3136 2024-02-29 15:21:09.000000 pybrops-1.0.2/pybrops/model/vmat/DenseAdditiveGeneticVarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3107 2024-02-29 15:31:56.000000 pybrops-1.0.2/pybrops/model/vmat/DenseAdditiveGenicVarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    42247 2024-02-29 15:35:59.000000 pybrops-1.0.2/pybrops/model/vmat/DenseDihybridDHAdditiveGeneticVarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    31085 2024-02-29 15:38:50.000000 pybrops-1.0.2/pybrops/model/vmat/DenseDihybridDHAdditiveGenicVarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    52996 2024-02-29 15:41:05.000000 pybrops-1.0.2/pybrops/model/vmat/DenseFourWayDHAdditiveGeneticVarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    40163 2024-02-29 15:44:50.000000 pybrops-1.0.2/pybrops/model/vmat/DenseFourWayDHAdditiveGenicVarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     5386 2023-10-12 15:02:58.000000 pybrops-1.0.2/pybrops/model/vmat/DenseGeneticVarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     4554 2024-02-29 15:49:21.000000 pybrops-1.0.2/pybrops/model/vmat/DenseGenicVarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    45919 2024-02-29 15:53:30.000000 pybrops-1.0.2/pybrops/model/vmat/DenseThreeWayDHAdditiveGeneticVarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    35807 2024-02-29 15:56:07.000000 pybrops-1.0.2/pybrops/model/vmat/DenseThreeWayDHAdditiveGenicVarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    38075 2024-02-29 15:58:59.000000 pybrops-1.0.2/pybrops/model/vmat/DenseTwoWayDHAdditiveGeneticVarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    31049 2024-02-29 16:07:50.000000 pybrops-1.0.2/pybrops/model/vmat/DenseTwoWayDHAdditiveGenicVarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3811 2023-10-12 15:02:58.000000 pybrops-1.0.2/pybrops/model/vmat/GeneticVarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3324 2024-02-29 16:07:04.000000 pybrops-1.0.2/pybrops/model/vmat/GenicVarianceMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1647 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/model/vmat/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.976354 pybrops-1.0.2/pybrops/model/vmat/fcty/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2956 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/model/vmat/fcty/AdditiveGeneticVarianceMatrixFactory.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2758 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/model/vmat/fcty/AdditiveGenicVarianceMatrixFactory.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     5333 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/model/vmat/fcty/DenseDihybridDHAdditiveGeneticVarianceMatrixFactory.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     5318 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/model/vmat/fcty/DenseFourWayDHAdditiveGeneticVarianceMatrixFactory.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     5333 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/model/vmat/fcty/DenseThreeWayDHAdditiveGeneticVarianceMatrixFactory.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     5303 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/model/vmat/fcty/DenseTwoWayDHAdditiveGeneticVarianceMatrixFactory.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     4813 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/model/vmat/fcty/DenseTwoWayDHAdditiveGenicVarianceMatrixFactory.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2875 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/model/vmat/fcty/GeneticVarianceMatrixFactory.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2524 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/model/vmat/fcty/GenicVarianceMatrixFactory.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1468 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/model/vmat/fcty/__init__.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    10273 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/model/vmat/util.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.976354 pybrops-1.0.2/pybrops/opt/
--rw-r--r--   0 rs14      (1000) rs14      (1000)      222 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.980354 pybrops-1.0.2/pybrops/opt/algo/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     6402 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/algo/BinaryGeneticAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2309 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/algo/BinaryOptimizationAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     6420 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/algo/IntegerGeneticAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2329 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/algo/IntegerOptimizationAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     6407 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/algo/NSGA2BinaryGeneticAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     6425 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/algo/NSGA2IntegerGeneticAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    24807 2024-02-21 20:29:38.000000 pybrops-1.0.2/pybrops/opt/algo/NSGA2MemeticSubsetGeneticAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     6369 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/algo/NSGA2RealGeneticAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     6398 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/algo/NSGA2SubsetGeneticAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     7316 2024-02-21 20:29:38.000000 pybrops-1.0.2/pybrops/opt/algo/NSGA3SubsetGeneticAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2067 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/algo/OptimizationAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     6364 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/algo/RealGeneticAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2269 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/algo/RealOptimizationAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     7087 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/opt/algo/SortingSteepestDescentSubsetHillClimber.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     4002 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/opt/algo/SortingSubsetOptimizationAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     6370 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/opt/algo/SteepestDescentSubsetHillClimber.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     6393 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/algo/SubsetGeneticAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2309 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/algo/SubsetOptimizationAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    13179 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/algo/UnconstrainedNSGA2SetGeneticAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2438 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/algo/UnconstrainedOptimizationAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    13721 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/algo/UnconstrainedSetGeneticAlgorithm.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3829 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/algo/UnconstrainedSteepestAscentSetHillClimber.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1876 2023-10-13 21:27:18.000000 pybrops-1.0.2/pybrops/opt/algo/__init__.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    71359 2024-02-21 20:29:38.000000 pybrops-1.0.2/pybrops/opt/algo/pymoo_addon.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.981354 pybrops-1.0.2/pybrops/opt/prob/
--rw-r--r--   0 rs14      (1000) rs14      (1000)    11877 2024-02-26 02:48:14.000000 pybrops-1.0.2/pybrops/opt/prob/BinaryProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     8255 2024-02-26 03:12:05.000000 pybrops-1.0.2/pybrops/opt/prob/FunctionWeight.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    11670 2024-02-26 03:01:51.000000 pybrops-1.0.2/pybrops/opt/prob/IntegerProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    20189 2024-02-26 02:56:39.000000 pybrops-1.0.2/pybrops/opt/prob/Problem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    11725 2024-02-26 03:02:11.000000 pybrops-1.0.2/pybrops/opt/prob/RealProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    10043 2024-02-26 03:02:25.000000 pybrops-1.0.2/pybrops/opt/prob/SubsetProblem.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      475 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/prob/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.982354 pybrops-1.0.2/pybrops/opt/soln/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     9514 2024-02-26 03:22:24.000000 pybrops-1.0.2/pybrops/opt/soln/BinarySolution.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     9082 2024-02-26 03:23:03.000000 pybrops-1.0.2/pybrops/opt/soln/IntegerSolution.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     9016 2024-02-26 03:23:07.000000 pybrops-1.0.2/pybrops/opt/soln/RealSolution.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    10600 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/soln/Solution.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     8746 2024-02-26 03:23:11.000000 pybrops-1.0.2/pybrops/opt/soln/SubsetSolution.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      413 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/opt/soln/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.982354 pybrops-1.0.2/pybrops/popgen/
--rw-r--r--   0 rs14      (1000) rs14      (1000)      408 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.983354 pybrops-1.0.2/pybrops/popgen/bvmat/
--rw-r--r--   0 rs14      (1000) rs14      (1000)    10574 2023-09-29 20:57:49.000000 pybrops-1.0.2/pybrops/popgen/bvmat/BreedingValueMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    47303 2024-02-21 20:29:38.000000 pybrops-1.0.2/pybrops/popgen/bvmat/DenseBreedingValueMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3501 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/bvmat/DenseEstimatedBreedingValueMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3587 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/bvmat/DenseGenomicEstimatedBreedingValueMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      580 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/bvmat/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.984354 pybrops-1.0.2/pybrops/popgen/cmat/
--rw-r--r--   0 rs14      (1000) rs14      (1000)    15009 2024-02-26 00:59:04.000000 pybrops-1.0.2/pybrops/popgen/cmat/CoancestryMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    41187 2024-02-26 01:06:08.000000 pybrops-1.0.2/pybrops/popgen/cmat/DenseCoancestryMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     6446 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/cmat/DenseGeneralizedWeightedCoancestryMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     8822 2024-02-26 01:06:32.000000 pybrops-1.0.2/pybrops/popgen/cmat/DenseMolecularCoancestryMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     9145 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/cmat/DenseVanRadenCoancestryMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     9090 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/cmat/DenseYangCoancestryMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      752 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/cmat/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.985354 pybrops-1.0.2/pybrops/popgen/cmat/fcty/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1790 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/cmat/fcty/CoancestryMatrixFactory.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2299 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/cmat/fcty/DenseCoancestryMatrixFactory.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2814 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/cmat/fcty/DenseGeneralizedWeightedCoancestryMatrixFactory.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2425 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/cmat/fcty/DenseMolecularCoancestryMatrixFactory.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2537 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/cmat/fcty/DenseVanRadenCoancestryMatrixFactory.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2482 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/cmat/fcty/DenseYangCoancestryMatrixFactory.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      850 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/cmat/fcty/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.987354 pybrops-1.0.2/pybrops/popgen/gmap/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     5099 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/gmap/DenseGeneticMappableMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    84219 2024-02-26 01:23:08.000000 pybrops-1.0.2/pybrops/popgen/gmap/ExtendedGeneticMap.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    29544 2024-02-26 02:32:14.000000 pybrops-1.0.2/pybrops/popgen/gmap/GeneticMap.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     7143 2024-02-26 01:24:30.000000 pybrops-1.0.2/pybrops/popgen/gmap/GeneticMapFunction.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2742 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/gmap/GeneticMappableMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     7665 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/gmap/HaldaneMapFunction.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     7561 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/gmap/KosambiMapFunction.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    60485 2024-02-26 02:35:02.000000 pybrops-1.0.2/pybrops/popgen/gmap/StandardGeneticMap.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      820 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/gmap/__init__.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      569 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/gmap/util.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.988354 pybrops-1.0.2/pybrops/popgen/gmat/
--rw-r--r--   0 rs14      (1000) rs14      (1000)    48956 2024-02-26 01:27:51.000000 pybrops-1.0.2/pybrops/popgen/gmat/DenseGenotypeMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    41010 2024-02-02 20:35:22.000000 pybrops-1.0.2/pybrops/popgen/gmat/DensePhasedGenotypeMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    10324 2024-02-26 00:48:32.000000 pybrops-1.0.2/pybrops/popgen/gmat/GenotypeMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     8543 2024-02-26 00:49:50.000000 pybrops-1.0.2/pybrops/popgen/gmat/HaplotypeMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1602 2024-02-26 00:51:07.000000 pybrops-1.0.2/pybrops/popgen/gmat/PhasedGenotypeMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)     1286 2024-02-26 00:52:07.000000 pybrops-1.0.2/pybrops/popgen/gmat/PhasedHaplotypeMatrix.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)      649 2023-09-17 21:28:54.000000 pybrops-1.0.2/pybrops/popgen/gmat/__init__.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.988354 pybrops-1.0.2/pybrops/test/
--rw-r--r--   0 rs14      (1000) rs14      (1000)      156 2024-02-21 20:29:38.000000 pybrops-1.0.2/pybrops/test/__init__.py
--rw-r--r--   0 rs14      (1000) rs14      (1000)    33089 2024-02-29 15:28:00.000000 pybrops-1.0.2/pybrops/test/assert_python.py
-drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-02-29 17:48:51.989354 pybrops-1.0.2/pybrops.egg-info/
--rw-r--r--   0 rs14      (1000) rs14      (1000)     3133 2024-02-29 17:48:51.000000 pybrops-1.0.2/pybrops.egg-info/PKG-INFO
--rw-r--r--   0 rs14      (1000) rs14      (1000)    17177 2024-02-29 17:48:51.000000 pybrops-1.0.2/pybrops.egg-info/SOURCES.txt
--rw-r--r--   0 rs14      (1000) rs14      (1000)        1 2024-02-29 17:48:51.000000 pybrops-1.0.2/pybrops.egg-info/dependency_links.txt
--rw-r--r--   0 rs14      (1000) rs14      (1000)       53 2024-02-29 17:48:51.000000 pybrops-1.0.2/pybrops.egg-info/requires.txt
--rw-r--r--   0 rs14      (1000) rs14      (1000)        8 2024-02-29 17:48:51.000000 pybrops-1.0.2/pybrops.egg-info/top_level.txt
--rw-r--r--   0 rs14      (1000) rs14      (1000)       87 2024-02-02 20:35:22.000000 pybrops-1.0.2/pyproject.toml
--rw-r--r--   0 rs14      (1000) rs14      (1000)       38 2024-02-29 17:48:51.990354 pybrops-1.0.2/setup.cfg
--rw-r--r--   0 rs14      (1000) rs14      (1000)     2010 2024-02-29 16:57:06.000000 pybrops-1.0.2/setup.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.530771 pybrops-1.0.3/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1075 2023-09-17 21:28:53.000000 pybrops-1.0.3/LICENSE
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3133 2024-05-28 20:33:12.530771 pybrops-1.0.3/PKG-INFO
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2393 2023-10-16 21:05:32.000000 pybrops-1.0.3/README.md
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.455770 pybrops-1.0.3/pybrops/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      544 2024-02-29 17:55:04.000000 pybrops-1.0.3/pybrops/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.455770 pybrops-1.0.3/pybrops/breed/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      224 2023-09-17 21:28:53.000000 pybrops-1.0.3/pybrops/breed/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.457770 pybrops-1.0.3/pybrops/breed/arch/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1261 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/arch/BreedingEdge.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2019 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/arch/BreedingGraph.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     4428 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/arch/BreedingNode.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     9078 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/arch/BreedingProgram.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1931 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/arch/EmigrationOperator.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1307 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/arch/GermplasmBank.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2057 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/arch/ImmigrationOperator.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    19535 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/arch/RecurrentSelectionBreedingProgram.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      797 2023-09-17 21:28:53.000000 pybrops-1.0.3/pybrops/breed/arch/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.457770 pybrops-1.0.3/pybrops/breed/op/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      500 2023-09-17 21:28:53.000000 pybrops-1.0.3/pybrops/breed/op/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.457770 pybrops-1.0.3/pybrops/breed/op/eval/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3161 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/op/eval/EvaluationOperator.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      208 2023-09-17 21:28:53.000000 pybrops-1.0.3/pybrops/breed/op/eval/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.458770 pybrops-1.0.3/pybrops/breed/op/init/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2443 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/op/init/InitializationOperator.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      237 2023-09-17 21:28:53.000000 pybrops-1.0.3/pybrops/breed/op/init/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.458770 pybrops-1.0.3/pybrops/breed/op/log/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     8117 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/op/log/Logbook.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      182 2023-09-17 21:28:53.000000 pybrops-1.0.3/pybrops/breed/op/log/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.458770 pybrops-1.0.3/pybrops/breed/op/mate/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3260 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/op/mate/MatingOperator.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      213 2023-09-17 21:28:53.000000 pybrops-1.0.3/pybrops/breed/op/mate/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.459770 pybrops-1.0.3/pybrops/breed/op/psel/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3302 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/op/psel/ParentSelectionOperator.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      241 2023-09-17 21:28:53.000000 pybrops-1.0.3/pybrops/breed/op/psel/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.459770 pybrops-1.0.3/pybrops/breed/op/ssel/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3246 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/op/ssel/SurvivorSelectionOperator.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      247 2023-09-17 21:28:53.000000 pybrops-1.0.3/pybrops/breed/op/ssel/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.459770 pybrops-1.0.3/pybrops/breed/prot/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      288 2023-09-17 21:28:53.000000 pybrops-1.0.3/pybrops/breed/prot/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.460770 pybrops-1.0.3/pybrops/breed/prot/bv/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2364 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/bv/BreedingValueProtocol.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     7368 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/bv/MeanPhenotypicBreedingValue.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2982 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/bv/TrueBreedingValue.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      469 2023-09-17 21:28:53.000000 pybrops-1.0.3/pybrops/breed/prot/bv/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.461770 pybrops-1.0.3/pybrops/breed/prot/gt/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     6963 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/breed/prot/gt/DenseMaskedPhasedGenotyping.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     6999 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/breed/prot/gt/DenseMaskedUnphasedGenotyping.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3351 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/gt/DenseUnphasedGenotyping.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2162 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/gt/GenotypingProtocol.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      298 2023-09-17 21:28:53.000000 pybrops-1.0.3/pybrops/breed/prot/gt/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.463770 pybrops-1.0.3/pybrops/breed/prot/mate/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    11857 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/mate/FourWayCross.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    13477 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/mate/FourWayDHCross.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3260 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/mate/MatingProtocol.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    11255 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/mate/SelfCross.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    11185 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/mate/ThreeWayCross.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    13226 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/mate/ThreeWayDHCross.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    11662 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/mate/TwoWayCross.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    12693 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/mate/TwoWayDHCross.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      821 2023-09-17 21:28:53.000000 pybrops-1.0.3/pybrops/breed/prot/mate/__init__.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     4002 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/breed/prot/mate/util.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.463770 pybrops-1.0.3/pybrops/breed/prot/pt/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    28779 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/pt/G_E_Phenotyping.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     4617 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/pt/PhenotypingProtocol.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    15263 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/pt/TruePhenotyping.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      319 2023-09-17 21:28:53.000000 pybrops-1.0.3/pybrops/breed/prot/pt/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.471770 pybrops-1.0.3/pybrops/breed/prot/sel/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    14342 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/BinaryMateSelectionProtocol.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    28864 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/BinarySelectionProtocol.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    70881 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/EstimatedBreedingValueSelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    75714 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/breed/prot/sel/ExpectedMaximumBreedingValueSelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    69409 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/FamilyEstimatedBreedingValueSelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    71813 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/GeneralizedWeightedGenomicEstimatedBreedingValueSelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    70809 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/GenomicEstimatedBreedingValueSelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    20445 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/GenotypeBuilderSelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    13869 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/IntegerMateSelectionProtocol.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    28921 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/IntegerSelectionProtocol.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)        0 2023-09-17 21:28:53.000000 pybrops-1.0.3/pybrops/breed/prot/sel/L1NormGenomicSelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    69306 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/L2NormGenomicSelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     8566 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/MateSelectionProtocol.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    69096 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/MeanExpectedHeterozygositySelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    69993 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/MeanGenomicRelationshipSelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    20037 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/MultiObjectiveGenomicSelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    74674 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/OptimalContributionSelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    72802 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/OptimalHaploidValueSelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    19441 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/OptimalPopulationValueSelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    20144 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/PopulationAlleleFrequencyDistanceSelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    20118 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/PopulationAlleleUnavailabilitySelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    68291 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/RandomSelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    14280 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/RealMateSelectionProtocol.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    28774 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/RealSelectionProtocol.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    35263 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/SelectionProtocol.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    13836 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/SubsetMateSelectionProtocol.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    29025 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/SubsetSelectionProtocol.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    25667 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/UnconstrainedGeneralized1NormGenomicSelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    72505 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/breed/prot/sel/UnconstrainedMultiObjectiveGenomicMating.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     8862 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/breed/prot/sel/UnconstrainedSelectionProtocol.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    80172 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/UsefulnessCriterionSelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    56094 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/WeightedGenomicSelection.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3339 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/breed/prot/sel/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.474770 pybrops-1.0.3/pybrops/breed/prot/sel/cfg/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     4990 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/cfg/BinaryMateSelectionConfiguration.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     5498 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/cfg/BinarySelectionConfiguration.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     4994 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/cfg/IntegerMateSelectionConfiguration.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     5356 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/cfg/IntegerSelectionConfiguration.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2347 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/cfg/MateSelectionConfiguration.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     4850 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/cfg/RealMateSelectionConfiguration.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     5277 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/cfg/RealSelectionConfiguration.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2561 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/cfg/SampledSelectionConfigurationMixin.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     5642 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/cfg/SelectionConfiguration.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3326 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/cfg/SimpleMateSelectionConfiguration.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2883 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/cfg/SimpleSelectionConfiguration.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     4793 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/cfg/SubsetMateSelectionConfiguration.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     5210 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/cfg/SubsetSelectionConfiguration.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1605 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/breed/prot/sel/cfg/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.482771 pybrops-1.0.3/pybrops/breed/prot/sel/prob/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     7915 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/BinaryMateSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     8938 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/BinarySelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    41536 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/EstimatedBreedingValueSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    47510 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/ExpectedMaximumBreedingValueSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    44174 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/FamilyEstimatedBreedingValueSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    49880 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    48766 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/GenomicEstimatedBreedingValueSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    14996 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/GenotypeBuilderSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     7923 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/IntegerMateSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     8952 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/IntegerSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    48321 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/L1NormGenomicSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    47839 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/L2NormGenomicSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1256 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/MateSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    43116 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/MeanExpectedHeterozygositySelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    42604 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/MeanGenomicRelationshipSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    20681 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/MultiObjectiveGenomicMatingProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    25628 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/MultiObjectiveGenomicSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    48242 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/OptimalContributionSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    49268 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/OptimalHaploidValueSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    15687 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/OptimalPopulationValueSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    17853 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/PopulationAlleleFrequencyDistanceSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    18670 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/PopulationAlleleUnavailabilitySelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    41588 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/RandomSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     9106 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/RealLookAheadGeneralizedWeightedGenomicSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     7899 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/RealMateSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     8910 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/RealSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    11348 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/SelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     7915 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/SubsetMateSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     9013 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/SubsetSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    67265 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/UsefulnessCriterionSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    40942 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/WeightedGenomicSelectionProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2791 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/__init__.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     6738 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/breed/prot/sel/prob/trans.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.484770 pybrops-1.0.3/pybrops/breed/prot/sel/soln/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2902 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/soln/BinaryMateSelectionSolution.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1000 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/soln/BinarySelectionSolution.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2912 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/soln/IntegerMateSelectionSolution.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1010 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/soln/IntegerSelectionSolution.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1795 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/soln/MateSelectionSolution.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2882 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/soln/RealMateSelectionSolution.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      980 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/soln/RealSelectionSolution.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      950 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/soln/SelectionSolution.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2902 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/soln/SubsetMateSelectionSolution.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1000 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/soln/SubsetSelectionSolution.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1101 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/breed/prot/sel/soln/__init__.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1668 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/breed/prot/sel/targetfn.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     8347 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/breed/prot/sel/transfn.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      984 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/breed/prot/sel/weightfn.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.484770 pybrops-1.0.3/pybrops/core/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      830 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.486770 pybrops-1.0.3/pybrops/core/error/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1174 2023-10-12 15:02:58.000000 pybrops-1.0.3/pybrops/core/error/__init__.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1726 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/core/error/error_attr_python.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     4817 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/error/error_generic_numpy.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1293 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/core/error/error_generic_python.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1481 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/error/error_io_python.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      593 2023-10-12 15:02:58.000000 pybrops-1.0.3/pybrops/core/error/error_type_h5py.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    17583 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/error/error_type_numpy.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1220 2023-09-29 20:57:49.000000 pybrops-1.0.3/pybrops/core/error/error_type_pandas.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    17881 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/error/error_type_python.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2378 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/error/error_value_h5py.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    16350 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/error/error_value_numpy.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     5025 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/error/error_value_pandas.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    13667 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/error/error_value_python.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.488771 pybrops-1.0.3/pybrops/core/io/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2774 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/io/CSVDictInputOutput.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2547 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/io/CSVInputOutput.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3246 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/io/Copyable.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2678 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/io/DictInputOutput.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3343 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/io/HDF5InputOutput.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     6477 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/io/NPYInputOutput.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     5022 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/io/NPZInputOutput.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2721 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/io/NumPyInputOutput.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3061 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/io/PandasDictInputOutput.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2741 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/io/PandasInputOutput.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      792 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/io/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.495771 pybrops-1.0.3/pybrops/core/mat/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    37298 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/DenseMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     4966 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/DenseMutableMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    23230 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/DensePhasedMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    32346 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/DensePhasedTaxaVariantMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    10662 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/DenseScaledMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     5616 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/DenseScaledSquareTaxaTraitMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    15631 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/DenseSquare2TaxaTraitMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     7149 2024-02-02 20:35:22.000000 pybrops-1.0.3/pybrops/core/mat/DenseSquareMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    48536 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/DenseSquareTaxaMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    39025 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/DenseSquareTaxaSquareTraitMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    62380 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/DenseSquareTaxaTraitMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    40851 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/DenseSquareTraitMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    58335 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/DenseTaxaMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    47453 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/DenseTaxaTraitMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    73909 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/DenseTaxaVariantMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    41797 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/DenseTraitMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)   104133 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/DenseVariantMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3092 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/mat/GroupableMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    29829 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/mat/Matrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3407 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/mat/MutableMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     8043 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/mat/PhasedMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1414 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/mat/PhasedTaxaVariantMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2069 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/mat/PrunableMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     5106 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/ScaledMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1399 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/ScaledSquareTaxaTraitMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3826 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/mat/SortableMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2962 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/mat/SquareMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2656 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/mat/SquareTaxaMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1402 2024-02-02 20:35:22.000000 pybrops-1.0.3/pybrops/core/mat/SquareTaxaSquareTraitMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1384 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/mat/SquareTaxaTraitMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2687 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/mat/SquareTraitMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    14709 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/mat/TaxaMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1295 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/mat/TaxaTraitMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1321 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/mat/TaxaVariantMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    11038 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/mat/TraitMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    21111 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/mat/VariantMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3018 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/mat/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.496770 pybrops-1.0.3/pybrops/core/random/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      127 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/core/random/__init__.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     5149 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/random/prng.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     9402 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/random/sampling.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.497771 pybrops-1.0.3/pybrops/core/util/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      303 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/util/__init__.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     6000 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/util/array.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     8870 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/util/h5py.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    11434 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/core/util/haplo.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      459 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/core/util/iterator.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     6052 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/util/mate.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1866 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/core/util/pareto.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     4310 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/core/util/subroutines.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3426 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/core/util/trans.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.498771 pybrops-1.0.3/pybrops/model/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      368 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/model/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.498771 pybrops-1.0.3/pybrops/model/embvmat/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    10200 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/embvmat/DenseExpectedMaximumBreedingValueMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3660 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/embvmat/ExpectedMaximumBreedingValueMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      524 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/embvmat/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.500771 pybrops-1.0.3/pybrops/model/gmod/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     4777 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/gmod/AdditiveDominanceEpistaticLinearGenomicModel.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     4367 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/gmod/AdditiveDominanceLinearGenomicModel.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     4796 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/gmod/AdditiveLinearGenomicModel.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3824 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/gmod/CoancestryLinearGenomicModel.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    51764 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/gmod/DenseAdditiveDominanceLinearGenomicModel.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    90682 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/gmod/DenseAdditiveLinearGenomicModel.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    54942 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/gmod/DenseLinearGenomicModel.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    37366 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/gmod/GenomicModel.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3967 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/gmod/LinearGenomicModel.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1179 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/gmod/NonlinearGenomicModel.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1040 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/model/gmod/__init__.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    31054 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/gmod/rrBLUPModel0.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.504771 pybrops-1.0.3/pybrops/model/pcvmat/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3494 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/pcvmat/AdditiveProgenyGeneticCovarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2712 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/pcvmat/AdditiveProgenyGenicCovarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3326 2024-02-02 20:35:22.000000 pybrops-1.0.3/pybrops/model/pcvmat/DenseAdditiveProgenyGeneticCovarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3321 2024-02-02 20:35:22.000000 pybrops-1.0.3/pybrops/model/pcvmat/DenseAdditiveProgenyGenicCovarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    40224 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/pcvmat/DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    29186 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/pcvmat/DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    50978 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/pcvmat/DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    38370 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/pcvmat/DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     5877 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/pcvmat/DenseProgenyGeneticCovarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     4545 2024-02-02 20:35:22.000000 pybrops-1.0.3/pybrops/model/pcvmat/DenseProgenyGenicCovarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    43686 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/pcvmat/DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    33673 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/pcvmat/DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    36558 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/pcvmat/DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    29211 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/pcvmat/DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3741 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/pcvmat/ProgenyGeneticCovarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3206 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/pcvmat/ProgenyGenicCovarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)       83 2024-02-02 20:35:22.000000 pybrops-1.0.3/pybrops/model/pcvmat/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.504771 pybrops-1.0.3/pybrops/model/pmebvmat/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    11244 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/pmebvmat/DenseTwoWayProgenyMeanEstimatedBreedingValueMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     9217 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/pmebvmat/ProgenyMeanEstimatedBreedingValueMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      442 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/pmebvmat/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.508771 pybrops-1.0.3/pybrops/model/vmat/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3422 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/vmat/AdditiveGeneticVarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2577 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/vmat/AdditiveGenicVarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3136 2024-02-29 17:55:04.000000 pybrops-1.0.3/pybrops/model/vmat/DenseAdditiveGeneticVarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3107 2024-02-29 17:55:04.000000 pybrops-1.0.3/pybrops/model/vmat/DenseAdditiveGenicVarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    38650 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/vmat/DenseDihybridDHAdditiveGeneticVarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    27423 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/vmat/DenseDihybridDHAdditiveGenicVarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    49385 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/vmat/DenseFourWayDHAdditiveGeneticVarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    36487 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/vmat/DenseFourWayDHAdditiveGenicVarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     5736 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/vmat/DenseGeneticVarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     4578 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/vmat/DenseGenicVarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    42321 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/vmat/DenseThreeWayDHAdditiveGeneticVarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    32144 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/vmat/DenseThreeWayDHAdditiveGenicVarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    34144 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/vmat/DenseTwoWayDHAdditiveGeneticVarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    27358 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/vmat/DenseTwoWayDHAdditiveGenicVarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3829 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/vmat/GeneticVarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3340 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/vmat/GenicVarianceMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1647 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/model/vmat/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.510771 pybrops-1.0.3/pybrops/model/vmat/fcty/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2997 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/vmat/fcty/AdditiveGeneticVarianceMatrixFactory.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2799 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/vmat/fcty/AdditiveGenicVarianceMatrixFactory.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     5350 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/vmat/fcty/DenseDihybridDHAdditiveGeneticVarianceMatrixFactory.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     5335 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/vmat/fcty/DenseFourWayDHAdditiveGeneticVarianceMatrixFactory.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     5350 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/vmat/fcty/DenseThreeWayDHAdditiveGeneticVarianceMatrixFactory.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     5320 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/vmat/fcty/DenseTwoWayDHAdditiveGeneticVarianceMatrixFactory.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     4828 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/vmat/fcty/DenseTwoWayDHAdditiveGenicVarianceMatrixFactory.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2907 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/vmat/fcty/GeneticVarianceMatrixFactory.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2556 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/model/vmat/fcty/GenicVarianceMatrixFactory.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1468 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/model/vmat/fcty/__init__.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    10273 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/model/vmat/util.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.511771 pybrops-1.0.3/pybrops/model/wgebvmat/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     8181 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/wgebvmat/DenseWeightedGenomicEstimatedBreedingValueMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3040 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/wgebvmat/WeightedGenomicEstimatedBreedingValueMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      574 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/model/wgebvmat/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.511771 pybrops-1.0.3/pybrops/opt/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      222 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/opt/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.517771 pybrops-1.0.3/pybrops/opt/algo/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     6592 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/BinaryGeneticAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2350 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/BinaryOptimizationAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     6653 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/IntegerGeneticAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2370 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/IntegerOptimizationAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     6597 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/NSGA2BinaryGeneticAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     6657 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/NSGA2IntegerGeneticAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    25286 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/NSGA2MemeticSubsetGeneticAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     6555 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/NSGA2RealGeneticAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     6667 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/NSGA2SubsetGeneticAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     7585 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/NSGA3SubsetGeneticAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2099 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/OptimizationAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     6550 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/RealGeneticAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2310 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/RealOptimizationAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     7186 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/SortingSteepestDescentSubsetHillClimber.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     4101 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/SortingSubsetOptimizationAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     6511 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/SteepestDescentSubsetHillClimber.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     6662 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/SubsetGeneticAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2350 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/SubsetOptimizationAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    13194 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/UnconstrainedNSGA2SetGeneticAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2438 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/opt/algo/UnconstrainedOptimizationAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    13736 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/UnconstrainedSetGeneticAlgorithm.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3844 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/UnconstrainedSteepestAscentSetHillClimber.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1876 2023-10-13 21:27:18.000000 pybrops-1.0.3/pybrops/opt/algo/__init__.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    71576 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/algo/pymoo_addon.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.519771 pybrops-1.0.3/pybrops/opt/prob/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    12109 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/prob/BinaryProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     8285 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/prob/FunctionWeight.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    11854 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/prob/IntegerProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    20439 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/prob/Problem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    11909 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/prob/RealProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    10227 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/prob/SubsetProblem.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      475 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/opt/prob/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.520771 pybrops-1.0.3/pybrops/opt/soln/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     9644 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/soln/BinarySolution.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     9164 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/soln/IntegerSolution.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     9098 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/soln/RealSolution.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    11241 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/soln/Solution.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     8876 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/opt/soln/SubsetSolution.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      413 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/opt/soln/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.520771 pybrops-1.0.3/pybrops/popgen/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      408 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/popgen/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.521771 pybrops-1.0.3/pybrops/popgen/bvmat/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    10934 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/bvmat/BreedingValueMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    56689 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/popgen/bvmat/DenseBreedingValueMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3516 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/bvmat/DenseEstimatedBreedingValueMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3602 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/bvmat/DenseGenomicEstimatedBreedingValueMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      580 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/popgen/bvmat/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.523771 pybrops-1.0.3/pybrops/popgen/cmat/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    15509 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/cmat/CoancestryMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    38862 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/cmat/DenseCoancestryMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     6461 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/cmat/DenseGeneralizedWeightedCoancestryMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     8839 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/cmat/DenseMolecularCoancestryMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     9162 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/cmat/DenseVanRadenCoancestryMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     9105 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/cmat/DenseYangCoancestryMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      752 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/popgen/cmat/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.524771 pybrops-1.0.3/pybrops/popgen/cmat/fcty/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1822 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/cmat/fcty/CoancestryMatrixFactory.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2314 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/cmat/fcty/DenseCoancestryMatrixFactory.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2829 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/cmat/fcty/DenseGeneralizedWeightedCoancestryMatrixFactory.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2440 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/cmat/fcty/DenseMolecularCoancestryMatrixFactory.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2552 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/cmat/fcty/DenseVanRadenCoancestryMatrixFactory.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2496 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/cmat/fcty/DenseYangCoancestryMatrixFactory.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      850 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/popgen/cmat/fcty/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.526771 pybrops-1.0.3/pybrops/popgen/gmap/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     5215 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/gmap/DenseGeneticMappableMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    84293 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/gmap/ExtendedGeneticMap.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    29598 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/gmap/GeneticMap.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     7178 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/gmap/GeneticMapFunction.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2783 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/gmap/GeneticMappableMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     7682 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/gmap/HaldaneMapFunction.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     7578 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/gmap/KosambiMapFunction.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    60559 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/gmap/StandardGeneticMap.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      820 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/popgen/gmap/__init__.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      569 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/popgen/gmap/util.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.528771 pybrops-1.0.3/pybrops/popgen/gmat/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    59341 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/gmat/DenseGenotypeMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    42062 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/gmat/DensePhasedGenotypeMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    11324 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/gmat/GenotypeMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     8593 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/gmat/HaplotypeMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2774 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/popgen/gmat/PhasedGenotypeMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     1321 2024-05-28 20:08:37.000000 pybrops-1.0.3/pybrops/popgen/gmat/PhasedHaplotypeMatrix.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      649 2023-09-17 21:28:54.000000 pybrops-1.0.3/pybrops/popgen/gmat/__init__.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.528771 pybrops-1.0.3/pybrops/test/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)      156 2024-02-21 20:29:38.000000 pybrops-1.0.3/pybrops/test/__init__.py
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    35512 2024-05-28 20:08:38.000000 pybrops-1.0.3/pybrops/test/assert_python.py
+drwxr-xr-x   0 rs14      (1000) rs14      (1000)        0 2024-05-28 20:33:12.530771 pybrops-1.0.3/pybrops.egg-info/
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     3133 2024-05-28 20:33:12.000000 pybrops-1.0.3/pybrops.egg-info/PKG-INFO
+-rw-r--r--   0 rs14      (1000) rs14      (1000)    18249 2024-05-28 20:33:12.000000 pybrops-1.0.3/pybrops.egg-info/SOURCES.txt
+-rw-r--r--   0 rs14      (1000) rs14      (1000)        1 2024-05-28 20:33:12.000000 pybrops-1.0.3/pybrops.egg-info/dependency_links.txt
+-rw-r--r--   0 rs14      (1000) rs14      (1000)       53 2024-05-28 20:33:12.000000 pybrops-1.0.3/pybrops.egg-info/requires.txt
+-rw-r--r--   0 rs14      (1000) rs14      (1000)        8 2024-05-28 20:33:12.000000 pybrops-1.0.3/pybrops.egg-info/top_level.txt
+-rw-r--r--   0 rs14      (1000) rs14      (1000)       87 2024-02-02 20:35:22.000000 pybrops-1.0.3/pyproject.toml
+-rw-r--r--   0 rs14      (1000) rs14      (1000)       38 2024-05-28 20:33:12.530771 pybrops-1.0.3/setup.cfg
+-rw-r--r--   0 rs14      (1000) rs14      (1000)     2010 2024-05-28 20:28:00.000000 pybrops-1.0.3/setup.py
```

### Comparing `pybrops-1.0.2/LICENSE` & `pybrops-1.0.3/LICENSE`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/PKG-INFO` & `pybrops-1.0.3/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pybrops
-Version: 1.0.2
+Version: 1.0.3
 Summary: Python package for breeding program numerical optimization and simulation
 Home-page: https://github.com/rzshrote/pybrops
 Author: Robert Z. Shrote
 Author-email: shrotero@msu.edu
 License: Apache License 2.0
 Project-URL: Bug Tracker, https://github.com/rzshrote/pybrops/issues
 Classifier: Programming Language :: Python :: 3
```

### Comparing `pybrops-1.0.2/README.md` & `pybrops-1.0.3/README.md`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/__init__.py` & `pybrops-1.0.3/pybrops/__init__.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/breed/arch/BreedingEdge.py` & `pybrops-1.0.3/pybrops/breed/arch/BreedingEdge.py`

 * *Files 12% similar despite different names*

```diff
@@ -8,15 +8,17 @@
     "BreedingEdge",
     "check_is_BreedingEdge",
 ]
 
 from abc import ABCMeta
 
 
-class BreedingEdge(metaclass=ABCMeta):
+class BreedingEdge(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class defining interfaces for breeding edges. Breeding edges define
     how information and germplasm flows between breeding nodes.
     """
 
     ########################## Special Object Methods ##########################
```

### Comparing `pybrops-1.0.2/pybrops/breed/arch/BreedingGraph.py` & `pybrops-1.0.3/pybrops/breed/arch/BreedingGraph.py`

 * *Files 6% similar despite different names*

```diff
@@ -6,18 +6,21 @@
 """
 
 __all__ = [
     "BreedingGraph",
     "check_is_BreedingGraph",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 
 
-class BreedingGraph(metaclass=ABCMeta):
+class BreedingGraph(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class defining interfaces for breeding graphs. Breeding graphs
     represent breeding programs with multiple subpopulations. Germplasm and
     information is passed between breeding nodes through breeding edges.
 
     The purpose of this abstract class is to provide functionality for:
         1) Graph representation of the entire breeding graph.
```

### Comparing `pybrops-1.0.2/pybrops/breed/arch/BreedingNode.py` & `pybrops-1.0.3/pybrops/breed/arch/BreedingNode.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,18 +1,21 @@
 """
 Module defining basal interfaces and associated error checking routines for
 breeding nodes. Breeding nodes compose complex breeding programs in a graph-like
 structure. They are points were germplasm and information are located.
 """
 
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 
 
-class BreedingNode(metaclass=ABCMeta):
+class BreedingNode(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class defining a breeding node. Breeding nodes compose complex
     breeding programs in a graph-like structure. They are points were germplasm
     and information are located.
 
     The purpose of this abstract class is to define functionality for:
         1) Container storage for germplasm and information.
```

### Comparing `pybrops-1.0.2/pybrops/breed/arch/BreedingProgram.py` & `pybrops-1.0.3/pybrops/breed/arch/BreedingProgram.py`

 * *Files 1% similar despite different names*

```diff
@@ -4,19 +4,23 @@
 """
 
 __all__ = [
     "BreedingProgram",
     "check_is_BreedingProgram",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.breed.arch.BreedingNode import BreedingNode
 from pybrops.breed.op.log.Logbook import Logbook
 
-class BreedingProgram(BreedingNode,metaclass=ABCMeta):
+class BreedingProgram(
+        BreedingNode,
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class defining a breeding program.
 
     The purpose of this abstract class is to define functionality for:
         1) Container storage for the breeding program.
         2) Contain breeding operators used in the breeding program.
         3) Initialization routines for the breeding program.
```

### Comparing `pybrops-1.0.2/pybrops/breed/arch/EmigrationOperator.py` & `pybrops-1.0.3/pybrops/breed/arch/EmigrationOperator.py`

 * *Files 6% similar despite different names*

```diff
@@ -4,19 +4,23 @@
 """
 
 __all__ = [
     "EmigrationOperator",
     "check_is_EmigrationOperator",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.breed.arch.BreedingEdge import BreedingEdge
 from pybrops.breed.arch.BreedingNode import BreedingNode
 
-class EmigrationOperator(BreedingEdge,metaclass=ABCMeta):
+class EmigrationOperator(
+        BreedingEdge,
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class defining immigration operators.
 
     The purpose of this abstract class is to define functionality for:
         1) Protocols for emigration between different breeding nodes.
     """
```

### Comparing `pybrops-1.0.2/pybrops/breed/arch/GermplasmBank.py` & `pybrops-1.0.3/pybrops/breed/arch/GermplasmBank.py`

 * *Files 13% similar despite different names*

```diff
@@ -7,15 +7,18 @@
     "GermplasmBank",
     "check_is_GermplasmBank",
 ]
 
 from abc import ABCMeta
 from pybrops.breed.arch.BreedingNode import BreedingNode
 
-class GermplasmBank(BreedingNode,metaclass=ABCMeta):
+class GermplasmBank(
+        BreedingNode,
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class defining a germplasm bank.
 
     The purpose of this abstract class is to define functionality for:
         1) Container storage for the germplasm bank.
     """
```

### Comparing `pybrops-1.0.2/pybrops/breed/arch/ImmigrationOperator.py` & `pybrops-1.0.3/pybrops/breed/arch/ImmigrationOperator.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,19 +4,23 @@
 """
 
 __all__ = [
     "ImmigrationOperator",
     "check_is_ImmigrationOperator",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.breed.arch.BreedingEdge import BreedingEdge
 from pybrops.breed.arch.BreedingNode import BreedingNode
 
-class ImmigrationOperator(BreedingEdge,metaclass=ABCMeta):
+class ImmigrationOperator(
+        BreedingEdge,
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class defining immigration operators.
 
     The purpose of this abstract class is to define functionality for:
         1) Protocols for immigration between different breeding nodes.
     """
```

### Comparing `pybrops-1.0.2/pybrops/breed/arch/RecurrentSelectionBreedingProgram.py` & `pybrops-1.0.3/pybrops/breed/arch/RecurrentSelectionBreedingProgram.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,24 +7,30 @@
     "check_is_RecurrentSelectionBreedingProgram",
 ]
 
 import copy
 from typing import Union
 
 from pybrops.breed.arch.BreedingProgram import BreedingProgram
-from pybrops.breed.op.init.InitializationOperator import InitializationOperator, check_is_InitializationOperator
-from pybrops.breed.op.eval.EvaluationOperator import EvaluationOperator, check_is_EvaluationOperator
-from pybrops.breed.op.mate.MatingOperator import MatingOperator, check_is_MatingOperator
-from pybrops.breed.op.psel.ParentSelectionOperator import ParentSelectionOperator, check_is_ParentSelectionOperator
-from pybrops.breed.op.ssel.SurvivorSelectionOperator import SurvivorSelectionOperator, check_is_SurvivorSelectionOperator
+from pybrops.breed.op.init.InitializationOperator import InitializationOperator
+from pybrops.breed.op.init.InitializationOperator import check_is_InitializationOperator
+from pybrops.breed.op.eval.EvaluationOperator import EvaluationOperator
+from pybrops.breed.op.eval.EvaluationOperator import check_is_EvaluationOperator
+from pybrops.breed.op.mate.MatingOperator import MatingOperator
+from pybrops.breed.op.mate.MatingOperator import check_is_MatingOperator
+from pybrops.breed.op.psel.ParentSelectionOperator import ParentSelectionOperator
+from pybrops.breed.op.psel.ParentSelectionOperator import check_is_ParentSelectionOperator
+from pybrops.breed.op.ssel.SurvivorSelectionOperator import SurvivorSelectionOperator
+from pybrops.breed.op.ssel.SurvivorSelectionOperator import check_is_SurvivorSelectionOperator
 from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.core.error.error_type_python import check_is_int
-from pybrops.core.error.error_value_python import check_dict_has_keys
 
-class RecurrentSelectionBreedingProgram(BreedingProgram):
+class RecurrentSelectionBreedingProgram(
+        BreedingProgram,
+    ):
     """
     Class implementing recurrent selection. This class is very generic and
     highly modular to facilitate rapid prototyping.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
```

### Comparing `pybrops-1.0.2/pybrops/breed/arch/__init__.py` & `pybrops-1.0.3/pybrops/breed/arch/__init__.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/breed/op/eval/EvaluationOperator.py` & `pybrops-1.0.3/pybrops/breed/op/eval/EvaluationOperator.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,19 +4,22 @@
 """
 
 __all__ = [
     "EvaluationOperator",
     "check_is_EvaluationOperator",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from typing import Optional
 
 
-class EvaluationOperator(metaclass=ABCMeta):
+class EvaluationOperator(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class defining interfaces for the evaluation of an entire breeding
     program.
 
     The purpose of this abstract class is to provide functionality for:
         1) Evaluation of an entire breeding program.
     """
```

### Comparing `pybrops-1.0.2/pybrops/breed/op/init/InitializationOperator.py` & `pybrops-1.0.3/pybrops/breed/op/init/InitializationOperator.py`

 * *Files 5% similar despite different names*

```diff
@@ -4,19 +4,22 @@
 """
 
 __all__ = [
     "InitializationOperator",
     "check_is_InitializationOperator",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from typing import Optional
 
 
-class InitializationOperator(metaclass=ABCMeta):
+class InitializationOperator(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class defining interfaces for the evaluation of an entire breeding
     program.
 
     The purpose of this abstract class is to provide functionality for:
         1) Initialization of an entire breeding program.
     """
```

### Comparing `pybrops-1.0.2/pybrops/breed/op/log/Logbook.py` & `pybrops-1.0.3/pybrops/breed/op/log/Logbook.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,18 +5,21 @@
 
 __all__ = [
     "Logbook",
     "check_is_Logbook",
 ]
 
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 
 
-class Logbook(metaclass=ABCMeta):
+class Logbook(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class defining interfaces for logging statistics about an entire
     breeding program.
 
     The purpose of this abstract class is to provide functionality for:
         1) Logging data on an entire breeding program.
     """
```

### Comparing `pybrops-1.0.2/pybrops/breed/op/mate/MatingOperator.py` & `pybrops-1.0.3/pybrops/breed/op/mate/MatingOperator.py`

 * *Files 3% similar despite different names*

```diff
@@ -4,19 +4,22 @@
 """
 
 __all__ = [
     "MatingOperator",
     "check_is_MatingOperator",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from typing import Optional
 
 
-class MatingOperator(metaclass=ABCMeta):
+class MatingOperator(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class defining interfaces for the mating of an entire breeding
     program.
 
     The purpose of this abstract class is to provide functionality for:
         1) Mating of an entire breeding program.
     """
```

### Comparing `pybrops-1.0.2/pybrops/breed/op/psel/ParentSelectionOperator.py` & `pybrops-1.0.3/pybrops/breed/op/psel/ParentSelectionOperator.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,18 +4,21 @@
 """
 
 __all__ = [
     "ParentSelectionOperator",
     "check_is_ParentSelectionOperator",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 
 
-class ParentSelectionOperator(metaclass=ABCMeta):
+class ParentSelectionOperator(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class defining interfaces for parental selection within an entire
     breeding program.
 
     The purpose of this abstract class is to provide functionality for:
         1) Parental selection for an entire breeding program.
     """
```

### Comparing `pybrops-1.0.2/pybrops/breed/op/ssel/SurvivorSelectionOperator.py` & `pybrops-1.0.3/pybrops/breed/op/ssel/SurvivorSelectionOperator.py`

 * *Files 14% similar despite different names*

```diff
@@ -4,19 +4,22 @@
 """
 
 __all__ = [
     "SurvivorSelectionOperator",
     "check_is_SurvivorSelectionOperator",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from typing import Optional
 
 
-class SurvivorSelectionOperator(metaclass=ABCMeta):
+class SurvivorSelectionOperator(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class defining interfaces for survivor selection within an entire
     breeding program.
 
     The purpose of this abstract class is to provide functionality for:
         1) Survivor selection for an entire breeding program.
     """
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/bv/BreedingValueProtocol.py` & `pybrops-1.0.3/pybrops/breed/prot/bv/BreedingValueProtocol.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,21 +1,24 @@
 """
 Module defining interfaces and associated error checking methods for breeding
 value calculation protocols.
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from typing import Optional
 
 import pandas
 
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
-class BreedingValueProtocol(metaclass=ABCMeta):
+class BreedingValueProtocol(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class defining interfaces for breeding value calculation protocols.
 
     The purpose of this abstract class is to provide functionality for:
         1) Estimation of breeding values from phenotype values.
     """
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/bv/MeanPhenotypicBreedingValue.py` & `pybrops-1.0.3/pybrops/breed/prot/bv/MeanPhenotypicBreedingValue.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,24 +1,31 @@
 """
 Module for estimating breeding values using the mean across all environments.
 """
 
-from typing import Iterable, Optional, Union
+from typing import Iterable
+from typing import Optional
+from typing import Union
 import numpy
 import pandas
 
 from pybrops.breed.prot.bv.BreedingValueProtocol import BreedingValueProtocol
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
 from pybrops.core.error.error_type_python import check_is_str
-from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column, check_pandas_DataFrame_has_columns
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_columns
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.bvmat.DenseEstimatedBreedingValueMatrix import DenseEstimatedBreedingValueMatrix
-from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix, check_GenotypeMatrix_has_taxa, check_is_GenotypeMatrix
+from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
+from pybrops.popgen.gmat.GenotypeMatrix import check_GenotypeMatrix_has_taxa
+from pybrops.popgen.gmat.GenotypeMatrix import check_is_GenotypeMatrix
 
-class MeanPhenotypicBreedingValue(BreedingValueProtocol):
+class MeanPhenotypicBreedingValue(
+        BreedingValueProtocol,
+    ):
     """
     Class implementing estimation of breeding values by taking the mean across
     all environments.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/bv/TrueBreedingValue.py` & `pybrops-1.0.3/pybrops/breed/prot/bv/TrueBreedingValue.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,19 +2,22 @@
 Module implementing the extraction of true breeding value.
 """
 
 from typing import Union
 import numpy
 import pandas
 from pybrops.breed.prot.bv.BreedingValueProtocol import BreedingValueProtocol
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
-class TrueBreedingValue(BreedingValueProtocol):
+class TrueBreedingValue(
+        BreedingValueProtocol,
+    ):
     """
     Class implementing the extraction of true breeding value.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/gt/DenseUnphasedGenotyping.py` & `pybrops-1.0.3/pybrops/breed/prot/gt/DenseUnphasedGenotyping.py`

 * *Files 18% similar despite different names*

```diff
@@ -2,17 +2,20 @@
 Module implementing unphased genotyping for dense genotype matrices.
 """
 
 from typing import Optional
 from pybrops.breed.prot.gt.GenotypingProtocol import GenotypingProtocol
 from pybrops.popgen.gmat.DenseGenotypeMatrix import DenseGenotypeMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
 
-class DenseUnphasedGenotyping(GenotypingProtocol):
+class DenseUnphasedGenotyping(
+        GenotypingProtocol,
+    ):
     """
     Class implementing unphased genotyping for dense genotype matrices. This
     converts a DensePhasedGenotypeMatrix to a DenseGenotypeMatrix containing
     genotype values.
     """
 
     ########################## Special Object Methods ##########################
@@ -75,8 +78,18 @@
             vrnt_hapalt = pgmat.vrnt_hapalt,
             vrnt_hapref = pgmat.vrnt_hapref,
             vrnt_mask = pgmat.vrnt_mask,
             ploidy = pgmat.ploidy,
             **kwargs
         )
 
+        # copy metadata
+        out.taxa_grp_name    = pgmat.taxa_grp_name
+        out.taxa_grp_stix    = pgmat.taxa_grp_stix
+        out.taxa_grp_spix    = pgmat.taxa_grp_spix
+        out.taxa_grp_len     = pgmat.taxa_grp_len
+        out.vrnt_chrgrp_name = pgmat.vrnt_chrgrp_name
+        out.vrnt_chrgrp_stix = pgmat.vrnt_chrgrp_stix
+        out.vrnt_chrgrp_spix = pgmat.vrnt_chrgrp_spix
+        out.vrnt_chrgrp_len  = pgmat.vrnt_chrgrp_len
+
         return out
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/gt/GenotypingProtocol.py` & `pybrops-1.0.3/pybrops/breed/prot/gt/GenotypingProtocol.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,22 @@
 """
 Module containing the abstract class GenotypingProtocol and its service functions.
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from typing import Optional
 
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class GenotypingProtocol(metaclass=ABCMeta):
+class GenotypingProtocol(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class defining genotyping protocols.
 
     The purpose of this abstract class is to define functionality for:
         1) Genotyping of individuals (converting a genome matrix to genotype matrix).
     """
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/mate/FourWayCross.py` & `pybrops-1.0.3/pybrops/breed/prot/mate/FourWayCross.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,28 +4,37 @@
 
 __all__ = [
     "FourWayCross",
     "check_is_FourWayCross",
 ]
 
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.breed.prot.mate.util import mat_mate
 from pybrops.breed.prot.mate.MatingProtocol import MatingProtocol
-from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState, check_is_ndarray
+from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
+from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_attr_python import error_readonly
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_dict
-from pybrops.core.error.error_value_numpy import check_ndarray_axis_len, check_ndarray_ndim, check_ndarray_shape_eq
-from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import DensePhasedGenotypeMatrix, check_DensePhasedGenotypeMatrix_has_vrnt_xoprob
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_dict
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_shape_eq
+from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import DensePhasedGenotypeMatrix
+from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import check_DensePhasedGenotypeMatrix_has_vrnt_xoprob
 from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import check_is_DensePhasedGenotypeMatrix
 from pybrops.core.random.prng import global_prng
 
-class FourWayCross(MatingProtocol):
+class FourWayCross(
+        MatingProtocol,
+    ):
     """
     Class implementing mating protocols for four-way crosses.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/mate/FourWayDHCross.py` & `pybrops-1.0.3/pybrops/breed/prot/mate/ThreeWayDHCross.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,86 +1,94 @@
 """
-Module implementing mating protocols for four-way DH crosses.
+Module implementing mating protocols for three-way DH crosses.
 """
 
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.breed.prot.mate.util import mat_dh
 from pybrops.breed.prot.mate.util import mat_mate
 from pybrops.breed.prot.mate.MatingProtocol import MatingProtocol
-from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState, check_is_ndarray
+from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
+from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_attr_python import error_readonly
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_dict
-from pybrops.core.error.error_value_numpy import check_ndarray_axis_len, check_ndarray_ndim, check_ndarray_shape_eq
-from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import DensePhasedGenotypeMatrix, check_DensePhasedGenotypeMatrix_has_vrnt_xoprob, check_is_DensePhasedGenotypeMatrix
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_dict
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_shape_eq
+from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import DensePhasedGenotypeMatrix
+from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import check_DensePhasedGenotypeMatrix_has_vrnt_xoprob
+from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import check_is_DensePhasedGenotypeMatrix
 from pybrops.core.random.prng import global_prng
 
-class FourWayDHCross(MatingProtocol):
+class ThreeWayDHCross(
+        MatingProtocol,
+    ):
     """
-    Class implementing mating protocols for four-way DH crosses.
+    Class implementing mating protocols for three-way DH crosses.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
-            progeny_counter: Integral = 0, 
-            family_counter: Integral = 0, 
-            rng: Union[Generator,RandomState,None] = global_prng, 
+            progeny_counter: int = 0, 
+            family_counter: int = 0, 
+            rng: Optional[Union[Generator,RandomState]] = None, 
             **kwargs: dict
         ) -> None:
         """
-        Constructor for the concrete class FourWayDHCross.
+        Constructor for the concrete class ThreeWayDHCross.
 
         Parameters
         ----------
         progeny_counter : Integral
             Progeny counter. This helps create progeny names.
         family_counter : Integral
             Family counter. This helps label groups of progenies as originating 
             from the same family.
         rng : numpy.random.Generator, numpy.random.RandomState
             Random number source.
         kwargs : dict
             Additional keyword arguments.
         """
-        super(FourWayDHCross, self).__init__(**kwargs)
-
         # make assignments
         self.progeny_counter = progeny_counter
         self.family_counter = family_counter
         self.rng = rng
 
     ############################ Object Properties #############################
     @property
     def nparent(self) -> Integral:
         """Number of parents the mating protocol requires."""
-        return 4
+        return 3
     @nparent.setter
     def nparent(self, value: Integral) -> None:
         """Set number of parents the mating protocol requires."""
         error_readonly("nparent")
 
     @property
-    def progeny_counter(self) -> int:
+    def progeny_counter(self) -> Integral:
         """Description for property progeny_counter."""
         return self._progeny_counter
     @progeny_counter.setter
-    def progeny_counter(self, value: int) -> None:
+    def progeny_counter(self, value: Integral) -> None:
         """Set data for property progeny_counter."""
         check_is_Integral(value, "progeny_counter")
         self._progeny_counter = value
 
     @property
-    def family_counter(self) -> int:
+    def family_counter(self) -> Integral:
         """Description for property family_counter."""
         return self._family_counter
     @family_counter.setter
-    def family_counter(self, value: int) -> None:
+    def family_counter(self, value: Integral) -> None:
         """Set data for property family_counter."""
         check_is_Integral(value, "family_counter")
         self._family_counter = value
 
     @property
     def rng(self) -> Union[Generator,RandomState]:
         """Random number generator."""
@@ -101,30 +109,30 @@
             nmating: Union[Integral,numpy.ndarray], 
             nprogeny: Union[Integral,numpy.ndarray], 
             miscout: Optional[dict] = None, 
             nself: Integral = 0, 
             **kwargs: dict
         ) -> DensePhasedGenotypeMatrix:
         """
-        Mate individuals according to a 4-way mate selection scheme.
+        Mate individuals according to a 3-way mate selection scheme.
 
         Example crossing diagram::
 
-            sel = [F2,M2,F1,M1,...], ncross = 2, nprogeny = 2, nself = 2
-                                                 pgmat
-                                                   │                        sel = [F2,M2,F1,M1,...]
-                                            (F2xM2)x(F1xM1)
-                                   ┌───────────────┴───────────────┐        ncross = 2
-                            (F2xM2)x(F1xM1)                       ...       duplicate cross 2x
-                                   │                               │        nself = 2
-                          S0((F2xM2)x(F1xM1))                     ...       first self
-                                   │                               │
-                          S1((F2xM2)x(F1xM1))                     ...       second self
-                       ┌───────────┴───────────┐               ┌───┴───┐    DH, nprogeny = 2
-            DH(S1((F2xM2)x(F1xM1))) DH(S1((F2xM2)x(F1xM1)))   ...     ...   final result
+            sel = [R,F,M,...], nmating = 2, nprogeny = 2, nself = 2
+                                        pgmat
+                                          │                                 sel = [R,F,M,...]
+                                       Rx(FxM)
+                          ┌───────────────┴───────────────┐                 nmating = 2
+                       Rx(FxM)                         Rx(FxM)              duplicate cross 2x
+                          │                               │                 nself = 2
+                      S0(Rx(FxM))                     S0(Rx(FxM))           first self
+                          │                               │
+                      S1(Rx(FxM))                     S1(Rx(FxM))           second self
+                  ┌───────┴───────┐               ┌───────┴───────┐         DH, nprogeny = 2
+            DH(S1(Rx(FxM))) DH(S1(Rx(FxM))) DH(S1(Rx(FxM))) DH(S1(Rx(FxM))) final result
 
         Parameters
         ----------
         pgmat : DensePhasedGenotypeMatrix
             A GenotypeMatrix containing candidate breeding individuals.
         xconfig : numpy.ndarray
             Array of shape ``(ncross,nparent)`` containing indices specifying a cross
@@ -133,37 +141,35 @@
             Where:
 
             - ``ncross`` is the number of crosses to perform.
             - ``nparent`` is the number of parents required for a cross.
 
             Indices are paired as follows:
 
-            - First index is the female parent 2.
-            - Second index is the male parent 2.
-            - Third index is the female parent 1.
-            - Fourth index is the male parent 1.
+            - First index is the recurrent parent.
+            - Second index is the female parent.
+            - Third index is the male parent.
 
             Example::
 
-                xconfig = [[ 1, 5, 3, 8 ],
-                           [ 2, 7, 0, 4 ],
+                xconfig = [[ 1, 5, 3 ],
+                           [ 8, 2, 7 ],
                            ...,
-                           [ F2, M2, F1, M1 ]]
-                female2 = [1, 2, ..., F2]
-                male2 = [5, 7, ..., M2]
-                female1 = [3, 0, ..., F1]
-                male1 = [8, 4, ..., M1]
+                           [ R, F, M ]]
+                recurrent = [1, 8, ..., R]
+                female = [5, 2, ..., F]
+                male = [3, 7, ..., M]
         nmating : numpy.ndarray
             Number of cross patterns to perform.
         nprogeny : numpy.ndarray
             Number of doubled haploid progeny to generate per cross.
         miscout : dict, None, default = None
             Pointer to a dictionary for miscellaneous user defined output.
-            If ``dict``, write to dict (may overwrite previously defined fields).
-            If ``None``, user defined output is not calculated or stored.
+            If dict, write to dict (may overwrite previously defined fields).
+            If None, user defined output is not calculated or stored.
         nself : int, default = 0
             Number of selfing generations post-cross before double haploids are
             generated.
         kwargs : dict
             Additional keyword arguments to be passed to constructor for the
             output DensePhasedGenotypeMatrix.
 
@@ -198,51 +204,48 @@
             check_is_dict(miscout, "miscout")
         
         # check nself
         check_is_Integral(nself, "nself")
 
         ########################################################################
         ########################## Progeny generation ##########################
-        # get female2, male2, female1, and male1 selections; repeat by nmating
-        f2sel = numpy.repeat(xconfig[:,0], nmating)
-        m2sel = numpy.repeat(xconfig[:,1], nmating)
-        f1sel = numpy.repeat(xconfig[:,2], nmating)
-        m1sel = numpy.repeat(xconfig[:,3], nmating)
+        # get recurrent, female, and male selections; repeat by ncross
+        rsel = numpy.repeat(xconfig[:,0], nmating)  # recurrent parent
+        fsel = numpy.repeat(xconfig[:,1], nmating)  # female parent
+        msel = numpy.repeat(xconfig[:,2], nmating)  # male parent
 
         # get pointers to genotypes and crossover probabilities, respectively
         geno = pgmat.mat
         xoprob = pgmat.vrnt_xoprob
 
         # create F1 genotypes
-        abgeno = mat_mate(geno, geno, f1sel, m1sel, xoprob, self.rng)
-        cdgeno = mat_mate(geno, geno, f2sel, m2sel, xoprob, self.rng)
+        f1geno = mat_mate(geno, geno, fsel, msel, xoprob, self.rng)
 
-        # generate selection array for hybrid lines
-        absel = numpy.arange(abgeno.shape[1])
-        cdsel = numpy.arange(cdgeno.shape[1])
+        # generate selection array for all hybrid lines
+        hsel = numpy.arange(f1geno.shape[1])
 
-        # generate dihybrid cross
-        dihgeno = mat_mate(abgeno, cdgeno, absel, cdsel, xoprob, self.rng)
+        # create backcross genotypes
+        bcgeno = mat_mate(geno, f1geno, rsel, hsel, xoprob, self.rng)
 
-        # generate selection array for dihybrid lines
-        dihsel = numpy.arange(dihgeno.shape[1])
+        # generate selection array for all backcross lines
+        bcsel = numpy.arange(bcgeno.shape[1])
 
         # self down hybrids if needed
         for i in range(nself):
-            # self hybrids
-            dihgeno = mat_mate(dihgeno, dihgeno, dihsel, dihsel, xoprob, self.rng)
+            # self backcross lines
+            bcgeno = mat_mate(bcgeno, bcgeno, bcsel, bcsel, xoprob, self.rng)
 
         # generate selection array for progeny
         psel = numpy.repeat(
-            numpy.arange(dihgeno.shape[1]), 
+            numpy.arange(bcgeno.shape[1]), 
             numpy.repeat(nprogeny, nmating)
         )
 
         # generate doubled haploids
-        dhgeno = mat_dh(dihgeno, psel, xoprob, self.rng)
+        dhgeno = mat_dh(bcgeno, psel, xoprob, self.rng)
 
         ########################################################################
         ######################### Metadata generation ##########################
         # generate line names
         progcnt = dhgeno.shape[1]               # get number of hybrid progeny generated
         riter = range(                          # range iterator for line names
             self.progeny_counter,               # start progeny number (inclusive)
@@ -294,20 +297,20 @@
         progeny.group_taxa()
 
         return progeny
 
 
 
 ################################## Utilities ###################################
-def check_is_FourWayDHCross(v: object, vname: str) -> None:
+def check_is_ThreeWayDHCross(v: object, vname: str) -> None:
     """
-    Check if object is of type FourWayDHCross. Otherwise raise TypeError.
+    Check if object is of type ThreeWayDHCross. Otherwise raise TypeError.
 
     Parameters
     ----------
     v : object
         Any Python object to test.
     vname : str
         Name of variable to print in TypeError message.
     """
-    if not isinstance(v, FourWayDHCross):
-        raise TypeError("'%s' must be a FourWayDHCross." % vname)
+    if not isinstance(v, ThreeWayDHCross):
+        raise TypeError("variable '{0}' must be of type '{1}' but received type '{2}'".format(vname,ThreeWayDHCross.__name__,type(v).__name__))
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/mate/MatingProtocol.py` & `pybrops-1.0.3/pybrops/breed/prot/mate/MatingProtocol.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,24 @@
 """
 Module defining interfaces and associated error checking routines for mating
 mating protocols.
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 import numpy
 
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
-class MatingProtocol(metaclass=ABCMeta):
+class MatingProtocol(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class for mating protocols.
 
     The purpose of this abstract class is to provide functionality for:
         1) Mating simulation and progeny generation from genotype matrices.
     """
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/mate/SelfCross.py` & `pybrops-1.0.3/pybrops/breed/prot/mate/TwoWayCross.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,39 +1,49 @@
 """
-Module implementing mating protocols for self-fertilization.
+Module implementing mating protocols for two-way crosses.
 """
 
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.breed.prot.mate.util import mat_mate
 from pybrops.breed.prot.mate.MatingProtocol import MatingProtocol
-from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState, check_is_ndarray
+from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
 from pybrops.core.error.error_attr_python import error_readonly
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_dict
-from pybrops.core.error.error_value_numpy import check_ndarray_axis_len, check_ndarray_ndim, check_ndarray_shape_eq
-from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import DensePhasedGenotypeMatrix, check_DensePhasedGenotypeMatrix_has_vrnt_xoprob, check_is_DensePhasedGenotypeMatrix
+from pybrops.core.error.error_type_numpy import check_is_ndarray
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_dict
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_shape_eq
+from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import check_DensePhasedGenotypeMatrix_has_vrnt_xoprob
+from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import check_is_DensePhasedGenotypeMatrix
+from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import DensePhasedGenotypeMatrix
 from pybrops.core.random.prng import global_prng
 
-class SelfCross(MatingProtocol):
+class TwoWayCross(
+        MatingProtocol,
+    ):
     """
-    Class implementing mating protocols for self-fertilization.
+    Class implementing mating protocols for two-way crosses.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             progeny_counter: Integral = 0, 
             family_counter: Integral = 0, 
             rng: Optional[Union[Generator,RandomState]] = None, 
             **kwargs: dict
         ) -> None:
         """
-        Constructor for the concrete class SelfCross.
+        Constructor for the concrete class TwoWayCross.
 
         Parameters
         ----------
         progeny_counter : Integral
             Progeny counter. This helps create progeny names.
         family_counter : Integral
             Family counter. This helps label groups of progenies as originating 
@@ -48,15 +58,15 @@
         self.family_counter = family_counter
         self.rng = rng
 
     ############################ Object Properties #############################
     @property
     def nparent(self) -> Integral:
         """Number of parents the mating protocol requires."""
-        return 1
+        return 2
     @nparent.setter
     def nparent(self, value: Integral) -> None:
         """Set number of parents the mating protocol requires."""
         error_readonly("nparent")
 
     @property
     def progeny_counter(self) -> Integral:
@@ -98,29 +108,29 @@
             nmating: Union[Integral,numpy.ndarray], 
             nprogeny: Union[Integral,numpy.ndarray], 
             miscout: Optional[dict] = None, 
             nself: Integral = 0, 
             **kwargs: dict
         ) -> DensePhasedGenotypeMatrix:
         """
-        Self-fertilize individuals.
+        Mate individuals according to a 2-way mate selection scheme.
 
         Example crossing diagram::
 
-                     pgmat
-                       │                sel = [A,...]
-                       A
-                 ┌─────┴─────┐          nmating = 2
-                 A           A
-              ┌──┴──┐     ┌──┴──┐       initial self, nprogeny = 2
-            S0(A) S0(A) S0(A) S0(A)     cross pattern finished.
-              │     │     │     │       s = 2
-            S1(A) S1(A) S1(A) S1(A)     first self
-              │     │     │     │
-            S2(A) S2(A) S2(A) S2(A)     second self, final result
+                                pgmat
+                                │                       sel = [A,B,...]
+                               AxB
+                    ┌───────────┴───────────┐           nmating * nprogeny = 2
+                   AxB                     AxB          duplicate cross (nmating * nprogeny) times
+                    │                       │           nself = 2
+                S0(AxB)                 S0(AxB)         first self
+                    │                       │
+                S1(AxB)                 S1(AxB)         second self
+                    |                       |
+                S1(AxB)                 S1(AxB)         final result
 
         Parameters
         ----------
         pgmat : DensePhasedGenotypeMatrix
             A DensePhasedGenotypeMatrix containing candidate breeding
             individuals.
         xconfig : numpy.ndarray
@@ -128,36 +138,39 @@
             configuration. Each index corresponds to an individual in ``pgmat``.
 
             Where:
 
             - ``ncross`` is the number of crosses to perform.
             - ``nparent`` is the number of parents required for a cross.
 
-            Indices are organized as follows:
+            Indices are paired as follows:
 
-            - All indices are self parents.
+            - Even indices are female.
+            - Odd indices are male.
 
             Example::
 
-                xconfig = [[ 1 ],
-                           [ 3 ],
-                           [ 2 ],
+                xconfig = [[ 1, 5 ],
+                           [ 3, 8 ],
+                           [ 2, 7 ],
                            ...,
-                           [ S ]]
-                self = [1, 3, 2, ..., S]
+                           [ F, M ]]
+                female = [1, 3, 2, ..., F]
+                male = [5, 8, 7, ..., M]
         ncross : numpy.ndarray
             Number of cross patterns to perform.
         nprogeny : numpy.ndarray
             Number of progeny to generate per cross.
         miscout : dict, None, default = None
             Pointer to a dictionary for miscellaneous user defined output.
             If ``dict``, write to dict (may overwrite previously defined fields).
             If ``None``, user defined output is not calculated or stored.
-        s : int, default = 0
-            Number of generations of single seed descent post-cross pattern.
+        nself : int, default = 0
+            Number of selfing generations post-cross before progeny lines are
+            generated.
         kwargs : dict
             Additional keyword arguments to be passed to constructor for the
             output DensePhasedGenotypeMatrix.
 
         Returns
         -------
         out : DensePhasedGenotypeMatrix
@@ -189,61 +202,62 @@
             check_is_dict(miscout, "miscout")
         
         # check nself
         check_is_Integral(nself, "nself")
 
         ########################################################################
         ########################## Progeny generation ##########################
+        # get female and male selections; repeat by nmating
+        fsel = numpy.repeat(xconfig[:,0], nmating * nprogeny)
+        msel = numpy.repeat(xconfig[:,1], nmating * nprogeny)
+
         # get pointers to genotypes and crossover probabilities, respectively
         geno = pgmat.mat
         xoprob = pgmat.vrnt_xoprob
 
-        # get female selections; repeat by ncross
-        fsel = numpy.repeat(xconfig[:,0], nmating * nprogeny)
-
-        # self genotypes
-        sgeno = mat_mate(geno, geno, fsel, fsel, xoprob, self.rng)
+        # create hybrid genotypes
+        hgeno = mat_mate(geno, geno, fsel, msel, xoprob, self.rng)
 
-        # generate selection array for all selfed lines
-        ssel = numpy.arange(sgeno.shape[1])
+        # generate selection array for all hybrid lines
+        asel = numpy.arange(hgeno.shape[1])
 
-        # perform single seed descent
+        # self down hybrids if needed
         for i in range(nself):
-            # self lines
-            sgeno = mat_mate(sgeno, sgeno, ssel, ssel, xoprob, self.rng)
+            # self hybrids
+            hgeno = mat_mate(hgeno, hgeno, asel, asel, xoprob, self.rng)
 
         ########################################################################
         ######################### Metadata generation ##########################
         # generate line names
-        progcnt = sgeno.shape[1]                # get number of self progeny generated
+        progcnt = hgeno.shape[1]                # get number of hybrid progeny generated
         riter = range(                          # range iterator for line names
             self.progeny_counter,               # start progeny number (inclusive)
             self.progeny_counter + progcnt      # stop progeny number (exclusive)
         )
         # create taxa names
-        taxa = numpy.array(["sx"+str(i).zfill(7) for i in riter], dtype = "object")
+        taxa = numpy.array(["2w"+str(i).zfill(7) for i in riter], dtype = "object")
         self.progeny_counter += progcnt         # increment counter
 
         # calculate taxa family groupings
         nfam = len(xconfig)                     # calculate number of families
-        taxa_grp = numpy.repeat(                # repeat for mating * progeny
-            numpy.arange(                       # repeat for crosses
+        taxa_grp = numpy.repeat(                # construct taxa_grp vector
+            numpy.arange(                       # repeat for crosses * progeny
                 self.family_counter,            # start family number (inclusive)
                 self.family_counter + nfam,     # stop family number (exclusive)
                 dtype = 'int64'
             ),
             nmating * nprogeny
         )
         self.family_counter += nfam             # increment counter
-
+        
         ########################################################################
         ########################## Output generation ###########################
         # create new DensePhasedGenotypeMatrix
         progeny = DensePhasedGenotypeMatrix(
-            mat = sgeno,
+            mat = hgeno,
             taxa = taxa,
             taxa_grp = taxa_grp,
             vrnt_chrgrp = pgmat.vrnt_chrgrp,
             vrnt_phypos = pgmat.vrnt_phypos,
             vrnt_name = pgmat.vrnt_name,
             vrnt_genpos = pgmat.vrnt_genpos,
             vrnt_xoprob = pgmat.vrnt_xoprob,
@@ -262,20 +276,20 @@
         progeny.group_taxa()
 
         return progeny
 
 
 
 ################################## Utilities ###################################
-def check_is_SelfCross(v: object, vname: str) -> None:
+def check_is_TwoWayCross(v: object, vname: str) -> None:
     """
-    Check if object is of type SelfCross. Otherwise raise TypeError.
+    Check if object is of type TwoWayCross. Otherwise raise TypeError.
 
     Parameters
     ----------
     v : object
         Any Python object to test.
     vname : str
         Name of variable to print in TypeError message.
     """
-    if not isinstance(v, SelfCross):
-        raise TypeError("'%s' must be a SelfCross." % vname)
+    if not isinstance(v, TwoWayCross):
+        raise TypeError("'%s' must be a TwoWayCross." % vname)
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/mate/ThreeWayCross.py` & `pybrops-1.0.3/pybrops/breed/prot/mate/ThreeWayCross.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,26 +1,35 @@
 """
 Module implementing mating protocols for three-way crosses.
 """
 
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.breed.prot.mate.util import mat_mate
 from pybrops.breed.prot.mate.MatingProtocol import MatingProtocol
-from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState, check_is_ndarray
+from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
+from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_attr_python import error_readonly
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_dict
-from pybrops.core.error.error_value_numpy import check_ndarray_axis_len, check_ndarray_ndim, check_ndarray_shape_eq
-from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import check_DensePhasedGenotypeMatrix_has_vrnt_xoprob, check_is_DensePhasedGenotypeMatrix
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_dict
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_shape_eq
+from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import check_DensePhasedGenotypeMatrix_has_vrnt_xoprob
+from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import check_is_DensePhasedGenotypeMatrix
 from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import DensePhasedGenotypeMatrix
 from pybrops.core.random.prng import global_prng
 
-class ThreeWayCross(MatingProtocol):
+class ThreeWayCross(
+        MatingProtocol,
+    ):
     """
     Class implementing mating protocols for three-way crosses.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/mate/ThreeWayDHCross.py` & `pybrops-1.0.3/pybrops/breed/prot/mate/TwoWayDHCross.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,63 +1,73 @@
 """
 Module implementing mating protocols for three-way DH crosses.
 """
 
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.breed.prot.mate.util import mat_dh
 from pybrops.breed.prot.mate.util import mat_mate
 from pybrops.breed.prot.mate.MatingProtocol import MatingProtocol
-from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState, check_is_ndarray
+from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
+from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_attr_python import error_readonly
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_dict
-from pybrops.core.error.error_value_numpy import check_ndarray_axis_len, check_ndarray_ndim, check_ndarray_shape_eq
-from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import DensePhasedGenotypeMatrix, check_DensePhasedGenotypeMatrix_has_vrnt_xoprob, check_is_DensePhasedGenotypeMatrix
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_dict
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_shape_eq
+from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import DensePhasedGenotypeMatrix
+from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import check_DensePhasedGenotypeMatrix_has_vrnt_xoprob
+from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import check_is_DensePhasedGenotypeMatrix
 from pybrops.core.random.prng import global_prng
 
-class ThreeWayDHCross(MatingProtocol):
+class TwoWayDHCross(
+        MatingProtocol,
+    ):
     """
-    Class implementing mating protocols for three-way DH crosses.
+    Class implementing mating protocols for two-way DH crosses.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
-            progeny_counter: int = 0, 
-            family_counter: int = 0, 
+            progeny_counter: Integral = 0, 
+            family_counter: Integral = 0, 
             rng: Optional[Union[Generator,RandomState]] = None, 
             **kwargs: dict
         ) -> None:
         """
-        Constructor for the concrete class ThreeWayDHCross.
+        Constructor for the concrete class TwoWayDHCross.
 
         Parameters
         ----------
         progeny_counter : Integral
             Progeny counter. This helps create progeny names.
         family_counter : Integral
             Family counter. This helps label groups of progenies as originating 
             from the same family.
-        rng : numpy.random.Generator, numpy.random.RandomState
+        rng : numpy.random.Generator, numpy.random.RandomState, None
             Random number source.
         kwargs : dict
             Additional keyword arguments.
         """
         # make assignments
         self.progeny_counter = progeny_counter
         self.family_counter = family_counter
         self.rng = rng
 
     ############################ Object Properties #############################
     @property
     def nparent(self) -> Integral:
         """Number of parents the mating protocol requires."""
-        return 3
+        return 2
     @nparent.setter
     def nparent(self, value: Integral) -> None:
         """Set number of parents the mating protocol requires."""
         error_readonly("nparent")
 
     @property
     def progeny_counter(self) -> Integral:
@@ -99,70 +109,70 @@
             nmating: Union[Integral,numpy.ndarray], 
             nprogeny: Union[Integral,numpy.ndarray], 
             miscout: Optional[dict] = None, 
             nself: Integral = 0, 
             **kwargs: dict
         ) -> DensePhasedGenotypeMatrix:
         """
-        Mate individuals according to a 3-way mate selection scheme.
+        Mate individuals according to a 2-way mate selection scheme, then create
+        doubled haploid (DH) progenies.
 
         Example crossing diagram::
 
-            sel = [R,F,M,...], nmating = 2, nprogeny = 2, nself = 2
-                                        pgmat
-                                          │                                 sel = [R,F,M,...]
-                                       Rx(FxM)
-                          ┌───────────────┴───────────────┐                 nmating = 2
-                       Rx(FxM)                         Rx(FxM)              duplicate cross 2x
-                          │                               │                 nself = 2
-                      S0(Rx(FxM))                     S0(Rx(FxM))           first self
-                          │                               │
-                      S1(Rx(FxM))                     S1(Rx(FxM))           second self
-                  ┌───────┴───────┐               ┌───────┴───────┐         DH, nprogeny = 2
-            DH(S1(Rx(FxM))) DH(S1(Rx(FxM))) DH(S1(Rx(FxM))) DH(S1(Rx(FxM))) final result
+                                 pgmat
+                                   │                        sel = [A,B,...]
+                                  AxB
+                       ┌───────────┴───────────┐            nmating = 2
+                      AxB                     AxB           duplicate cross 2x
+                       │                       │            nself = 2
+                    S0(AxB)                 S0(AxB)         first self
+                       │                       │
+                    S1(AxB)                 S1(AxB)         second self
+                 ┌─────┴─────┐           ┌─────┴─────┐      DH, nprogeny = 2
+            DH(S1(AxB)) DH(S1(AxB)) DH(S1(AxB)) DH(S1(AxB)) final result
 
         Parameters
         ----------
         pgmat : DensePhasedGenotypeMatrix
-            A GenotypeMatrix containing candidate breeding individuals.
+            A DensePhasedGenotypeMatrix containing candidate breeding
+            individuals.
         xconfig : numpy.ndarray
             Array of shape ``(ncross,nparent)`` containing indices specifying a cross
             configuration. Each index corresponds to an individual in ``pgmat``.
 
             Where:
 
             - ``ncross`` is the number of crosses to perform.
             - ``nparent`` is the number of parents required for a cross.
 
             Indices are paired as follows:
 
-            - First index is the recurrent parent.
-            - Second index is the female parent.
-            - Third index is the male parent.
+            - Even indices are female.
+            - Odd indices are male.
 
             Example::
 
-                xconfig = [[ 1, 5, 3 ],
-                           [ 8, 2, 7 ],
+                xconfig = [[ 1, 5 ],
+                           [ 3, 8 ],
+                           [ 2, 7 ],
                            ...,
-                           [ R, F, M ]]
-                recurrent = [1, 8, ..., R]
-                female = [5, 2, ..., F]
-                male = [3, 7, ..., M]
+                           [ F, M ]]
+                female = [1, 3, 2, ..., F]
+                male = [5, 8, 7, ..., M]
         nmating : numpy.ndarray
             Number of cross patterns to perform.
         nprogeny : numpy.ndarray
             Number of doubled haploid progeny to generate per cross.
         miscout : dict, None, default = None
             Pointer to a dictionary for miscellaneous user defined output.
-            If dict, write to dict (may overwrite previously defined fields).
-            If None, user defined output is not calculated or stored.
+            If ``dict``, write to dict (may overwrite previously defined fields).
+            If ``None``, user defined output is not calculated or stored.
         nself : int, default = 0
-            Number of selfing generations post-cross before double haploids are
-            generated.
+            Number of selfing generations post-cross pattern before 'nprogeny'
+            double haploids are generated.
         kwargs : dict
             Additional keyword arguments to be passed to constructor for the
             output DensePhasedGenotypeMatrix.
 
         Returns
         -------
         out : DensePhasedGenotypeMatrix
@@ -194,70 +204,65 @@
             check_is_dict(miscout, "miscout")
         
         # check nself
         check_is_Integral(nself, "nself")
 
         ########################################################################
         ########################## Progeny generation ##########################
-        # get recurrent, female, and male selections; repeat by ncross
-        rsel = numpy.repeat(xconfig[:,0], nmating)  # recurrent parent
-        fsel = numpy.repeat(xconfig[:,1], nmating)  # female parent
-        msel = numpy.repeat(xconfig[:,2], nmating)  # male parent
+        # get female and male selections; repeat by ncross
+        fsel = numpy.repeat(xconfig[:,0], nmating)
+        msel = numpy.repeat(xconfig[:,1], nmating)
 
         # get pointers to genotypes and crossover probabilities, respectively
         geno = pgmat.mat
         xoprob = pgmat.vrnt_xoprob
 
-        # create F1 genotypes
-        f1geno = mat_mate(geno, geno, fsel, msel, xoprob, self.rng)
+        # create hybrid genotypes
+        hgeno = mat_mate(geno, geno, fsel, msel, xoprob, self.rng)
 
         # generate selection array for all hybrid lines
-        hsel = numpy.arange(f1geno.shape[1])
-
-        # create backcross genotypes
-        bcgeno = mat_mate(geno, f1geno, rsel, hsel, xoprob, self.rng)
-
-        # generate selection array for all backcross lines
-        bcsel = numpy.arange(bcgeno.shape[1])
+        asel = numpy.arange(hgeno.shape[1])
 
         # self down hybrids if needed
         for i in range(nself):
-            # self backcross lines
-            bcgeno = mat_mate(bcgeno, bcgeno, bcsel, bcsel, xoprob, self.rng)
+            # self hybrids
+            hgeno = mat_mate(hgeno, hgeno, asel, asel, xoprob, self.rng)
 
-        # generate selection array for progeny
-        psel = numpy.repeat(
-            numpy.arange(bcgeno.shape[1]), 
+        # generate selection array for all hybrid lines
+        asel = numpy.repeat(
+            numpy.arange(hgeno.shape[1]), 
             numpy.repeat(nprogeny, nmating)
         )
 
         # generate doubled haploids
-        dhgeno = mat_dh(bcgeno, psel, xoprob, self.rng)
+        dhgeno = mat_dh(hgeno, asel, xoprob, self.rng)
 
         ########################################################################
         ######################### Metadata generation ##########################
         # generate line names
-        progcnt = dhgeno.shape[1]               # get number of hybrid progeny generated
+        progcnt = dhgeno.shape[1]               # get number of progeny generated
         riter = range(                          # range iterator for line names
             self.progeny_counter,               # start progeny number (inclusive)
             self.progeny_counter + progcnt      # stop progeny number (exclusive)
         )
-        # create taxa names
-        taxa = numpy.array(["dh"+str(i).zfill(7) for i in riter], dtype = "object")
+        taxa = numpy.array(                     # create taxa names
+            ["dh"+str(i).zfill(7) for i in riter],
+            dtype = object
+        )
         self.progeny_counter += progcnt         # increment counter
 
         # calculate taxa family groupings
         nfam = len(xconfig)                     # calculate number of families
         taxa_grp = numpy.repeat(                # construct taxa_grp
             numpy.repeat(                       # repeat for progeny
                 numpy.arange(                   # repeat for crosses
                     self.family_counter,        # start family number (inclusive)
                     self.family_counter + nfam, # stop family number (exclusive)
                     dtype = 'int64'
-                ),
+                ), 
                 nmating
             ), 
             numpy.repeat(nprogeny, nmating)
         )
         self.family_counter += nfam             # increment counter
 
         ########################################################################
@@ -287,20 +292,20 @@
         progeny.group_taxa()
 
         return progeny
 
 
 
 ################################## Utilities ###################################
-def check_is_ThreeWayDHCross(v: object, vname: str) -> None:
+def check_is_TwoWayDHCross(v: object, vname: str) -> None:
     """
-    Check if object is of type ThreeWayDHCross. Otherwise raise TypeError.
+    Check if object is of type TwoWayDHCross. Otherwise raise TypeError.
 
     Parameters
     ----------
     v : object
         Any Python object to test.
     vname : str
         Name of variable to print in TypeError message.
     """
-    if not isinstance(v, ThreeWayDHCross):
-        raise TypeError("variable '{0}' must be of type '{1}' but received type '{2}'".format(vname,ThreeWayDHCross.__name__,type(v).__name__))
+    if not isinstance(v, TwoWayDHCross):
+        raise TypeError("variable '{0}' must be of type '{1}' but received type '{2}'".format(vname,TwoWayDHCross.__name__,type(v).__name__))
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/mate/TwoWayCross.py` & `pybrops-1.0.3/pybrops/breed/prot/mate/SelfCross.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,41 +1,49 @@
 """
-Module implementing mating protocols for two-way crosses.
+Module implementing mating protocols for self-fertilization.
 """
 
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.breed.prot.mate.util import mat_mate
 from pybrops.breed.prot.mate.MatingProtocol import MatingProtocol
 from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
-from pybrops.core.error.error_attr_python import error_readonly
 from pybrops.core.error.error_type_numpy import check_is_ndarray
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_dict
-from pybrops.core.error.error_value_numpy import check_ndarray_axis_len, check_ndarray_ndim, check_ndarray_shape_eq
-from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import check_DensePhasedGenotypeMatrix_has_vrnt_xoprob, check_is_DensePhasedGenotypeMatrix
+from pybrops.core.error.error_attr_python import error_readonly
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_dict
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_shape_eq
 from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import DensePhasedGenotypeMatrix
+from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import check_DensePhasedGenotypeMatrix_has_vrnt_xoprob
+from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import check_is_DensePhasedGenotypeMatrix
 from pybrops.core.random.prng import global_prng
 
-class TwoWayCross(MatingProtocol):
+class SelfCross(
+        MatingProtocol,
+    ):
     """
-    Class implementing mating protocols for two-way crosses.
+    Class implementing mating protocols for self-fertilization.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             progeny_counter: Integral = 0, 
             family_counter: Integral = 0, 
             rng: Optional[Union[Generator,RandomState]] = None, 
             **kwargs: dict
         ) -> None:
         """
-        Constructor for the concrete class TwoWayCross.
+        Constructor for the concrete class SelfCross.
 
         Parameters
         ----------
         progeny_counter : Integral
             Progeny counter. This helps create progeny names.
         family_counter : Integral
             Family counter. This helps label groups of progenies as originating 
@@ -50,15 +58,15 @@
         self.family_counter = family_counter
         self.rng = rng
 
     ############################ Object Properties #############################
     @property
     def nparent(self) -> Integral:
         """Number of parents the mating protocol requires."""
-        return 2
+        return 1
     @nparent.setter
     def nparent(self, value: Integral) -> None:
         """Set number of parents the mating protocol requires."""
         error_readonly("nparent")
 
     @property
     def progeny_counter(self) -> Integral:
@@ -100,29 +108,29 @@
             nmating: Union[Integral,numpy.ndarray], 
             nprogeny: Union[Integral,numpy.ndarray], 
             miscout: Optional[dict] = None, 
             nself: Integral = 0, 
             **kwargs: dict
         ) -> DensePhasedGenotypeMatrix:
         """
-        Mate individuals according to a 2-way mate selection scheme.
+        Self-fertilize individuals.
 
         Example crossing diagram::
 
-                                pgmat
-                                │                       sel = [A,B,...]
-                               AxB
-                    ┌───────────┴───────────┐           nmating * nprogeny = 2
-                   AxB                     AxB          duplicate cross (nmating * nprogeny) times
-                    │                       │           nself = 2
-                S0(AxB)                 S0(AxB)         first self
-                    │                       │
-                S1(AxB)                 S1(AxB)         second self
-                    |                       |
-                S1(AxB)                 S1(AxB)         final result
+                     pgmat
+                       │                sel = [A,...]
+                       A
+                 ┌─────┴─────┐          nmating = 2
+                 A           A
+              ┌──┴──┐     ┌──┴──┐       initial self, nprogeny = 2
+            S0(A) S0(A) S0(A) S0(A)     cross pattern finished.
+              │     │     │     │       s = 2
+            S1(A) S1(A) S1(A) S1(A)     first self
+              │     │     │     │
+            S2(A) S2(A) S2(A) S2(A)     second self, final result
 
         Parameters
         ----------
         pgmat : DensePhasedGenotypeMatrix
             A DensePhasedGenotypeMatrix containing candidate breeding
             individuals.
         xconfig : numpy.ndarray
@@ -130,39 +138,36 @@
             configuration. Each index corresponds to an individual in ``pgmat``.
 
             Where:
 
             - ``ncross`` is the number of crosses to perform.
             - ``nparent`` is the number of parents required for a cross.
 
-            Indices are paired as follows:
+            Indices are organized as follows:
 
-            - Even indices are female.
-            - Odd indices are male.
+            - All indices are self parents.
 
             Example::
 
-                xconfig = [[ 1, 5 ],
-                           [ 3, 8 ],
-                           [ 2, 7 ],
+                xconfig = [[ 1 ],
+                           [ 3 ],
+                           [ 2 ],
                            ...,
-                           [ F, M ]]
-                female = [1, 3, 2, ..., F]
-                male = [5, 8, 7, ..., M]
+                           [ S ]]
+                self = [1, 3, 2, ..., S]
         ncross : numpy.ndarray
             Number of cross patterns to perform.
         nprogeny : numpy.ndarray
             Number of progeny to generate per cross.
         miscout : dict, None, default = None
             Pointer to a dictionary for miscellaneous user defined output.
             If ``dict``, write to dict (may overwrite previously defined fields).
             If ``None``, user defined output is not calculated or stored.
-        nself : int, default = 0
-            Number of selfing generations post-cross before progeny lines are
-            generated.
+        s : int, default = 0
+            Number of generations of single seed descent post-cross pattern.
         kwargs : dict
             Additional keyword arguments to be passed to constructor for the
             output DensePhasedGenotypeMatrix.
 
         Returns
         -------
         out : DensePhasedGenotypeMatrix
@@ -194,62 +199,61 @@
             check_is_dict(miscout, "miscout")
         
         # check nself
         check_is_Integral(nself, "nself")
 
         ########################################################################
         ########################## Progeny generation ##########################
-        # get female and male selections; repeat by nmating
-        fsel = numpy.repeat(xconfig[:,0], nmating * nprogeny)
-        msel = numpy.repeat(xconfig[:,1], nmating * nprogeny)
-
         # get pointers to genotypes and crossover probabilities, respectively
         geno = pgmat.mat
         xoprob = pgmat.vrnt_xoprob
 
-        # create hybrid genotypes
-        hgeno = mat_mate(geno, geno, fsel, msel, xoprob, self.rng)
+        # get female selections; repeat by ncross
+        fsel = numpy.repeat(xconfig[:,0], nmating * nprogeny)
+
+        # self genotypes
+        sgeno = mat_mate(geno, geno, fsel, fsel, xoprob, self.rng)
 
-        # generate selection array for all hybrid lines
-        asel = numpy.arange(hgeno.shape[1])
+        # generate selection array for all selfed lines
+        ssel = numpy.arange(sgeno.shape[1])
 
-        # self down hybrids if needed
+        # perform single seed descent
         for i in range(nself):
-            # self hybrids
-            hgeno = mat_mate(hgeno, hgeno, asel, asel, xoprob, self.rng)
+            # self lines
+            sgeno = mat_mate(sgeno, sgeno, ssel, ssel, xoprob, self.rng)
 
         ########################################################################
         ######################### Metadata generation ##########################
         # generate line names
-        progcnt = hgeno.shape[1]                # get number of hybrid progeny generated
+        progcnt = sgeno.shape[1]                # get number of self progeny generated
         riter = range(                          # range iterator for line names
             self.progeny_counter,               # start progeny number (inclusive)
             self.progeny_counter + progcnt      # stop progeny number (exclusive)
         )
         # create taxa names
-        taxa = numpy.array(["2w"+str(i).zfill(7) for i in riter], dtype = "object")
+        taxa = numpy.array(["sx"+str(i).zfill(7) for i in riter], dtype = "object")
         self.progeny_counter += progcnt         # increment counter
 
         # calculate taxa family groupings
         nfam = len(xconfig)                     # calculate number of families
-        taxa_grp = numpy.repeat(                # construct taxa_grp vector
-            numpy.arange(                       # repeat for crosses * progeny
+        taxa_grp = numpy.repeat(                # repeat for mating * progeny
+            numpy.arange(                       # repeat for crosses
                 self.family_counter,            # start family number (inclusive)
                 self.family_counter + nfam,     # stop family number (exclusive)
                 dtype = 'int64'
             ),
             nmating * nprogeny
         )
         self.family_counter += nfam             # increment counter
-        
+
         ########################################################################
         ########################## Output generation ###########################
         # create new DensePhasedGenotypeMatrix
         progeny = DensePhasedGenotypeMatrix(
-            mat = hgeno,
+            mat = sgeno,
             taxa = taxa,
             taxa_grp = taxa_grp,
             vrnt_chrgrp = pgmat.vrnt_chrgrp,
             vrnt_phypos = pgmat.vrnt_phypos,
             vrnt_name = pgmat.vrnt_name,
             vrnt_genpos = pgmat.vrnt_genpos,
             vrnt_xoprob = pgmat.vrnt_xoprob,
@@ -268,20 +272,20 @@
         progeny.group_taxa()
 
         return progeny
 
 
 
 ################################## Utilities ###################################
-def check_is_TwoWayCross(v: object, vname: str) -> None:
+def check_is_SelfCross(v: object, vname: str) -> None:
     """
-    Check if object is of type TwoWayCross. Otherwise raise TypeError.
+    Check if object is of type SelfCross. Otherwise raise TypeError.
 
     Parameters
     ----------
     v : object
         Any Python object to test.
     vname : str
         Name of variable to print in TypeError message.
     """
-    if not isinstance(v, TwoWayCross):
-        raise TypeError("'%s' must be a TwoWayCross." % vname)
+    if not isinstance(v, SelfCross):
+        raise TypeError("'%s' must be a SelfCross." % vname)
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/mate/TwoWayDHCross.py` & `pybrops-1.0.3/pybrops/breed/prot/mate/FourWayDHCross.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,84 +1,96 @@
 """
-Module implementing mating protocols for three-way DH crosses.
+Module implementing mating protocols for four-way DH crosses.
 """
 
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.breed.prot.mate.util import mat_dh
 from pybrops.breed.prot.mate.util import mat_mate
 from pybrops.breed.prot.mate.MatingProtocol import MatingProtocol
-from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState, check_is_ndarray
+from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
+from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_attr_python import error_readonly
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_dict
-from pybrops.core.error.error_value_numpy import check_ndarray_axis_len, check_ndarray_ndim, check_ndarray_shape_eq
-from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import DensePhasedGenotypeMatrix, check_DensePhasedGenotypeMatrix_has_vrnt_xoprob, check_is_DensePhasedGenotypeMatrix
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_dict
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_shape_eq
+from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import DensePhasedGenotypeMatrix
+from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import check_DensePhasedGenotypeMatrix_has_vrnt_xoprob
+from pybrops.popgen.gmat.DensePhasedGenotypeMatrix import check_is_DensePhasedGenotypeMatrix
 from pybrops.core.random.prng import global_prng
 
-class TwoWayDHCross(MatingProtocol):
+class FourWayDHCross(
+        MatingProtocol,
+    ):
     """
-    Class implementing mating protocols for two-way DH crosses.
+    Class implementing mating protocols for four-way DH crosses.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             progeny_counter: Integral = 0, 
             family_counter: Integral = 0, 
-            rng: Optional[Union[Generator,RandomState]] = None, 
+            rng: Union[Generator,RandomState,None] = global_prng, 
             **kwargs: dict
         ) -> None:
         """
-        Constructor for the concrete class TwoWayDHCross.
+        Constructor for the concrete class FourWayDHCross.
 
         Parameters
         ----------
         progeny_counter : Integral
             Progeny counter. This helps create progeny names.
         family_counter : Integral
             Family counter. This helps label groups of progenies as originating 
             from the same family.
-        rng : numpy.random.Generator, numpy.random.RandomState, None
+        rng : numpy.random.Generator, numpy.random.RandomState
             Random number source.
         kwargs : dict
             Additional keyword arguments.
         """
+        super(FourWayDHCross, self).__init__(**kwargs)
+
         # make assignments
         self.progeny_counter = progeny_counter
         self.family_counter = family_counter
         self.rng = rng
 
     ############################ Object Properties #############################
     @property
     def nparent(self) -> Integral:
         """Number of parents the mating protocol requires."""
-        return 2
+        return 4
     @nparent.setter
     def nparent(self, value: Integral) -> None:
         """Set number of parents the mating protocol requires."""
         error_readonly("nparent")
 
     @property
-    def progeny_counter(self) -> Integral:
+    def progeny_counter(self) -> int:
         """Description for property progeny_counter."""
         return self._progeny_counter
     @progeny_counter.setter
-    def progeny_counter(self, value: Integral) -> None:
+    def progeny_counter(self, value: int) -> None:
         """Set data for property progeny_counter."""
         check_is_Integral(value, "progeny_counter")
         self._progeny_counter = value
 
     @property
-    def family_counter(self) -> Integral:
+    def family_counter(self) -> int:
         """Description for property family_counter."""
         return self._family_counter
     @family_counter.setter
-    def family_counter(self, value: Integral) -> None:
+    def family_counter(self, value: int) -> None:
         """Set data for property family_counter."""
         check_is_Integral(value, "family_counter")
         self._family_counter = value
 
     @property
     def rng(self) -> Union[Generator,RandomState]:
         """Random number generator."""
@@ -99,70 +111,72 @@
             nmating: Union[Integral,numpy.ndarray], 
             nprogeny: Union[Integral,numpy.ndarray], 
             miscout: Optional[dict] = None, 
             nself: Integral = 0, 
             **kwargs: dict
         ) -> DensePhasedGenotypeMatrix:
         """
-        Mate individuals according to a 2-way mate selection scheme, then create
-        doubled haploid (DH) progenies.
+        Mate individuals according to a 4-way mate selection scheme.
 
         Example crossing diagram::
 
-                                 pgmat
-                                   │                        sel = [A,B,...]
-                                  AxB
-                       ┌───────────┴───────────┐            nmating = 2
-                      AxB                     AxB           duplicate cross 2x
-                       │                       │            nself = 2
-                    S0(AxB)                 S0(AxB)         first self
-                       │                       │
-                    S1(AxB)                 S1(AxB)         second self
-                 ┌─────┴─────┐           ┌─────┴─────┐      DH, nprogeny = 2
-            DH(S1(AxB)) DH(S1(AxB)) DH(S1(AxB)) DH(S1(AxB)) final result
+            sel = [F2,M2,F1,M1,...], ncross = 2, nprogeny = 2, nself = 2
+                                                 pgmat
+                                                   │                        sel = [F2,M2,F1,M1,...]
+                                            (F2xM2)x(F1xM1)
+                                   ┌───────────────┴───────────────┐        ncross = 2
+                            (F2xM2)x(F1xM1)                       ...       duplicate cross 2x
+                                   │                               │        nself = 2
+                          S0((F2xM2)x(F1xM1))                     ...       first self
+                                   │                               │
+                          S1((F2xM2)x(F1xM1))                     ...       second self
+                       ┌───────────┴───────────┐               ┌───┴───┐    DH, nprogeny = 2
+            DH(S1((F2xM2)x(F1xM1))) DH(S1((F2xM2)x(F1xM1)))   ...     ...   final result
 
         Parameters
         ----------
         pgmat : DensePhasedGenotypeMatrix
-            A DensePhasedGenotypeMatrix containing candidate breeding
-            individuals.
+            A GenotypeMatrix containing candidate breeding individuals.
         xconfig : numpy.ndarray
             Array of shape ``(ncross,nparent)`` containing indices specifying a cross
             configuration. Each index corresponds to an individual in ``pgmat``.
 
             Where:
 
             - ``ncross`` is the number of crosses to perform.
             - ``nparent`` is the number of parents required for a cross.
 
             Indices are paired as follows:
 
-            - Even indices are female.
-            - Odd indices are male.
+            - First index is the female parent 2.
+            - Second index is the male parent 2.
+            - Third index is the female parent 1.
+            - Fourth index is the male parent 1.
 
             Example::
 
-                xconfig = [[ 1, 5 ],
-                           [ 3, 8 ],
-                           [ 2, 7 ],
+                xconfig = [[ 1, 5, 3, 8 ],
+                           [ 2, 7, 0, 4 ],
                            ...,
-                           [ F, M ]]
-                female = [1, 3, 2, ..., F]
-                male = [5, 8, 7, ..., M]
+                           [ F2, M2, F1, M1 ]]
+                female2 = [1, 2, ..., F2]
+                male2 = [5, 7, ..., M2]
+                female1 = [3, 0, ..., F1]
+                male1 = [8, 4, ..., M1]
         nmating : numpy.ndarray
             Number of cross patterns to perform.
         nprogeny : numpy.ndarray
             Number of doubled haploid progeny to generate per cross.
         miscout : dict, None, default = None
             Pointer to a dictionary for miscellaneous user defined output.
             If ``dict``, write to dict (may overwrite previously defined fields).
             If ``None``, user defined output is not calculated or stored.
         nself : int, default = 0
-            Number of selfing generations post-cross pattern before 'nprogeny'
-            double haploids are generated.
+            Number of selfing generations post-cross before double haploids are
+            generated.
         kwargs : dict
             Additional keyword arguments to be passed to constructor for the
             output DensePhasedGenotypeMatrix.
 
         Returns
         -------
         out : DensePhasedGenotypeMatrix
@@ -194,65 +208,73 @@
             check_is_dict(miscout, "miscout")
         
         # check nself
         check_is_Integral(nself, "nself")
 
         ########################################################################
         ########################## Progeny generation ##########################
-        # get female and male selections; repeat by ncross
-        fsel = numpy.repeat(xconfig[:,0], nmating)
-        msel = numpy.repeat(xconfig[:,1], nmating)
+        # get female2, male2, female1, and male1 selections; repeat by nmating
+        f2sel = numpy.repeat(xconfig[:,0], nmating)
+        m2sel = numpy.repeat(xconfig[:,1], nmating)
+        f1sel = numpy.repeat(xconfig[:,2], nmating)
+        m1sel = numpy.repeat(xconfig[:,3], nmating)
 
         # get pointers to genotypes and crossover probabilities, respectively
         geno = pgmat.mat
         xoprob = pgmat.vrnt_xoprob
 
-        # create hybrid genotypes
-        hgeno = mat_mate(geno, geno, fsel, msel, xoprob, self.rng)
+        # create F1 genotypes
+        abgeno = mat_mate(geno, geno, f1sel, m1sel, xoprob, self.rng)
+        cdgeno = mat_mate(geno, geno, f2sel, m2sel, xoprob, self.rng)
+
+        # generate selection array for hybrid lines
+        absel = numpy.arange(abgeno.shape[1])
+        cdsel = numpy.arange(cdgeno.shape[1])
+
+        # generate dihybrid cross
+        dihgeno = mat_mate(abgeno, cdgeno, absel, cdsel, xoprob, self.rng)
 
-        # generate selection array for all hybrid lines
-        asel = numpy.arange(hgeno.shape[1])
+        # generate selection array for dihybrid lines
+        dihsel = numpy.arange(dihgeno.shape[1])
 
         # self down hybrids if needed
         for i in range(nself):
             # self hybrids
-            hgeno = mat_mate(hgeno, hgeno, asel, asel, xoprob, self.rng)
+            dihgeno = mat_mate(dihgeno, dihgeno, dihsel, dihsel, xoprob, self.rng)
 
-        # generate selection array for all hybrid lines
-        asel = numpy.repeat(
-            numpy.arange(hgeno.shape[1]), 
+        # generate selection array for progeny
+        psel = numpy.repeat(
+            numpy.arange(dihgeno.shape[1]), 
             numpy.repeat(nprogeny, nmating)
         )
 
         # generate doubled haploids
-        dhgeno = mat_dh(hgeno, asel, xoprob, self.rng)
+        dhgeno = mat_dh(dihgeno, psel, xoprob, self.rng)
 
         ########################################################################
         ######################### Metadata generation ##########################
         # generate line names
-        progcnt = dhgeno.shape[1]               # get number of progeny generated
+        progcnt = dhgeno.shape[1]               # get number of hybrid progeny generated
         riter = range(                          # range iterator for line names
             self.progeny_counter,               # start progeny number (inclusive)
             self.progeny_counter + progcnt      # stop progeny number (exclusive)
         )
-        taxa = numpy.array(                     # create taxa names
-            ["dh"+str(i).zfill(7) for i in riter],
-            dtype = object
-        )
+        # create taxa names
+        taxa = numpy.array(["dh"+str(i).zfill(7) for i in riter], dtype = "object")
         self.progeny_counter += progcnt         # increment counter
 
         # calculate taxa family groupings
         nfam = len(xconfig)                     # calculate number of families
         taxa_grp = numpy.repeat(                # construct taxa_grp
             numpy.repeat(                       # repeat for progeny
                 numpy.arange(                   # repeat for crosses
                     self.family_counter,        # start family number (inclusive)
                     self.family_counter + nfam, # stop family number (exclusive)
                     dtype = 'int64'
-                ), 
+                ),
                 nmating
             ), 
             numpy.repeat(nprogeny, nmating)
         )
         self.family_counter += nfam             # increment counter
 
         ########################################################################
@@ -282,20 +304,20 @@
         progeny.group_taxa()
 
         return progeny
 
 
 
 ################################## Utilities ###################################
-def check_is_TwoWayDHCross(v: object, vname: str) -> None:
+def check_is_FourWayDHCross(v: object, vname: str) -> None:
     """
-    Check if object is of type TwoWayDHCross. Otherwise raise TypeError.
+    Check if object is of type FourWayDHCross. Otherwise raise TypeError.
 
     Parameters
     ----------
     v : object
         Any Python object to test.
     vname : str
         Name of variable to print in TypeError message.
     """
-    if not isinstance(v, TwoWayDHCross):
-        raise TypeError("variable '{0}' must be of type '{1}' but received type '{2}'".format(vname,TwoWayDHCross.__name__,type(v).__name__))
+    if not isinstance(v, FourWayDHCross):
+        raise TypeError("'%s' must be a FourWayDHCross." % vname)
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/mate/__init__.py` & `pybrops-1.0.3/pybrops/breed/prot/mate/__init__.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/breed/prot/mate/util.py` & `pybrops-1.0.3/pybrops/breed/prot/mate/util.py`

 * *Files 2% similar despite different names*

```diff
@@ -23,15 +23,15 @@
     Parameters
     ----------
     geno : numpy.ndarray
         Genotype matrix.
     sel : numpy.ndarray
         Selection configuration array.
     xoprob : numpy.ndarray
-        Crossover porbability array.
+        Crossover probability array.
     rng : numpy.random.Generator, numpy.random.RandomState
         Random number generator instance
 
     Returns
     -------
     gamete : numpy.ndarray
         Genotype matrix of gametes.
@@ -84,15 +84,15 @@
     Parameters
     ----------
     geno : numpy.ndarray
         Genotype matrix.
     sel : numpy.ndarray
         Selection configuration array.
     xoprob : numpy.ndarray
-        Crossover porbability array.
+        Crossover probability array.
     rng : numpy.random.Generator, numpy.random.RandomState
         Random number generator instance
 
     Returns
     -------
     progeny : numpy.ndarray
         Genotype matrix of progenies.
@@ -123,15 +123,15 @@
     mgeno : numpy.ndarray
         Male genotype matrix.
     fsel : numpy.ndarray
         Female selection configuration array.
     msel : numpy.ndarray
         Male selection configuration array.
     xoprob : numpy.ndarray
-        Crossover porbability array.
+        Crossover probability array.
     rng : numpy.random.Generator, numpy.random.RandomState
         Random number generator instance
 
     Returns
     -------
     progeny : numpy.ndarray
         Genotype matrix of progenies.
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/pt/PhenotypingProtocol.py` & `pybrops-1.0.3/pybrops/breed/prot/pt/PhenotypingProtocol.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,20 +1,32 @@
 """
 Module defining interfaces and associated protocols for phenotyping protocols.
 """
 
-from abc import ABCMeta, abstractmethod
+__all__ = [
+    "PhenotypingProtocol",
+    "check_is_PhenotypingProtocol",
+]
+
+from abc import ABCMeta
+from abc import abstractmethod
 from numbers import Real
 from typing import Union
 import numpy
 import pandas
+from pybrops.core.io.Copyable import Copyable
+from pybrops.core.io.HDF5InputOutput import HDF5InputOutput
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
-class PhenotypingProtocol(metaclass=ABCMeta):
+class PhenotypingProtocol(
+        Copyable,
+        HDF5InputOutput,
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class defining interfaces for phenotyping protocols.
 
     The purpose of this abstract class is to provide functionality for:
         1) Genomic model metadata.
         2) Phenotype simulation.
         3) Manipulation and setting of environmental variance metadata.
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/BinaryMateSelectionProtocol.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/BinaryMateSelectionProtocol.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,15 +3,16 @@
 """
 
 __all__ = [
     "BinaryMateSelectionProtocol",
     "check_is_BinaryMateSelectionProtocol",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from numbers import Integral
 from typing import Optional
 
 import pandas
 
 from pybrops.breed.prot.sel.BinarySelectionProtocol import BinarySelectionProtocol
 from pybrops.breed.prot.sel.MateSelectionProtocol import MateSelectionProtocol
@@ -20,15 +21,19 @@
 from pybrops.breed.prot.sel.soln.BinaryMateSelectionSolution import BinaryMateSelectionSolution
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class BinaryMateSelectionProtocol(BinarySelectionProtocol,MateSelectionProtocol,metaclass=ABCMeta):
+class BinaryMateSelectionProtocol(
+        BinarySelectionProtocol,
+        MateSelectionProtocol,
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for creating binary selection protocols.
     """
     ########################## Special Object Methods ##########################
     # inherit __init__ from BinarySelectionProtocol
 
     ############################ Object Properties #############################
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/BinarySelectionProtocol.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/BinarySelectionProtocol.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,36 +3,44 @@
 """
 
 __all__ = [
     "BinarySelectionProtocol",
     "check_is_BinarySelectionProtocol",
 ]
 
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
-
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
 from pybrops.breed.prot.sel.SelectionProtocol import SelectionProtocol
 from pybrops.breed.prot.sel.cfg.BinarySelectionConfiguration import BinarySelectionConfiguration
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
 from pybrops.breed.prot.sel.soln.BinarySelectionSolution import BinarySelectionSolution
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.opt.algo.NSGA2BinaryGeneticAlgorithm import NSGA2BinaryGeneticAlgorithm
 from pybrops.opt.algo.BinaryGeneticAlgorithm import BinaryGeneticAlgorithm
-from pybrops.opt.algo.BinaryOptimizationAlgorithm import BinaryOptimizationAlgorithm, check_is_BinaryOptimizationAlgorithm
+from pybrops.opt.algo.BinaryOptimizationAlgorithm import BinaryOptimizationAlgorithm
+from pybrops.opt.algo.BinaryOptimizationAlgorithm import check_is_BinaryOptimizationAlgorithm
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class BinarySelectionProtocol(SelectionProtocol,metaclass=ABCMeta):
+class BinarySelectionProtocol(
+        SelectionProtocol,
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for creating binary selection protocols.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ncross: Integral,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/EstimatedBreedingValueSelection.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/EstimatedBreedingValueSelection.py`

 * *Files 0% similar despite different names*

```diff
@@ -9,45 +9,53 @@
     "EstimatedBreedingValueIntegerSelection",
     "EstimatedBreedingValueRealSelection",
     "EstimatedBreedingValueSubsetSelection",
 ]
 
 # imports
 from abc import ABCMeta
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
 from pybrops.breed.prot.sel.BinarySelectionProtocol import BinarySelectionProtocol
 from pybrops.breed.prot.sel.IntegerSelectionProtocol import IntegerSelectionProtocol
 from pybrops.breed.prot.sel.RealSelectionProtocol import RealSelectionProtocol
 from pybrops.breed.prot.sel.SubsetSelectionProtocol import SubsetSelectionProtocol
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
 from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_bool
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_bool
 from pybrops.breed.prot.sel.prob.EstimatedBreedingValueSelectionProblem import EstimatedBreedingValueBinarySelectionProblem
 from pybrops.breed.prot.sel.prob.EstimatedBreedingValueSelectionProblem import EstimatedBreedingValueIntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.EstimatedBreedingValueSelectionProblem import EstimatedBreedingValueRealSelectionProblem
 from pybrops.breed.prot.sel.prob.EstimatedBreedingValueSelectionProblem import EstimatedBreedingValueSubsetSelectionProblem
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.opt.algo.BinaryOptimizationAlgorithm import BinaryOptimizationAlgorithm
 from pybrops.opt.algo.IntegerOptimizationAlgorithm import IntegerOptimizationAlgorithm
 from pybrops.opt.algo.RealOptimizationAlgorithm import RealOptimizationAlgorithm
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
-from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix, check_is_BreedingValueMatrix
+from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
+from pybrops.popgen.bvmat.BreedingValueMatrix import check_is_BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
-class EstimatedBreedingValueSelectionMixin(metaclass=ABCMeta):
+class EstimatedBreedingValueSelectionMixin(
+        metaclass = ABCMeta,
+    ):
     """
     Mixin class to provide properties common to all Estimated Breeding Value Selection protocols.
     """
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
@@ -69,15 +77,18 @@
         return self._unscale
     @unscale.setter
     def unscale(self, value: bool) -> None:
         """Set whether to unscale and uncenter breeding values."""
         check_is_bool(value, "unscale")
         self._unscale = value
 
-class EstimatedBreedingValueBinarySelection(EstimatedBreedingValueSelectionMixin,BinarySelectionProtocol):
+class EstimatedBreedingValueBinarySelection(
+        EstimatedBreedingValueSelectionMixin,
+        BinarySelectionProtocol,
+    ):
     """
     Estimated Breeding Value Selection in a subset search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ntrait: Integral,
@@ -481,15 +492,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from BinarySelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from BinarySelectionProtocol
 
-class EstimatedBreedingValueIntegerSelection(EstimatedBreedingValueSelectionMixin,IntegerSelectionProtocol):
+class EstimatedBreedingValueIntegerSelection(
+        EstimatedBreedingValueSelectionMixin,
+        IntegerSelectionProtocol,
+    ):
     """
     Estimated Breeding Value Selection in an integer search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ntrait: Integral,
@@ -890,15 +904,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from IntegerSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from IntegerSelectionProtocol
 
-class EstimatedBreedingValueRealSelection(EstimatedBreedingValueSelectionMixin,RealSelectionProtocol):
+class EstimatedBreedingValueRealSelection(
+        EstimatedBreedingValueSelectionMixin,
+        RealSelectionProtocol,
+    ):
     """
     Estimated Breeding Value Selection in a real search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ntrait: Integral,
@@ -1299,15 +1316,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from RealSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from RealSelectionProtocol
 
-class EstimatedBreedingValueSubsetSelection(EstimatedBreedingValueSelectionMixin,SubsetSelectionProtocol):
+class EstimatedBreedingValueSubsetSelection(
+        EstimatedBreedingValueSelectionMixin,
+        SubsetSelectionProtocol,
+    ):
     """
     Estimated Breeding Value Selection in a subset search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ntrait: Integral,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/ExpectedMaximumBreedingValueSelection.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/ExpectedMaximumBreedingValueSelection.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,47 +7,55 @@
     "ExpectedMaximumBreedingValueBinarySelection",
     "ExpectedMaximumBreedingValueIntegerSelection",
     "ExpectedMaximumBreedingValueRealSelection",
     "ExpectedMaximumBreedingValueSubsetSelection",
 ]
 
 from abc import ABCMeta
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
-from pybrops.breed.prot.mate.MatingProtocol import MatingProtocol, check_is_MatingProtocol
-from pybrops.breed.prot.sel.BinarySelectionProtocol import BinarySelectionProtocol
-from pybrops.breed.prot.sel.IntegerSelectionProtocol import IntegerSelectionProtocol
-from pybrops.breed.prot.sel.RealSelectionProtocol import RealSelectionProtocol
-from pybrops.breed.prot.sel.SubsetSelectionProtocol import SubsetSelectionProtocol
+from pybrops.breed.prot.mate.MatingProtocol import MatingProtocol
+from pybrops.breed.prot.mate.MatingProtocol import check_is_MatingProtocol
+from pybrops.breed.prot.sel.BinaryMateSelectionProtocol import BinaryMateSelectionProtocol
+from pybrops.breed.prot.sel.IntegerMateSelectionProtocol import IntegerMateSelectionProtocol
+from pybrops.breed.prot.sel.RealMateSelectionProtocol import RealMateSelectionProtocol
+from pybrops.breed.prot.sel.SubsetMateSelectionProtocol import SubsetMateSelectionProtocol
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
 from pybrops.breed.prot.sel.prob.ExpectedMaximumBreedingValueSelectionProblem import ExpectedMaximumBreedingValueBinarySelectionProblem
 from pybrops.breed.prot.sel.prob.ExpectedMaximumBreedingValueSelectionProblem import ExpectedMaximumBreedingValueIntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.ExpectedMaximumBreedingValueSelectionProblem import ExpectedMaximumBreedingValueRealSelectionProblem
 from pybrops.breed.prot.sel.prob.ExpectedMaximumBreedingValueSelectionProblem import ExpectedMaximumBreedingValueSubsetSelectionProblem
 from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_bool
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_bool
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.opt.algo.BinaryOptimizationAlgorithm import BinaryOptimizationAlgorithm
 from pybrops.opt.algo.IntegerOptimizationAlgorithm import IntegerOptimizationAlgorithm
 from pybrops.opt.algo.RealOptimizationAlgorithm import RealOptimizationAlgorithm
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class ExpectedMaximumBreedingValueSelectionMixin(metaclass=ABCMeta):
+class ExpectedMaximumBreedingValueSelectionMixin(
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for Expected Maximum Breeding Value (EMBV) selection with constraints.
     """
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
@@ -90,15 +98,18 @@
         return self._unique_parents
     @unique_parents.setter
     def unique_parents(self, value: bool) -> None:
         """Set whether parents should be unique."""
         check_is_bool(value, "unique_parents")
         self._unique_parents = value
 
-class ExpectedMaximumBreedingValueBinarySelection(ExpectedMaximumBreedingValueSelectionMixin,BinarySelectionProtocol):
+class ExpectedMaximumBreedingValueBinarySelection(
+        ExpectedMaximumBreedingValueSelectionMixin,
+        BinaryMateSelectionProtocol,
+    ):
     """
     Expected Maximum Breeding Value (EMBV) Selection in a subset search space.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -524,15 +535,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from BinarySelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from BinarySelectionProtocol
 
-class ExpectedMaximumBreedingValueIntegerSelection(ExpectedMaximumBreedingValueSelectionMixin,IntegerSelectionProtocol):
+class ExpectedMaximumBreedingValueIntegerSelection(
+        ExpectedMaximumBreedingValueSelectionMixin,
+        IntegerMateSelectionProtocol,
+    ):
     """
     Expected Maximum Breeding Value (EMBV) Selection in a subset search space.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -958,15 +972,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from IntegerSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from IntegerSelectionProtocol
 
-class ExpectedMaximumBreedingValueRealSelection(ExpectedMaximumBreedingValueSelectionMixin,RealSelectionProtocol):
+class ExpectedMaximumBreedingValueRealSelection(
+        ExpectedMaximumBreedingValueSelectionMixin,
+        RealMateSelectionProtocol,
+    ):
     """
     Expected Maximum Breeding Value (EMBV) Selection in a subset search space.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -1392,15 +1409,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from RealSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from RealSelectionProtocol
 
-class ExpectedMaximumBreedingValueSubsetSelection(ExpectedMaximumBreedingValueSelectionMixin,SubsetSelectionProtocol):
+class ExpectedMaximumBreedingValueSubsetSelection(
+        ExpectedMaximumBreedingValueSelectionMixin,
+        SubsetMateSelectionProtocol,
+    ):
     """
     Expected Maximum Breeding Value (EMBV) Selection in a subset search space.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/FamilyEstimatedBreedingValueSelection.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/FamilyEstimatedBreedingValueSelection.py`

 * *Files 0% similar despite different names*

```diff
@@ -9,19 +9,23 @@
     "FamilyEstimatedBreedingValueIntegerSelection",
     "FamilyEstimatedBreedingValueRealSelection",
     "FamilyEstimatedBreedingValueSubsetSelection",
 ]
 
 # imports
 from abc import ABCMeta
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
 from pybrops.breed.prot.sel.BinarySelectionProtocol import BinarySelectionProtocol
 from pybrops.breed.prot.sel.IntegerSelectionProtocol import IntegerSelectionProtocol
 from pybrops.breed.prot.sel.RealSelectionProtocol import RealSelectionProtocol
 from pybrops.breed.prot.sel.SubsetSelectionProtocol import SubsetSelectionProtocol
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
@@ -39,15 +43,17 @@
 from pybrops.opt.algo.IntegerOptimizationAlgorithm import IntegerOptimizationAlgorithm
 from pybrops.opt.algo.RealOptimizationAlgorithm import RealOptimizationAlgorithm
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
-class FamilyEstimatedBreedingValueSelectionMixin(metaclass=ABCMeta):
+class FamilyEstimatedBreedingValueSelectionMixin(
+        metaclass = ABCMeta,
+    ):
     """
     Semiabstract class for Within-family Estimated Breeding Value Selection with constraints.
     """
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
@@ -58,15 +64,18 @@
     @ntrait.setter
     def ntrait(self, value: Integral) -> None:
         """Set number of traits to expect."""
         check_is_Integral(value, "ntrait")
         check_is_gt(value, "ntrait", 0)
         self._ntrait = value
 
-class FamilyEstimatedBreedingValueBinarySelection(FamilyEstimatedBreedingValueSelectionMixin,BinarySelectionProtocol):
+class FamilyEstimatedBreedingValueBinarySelection(
+        FamilyEstimatedBreedingValueSelectionMixin,
+        BinarySelectionProtocol,
+    ):
     """
     Within-family Estimated Breeding Value Selection in a subset search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ntrait: Integral,
@@ -459,15 +468,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from BinarySelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from BinarySelectionProtocol
 
-class FamilyEstimatedBreedingValueIntegerSelection(FamilyEstimatedBreedingValueSelectionMixin,IntegerSelectionProtocol):
+class FamilyEstimatedBreedingValueIntegerSelection(
+        FamilyEstimatedBreedingValueSelectionMixin,
+        IntegerSelectionProtocol,
+    ):
     """
     Within-family Estimated Breeding Value Selection in an integer search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ntrait: Integral,
@@ -860,15 +872,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from IntegerSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from IntegerSelectionProtocol
 
-class FamilyEstimatedBreedingValueRealSelection(FamilyEstimatedBreedingValueSelectionMixin,RealSelectionProtocol):
+class FamilyEstimatedBreedingValueRealSelection(
+        FamilyEstimatedBreedingValueSelectionMixin,
+        RealSelectionProtocol,
+    ):
     """
     Within-family Estimated Breeding Value Selection in a real search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ntrait: Integral,
@@ -1261,15 +1276,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from RealSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from RealSelectionProtocol
 
-class FamilyEstimatedBreedingValueSubsetSelection(FamilyEstimatedBreedingValueSelectionMixin,SubsetSelectionProtocol):
+class FamilyEstimatedBreedingValueSubsetSelection(
+        FamilyEstimatedBreedingValueSelectionMixin,
+        SubsetSelectionProtocol,
+    ):
     """
     Within-family Estimated Breeding Value Selection in a subset search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ntrait: Integral,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/GeneralizedWeightedGenomicEstimatedBreedingValueSelection.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/GeneralizedWeightedGenomicEstimatedBreedingValueSelection.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,46 +9,54 @@
     "GeneralizedWeightedGenomicEstimatedBreedingValueIntegerSelection",
     "GeneralizedWeightedGenomicEstimatedBreedingValueRealSelection",
     "GeneralizedWeightedGenomicEstimatedBreedingValueSubsetSelection",
 ]
 
 # imports
 from abc import ABCMeta
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
 from pybrops.breed.prot.sel.BinarySelectionProtocol import BinarySelectionProtocol
 from pybrops.breed.prot.sel.IntegerSelectionProtocol import IntegerSelectionProtocol
 from pybrops.breed.prot.sel.RealSelectionProtocol import RealSelectionProtocol
 from pybrops.breed.prot.sel.SubsetSelectionProtocol import SubsetSelectionProtocol
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
 from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_Real
-from pybrops.core.error.error_value_python import check_is_gt, check_is_in_interval_inclusive
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_Real
+from pybrops.core.error.error_value_python import check_is_gt
+from pybrops.core.error.error_value_python import check_is_in_interval_inclusive
 from pybrops.breed.prot.sel.prob.GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblem import GeneralizedWeightedGenomicEstimatedBreedingValueBinarySelectionProblem
 from pybrops.breed.prot.sel.prob.GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblem import GeneralizedWeightedGenomicEstimatedBreedingValueIntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblem import GeneralizedWeightedGenomicEstimatedBreedingValueRealSelectionProblem
 from pybrops.breed.prot.sel.prob.GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblem import GeneralizedWeightedGenomicEstimatedBreedingValueSubsetSelectionProblem
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.opt.algo.BinaryOptimizationAlgorithm import BinaryOptimizationAlgorithm
 from pybrops.opt.algo.IntegerOptimizationAlgorithm import IntegerOptimizationAlgorithm
 from pybrops.opt.algo.RealOptimizationAlgorithm import RealOptimizationAlgorithm
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
-class GeneralizedWeightedGenomicEstimatedBreedingValueSelectionMixin(metaclass=ABCMeta):
+class GeneralizedWeightedGenomicEstimatedBreedingValueSelectionMixin(
+        metaclass = ABCMeta,
+    ):
     """
     Semiabstract class for Generalized Weighted Genomic Estimated Breeding Value (gwGEBV) 
     selection with constraints.
     """
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
@@ -72,15 +80,18 @@
     @alpha.setter
     def alpha(self, value: Real) -> None:
         """Set exponent with which to adjust allele values. Must be in range [0,1]."""
         check_is_Real(value, "alpha")
         check_is_in_interval_inclusive(value, "alpha", 0.0, 1.0)
         self._alpha = value
 
-class GeneralizedWeightedGenomicEstimatedBreedingValueBinarySelection(GeneralizedWeightedGenomicEstimatedBreedingValueSelectionMixin,BinarySelectionProtocol):
+class GeneralizedWeightedGenomicEstimatedBreedingValueBinarySelection(
+        GeneralizedWeightedGenomicEstimatedBreedingValueSelectionMixin,
+        BinarySelectionProtocol,
+    ):
     """
     Generalized Weighted Genomic Estiamted Breeding Value Selection in a subset search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ntrait: Integral,
@@ -480,15 +491,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from BinarySelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from BinarySelectionProtocol
 
-class GeneralizedWeightedGenomicEstimatedBreedingValueIntegerSelection(GeneralizedWeightedGenomicEstimatedBreedingValueSelectionMixin,IntegerSelectionProtocol):
+class GeneralizedWeightedGenomicEstimatedBreedingValueIntegerSelection(
+        GeneralizedWeightedGenomicEstimatedBreedingValueSelectionMixin,
+        IntegerSelectionProtocol,
+    ):
     """
     Generalized Weighted Genomic Estiamted Breeding Value Selection in an integer search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ntrait: Integral,
@@ -888,15 +902,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from IntegerSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from IntegerSelectionProtocol
 
-class GeneralizedWeightedGenomicEstimatedBreedingValueRealSelection(GeneralizedWeightedGenomicEstimatedBreedingValueSelectionMixin,RealSelectionProtocol):
+class GeneralizedWeightedGenomicEstimatedBreedingValueRealSelection(
+        GeneralizedWeightedGenomicEstimatedBreedingValueSelectionMixin,
+        RealSelectionProtocol,
+    ):
     """
     Generalized Weighted Genomic Estiamted Breeding Value Selection in a real search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ntrait: Integral,
@@ -1296,15 +1313,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from RealSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from RealSelectionProtocol
 
-class GeneralizedWeightedGenomicEstimatedBreedingValueSubsetSelection(GeneralizedWeightedGenomicEstimatedBreedingValueSelectionMixin,SubsetSelectionProtocol):
+class GeneralizedWeightedGenomicEstimatedBreedingValueSubsetSelection(
+        GeneralizedWeightedGenomicEstimatedBreedingValueSelectionMixin,
+        SubsetSelectionProtocol,
+    ):
     """
     Generalized Weighted Genomic Estiamted Breeding Value Selection in a subset search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ntrait: Integral,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/GenomicEstimatedBreedingValueSelection.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/GenomicEstimatedBreedingValueSelection.py`

 * *Files 0% similar despite different names*

```diff
@@ -9,45 +9,52 @@
     "GenomicEstimatedBreedingValueIntegerSelection",
     "GenomicEstimatedBreedingValueRealSelection",
     "GenomicEstimatedBreedingValueSubsetSelection",
 ]
 
 # imports
 from abc import ABCMeta
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
 from pybrops.breed.prot.sel.BinarySelectionProtocol import BinarySelectionProtocol
 from pybrops.breed.prot.sel.IntegerSelectionProtocol import IntegerSelectionProtocol
 from pybrops.breed.prot.sel.RealSelectionProtocol import RealSelectionProtocol
 from pybrops.breed.prot.sel.SubsetSelectionProtocol import SubsetSelectionProtocol
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
 from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_bool
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_bool
 from pybrops.breed.prot.sel.prob.GenomicEstimatedBreedingValueSelectionProblem import GenomicEstimatedBreedingValueBinarySelectionProblem
 from pybrops.breed.prot.sel.prob.GenomicEstimatedBreedingValueSelectionProblem import GenomicEstimatedBreedingValueIntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.GenomicEstimatedBreedingValueSelectionProblem import GenomicEstimatedBreedingValueRealSelectionProblem
 from pybrops.breed.prot.sel.prob.GenomicEstimatedBreedingValueSelectionProblem import GenomicEstimatedBreedingValueSubsetSelectionProblem
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.opt.algo.BinaryOptimizationAlgorithm import BinaryOptimizationAlgorithm
 from pybrops.opt.algo.IntegerOptimizationAlgorithm import IntegerOptimizationAlgorithm
 from pybrops.opt.algo.RealOptimizationAlgorithm import RealOptimizationAlgorithm
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
-class GenomicEstimatedBreedingValueSelectionMixin(metaclass=ABCMeta):
+class GenomicEstimatedBreedingValueSelectionMixin(
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for Genomic Estimated Breeding Value Selection with constraints.
     """
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
@@ -69,15 +76,18 @@
         return self._unscale
     @unscale.setter
     def unscale(self, value: bool) -> None:
         """Set whether to unscale and uncenter breeding values."""
         check_is_bool(value, "unscale")
         self._unscale = value
 
-class GenomicEstimatedBreedingValueBinarySelection(GenomicEstimatedBreedingValueSelectionMixin,BinarySelectionProtocol):
+class GenomicEstimatedBreedingValueBinarySelection(
+        GenomicEstimatedBreedingValueSelectionMixin,
+        BinarySelectionProtocol,
+    ):
     """
     Genomic Estimated Breeding Value Selection in a subset search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ntrait: Integral,
@@ -477,15 +487,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from RealSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from RealSelectionProtocol
 
-class GenomicEstimatedBreedingValueIntegerSelection(GenomicEstimatedBreedingValueSelectionMixin,IntegerSelectionProtocol):
+class GenomicEstimatedBreedingValueIntegerSelection(
+        GenomicEstimatedBreedingValueSelectionMixin,
+        IntegerSelectionProtocol,
+    ):
     """
     Genomic Estimated Breeding Value Selection in an integer search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ntrait: Integral,
@@ -885,15 +898,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from RealSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from RealSelectionProtocol
 
-class GenomicEstimatedBreedingValueRealSelection(GenomicEstimatedBreedingValueSelectionMixin,RealSelectionProtocol):
+class GenomicEstimatedBreedingValueRealSelection(
+        GenomicEstimatedBreedingValueSelectionMixin,
+        RealSelectionProtocol,
+    ):
     """
     Genomic Estimated Breeding Value Selection in a real search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ntrait: Integral,
@@ -1293,15 +1309,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from RealSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from RealSelectionProtocol
 
-class GenomicEstimatedBreedingValueSubsetSelection(GenomicEstimatedBreedingValueSelectionMixin,SubsetSelectionProtocol):
+class GenomicEstimatedBreedingValueSubsetSelection(
+        GenomicEstimatedBreedingValueSelectionMixin,
+        SubsetSelectionProtocol,
+    ):
     """
     Genomic Estimated Breeding Value Selection in a subset search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ntrait: Integral,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/GenotypeBuilderSelection.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/GenotypeBuilderSelection.py`

 * *Files 3% similar despite different names*

```diff
@@ -4,35 +4,43 @@
 
 __all__ = [
     "GenotypeBuilderSelectionMixin",
     "GenotypeBuilderSubsetSelection",
 ]
 
 from abc import ABCMeta
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
 from pybrops.breed.prot.sel.SubsetSelectionProtocol import SubsetSelectionProtocol
 from pybrops.breed.prot.sel.prob.GenotypeBuilderSelectionProblem import GenotypeBuilderSubsetSelectionProblem
 from pybrops.breed.prot.sel.prob.SelectionProblem import SelectionProblem
 from pybrops.core.error.error_type_python import check_is_Integral
-from pybrops.core.error.error_value_python import check_is_gt, check_is_in_interval_inclusive
+from pybrops.core.error.error_value_python import check_is_gt
+from pybrops.core.error.error_value_python import check_is_in_interval_inclusive
 from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
 
 
-class GenotypeBuilderSelectionMixin(metaclass=ABCMeta):
+class GenotypeBuilderSelectionMixin(
+        metaclass = ABCMeta,
+    ):
     """
     docstring for GenotypeBuilderBaseSelection.
     """
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
@@ -66,15 +74,18 @@
     @nbestfndr.setter
     def nbestfndr(self, value: Integral) -> None:
         """Set number of best founders to consider."""
         check_is_Integral(value, "nbestfndr")           # must be int
         check_is_gt(value, "nbestfndr", 0)
         self._nbestfndr = value
 
-class GenotypeBuilderSubsetSelection(GenotypeBuilderSelectionMixin,SubsetSelectionProtocol):
+class GenotypeBuilderSubsetSelection(
+        GenotypeBuilderSelectionMixin,
+        SubsetSelectionProtocol,
+    ):
     """
     Class defining Genotype Builder (GB) Selection for subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/IntegerMateSelectionProtocol.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/IntegerMateSelectionProtocol.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,15 +3,16 @@
 """
 
 __all__ = [
     "IntegerMateSelectionProtocol",
     "check_is_IntegerMateSelectionProtocol",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from numbers import Integral
 from typing import Optional
 
 import pandas
 
 from pybrops.breed.prot.sel.IntegerSelectionProtocol import IntegerSelectionProtocol
 from pybrops.breed.prot.sel.MateSelectionProtocol import MateSelectionProtocol
@@ -20,15 +21,19 @@
 from pybrops.breed.prot.sel.soln.IntegerMateSelectionSolution import IntegerMateSelectionSolution
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class IntegerMateSelectionProtocol(IntegerSelectionProtocol,MateSelectionProtocol,metaclass=ABCMeta):
+class IntegerMateSelectionProtocol(
+        IntegerSelectionProtocol,
+        MateSelectionProtocol,
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for creating integer selection protocols.
     """
     ########################## Special Object Methods ##########################
     # inherit __init__ from IntegerSelectionProtocol
 
     ############################ Object Properties #############################
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/IntegerSelectionProtocol.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/IntegerSelectionProtocol.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,36 +3,45 @@
 """
 
 __all__ = [
     "IntegerSelectionProtocol",
     "check_is_IntegerSelectionProtocol",
 ]
 
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator,RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
 from pybrops.breed.prot.sel.SelectionProtocol import SelectionProtocol
 from pybrops.breed.prot.sel.cfg.IntegerSelectionConfiguration import IntegerSelectionConfiguration
 from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
 from pybrops.breed.prot.sel.soln.IntegerSelectionSolution import IntegerSelectionSolution
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.opt.algo.NSGA2IntegerGeneticAlgorithm import NSGA2IntegerGeneticAlgorithm
 from pybrops.opt.algo.IntegerGeneticAlgorithm import IntegerGeneticAlgorithm
-from pybrops.opt.algo.IntegerOptimizationAlgorithm import IntegerOptimizationAlgorithm, check_is_IntegerOptimizationAlgorithm
+from pybrops.opt.algo.IntegerOptimizationAlgorithm import IntegerOptimizationAlgorithm
+from pybrops.opt.algo.IntegerOptimizationAlgorithm import check_is_IntegerOptimizationAlgorithm
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class IntegerSelectionProtocol(SelectionProtocol,metaclass=ABCMeta):
+class IntegerSelectionProtocol(
+        SelectionProtocol,
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for creating integer selection protocols.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ncross: Integral,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/L2NormGenomicSelection.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/L2NormGenomicSelection.py`

 * *Files 1% similar despite different names*

```diff
@@ -9,41 +9,51 @@
     "L2NormGenomicIntegerSelection",
     "L2NormGenomicRealSelection",
     "L2NormGenomicSubsetSelection",
 ]
 
 # imports
 from abc import ABCMeta
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
 from pybrops.breed.prot.sel.BinarySelectionProtocol import BinarySelectionProtocol
 from pybrops.breed.prot.sel.IntegerSelectionProtocol import IntegerSelectionProtocol
 from pybrops.breed.prot.sel.RealSelectionProtocol import RealSelectionProtocol
 from pybrops.breed.prot.sel.SubsetSelectionProtocol import SubsetSelectionProtocol
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
 from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
-from pybrops.breed.prot.sel.prob.L2NormGenomicSelectionProblem import L2NormGenomicBinarySelectionProblem, L2NormGenomicIntegerSelectionProblem, L2NormGenomicRealSelectionProblem, L2NormGenomicSubsetSelectionProblem
+from pybrops.breed.prot.sel.prob.L2NormGenomicSelectionProblem import L2NormGenomicBinarySelectionProblem
+from pybrops.breed.prot.sel.prob.L2NormGenomicSelectionProblem import L2NormGenomicIntegerSelectionProblem
+from pybrops.breed.prot.sel.prob.L2NormGenomicSelectionProblem import L2NormGenomicRealSelectionProblem
+from pybrops.breed.prot.sel.prob.L2NormGenomicSelectionProblem import L2NormGenomicSubsetSelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.opt.algo.BinaryOptimizationAlgorithm import BinaryOptimizationAlgorithm
 from pybrops.opt.algo.IntegerOptimizationAlgorithm import IntegerOptimizationAlgorithm
 from pybrops.opt.algo.RealOptimizationAlgorithm import RealOptimizationAlgorithm
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
-from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import CoancestryMatrixFactory, check_is_CoancestryMatrixFactory
+from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import CoancestryMatrixFactory
+from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import check_is_CoancestryMatrixFactory
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
-class L2NormGenomicSelectionMixin(metaclass=ABCMeta):
+class L2NormGenomicSelectionMixin(
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for L2-Norm Genomic Selection (L2GS) with constraints.
     """
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
@@ -54,15 +64,18 @@
         return self._cmatfcty
     @cmatfcty.setter
     def cmatfcty(self, value: CoancestryMatrixFactory) -> None:
         """Set coancestry matrix factory."""
         check_is_CoancestryMatrixFactory(value, "cmatfcty")
         self._cmatfcty = value
 
-class L2NormGenomicBinarySelection(L2NormGenomicSelectionMixin,BinarySelectionProtocol):
+class L2NormGenomicBinarySelection(
+        L2NormGenomicSelectionMixin,
+        BinarySelectionProtocol,
+    ):
     """
     L2-Norm Genomic Selection (L2GS) in a subset search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             cmatfcty: CoancestryMatrixFactory,
@@ -456,15 +469,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from BinarySelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from BinarySelectionProtocol
 
-class L2NormGenomicIntegerSelection(L2NormGenomicSelectionMixin,IntegerSelectionProtocol):
+class L2NormGenomicIntegerSelection(
+        L2NormGenomicSelectionMixin,
+        IntegerSelectionProtocol,
+    ):
     """
     L2-Norm Genomic Selection (L2GS) in an integer search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             cmatfcty: CoancestryMatrixFactory,
@@ -858,15 +874,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from IntegerSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from IntegerSelectionProtocol
 
-class L2NormGenomicRealSelection(L2NormGenomicSelectionMixin,RealSelectionProtocol):
+class L2NormGenomicRealSelection(
+        L2NormGenomicSelectionMixin,
+        RealSelectionProtocol,
+    ):
     """
     L2-Norm Genomic Selection (L2GS) in a real search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             cmatfcty: CoancestryMatrixFactory,
@@ -1260,15 +1279,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from RealSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from RealSelectionProtocol
 
-class L2NormGenomicSubsetSelection(L2NormGenomicSelectionMixin,SubsetSelectionProtocol):
+class L2NormGenomicSubsetSelection(
+        L2NormGenomicSelectionMixin,
+        SubsetSelectionProtocol,
+    ):
     """
     L2-Norm Genomic Selection (L2GS) in a subset search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             cmatfcty: CoancestryMatrixFactory,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/MateSelectionProtocol.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/MateSelectionProtocol.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,30 +5,34 @@
 # list of all public objects in this module
 __all__ = [
     "MateSelectionProtocol",
     "check_is_MateSelectionProtocol",
 ]
 
 # imports
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from numbers import Integral
 from typing import Optional
 
 import pandas
 
 from pybrops.breed.prot.sel.SelectionProtocol import SelectionProtocol
 from pybrops.breed.prot.sel.cfg.MateSelectionConfiguration import MateSelectionConfiguration
 from pybrops.breed.prot.sel.prob.MateSelectionProblem import MateSelectionProblem
 from pybrops.breed.prot.sel.soln.MateSelectionSolution import MateSelectionSolution
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
-class MateSelectionProtocol(SelectionProtocol,metaclass=ABCMeta):
+class MateSelectionProtocol(
+        SelectionProtocol,
+        metaclass = ABCMeta,
+    ):
     """
     A semi-abstract class implementing several key properties common to most, 
     if not all, constrained selection protocols.
     """
 
     ########################## Special Object Methods ##########################
     # inherit from SelectionProtocol
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/MeanExpectedHeterozygositySelection.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/MeanExpectedHeterozygositySelection.py`

 * *Files 0% similar despite different names*

```diff
@@ -9,19 +9,23 @@
     "MeanExpectedHeterozygosityIntegerSelection",
     "MeanExpectedHeterozygosityRealSelection",
     "MeanExpectedHeterozygositySubsetSelection",
 ]
 
 # imports
 from abc import ABCMeta
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
 from pybrops.breed.prot.sel.BinarySelectionProtocol import BinarySelectionProtocol
 from pybrops.breed.prot.sel.IntegerSelectionProtocol import IntegerSelectionProtocol
 from pybrops.breed.prot.sel.RealSelectionProtocol import RealSelectionProtocol
 from pybrops.breed.prot.sel.SubsetSelectionProtocol import SubsetSelectionProtocol
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
@@ -35,29 +39,35 @@
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.opt.algo.BinaryOptimizationAlgorithm import BinaryOptimizationAlgorithm
 from pybrops.opt.algo.IntegerOptimizationAlgorithm import IntegerOptimizationAlgorithm
 from pybrops.opt.algo.RealOptimizationAlgorithm import RealOptimizationAlgorithm
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.cmat.fcty.DenseMolecularCoancestryMatrixFactory import DenseMolecularCoancestryMatrixFactory
-from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix, check_is_GenotypeMatrix
+from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
+from pybrops.popgen.gmat.GenotypeMatrix import check_is_GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
-class MeanExpectedHeterozygositySelectionMixin(metaclass=ABCMeta):
+class MeanExpectedHeterozygositySelectionMixin(
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for Mean Expected Heterozygosity Selection with constraints.
     """
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
     # no properties to define; 
 
-class MeanExpectedHeterozygosityBinarySelection(MeanExpectedHeterozygositySelectionMixin,BinarySelectionProtocol):
+class MeanExpectedHeterozygosityBinarySelection(
+        MeanExpectedHeterozygositySelectionMixin,
+        BinarySelectionProtocol,
+    ):
     """
     Mean Expected Heterozygosity Selection in a subset search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ncross: Integral,
@@ -450,15 +460,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from BinarySelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from BinarySelectionProtocol
 
-class MeanExpectedHeterozygosityIntegerSelection(MeanExpectedHeterozygositySelectionMixin,IntegerSelectionProtocol):
+class MeanExpectedHeterozygosityIntegerSelection(
+        MeanExpectedHeterozygositySelectionMixin,
+        IntegerSelectionProtocol,
+    ):
     """
     Mean Expected Heterozygosity Selection in an integer search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ncross: Integral,
@@ -851,15 +864,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from IntegerSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from IntegerSelectionProtocol
 
-class MeanExpectedHeterozygosityRealSelection(MeanExpectedHeterozygositySelectionMixin,RealSelectionProtocol):
+class MeanExpectedHeterozygosityRealSelection(
+        MeanExpectedHeterozygositySelectionMixin,
+        RealSelectionProtocol,
+    ):
     """
     Mean Expected Heterozygosity Selection in a real search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ncross: Integral,
@@ -1252,15 +1268,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from RealSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from RealSelectionProtocol
 
-class MeanExpectedHeterozygositySubsetSelection(MeanExpectedHeterozygositySelectionMixin,SubsetSelectionProtocol):
+class MeanExpectedHeterozygositySubsetSelection(
+        MeanExpectedHeterozygositySelectionMixin,
+        SubsetSelectionProtocol,
+    ):
     """
     Mean Expected Heterozygosity Selection in a subset search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ncross: Integral,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/MeanGenomicRelationshipSelection.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/MeanGenomicRelationshipSelection.py`

 * *Files 1% similar despite different names*

```diff
@@ -9,19 +9,23 @@
     "MeanGenomicRelationshipIntegerSelection",
     "MeanGenomicRelationshipRealSelection",
     "MeanGenomicRelationshipSubsetSelection",
 ]
 
 # imports
 from abc import ABCMeta
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
 from pybrops.breed.prot.sel.BinarySelectionProtocol import BinarySelectionProtocol
 from pybrops.breed.prot.sel.IntegerSelectionProtocol import IntegerSelectionProtocol
 from pybrops.breed.prot.sel.RealSelectionProtocol import RealSelectionProtocol
 from pybrops.breed.prot.sel.SubsetSelectionProtocol import SubsetSelectionProtocol
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
@@ -34,19 +38,23 @@
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.opt.algo.BinaryOptimizationAlgorithm import BinaryOptimizationAlgorithm
 from pybrops.opt.algo.IntegerOptimizationAlgorithm import IntegerOptimizationAlgorithm
 from pybrops.opt.algo.RealOptimizationAlgorithm import RealOptimizationAlgorithm
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
-from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import CoancestryMatrixFactory, check_is_CoancestryMatrixFactory
-from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix, check_is_GenotypeMatrix
+from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import CoancestryMatrixFactory
+from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import check_is_CoancestryMatrixFactory
+from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
+from pybrops.popgen.gmat.GenotypeMatrix import check_is_GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
-class MeanGenomicRelationshipSelectionMixin(metaclass=ABCMeta):
+class MeanGenomicRelationshipSelectionMixin(
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for Mean Genomic Relationship Selection with constraints.
     """
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
@@ -57,15 +65,18 @@
         return self._cmatfcty
     @cmatfcty.setter
     def cmatfcty(self, value: CoancestryMatrixFactory) -> None:
         """Set coancestry matrix factory."""
         check_is_CoancestryMatrixFactory(value, "cmatfcty")
         self._cmatfcty = value
 
-class MeanGenomicRelationshipBinarySelection(MeanGenomicRelationshipSelectionMixin,BinarySelectionProtocol):
+class MeanGenomicRelationshipBinarySelection(
+        MeanGenomicRelationshipSelectionMixin,
+        BinarySelectionProtocol,
+    ):
     """
     Mean Genomic Relationship Selection in a subset search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             cmatfcty: CoancestryMatrixFactory,
@@ -462,15 +473,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from BinarySelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from BinarySelectionProtocol
 
-class MeanGenomicRelationshipIntegerSelection(MeanGenomicRelationshipSelectionMixin,IntegerSelectionProtocol):
+class MeanGenomicRelationshipIntegerSelection(
+        MeanGenomicRelationshipSelectionMixin,
+        IntegerSelectionProtocol,
+    ):
     """
     Mean Genomic Relationship Selection in an integer search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             cmatfcty: CoancestryMatrixFactory,
@@ -867,15 +881,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from IntegerSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from IntegerSelectionProtocol
 
-class MeanGenomicRelationshipRealSelection(MeanGenomicRelationshipSelectionMixin,RealSelectionProtocol):
+class MeanGenomicRelationshipRealSelection(
+        MeanGenomicRelationshipSelectionMixin,
+        RealSelectionProtocol,
+    ):
     """
     Mean Genomic Relationship Selection in a real search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             cmatfcty: CoancestryMatrixFactory,
@@ -1272,15 +1289,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from RealSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from RealSelectionProtocol
 
-class MeanGenomicRelationshipSubsetSelection(MeanGenomicRelationshipSelectionMixin,SubsetSelectionProtocol):
+class MeanGenomicRelationshipSubsetSelection(
+        MeanGenomicRelationshipSelectionMixin,
+        SubsetSelectionProtocol,
+    ):
     """
     Mean Genomic Relationship Selection in a subset search space.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             cmatfcty: CoancestryMatrixFactory,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/MultiObjectiveGenomicSelection.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/PopulationAlleleFrequencyDistanceSelection.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,37 +1,42 @@
 """
 Module implementing selection protocols for Multi-Objective Genomic Selection.
 """
 
 __all__ = [
     "MultiObjectiveGenomicBaseSelection",
-    "MultiObjectiveGenomicSubsetSelection",
+    "PopulationAlleleFrequencyDistanceSubsetSelection",
 ]
 
 from abc import ABCMeta
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
-
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
 from pybrops.breed.prot.sel.SubsetSelectionProtocol import SubsetSelectionProtocol
-from pybrops.breed.prot.sel.prob.MultiObjectiveGenomicSelectionProblem import MultiObjectiveGenomicSubsetSelectionProblem
+from pybrops.breed.prot.sel.prob.PopulationAlleleFrequencyDistanceSelectionProblem import PopulationAlleleFrequencyDistanceSubsetSelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.core.error.error_type_python import check_is_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
-class MultiObjectiveGenomicSelectionMixin(metaclass=ABCMeta):
+class PopulationAlleleFrequencyDistanceSelectionMixin(
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for Multi-Objective Genomic Selection with constraints.
     """
     ########################## Special Object Methods ##########################
 
     ############################ Object Properties #############################
     @property
@@ -71,15 +76,18 @@
             check_ndarray_ndim(value, "target", 2)
         elif callable(value):
             pass
         else:
             raise TypeError("variable 'target' must be a callable function or numpy.ndarray")
         self._target = value
 
-class MultiObjectiveGenomicSubsetSelection(MultiObjectiveGenomicSelectionMixin,SubsetSelectionProtocol):
+class PopulationAlleleFrequencyDistanceSubsetSelection(
+        PopulationAlleleFrequencyDistanceSelectionMixin,
+        SubsetSelectionProtocol,
+    ):
     """
     Class defining Optimal Haploid Value (OHV) Selection for subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -107,15 +115,15 @@
             ndset_trans_kwargs: Optional[dict] = None, 
             rng: Optional[Union[Generator,RandomState]] = None, 
             soalgo: Optional[SubsetOptimizationAlgorithm] = None,
             moalgo: Optional[SubsetOptimizationAlgorithm] = None,
             **kwargs: dict
         ) -> None:
         """
-        Constructor for the concrete class MultiObjectiveGenomicSubsetSelection.
+        Constructor for the concrete class PopulationAlleleFrequencyDistanceSubsetSelection.
 
         Parameters
         ----------
         ntrait : Integral
             Number of traits to expect from matrix inputs.
 
         weight : numpy.ndarray, Callable
@@ -376,15 +384,15 @@
         """
         # order dependent assignments
         # make assignments from Mixin class first
         self.ntrait = ntrait
         self.weight = weight
         self.target = target
         # make assignments from SubsetSelectionProtocol second
-        super(MultiObjectiveGenomicSubsetSelection, self).__init__(
+        super(PopulationAlleleFrequencyDistanceSubsetSelection, self).__init__(
             ncross = ncross,
             nparent = nparent,
             nmating = nmating,
             nprogeny = nprogeny,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
@@ -447,25 +455,26 @@
         Returns
         -------
         out : SubsetSelectionProblem
             An optimization problem definition.
         """
         # get decision space parameters
         ntaxa = gmat.ntaxa
+        ndecn = self.ncross * self.nparent
         decn_space = numpy.arange(ntaxa)
-        decn_space_lower = numpy.repeat(0, self.nparent)
-        decn_space_upper = numpy.repeat(ntaxa-1, self.nparent)
+        decn_space_lower = numpy.repeat(0, ndecn)
+        decn_space_upper = numpy.repeat(ntaxa-1, ndecn)
 
         # construct problem
-        prob = MultiObjectiveGenomicSubsetSelectionProblem.from_gmat_gpmod(
+        prob = PopulationAlleleFrequencyDistanceSubsetSelectionProblem.from_gmat_gpmod(
             gmat = gmat,
             weight = self.weight,
             target = self.target,
             gpmod = gpmod,
-            ndecn = self.nparent,
+            ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
             nobj = self.nobj,
             obj_wt = self.obj_wt,
             obj_trans = self.obj_trans,
             obj_trans_kwargs = self.obj_trans_kwargs,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/OptimalContributionSelection.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/OptimalContributionSelection.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,19 +7,23 @@
     "OptimalContributionBinarySelection",
     "OptimalContributionIntegerSelection",
     "OptimalContributionRealSelection",
     "OptimalContributionSubsetSelection",
 ]
 
 from abc import ABCMeta
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
 from pybrops.breed.prot.sel.BinarySelectionProtocol import BinarySelectionProtocol
 from pybrops.breed.prot.sel.IntegerSelectionProtocol import IntegerSelectionProtocol
 from pybrops.breed.prot.sel.RealSelectionProtocol import RealSelectionProtocol
 from pybrops.breed.prot.sel.SubsetSelectionProtocol import SubsetSelectionProtocol
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
@@ -28,25 +32,31 @@
 from pybrops.breed.prot.sel.prob.OptimalContributionSelectionProblem import OptimalContributionIntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.OptimalContributionSelectionProblem import OptimalContributionRealSelectionProblem
 from pybrops.breed.prot.sel.prob.OptimalContributionSelectionProblem import OptimalContributionSubsetSelectionProblem
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.opt.algo.BinaryOptimizationAlgorithm import BinaryOptimizationAlgorithm
 from pybrops.opt.algo.IntegerOptimizationAlgorithm import IntegerOptimizationAlgorithm
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_bool
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_bool
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.opt.algo.RealOptimizationAlgorithm import RealOptimizationAlgorithm
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
-from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix, check_is_BreedingValueMatrix
-from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix, check_is_GenotypeMatrix
+from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
+from pybrops.popgen.bvmat.BreedingValueMatrix import check_is_BreedingValueMatrix
+from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
+from pybrops.popgen.gmat.GenotypeMatrix import check_is_GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
-from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import CoancestryMatrixFactory, check_is_CoancestryMatrixFactory
+from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import CoancestryMatrixFactory
+from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import check_is_CoancestryMatrixFactory
 
-class OptimalContributionSelectionMixin(metaclass=ABCMeta):
+class OptimalContributionSelectionMixin(
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for Optimal Contribution Selection (OCS) with constraints.
     """
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
@@ -131,15 +141,18 @@
         K = G.mat_asformat("kinship")
 
         # cholesky decomposition of K matrix: (n,n)
         out = numpy.linalg.cholesky(K).T
 
         return out
 
-class OptimalContributionBinarySelection(OptimalContributionSelectionMixin,BinarySelectionProtocol):
+class OptimalContributionBinarySelection(
+        OptimalContributionSelectionMixin,
+        BinarySelectionProtocol,
+    ):
     """
     Class defining Optimal Contribution Selection (OCS) for binary search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -552,15 +565,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from BinarySelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from BinarySelectionProtocol
 
-class OptimalContributionIntegerSelection(OptimalContributionSelectionMixin,IntegerSelectionProtocol):
+class OptimalContributionIntegerSelection(
+        OptimalContributionSelectionMixin,
+        IntegerSelectionProtocol,
+    ):
     """
     Class defining Optimal Contribution Selection (OCS) for integer search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -973,15 +989,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from IntegerSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from IntegerSelectionProtocol
 
-class OptimalContributionRealSelection(OptimalContributionSelectionMixin,RealSelectionProtocol):
+class OptimalContributionRealSelection(
+        OptimalContributionSelectionMixin,
+        RealSelectionProtocol,
+    ):
     """
     Class defining Optimal Contribution Selection (OCS) for real search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -1394,15 +1413,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from RealSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from RealSelectionProtocol
 
-class OptimalContributionSubsetSelection(OptimalContributionSelectionMixin,SubsetSelectionProtocol):
+class OptimalContributionSubsetSelection(
+        OptimalContributionSelectionMixin,
+        SubsetSelectionProtocol,
+    ):
     """
     Class defining Optimal Contribution Selection (OCS) for subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/OptimalHaploidValueSelection.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/OptimalHaploidValueSelection.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,45 +7,54 @@
     "OptimalHaploidValueBinarySelection",
     "OptimalHaploidValueIntegerSelection",
     "OptimalHaploidValueRealSelection",
     "OptimalHaploidValueSubsetSelection",
 ]
 
 from abc import ABCMeta
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
+from pybrops.breed.prot.sel.BinaryMateSelectionProtocol import BinaryMateSelectionProtocol
+from pybrops.breed.prot.sel.IntegerMateSelectionProtocol import IntegerMateSelectionProtocol
+from pybrops.breed.prot.sel.RealMateSelectionProtocol import RealMateSelectionProtocol
+from pybrops.breed.prot.sel.SubsetMateSelectionProtocol import SubsetMateSelectionProtocol
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
 from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.OptimalHaploidValueSelectionProblem import OptimalHaploidValueBinarySelectionProblem
 from pybrops.breed.prot.sel.prob.OptimalHaploidValueSelectionProblem import OptimalHaploidValueIntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.OptimalHaploidValueSelectionProblem import OptimalHaploidValueRealSelectionProblem
 from pybrops.breed.prot.sel.prob.OptimalHaploidValueSelectionProblem import OptimalHaploidValueSubsetSelectionProblem
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
-from pybrops.breed.prot.sel.SubsetSelectionProtocol import SubsetSelectionProtocol
-from pybrops.breed.prot.sel.RealSelectionProtocol import RealSelectionProtocol
-from pybrops.breed.prot.sel.IntegerSelectionProtocol import IntegerSelectionProtocol
-from pybrops.breed.prot.sel.BinarySelectionProtocol import BinarySelectionProtocol
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.opt.algo.BinaryOptimizationAlgorithm import BinaryOptimizationAlgorithm
 from pybrops.opt.algo.IntegerOptimizationAlgorithm import IntegerOptimizationAlgorithm
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_bool
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_bool
 from pybrops.core.error.error_value_python import check_is_gt
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
 from pybrops.opt.algo.RealOptimizationAlgorithm import RealOptimizationAlgorithm
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
 
-class OptimalHaploidValueSelectionMixin(metaclass=ABCMeta):
+class OptimalHaploidValueSelectionMixin(
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for Optimal Haploid Value (OHV) Selection with constraints.
     """
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
@@ -78,15 +87,18 @@
         return self._unique_parents
     @unique_parents.setter
     def unique_parents(self, value: bool) -> None:
         """Set whether parents should be unique."""
         check_is_bool(value, "unique_parents")
         self._unique_parents = value
 
-class OptimalHaploidValueBinarySelection(OptimalHaploidValueSelectionMixin,BinarySelectionProtocol):
+class OptimalHaploidValueBinarySelection(
+        OptimalHaploidValueSelectionMixin,
+        BinaryMateSelectionProtocol,
+    ):
     """
     Class defining Optimal Haploid Value (OHV) Selection for a binary search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -501,15 +513,18 @@
 
     ############## Pareto Frontier Functions ###############
     # inherit pareto() implementation
 
     ################# Selection Functions ##################
     # inherit select() implementation
 
-class OptimalHaploidValueIntegerSelection(OptimalHaploidValueSelectionMixin,IntegerSelectionProtocol):
+class OptimalHaploidValueIntegerSelection(
+        OptimalHaploidValueSelectionMixin,
+        IntegerMateSelectionProtocol,
+    ):
     """
     Class defining Optimal Haploid Value (OHV) Selection for a integer search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -924,15 +939,18 @@
 
     ############## Pareto Frontier Functions ###############
     # inherit pareto() implementation
 
     ################# Selection Functions ##################
     # inherit select() implementation
 
-class OptimalHaploidValueRealSelection(OptimalHaploidValueSelectionMixin,RealSelectionProtocol):
+class OptimalHaploidValueRealSelection(
+        OptimalHaploidValueSelectionMixin,
+        RealMateSelectionProtocol,
+    ):
     """
     Class defining Optimal Haploid Value (OHV) Selection for real search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -1347,15 +1365,18 @@
 
     ############## Pareto Frontier Functions ###############
     # inherit pareto() implementation
 
     ################# Selection Functions ##################
     # inherit select() implementation
 
-class OptimalHaploidValueSubsetSelection(OptimalHaploidValueSelectionMixin,SubsetSelectionProtocol):
+class OptimalHaploidValueSubsetSelection(
+        OptimalHaploidValueSelectionMixin,
+        SubsetMateSelectionProtocol,
+    ):
     """
     Class defining Optimal Haploid Value (OHV) Selection for subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/OptimalPopulationValueSelection.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/OptimalPopulationValueSelection.py`

 * *Files 1% similar despite different names*

```diff
@@ -4,33 +4,41 @@
 
 __all__ = [
     "OptimalPopulationValueBaseSelection",
     "OptimalPopulationValueSubsetSelection",
 ]
 
 from abc import ABCMeta
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
 from pybrops.breed.prot.sel.SubsetSelectionProtocol import SubsetSelectionProtocol
 from pybrops.breed.prot.sel.prob.SelectionProblem import SelectionProblem
 from pybrops.breed.prot.sel.prob.OptimalPopulationValueSelectionProblem import OptimalPopulationValueSubsetSelectionProblem
 from pybrops.core.error.error_type_python import check_is_Integral
 from pybrops.core.error.error_value_python import check_is_gt
-from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel, check_is_AdditiveLinearGenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
 from pybrops.opt.algo.OptimizationAlgorithm import OptimizationAlgorithm
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
 
-class OptimalPopulationValueSelectionMixin(metaclass=ABCMeta):
+class OptimalPopulationValueSelectionMixin(
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for Optimal Population Value (OPV) Selection with constraints.
     """
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
@@ -52,15 +60,18 @@
     @nhaploblk.setter
     def nhaploblk(self, value: Integral) -> None:
         """Set number of haplotype blocks to consider."""
         check_is_Integral(value, "nhaploblk")
         check_is_gt(value, "nhaploblk", 0)
         self._nhaploblk = value
 
-class OptimalPopulationValueSubsetSelection(OptimalPopulationValueSelectionMixin,SubsetSelectionProtocol):
+class OptimalPopulationValueSubsetSelection(
+        OptimalPopulationValueSelectionMixin,
+        SubsetSelectionProtocol,
+    ):
     """
     Class defining Optimal Haploid Value (OHV) Selection for subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/RandomSelection.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/RandomSelection.py`

 * *Files 0% similar despite different names*

```diff
@@ -7,19 +7,23 @@
     "RandomBinarySelection",
     "RandomIntegerSelection",
     "RandomRealSelection",
     "RandomSubsetSelection",
 ]
 
 from abc import ABCMeta
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
 from pybrops.breed.prot.sel.BinarySelectionProtocol import BinarySelectionProtocol
 from pybrops.breed.prot.sel.IntegerSelectionProtocol import IntegerSelectionProtocol
 from pybrops.breed.prot.sel.RealSelectionProtocol import RealSelectionProtocol
 from pybrops.breed.prot.sel.SubsetSelectionProtocol import SubsetSelectionProtocol
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
@@ -37,15 +41,17 @@
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.opt.algo.RealOptimizationAlgorithm import RealOptimizationAlgorithm
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
-class RandomSelectionMixin(metaclass=ABCMeta):
+class RandomSelectionMixin(
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for Random Selection (RS) with constraints.
     """
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
@@ -59,15 +65,18 @@
         """Set number of random traits."""
         check_is_Integral(value, "ntrait")      # must be int
         check_is_gt(value, "ntrait", 0)    # int must be >0
         self._ntrait = value
 
     ######################### Private Object Methods ###########################
 
-class RandomBinarySelection(RandomSelectionMixin,BinarySelectionProtocol):
+class RandomBinarySelection(
+        RandomSelectionMixin,
+        BinarySelectionProtocol,
+    ):
     """
     Class defining Optimal Haploid Value (OHV) Selection for a binary search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -459,15 +468,18 @@
 
     ############## Pareto Frontier Functions ###############
     # inherit pareto() implementation
 
     ################# Selection Functions ##################
     # inherit select() implementation
 
-class RandomIntegerSelection(RandomSelectionMixin,IntegerSelectionProtocol):
+class RandomIntegerSelection(
+        RandomSelectionMixin,
+        IntegerSelectionProtocol,
+    ):
     """
     Class defining Optimal Haploid Value (OHV) Selection for a integer search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -859,15 +871,18 @@
 
     ############## Pareto Frontier Functions ###############
     # inherit pareto() implementation
 
     ################# Selection Functions ##################
     # inherit select() implementation
 
-class RandomRealSelection(RandomSelectionMixin,RealSelectionProtocol):
+class RandomRealSelection(
+        RandomSelectionMixin,
+        RealSelectionProtocol,
+    ):
     """
     Class defining Optimal Haploid Value (OHV) Selection for real search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -1259,15 +1274,18 @@
 
     ############## Pareto Frontier Functions ###############
     # inherit pareto() implementation
 
     ################# Selection Functions ##################
     # inherit select() implementation
 
-class RandomSubsetSelection(RandomSelectionMixin,SubsetSelectionProtocol):
+class RandomSubsetSelection(
+        RandomSelectionMixin,
+        SubsetSelectionProtocol,
+    ):
     """
     Class defining Optimal Haploid Value (OHV) Selection for subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/RealMateSelectionProtocol.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/RealMateSelectionProtocol.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,15 +3,16 @@
 """
 
 __all__ = [
     "RealMateSelectionProtocol",
     "check_is_RealMateSelectionProtocol",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from numbers import Integral
 from typing import Optional
 
 import pandas
 
 from pybrops.breed.prot.sel.MateSelectionProtocol import MateSelectionProtocol
 from pybrops.breed.prot.sel.RealSelectionProtocol import RealSelectionProtocol
@@ -20,15 +21,19 @@
 from pybrops.breed.prot.sel.soln.RealMateSelectionSolution import RealMateSelectionSolution
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class RealMateSelectionProtocol(RealSelectionProtocol,MateSelectionProtocol,metaclass=ABCMeta):
+class RealMateSelectionProtocol(
+        RealSelectionProtocol,
+        MateSelectionProtocol,
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for creating real selection protocols.
     """
     ########################## Special Object Methods ##########################
     # inherit __init__ from RealSelectionProtocol
 
     ############################ Object Properties #############################
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/RealSelectionProtocol.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/RealSelectionProtocol.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,36 +3,45 @@
 """
 
 __all__ = [
     "RealSelectionProtocol",
     "check_is_RealSelectionProtocol",
 ]
 
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
 from pybrops.breed.prot.sel.SelectionProtocol import SelectionProtocol
 from pybrops.breed.prot.sel.cfg.RealSelectionConfiguration import RealSelectionConfiguration
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
 from pybrops.breed.prot.sel.soln.RealSelectionSolution import RealSelectionSolution
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.opt.algo.NSGA2RealGeneticAlgorithm import NSGA2RealGeneticAlgorithm
 from pybrops.opt.algo.RealGeneticAlgorithm import RealGeneticAlgorithm
-from pybrops.opt.algo.RealOptimizationAlgorithm import RealOptimizationAlgorithm, check_is_RealOptimizationAlgorithm
+from pybrops.opt.algo.RealOptimizationAlgorithm import RealOptimizationAlgorithm
+from pybrops.opt.algo.RealOptimizationAlgorithm import check_is_RealOptimizationAlgorithm
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class RealSelectionProtocol(SelectionProtocol,metaclass=ABCMeta):
+class RealSelectionProtocol(
+        SelectionProtocol,
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for creating real selection protocols.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ncross: Integral,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/SelectionProtocol.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/SelectionProtocol.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,38 +5,56 @@
 # list of all public objects in this module
 __all__ = [
     "SelectionProtocol",
     "check_is_SelectionProtocol",
 ]
 
 # imports
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
 from pybrops.breed.prot.sel.cfg.SelectionConfiguration import SelectionConfiguration
 from pybrops.breed.prot.sel.prob.SelectionProblem import SelectionProblem
-from pybrops.breed.prot.sel.prob.trans import trans_empty, trans_identity, trans_ndpt_to_vec_dist
+from pybrops.breed.prot.sel.prob.trans import trans_empty
+from pybrops.breed.prot.sel.prob.trans import trans_identity
+from pybrops.breed.prot.sel.prob.trans import trans_ndpt_to_vec_dist
 from pybrops.breed.prot.sel.soln.SelectionSolution import SelectionSolution
-from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState, check_is_ndarray, check_ndarray_dtype_is_integer
-from pybrops.core.error.error_type_python import check_is_Callable, check_is_Integral, check_is_Real, check_is_dict
-from pybrops.core.error.error_value_numpy import check_ndarray_all_gteq, check_ndarray_len_eq, check_ndarray_ndim
-from pybrops.core.error.error_value_python import check_is_gt, check_is_gteq, check_is_neq
+from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
+from pybrops.core.error.error_type_numpy import check_is_ndarray
+from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_integer
+from pybrops.core.error.error_type_python import check_is_Callable
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_Real
+from pybrops.core.error.error_type_python import check_is_dict
+from pybrops.core.error.error_value_numpy import check_ndarray_all_gteq
+from pybrops.core.error.error_value_numpy import check_ndarray_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
+from pybrops.core.error.error_value_python import check_is_gt
+from pybrops.core.error.error_value_python import check_is_gteq
+from pybrops.core.error.error_value_python import check_is_neq
 from pybrops.core.random.prng import global_prng
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.opt.algo.OptimizationAlgorithm import OptimizationAlgorithm
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
-class SelectionProtocol(metaclass=ABCMeta):
+class SelectionProtocol(
+        metaclass = ABCMeta,
+    ):
     """
     A semi-abstract class implementing several key properties common to most, 
     if not all, constrained selection protocols.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/SubsetMateSelectionProtocol.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/SubsetMateSelectionProtocol.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,15 +3,16 @@
 """
 
 __all__ = [
     "SubsetMateSelectionProtocol",
     "check_is_SubsetMateSelectionProtocol",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from numbers import Integral
 from typing import Optional
 
 import pandas
 
 from pybrops.breed.prot.sel.MateSelectionProtocol import MateSelectionProtocol
 from pybrops.breed.prot.sel.SubsetSelectionProtocol import SubsetSelectionProtocol
@@ -20,15 +21,19 @@
 from pybrops.breed.prot.sel.prob.SubsetMateSelectionProblem import SubsetMateSelectionProblem
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class SubsetMateSelectionProtocol(SubsetSelectionProtocol,MateSelectionProtocol,metaclass=ABCMeta):
+class SubsetMateSelectionProtocol(
+        SubsetSelectionProtocol,
+        MateSelectionProtocol,
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for creating subset selection protocols.
     """
     ########################## Special Object Methods ##########################
     # inherit __init__ from SubsetSelectionProtocol
 
     ############################ Object Properties #############################
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/SubsetSelectionProtocol.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/SubsetSelectionProtocol.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,36 +3,46 @@
 """
 
 __all__ = [
     "SubsetSelectionProtocol",
     "check_is_SubsetSelectionProtocol",
 ]
 
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 
 from pybrops.breed.prot.sel.SelectionProtocol import SelectionProtocol
 from pybrops.breed.prot.sel.cfg.SubsetSelectionConfiguration import SubsetSelectionConfiguration
 from pybrops.breed.prot.sel.soln.SubsetSelectionSolution import SubsetSelectionSolution
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.opt.algo.NSGA2SubsetGeneticAlgorithm import NSGA2SubsetGeneticAlgorithm
 from pybrops.opt.algo.SubsetGeneticAlgorithm import SubsetGeneticAlgorithm
-from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm, check_is_SubsetOptimizationAlgorithm
+from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
+from pybrops.opt.algo.SubsetOptimizationAlgorithm import check_is_SubsetOptimizationAlgorithm
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
 
 
-class SubsetSelectionProtocol(SelectionProtocol,metaclass=ABCMeta):
+class SubsetSelectionProtocol(
+        SelectionProtocol,
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for creating subset selection protocols.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             ncross: Integral,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/UnconstrainedGeneralized1NormGenomicSelection.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/UnconstrainedGeneralized1NormGenomicSelection.py`

 * *Files 0% similar despite different names*

```diff
@@ -4,15 +4,16 @@
 
 import types
 import numpy
 from typing import Union
 from typing import Callable
 
 from pybrops.opt.algo.UnconstrainedNSGA2SetGeneticAlgorithm import UnconstrainedNSGA2SetGeneticAlgorithm
-from pybrops.opt.algo.UnconstrainedOptimizationAlgorithm import UnconstrainedOptimizationAlgorithm, check_is_OptimizationAlgorithm
+from pybrops.opt.algo.UnconstrainedOptimizationAlgorithm import UnconstrainedOptimizationAlgorithm
+from pybrops.opt.algo.UnconstrainedOptimizationAlgorithm import check_is_OptimizationAlgorithm
 from pybrops.opt.algo.UnconstrainedSteepestAscentSetHillClimber import UnconstrainedSteepestAscentSetHillClimber
 from pybrops.breed.prot.sel.UnconstrainedSelectionProtocol import UnconstrainedSelectionProtocol
 from pybrops.breed.prot.sel.targetfn import target_positive
 from pybrops.breed.prot.sel.weightfn import weight_absolute
 from pybrops.core.error.error_attr_python import check_is_callable
 from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
 from pybrops.core.error.error_type_python import check_is_dict
@@ -20,15 +21,17 @@
 from pybrops.core.error.error_type_python import check_is_str
 from pybrops.core.error.error_type_python import check_isinstance
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.core.random.prng import global_prng
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
-class Generalized1NormGenomicSelection(UnconstrainedSelectionProtocol):
+class Generalized1NormGenomicSelection(
+        UnconstrainedSelectionProtocol,
+    ):
     """
     docstring for Generalized1NormGenomicSelection.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/UnconstrainedMultiObjectiveGenomicMating.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/UnconstrainedMultiObjectiveGenomicMating.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,43 +1,52 @@
 """
 Module implementing selection protocols for multi-objective genomic mating.
 """
 
 from numbers import Real
-from typing import Callable, Union
+from typing import Callable
+from typing import Union
 import numpy
 import types
-from pybrops.opt.algo.UnconstrainedOptimizationAlgorithm import UnconstrainedOptimizationAlgorithm, check_is_OptimizationAlgorithm
-from pybrops.breed.prot.sel.targetfn import target_negative, target_positive, target_stabilizing
-from pybrops.breed.prot.sel.weightfn import weight_absolute, weight_one
+
+from pybrops.opt.algo.UnconstrainedOptimizationAlgorithm import UnconstrainedOptimizationAlgorithm
+from pybrops.opt.algo.UnconstrainedOptimizationAlgorithm import check_is_OptimizationAlgorithm
+from pybrops.breed.prot.sel.targetfn import target_negative
+from pybrops.breed.prot.sel.targetfn import target_positive
+from pybrops.breed.prot.sel.targetfn import target_stabilizing
+from pybrops.breed.prot.sel.weightfn import weight_absolute
+from pybrops.breed.prot.sel.weightfn import weight_one
 from pybrops.core.error.error_type_python import check_is_int_or_inf
 from pybrops.core.error.error_value_python import check_is_gteq
-
 from pybrops.core.random.prng import global_prng
 from pybrops.opt.algo.UnconstrainedNSGA2SetGeneticAlgorithm import UnconstrainedNSGA2SetGeneticAlgorithm
 from pybrops.opt.algo.UnconstrainedSteepestAscentSetHillClimber import UnconstrainedSteepestAscentSetHillClimber
 from pybrops.breed.prot.sel.UnconstrainedSelectionProtocol import UnconstrainedSelectionProtocol
 from pybrops.core.error.error_type_python import check_isinstance
 from pybrops.core.error.error_type_python import check_is_bool
 from pybrops.core.error.error_attr_python import check_is_callable
 from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.core.error.error_type_python import check_is_int
 from pybrops.core.error.error_type_python import check_is_str
 from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
-from pybrops.core.util.arrayix import triudix, triuix
+from pybrops.core.util.array import triudix
+from pybrops.core.util.array import triuix
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.model.vmat.AdditiveGeneticVarianceMatrix import AdditiveGeneticVarianceMatrix
 from pybrops.model.vmat.AdditiveGenicVarianceMatrix import AdditiveGenicVarianceMatrix
-from pybrops.model.vmat.fcty.GeneticVarianceMatrixFactory import GeneticVarianceMatrixFactory, check_is_GeneticVarianceMatrixFactory
+from pybrops.model.vmat.fcty.GeneticVarianceMatrixFactory import GeneticVarianceMatrixFactory
+from pybrops.model.vmat.fcty.GeneticVarianceMatrixFactory import check_is_GeneticVarianceMatrixFactory
 from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
-class MultiObjectiveGenomicMating(UnconstrainedSelectionProtocol):
+class MultiObjectiveGenomicMating(
+        UnconstrainedSelectionProtocol,
+    ):
     """
     Class implementing selection protocols for multi-objective genomic mating.
 
     # TODO: add formulae for methodology.
     """
 
     ########################## Special Object Methods ##########################
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/UnconstrainedSelectionProtocol.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/UnconstrainedSelectionProtocol.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/UsefulnessCriterionSelection.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/UsefulnessCriterionSelection.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,20 +7,23 @@
     "UsefulnessCriterionBinarySelection",
     "UsefulnessCriterionIntegerSelection",
     "UsefulnessCriterionRealSelection",
     "UsefulnessCriterionSubsetSelection",
 ]
 
 from abc import ABCMeta
-from numbers import Integral, Real
-from typing import Optional, Union
+from numbers import Integral
+from numbers import Real
+from typing import Optional
+from typing import Union
 from typing import Callable
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 import pandas
 import scipy.stats
 
 from pybrops.breed.prot.sel.BinaryMateSelectionProtocol import BinaryMateSelectionProtocol
 from pybrops.breed.prot.sel.IntegerMateSelectionProtocol import IntegerMateSelectionProtocol
 from pybrops.breed.prot.sel.RealMateSelectionProtocol import RealMateSelectionProtocol
 from pybrops.breed.prot.sel.SubsetMateSelectionProtocol import SubsetMateSelectionProtocol
@@ -28,28 +31,38 @@
 from pybrops.breed.prot.sel.prob.IntegerMateSelectionProblem import IntegerMateSelectionProblem
 from pybrops.breed.prot.sel.prob.RealMateSelectionProblem import RealMateSelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetMateSelectionProblem import SubsetMateSelectionProblem
 from pybrops.breed.prot.sel.prob.UsefulnessCriterionSelectionProblem import UsefulnessCriterionBinaryMateSelectionProblem
 from pybrops.breed.prot.sel.prob.UsefulnessCriterionSelectionProblem import UsefulnessCriterionIntegerMateSelectionProblem
 from pybrops.breed.prot.sel.prob.UsefulnessCriterionSelectionProblem import UsefulnessCriterionRealMateSelectionProblem
 from pybrops.breed.prot.sel.prob.UsefulnessCriterionSelectionProblem import UsefulnessCriterionSubsetMateSelectionProblem
-from pybrops.model.vmat.fcty.GeneticVarianceMatrixFactory import GeneticVarianceMatrixFactory, check_is_GeneticVarianceMatrixFactory
+from pybrops.model.vmat.fcty.GeneticVarianceMatrixFactory import GeneticVarianceMatrixFactory
+from pybrops.model.vmat.fcty.GeneticVarianceMatrixFactory import check_is_GeneticVarianceMatrixFactory
 from pybrops.opt.algo.BinaryOptimizationAlgorithm import BinaryOptimizationAlgorithm
 from pybrops.opt.algo.IntegerOptimizationAlgorithm import IntegerOptimizationAlgorithm
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_Real, check_is_bool
-from pybrops.core.error.error_value_python import check_is_gt, check_is_gteq, check_is_in_interval_exclusive
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_Real
+from pybrops.core.error.error_type_python import check_is_bool
+from pybrops.core.error.error_value_python import check_is_gt
+from pybrops.core.error.error_value_python import check_is_gteq
+from pybrops.core.error.error_value_python import check_is_in_interval_exclusive
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
 from pybrops.opt.algo.RealOptimizationAlgorithm import RealOptimizationAlgorithm
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
-from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction, check_is_GeneticMapFunction
+from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
+from pybrops.popgen.gmap.GeneticMapFunction import check_is_GeneticMapFunction
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
 
-class UsefulnessCriterionSelectionMixin(metaclass=ABCMeta):
+class UsefulnessCriterionSelectionMixin(
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract class for Usefulness Criterion (UC) Selection with constraints.
     """
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
@@ -118,15 +131,18 @@
         return self._unique_parents
     @unique_parents.setter
     def unique_parents(self, value: bool) -> None:
         """Set whether parents should be unique."""
         check_is_bool(value, "unique_parents")
         self._unique_parents = value
 
-class UsefulnessCriterionBinarySelection(UsefulnessCriterionSelectionMixin,BinaryMateSelectionProtocol):
+class UsefulnessCriterionBinarySelection(
+        UsefulnessCriterionSelectionMixin,
+        BinaryMateSelectionProtocol,
+    ):
     """
     Class defining Usefulness Criterion (UC) Selection for a binary search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -570,15 +586,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from BinaryMateSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from BinaryMateSelectionProtocol
 
-class UsefulnessCriterionIntegerSelection(UsefulnessCriterionSelectionMixin,IntegerMateSelectionProtocol):
+class UsefulnessCriterionIntegerSelection(
+        UsefulnessCriterionSelectionMixin,
+        IntegerMateSelectionProtocol,
+    ):
     """
     Class defining Usefulness Criterion (UC) Selection for a integer search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -1022,15 +1041,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from IntegerMateSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from IntegerMateSelectionProtocol
 
-class UsefulnessCriterionRealSelection(UsefulnessCriterionSelectionMixin,RealMateSelectionProtocol):
+class UsefulnessCriterionRealSelection(
+        UsefulnessCriterionSelectionMixin,
+        RealMateSelectionProtocol,
+    ):
     """
     Class defining Usefulness Criterion (UC) Selection for real search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -1474,15 +1496,18 @@
 
     ################ Multi Objective Solve #################
     # inherit mosolve() from RealMateSelectionProtocol
 
     ################# Selection Functions ##################
     # inherit select() from RealMateSelectionProtocol
 
-class UsefulnessCriterionSubsetSelection(UsefulnessCriterionSelectionMixin,SubsetMateSelectionProtocol):
+class UsefulnessCriterionSubsetSelection(
+        UsefulnessCriterionSelectionMixin,
+        SubsetMateSelectionProtocol,
+    ):
     """
     Class defining Usefulness Criterion (UC) Selection for subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/WeightedGenomicSelection.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/WeightedGenomicSelection.py`

 * *Files 0% similar despite different names*

```diff
@@ -5,29 +5,35 @@
 __all__ = [
     "WeightedGenomicBinarySelection",
     "WeightedGenomicIntegerSelection",
     "WeightedGenomicRealSelection",
     "WeightedGenomicSubsetSelection",
 ]
 
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.breed.prot.sel.GeneralizedWeightedGenomicEstimatedBreedingValueSelection import GeneralizedWeightedGenomicEstimatedBreedingValueBinarySelection
 from pybrops.breed.prot.sel.GeneralizedWeightedGenomicEstimatedBreedingValueSelection import GeneralizedWeightedGenomicEstimatedBreedingValueIntegerSelection
 from pybrops.breed.prot.sel.GeneralizedWeightedGenomicEstimatedBreedingValueSelection import GeneralizedWeightedGenomicEstimatedBreedingValueRealSelection
 from pybrops.breed.prot.sel.GeneralizedWeightedGenomicEstimatedBreedingValueSelection import GeneralizedWeightedGenomicEstimatedBreedingValueSubsetSelection
 from pybrops.opt.algo.BinaryOptimizationAlgorithm import BinaryOptimizationAlgorithm
 from pybrops.opt.algo.IntegerOptimizationAlgorithm import IntegerOptimizationAlgorithm
 from pybrops.opt.algo.RealOptimizationAlgorithm import RealOptimizationAlgorithm
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
 
-class WeightedGenomicBinarySelection(GeneralizedWeightedGenomicEstimatedBreedingValueBinarySelection):
+class WeightedGenomicBinarySelection(
+        GeneralizedWeightedGenomicEstimatedBreedingValueBinarySelection,
+    ):
     """
     Weighted Genomic Selection in a subset search space.
     """
 
     ########################## Special Object Methods ##########################
     # override constructor from GeneralizedWeightedGenomicEstimatedBreedingValueBinarySelection
     def __init__(
@@ -339,15 +345,17 @@
             ndset_trans_kwargs = ndset_trans_kwargs, 
             rng = rng, 
             soalgo = soalgo,
             moalgo = moalgo,
             **kwargs
         )
 
-class WeightedGenomicIntegerSelection(GeneralizedWeightedGenomicEstimatedBreedingValueIntegerSelection):
+class WeightedGenomicIntegerSelection(
+        GeneralizedWeightedGenomicEstimatedBreedingValueIntegerSelection,
+    ):
     """
     Weighted Genomic Selection in an integer search space.
     """
 
     ########################## Special Object Methods ##########################
     # override constructor from GeneralizedWeightedGenomicEstimatedBreedingValueIntegerSelection
     def __init__(
@@ -659,15 +667,17 @@
             ndset_trans_kwargs = ndset_trans_kwargs, 
             rng = rng, 
             soalgo = soalgo,
             moalgo = moalgo,
             **kwargs
         )
 
-class WeightedGenomicRealSelection(GeneralizedWeightedGenomicEstimatedBreedingValueRealSelection):
+class WeightedGenomicRealSelection(
+        GeneralizedWeightedGenomicEstimatedBreedingValueRealSelection,
+    ):
     """
     Weighted Genomic Selection in a real search space.
     """
 
     ########################## Special Object Methods ##########################
     # override constructor from GeneralizedWeightedGenomicEstimatedBreedingValueRealSelection
     def __init__(
@@ -979,15 +989,17 @@
             ndset_trans_kwargs = ndset_trans_kwargs, 
             rng = rng, 
             soalgo = soalgo,
             moalgo = moalgo,
             **kwargs
         )
 
-class WeightedGenomicSubsetSelection(GeneralizedWeightedGenomicEstimatedBreedingValueSubsetSelection):
+class WeightedGenomicSubsetSelection(
+        GeneralizedWeightedGenomicEstimatedBreedingValueSubsetSelection,
+    ):
     """
     Weighted Genomic Selection in a subset search space.
     """
 
     ########################## Special Object Methods ##########################
     # override constructor from GeneralizedWeightedGenomicEstimatedBreedingValueSubsetSelection
     def __init__(
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/__init__.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/__init__.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/cfg/BinaryMateSelectionConfiguration.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/cfg/BinaryMateSelectionConfiguration.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,19 @@
 """
 Module containing representations of binary selection configurations 
 where the binary originates from a cross map.
 """
 
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.breed.prot.sel.cfg.MateSelectionConfiguration import MateSelectionConfiguration
 from pybrops.breed.prot.sel.cfg.BinarySelectionConfiguration import BinarySelectionConfiguration
 from pybrops.core.random.sampling import tiled_choice
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 class BinaryMateSelectionConfiguration(
         BinarySelectionConfiguration,
@@ -43,15 +45,15 @@
             Number of cross configurations to consider. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nparent : Integral
             The number of parents in a given cross configuration. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nmating : Integral, numpy.ndarray
             The number of times an individual cross configuration is executed.
-            This becomes important in four-way crosses with heterozygous parents, where
+            This becomes important in four-way crosses with heterozygous parents where
             initial F1 hybrids are unique and can affect the dihybrid composition.
         nprogeny : Integral, numpy.ndarray
             The number of progeny to derive from a mating event.
         pgmat : PhasedGenotypeMatrix
             A genome matrix containing parental candidates
         xconfig_decn : numpy.ndarray
             A decision vector of shape ``(ndecn,)`` containing indices corresponding to individuals in ``pgmat``.
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/cfg/BinarySelectionConfiguration.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/cfg/SubsetSelectionConfiguration.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,27 +1,35 @@
 """
-Module defining selection configurations where the decision space is binary in nature.
+Module defining selection configurations where the decision space is subset in nature.
 """
 
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.breed.prot.sel.cfg.SelectionConfiguration import SelectionConfiguration
 from pybrops.breed.prot.sel.cfg.SampledSelectionConfigurationMixin import SampledSelectionConfigurationMixin
-from pybrops.core.error.error_type_numpy import check_is_ndarray, check_ndarray_dtype_is_bool_or_integer
-from pybrops.core.error.error_value_numpy import check_ndarray_is_binary, check_ndarray_ndim
-from pybrops.core.random.sampling import axis_shuffle, outcross_shuffle, tiled_choice
+from pybrops.core.error.error_type_numpy import check_is_ndarray
+from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_integer
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
+from pybrops.core.random.sampling import axis_shuffle
+from pybrops.core.random.sampling import outcross_shuffle
+from pybrops.core.random.sampling import tiled_choice
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class BinarySelectionConfiguration(SampledSelectionConfigurationMixin,SelectionConfiguration):
+class SubsetSelectionConfiguration(
+        SampledSelectionConfigurationMixin,
+        SelectionConfiguration,
+    ):
     """
-    docstring for BinarySelectionConfiguration.
+    docstring for SubsetSelectionConfiguration.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             ncross: Integral,
             nparent: Integral,
@@ -41,15 +49,15 @@
             Number of cross configurations to consider. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nparent : Integral
             The number of parents in a given cross configuration. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nmating : Integral, numpy.ndarray
             The number of times an individual cross configuration is executed.
-            This becomes important in four-way crosses with heterozygous parents, where
+            This becomes important in four-way crosses with heterozygous parents where
             initial F1 hybrids are unique and can affect the dihybrid composition.
         nprogeny : Integral, numpy.ndarray
             The number of progeny to derive from a mating event.
         pgmat : PhasedGenotypeMatrix
             A genome matrix containing parental candidates
         xconfig_decn : numpy.ndarray
             A decision vector of shape ``(ndecn,)`` containing indices corresponding to individuals in ``pgmat``.
@@ -74,22 +82,21 @@
 
     ############################ Object Properties #############################
     @SampledSelectionConfigurationMixin.xconfig_decn.setter
     def xconfig_decn(self, value: numpy.ndarray) -> None:
         """Set decision vector for calculating the cross configuration matrix."""
         check_is_ndarray(value, "xconfig_decn")
         check_ndarray_ndim(value, "xconfig_decn", 1)
-        check_ndarray_dtype_is_bool_or_integer(value, "xconfig_decn")
-        check_ndarray_is_binary(value, "xconfig_decn")
+        check_ndarray_dtype_is_integer(value, "xconfig_decn")
         self._xconfig_decn = value
 
     ############################## Object Methods ##############################
     def sample_xconfig(
             self, 
-            return_xconfig: bool = True
+            return_xconfig: bool = False
         ) -> Union[numpy.ndarray,None]:
         """
         Sample a cross configuration from the decision vector and set it as the
         ``xconfig`` value.
 
         Parameters
         ----------
@@ -98,23 +105,17 @@
 
         Returns
         -------
         out : numpy.ndarray, None
             The sampled ``xconfig`` matrix if ``return_xconfig`` is true,
             otherwise return nothing.
         """
-        # duplicate selections
-        options = numpy.repeat(
-            numpy.arange(len(self.xconfig_decn)), 
-            self.xconfig_decn
-        )
-
         # create sample
         out = tiled_choice(
-            options,
+            self.xconfig_decn,
             size = (self.ncross, self.nparent),
             replace = False,
             rng = self.rng
         )
 
         # at least locally ensure outcrossing
         outcross_shuffle(out, rng = self.rng)
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/cfg/IntegerMateSelectionConfiguration.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/cfg/IntegerMateSelectionConfiguration.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,23 +1,28 @@
 """
 Module containing representations of subset selection configurations 
 where the subset originates from a cross map.
 """
 
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.breed.prot.sel.cfg.MateSelectionConfiguration import MateSelectionConfiguration
 from pybrops.breed.prot.sel.cfg.IntegerSelectionConfiguration import IntegerSelectionConfiguration
 from pybrops.core.random.sampling import tiled_choice
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
-class IntegerMateSelectionConfiguration(IntegerSelectionConfiguration,MateSelectionConfiguration):
+class IntegerMateSelectionConfiguration(
+        IntegerSelectionConfiguration,
+        MateSelectionConfiguration,
+    ):
     """
     Class representing a subset selection configuration where the subset 
     originates from a cross map.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -40,15 +45,15 @@
             Number of cross configurations to consider. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nparent : Integral
             The number of parents in a given cross configuration. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nmating : Integral, numpy.ndarray
             The number of times an individual cross configuration is executed.
-            This becomes important in four-way crosses with heterozygous parents, where
+            This becomes important in four-way crosses with heterozygous parents where
             initial F1 hybrids are unique and can affect the dihybrid composition.
         nprogeny : Integral, numpy.ndarray
             The number of progeny to derive from a mating event.
         pgmat : PhasedGenotypeMatrix
             A genome matrix containing parental candidates
         xconfig_decn : numpy.ndarray
             A decision vector of shape ``(ndecn,)`` containing indices corresponding to individuals in ``pgmat``.
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/cfg/IntegerSelectionConfiguration.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/cfg/IntegerSelectionConfiguration.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,25 +1,33 @@
 """
 Module defining selection configurations where the decision space is integer in nature.
 """
 
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.breed.prot.sel.cfg.SelectionConfiguration import SelectionConfiguration
 from pybrops.breed.prot.sel.cfg.SampledSelectionConfigurationMixin import SampledSelectionConfigurationMixin
-from pybrops.core.error.error_type_numpy import check_is_ndarray, check_ndarray_dtype_is_integer
+from pybrops.core.error.error_type_numpy import check_is_ndarray
+from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_integer
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.random.sampling import axis_shuffle, outcross_shuffle, tiled_choice
+from pybrops.core.random.sampling import axis_shuffle
+from pybrops.core.random.sampling import outcross_shuffle
+from pybrops.core.random.sampling import tiled_choice
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class IntegerSelectionConfiguration(SampledSelectionConfigurationMixin,SelectionConfiguration):
+class IntegerSelectionConfiguration(
+        SampledSelectionConfigurationMixin,
+        SelectionConfiguration,
+    ):
     """
     docstring for SubsetSelectionConfiguration.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -41,15 +49,15 @@
             Number of cross configurations to consider. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nparent : Integral
             The number of parents in a given cross configuration. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nmating : Integral, numpy.ndarray
             The number of times an individual cross configuration is executed.
-            This becomes important in four-way crosses with heterozygous parents, where
+            This becomes important in four-way crosses with heterozygous parents where
             initial F1 hybrids are unique and can affect the dihybrid composition.
         nprogeny : Integral, numpy.ndarray
             The number of progeny to derive from a mating event.
         pgmat : PhasedGenotypeMatrix
             A genome matrix containing parental candidates
         xconfig_decn : numpy.ndarray
             A decision vector of shape ``(ndecn,)`` containing indices corresponding to individuals in ``pgmat``.
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/cfg/MateSelectionConfiguration.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/cfg/MateSelectionConfiguration.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,20 +1,25 @@
 """
 Mixin class to provide functionality for selection configurations that require cross maps.
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
 
 import numpy
 from pybrops.breed.prot.sel.cfg.SelectionConfiguration import SelectionConfiguration
-from pybrops.core.error.error_type_numpy import check_is_ndarray, check_ndarray_dtype_is_integer
-from pybrops.core.error.error_value_numpy import check_ndarray_axis_len, check_ndarray_ndim
+from pybrops.core.error.error_type_numpy import check_is_ndarray
+from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_integer
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 
 
-class MateSelectionConfiguration(SelectionConfiguration,metaclass=ABCMeta):
+class MateSelectionConfiguration(
+        SelectionConfiguration,
+        metaclass = ABCMeta,
+    ):
     """
     A mixin class to provide functionality for selection configurations which 
     require random samples to be drawn.
     """
 
     ########################## Special Object Methods ##########################
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/cfg/RealMateSelectionConfiguration.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/cfg/SubsetMateSelectionConfiguration.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,23 +1,28 @@
 """
 Module containing representations of subset selection configurations 
 where the subset originates from a cross map.
 """
 
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.breed.prot.sel.cfg.MateSelectionConfiguration import MateSelectionConfiguration
-from pybrops.breed.prot.sel.cfg.RealSelectionConfiguration import RealSelectionConfiguration
-from pybrops.core.random.sampling import stochastic_universal_sampling
+from pybrops.breed.prot.sel.cfg.SubsetSelectionConfiguration import SubsetSelectionConfiguration
+from pybrops.core.random.sampling import tiled_choice
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
-class RealMateSelectionConfiguration(RealSelectionConfiguration,MateSelectionConfiguration):
+class SubsetMateSelectionConfiguration(
+        SubsetSelectionConfiguration,
+        MateSelectionConfiguration,
+    ):
     """
     Class representing a subset selection configuration where the subset 
     originates from a cross map.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -40,15 +45,15 @@
             Number of cross configurations to consider. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nparent : Integral
             The number of parents in a given cross configuration. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nmating : Integral, numpy.ndarray
             The number of times an individual cross configuration is executed.
-            This becomes important in four-way crosses with heterozygous parents, where
+            This becomes important in four-way crosses with heterozygous parents where
             initial F1 hybrids are unique and can affect the dihybrid composition.
         nprogeny : Integral, numpy.ndarray
             The number of progeny to derive from a mating event.
         pgmat : PhasedGenotypeMatrix
             A genome matrix containing parental candidates
         xconfig_decn : numpy.ndarray
             A decision vector of shape ``(ndecn,)`` containing indices corresponding to individuals in ``pgmat``.
@@ -92,20 +97,20 @@
 
         Returns
         -------
         out : numpy.ndarray, None
             The sampled ``xconfig`` matrix if ``return_xconfig`` is true,
             otherwise return nothing.
         """
-        # create sample using SUS
+        # create sample
         # (ncross,)
-        out = stochastic_universal_sampling(
-            numpy.arange(len(self.xconfig_decn)),
+        out = tiled_choice(
             self.xconfig_decn,
             size = (self.ncross,),
+            replace = False,
             rng = self.rng
         )
 
         # shuffle within mating configurations just for good measure
         # (ncross,)
         self.rng.shuffle(out)
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/cfg/RealSelectionConfiguration.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/cfg/RealSelectionConfiguration.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,25 +1,33 @@
 """
 Module defining selection configurations where the decision space is real-valued in nature.
 """
 
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.breed.prot.sel.cfg.SampledSelectionConfigurationMixin import SampledSelectionConfigurationMixin
 from pybrops.breed.prot.sel.cfg.SelectionConfiguration import SelectionConfiguration
-from pybrops.core.error.error_type_numpy import check_is_ndarray, check_ndarray_dtype_is_floating
+from pybrops.core.error.error_type_numpy import check_is_ndarray
+from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_floating
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.random.sampling import axis_shuffle, outcross_shuffle, stochastic_universal_sampling
+from pybrops.core.random.sampling import axis_shuffle
+from pybrops.core.random.sampling import outcross_shuffle
+from pybrops.core.random.sampling import stochastic_universal_sampling
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class RealSelectionConfiguration(SampledSelectionConfigurationMixin,SelectionConfiguration):
+class RealSelectionConfiguration(
+        SampledSelectionConfigurationMixin,
+        SelectionConfiguration,
+    ):
     """
     docstring for RealSelectionConfiguration.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -41,15 +49,15 @@
             Number of cross configurations to consider. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nparent : Integral
             The number of parents in a given cross configuration. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nmating : Integral, numpy.ndarray
             The number of times an individual cross configuration is executed.
-            This becomes important in four-way crosses with heterozygous parents, where
+            This becomes important in four-way crosses with heterozygous parents where
             initial F1 hybrids are unique and can affect the dihybrid composition.
         nprogeny : Integral, numpy.ndarray
             The number of progeny to derive from a mating event.
         pgmat : PhasedGenotypeMatrix
             A genome matrix containing parental candidates
         xconfig_decn : numpy.ndarray
             A decision vector of shape ``(ndecn,)`` containing indices corresponding to individuals in ``pgmat``.
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/cfg/SampledSelectionConfigurationMixin.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/cfg/SampledSelectionConfigurationMixin.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,21 +1,26 @@
 """
 Mixin class to provide functionality for selection configurations that require sampling.
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.core.random.prng import global_prng
-from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState, check_is_ndarray
+from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
+from pybrops.core.error.error_type_numpy import check_is_ndarray
 
 
-class SampledSelectionConfigurationMixin(metaclass=ABCMeta):
+class SampledSelectionConfigurationMixin(
+        metaclass = ABCMeta,
+    ):
     """
     A mixin class to provide functionality for selection configurations which 
     require random samples to be drawn.
     """
 
     ########################## Special Object Methods ##########################
     # __init__ cannot be defined since this is a mixin class
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/cfg/SelectionConfiguration.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/cfg/SelectionConfiguration.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,25 +1,32 @@
 """
 Module containing abstract class definitions for selection configurations
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
 from numbers import Integral
 from typing import Union
 
 import numpy
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
-from pybrops.core.error.error_type_numpy import check_is_ndarray, check_ndarray_dtype_is_integer
+from pybrops.core.error.error_type_numpy import check_is_ndarray
+from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_integer
 from pybrops.core.error.error_type_python import check_is_Integral
-from pybrops.core.error.error_value_numpy import check_ndarray_all_gt, check_ndarray_len_eq, check_ndarray_ndim, check_ndarray_shape_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_all_gt
+from pybrops.core.error.error_value_numpy import check_ndarray_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_shape_eq
 from pybrops.core.error.error_value_python import check_is_gt
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
 
 
-class SelectionConfiguration(metaclass=ABCMeta):
+class SelectionConfiguration(
+        metaclass = ABCMeta,
+    ):
     """
     docstring for SelectionConfiguration.
     """
 
     ########################## Special Object Methods ##########################
     # do not define __init__ since this is a semi-abstract class
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/cfg/SimpleMateSelectionConfiguration.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/cfg/SimpleMateSelectionConfiguration.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,15 +7,18 @@
 
 import numpy
 from pybrops.breed.prot.sel.cfg.MateSelectionConfiguration import MateSelectionConfiguration
 from pybrops.breed.prot.sel.cfg.SimpleSelectionConfiguration import SimpleSelectionConfiguration
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class SimpleMateSelectionConfiguration(SimpleSelectionConfiguration,MateSelectionConfiguration):
+class SimpleMateSelectionConfiguration(
+        SimpleSelectionConfiguration,
+        MateSelectionConfiguration,
+    ):
     """
     A simple selection configuration class containing the basic necessities for
     a SelectionConfiguration object.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
@@ -38,15 +41,15 @@
             Number of cross configurations to consider. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nparent : Integral
             The number of parents in a given cross configuration. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nmating : Integral, numpy.ndarray
             The number of times an individual cross configuration is executed.
-            This becomes important in four-way crosses with heterozygous parents, where
+            This becomes important in four-way crosses with heterozygous parents where
             initial F1 hybrids are unique and can affect the dihybrid composition.
         nprogeny : Integral, numpy.ndarray
             The number of progeny to derive from a mating event.
         pgmat : PhasedGenotypeMatrix
             A genome matrix containing parental candidates
         xconfig : numpy.ndarray
             A mating configuration matrix of shape ``(ncross,nparent)``.
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/cfg/SimpleSelectionConfiguration.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/cfg/SimpleSelectionConfiguration.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,15 +6,17 @@
 from typing import Union
 
 import numpy
 from pybrops.breed.prot.sel.cfg.SelectionConfiguration import SelectionConfiguration
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class SimpleSelectionConfiguration(SelectionConfiguration):
+class SimpleSelectionConfiguration(
+        SelectionConfiguration,
+    ):
     """
     A simple selection configuration class containing the basic necessities for
     a SelectionConfiguration object.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
@@ -36,15 +38,15 @@
             Number of cross configurations to consider. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nparent : Integral
             The number of parents in a given cross configuration. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nmating : Integral, numpy.ndarray
             The number of times an individual cross configuration is executed.
-            This becomes important in four-way crosses with heterozygous parents, where
+            This becomes important in four-way crosses with heterozygous parents where
             initial F1 hybrids are unique and can affect the dihybrid composition.
         nprogeny : Integral, numpy.ndarray
             The number of progeny to derive from a mating event.
         pgmat : PhasedGenotypeMatrix
             A genome matrix containing parental candidates
         xconfig : numpy.ndarray
             A mating configuration matrix of shape ``(ncross,nparent)``.
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/cfg/SubsetMateSelectionConfiguration.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/cfg/RealMateSelectionConfiguration.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,23 +1,28 @@
 """
 Module containing representations of subset selection configurations 
 where the subset originates from a cross map.
 """
 
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.breed.prot.sel.cfg.MateSelectionConfiguration import MateSelectionConfiguration
-from pybrops.breed.prot.sel.cfg.SubsetSelectionConfiguration import SubsetSelectionConfiguration
-from pybrops.core.random.sampling import tiled_choice
+from pybrops.breed.prot.sel.cfg.RealSelectionConfiguration import RealSelectionConfiguration
+from pybrops.core.random.sampling import stochastic_universal_sampling
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
-class SubsetMateSelectionConfiguration(SubsetSelectionConfiguration,MateSelectionConfiguration):
+class RealMateSelectionConfiguration(
+        RealSelectionConfiguration,
+        MateSelectionConfiguration,
+    ):
     """
     Class representing a subset selection configuration where the subset 
     originates from a cross map.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -40,15 +45,15 @@
             Number of cross configurations to consider. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nparent : Integral
             The number of parents in a given cross configuration. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nmating : Integral, numpy.ndarray
             The number of times an individual cross configuration is executed.
-            This becomes important in four-way crosses with heterozygous parents, where
+            This becomes important in four-way crosses with heterozygous parents where
             initial F1 hybrids are unique and can affect the dihybrid composition.
         nprogeny : Integral, numpy.ndarray
             The number of progeny to derive from a mating event.
         pgmat : PhasedGenotypeMatrix
             A genome matrix containing parental candidates
         xconfig_decn : numpy.ndarray
             A decision vector of shape ``(ndecn,)`` containing indices corresponding to individuals in ``pgmat``.
@@ -92,20 +97,20 @@
 
         Returns
         -------
         out : numpy.ndarray, None
             The sampled ``xconfig`` matrix if ``return_xconfig`` is true,
             otherwise return nothing.
         """
-        # create sample
+        # create sample using SUS
         # (ncross,)
-        out = tiled_choice(
+        out = stochastic_universal_sampling(
+            numpy.arange(len(self.xconfig_decn)),
             self.xconfig_decn,
             size = (self.ncross,),
-            replace = False,
             rng = self.rng
         )
 
         # shuffle within mating configurations just for good measure
         # (ncross,)
         self.rng.shuffle(out)
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/cfg/SubsetSelectionConfiguration.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/cfg/BinarySelectionConfiguration.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,27 +1,36 @@
 """
-Module defining selection configurations where the decision space is subset in nature.
+Module defining selection configurations where the decision space is binary in nature.
 """
 
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.breed.prot.sel.cfg.SelectionConfiguration import SelectionConfiguration
 from pybrops.breed.prot.sel.cfg.SampledSelectionConfigurationMixin import SampledSelectionConfigurationMixin
-from pybrops.core.error.error_type_numpy import check_is_ndarray, check_ndarray_dtype_is_integer
+from pybrops.core.error.error_type_numpy import check_is_ndarray
+from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_bool_or_integer
+from pybrops.core.error.error_value_numpy import check_ndarray_is_binary
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.random.sampling import axis_shuffle, outcross_shuffle, tiled_choice
+from pybrops.core.random.sampling import axis_shuffle
+from pybrops.core.random.sampling import outcross_shuffle
+from pybrops.core.random.sampling import tiled_choice
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class SubsetSelectionConfiguration(SampledSelectionConfigurationMixin,SelectionConfiguration):
+class BinarySelectionConfiguration(
+        SampledSelectionConfigurationMixin,
+        SelectionConfiguration,
+    ):
     """
-    docstring for SubsetSelectionConfiguration.
+    docstring for BinarySelectionConfiguration.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             ncross: Integral,
             nparent: Integral,
@@ -41,15 +50,15 @@
             Number of cross configurations to consider. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nparent : Integral
             The number of parents in a given cross configuration. Example: ``ncross = 10, nparent = 2``
             specifies 10 two-way crosses.
         nmating : Integral, numpy.ndarray
             The number of times an individual cross configuration is executed.
-            This becomes important in four-way crosses with heterozygous parents, where
+            This becomes important in four-way crosses with heterozygous parents where
             initial F1 hybrids are unique and can affect the dihybrid composition.
         nprogeny : Integral, numpy.ndarray
             The number of progeny to derive from a mating event.
         pgmat : PhasedGenotypeMatrix
             A genome matrix containing parental candidates
         xconfig_decn : numpy.ndarray
             A decision vector of shape ``(ndecn,)`` containing indices corresponding to individuals in ``pgmat``.
@@ -74,21 +83,22 @@
 
     ############################ Object Properties #############################
     @SampledSelectionConfigurationMixin.xconfig_decn.setter
     def xconfig_decn(self, value: numpy.ndarray) -> None:
         """Set decision vector for calculating the cross configuration matrix."""
         check_is_ndarray(value, "xconfig_decn")
         check_ndarray_ndim(value, "xconfig_decn", 1)
-        check_ndarray_dtype_is_integer(value, "xconfig_decn")
+        check_ndarray_dtype_is_bool_or_integer(value, "xconfig_decn")
+        check_ndarray_is_binary(value, "xconfig_decn")
         self._xconfig_decn = value
 
     ############################## Object Methods ##############################
     def sample_xconfig(
             self, 
-            return_xconfig: bool = False
+            return_xconfig: bool = True
         ) -> Union[numpy.ndarray,None]:
         """
         Sample a cross configuration from the decision vector and set it as the
         ``xconfig`` value.
 
         Parameters
         ----------
@@ -97,17 +107,23 @@
 
         Returns
         -------
         out : numpy.ndarray, None
             The sampled ``xconfig`` matrix if ``return_xconfig`` is true,
             otherwise return nothing.
         """
+        # duplicate selections
+        options = numpy.repeat(
+            numpy.arange(len(self.xconfig_decn)), 
+            self.xconfig_decn
+        )
+
         # create sample
         out = tiled_choice(
-            self.xconfig_decn,
+            options,
             size = (self.ncross, self.nparent),
             replace = False,
             rng = self.rng
         )
 
         # at least locally ensure outcrossing
         outcross_shuffle(out, rng = self.rng)
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/cfg/__init__.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/cfg/__init__.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/BinaryMateSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/IntegerMateSelectionProblem.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,27 @@
-from numbers import Integral, Real
-from typing import Callable, Iterable, Optional, Sequence, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Iterable
+from typing import Optional
+from typing import Sequence
+from typing import Union
 import numpy
 from pybrops.breed.prot.sel.prob.MateSelectionProblem import MateSelectionProblem
-from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
-from pymoo.core.problem import ElementwiseEvaluationFunction, LoopedElementwiseEvaluation
+from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
+from pymoo.core.problem import ElementwiseEvaluationFunction
+from pymoo.core.problem import LoopedElementwiseEvaluation
 
 
-class BinaryMateSelectionProblem(BinarySelectionProblem,MateSelectionProblem):
+class IntegerMateSelectionProblem(
+        IntegerSelectionProblem,
+        MateSelectionProblem,
+    ):
     """
-    docstring for BinaryMateSelectionProblem.
+    docstring for IntegerMateSelectionProblem.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             ndecn: Integral,
             decn_space: Union[numpy.ndarray,None],
@@ -39,15 +48,15 @@
             replace_nan_values_by: Optional[Real] = None,
             exclude_from_serialization: Optional[Iterable] = None,
             callback: Optional[Callable] = None,
             strict: bool = True,
             **kwargs: dict
         ) -> None:
         """
-        Constructor for BinarySelectionProblem.
+        Constructor for IntegerSelectionProblem.
         
         Parameters
         ----------
         ndecn : Integral
             Number of decision variables.
         decn_space: numpy.ndarray, None
             An array of shape ``(2,ndecn)`` defining the decision space.
@@ -110,16 +119,16 @@
         exclude_from_serialization: Iterable, None
             Attributes which are excluded from being serialized. See PyMOO documentation.
         callback: Callable, None
             A callback function to be called after every evaluation. See PyMOO documentation.
         kwargs : dict
             Additional keyword arguments used for cooperative inheritance. See PyMOO documentation.
         """
-        # call the BinaryProblem constructor
-        super(BinaryMateSelectionProblem, self).__init__(
+        # call the IntegerProblem constructor
+        super(IntegerMateSelectionProblem, self).__init__(
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/BinarySelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/RealSelectionProblem.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,30 +1,39 @@
 """
 Module partially implementing the SetSelectionProblem interface.
 """
 
 # list of public objects in this module
 __all__ = [
-    "BinarySelectionProblem",
-    "check_is_BinarySelectionProblem",
+    "RealSelectionProblem",
+    "check_is_RealSelectionProblem",
 ]
 
 # imports
 import numpy
-from numbers import Integral, Real
-from typing import Callable, Iterable, Optional, Sequence, Union
-from pymoo.core.problem import ElementwiseEvaluationFunction, LoopedElementwiseEvaluation
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Iterable
+from typing import Optional
+from typing import Sequence
+from typing import Union
+from pymoo.core.problem import ElementwiseEvaluationFunction
+from pymoo.core.problem import LoopedElementwiseEvaluation
 
 from pybrops.breed.prot.sel.prob.SelectionProblem import SelectionProblem
-from pybrops.opt.prob.BinaryProblem import BinaryProblem
+from pybrops.opt.prob.RealProblem import RealProblem
 
 # inheritance ordering is important here to avoid circular dependency/method resolution issues
-class BinarySelectionProblem(BinaryProblem,SelectionProblem):
+class RealSelectionProblem(
+        RealProblem,
+        SelectionProblem,
+    ):
     """
-    Semi-abstract class representing selection problems in binary search spaces.
+    Semi-abstract class representing selection problems in real search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             ndecn: Integral,
             decn_space: Union[numpy.ndarray,None],
@@ -50,15 +59,15 @@
             replace_nan_values_by: Optional[Real] = None,
             exclude_from_serialization: Optional[Iterable] = None,
             callback: Optional[Callable] = None,
             strict: bool = True,
             **kwargs: dict
         ) -> None:
         """
-        Constructor for BinarySelectionProblem.
+        Constructor for RealSelectionProblem.
         
         Parameters
         ----------
         ndecn : Integral
             Number of decision variables.
         decn_space: numpy.ndarray, None
             An array of shape ``(2,ndecn)`` defining the decision space.
@@ -121,16 +130,16 @@
         callback: Callable, None
             A callback function to be called after every evaluation. See PyMOO documentation.
         strict : bool, default = True
             See PyMOO documentation.
         kwargs : dict
             Additional keyword arguments used for cooperative inheritance. See PyMOO documentation.
         """
-        # call the BinaryProblem constructor
-        super(BinarySelectionProblem, self).__init__(
+        # call the RealProblem constructor
+        super(RealSelectionProblem, self).__init__(
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
             nobj = nobj,
             obj_wt = obj_wt,
             nineqcv = nineqcv,
@@ -163,20 +172,20 @@
     # leave latentfn abstract
     # evalfn defined by SelectionProblem
     # _evaluate defined by SelectionProblem
 
 
 
 ################################## Utilities ###################################
-def check_is_BinarySelectionProblem(v: object, vname: str) -> None:
+def check_is_RealSelectionProblem(v: object, vname: str) -> None:
     """
-    Check if object is of type BinarySelectionProblem, otherwise raise TypeError.
+    Check if object is of type RealSelectionProblem, otherwise raise TypeError.
 
     Parameters
     ----------
     v : object
         Any Python object to test.
     vname : str
         Name of variable to print in TypeError message.
     """
-    if not isinstance(v, BinarySelectionProblem):
-        raise TypeError("'{0}' must be of type BinarySelectionProblem.".format(vname))
+    if not isinstance(v, RealSelectionProblem):
+        raise TypeError("'{0}' must be of type RealSelectionProblem.".format(vname))
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/EstimatedBreedingValueSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/EstimatedBreedingValueSelectionProblem.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,29 +5,38 @@
 __all__ = [
     "EstimatedBreedingValueBinarySelectionProblem",
     "EstimatedBreedingValueIntegerSelectionProblem",
     "EstimatedBreedingValueRealSelectionProblem",
     "EstimatedBreedingValueSubsetSelectionProblem",
 ]
 
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Number, Real
-from typing import Callable, Optional, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Number
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
 from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.core.error.error_type_numpy import check_is_ndarray
-from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_eq, check_ndarray_axis_len_gteq, check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_gteq
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 
 
-class EstimatedBreedingValueSelectionProblemMixin(metaclass=ABCMeta):
+class EstimatedBreedingValueSelectionProblemMixin(
+        metaclass = ABCMeta,
+    ):
     """Helper class containing common properties for EBV selection problems."""
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
     
@@ -75,15 +84,18 @@
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
         ) -> "EstimatedBreedingValueSelectionProblemMixin":
         raise NotImplementedError("class method is abstract")
 
-class EstimatedBreedingValueSubsetSelectionProblem(EstimatedBreedingValueSelectionProblemMixin,SubsetSelectionProblem):
+class EstimatedBreedingValueSubsetSelectionProblem(
+        EstimatedBreedingValueSelectionProblemMixin,
+        SubsetSelectionProblem,
+    ):
     """
     Class representing selection on Estimated Breeding Values (EBVs) in subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -282,15 +294,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class EstimatedBreedingValueRealSelectionProblem(EstimatedBreedingValueSelectionProblemMixin,RealSelectionProblem):
+class EstimatedBreedingValueRealSelectionProblem(
+        EstimatedBreedingValueSelectionProblemMixin,
+        RealSelectionProblem,
+    ):
     """
     Class representing selection on Estimated Breeding Values (EBVs) in real search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -488,15 +503,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class EstimatedBreedingValueIntegerSelectionProblem(EstimatedBreedingValueSelectionProblemMixin,IntegerSelectionProblem):
+class EstimatedBreedingValueIntegerSelectionProblem(
+        EstimatedBreedingValueSelectionProblemMixin,
+        IntegerSelectionProblem,
+    ):
     """
     Class representing selection on Estimated Breeding Values (EBVs) in integer search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -694,15 +712,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class EstimatedBreedingValueBinarySelectionProblem(EstimatedBreedingValueSelectionProblemMixin,BinarySelectionProblem):
+class EstimatedBreedingValueBinarySelectionProblem(
+        EstimatedBreedingValueSelectionProblemMixin,
+        BinarySelectionProblem,
+    ):
     """
     Class representing selection on Estimated Breeding Values (EBVs) in binary search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/ExpectedMaximumBreedingValueSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/ExpectedMaximumBreedingValueSelectionProblem.py`

 * *Files 3% similar despite different names*

```diff
@@ -6,31 +6,43 @@
     "ExpectedMaximumBreedingValueSubsetSelectionProblem",
     "ExpectedMaximumBreedingValueRealSelectionProblem",
     "ExpectedMaximumBreedingValueIntegerSelectionProblem",
     "ExpectedMaximumBreedingValueBinarySelectionProblem",
 ]
 
 from abc import ABCMeta
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 import numpy
-from pybrops.breed.prot.mate.MatingProtocol import MatingProtocol, check_is_MatingProtocol
-from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
-from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
-from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
-from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
+from pybrops.breed.prot.mate.MatingProtocol import MatingProtocol
+from pybrops.breed.prot.mate.MatingProtocol import check_is_MatingProtocol
+from pybrops.breed.prot.sel.prob.BinaryMateSelectionProblem import BinaryMateSelectionProblem
+from pybrops.breed.prot.sel.prob.IntegerMateSelectionProblem import IntegerMateSelectionProblem
+from pybrops.breed.prot.sel.prob.RealMateSelectionProblem import RealMateSelectionProblem
+from pybrops.breed.prot.sel.prob.SubsetMateSelectionProblem import SubsetMateSelectionProblem
 from pybrops.core.error.error_type_numpy import check_is_ndarray
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_bool
-from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_eq, check_ndarray_axis_len_gteq, check_ndarray_ndim
-from pybrops.core.util.arrayix import triudix, triuix
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
-
-
-class ExpectedMaximumBreedingValueSelectionProblemMixin(metaclass=ABCMeta):
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_bool
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_gteq
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
+from pybrops.core.util.array import triudix
+from pybrops.core.util.array import triuix
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
+
+
+class ExpectedMaximumBreedingValueSelectionProblemMixin(
+        metaclass = ABCMeta,
+    ):
     """Helper class to implement properties common to EMBV selection problems."""
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
 
@@ -80,30 +92,22 @@
         if unique_parents:
             return numpy.array(list(triudix(ntaxa,nparent)))
         else:
             return numpy.array(list(triuix(ntaxa,nparent)))
     
     @staticmethod
     def _calc_embv(
-            nparent: int,
             nmating: int,
             nprogeny: int,
             nrep: int,
-            unique_parents: bool,
+            xmap: numpy.ndarray, # (s,d)
             pgmat: PhasedGenotypeMatrix, 
             gpmod: GenomicModel, 
             mateprot: MatingProtocol
         ) -> numpy.ndarray:
-        # calculate cross map for our genotype matrix
-        # (s,d)
-        xmap = ExpectedMaximumBreedingValueSelectionProblemMixin._calc_xmap(
-            pgmat.ntaxa,
-            nparent,
-            unique_parents
-        )
 
         # allocate matrix for output EMBVs
         # (s,t)
         embv = numpy.empty((xmap.shape[0],gpmod.ntrait), dtype = float)
 
         # for each cross configuration
         # (d,)
@@ -136,27 +140,31 @@
             # (t,)
             avg = avg / nrep
 
             embv[i,:] = avg
 
         return embv
 
-class ExpectedMaximumBreedingValueSubsetSelectionProblem(ExpectedMaximumBreedingValueSelectionProblemMixin,SubsetSelectionProblem):
+class ExpectedMaximumBreedingValueSubsetSelectionProblem(
+        ExpectedMaximumBreedingValueSelectionProblemMixin,
+        SubsetMateSelectionProblem,
+    ):
     """
     Class representing Expected Maximum Breeding Value (EMBV) selection problems in subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             embv: numpy.ndarray,
             ndecn: Integral,
             decn_space: Union[numpy.ndarray,None],
             decn_space_lower: Union[numpy.ndarray,Real,None],
             decn_space_upper: Union[numpy.ndarray,Real,None],
+            decn_space_xmap: numpy.ndarray,
             nobj: Integral,
             obj_wt: Optional[Union[numpy.ndarray,Real]] = None,
             obj_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             obj_trans_kwargs: Optional[dict] = None,
             nineqcv: Optional[Integral] = None,
             ineqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             ineqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
@@ -230,14 +238,15 @@
         """
         super(ExpectedMaximumBreedingValueSubsetSelectionProblem, self).__init__(
             embv = embv,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
+            decn_space_xmap = decn_space_xmap,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
             obj_trans_kwargs = obj_trans_kwargs,
             nineqcv = nineqcv,
             ineqcv_wt = ineqcv_wt,
             ineqcv_trans = ineqcv_trans,
@@ -339,24 +348,28 @@
         check_is_Integral(nprogeny, "nprogeny")
         check_is_Integral(nrep, "nrep")
         check_is_bool(unique_parents, "unique_parents")
         check_is_PhasedGenotypeMatrix(pgmat, "pgmat")
         check_is_GenomicModel(gpmod, "gpmod")
         check_is_MatingProtocol(mateprot, "mateprot")
 
+        # calculate cross map
+        xmap = cls._calc_xmap(pgmat.ntaxa, nparent, unique_parents)
+
         # calculate estimated maximum breeding values
-        embv = cls._calc_embv(nparent, nmating, nprogeny, nrep, unique_parents, pgmat, gpmod, mateprot)
+        embv = cls._calc_embv(nmating, nprogeny, nrep, xmap, pgmat, gpmod, mateprot)
 
         # construct class
         out = cls(
             embv = embv,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
+            decn_space_xmap = xmap,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
             obj_trans_kwargs = obj_trans_kwargs,
             nineqcv = nineqcv,
             ineqcv_wt = ineqcv_wt,
             ineqcv_trans = ineqcv_trans,
@@ -366,27 +379,31 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class ExpectedMaximumBreedingValueRealSelectionProblem(ExpectedMaximumBreedingValueSelectionProblemMixin,RealSelectionProblem):
+class ExpectedMaximumBreedingValueRealSelectionProblem(
+        ExpectedMaximumBreedingValueSelectionProblemMixin,
+        RealMateSelectionProblem,
+    ):
     """
     Class representing Expected Maximum Breeding Value (EMBV) selection problems in real search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             embv: numpy.ndarray,
             ndecn: Integral,
             decn_space: Union[numpy.ndarray,None],
             decn_space_lower: Union[numpy.ndarray,Real,None],
             decn_space_upper: Union[numpy.ndarray,Real,None],
+            decn_space_xmap: numpy.ndarray,
             nobj: Integral,
             obj_wt: Optional[Union[numpy.ndarray,Real]] = None,
             obj_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             obj_trans_kwargs: Optional[dict] = None,
             nineqcv: Optional[Integral] = None,
             ineqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             ineqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
@@ -460,14 +477,15 @@
         """
         super(ExpectedMaximumBreedingValueRealSelectionProblem, self).__init__(
             embv = embv,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
+            decn_space_xmap = decn_space_xmap,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
             obj_trans_kwargs = obj_trans_kwargs,
             nineqcv = nineqcv,
             ineqcv_wt = ineqcv_wt,
             ineqcv_trans = ineqcv_trans,
@@ -568,24 +586,28 @@
         check_is_Integral(nprogeny, "nprogeny")
         check_is_Integral(nrep, "nrep")
         check_is_bool(unique_parents, "unique_parents")
         check_is_PhasedGenotypeMatrix(pgmat, "pgmat")
         check_is_GenomicModel(gpmod, "gpmod")
         check_is_MatingProtocol(mateprot, "mateprot")
 
+        # calculate cross map
+        xmap = cls._calc_xmap(pgmat.ntaxa, nparent, unique_parents)
+
         # calculate estimated maximum breeding values
-        embv = cls._calc_embv(nparent, nmating, nprogeny, nrep, unique_parents, pgmat, gpmod, mateprot)
+        embv = cls._calc_embv(nmating, nprogeny, nrep, xmap, pgmat, gpmod, mateprot)
 
         # construct class
         out = cls(
             embv = embv,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
+            decn_space_xmap = xmap,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
             obj_trans_kwargs = obj_trans_kwargs,
             nineqcv = nineqcv,
             ineqcv_wt = ineqcv_wt,
             ineqcv_trans = ineqcv_trans,
@@ -595,27 +617,31 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class ExpectedMaximumBreedingValueIntegerSelectionProblem(ExpectedMaximumBreedingValueSelectionProblemMixin,IntegerSelectionProblem):
+class ExpectedMaximumBreedingValueIntegerSelectionProblem(
+        ExpectedMaximumBreedingValueSelectionProblemMixin,
+        IntegerMateSelectionProblem,
+    ):
     """
     Class representing Expected Maximum Breeding Value (EMBV) selection problems in integer search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             embv: numpy.ndarray,
             ndecn: Integral,
             decn_space: Union[numpy.ndarray,None],
             decn_space_lower: Union[numpy.ndarray,Real,None],
             decn_space_upper: Union[numpy.ndarray,Real,None],
+            decn_space_xmap: numpy.ndarray,
             nobj: Integral,
             obj_wt: Optional[Union[numpy.ndarray,Real]] = None,
             obj_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             obj_trans_kwargs: Optional[dict] = None,
             nineqcv: Optional[Integral] = None,
             ineqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             ineqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
@@ -689,14 +715,15 @@
         """
         super(ExpectedMaximumBreedingValueIntegerSelectionProblem, self).__init__(
             embv = embv,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
+            decn_space_xmap = decn_space_xmap,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
             obj_trans_kwargs = obj_trans_kwargs,
             nineqcv = nineqcv,
             ineqcv_wt = ineqcv_wt,
             ineqcv_trans = ineqcv_trans,
@@ -797,24 +824,28 @@
         check_is_Integral(nprogeny, "nprogeny")
         check_is_Integral(nrep, "nrep")
         check_is_bool(unique_parents, "unique_parents")
         check_is_PhasedGenotypeMatrix(pgmat, "pgmat")
         check_is_GenomicModel(gpmod, "gpmod")
         check_is_MatingProtocol(mateprot, "mateprot")
 
+        # calculate cross map
+        xmap = cls._calc_xmap(pgmat.ntaxa, nparent, unique_parents)
+
         # calculate estimated maximum breeding values
-        embv = cls._calc_embv(nparent, nmating, nprogeny, nrep, unique_parents, pgmat, gpmod, mateprot)
+        embv = cls._calc_embv(nmating, nprogeny, nrep, xmap, pgmat, gpmod, mateprot)
 
         # construct class
         out = cls(
             embv = embv,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
+            decn_space_xmap = xmap,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
             obj_trans_kwargs = obj_trans_kwargs,
             nineqcv = nineqcv,
             ineqcv_wt = ineqcv_wt,
             ineqcv_trans = ineqcv_trans,
@@ -824,27 +855,31 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class ExpectedMaximumBreedingValueBinarySelectionProblem(ExpectedMaximumBreedingValueSelectionProblemMixin,BinarySelectionProblem):
+class ExpectedMaximumBreedingValueBinarySelectionProblem(
+        ExpectedMaximumBreedingValueSelectionProblemMixin,
+        BinaryMateSelectionProblem,
+    ):
     """
     Class representing Expected Maximum Breeding Value (EMBV) selection problems in binary search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             embv: numpy.ndarray,
             ndecn: Integral,
             decn_space: Union[numpy.ndarray,None],
             decn_space_lower: Union[numpy.ndarray,Real,None],
             decn_space_upper: Union[numpy.ndarray,Real,None],
+            decn_space_xmap: numpy.ndarray,
             nobj: Integral,
             obj_wt: Optional[Union[numpy.ndarray,Real]] = None,
             obj_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             obj_trans_kwargs: Optional[dict] = None,
             nineqcv: Optional[Integral] = None,
             ineqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             ineqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
@@ -918,14 +953,15 @@
         """
         super(ExpectedMaximumBreedingValueBinarySelectionProblem, self).__init__(
             embv = embv,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
+            decn_space_xmap = decn_space_xmap,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
             obj_trans_kwargs = obj_trans_kwargs,
             nineqcv = nineqcv,
             ineqcv_wt = ineqcv_wt,
             ineqcv_trans = ineqcv_trans,
@@ -1026,24 +1062,28 @@
         check_is_Integral(nprogeny, "nprogeny")
         check_is_Integral(nrep, "nrep")
         check_is_bool(unique_parents, "unique_parents")
         check_is_PhasedGenotypeMatrix(pgmat, "pgmat")
         check_is_GenomicModel(gpmod, "gpmod")
         check_is_MatingProtocol(mateprot, "mateprot")
 
+        # calculate cross map
+        xmap = cls._calc_xmap(pgmat.ntaxa, nparent, unique_parents)
+
         # calculate estimated maximum breeding values
-        embv = cls._calc_embv(nparent, nmating, nprogeny, nrep, unique_parents, pgmat, gpmod, mateprot)
+        embv = cls._calc_embv(nmating, nprogeny, nrep, xmap, pgmat, gpmod, mateprot)
 
         # construct class
         out = cls(
             embv = embv,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
+            decn_space_xmap = xmap,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
             obj_trans_kwargs = obj_trans_kwargs,
             nineqcv = nineqcv,
             ineqcv_wt = ineqcv_wt,
             ineqcv_trans = ineqcv_trans,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/FamilyEstimatedBreedingValueSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/FamilyEstimatedBreedingValueSelectionProblem.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,29 +5,38 @@
 __all__ = [
     "FamilyEstimatedBreedingValueSubsetSelectionProblem",
     "FamilyEstimatedBreedingValueRealSelectionProblem",
     "FamilyEstimatedBreedingValueIntegerSelectionProblem",
     "FamilyEstimatedBreedingValueBinarySelectionProblem",
 ]
 
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Number, Real
-from typing import Callable, Optional, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Number
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
 from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.core.error.error_type_numpy import check_is_ndarray
-from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_eq, check_ndarray_axis_len_gteq, check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_gteq
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 
 
-class FamilyEstimatedBreedingValueSelectionProblemMixin(metaclass=ABCMeta):
+class FamilyEstimatedBreedingValueSelectionProblemMixin(
+        metaclass = ABCMeta,
+    ):
     """Helper class containing common properties for EBV selection problems."""
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
     
@@ -97,15 +106,18 @@
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
         ) -> "FamilyEstimatedBreedingValueSelectionProblemMixin":
         raise NotImplementedError("class method is abstract")
 
-class FamilyEstimatedBreedingValueSubsetSelectionProblem(FamilyEstimatedBreedingValueSelectionProblemMixin,SubsetSelectionProblem):
+class FamilyEstimatedBreedingValueSubsetSelectionProblem(
+        FamilyEstimatedBreedingValueSelectionProblemMixin,
+        SubsetSelectionProblem,
+    ):
     """
     Class representing selection on Genomic Estimated Breeding Values (GEBVs) in subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -331,15 +343,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class FamilyEstimatedBreedingValueRealSelectionProblem(FamilyEstimatedBreedingValueSelectionProblemMixin,RealSelectionProblem):
+class FamilyEstimatedBreedingValueRealSelectionProblem(
+        FamilyEstimatedBreedingValueSelectionProblemMixin,
+        RealSelectionProblem,
+    ):
     """
     Class representing selection on Genomic Estimated Breeding Values (GEBVs) in real search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -543,15 +558,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class FamilyEstimatedBreedingValueIntegerSelectionProblem(FamilyEstimatedBreedingValueSelectionProblemMixin,IntegerSelectionProblem):
+class FamilyEstimatedBreedingValueIntegerSelectionProblem(
+        FamilyEstimatedBreedingValueSelectionProblemMixin,
+        IntegerSelectionProblem,
+    ):
     """
     Class representing selection on Genomic Estimated Breeding Values (GEBVs) in integer search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -755,15 +773,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class FamilyEstimatedBreedingValueBinarySelectionProblem(FamilyEstimatedBreedingValueSelectionProblemMixin,BinarySelectionProblem):
+class FamilyEstimatedBreedingValueBinarySelectionProblem(
+        FamilyEstimatedBreedingValueSelectionProblemMixin,
+        BinarySelectionProblem,
+    ):
     """
     Class representing selection on Genomic Estimated Breeding Values (GEBVs) in binary search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblem.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,27 +6,33 @@
     "GeneralizedWeightedGenomicEstimatedBreedingValueBinarySelectionProblem",
     "GeneralizedWeightedGenomicEstimatedBreedingValueIntegerSelectionProblem",
     "GeneralizedWeightedGenomicEstimatedBreedingValueRealSelectionProblem",
     "GeneralizedWeightedGenomicEstimatedBreedingValueSubsetSelectionProblem",
 ]
 
 from abc import ABCMeta
-from numbers import Integral, Number, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Number
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 import numpy
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
 from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
-class GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblemMixin(metaclass=ABCMeta):
+class GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblemMixin(
+        metaclass = ABCMeta,
+    ):
     """Helper class containing common properties for gwGEBV selection problems."""
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
     @property
@@ -42,15 +48,18 @@
     @gwgebv.setter
     def gwgebv(self, value: numpy.ndarray) -> None:
         """Set generalized weighted genomic estimated breeding values matrix."""
         check_is_ndarray(value, "wgebv")
         check_ndarray_ndim(value, "wgebv", 2)
         self._gwgebv = value
 
-class GeneralizedWeightedGenomicEstimatedBreedingValueSubsetSelectionProblem(GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblemMixin,SubsetSelectionProblem):
+class GeneralizedWeightedGenomicEstimatedBreedingValueSubsetSelectionProblem(
+        GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblemMixin,
+        SubsetSelectionProblem,
+    ):
     """
     Class representing selection on Generalized Weighted Genomic Estimated Breeding Values (gwGEBVs) in subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -222,15 +231,17 @@
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
         ) -> "GeneralizedWeightedGenomicEstimatedBreedingValueSubsetSelectionProblem":
         # calculate wGEBVs
         # (n,p) @ (p,t) -> (n,t)
-        gwgebv = Z_a.dot(u_a * numpy.power(fafreq, -alpha))
+        tmp = fafreq.copy()
+        tmp[tmp == 0.0] = 1.0
+        gwgebv = Z_a.dot(u_a * numpy.power(tmp, -alpha))
 
         # construct problem
         out = cls(
             gwgebv = gwgebv,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
@@ -274,15 +285,15 @@
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
         ) -> "GeneralizedWeightedGenomicEstimatedBreedingValueSubsetSelectionProblem":
         # construct class
         out = cls.from_numpy(
-            Z_a = gmat.mat,
+            Z_a = gmat.mat_asformat("{0,1,2}"),
             u_a = algpmod.u_a,
             fafreq = algpmod.fafreq(gmat),
             alpha = alpha,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
@@ -299,15 +310,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class GeneralizedWeightedGenomicEstimatedBreedingValueRealSelectionProblem(GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblemMixin,RealSelectionProblem):
+class GeneralizedWeightedGenomicEstimatedBreedingValueRealSelectionProblem(
+        GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblemMixin,
+        RealSelectionProblem,
+    ):
     """
     Class representing selection on Generalized Weighted Genomic Estimated Breeding Values (gwGEBVs) in real search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -489,15 +503,17 @@
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
         ) -> "GeneralizedWeightedGenomicEstimatedBreedingValueRealSelectionProblem":
         # calculate wGEBVs
         # (n,p) @ (p,t) -> (n,t)
-        gwgebv = Z_a.dot(u_a * numpy.power(fafreq, -alpha))
+        tmp = fafreq.copy()
+        tmp[tmp == 0.0] = 1.0
+        gwgebv = Z_a.dot(u_a * numpy.power(tmp, -alpha))
 
         # construct problem
         out = cls(
             gwgebv = gwgebv,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
@@ -541,15 +557,15 @@
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
         ) -> "GeneralizedWeightedGenomicEstimatedBreedingValueRealSelectionProblem":
         # construct class
         out = cls.from_numpy(
-            Z_a = gmat.mat,
+            Z_a = gmat.mat_asformat("{0,1,2}"),
             u_a = algpmod.u_a,
             fafreq = algpmod.fafreq(gmat),
             alpha = alpha,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
@@ -566,15 +582,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class GeneralizedWeightedGenomicEstimatedBreedingValueIntegerSelectionProblem(GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblemMixin,IntegerSelectionProblem):
+class GeneralizedWeightedGenomicEstimatedBreedingValueIntegerSelectionProblem(
+        GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblemMixin,
+        IntegerSelectionProblem,
+    ):
     """
     Class representing selection on Generalized Weighted Genomic Estimated Breeding Values (gwGEBVs) in integer search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -756,15 +775,17 @@
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
         ) -> "GeneralizedWeightedGenomicEstimatedBreedingValueIntegerSelectionProblem":
         # calculate wGEBVs
         # (n,p) @ (p,t) -> (n,t)
-        gwgebv = Z_a.dot(u_a * numpy.power(fafreq, -alpha))
+        tmp = fafreq.copy()
+        tmp[tmp == 0.0] = 1.0
+        gwgebv = Z_a.dot(u_a * numpy.power(tmp, -alpha))
 
         # construct problem
         out = cls(
             gwgebv = gwgebv,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
@@ -808,15 +829,15 @@
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
         ) -> "GeneralizedWeightedGenomicEstimatedBreedingValueIntegerSelectionProblem":
         # construct class
         out = cls.from_numpy(
-            Z_a = gmat.mat,
+            Z_a = gmat.mat_asformat("{0,1,2}"),
             u_a = algpmod.u_a,
             fafreq = algpmod.fafreq(gmat),
             alpha = alpha,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
@@ -833,15 +854,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class GeneralizedWeightedGenomicEstimatedBreedingValueBinarySelectionProblem(GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblemMixin,BinarySelectionProblem):
+class GeneralizedWeightedGenomicEstimatedBreedingValueBinarySelectionProblem(
+        GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblemMixin,
+        BinarySelectionProblem,
+    ):
     """
     Class representing selection on Generalized Weighted Genomic Estimated Breeding Values (gwGEBVs) in binary search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -1024,15 +1048,17 @@
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
         ) -> "GeneralizedWeightedGenomicEstimatedBreedingValueBinarySelectionProblem":
         # calculate wGEBVs
         # (n,p) @ (p,t) -> (n,t)
-        gwgebv = Z_a.dot(u_a * numpy.power(fafreq, -alpha))
+        tmp = fafreq.copy()
+        tmp[tmp == 0.0] = 1.0
+        gwgebv = Z_a.dot(u_a * numpy.power(tmp, -alpha))
 
         # construct problem
         out = cls(
             gwgebv = gwgebv,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
@@ -1076,15 +1102,15 @@
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
         ) -> "GeneralizedWeightedGenomicEstimatedBreedingValueBinarySelectionProblem":
         # construct class
         out = cls.from_numpy(
-            Z_a = gmat.mat,
+            Z_a = gmat.mat_asformat("{0,1,2}"),
             u_a = algpmod.u_a,
             fafreq = algpmod.fafreq(gmat),
             alpha = alpha,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/GenomicEstimatedBreedingValueSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/GenomicEstimatedBreedingValueSelectionProblem.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,30 +6,38 @@
     "GenomicEstimatedBreedingValueBinarySelectionProblem",
     "GenomicEstimatedBreedingValueIntegerSelectionProblem",
     "GenomicEstimatedBreedingValueRealSelectionProblem",
     "GenomicEstimatedBreedingValueSubsetSelectionProblem",
 ]
 
 from abc import ABCMeta
-from numbers import Integral, Number, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Number
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
 from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.core.error.error_type_numpy import check_is_ndarray
-from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_eq, check_ndarray_axis_len_gteq, check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_gteq
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
 
-class GenomicEstimatedBreedingValueSelectionProblemMixin(metaclass=ABCMeta):
+class GenomicEstimatedBreedingValueSelectionProblemMixin(
+        metaclass = ABCMeta,
+    ):
     """Helper class containing common properties for CGS Problems."""
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
     
@@ -50,15 +58,18 @@
         """Set genomic estimated breeding values."""
         check_is_ndarray(value, "gebv")
         check_ndarray_ndim(value, "gebv", 2)
         # most (binary, real, integer) problems require decisons for each cross
         check_ndarray_axis_len_eq(value, "gebv", 0, self.ndecn)
         self._gebv = value
 
-class GenomicEstimatedBreedingValueSubsetSelectionProblem(GenomicEstimatedBreedingValueSelectionProblemMixin,SubsetSelectionProblem):
+class GenomicEstimatedBreedingValueSubsetSelectionProblem(
+        GenomicEstimatedBreedingValueSelectionProblemMixin,
+        SubsetSelectionProblem,
+    ):
     """
     Class representing selection on Genomic Estimated Breeding Values (GEBVs) in subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -309,15 +320,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class GenomicEstimatedBreedingValueRealSelectionProblem(GenomicEstimatedBreedingValueSelectionProblemMixin,RealSelectionProblem):
+class GenomicEstimatedBreedingValueRealSelectionProblem(
+        GenomicEstimatedBreedingValueSelectionProblemMixin,
+        RealSelectionProblem,
+    ):
     """
     Class representing selection on Genomic Estimated Breeding Values (GEBVs) in real search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -567,15 +581,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class GenomicEstimatedBreedingValueIntegerSelectionProblem(GenomicEstimatedBreedingValueSelectionProblemMixin,IntegerSelectionProblem):
+class GenomicEstimatedBreedingValueIntegerSelectionProblem(
+        GenomicEstimatedBreedingValueSelectionProblemMixin,
+        IntegerSelectionProblem,
+    ):
     """
     Class representing selection on Genomic Estimated Breeding Values (GEBVs) in integer search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -825,15 +842,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class GenomicEstimatedBreedingValueBinarySelectionProblem(GenomicEstimatedBreedingValueSelectionProblemMixin,BinarySelectionProblem):
+class GenomicEstimatedBreedingValueBinarySelectionProblem(
+        GenomicEstimatedBreedingValueSelectionProblemMixin,
+        BinarySelectionProblem,
+    ):
     """
     Class representing selection on Genomic Estimated Breeding Values (GEBVs) in binary search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/GenotypeBuilderSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/GenotypeBuilderSelectionProblem.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,29 +3,36 @@
 """
 
 __all__ = [
     "GenotypeBuilderSubsetSelectionProblem",
 ]
 
 from abc import ABCMeta
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_python import check_is_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.core.error.error_value_python import check_is_in_interval_inclusive
-from pybrops.core.util.haplo import haplobin, haplobin_bounds, nhaploblk_chrom
+from pybrops.core.util.haplo import haplobin
+from pybrops.core.util.haplo import haplobin_bounds
+from pybrops.core.util.haplo import nhaploblk_chrom
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class GenotypeBuilderSelectionProblemMixin(metaclass=ABCMeta):
+class GenotypeBuilderSelectionProblemMixin(
+        metaclass = ABCMeta,
+    ):
     """Helper class to implement properties common to GB."""
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
 
@@ -181,15 +188,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class GenotypeBuilderSubsetSelectionProblem(GenotypeBuilderSelectionProblemMixin,SubsetSelectionProblem):
+class GenotypeBuilderSubsetSelectionProblem(
+        GenotypeBuilderSelectionProblemMixin,
+        SubsetSelectionProblem,
+    ):
     """
     Class representing Genotype Builder (GB) Selection problems in subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/IntegerMateSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/RealMateSelectionProblem.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,18 +1,27 @@
-from numbers import Integral, Real
-from typing import Callable, Iterable, Optional, Sequence, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Iterable
+from typing import Optional
+from typing import Sequence
+from typing import Union
 import numpy
 from pybrops.breed.prot.sel.prob.MateSelectionProblem import MateSelectionProblem
-from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
-from pymoo.core.problem import ElementwiseEvaluationFunction, LoopedElementwiseEvaluation
+from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
+from pymoo.core.problem import ElementwiseEvaluationFunction
+from pymoo.core.problem import LoopedElementwiseEvaluation
 
 
-class IntegerMateSelectionProblem(IntegerSelectionProblem,MateSelectionProblem):
+class RealMateSelectionProblem(
+        RealSelectionProblem,
+        MateSelectionProblem,
+    ):
     """
-    docstring for IntegerMateSelectionProblem.
+    docstring for RealMateSelectionProblem.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             ndecn: Integral,
             decn_space: Union[numpy.ndarray,None],
@@ -39,15 +48,15 @@
             replace_nan_values_by: Optional[Real] = None,
             exclude_from_serialization: Optional[Iterable] = None,
             callback: Optional[Callable] = None,
             strict: bool = True,
             **kwargs: dict
         ) -> None:
         """
-        Constructor for IntegerSelectionProblem.
+        Constructor for RealSelectionProblem.
         
         Parameters
         ----------
         ndecn : Integral
             Number of decision variables.
         decn_space: numpy.ndarray, None
             An array of shape ``(2,ndecn)`` defining the decision space.
@@ -110,16 +119,16 @@
         exclude_from_serialization: Iterable, None
             Attributes which are excluded from being serialized. See PyMOO documentation.
         callback: Callable, None
             A callback function to be called after every evaluation. See PyMOO documentation.
         kwargs : dict
             Additional keyword arguments used for cooperative inheritance. See PyMOO documentation.
         """
-        # call the IntegerProblem constructor
-        super(IntegerMateSelectionProblem, self).__init__(
+        # call the RealProblem constructor
+        super(RealMateSelectionProblem, self).__init__(
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/IntegerSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/IntegerSelectionProblem.py`

 * *Files 3% similar despite different names*

```diff
@@ -6,23 +6,32 @@
 __all__ = [
     "IntegerSelectionProblem",
     "check_is_IntegerSelectionProblem",
 ]
 
 # imports
 import numpy
-from numbers import Integral, Real
-from typing import Callable, Iterable, Optional, Sequence, Union
-from pymoo.core.problem import ElementwiseEvaluationFunction, LoopedElementwiseEvaluation
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Iterable
+from typing import Optional
+from typing import Sequence
+from typing import Union
+from pymoo.core.problem import ElementwiseEvaluationFunction
+from pymoo.core.problem import LoopedElementwiseEvaluation
 
 from pybrops.breed.prot.sel.prob.SelectionProblem import SelectionProblem
 from pybrops.opt.prob.IntegerProblem import IntegerProblem
 
 # inheritance ordering is important here to avoid circular dependency/method resolution issues
-class IntegerSelectionProblem(IntegerProblem,SelectionProblem):
+class IntegerSelectionProblem(
+        IntegerProblem,
+        SelectionProblem,
+    ):
     """
     Semi-abstract class representing selection problems in integer search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/L1NormGenomicSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/L1NormGenomicSelectionProblem.py`

 * *Files 0% similar despite different names*

```diff
@@ -5,28 +5,34 @@
 __all__ = [
     "L1NormGenomicBinarySelectionProblem",
     "L1NormGenomicIntegerSelectionProblem",
     "L1NormGenomicRealSelectionProblem",
     "L1NormGenomicSubsetSelectionProblem",
 ]
 
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
 from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 
 
-class L1NormGenomicSelectionProblemMixin(metaclass=ABCMeta):
+class L1NormGenomicSelectionProblemMixin(
+        metaclass = ABCMeta,
+    ):
     """Helper class containing common properties for L1GS problems."""
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
 
@@ -159,15 +165,18 @@
             Where:
 
             - ``p`` is the number of markers.
             - ``t`` is the number of traits.
         """
         raise NotImplementedError("class method is abstract")
 
-class L1NormGenomicSubsetSelectionProblem(L1NormGenomicSelectionProblemMixin,SubsetSelectionProblem):
+class L1NormGenomicSubsetSelectionProblem(
+        L1NormGenomicSelectionProblemMixin,
+        SubsetSelectionProblem,
+    ):
     """
     Class representing L1-norm Genomic Selection (L1GS) in subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -403,15 +412,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class L1NormGenomicRealSelectionProblem(L1NormGenomicSelectionProblemMixin,RealSelectionProblem):
+class L1NormGenomicRealSelectionProblem(
+        L1NormGenomicSelectionProblemMixin,
+        RealSelectionProblem,
+    ):
     """
     Class representing L1-norm Genomic Selection (L1GS) in real search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -650,15 +662,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class L1NormGenomicIntegerSelectionProblem(L1NormGenomicSelectionProblemMixin,IntegerSelectionProblem):
+class L1NormGenomicIntegerSelectionProblem(
+        L1NormGenomicSelectionProblemMixin,
+        IntegerSelectionProblem,
+    ):
     """
     Class representing L1-norm Genomic Selection (L1GS) in integer search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -897,15 +912,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class L1NormGenomicBinarySelectionProblem(L1NormGenomicSelectionProblemMixin,BinarySelectionProblem):
+class L1NormGenomicBinarySelectionProblem(
+        L1NormGenomicSelectionProblemMixin,
+        BinarySelectionProblem,
+    ):
     """
     Class representing L1-norm Genomic Selection (L1GS) in binary search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/L2NormGenomicSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/L2NormGenomicSelectionProblem.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,29 +5,39 @@
 __all__ = [
     "L2NormGenomicBinarySelectionProblem",
     "L2NormGenomicIntegerSelectionProblem",
     "L2NormGenomicRealSelectionProblem",
     "L2NormGenomicSubsetSelectionProblem",
 ]
 
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 import numpy
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
 from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
 from pybrops.core.error.error_type_numpy import check_is_ndarray
-from pybrops.core.error.error_value_numpy import check_ndarray_is_square, check_ndarray_is_triu, check_ndarray_ndim
-from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import CoancestryMatrixFactory, check_is_CoancestryMatrixFactory
-from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix, check_is_GenotypeMatrix
+from pybrops.core.error.error_value_numpy import check_ndarray_is_square
+from pybrops.core.error.error_value_numpy import check_ndarray_is_triu
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
+from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import CoancestryMatrixFactory
+from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import check_is_CoancestryMatrixFactory
+from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
+from pybrops.popgen.gmat.GenotypeMatrix import check_is_GenotypeMatrix
 
 
-class L2NormGenomicSelectionProblemMixin(metaclass=ABCMeta):
+class L2NormGenomicSelectionProblemMixin(
+        metaclass = ABCMeta,
+    ):
     """Helper class containing common properties for L2GS problems."""
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
 
@@ -87,15 +97,18 @@
         mkrwt : numpy.ndarray
             A marker weight matrix of shape ``(p,t)``.
         afreq : numpy.ndarray
             A marker target allele frequency matrix of shape ``(p,t)``.
         """
         raise NotImplementedError("class method is abstract")
 
-class L2NormGenomicSubsetSelectionProblem(L2NormGenomicSelectionProblemMixin,SubsetSelectionProblem):
+class L2NormGenomicSubsetSelectionProblem(
+        L2NormGenomicSelectionProblemMixin,
+        SubsetSelectionProblem,
+    ):
     """
     Class representing L2-norm Genomic Selection (L2GS) in subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -334,15 +347,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class L2NormGenomicRealSelectionProblem(L2NormGenomicSelectionProblemMixin,RealSelectionProblem):
+class L2NormGenomicRealSelectionProblem(
+        L2NormGenomicSelectionProblemMixin,
+        RealSelectionProblem,
+    ):
     """
     Class representing L2-norm Genomic Selection (L2GS) in real search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -582,15 +598,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class L2NormGenomicIntegerSelectionProblem(L2NormGenomicSelectionProblemMixin,IntegerSelectionProblem):
+class L2NormGenomicIntegerSelectionProblem(
+        L2NormGenomicSelectionProblemMixin,
+        IntegerSelectionProblem,
+    ):
     """
     Class representing L2-norm Genomic Selection (L2GS) in integer search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -830,15 +849,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class L2NormGenomicBinarySelectionProblem(L2NormGenomicSelectionProblemMixin,BinarySelectionProblem):
+class L2NormGenomicBinarySelectionProblem(
+        L2NormGenomicSelectionProblemMixin,
+        BinarySelectionProblem,
+    ):
     """
     Class representing L2-norm Genomic Selection (L2GS) in binary search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/MateSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/MateSelectionProblem.py`

 * *Files 16% similar despite different names*

```diff
@@ -2,19 +2,23 @@
 Module defining interfaces for mate selection problems.
 """
 
 from abc import ABCMeta
 
 import numpy
 from pybrops.breed.prot.sel.prob.SelectionProblem import SelectionProblem
-from pybrops.core.error.error_type_numpy import check_is_ndarray, check_ndarray_dtype_is_integer
+from pybrops.core.error.error_type_numpy import check_is_ndarray
+from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_integer
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 
 
-class MateSelectionProblem(SelectionProblem,metaclass=ABCMeta):
+class MateSelectionProblem(
+        SelectionProblem,
+        metaclass = ABCMeta,
+    ):
     """
     docstring for MateSelectionProblem.
     """
 
     ########################## Special Object Methods ##########################
     # do not define __init__() since this is a semi-abstract/mixin class
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/MeanExpectedHeterozygositySelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/MeanExpectedHeterozygositySelectionProblem.py`

 * *Files 0% similar despite different names*

```diff
@@ -5,31 +5,39 @@
 __all__ = [
     "MeanExpectedHeterozygosityBinarySelectionProblem",
     "MeanExpectedHeterozygosityIntegerSelectionProblem",
     "MeanExpectedHeterozygosityRealSelectionProblem",
     "MeanExpectedHeterozygositySubsetSelectionProblem",
 ]
 
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
 from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
 from pybrops.breed.prot.sel.prob.SelectionProblem import SelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.core.error.error_type_numpy import check_is_ndarray
-from pybrops.core.error.error_value_numpy import check_ndarray_is_square, check_ndarray_is_triu, check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_is_square
+from pybrops.core.error.error_value_numpy import check_ndarray_is_triu
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import CoancestryMatrixFactory
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
 
-class MeanExpectedHeterozygositySelectionProblemMixin(metaclass=ABCMeta):
+class MeanExpectedHeterozygositySelectionProblemMixin(
+        metaclass = ABCMeta,
+    ):
     """Helper class containing common properties for Mean Expected Heterozygosity Selection Problems."""
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
     @property
@@ -74,15 +82,18 @@
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
         ) -> "MeanExpectedHeterozygositySelectionProblemMixin":
         raise NotImplementedError("class method is abstract")
 
-class MeanExpectedHeterozygositySubsetSelectionProblem(MeanExpectedHeterozygositySelectionProblemMixin,SubsetSelectionProblem):
+class MeanExpectedHeterozygositySubsetSelectionProblem(
+        MeanExpectedHeterozygositySelectionProblemMixin,
+        SubsetSelectionProblem,
+    ):
     """
     Class representing Mean Expected Heterozygosity (MEH) selection problems in subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -288,15 +299,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class MeanExpectedHeterozygosityRealSelectionProblem(MeanExpectedHeterozygositySelectionProblemMixin,RealSelectionProblem):
+class MeanExpectedHeterozygosityRealSelectionProblem(
+        MeanExpectedHeterozygositySelectionProblemMixin,
+        RealSelectionProblem,
+    ):
     """
     Class representing Mean Expected Heterozygosity (MEH) selection problems in real search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -508,15 +522,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class MeanExpectedHeterozygosityIntegerSelectionProblem(MeanExpectedHeterozygositySelectionProblemMixin,IntegerSelectionProblem):
+class MeanExpectedHeterozygosityIntegerSelectionProblem(
+        MeanExpectedHeterozygositySelectionProblemMixin,
+        IntegerSelectionProblem,
+    ):
     """
     Class representing Mean Expected Heterozygosity (MEH) selection problems in integer search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -726,15 +743,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class MeanExpectedHeterozygosityBinarySelectionProblem(MeanExpectedHeterozygositySelectionProblemMixin,BinarySelectionProblem):
+class MeanExpectedHeterozygosityBinarySelectionProblem(
+        MeanExpectedHeterozygositySelectionProblemMixin,
+        BinarySelectionProblem,
+    ):
     """
     Class representing Mean Expected Heterozygosity (MEH) selection problems in integer search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/MeanGenomicRelationshipSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/MeanGenomicRelationshipSelectionProblem.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,30 +5,38 @@
 __all__ = [
     "MeanGenomicRelationshipBinarySelectionProblem",
     "MeanGenomicRelationshipIntegerSelectionProblem",
     "MeanGenomicRelationshipRealSelectionProblem",
     "MeanGenomicRelationshipSubsetSelectionProblem",
 ]
 
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
 from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.core.error.error_type_numpy import check_is_ndarray
-from pybrops.core.error.error_value_numpy import check_ndarray_is_square, check_ndarray_is_triu, check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_is_square
+from pybrops.core.error.error_value_numpy import check_ndarray_is_triu
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import CoancestryMatrixFactory
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
 
-class MeanGenomicRelationshipSelectionProblemMixin(metaclass=ABCMeta):
+class MeanGenomicRelationshipSelectionProblemMixin(
+        metaclass = ABCMeta,
+    ):
     """Helper class containing common properties for Mean Expected Heterozygosity Selection Problems."""
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
     @property
@@ -73,15 +81,18 @@
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
         ) -> "MeanGenomicRelationshipSelectionProblemMixin":
         raise NotImplementedError("class method is abstract")
 
-class MeanGenomicRelationshipSubsetSelectionProblem(MeanGenomicRelationshipSelectionProblemMixin,SubsetSelectionProblem):
+class MeanGenomicRelationshipSubsetSelectionProblem(
+        MeanGenomicRelationshipSelectionProblemMixin,
+        SubsetSelectionProblem,
+    ):
     """
     Class representing Mean Expected Heterozygosity (MEH) selection problems in subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -283,15 +294,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class MeanGenomicRelationshipRealSelectionProblem(MeanGenomicRelationshipSelectionProblemMixin,RealSelectionProblem):
+class MeanGenomicRelationshipRealSelectionProblem(
+        MeanGenomicRelationshipSelectionProblemMixin,
+        RealSelectionProblem,
+    ):
     """
     Class representing Mean Expected Heterozygosity (MEH) selection problems in real search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -502,15 +516,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class MeanGenomicRelationshipIntegerSelectionProblem(MeanGenomicRelationshipSelectionProblemMixin,IntegerSelectionProblem):
+class MeanGenomicRelationshipIntegerSelectionProblem(
+        MeanGenomicRelationshipSelectionProblemMixin,
+        IntegerSelectionProblem,
+    ):
     """
     Class representing Mean Expected Heterozygosity (MEH) selection problems in integer search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -719,15 +736,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class MeanGenomicRelationshipBinarySelectionProblem(MeanGenomicRelationshipSelectionProblemMixin,BinarySelectionProblem):
+class MeanGenomicRelationshipBinarySelectionProblem(
+        MeanGenomicRelationshipSelectionProblemMixin,
+        BinarySelectionProblem,
+    ):
     """
     Class representing Mean Expected Heterozygosity (MEH) selection problems in integer search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/MultiObjectiveGenomicMatingProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/MultiObjectiveGenomicMatingProblem.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,28 +3,34 @@
 STILL UNDER CONSTRUCTION.
 """
 
 __all__ = [
     "MultiObjectiveGenomicSubsetMatingProblem",
 ]
 
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
 from pybrops.breed.prot.sel.prob.SubsetMateSelectionProblem import SubsetMateSelectionProblem
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_python import check_is_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
 
-class MultiObjectiveGenomicMatingProblemMixin(metaclass=ABCMeta):
+class MultiObjectiveGenomicMatingProblemMixin(
+        metaclass = ABCMeta,
+    ):
     """Helper class to implement properties common to MOGS."""
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
     @property
@@ -162,15 +168,18 @@
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
         ) -> "MultiObjectiveGenomicMatingProblemMixin":
         raise NotImplementedError("class method is abstract")
 
-class MultiObjectiveGenomicSubsetMatingProblem(MultiObjectiveGenomicMatingProblemMixin,SubsetMateSelectionProblem):
+class MultiObjectiveGenomicSubsetMatingProblem(
+        MultiObjectiveGenomicMatingProblemMixin,
+        SubsetMateSelectionProblem,
+    ):
     """
     docstring for MultiObjectiveGenomicSubsetMatingProblem.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/MultiObjectiveGenomicSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/PopulationAlleleUnavailabilitySelectionProblem.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,33 +1,36 @@
 """
 Module implementing Multi-Objective Genomic Selection (MOGS) optimization problems.
 """
 
 __all__ = [
-    "MultiObjectiveGenomicSubsetSelectionProblem",
+    "PopulationAlleleUnavailabilitySubsetSelectionProblem",
 ]
 
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-# from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
-# from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
-from pybrops.breed.prot.sel.prob.SelectionProblem import SelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_python import check_is_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
 
-class MultiObjectiveGenomicSelectionProblemMixin(metaclass=ABCMeta):
+class PopulationAlleleUnavailabilitySelectionProblemMixin(
+        metaclass = ABCMeta,
+    ):
     """Helper class to implement properties common to MOGS."""
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
     @property
@@ -154,18 +157,21 @@
             ineqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             ineqcv_trans_kwargs: Optional[dict] = None,
             neqcv: Optional[Integral] = None,
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
-        ) -> "MultiObjectiveGenomicSelectionProblemMixin":
+        ) -> "PopulationAlleleUnavailabilitySelectionProblemMixin":
         raise NotImplementedError("class method is abstract")
 
-class MultiObjectiveGenomicSubsetSelectionProblem(MultiObjectiveGenomicSelectionProblemMixin,SubsetSelectionProblem):
+class PopulationAlleleUnavailabilitySubsetSelectionProblem(
+        PopulationAlleleUnavailabilitySelectionProblemMixin,
+        SubsetSelectionProblem,
+    ):
     """
     docstring for SubsetMultiObjectiveSelectionProblem.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -282,15 +288,15 @@
             If None, use the empty set transformation function: return an empty vector of length zero.
         eqcv_trans_kwargs: dict, None
             Keyword arguments for the latent space to equality constraint violation space transformation function.
             If None, an empty dictionary is used.
         kwargs : dict
             Additional keyword arguments passed to the parent class (SubsetSelectionProblem) constructor.
         """
-        super(MultiObjectiveGenomicSubsetSelectionProblem, self).__init__(
+        super(PopulationAlleleUnavailabilitySubsetSelectionProblem, self).__init__(
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
@@ -343,28 +349,14 @@
         unlimited generations of selection. If the target allele frequency at a
         locus cannot be attained, score locus as ``1``, otherwise score as
         ``0``. Store this into a binary score vector :math:`\\textbf{u}`.
         Take the dot product between the binary score vector and the marker
         weight vector :math:`\\textbf{w} =` ``mkrwt`` to calculate
         :math:`f^{\\textup{PAU}}(\\textbf{x})` and return the result.
 
-        Population Allele Frequency Distance (PAFD): :math:`f^{\\textup{PAFD}}(\\textbf{x})`
-
-        .. math::
-            f^{\\textup{PAFD}}(\\textbf{x}) = \\textbf{w} \\cdot \\left | \\textbf{p}_{x} - \\textbf{p}_{t} \\right |
-
-        Given a genotype matrix ``mat`` and a selection indices vector
-        :math:`\\textbf{x} =` ``sel``, calculate the selection allele frequency
-        :math:`\\textbf{p}_{x}`. From the selection allele frequencies and the
-        target allele frequencies :math:`\\textbf{p}_{t} =` ``tfreq``,
-        calculate the absolute value of the difference between the two vectors.
-        Finally, take the dot product between the difference vector and the marker
-        weight vector :math:`\\textbf{w} =` ``mkrwt`` to calculate
-        :math:`f^{\\textup{PAFD}}(\\textbf{x})` and return the result.
-
         Parameters
         ----------
         x : numpy.ndarray
             A candidate solution vector of shape ``(ndecn,)``.
         args : tuple
             Additional non-keyword arguments.
         kwargs : dict
@@ -403,27 +395,19 @@
                 numpy.logical_or(
                     numpy.logical_and(p_het, self.thet), 
                     numpy.logical_and(p_gtminor, self.tmajor)
                 )
             )
         )
 
-        # calculate the manhattan distance and PAFD
-        # (p,t) -> (t,)
-        pafd = (self.mkrwt * numpy.absolute(self.tfreq - pfreq)).sum(0)
-        
         # calculate the allele unavailability
         # (p,t) -> (t,)
         pau = (self.mkrwt * allele_unavail).sum(0)
 
-        # concatenate to make MOGS vector
-        # (t,) and (t,) -> (t + t,)
-        out = numpy.concatenate([pau, pafd])
-
-        return out
+        return pau
 
     ############################## Class Methods ###############################
     @classmethod
     def from_gmat_gpmod(
             cls,
             gmat: GenotypeMatrix,
             weight: Union[numpy.ndarray,Callable],
@@ -442,15 +426,15 @@
             ineqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             ineqcv_trans_kwargs: Optional[dict] = None,
             neqcv: Optional[Integral] = None,
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
-        ) -> "MultiObjectiveGenomicSubsetSelectionProblem":
+        ) -> "PopulationAlleleUnavailabilitySubsetSelectionProblem":
         # extract genotype matrix
         geno = gmat.mat_asformat("{0,1,2}")
         ploidy = gmat.ploidy
         mkrwt = cls._calc_mkrwt(weight, gpmod.u_a)
         tfreq = cls._calc_tfreq(target, gpmod.u_a)
 
         # construct class
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/OptimalContributionSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/OptimalContributionSelectionProblem.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,31 +5,39 @@
 __all__ = [
     "OptimalContributionSubsetSelectionProblem",
     "OptimalContributionRealSelectionProblem",
     "OptimalContributionIntegerSelectionProblem",
     "OptimalContributionBinarySelectionProblem",
 ]
 
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
 from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.core.error.error_type_numpy import check_is_ndarray
-from pybrops.core.error.error_value_numpy import check_ndarray_is_square, check_ndarray_is_triu, check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_is_square
+from pybrops.core.error.error_value_numpy import check_ndarray_is_triu
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import CoancestryMatrixFactory
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
 
-class OptimalContributionSelectionProblemMixin(metaclass=ABCMeta):
+class OptimalContributionSelectionProblemMixin(
+        metaclass = ABCMeta,
+    ):
     """Helper class containing common properties for Optimal Contribution Selection Problems."""
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
     @property
@@ -142,15 +150,18 @@
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
         ) -> "OptimalContributionSelectionProblemMixin":
         raise NotImplementedError("class method is abstract")
 
-class OptimalContributionSubsetSelectionProblem(OptimalContributionSelectionProblemMixin,SubsetSelectionProblem):
+class OptimalContributionSubsetSelectionProblem(
+        OptimalContributionSelectionProblemMixin,
+        SubsetSelectionProblem,
+    ):
     """
     Class representing an Optimal Contribution Selection Problem for subset
     search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
@@ -384,15 +395,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class OptimalContributionRealSelectionProblem(OptimalContributionSelectionProblemMixin,RealSelectionProblem):
+class OptimalContributionRealSelectionProblem(
+        OptimalContributionSelectionProblemMixin,
+        RealSelectionProblem,
+    ):
     """
     Class representing an Optimal Contribution Selection Problem for real
     search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
@@ -630,15 +644,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class OptimalContributionIntegerSelectionProblem(OptimalContributionSelectionProblemMixin,IntegerSelectionProblem):
+class OptimalContributionIntegerSelectionProblem(
+        OptimalContributionSelectionProblemMixin,
+        IntegerSelectionProblem,
+    ):
     """
     Class representing an Optimal Contribution Selection Problem for integer
     search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
@@ -876,15 +893,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class OptimalContributionBinarySelectionProblem(OptimalContributionSelectionProblemMixin,BinarySelectionProblem):
+class OptimalContributionBinarySelectionProblem(
+        OptimalContributionSelectionProblemMixin,
+        BinarySelectionProblem,
+    ):
     """
     Class representing an Optimal Contribution Selection Problem for integer
     search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/OptimalHaploidValueSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/OptimalHaploidValueSelectionProblem.py`

 * *Files 0% similar despite different names*

```diff
@@ -5,33 +5,42 @@
 __all__ = [
     "OptimalHaploidValueSubsetSelectionProblem",
     "OptimalHaploidValueRealSelectionProblem",
     "OptimalHaploidValueIntegerSelectionProblem",
     "OptimalHaploidValueBinarySelectionProblem",
 ]
 
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 import numpy
-from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
-from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
-from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
-from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
+from pybrops.breed.prot.sel.prob.BinaryMateSelectionProblem import BinaryMateSelectionProblem
+from pybrops.breed.prot.sel.prob.IntegerMateSelectionProblem import IntegerMateSelectionProblem
+from pybrops.breed.prot.sel.prob.RealMateSelectionProblem import RealMateSelectionProblem
+from pybrops.breed.prot.sel.prob.SubsetMateSelectionProblem import SubsetMateSelectionProblem
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.util.arrayix import triudix, triuix
-from pybrops.core.util.haplo import haplobin, haplobin_bounds, nhaploblk_chrom
+from pybrops.core.util.array import triudix
+from pybrops.core.util.array import triuix
+from pybrops.core.util.haplo import haplobin
+from pybrops.core.util.haplo import haplobin_bounds
+from pybrops.core.util.haplo import nhaploblk_chrom
 from pybrops.core.util.subroutines import srange
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class OptimalHaploidValueSelectionProblemMixin(metaclass=ABCMeta):
+class OptimalHaploidValueSelectionProblemMixin(
+        metaclass = ABCMeta,
+    ):
     """Helper class to implement properties common to OHV."""
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
 
@@ -245,26 +254,30 @@
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
         ) -> "OptimalHaploidValueSelectionProblemMixin":
         raise NotImplementedError("class method is abstract")
 
-class OptimalHaploidValueSubsetSelectionProblem(OptimalHaploidValueSelectionProblemMixin,SubsetSelectionProblem):
+class OptimalHaploidValueSubsetSelectionProblem(
+        OptimalHaploidValueSelectionProblemMixin,
+        SubsetMateSelectionProblem,
+    ):
     """
     Class for representing Optimal Haploid Value (OHV) Selection problems in subset search spaces.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             ohvmat: numpy.ndarray,
             ndecn: Integral,
             decn_space: Union[numpy.ndarray,None],
             decn_space_lower: Union[numpy.ndarray,Real,None],
             decn_space_upper: Union[numpy.ndarray,Real,None],
+            decn_space_xmap: numpy.ndarray,
             nobj: Integral,
             obj_wt: Optional[Union[numpy.ndarray,Real]] = None,
             obj_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             obj_trans_kwargs: Optional[dict] = None,
             nineqcv: Optional[Integral] = None,
             ineqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             ineqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
@@ -337,14 +350,15 @@
             Additional keyword arguments passed to the parent class (SubsetSelectionProblem) constructor.
         """
         super(OptimalHaploidValueSubsetSelectionProblem, self).__init__(
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
+            decn_space_xmap = decn_space_xmap,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
             obj_trans_kwargs = obj_trans_kwargs,
             nineqcv = nineqcv,
             ineqcv_wt = ineqcv_wt,
             ineqcv_trans = ineqcv_trans,
@@ -441,14 +455,15 @@
         # construct class
         out = cls(
             ohvmat = ohvmat,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
+            decn_space_xmap = xmap,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
             obj_trans_kwargs = obj_trans_kwargs,
             nineqcv = nineqcv,
             ineqcv_wt = ineqcv_wt,
             ineqcv_trans = ineqcv_trans,
@@ -458,26 +473,30 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class OptimalHaploidValueRealSelectionProblem(OptimalHaploidValueSelectionProblemMixin,RealSelectionProblem):
+class OptimalHaploidValueRealSelectionProblem(
+        OptimalHaploidValueSelectionProblemMixin,
+        RealMateSelectionProblem,
+    ):
     """
     Class for representing Optimal Haploid Value (OHV) Selection problems in real search spaces.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             ohvmat: numpy.ndarray,
             ndecn: Integral,
             decn_space: Union[numpy.ndarray,None],
             decn_space_lower: Union[numpy.ndarray,Real,None],
             decn_space_upper: Union[numpy.ndarray,Real,None],
+            decn_space_xmap: numpy.ndarray,
             nobj: Integral,
             obj_wt: Optional[Union[numpy.ndarray,Real]] = None,
             obj_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             obj_trans_kwargs: Optional[dict] = None,
             nineqcv: Optional[Integral] = None,
             ineqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             ineqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
@@ -550,14 +569,15 @@
             Additional keyword arguments passed to the parent class (RealSelectionProblem) constructor.
         """
         super(OptimalHaploidValueRealSelectionProblem, self).__init__(
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
+            decn_space_xmap = decn_space_xmap,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
             obj_trans_kwargs = obj_trans_kwargs,
             nineqcv = nineqcv,
             ineqcv_wt = ineqcv_wt,
             ineqcv_trans = ineqcv_trans,
@@ -659,14 +679,15 @@
         # construct class
         out = cls(
             ohvmat = ohvmat,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
+            decn_space_xmap = xmap,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
             obj_trans_kwargs = obj_trans_kwargs,
             nineqcv = nineqcv,
             ineqcv_wt = ineqcv_wt,
             ineqcv_trans = ineqcv_trans,
@@ -676,26 +697,30 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class OptimalHaploidValueIntegerSelectionProblem(OptimalHaploidValueSelectionProblemMixin,IntegerSelectionProblem):
+class OptimalHaploidValueIntegerSelectionProblem(
+        OptimalHaploidValueSelectionProblemMixin,
+        IntegerMateSelectionProblem,
+    ):
     """
     Class for representing Optimal Haploid Value (OHV) Selection problems in integer search spaces.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             ohvmat: numpy.ndarray,
             ndecn: Integral,
             decn_space: Union[numpy.ndarray,None],
             decn_space_lower: Union[numpy.ndarray,Real,None],
             decn_space_upper: Union[numpy.ndarray,Real,None],
+            decn_space_xmap: numpy.ndarray,
             nobj: Integral,
             obj_wt: Optional[Union[numpy.ndarray,Real]] = None,
             obj_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             obj_trans_kwargs: Optional[dict] = None,
             nineqcv: Optional[Integral] = None,
             ineqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             ineqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
@@ -768,14 +793,15 @@
             Additional keyword arguments passed to the parent class (IntegerSelectionProblem) constructor.
         """
         super(OptimalHaploidValueIntegerSelectionProblem, self).__init__(
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
+            decn_space_xmap = decn_space_xmap,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
             obj_trans_kwargs = obj_trans_kwargs,
             nineqcv = nineqcv,
             ineqcv_wt = ineqcv_wt,
             ineqcv_trans = ineqcv_trans,
@@ -877,14 +903,15 @@
         # construct class
         out = cls(
             ohvmat = ohvmat,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
+            decn_space_xmap = xmap,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
             obj_trans_kwargs = obj_trans_kwargs,
             nineqcv = nineqcv,
             ineqcv_wt = ineqcv_wt,
             ineqcv_trans = ineqcv_trans,
@@ -894,26 +921,30 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class OptimalHaploidValueBinarySelectionProblem(OptimalHaploidValueSelectionProblemMixin,BinarySelectionProblem):
+class OptimalHaploidValueBinarySelectionProblem(
+        OptimalHaploidValueSelectionProblemMixin,
+        BinaryMateSelectionProblem,
+    ):
     """
     Class for representing Optimal Haploid Value (OHV) Selection problems in binary search spaces.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             ohvmat: numpy.ndarray,
             ndecn: Integral,
             decn_space: Union[numpy.ndarray,None],
             decn_space_lower: Union[numpy.ndarray,Real,None],
             decn_space_upper: Union[numpy.ndarray,Real,None],
+            decn_space_xmap: numpy.ndarray,
             nobj: Integral,
             obj_wt: Optional[Union[numpy.ndarray,Real]] = None,
             obj_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             obj_trans_kwargs: Optional[dict] = None,
             nineqcv: Optional[Integral] = None,
             ineqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             ineqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
@@ -986,14 +1017,15 @@
             Additional keyword arguments passed to the parent class (BinarySelectionProblem) constructor.
         """
         super(OptimalHaploidValueBinarySelectionProblem, self).__init__(
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
+            decn_space_xmap = decn_space_xmap,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
             obj_trans_kwargs = obj_trans_kwargs,
             nineqcv = nineqcv,
             ineqcv_wt = ineqcv_wt,
             ineqcv_trans = ineqcv_trans,
@@ -1095,14 +1127,15 @@
         # construct class
         out = cls(
             ohvmat = ohvmat,
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
+            decn_space_xmap = xmap,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
             obj_trans_kwargs = obj_trans_kwargs,
             nineqcv = nineqcv,
             ineqcv_wt = ineqcv_wt,
             ineqcv_trans = ineqcv_trans,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/OptimalPopulationValueSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/OptimalPopulationValueSelectionProblem.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,29 +2,39 @@
 Module implementing Optimal Population Value (OPV) Selection optimization problems.
 """
 
 __all__ = [
     "OptimalPopulationValueSubsetSelectionProblem",
 ]
 
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_python import check_is_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.util.haplo import haplobin, haplobin_bounds, nhaploblk_chrom
-from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel, check_is_AdditiveLinearGenomicModel
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
+from pybrops.core.util.haplo import haplobin
+from pybrops.core.util.haplo import haplobin_bounds
+from pybrops.core.util.haplo import nhaploblk_chrom
+from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
 
 
-class OptimalPopulationValueSelectionProblemMixin(metaclass=ABCMeta):
+class OptimalPopulationValueSelectionProblemMixin(
+        metaclass = ABCMeta,
+    ):
     """Helper class to implement properties common to OPV."""
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
     @property
@@ -144,15 +154,18 @@
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
         ) -> "OptimalPopulationValueSelectionProblemMixin":
         raise NotImplementedError("class method is abstract")
 
-class OptimalPopulationValueSubsetSelectionProblem(OptimalPopulationValueSelectionProblemMixin,SubsetSelectionProblem):
+class OptimalPopulationValueSubsetSelectionProblem(
+        OptimalPopulationValueSelectionProblemMixin,
+        SubsetSelectionProblem,
+    ):
     """
     docstring for SubsetOptimalPopulationValueSelectionProblem.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/RandomSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/RandomSelectionProblem.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,30 +5,39 @@
 __all__ = [
     "RandomSubsetSelectionProblem",
     "RandomRealSelectionProblem",
     "RandomIntegerSelectionProblem",
     "RandomBinarySelectionProblem",
 ]
 
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Number, Real
-from typing import Callable, Optional, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Number
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
 from pybrops.core.random.prng import global_prng
 from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
 from pybrops.breed.prot.sel.prob.IntegerSelectionProblem import IntegerSelectionProblem
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
 from pybrops.breed.prot.sel.prob.SelectionProblem import SelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
 from pybrops.core.error.error_type_numpy import check_is_ndarray
-from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_eq, check_ndarray_axis_len_gteq, check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_gteq
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 
 
-class RandomSelectionProblemMixin(metaclass=ABCMeta):
+class RandomSelectionProblemMixin(
+        metaclass = ABCMeta,
+    ):
     """Helper class containing common properties for random selection problems."""
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
     
@@ -76,15 +85,18 @@
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
         ) -> "RandomSelectionProblemMixin":
         raise NotImplementedError("class method is abstract")
 
-class RandomSubsetSelectionProblem(RandomSelectionProblemMixin,SubsetSelectionProblem):
+class RandomSubsetSelectionProblem(
+        RandomSelectionProblemMixin,
+        SubsetSelectionProblem,
+    ):
     """
     Class representing selection on Random Breeding Values (RBVs) in subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -285,15 +297,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class RandomRealSelectionProblem(RandomSelectionProblemMixin,RealSelectionProblem):
+class RandomRealSelectionProblem(
+        RandomSelectionProblemMixin,
+        RealSelectionProblem,
+    ):
     """
     Class representing selection on Random Breeding Values (RBVs) in real search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -493,15 +508,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class RandomIntegerSelectionProblem(RandomSelectionProblemMixin,IntegerSelectionProblem):
+class RandomIntegerSelectionProblem(
+        RandomSelectionProblemMixin,
+        IntegerSelectionProblem,
+    ):
     """
     Class representing selection on Random Breeding Values (RBVs) in integer search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -701,15 +719,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class RandomBinarySelectionProblem(RandomSelectionProblemMixin,BinarySelectionProblem):
+class RandomBinarySelectionProblem(
+        RandomSelectionProblemMixin,
+        BinarySelectionProblem,
+    ):
     """
     Class representing selection on Random Breeding Values (RBVs) in binary search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/RealLookAheadGeneralizedWeightedGenomicSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/RealLookAheadGeneralizedWeightedGenomicSelectionProblem.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,27 @@
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 
 import numpy
-from pybrops.breed.prot.mate.MatingProtocol import MatingProtocol, check_is_MatingProtocol
+from pybrops.breed.prot.mate.MatingProtocol import MatingProtocol
+from pybrops.breed.prot.mate.MatingProtocol import check_is_MatingProtocol
 from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
 from pybrops.core.error.error_type_python import check_is_Integral
-from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel, check_is_AdditiveLinearGenomicModel
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
+from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
 
 
-class RealLookAheadGeneralizedWeightedGenomicSelectionProblem(RealSelectionProblem):
+class RealLookAheadGeneralizedWeightedGenomicSelectionProblem(
+        RealSelectionProblem,
+    ):
     """
     docstring for RealLookAheadGeneralizedWeightedGenomicSelectionProblem.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/RealMateSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/BinaryMateSelectionProblem.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,18 +1,27 @@
-from numbers import Integral, Real
-from typing import Callable, Iterable, Optional, Sequence, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Iterable
+from typing import Optional
+from typing import Sequence
+from typing import Union
 import numpy
 from pybrops.breed.prot.sel.prob.MateSelectionProblem import MateSelectionProblem
-from pybrops.breed.prot.sel.prob.RealSelectionProblem import RealSelectionProblem
-from pymoo.core.problem import ElementwiseEvaluationFunction, LoopedElementwiseEvaluation
+from pybrops.breed.prot.sel.prob.BinarySelectionProblem import BinarySelectionProblem
+from pymoo.core.problem import ElementwiseEvaluationFunction
+from pymoo.core.problem import LoopedElementwiseEvaluation
 
 
-class RealMateSelectionProblem(RealSelectionProblem,MateSelectionProblem):
+class BinaryMateSelectionProblem(
+        BinarySelectionProblem,
+        MateSelectionProblem,
+    ):
     """
-    docstring for RealMateSelectionProblem.
+    docstring for BinaryMateSelectionProblem.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             ndecn: Integral,
             decn_space: Union[numpy.ndarray,None],
@@ -39,15 +48,15 @@
             replace_nan_values_by: Optional[Real] = None,
             exclude_from_serialization: Optional[Iterable] = None,
             callback: Optional[Callable] = None,
             strict: bool = True,
             **kwargs: dict
         ) -> None:
         """
-        Constructor for RealSelectionProblem.
+        Constructor for BinarySelectionProblem.
         
         Parameters
         ----------
         ndecn : Integral
             Number of decision variables.
         decn_space: numpy.ndarray, None
             An array of shape ``(2,ndecn)`` defining the decision space.
@@ -110,16 +119,16 @@
         exclude_from_serialization: Iterable, None
             Attributes which are excluded from being serialized. See PyMOO documentation.
         callback: Callable, None
             A callback function to be called after every evaluation. See PyMOO documentation.
         kwargs : dict
             Additional keyword arguments used for cooperative inheritance. See PyMOO documentation.
         """
-        # call the RealProblem constructor
-        super(RealMateSelectionProblem, self).__init__(
+        # call the BinaryProblem constructor
+        super(BinaryMateSelectionProblem, self).__init__(
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
             nobj = nobj,
             obj_wt = obj_wt,
             obj_trans = obj_trans,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/RealSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/BinarySelectionProblem.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,30 +1,39 @@
 """
 Module partially implementing the SetSelectionProblem interface.
 """
 
 # list of public objects in this module
 __all__ = [
-    "RealSelectionProblem",
-    "check_is_RealSelectionProblem",
+    "BinarySelectionProblem",
+    "check_is_BinarySelectionProblem",
 ]
 
 # imports
 import numpy
-from numbers import Integral, Real
-from typing import Callable, Iterable, Optional, Sequence, Union
-from pymoo.core.problem import ElementwiseEvaluationFunction, LoopedElementwiseEvaluation
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Iterable
+from typing import Optional
+from typing import Sequence
+from typing import Union
+from pymoo.core.problem import ElementwiseEvaluationFunction
+from pymoo.core.problem import LoopedElementwiseEvaluation
 
 from pybrops.breed.prot.sel.prob.SelectionProblem import SelectionProblem
-from pybrops.opt.prob.RealProblem import RealProblem
+from pybrops.opt.prob.BinaryProblem import BinaryProblem
 
 # inheritance ordering is important here to avoid circular dependency/method resolution issues
-class RealSelectionProblem(RealProblem,SelectionProblem):
+class BinarySelectionProblem(
+        BinaryProblem,
+        SelectionProblem,
+    ):
     """
-    Semi-abstract class representing selection problems in real search spaces.
+    Semi-abstract class representing selection problems in binary search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             ndecn: Integral,
             decn_space: Union[numpy.ndarray,None],
@@ -50,15 +59,15 @@
             replace_nan_values_by: Optional[Real] = None,
             exclude_from_serialization: Optional[Iterable] = None,
             callback: Optional[Callable] = None,
             strict: bool = True,
             **kwargs: dict
         ) -> None:
         """
-        Constructor for RealSelectionProblem.
+        Constructor for BinarySelectionProblem.
         
         Parameters
         ----------
         ndecn : Integral
             Number of decision variables.
         decn_space: numpy.ndarray, None
             An array of shape ``(2,ndecn)`` defining the decision space.
@@ -121,16 +130,16 @@
         callback: Callable, None
             A callback function to be called after every evaluation. See PyMOO documentation.
         strict : bool, default = True
             See PyMOO documentation.
         kwargs : dict
             Additional keyword arguments used for cooperative inheritance. See PyMOO documentation.
         """
-        # call the RealProblem constructor
-        super(RealSelectionProblem, self).__init__(
+        # call the BinaryProblem constructor
+        super(BinarySelectionProblem, self).__init__(
             ndecn = ndecn,
             decn_space = decn_space,
             decn_space_lower = decn_space_lower,
             decn_space_upper = decn_space_upper,
             nobj = nobj,
             obj_wt = obj_wt,
             nineqcv = nineqcv,
@@ -163,20 +172,20 @@
     # leave latentfn abstract
     # evalfn defined by SelectionProblem
     # _evaluate defined by SelectionProblem
 
 
 
 ################################## Utilities ###################################
-def check_is_RealSelectionProblem(v: object, vname: str) -> None:
+def check_is_BinarySelectionProblem(v: object, vname: str) -> None:
     """
-    Check if object is of type RealSelectionProblem, otherwise raise TypeError.
+    Check if object is of type BinarySelectionProblem, otherwise raise TypeError.
 
     Parameters
     ----------
     v : object
         Any Python object to test.
     vname : str
         Name of variable to print in TypeError message.
     """
-    if not isinstance(v, RealSelectionProblem):
-        raise TypeError("'{0}' must be of type RealSelectionProblem.".format(vname))
+    if not isinstance(v, BinarySelectionProblem):
+        raise TypeError("'{0}' must be of type BinarySelectionProblem.".format(vname))
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/SelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/SelectionProblem.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,24 +5,32 @@
 # list of public objects in this module
 __all__ = [
     "SelectionProblem",
     "check_is_SelectionProblem",
 ]
 
 # imports
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from numbers import Integral
-from typing import Callable, Tuple, Union
+from typing import Callable
+from typing import Tuple
+from typing import Union
 import numpy
-from pybrops.breed.prot.sel.prob.trans import trans_empty, trans_identity
-from pybrops.core.error.error_type_python import check_is_Callable, check_is_dict
+from pybrops.breed.prot.sel.prob.trans import trans_empty
+from pybrops.breed.prot.sel.prob.trans import trans_identity
+from pybrops.core.error.error_type_python import check_is_Callable
+from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.opt.prob.Problem import Problem
 
 # inheritance order is important for method resolution order
-class SelectionProblem(Problem,metaclass=ABCMeta):
+class SelectionProblem(
+        Problem,
+        metaclass = ABCMeta,
+    ):
     """
     A semi-abstract, mixin-esque class for defining the basal interface for 
     selection problems.
 
     All selection optimization problems have the form:
 
     .. math::
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/SubsetMateSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/SubsetMateSelectionProblem.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,16 +1,25 @@
-from numbers import Integral, Real
-from typing import Callable, Iterable, Optional, Sequence, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Iterable
+from typing import Optional
+from typing import Sequence
+from typing import Union
 import numpy
 from pybrops.breed.prot.sel.prob.MateSelectionProblem import MateSelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetSelectionProblem import SubsetSelectionProblem
-from pymoo.core.problem import ElementwiseEvaluationFunction, LoopedElementwiseEvaluation
+from pymoo.core.problem import ElementwiseEvaluationFunction
+from pymoo.core.problem import LoopedElementwiseEvaluation
 
 
-class SubsetMateSelectionProblem(SubsetSelectionProblem,MateSelectionProblem):
+class SubsetMateSelectionProblem(
+        SubsetSelectionProblem,
+        MateSelectionProblem,
+    ):
     """
     docstring for SubsetMateSelectionProblem.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/SubsetSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/SubsetSelectionProblem.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,24 +6,33 @@
 __all__ = [
     "SubsetSelectionProblem",
     "check_is_SubsetSelectionProblem",
 ]
 
 # imports
 import numpy
-from numbers import Integral, Real
-from typing import Callable, Iterable, Optional, Sequence, Union
-from pymoo.core.problem import ElementwiseEvaluationFunction, LoopedElementwiseEvaluation
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Iterable
+from typing import Optional
+from typing import Sequence
+from typing import Union
+from pymoo.core.problem import ElementwiseEvaluationFunction
+from pymoo.core.problem import LoopedElementwiseEvaluation
 
 from pybrops.breed.prot.sel.prob.SelectionProblem import SelectionProblem
 from pybrops.opt.prob.SubsetProblem import SubsetProblem
 
 # inheritance ordering is important here to avoid method resolution issues
 # SelectionProblem functions as a semi-abstract/mixin-esque class and must go second
-class SubsetSelectionProblem(SubsetProblem,SelectionProblem):
+class SubsetSelectionProblem(
+        SubsetProblem,
+        SelectionProblem,
+    ):
     """
     Semi-abstract class representing selection problems in subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/UsefulnessCriterionSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/UsefulnessCriterionSelectionProblem.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,32 +1,47 @@
 """
 Module implementing Usefulness Criterion (UC) Selection problems.
 """
 
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Real
-from typing import Callable, Optional, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 import numpy
 import scipy.stats
 from pybrops.breed.prot.sel.prob.BinaryMateSelectionProblem import BinaryMateSelectionProblem
 from pybrops.breed.prot.sel.prob.IntegerMateSelectionProblem import IntegerMateSelectionProblem
 from pybrops.breed.prot.sel.prob.RealMateSelectionProblem import RealMateSelectionProblem
 from pybrops.breed.prot.sel.prob.SubsetMateSelectionProblem import SubsetMateSelectionProblem
 from pybrops.core.error.error_type_numpy import check_is_ndarray
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_Real, check_is_bool
-from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_eq, check_ndarray_axis_len_gteq, check_ndarray_ndim
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_Real
+from pybrops.core.error.error_type_python import check_is_bool
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_gteq
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.core.error.error_value_python import check_is_in_interval_inclusive
-from pybrops.core.util.arrayix import triudix, triuix
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
-from pybrops.model.vmat.fcty.GeneticVarianceMatrixFactory import GeneticVarianceMatrixFactory, check_is_GeneticVarianceMatrixFactory
-from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction, check_is_GeneticMapFunction
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
+from pybrops.core.util.array import triudix
+from pybrops.core.util.array import triuix
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
+from pybrops.model.vmat.fcty.GeneticVarianceMatrixFactory import GeneticVarianceMatrixFactory
+from pybrops.model.vmat.fcty.GeneticVarianceMatrixFactory import check_is_GeneticVarianceMatrixFactory
+from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
+from pybrops.popgen.gmap.GeneticMapFunction import check_is_GeneticMapFunction
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
 
 
-class UsefulnessCriterionSelectionProblemMixin(metaclass=ABCMeta):
+class UsefulnessCriterionSelectionProblemMixin(
+        metaclass = ABCMeta,
+    ):
     """Mixin class containing properties common to UC selection problems."""
 
     ########################## Special Object Methods ##########################
     # __init__() CANNOT be defined to be classified as a Mixin class
 
     ############################ Object Properties #############################
 
@@ -202,15 +217,18 @@
             eqcv_wt: Optional[Union[numpy.ndarray,Real]] = None,
             eqcv_trans: Optional[Callable[[numpy.ndarray,numpy.ndarray,dict],numpy.ndarray]] = None,
             eqcv_trans_kwargs: Optional[dict] = None,
             **kwargs: dict
         ) -> "UsefulnessCriterionSelectionProblemMixin":
         raise NotImplementedError("class method is abstract")
 
-class UsefulnessCriterionBinaryMateSelectionProblem(UsefulnessCriterionSelectionProblemMixin,BinaryMateSelectionProblem):
+class UsefulnessCriterionBinaryMateSelectionProblem(
+        UsefulnessCriterionSelectionProblemMixin,
+        BinaryMateSelectionProblem,
+    ):
     """
     Class representing Usefulness Criterion (UC) selection problems in subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -541,15 +559,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class UsefulnessCriterionIntegerMateSelectionProblem(UsefulnessCriterionSelectionProblemMixin,IntegerMateSelectionProblem):
+class UsefulnessCriterionIntegerMateSelectionProblem(
+        UsefulnessCriterionSelectionProblemMixin,
+        IntegerMateSelectionProblem,
+    ):
     """
     Class representing Usefulness Criterion (UC) selection problems in integer search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -880,15 +901,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class UsefulnessCriterionRealMateSelectionProblem(UsefulnessCriterionSelectionProblemMixin,RealMateSelectionProblem):
+class UsefulnessCriterionRealMateSelectionProblem(
+        UsefulnessCriterionSelectionProblemMixin,
+        RealMateSelectionProblem,
+    ):
     """
     Class representing Usefulness Criterion (UC) selection problems in real search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -1219,15 +1243,18 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class UsefulnessCriterionSubsetMateSelectionProblem(UsefulnessCriterionSelectionProblemMixin,SubsetMateSelectionProblem):
+class UsefulnessCriterionSubsetMateSelectionProblem(
+        UsefulnessCriterionSelectionProblemMixin,
+        SubsetMateSelectionProblem,
+    ):
     """
     Class representing Usefulness Criterion (UC) selection problems in subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/WeightedGenomicSelectionProblem.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/WeightedGenomicSelectionProblem.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,23 +5,32 @@
 __all__ = [
     "WeightedGenomicBinarySelectionProblem",
     "WeightedGenomicIntegerSelectionProblem",
     "WeightedGenomicRealSelectionProblem",
     "WeightedGenomicSubsetSelectionProblem",
 ]
 
-from numbers import Integral, Number, Real
-from typing import Callable, Optional, Union
+from numbers import Integral
+from numbers import Number
+from numbers import Real
+from typing import Callable
+from typing import Optional
+from typing import Union
 import numpy
-from pybrops.breed.prot.sel.prob.GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblem import GeneralizedWeightedGenomicEstimatedBreedingValueBinarySelectionProblem, GeneralizedWeightedGenomicEstimatedBreedingValueIntegerSelectionProblem, GeneralizedWeightedGenomicEstimatedBreedingValueRealSelectionProblem, GeneralizedWeightedGenomicEstimatedBreedingValueSubsetSelectionProblem
+from pybrops.breed.prot.sel.prob.GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblem import GeneralizedWeightedGenomicEstimatedBreedingValueBinarySelectionProblem
+from pybrops.breed.prot.sel.prob.GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblem import GeneralizedWeightedGenomicEstimatedBreedingValueIntegerSelectionProblem
+from pybrops.breed.prot.sel.prob.GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblem import GeneralizedWeightedGenomicEstimatedBreedingValueRealSelectionProblem
+from pybrops.breed.prot.sel.prob.GeneralizedWeightedGenomicEstimatedBreedingValueSelectionProblem import GeneralizedWeightedGenomicEstimatedBreedingValueSubsetSelectionProblem
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
 
-class WeightedGenomicSubsetSelectionProblem(GeneralizedWeightedGenomicEstimatedBreedingValueSubsetSelectionProblem):
+class WeightedGenomicSubsetSelectionProblem(
+        GeneralizedWeightedGenomicEstimatedBreedingValueSubsetSelectionProblem,
+    ):
     """
     docstring for SubsetWeightedGenomicSelectionProblem.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             wgebv: numpy.ndarray,
@@ -224,15 +233,17 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class WeightedGenomicRealSelectionProblem(GeneralizedWeightedGenomicEstimatedBreedingValueRealSelectionProblem):
+class WeightedGenomicRealSelectionProblem(
+        GeneralizedWeightedGenomicEstimatedBreedingValueRealSelectionProblem,
+    ):
     """
     docstring for RealWeightedGenomicSelectionProblem.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             wgebv: numpy.ndarray,
@@ -435,15 +446,17 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class WeightedGenomicIntegerSelectionProblem(GeneralizedWeightedGenomicEstimatedBreedingValueIntegerSelectionProblem):
+class WeightedGenomicIntegerSelectionProblem(
+        GeneralizedWeightedGenomicEstimatedBreedingValueIntegerSelectionProblem,
+    ):
     """
     docstring for IntegerWeightedGenomicSelectionProblem.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             wgebv: numpy.ndarray,
@@ -646,15 +659,17 @@
             eqcv_trans = eqcv_trans,
             eqcv_trans_kwargs = eqcv_trans_kwargs,
             **kwargs
         )
 
         return out
 
-class WeightedGenomicBinarySelectionProblem(GeneralizedWeightedGenomicEstimatedBreedingValueBinarySelectionProblem):
+class WeightedGenomicBinarySelectionProblem(
+        GeneralizedWeightedGenomicEstimatedBreedingValueBinarySelectionProblem,
+    ):
     """
     docstring for BinaryWeightedGenomicSelectionProblem.
     """
     ########################## Special Object Methods ##########################
     def __init__(
             self,
             wgebv: numpy.ndarray,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/__init__.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/__init__.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/prob/trans.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/prob/trans.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/soln/BinaryMateSelectionSolution.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/soln/BinaryMateSelectionSolution.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,19 +1,23 @@
 """
 Module containing
 """
 
-from numbers import Integral, Real
+from numbers import Integral
+from numbers import Real
 from typing import Union
 import numpy
 from pybrops.breed.prot.sel.soln.MateSelectionSolution import MateSelectionSolution
 from pybrops.breed.prot.sel.soln.BinarySelectionSolution import BinarySelectionSolution
 
 
-class BinaryMateSelectionSolution(BinarySelectionSolution,MateSelectionSolution):
+class BinaryMateSelectionSolution(
+        BinarySelectionSolution,
+        MateSelectionSolution,
+    ):
     """
     Class representing mate selection solutions in subset search spaces.
     """
     
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/soln/BinarySelectionSolution.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/soln/BinarySelectionSolution.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,18 @@
 __all__ = [
     "BinarySelectionSolution",
 ]
 
 from pybrops.breed.prot.sel.soln.SelectionSolution import SelectionSolution
 from pybrops.opt.soln.BinarySolution import BinarySolution
 
-class BinarySelectionSolution(BinarySolution,SelectionSolution):
+class BinarySelectionSolution(
+        BinarySolution,
+        SelectionSolution,
+    ):
     """
     Class representing subset selection solutions.
     """
     # use implementation from BinarySolution
     pass
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/soln/IntegerMateSelectionSolution.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/soln/IntegerMateSelectionSolution.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,19 +1,23 @@
 """
 Module containing
 """
 
-from numbers import Integral, Real
+from numbers import Integral
+from numbers import Real
 from typing import Union
 import numpy
 from pybrops.breed.prot.sel.soln.MateSelectionSolution import MateSelectionSolution
 from pybrops.breed.prot.sel.soln.IntegerSelectionSolution import IntegerSelectionSolution
 
 
-class IntegerMateSelectionSolution(IntegerSelectionSolution,MateSelectionSolution):
+class IntegerMateSelectionSolution(
+        IntegerSelectionSolution,
+        MateSelectionSolution,
+    ):
     """
     Class representing mate selection solutions in subset search spaces.
     """
     
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/soln/IntegerSelectionSolution.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/soln/IntegerSelectionSolution.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,15 +1,18 @@
 __all__ = [
     "IntegerSelectionSolution",
 ]
 
 from pybrops.breed.prot.sel.soln.SelectionSolution import SelectionSolution
 from pybrops.opt.soln.IntegerSolution import IntegerSolution
 
-class IntegerSelectionSolution(IntegerSolution,SelectionSolution):
+class IntegerSelectionSolution(
+        IntegerSolution,
+        SelectionSolution,
+    ):
     """
     Class representing subset selection solutions.
     """
     # use implementation from IntegerSolution
     pass
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/soln/MateSelectionSolution.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/soln/MateSelectionSolution.py`

 * *Files 8% similar despite different names*

```diff
@@ -3,19 +3,23 @@
 """
 
 from abc import ABCMeta
 
 import numpy
 
 from pybrops.breed.prot.sel.soln.SelectionSolution import SelectionSolution
-from pybrops.core.error.error_type_numpy import check_is_ndarray, check_ndarray_dtype_is_integer
+from pybrops.core.error.error_type_numpy import check_is_ndarray
+from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_integer
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 
 
-class MateSelectionSolution(SelectionSolution,metaclass=ABCMeta):
+class MateSelectionSolution(
+        SelectionSolution,
+        metaclass = ABCMeta,
+    ):
     """
     Semi-abstract interface 
     """
     ########################## Special Object Methods ##########################
     # do not implement __init__()
 
     ############################ Object Properties #############################
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/soln/RealMateSelectionSolution.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/soln/RealMateSelectionSolution.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,23 @@
 """
 Module containing
 """
 
-from numbers import Integral, Real
+from numbers import Integral
+from numbers import Real
 from typing import Union
 import numpy
 from pybrops.breed.prot.sel.soln.MateSelectionSolution import MateSelectionSolution
 from pybrops.breed.prot.sel.soln.RealSelectionSolution import RealSelectionSolution
 
 
-class RealMateSelectionSolution(RealSelectionSolution,MateSelectionSolution):
+class RealMateSelectionSolution(
+        RealSelectionSolution,
+        MateSelectionSolution,
+    ):
     """
     Class representing mate selection solutions in subset search spaces.
     """
     
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/soln/RealSelectionSolution.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/soln/RealSelectionSolution.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,18 @@
 __all__ = [
     "RealSelectionSolution",
 ]
 
 from pybrops.breed.prot.sel.soln.SelectionSolution import SelectionSolution
 from pybrops.opt.soln.RealSolution import RealSolution
 
-class RealSelectionSolution(RealSolution,SelectionSolution):
+class RealSelectionSolution(
+        RealSolution,
+        SelectionSolution,
+    ):
     """
     Class representing subset selection solutions.
     """
     # use implementation from RealSolution
     pass
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/soln/SelectionSolution.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/soln/SelectionSolution.py`

 * *Files 12% similar despite different names*

```diff
@@ -6,15 +6,18 @@
     "SelectionSolution",
 ]
 
 from abc import ABCMeta
 from pybrops.opt.soln.Solution import Solution
 
 
-class SelectionSolution(Solution,metaclass=ABCMeta):
+class SelectionSolution(
+        Solution,
+        metaclass = ABCMeta,
+    ):
     """
     Class representing selection solutions.
     """
     # interface identical to Solution interface
     pass
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/soln/SubsetMateSelectionSolution.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/soln/SubsetMateSelectionSolution.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,19 +1,23 @@
 """
 Module containing
 """
 
-from numbers import Integral, Real
+from numbers import Integral
+from numbers import Real
 from typing import Union
 import numpy
 from pybrops.breed.prot.sel.soln.MateSelectionSolution import MateSelectionSolution
 from pybrops.breed.prot.sel.soln.SubsetSelectionSolution import SubsetSelectionSolution
 
 
-class SubsetMateSelectionSolution(SubsetSelectionSolution,MateSelectionSolution):
+class SubsetMateSelectionSolution(
+        SubsetSelectionSolution,
+        MateSelectionSolution,
+    ):
     """
     Class representing mate selection solutions in subset search spaces.
     """
     
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/soln/SubsetSelectionSolution.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/soln/SubsetSelectionSolution.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,15 +1,18 @@
 __all__ = [
     "SubsetSelectionSolution",
 ]
 
 from pybrops.breed.prot.sel.soln.SelectionSolution import SelectionSolution
 from pybrops.opt.soln.SubsetSolution import SubsetSolution
 
-class SubsetSelectionSolution(SubsetSolution,SelectionSolution):
+class SubsetSelectionSolution(
+        SubsetSolution,
+        SelectionSolution,
+    ):
     """
     Class representing subset selection solutions.
     """
     # use implementation from SubsetSolution
     pass
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/soln/__init__.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/soln/__init__.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/targetfn.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/targetfn.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/transfn.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/transfn.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 """
 Module containing functions for transforming objective function outputs.
 """
 
 from numbers import Real
 import numpy
-from typing import Tuple, Union
+from typing import Tuple
+from typing import Union
 
 __all__ = [
     "trans_ndpt_to_vec_dist", 
     "trans_sum", 
     "trans_dot", 
     "trans_flatten",
 ]
```

### Comparing `pybrops-1.0.2/pybrops/breed/prot/sel/weightfn.py` & `pybrops-1.0.3/pybrops/breed/prot/sel/weightfn.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/core/__init__.py` & `pybrops-1.0.3/pybrops/core/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -25,12 +25,12 @@
 
 # utility functions
 from pybrops.core import util
 
 # random number generator interface
 from pybrops.core import random
 
-# input/output interfaces
+# input/output interfaces: must be imported before ``mat``
 from pybrops.core import io
 
 # base matrix interfaces
 from pybrops.core import mat
```

### Comparing `pybrops-1.0.2/pybrops/core/error/__init__.py` & `pybrops-1.0.3/pybrops/core/error/__init__.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/core/error/error_attr_python.py` & `pybrops-1.0.3/pybrops/core/error/error_attr_python.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/core/error/error_generic_numpy.py` & `pybrops-1.0.3/pybrops/core/error/error_generic_numpy.py`

 * *Files 1% similar despite different names*

```diff
@@ -9,15 +9,17 @@
     "generic_check_ndarray_size",
     "generic_check_ndarray_sum",
     "generic_check_ndarray_shape",
     "generic_check_ndarray_is_square",
 ]
 
 from numbers import Real
-from typing import Optional, Tuple, Union
+from typing import Optional
+from typing import Tuple
+from typing import Union
 import numpy
 
 ################################################################################
 ########################### ndarray check functions ############################
 ################################################################################
 def generic_check_ndarray_eq(v: numpy.ndarray, vname: str, w: object, wname: str) -> None:
     """
```

### Comparing `pybrops-1.0.2/pybrops/core/error/error_generic_python.py` & `pybrops-1.0.3/pybrops/core/error/error_generic_python.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/core/error/error_io_python.py` & `pybrops-1.0.3/pybrops/core/error/error_io_python.py`

 * *Files 23% similar despite different names*

```diff
@@ -4,45 +4,48 @@
 
 __all__ = [
     "check_path_exists",
     "check_file_exists",
     "check_directory_exists",
 ]
 
-from os.path import exists, isfile
+from os.path import exists
+from os.path import isfile
+from pathlib import Path
+from typing import Union
 
-def check_path_exists(path: str) -> None:
+def check_path_exists(path: Union[str,Path]) -> None:
     """
     Subroutine to check whether a given path exists.
     If the path does not exist, raise an FileNotFoundError with a custom error
     message.
 
     Parameters
     ----------
     path : str, path-like object
         Path to check.
     """
     if not exists(path):
         raise FileNotFoundError("{0} does not exist".format(path))
 
-def check_file_exists(path: str) -> None:
+def check_file_exists(path: Union[str,Path]) -> None:
     """
     Subroutine to check whether a given file exists.
     If the file does not exist, raise an FileNotFoundError with a custom error
     message.
 
     Parameters
     ----------
     path : str, path-like object
         Path to check.
     """
     if not isfile(path):
         raise FileNotFoundError("{0} does not exist".format(path))
 
-def check_directory_exists(path: str) -> None:
+def check_directory_exists(path: Union[str,Path]) -> None:
     """
     Subroutine to check whether a given directory exists.
     If the directory does not exist, raise an NotADirectoryError with a custom
     error message.
 
     Parameters
     ----------
```

### Comparing `pybrops-1.0.2/pybrops/core/error/error_type_h5py.py` & `pybrops-1.0.3/pybrops/core/error/error_type_h5py.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/core/error/error_type_numpy.py` & `pybrops-1.0.3/pybrops/core/error/error_type_numpy.py`

 * *Files 0% similar despite different names*

```diff
@@ -28,17 +28,20 @@
     "check_ndarray_dtype_is_unicode",
     "check_ndarray_dtype_is_bool_or_integer",
     "check_ndarray_dtype_is_bool_or_number",
     "check_ndarray_dtype_is_integer_or_floating",
     "check_ndarray_dtype_is_object_or_string",
 ]
 
-from numbers import Integral, Number, Real
+from numbers import Integral
+from numbers import Number
+from numbers import Real
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from typing import Union
 
 ################################################################################
 ########################## isinstance check functions ##########################
 ################################################################################
 def check_is_str_or_ndarray(v: object, vname: str) -> None:
     """
```

### Comparing `pybrops-1.0.2/pybrops/core/error/error_type_pandas.py` & `pybrops-1.0.3/pybrops/core/error/error_type_pandas.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/core/error/error_type_python.py` & `pybrops-1.0.3/pybrops/core/error/error_type_python.py`

 * *Files 1% similar despite different names*

```diff
@@ -27,16 +27,21 @@
     "check_is_Sequence",
     "check_is_array_like",
     "check_is_str_or_iterable",
     "check_is_list_or_tuple",
 ]
 
 import math
-from numbers import Complex, Integral, Number, Real
-from typing import Callable, Container, Sequence
+from numbers import Complex
+from numbers import Integral
+from numbers import Number
+from numbers import Real
+from typing import Callable, Tuple
+from typing import Container
+from typing import Sequence
 from typing import Union
 import inspect
 
 ################################################################################
 ###################### basic inheritance check functions #######################
 ################################################################################
 def check_inherits(v: object, vname: str, vtype: type) -> None:
@@ -523,16 +528,16 @@
         Name associated with the Python object.
     """
     if (v is not None) and (not isinstance(v, Integral)):
         raise TypeError("variable '{0}' must be of type '{1}' or the value 'None' but received type '{2}'".format(vname,Integral.__name__,type(v).__name__))
 
 ### Iterating type checks ###
 
-def check_Sequence_all_type(v: Sequence, vname: str, vtype: Union[type,tuple]) -> None:
+def check_Sequence_all_type(v: Sequence, vname: str, vtype: Union[type,Tuple[type]]) -> None:
     if not all(isinstance(e, vtype) for e in v):
         raise TypeError(
             "Sequence '{0}' must have values all of type '{1}'".format(
                 vname,
-                vtype.__name__
+                vtype.__name__ if isinstance(vtype, type) else tuple(e.__name__ for e in vtype)
             )
         )
```

### Comparing `pybrops-1.0.2/pybrops/core/error/error_value_numpy.py` & `pybrops-1.0.3/pybrops/core/error/error_value_numpy.py`

 * *Files 0% similar despite different names*

```diff
@@ -25,14 +25,15 @@
     "check_ndarray_axis_len_gteq",
     "check_ndarray_is_hypercube",
     "check_ndarray_is_square",
     "check_ndarray_is_triu",
     "check_ndarray_len_is_multiple_of",
 ]
 from numbers import Real
+from typing import Tuple
 import numpy
 
 from pybrops.core.error.error_generic_numpy import generic_check_ndarray_shape
 
 ################################################################################
 ############################### check functions ################################
 ################################################################################
@@ -49,15 +50,15 @@
         Name of the ``numpy.ndarray`` variable.
     value : object
         A required value that the ``numpy.ndarray`` must contain.
     """
     if value not in v:
         raise ValueError("numpy.ndarray '{0}' must have value '{1}'".format(vname,value))
 
-def check_ndarray_has_values(v: numpy.ndarray, vname: str, *args: tuple[object]) -> None:
+def check_ndarray_has_values(v: numpy.ndarray, vname: str, *args: Tuple[object,...]) -> None:
     """
     Check if a ``numpy.ndarray`` contains all required values.
 
     Parameters
     ----------
     v : numpy.ndarray
         Input ``numpy.ndarray``.
```

### Comparing `pybrops-1.0.2/pybrops/core/error/error_value_pandas.py` & `pybrops-1.0.3/pybrops/core/error/error_value_pandas.py`

 * *Files 4% similar despite different names*

```diff
@@ -4,14 +4,15 @@
 
 __all__ = [
     "check_pandas_DataFrame_has_column",
     "check_pandas_DataFrame_has_columns",
 ]
     
 from numbers import Integral
+from typing import Tuple
 import pandas
 
 
 ##################################################
 ########### DataFrame check functions ############
 ##################################################
 
@@ -27,15 +28,15 @@
         Name of the ``pandas.DataFrame`` variable.
     column : object
         A required column that the ``pandas.DataFrame`` must contain.
     """
     if column not in df.columns:
         raise ValueError("pandas.DataFrame '{0}' must have column '{1}'".format(dfname,column))
 
-def check_pandas_DataFrame_has_columns(df: pandas.DataFrame, dfname: str, *args: tuple[str]) -> None:
+def check_pandas_DataFrame_has_columns(df: pandas.DataFrame, dfname: str, *args: Tuple[str,...]) -> None:
     """
     Check if a ``pandas.DataFrame`` contains all required columns.
 
     Parameters
     ----------
     df : pandas.DataFrame
         Input ``pandas.DataFrame``.
@@ -60,15 +61,15 @@
         Name of the ``pandas.DataFrame`` variable.
     ix : object
         A required column index that the ``pandas.DataFrame`` must contain.
     """
     if (ix < 0) or (len(df.columns) <= ix):
         raise ValueError("pandas.DataFrame '{0}' must have column index '{1}'".format(dfname,ix))
 
-def check_pandas_DataFrame_has_column_indices(df: pandas.DataFrame, dfname: str, *args: tuple[Integral]) -> None:
+def check_pandas_DataFrame_has_column_indices(df: pandas.DataFrame, dfname: str, *args: Tuple[Integral,...]) -> None:
     """
     Check if a ``pandas.DataFrame`` contains a required column indices.
 
     Parameters
     ----------
     df : pandas.DataFrame
         Input ``pandas.DataFrame``.
@@ -97,15 +98,15 @@
         Name of the ``pandas.Series`` variable.
     value : object
         A required value that the ``pandas.Series`` must contain.
     """
     if value not in v:
         raise ValueError("pandas.Series '{0}' must have value '{1}'".format(vname,value))
 
-def check_pandas_Series_has_values(v: pandas.Series, vname: str, *args: tuple[str]) -> None:
+def check_pandas_Series_has_values(v: pandas.Series, vname: str, *args: Tuple[str,...]) -> None:
     """
     Check if a ``pandas.Series`` contains all required values.
 
     Parameters
     ----------
     v : Series
         Input ``pandas.Series``.
@@ -130,15 +131,15 @@
         Name of the ``pandas.Series`` variable.
     ix : object
         A required index that the ``pandas.Series`` must contain.
     """
     if (ix < 0) or (len(v) <= ix):
         raise ValueError("pandas.Series '{0}' must have index '{1}'".format(vname,ix))
 
-def check_pandas_Series_has_indices(v: pandas.Series, vname: str, *args: tuple[Integral]) -> None:
+def check_pandas_Series_has_indices(v: pandas.Series, vname: str, *args: Tuple[Integral,...]) -> None:
     """
     Check if a ``pandas.Series`` contains required indices.
 
     Parameters
     ----------
     v : Series
         Input ``pandas.Series``.
```

### Comparing `pybrops-1.0.2/pybrops/core/error/error_value_python.py` & `pybrops-1.0.3/pybrops/core/error/error_value_python.py`

 * *Files 1% similar despite different names*

```diff
@@ -18,15 +18,16 @@
     "check_dict_keys_all_type",
     "check_dict_values_all_type",
     "check_dict_values_have_equal_len",
     "check_dict_values_len_eq",
 ]
 
 from numbers import Integral
-from typing import Sequence, Tuple
+from typing import Sequence
+from typing import Tuple
 
 ################################################################################
 ############################### check functions ################################
 ################################################################################
 def check_is_not_None(v: object, vname: str) -> None:
     """
     Check if an object is not None.
@@ -334,15 +335,15 @@
     if any(len(e) != vlen for e in viter):
         raise ValueError("not all values in dict '{0}' have length == {1}".format(vname, vlen))
 
 ##################################################
 ############# String check functions #############
 ##################################################
 
-def check_str_value(v: str, vname: str, *args: tuple[str]) -> None:
+def check_str_value(v: str, vname: str, *args: Tuple[str]) -> None:
     """
     Check if a string has an accepted value:
 
     Parameters
     ----------
     v : str
         Input string.
@@ -397,15 +398,15 @@
         Name of the ``Sequence`` variable.
     value : object
         A required value that the ``Sequence`` must contain.
     """
     if value not in v:
         raise ValueError("Sequence '{0}' must have value '{1}'".format(vname,value))
 
-def check_Sequence_has_values(v: Sequence, vname: str, *args: tuple[str]) -> None:
+def check_Sequence_has_values(v: Sequence, vname: str, *args: Tuple[str]) -> None:
     """
     Check if a ``Sequence`` contains all required values.
 
     Parameters
     ----------
     v : Sequence
         Input ``Sequence``.
@@ -430,15 +431,15 @@
         Name of the ``Sequence`` variable.
     ix : object
         A required index that the ``Sequence`` must contain.
     """
     if (ix < 0) or (len(v) <= ix):
         raise ValueError("Sequence '{0}' must have index '{1}'".format(vname,ix))
 
-def check_Sequence_has_indices(v: Sequence, vname: str, *args: tuple[Integral]) -> None:
+def check_Sequence_has_indices(v: Sequence, vname: str, *args: Tuple[Integral]) -> None:
     """
     Check if a ``Sequence`` contains required indices.
 
     Parameters
     ----------
     v : Sequence
         Input ``Sequence``.
```

### Comparing `pybrops-1.0.2/pybrops/core/io/CSVDictInputOutput.py` & `pybrops-1.0.3/pybrops/core/io/CSVDictInputOutput.py`

 * *Files 16% similar despite different names*

```diff
@@ -4,19 +4,21 @@
 """
 
 __all__ = [
     "CSVDictInputOutput",
     "check_is_CSVDictInputOutput",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from typing import Dict
 
-
-class CSVDictInputOutput(metaclass=ABCMeta):
+class CSVDictInputOutput(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class for defining CSV input/output functionality.
 
     This abstract class defines two functions with the following purposes:
 
     - ``to_csv_dict`` - write an object to a csv file.
     - ``from_csv_dict`` - load an object from a csv file.
```

### Comparing `pybrops-1.0.2/pybrops/core/io/CSVInputOutput.py` & `pybrops-1.0.3/pybrops/core/io/CSVInputOutput.py`

 * *Files 15% similar despite different names*

```diff
@@ -4,18 +4,20 @@
 """
 
 __all__ = [
     "CSVInputOutput",
     "check_is_CSVInputOutput",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 
-
-class CSVInputOutput(metaclass=ABCMeta):
+class CSVInputOutput(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class for defining CSV input/output functionality.
 
     This abstract class defines two functions with the following purposes:
 
     - ``to_csv`` - write an object to a csv file.
     - ``from_csv`` - load an object from a csv file.
```

### Comparing `pybrops-1.0.2/pybrops/core/io/DictInputOutput.py` & `pybrops-1.0.3/pybrops/core/io/DictInputOutput.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,17 +4,20 @@
 """
 
 __all__ = [
     "DictInputOutput",
     "check_is_DictInputOutput",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 
-class DictInputOutput(metaclass=ABCMeta):
+class DictInputOutput(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class for defining ``dict`` input/output functionality.
 
     This abstract class defines two functions with the following purposes:
 
     - ``to_dict`` - export an object to a ``dict``.
     - ``from_dict`` - load an object from a ``dict``.
```

### Comparing `pybrops-1.0.2/pybrops/core/io/HDF5InputOutput.py` & `pybrops-1.0.3/pybrops/core/io/PandasDictInputOutput.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,91 +1,104 @@
 """
-Module defining HDF5 I/O interfaces and associated error checking routines.
+Module defining pandas dictionary I/O interfaces and associated error
+checking routines.
 """
 
 __all__ = [
-    "HDF5InputOutput",
-    "check_is_HDF5InputOutput",
+    "PandasDictInputOutput",
+    "check_is_PandasDictInputOutput",
 ]
 
-from abc import ABCMeta, abstractmethod
-from typing import Optional
-
-
-class HDF5InputOutput(metaclass=ABCMeta):
+from abc import ABCMeta
+from abc import abstractmethod
+from typing import Dict
+
+import pandas
+
+class PandasDictInputOutput(
+        metaclass = ABCMeta,
+    ):
     """
-    Abstract class for defining HDF5 input/output functionality.
+    Abstract class for defining pandas dictionary input/output functionality.
 
     This abstract class defines two functions with the following purposes:
 
-    - ``to_hdf5`` - write an object to an HDF5 file.
-    - ``from_hdf5`` - load an object from an HDF5 file.
+    - ``to_pandas_dict`` - export an object to a ``dict`` of ``pandas.DataFrame``.
+    - ``from_pandas_dict`` - load an object from a ``dict`` of ``pandas.DataFrame``.
     """
 
     ########################## Special Object Methods ##########################
 
     ############################## Object Methods ##############################
 
-    ################### Matrix File I/O ####################
+    ####################### File I/O #######################
     @abstractmethod
-    def to_hdf5(
+    def to_pandas_dict(
             self, 
-            filename: str, 
-            groupname: Optional[str]
-        ) -> None:
+            **kwargs: dict
+        ) -> Dict[str,pandas.DataFrame]:
         """
-        Write an object to an HDF5 file.
+        Export an object to a ``dict`` of ``pandas.DataFrame``.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name to which to write.
-        groupname : str or None
-            HDF5 group name under which object data is stored.
-            If None, object is written to the base HDF5 group.
+        kwargs : dict
+            Additional keyword arguments to use for dictating export to a 
+            ``dict`` of ``pandas.DataFrame``.
+        
+        Returns
+        -------
+        out : dict
+            An output dataframe.
         """
         raise NotImplementedError("method is abstract")
 
     ############################## Class Methods ###############################
 
-    ################### Matrix File I/O ####################
+    ####################### File I/O #######################
     @classmethod
     @abstractmethod
-    def from_hdf5(
+    def from_pandas_dict(
             cls, 
-            filename: str, 
-            groupname: Optional[str]
-        ) -> 'HDF5InputOutput':
+            dic: Dict[str,pandas.DataFrame],
+            **kwargs: dict
+        ) -> 'PandasDictInputOutput':
         """
-        Read an object from an HDF5 file.
+        Read an object from a ``dict`` of ``pandas.DataFrame``.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which object data is stored.
-            If None, object is read from base HDF5 group.
+        dic : dict
+            Python dictionary containing ``pandas.DataFrame`` from which to read.
+        kwargs : dict
+            Additional keyword arguments to use for dictating importing from a 
+            ``dict`` of ``pandas.DataFrame``.
 
         Returns
         -------
-        out : HDF5InputOutput
-            An object read from an HDF5 file.
+        out : PandasDictInputOutput
+            An object read from a ``dict`` of ``pandas.DataFrame``.
         """
         raise NotImplementedError("class method is abstract")
 
 
 
 ################################## Utilities ###################################
-def check_is_HDF5InputOutput(v: object, vname: str) -> None:
+def check_is_PandasDictInputOutput(v: object, vname: str) -> None:
     """
-    Check if object is of type HDF5InputOutput. Otherwise raise TypeError.
+    Check if object is of type ``PandasDictInputOutput``. Otherwise raise ``TypeError``.
 
     Parameters
     ----------
     v : object
         Any Python object to test.
     vname : str
         Name of variable to print in TypeError message.
     """
-    if not isinstance(v, HDF5InputOutput):
-        raise TypeError("variable '{0}' must be a of type '{1}' but received type '{2}'".format(vname,HDF5InputOutput.__name__,type(v).__name__))
+    if not isinstance(v, PandasDictInputOutput):
+        raise TypeError(
+            "variable '{0}' must be a of type '{1}' but received type '{2}'".format(
+                vname,
+                PandasDictInputOutput.__name__,
+                type(v).__name__
+            )
+        )
```

### Comparing `pybrops-1.0.2/pybrops/core/io/NPYInputOutput.py` & `pybrops-1.0.3/pybrops/core/io/NPYInputOutput.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,21 @@
 """
 Module defining binary NumPy format I/O interfaces and assocated error 
 checking routines.
 """
 
-from abc import ABCMeta, abstractmethod
-from typing import Optional, Sequence, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from typing import Optional
+from typing import Sequence
+from typing import Union
 
-
-class NPYInputOutput(metaclass=ABCMeta):
+class NPYInputOutput(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class for defining ``.npy`` file input/output functionality.
 
     This abstract class defines two functions with the following purposes:
     
     - ``to_npy`` - write an object to a ``.npy`` file.
     - ``from_npy`` - load an object from a ``.npy`` file.
```

### Comparing `pybrops-1.0.2/pybrops/core/io/NPZInputOutput.py` & `pybrops-1.0.3/pybrops/core/io/NPZInputOutput.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,17 +1,19 @@
 """
 Module defining binary NumPy archive format I/O interfaces and assocated error 
 checking routines.
 """
 
-from abc import ABCMeta, abstractmethod
-from typing import Optional, Sequence, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from typing import Optional
 
-
-class NPZInputOutput(metaclass=ABCMeta):
+class NPZInputOutput(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class for defining NPZ input/output functionality.
 
     This abstract class defines two functions with the following purposes:
     
     - ``to_npz`` - write an object to a ``.npz`` file.
     - ``from_npz`` - load an object from a ``.npz`` file.
```

### Comparing `pybrops-1.0.2/pybrops/core/io/NumPyInputOutput.py` & `pybrops-1.0.3/pybrops/core/io/NumPyInputOutput.py`

 * *Files 6% similar despite different names*

```diff
@@ -4,19 +4,21 @@
 """
 
 __all__ = [
     "NumPyInputOutput",
     "check_is_NumPyInputOutput",
 ]
 
-from abc import ABCMeta, abstractmethod
-
+from abc import ABCMeta
+from abc import abstractmethod
 import numpy
 
-class NumPyInputOutput(metaclass=ABCMeta):
+class NumPyInputOutput(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class for defining ``numpy.ndarray`` input/output functionality.
 
     This abstract class defines two functions with the following purposes:
 
     - ``to_numpy`` - export an object to a ``numpy.ndarray``.
     - ``from_numpy`` - load an object from a ``numpy.ndarray``.
```

### Comparing `pybrops-1.0.2/pybrops/core/io/PandasInputOutput.py` & `pybrops-1.0.3/pybrops/core/io/PandasInputOutput.py`

 * *Files 1% similar despite different names*

```diff
@@ -4,20 +4,21 @@
 """
 
 __all__ = [
     "PandasInputOutput",
     "check_is_PandasInputOutput",
 ]
 
-from abc import ABCMeta, abstractmethod
-
+from abc import ABCMeta
+from abc import abstractmethod
 import pandas
 
-
-class PandasInputOutput(metaclass=ABCMeta):
+class PandasInputOutput(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class for defining pandas.DataFrame input/output functionality.
 
     This abstract class defines two functions with the following purposes:
 
     - ``to_pandas`` - export an object to a pandas.DataFrame.
     - ``from_pandas`` - load an object from a pandas.DataFrame.
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/DenseMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/DenseMatrix.py`

 * *Files 12% similar despite different names*

```diff
@@ -4,29 +4,37 @@
 
 __all__ = [
     "DenseMatrix",
     "check_is_DenseMatrix",
 ]
 
 import copy
+from pathlib import Path
 import numpy
 import h5py
-from typing import Iterator, Optional, Sequence, Union
+from typing import Iterator
+from typing import Optional
+from typing import Sequence
+from typing import Union
 from numpy.typing import ArrayLike
 
 from pybrops.core.error.error_io_python import check_file_exists
 from pybrops.core.error.error_attr_python import error_readonly
 from pybrops.core.error.error_type_numpy import check_is_ndarray
-from pybrops.core.error.error_type_python import check_is_str
 from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_readable
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_writable
 from pybrops.core.mat.Matrix import Matrix
-from pybrops.core.mat.util import get_axis
-from pybrops.core.util.h5py import save_dict_to_hdf5
-
-class DenseMatrix(Matrix):
+from pybrops.core.util.array import get_axis
+from pybrops.core.util.h5py import h5py_File_read_ndarray
+from pybrops.core.util.h5py import h5py_File_write_dict
+
+class DenseMatrix(
+        Matrix,
+    ):
     """
     A concrete class for dense matrices.
     Dense matrices utilize numpy.ndarray's for data storage.
 
     The purpose of this concrete class is to implement base functionality for:
         1) Dense matrix mathematical operators
         2) Dense matrix logical & bitwise operators
@@ -1106,133 +1114,208 @@
         out = mats[0].__class__(mat = mat, **kwargs)
 
         return out
 
     ################### Matrix File I/O ####################
     def to_hdf5(
             self, 
-            filename: str, 
-            groupname: Optional[str] = None
+            filename: Union[str,Path,h5py.File], 
+            groupname: Optional[str] = None,
+            overwrite: bool = True,
         ) -> None:
         """
         Write GenotypeMatrix to an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name to which to write.
-        groupname : str or None
-            HDF5 group name under which the ``DenseMatrix`` data is stored.
+        filename : str, Path, h5py.File
+            If ``str``, an HDF5 file name to which to write. File is closed after writing.
+            If ``h5py.File``, an opened HDF5 file to which to write. File is not closed after writing.
+
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseMatrix`` data is stored.
             If ``None``, the ``DenseMatrix`` is written to the base HDF5 group.
+
+        overwrite : bool
+            Whether to overwrite values in an HDF5 file if a field already exists.
         """
-        h5file = h5py.File(filename, "a")                       # open HDF5 in write mode
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### populate HDF5 file
-        data_dict = {                                           # data dictionary
-            "mat": self.mat
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in append (``r+``) mode
+        if isinstance(filename, (str,Path)):
+            h5file = h5py.File(filename, "a")
+
+        # elif we have an h5py.File, make sure mode is writable, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_writable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        #### write data to HDF5 file and (optionally) close ####
+
+        # data dictionary
+        data = {
+            "mat" : self.mat,
         }
-        save_dict_to_hdf5(h5file, groupname, data_dict)         # save data
-        ######################################################### write conclusion
-        h5file.close()                                          # close the file
+        
+        # save data to file
+        h5py_File_write_dict(h5file, groupname, data, overwrite)
+        
+        # close the file, only if the provided filename was a string or Path and not a h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
 
     ############################## Class Methods ###############################
 
     ################### Matrix File I/O ####################
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseMatrix':
         """
         Read DenseMatrix from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseMatrix data is stored.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which DenseMatrix data is stored.
             If None, DenseMatrix is read from base HDF5 group.
 
         Returns
         -------
         out : DenseMatrix
             A dense matrix read from file.
         """
-        # type checks
-        check_is_str(filename, "filename")
-        
-        # check file exists
-        check_file_exists(filename)
-        
-        # open HDF5 in read only
-        h5file = h5py.File(filename, "r")
-        
-        ############ process groupname argument ############
-        
-        # if groupname is None, set to empty string
-        if groupname is None:
-            groupname = ""
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in read (``r``) mode
+        if isinstance(filename, (str,Path)):
+            check_file_exists(filename)
+            h5file = h5py.File(filename, "r")
+
+        # elif we have an ``h5py.File``, make sure mode is in at least ``r`` mode, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_readable(filename)
+            h5file = filename
         
-        # if we have a string, check that group exists, add '/' to end if needed
-        elif isinstance(groupname, str):
-            check_h5py_File_has_group(h5file, filename, groupname)
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # FIXME: errors if groupname == "" or "/"
+            # if the group does not exist in the file, close and raise error
+            check_h5py_File_has_group(h5file, groupname)
+
+            # if last character in string is not '/', add '/' to end of string
             if groupname[-1] != '/':
                 groupname += '/'
         
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
         # else raise error
         else:
-            raise TypeError("'groupname' must be of type str or None")
-        
-        ###### check that we have all required fields ######
-        
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        ######## check that we have all required fields ########
+
         # all required arguments
         required_fields = ["mat"]
-        
-        # for each required field
+
+        # for each required field, check if the field exists in the HDF5 file.
         for field in required_fields:
-            # concatenate base groupname and field
-            fieldname = groupname + field
-            # check that group exists
-            check_h5py_File_has_group(h5file, filename, fieldname)
+            check_h5py_File_has_group(h5file, groupname + field)
+
+        ########################################################
+        ### read data from HDF5 file and (optionally) close ####
         
-        #################### read data #####################
         # output dictionary
         data = {
             "mat": None
         }
         
-        # for each field
-        for field in data.keys():
-            # concatenate base groupname and field
-            fieldname = groupname + field
-            # if the field exists in the HDF5 file
-            if fieldname in h5file:
-                # read array
-                data[field] = h5file[fieldname][()]
-        
-        ################# read conclusion ##################
-        # close file
-        h5file.close()
+        ##################################
+        ### read mandatory data fields ###
+
+        # read mat array (ndarray dtype = int8)
+        data["mat"] = h5py_File_read_ndarray(h5file, groupname + "mat")
+        
+        ######################
+        ### close the file ###
+
+        # close the file, only if the provided fieldname was a string or Path an not an h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
+        
+        ########################################################
+        ################### Object creation ####################
         
-        ################## create object ###################
         # create object from read data
-        mat = cls(
+        out = cls(
             mat = data["mat"],
         )
 
-        return mat
+        return out
 
 
 
 ################################## Utilities ###################################
 def check_is_DenseMatrix(v: object, vname: str) -> None:
     """
     Check if object is of type DenseMatrix. Otherwise raise TypeError.
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/DenseMutableMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/DenseMutableMatrix.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,21 +5,25 @@
 """
 
 __all__ = [
     "DenseMutableMatrix",
     "check_is_DenseMutableMatrix",
 ]
 
-from typing import Sequence, Union
+from typing import Sequence
+from typing import Union
 import numpy
-from pybrops.core.mat.util import get_axis
+from pybrops.core.util.array import get_axis
 from pybrops.core.mat.DenseMatrix import DenseMatrix
 from pybrops.core.mat.MutableMatrix import MutableMatrix
 
-class DenseMutableMatrix(DenseMatrix,MutableMatrix):
+class DenseMutableMatrix(
+        DenseMatrix,
+        MutableMatrix,
+    ):
     """
     A concrete class for dense mutable matrices.
     Dense mutable matrices utilize numpy.ndarray's for data storage.
 
     The purpose of this concrete class is to implement base functionality for:
         1) Dense matrix in-place matrix shape changing routines.
     """
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/DensePhasedMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/DensePhasedMatrix.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,27 +5,32 @@
 __all__ = [
     "DensePhasedMatrix",
     "check_is_DensePhasedMatrix",
 ]
 
 import copy
 import numpy
-from typing import Optional, Sequence, Union
+from typing import Optional
+from typing import Sequence
+from typing import Union
 from numpy.typing import ArrayLike
 
 from pybrops.core.error.error_type_python import check_is_array_like
 from pybrops.core.error.error_attr_python import check_is_iterable
 from pybrops.core.error.error_attr_python import error_readonly
 from pybrops.core.error.error_generic_python import generic_check_isinstance
 from pybrops.core.mat.Matrix import Matrix
-from pybrops.core.mat.util import get_axis
+from pybrops.core.util.array import get_axis
 from pybrops.core.mat.DenseMutableMatrix import DenseMutableMatrix
 from pybrops.core.mat.PhasedMatrix import PhasedMatrix
 
-class DensePhasedMatrix(DenseMutableMatrix,PhasedMatrix):
+class DensePhasedMatrix(
+        DenseMutableMatrix,
+        PhasedMatrix,
+    ):
     """
     A concrete class implementing dense phased matrices.
     A phased matrix is defined as a matrix with a third dimension.
 
     Dense phased matrices utilize numpy.ndarray's for data storage.
 
     The purpose of this concrete class is to implement base functionality for:
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/DensePhasedTaxaVariantMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/DensePhasedTaxaVariantMatrix.py`

 * *Files 0% similar despite different names*

```diff
@@ -5,22 +5,23 @@
 
 __all__ = [
     "DensePhasedTaxaVariantMatrix",
     "check_is_DensePhasedTaxaVariantMatrix",
 ]
 
 import numpy
-from typing import Sequence, Union
+from typing import Sequence
+from typing import Union
 from typing import Optional
 from numpy.typing import ArrayLike
 
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim_gteq
 from pybrops.core.mat.Matrix import Matrix
-from pybrops.core.mat.util import get_axis
+from pybrops.core.util.array import get_axis
 from pybrops.core.mat.PhasedTaxaVariantMatrix import PhasedTaxaVariantMatrix
 from pybrops.core.mat.DensePhasedMatrix import DensePhasedMatrix
 from pybrops.core.mat.DenseTaxaVariantMatrix import DenseTaxaVariantMatrix
 
 class DensePhasedTaxaVariantMatrix(
         DenseTaxaVariantMatrix,
         DensePhasedMatrix,
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/DenseSquareMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/DenseSquareMatrix.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/core/mat/DenseSquareTaxaMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/DenseSquareTaxaMatrix.py`

 * *Files 0% similar despite different names*

```diff
@@ -5,22 +5,24 @@
 
 __all__ = [
     "DenseSquareTaxaMatrix",
     "check_is_DenseSquareTaxaMatrix",
 ]
 
 import copy
-from typing import Optional, Sequence, Union
+from typing import Optional
+from typing import Sequence
+from typing import Union
 import numpy
 from numpy.typing import ArrayLike
 
 from pybrops.core.error.error_type_python import check_is_array_like
 from pybrops.core.error.error_attr_python import check_is_iterable
 from pybrops.core.mat.Matrix import Matrix
-from pybrops.core.mat.util import get_axis
+from pybrops.core.util.array import get_axis
 from pybrops.core.error.error_generic_python import generic_check_isinstance
 from pybrops.core.mat.DenseSquareMatrix import DenseSquareMatrix
 from pybrops.core.mat.DenseTaxaMatrix import DenseTaxaMatrix
 from pybrops.core.mat.SquareTaxaMatrix import SquareTaxaMatrix
 
 class DenseSquareTaxaMatrix(
         DenseSquareMatrix,
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/DenseSquareTaxaSquareTraitMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/DenseSquareTaxaSquareTraitMatrix.py`

 * *Files 7% similar despite different names*

```diff
@@ -5,26 +5,33 @@
 
 __all__ = [
     "DenseSquareTaxaSquareTraitMatrix",
     "check_is_DenseSquareTaxaSquareTraitMatrix",
 ]
 
 import copy
-from typing import Optional, Sequence, Union
+from pathlib import Path
+from typing import Optional
+from typing import Sequence
+from typing import Union
 import numpy
 import h5py
 from numpy.typing import ArrayLike
 from pybrops.core.error.error_io_python import check_file_exists
 from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_readable
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_writable
 from pybrops.core.mat.DenseSquareTaxaMatrix import DenseSquareTaxaMatrix
 from pybrops.core.mat.DenseSquareTraitMatrix import DenseSquareTraitMatrix
 from pybrops.core.mat.Matrix import Matrix
 from pybrops.core.mat.SquareTaxaSquareTraitMatrix import SquareTaxaSquareTraitMatrix
-from pybrops.core.mat.util import get_axis
-from pybrops.core.util.h5py import save_dict_to_hdf5
+from pybrops.core.util.array import get_axis
+from pybrops.core.util.h5py import h5py_File_read_ndarray
+from pybrops.core.util.h5py import h5py_File_read_ndarray_utf8
+from pybrops.core.util.h5py import h5py_File_write_dict
 
 class DenseSquareTaxaSquareTraitMatrix(
         DenseSquareTaxaMatrix,
         DenseSquareTraitMatrix,
         SquareTaxaSquareTraitMatrix,
     ):
     """
@@ -805,116 +812,267 @@
         return grouped
 
     # is_grouped_taxa is unaltered
 
     ################### Matrix File I/O ####################
     def to_hdf5(
             self, 
-            filename: str, 
-            groupname: Optional[str] = None
+            filename: Union[str,Path,h5py.File], 
+            groupname: Optional[str] = None,
+            overwrite: bool = True,
         ) -> None:
         """
-        Write DenseSquareTaxaSquareTraitMatrix to an HDF5 file.
+        Write ``DenseSquareTaxaSquareTraitMatrix`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name to which to write.
-        groupname : str or None
-            HDF5 group name under which the ``DenseSquareTaxaSquareTraitMatrix`` data is stored.
+        filename : str, Path, h5py.File
+            If ``str``, an HDF5 file name to which to write. File is closed after writing.
+            If ``h5py.File``, an opened HDF5 file to which to write. File is not closed after writing.
+
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseSquareTaxaSquareTraitMatrix`` data is stored.
             If ``None``, the ``DenseSquareTaxaSquareTraitMatrix`` is written to the base HDF5 group.
+
+        overwrite : bool
+            Whether to overwrite values in an HDF5 file if a field already exists.
         """
-        h5file = h5py.File(filename, "a")                       # open HDF5 in write mode
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### populate HDF5 file
-        data_dict = {                                           # data dictionary
-            "mat"       : self.mat,
-            "taxa"      : self.taxa,
-            "taxa_grp"  : self.taxa_grp,
-            "trait"     : self.trait
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in append (``r+``) mode
+        if isinstance(filename, (str,Path)):
+            h5file = h5py.File(filename, "a")
+
+        # elif we have an h5py.File, make sure mode is writable, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_writable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        #### write data to HDF5 file and (optionally) close ####
+
+        # data dictionary
+        data = {
+            "mat"           : self.mat,
+            "taxa"          : self.taxa,
+            "taxa_grp"      : self.taxa_grp,
+            "trait"         : self.trait,
+            # metadata
+            "taxa_grp_name" : self.taxa_grp_name,
+            "taxa_grp_stix" : self.taxa_grp_stix,
+            "taxa_grp_spix" : self.taxa_grp_spix,
+            "taxa_grp_len"  : self.taxa_grp_len,
         }
-        save_dict_to_hdf5(h5file, groupname, data_dict)         # save data
-        ######################################################### write conclusion
-        h5file.close()                                          # close the file
+
+        # save data
+        h5py_File_write_dict(h5file, groupname, data, overwrite)
+
+        # close the file, only if the provided filename was a string or Path and not a h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
 
     ############################## Class Methods ###############################
 
     ################### Matrix File I/O ####################
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseSquareTaxaSquareTraitMatrix':
         """
-        Read DenseSquareTaxaSquareTraitMatrix from an HDF5 file.
+        Read ``DenseSquareTaxaSquareTraitMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseSquareTaxaSquareTraitMatrix data is stored.
-            If None, DenseSquareTaxaSquareTraitMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseSquareTaxaSquareTraitMatrix`` data is stored.
+            If ``None``, ``DenseSquareTaxaSquareTraitMatrix`` is read from base HDF5 group.
 
         Returns
         -------
         out : DenseSquareTaxaSquareTraitMatrix
             A dense matrix read from file.
         """
-        check_file_exists(filename)                             # check file exists
-        h5file = h5py.File(filename, "r")                       # open HDF5 in read only
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            check_h5py_File_has_group(h5file, filename, groupname)    # check that group exists
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### check that we have all required fields
-        required_fields = ["mat"]                               # all required arguments
-        for field in required_fields:                           # for each required field
-            fieldname = groupname + field                       # concatenate base groupname and field
-            check_h5py_File_has_group(h5file, filename, fieldname)    # check that group exists
-        ######################################################### read data
-        data_dict = {                                           # output dictionary
-            "mat"       : None,
-            "taxa"      : None,
-            "taxa_grp"  : None,
-            "trait"     : None
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in read (``r``) mode
+        if isinstance(filename, (str,Path)):
+            check_file_exists(filename)
+            h5file = h5py.File(filename, "r")
+
+        # elif we have an ``h5py.File``, make sure mode is in at least ``r`` mode, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_readable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # FIXME: errors if groupname == "" or "/"
+            # if the group does not exist in the file, close and raise error
+            check_h5py_File_has_group(h5file, groupname)
+
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        ######## check that we have all required fields ########
+
+        # all required arguments
+        required_fields = ["mat"]
+
+        # for each required field, check if the field exists in the HDF5 file.
+        for field in required_fields:
+            check_h5py_File_has_group(h5file, groupname + field)
+        
+        ########################################################
+        ### read data from HDF5 file and (optionally) close ####
+        
+        # output dictionary
+        data = {
+            "mat"           : None,
+            "taxa"          : None,
+            "taxa_grp"      : None,
+            "trait"         : None,
+            # metadata
+            "taxa_grp_name" : None,
+            "taxa_grp_stix" : None,
+            "taxa_grp_spix" : None,
+            "taxa_grp_len"  : None,
         }
-        for field in data_dict.keys():                          # for each field
-            fieldname = groupname + field                       # concatenate base groupname and field
-            if fieldname in h5file:                             # if the field exists in the HDF5 file
-                data_dict[field] = h5file[fieldname][()]        # read array
-        ######################################################### read conclusion
-        h5file.close()                                          # close file
-        ######################################################### convert data types
-        str_fields = ["taxa","trait"]                           # string array fields
-        for field in str_fields:                                # for each field
-            if data_dict[field] is not None:                    # if the field is not None
-                arr = data_dict[field]                          # extract pointer to field
-                for i in range(len(arr)):                       # for each element in field
-                    if isinstance(arr[i], bytes):               # if element is bytes
-                        arr[i] = arr[i].decode("utf-8")         # convert bytes element to str
-                data_dict[field] = arr                          # store pointer
-        ######################################################### create object
-        mat = cls(**data_dict)                                  # create object from read data
-        return mat
 
-    ############################## Static Methods ##############################
+        ##################################
+        ### read mandatory data fields ###
+
+        # read mat array (ndarray dtype = int8)
+        data["mat"] = h5py_File_read_ndarray(h5file, groupname + "mat")
+        
+        #################################
+        ### read optional data fields ###
+
+        # read taxa array (ndarray dtype = unicode / object)
+        if groupname + "taxa" in h5file:
+            data["taxa"] = h5py_File_read_ndarray_utf8(h5file, groupname + "taxa")
+
+        # read taxa_grp array (ndarray dtype = any)
+        if groupname + "taxa_grp" in h5file:
+            data["taxa_grp"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp")
+        
+        # read trait array (ndarray dtype = unicode / object)
+        if groupname + "trait" in h5file:
+            data["trait"] = h5py_File_read_ndarray_utf8(h5file, groupname + "trait")
+
+        #####################################
+        ### read optional metadata fields ###
+
+        # read taxa_grp_name array (ndarray dtype = any)
+        if groupname + "taxa_grp_name" in h5file:
+            data["taxa_grp_name"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_name")
+
+        # read taxa_grp_stix array (ndarray dtype = any)
+        if groupname + "taxa_grp_stix" in h5file:
+            data["taxa_grp_stix"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_stix")
+
+        # read taxa_grp_spix array (ndarray dtype = any)
+        if groupname + "taxa_grp_spix" in h5file:
+            data["taxa_grp_spix"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_spix")
+
+        # read taxa_grp_len array (ndarray dtype = any)
+        if groupname + "taxa_grp_len" in h5file:
+            data["taxa_grp_len"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_len")
+
+        ######################
+        ### close the file ###
+
+        # close the file, only if the provided fieldname was a string or Path an not an h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
+
+        ########################################################
+        ################### Object creation ####################
+        
+        # create object from read data
+        out = cls(
+            mat         = data["mat"],
+            taxa        = data["taxa"],
+            taxa_grp    = data["taxa_grp"],
+            trait       = data["trait"],
+        )
+
+        # copy metadata
+        out.taxa_grp_name   = data["taxa_grp_name"]
+        out.taxa_grp_stix   = data["taxa_grp_stix"]
+        out.taxa_grp_spix   = data["taxa_grp_spix"]
+        out.taxa_grp_len    = data["taxa_grp_len"]
+
+        return out
 
 
 
 ################################## Utilities ###################################
 def check_is_DenseSquareTaxaSquareTraitMatrix(v: object, vname: str) -> None:
     """
     Check if object is of type DenseSquareTaxaSquareTraitMatrix. Otherwise raise TypeError.
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/DenseSquareTaxaTraitMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/DenseTraitMatrix.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,389 +1,521 @@
 """
-Module implementing a dense matrix with taxa axes that are square and a trait
-axis which is not square, and associated error checking routines.
+Module implementing a dense matrix with trait metadata and associated error
+checking routines.
 """
 
 __all__ = [
-    "DenseSquareTaxaTraitMatrix",
-    "check_is_DenseSquareTaxaTraitMatrix",
+    "DenseTraitMatrix",
+    "check_is_DenseTraitMatrix",
 ]
 
-
-import copy
-from typing import Optional, Sequence, Union
+from pathlib import Path
 import numpy
-import h5py
+import copy
+from typing import Sequence
+from typing import Union
+from typing import Optional
 from numpy.typing import ArrayLike
+import h5py
+
+from pybrops.core.error.error_attr_python import check_is_iterable
 from pybrops.core.error.error_io_python import check_file_exists
+from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
-from pybrops.core.mat.DenseSquareTaxaMatrix import DenseSquareTaxaMatrix
-from pybrops.core.mat.DenseTraitMatrix import DenseTraitMatrix
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_readable
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_writable
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len
+from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_object
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
+from pybrops.core.error.error_attr_python import error_readonly
+from pybrops.core.error.error_generic_python import generic_check_isinstance
 from pybrops.core.mat.Matrix import Matrix
-from pybrops.core.mat.SquareTaxaTraitMatrix import SquareTaxaTraitMatrix
-from pybrops.core.mat.util import get_axis
-from pybrops.core.util.h5py import save_dict_to_hdf5
-
-
-class DenseSquareTaxaTraitMatrix(
-        DenseSquareTaxaMatrix,
-        DenseTraitMatrix,
-        SquareTaxaTraitMatrix,
+from pybrops.core.util.array import get_axis
+from pybrops.core.mat.DenseMutableMatrix import DenseMutableMatrix
+from pybrops.core.mat.TraitMatrix import TraitMatrix
+from pybrops.core.util.h5py import h5py_File_read_ndarray
+from pybrops.core.util.h5py import h5py_File_read_ndarray_utf8
+from pybrops.core.util.h5py import h5py_File_write_dict
+
+class DenseTraitMatrix(
+        DenseMutableMatrix,
+        TraitMatrix,
     ):
     """
-    A concrete class for dense matrices with taxa axes that are square and a 
-    trait axis which is not square.
+    A concrete class for dense matrices with trait metadata.
 
-    The purpose of this abstract class is to merge the following implementations
-    and interfaces:
-
-        1. DenseSquareTaxaMatrix (implementation)
-        2. DenseTraitMatrix (implementation)
-        3. SquareTaxaTraitMatrix (interface)
+    The purpose of this concrete class is to implement base functionality for:
+        1) Dense matrix trait metadata.
+        2) Dense matrix trait routines.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             mat: numpy.ndarray, 
-            taxa: Optional[numpy.ndarray] = None, 
-            taxa_grp: Optional[numpy.ndarray] = None, 
-            trait: Optional[numpy.ndarray] = None,
+            trait: Optional[numpy.ndarray] = None, 
             **kwargs: dict
         ) -> None:
         """
-        Constructor for the DenseSquareTaxaTraitMatrix concrete class.
+        Constructor for the concrete class DenseTraitMatrix.
 
         Parameters
         ----------
         mat : numpy.ndarray
-            Matrix used to construct the object.
-        taxa : numpy.ndarray
-            Taxa names.
-        taxa_grp : numpy.ndarray
-            Taxa groupings.
-        trait : numpy.ndarray
-            Trait labels.
+            A numpy.ndarray used to construct the object.
+        trait : numpy.ndarray, None
+            A numpy.ndarray of shape ``(t,)`` containing trait names.
+            If ``None``, do not store any trait name information.
         kwargs : dict
             Additional keyword arguments.
         """
-        # since this is multiple inheritance, do not use parental constructors
-        self.mat = mat
-        self.taxa = taxa
-        self.taxa_grp = taxa_grp
+        super(DenseTraitMatrix, self).__init__(
+            mat = mat,
+            **kwargs
+        )
         self.trait = trait
-        # set taxa metadata to None
-        self.taxa_grp_name = None
-        self.taxa_grp_stix = None
-        self.taxa_grp_spix = None
-        self.taxa_grp_len = None
 
+    #################### Matrix copying ####################
     def __copy__(
             self
-        ) -> 'DenseSquareTaxaTraitMatrix':
+        ) -> 'DenseTraitMatrix':
         """
         Make a shallow copy of the the matrix.
 
         Returns
         -------
-        out : DenseSquareTaxaTraitMatrix
+        out : DenseTraitMatrix
+            A copy of the DenseTraitMatrix.
         """
         # create new object
         out = self.__class__(
             mat = copy.copy(self.mat),
-            taxa = copy.copy(self.taxa),
-            taxa_grp = copy.copy(self.taxa_grp),
             trait = copy.copy(self.trait)
         )
 
-        # copy taxa metadata
-        out.taxa_grp_name = copy.copy(self.taxa_grp_name)
-        out.taxa_grp_stix = copy.copy(self.taxa_grp_stix)
-        out.taxa_grp_spix = copy.copy(self.taxa_grp_spix)
-        out.taxa_grp_len = copy.copy(self.taxa_grp_len)
-
         return out
 
     def __deepcopy__(
             self, 
             memo: dict
-        ) -> 'DenseSquareTaxaTraitMatrix':
+        ) -> 'DenseTraitMatrix':
         """
         Make a deep copy of the matrix.
 
         Parameters
         ----------
         memo : dict
-            Dictionary of memo metadata.
+            Deep copy metadata.
 
         Returns
         -------
-        out : DenseSquareTaxaTraitMatrix
+        out : Matrix
+            A deep copy of the DenseTraitMatrix.
         """
         # create new object
         out = self.__class__(
             mat = copy.deepcopy(self.mat, memo),
-            taxa = copy.deepcopy(self.taxa, memo),
-            taxa_grp = copy.deepcopy(self.taxa_grp, memo),
             trait = copy.deepcopy(self.trait, memo)
         )
 
-        # copy taxa metadata
-        out.taxa_grp_name = copy.deepcopy(self.taxa_grp_name, memo)
-        out.taxa_grp_stix = copy.deepcopy(self.taxa_grp_stix, memo)
-        out.taxa_grp_spix = copy.deepcopy(self.taxa_grp_spix, memo)
-        out.taxa_grp_len = copy.deepcopy(self.taxa_grp_len, memo)
-
         return out
 
-    ############################## Object Methods ##############################
-
-    #################### Matrix copying ####################
-    def copy(
-            self
-        ) -> 'DenseSquareTaxaTraitMatrix':
-        """
-        Make a shallow copy of the Matrix.
-
-        Returns
-        -------
-        out : DenseSquareTaxaTraitMatrix
-            A shallow copy of the original DenseSquareTaxaTraitMatrix.
-        """
-        return copy.copy(self)
-
-    def deepcopy(
-            self, 
-            memo: Optional[dict] = None
-        ) -> 'DenseSquareTaxaTraitMatrix':
-        """
-        Make a deep copy of the Matrix.
-
-        Parameters
-        ----------
-        memo : dict
-            Dictionary of memo metadata.
-
-        Returns
-        -------
-        out : DenseSquareTaxaTraitMatrix
-            A deep copy of the original DenseSquareTaxaTraitMatrix.
-        """
-        return copy.deepcopy(self, memo)
+    ############################ Object Properties #############################
 
+    ###################### Trait data ######################
+    @property
+    def trait(self) -> Union[numpy.ndarray,None]:
+        """Trait label."""
+        return self._trait
+    @trait.setter
+    def trait(self, value: Union[numpy.ndarray,None]) -> None:
+        """Set trait label array"""
+        if value is not None:
+            check_is_ndarray(value, "trait")
+            check_ndarray_dtype_is_object(value, "trait")
+            check_ndarray_ndim(value, "trait", 1)
+            check_ndarray_axis_len(value, "trait", 0, self.ntrait)
+        self._trait = value
+    
+    #################### Trait metadata ####################
+    @property
+    def ntrait(self) -> int:
+        """Number of traits."""
+        return self._mat.shape[self.trait_axis]
+    
+    @property
+    def trait_axis(self) -> int:
+        """Axis along which traits are stored."""
+        return 0
+    
     ######### Matrix element copy-on-manipulation ##########
     def adjoin(
             self, 
             values: Union[Matrix,numpy.ndarray], 
             axis: int = -1, 
-            taxa: Optional[numpy.ndarray] = None, 
-            taxa_grp: Optional[numpy.ndarray] = None, 
-            trait: Optional[numpy.ndarray] = None,
+            trait: Optional[numpy.ndarray] = None, 
             **kwargs: dict
-        ) -> 'DenseSquareTaxaTraitMatrix':
+        ) -> 'DenseTraitMatrix':
         """
         Add additional elements to the end of the Matrix along an axis.
 
         Parameters
         ----------
         values : Matrix, numpy.ndarray
-            Values are appended to append to the Matrix.
+            Values to be adjoined to the Matrix.
         axis : int
             The axis along which values are adjoined.
-        taxa : numpy.ndarray
-            Taxa names to adjoin to the Matrix.
-            If values is a DenseSquareTaxaTraitMatrix that has a non-None
-            taxa field, providing this argument overwrites the field.
-        taxa_grp : numpy.ndarray
-            Taxa groups to adjoin to the Matrix.
-            If values is a DenseSquareTaxaTraitMatrix that has a non-None
-            taxa_grp field, providing this argument overwrites the field.
-        trait : numpy.ndarray, None
+        trait : numpy.ndarray
             Trait names to adjoin to the Matrix.
-            If ``values`` is a DenseSquareTaxaTraitMatrix that has a non-None
-            taxa_grp field, providing this argument overwrites the field.
+            If values is a DenseTraitMatrix that has a non-None
+            trait field, providing this argument overwrites the field.
         kwargs : dict
             Additional keyword arguments.
 
         Returns
         -------
-        out : DenseSquareTaxaTraitMatrix
-            A copy of DenseSquareTaxaTraitMatrix with values appended to axis. Note that adjoin does
-            not occur in-place: a new DenseSquareTaxaTraitMatrix is allocated and filled.
+        out : DenseTraitMatrix
+            A copy of mat with values adjoined to axis. Note that adjoin does
+            not occur in-place: a new Matrix is allocated and filled.
         """
         axis = get_axis(axis, self.mat_ndim)    # get axis
         out = None                              # declare variable
 
         # dispatch functions to handle operations
-        if axis in self.square_axes:
-            out = self.adjoin_taxa(
-                values = values,
-                taxa = taxa,
-                taxa_grp = taxa_grp,
-                **kwargs
-            )
-        elif axis == self.trait_axis:
+        if axis == self.trait_axis:
             out = self.adjoin_trait(
                 values = values,
                 trait = trait,
                 **kwargs
             )
         else:
             raise ValueError("cannot append along axis {0}".format(axis))
 
         return out
 
+    def adjoin_trait(
+            self, 
+            values: Union[Matrix,numpy.ndarray], 
+            trait: Optional[numpy.ndarray] = None, 
+            **kwargs: dict
+        ) -> 'DenseTraitMatrix':
+        """
+        Add additional elements to the end of the Matrix along the trait axis.
+
+        Parameters
+        ----------
+        values : DenseTraitMatrix, numpy.ndarray
+            Values to be adjoined to the Matrix.
+        trait : numpy.ndarray
+            Trait names to adjoin to the Matrix.
+            If values is a DenseTraitMatrix that has a non-None
+            trait field, providing this argument overwrites the field.
+        kwargs : dict
+            Additional keyword arguments.
+
+        Returns
+        -------
+        out : DenseTraitMatrix
+            A copy of mat with values adjoined to axis. Note that adjoin does
+            not occur in-place: a new Matrix is allocated and filled.
+        """
+        # extract mat values
+        if isinstance(values, self.__class__): # TODO: change to DenseTraitMatrix instead of self.__class__???
+            if trait is None:
+                trait = values.trait
+            values = values.mat
+        elif not isinstance(values, numpy.ndarray):
+            raise ValueError("cannot adjoin: 'values' must be of type {0} or numpy.ndarray".format(self.__class__))
+
+        # perform error checks before allocating memory
+        if values.ndim != self.mat_ndim:
+            raise ValueError("cannot adjoin: 'values' must have ndim == {0}".format(self.mat_ndim))
+        for i,(j,k) in enumerate(zip(values.shape, self.mat_shape)):
+            if (i != self.trait_axis) and (j != k):
+                raise ValueError("cannot adjoin: axis lengths incompatible for axis {0}".format(i))
+        if (self._trait is not None) and (trait is None):
+            raise TypeError("cannot adjoin: 'trait' argument is required")
+
+        # adjoin values
+        values = numpy.append(self._mat, values, axis = self.trait_axis)
+        if self._trait is not None:
+            trait = numpy.append(self._trait, trait, axis = 0)
+
+        out = self.__class__(
+            mat = values,
+            trait = trait,
+            **kwargs
+        )
+
+        return out
+
     def delete(
             self, 
             obj: Union[int,slice,Sequence], 
             axis: int = -1, 
             **kwargs: dict
-        ) -> 'DenseSquareTaxaTraitMatrix':
+        ) -> 'DenseTraitMatrix':
         """
         Delete sub-arrays along an axis.
 
         Parameters
         ----------
         obj : int, slice, or Sequence of ints
             Indicate indices of sub-arrays to remove along the specified axis.
         axis: int
             The axis along which to delete the subarray defined by obj.
         kwargs : dict
             Additional keyword arguments.
 
         Returns
         -------
-        out : DenseSquareTaxaTraitMatrix
-            A DenseSquareTaxaTraitMatrix with deleted elements. Note that concat does not occur
-            in-place: a new DenseSquareTaxaTraitMatrix is allocated and filled.
+        out : DenseTraitMatrix
+            A Matrix with deleted elements. Note that concat does not occur
+            in-place: a new Matrix is allocated and filled.
         """
         axis = get_axis(axis, self.mat_ndim)    # get axis
         out = None                              # declare variable
 
         # dispatch functions to handle operations
-        if axis in self.square_axes:
-            out = self.delete_taxa(obj = obj, **kwargs)
-        elif axis == self.trait_axis:
-            out = self.delete_trait(obj = obj, **kwargs)
+        if axis == self.trait_axis:
+            out = self.delete_trait(
+                obj = obj,
+                **kwargs
+            )
         else:
             raise ValueError("cannot delete along axis {0}".format(axis))
 
         return out
 
+    def delete_trait(
+            self, 
+            obj: Union[int,slice,Sequence], 
+            **kwargs: dict
+        ) -> 'DenseTraitMatrix':
+        """
+        Delete sub-arrays along the trait axis.
+
+        Parameters
+        ----------
+        obj : int, slice, or Sequence of ints
+            Indicate indices of sub-arrays to remove along the specified axis.
+        kwargs : dict
+            Additional keyword arguments.
+
+        Returns
+        -------
+        out : DenseTraitMatrix
+            A Matrix with deleted elements. Note that concat does not occur
+            in-place: a new Matrix is allocated and filled.
+        """
+        # get values
+        mat = self._mat
+        trait = self._trait
+
+        # delete values
+        mat = numpy.delete(mat, obj, axis = self.trait_axis)
+        if trait is not None:
+            trait = numpy.delete(trait, obj, axis = 0)
+
+        out = self.__class__(
+            mat = mat,
+            trait = trait,
+            **kwargs
+        )
+
+        return out
+
     def insert(
             self, 
             obj: Union[int,slice,Sequence], 
             values: Union[Matrix,numpy.ndarray], 
             axis: int = -1, 
-            taxa: Optional[numpy.ndarray] = None, 
-            taxa_grp: Optional[numpy.ndarray] = None, 
-            trait: Optional[numpy.ndarray] = None,
+            trait: Optional[numpy.ndarray] = None, 
             **kwargs: dict
-        ) -> 'DenseSquareTaxaTraitMatrix':
+        ) -> 'DenseTraitMatrix':
         """
         Insert values along the given axis before the given indices.
 
         Parameters
         ----------
         obj: int, slice, or Sequence of ints
             Object that defines the index or indices before which values is
             inserted.
-        values : Matrix, numpy.ndarray
+        values : DenseTraitMatrix, numpy.ndarray
             Values to insert into the matrix.
         axis : int
             The axis along which values are inserted.
-        taxa : numpy.ndarray
-            Taxa names to insert into the Matrix.
-            If values is a DenseSquareTaxaTraitMatrix that has a non-None
-            taxa field, providing this argument overwrites the field.
-        taxa_grp : numpy.ndarray
-            Taxa groups to insert into the Matrix.
-            If values is a DenseSquareTaxaTraitMatrix that has a non-None
-            taxa_grp field, providing this argument overwrites the field.
-        trait : numpy.ndarray, None
+        trait : numpy.ndarray
             Trait names to insert into the Matrix.
-            If ``values`` is a DenseSquareTaxaTraitMatrix that has a non-None
-            taxa_grp field, providing this argument overwrites the field.
+            If values is a DenseTraitMatrix that has a non-None
+            trait field, providing this argument overwrites the field.
         kwargs : dict
             Additional keyword arguments.
 
         Returns
         -------
-        out : DenseSquareTaxaTraitMatrix
-            A DenseSquareTaxaTraitMatrix with values inserted. Note that insert does not occur
-            in-place: a new DenseSquareTaxaTraitMatrix is allocated and filled.
+        out : DenseTraitMatrix
+            A Matrix with values inserted. Note that insert does not occur
+            in-place: a new Matrix is allocated and filled.
         """
         axis = get_axis(axis, self.mat_ndim)    # get axis
         out = None                              # declare variable
 
         # dispatch functions to handle operations
-        if axis in self.square_axes:
-            out = self.insert_taxa(
-                obj = obj,
-                values = values,
-                taxa = taxa,
-                taxa_grp = taxa_grp,
-                **kwargs
-            )
-        elif axis == self.trait_axis:
+        if axis == self.trait_axis:
             out = self.insert_trait(
                 obj = obj,
                 values = values,
                 trait = trait,
                 **kwargs
             )
         else:
             raise ValueError("cannot insert along axis {0}".format(axis))
 
         return out
 
+    def insert_trait(
+            self, 
+            obj: Union[int,slice,Sequence], 
+            values: Union[Matrix,numpy.ndarray], 
+            trait: Optional[numpy.ndarray] = None, 
+            **kwargs: dict
+        ) -> 'DenseTraitMatrix':
+        """
+        Insert values along the trait axis before the given indices.
+
+        Parameters
+        ----------
+        obj: int, slice, or Sequence of ints
+            Object that defines the index or indices before which values is
+            inserted.
+        values : Matrix, numpy.ndarray
+            Values to insert into the matrix.
+        trait : numpy.ndarray
+            Trait names to insert into the Matrix.
+        kwargs : dict
+            Additional keyword arguments.
+
+        Returns
+        -------
+        out : DenseTraitMatrix
+            A Matrix with values inserted. Note that insert does not occur
+            in-place: a new Matrix is allocated and filled.
+        """
+        # extract mat values
+        if isinstance(values, self.__class__):
+            if trait is None:
+                trait = values.trait
+            values = values.mat
+        elif not isinstance(values, numpy.ndarray):
+            raise ValueError("'values' must be of type {0} or numpy.ndarray".format(self.__class__))
+
+        # perform error checks before allocating memory
+        if values.ndim != self.mat_ndim:
+            raise ValueError("cannot insert: 'values' must have ndim == {0}".format(self.mat_ndim))
+        for i,(j,k) in enumerate(zip(values.shape, self.mat_shape)):
+            if (i != self.trait_axis) and (j != k):
+                raise ValueError("cannot insert: axis lengths incompatible for axis {0}".format(i))
+        if (self._trait is not None) and (trait is None):
+            raise ValueError("cannot insert: 'trait' argument is required")
+
+        # insert values
+        values = numpy.insert(self._mat, obj, values, axis = self.trait_axis)
+        if self._trait is not None:
+            trait = numpy.insert(self._trait, obj, trait, axis = 0)
+
+        # create output
+        out = self.__class__(
+            mat = values,
+            trait = trait,
+            **kwargs
+        )
+
+        return out
+
     def select(
             self, 
             indices: ArrayLike, 
             axis: int = -1, 
             **kwargs: dict
-        ) -> 'DenseSquareTaxaTraitMatrix':
+        ) -> 'DenseTraitMatrix':
         """
         Select certain values from the matrix.
 
         Parameters
         ----------
         indices : array_like (Nj, ...)
             The indices of the values to select.
         axis : int
             The axis along which values are selected.
         kwargs : dict
             Additional keyword arguments.
 
         Returns
         -------
-        out : DenseSquareTaxaTraitMatrix
-            The output DenseSquareTaxaTraitMatrix with values selected. Note that select does not
-            occur in-place: a new DenseSquareTaxaTraitMatrix is allocated and filled.
+        out : DenseTraitMatrix
+            The output matrix with values selected. Note that select does not
+            occur in-place: a new Matrix is allocated and filled.
         """
         axis = get_axis(axis, self.mat_ndim)    # get axis
         out = None                              # declare variable
 
         # dispatch functions to handle operations
-        if axis in self.square_axes:
-            out = self.select_taxa(indices = indices, **kwargs)
-        elif axis == self.trait_axis:
+        if axis == self.trait_axis:
             out = self.select_trait(indices = indices, **kwargs)
         else:
             raise ValueError("cannot select along axis {0}".format(axis))
 
         return out
 
+    def select_trait(
+            self, 
+            indices: ArrayLike, 
+            **kwargs: dict
+        ) -> 'DenseTraitMatrix':
+        """
+        Select certain values from the Matrix along the trait axis.
+
+        Parameters
+        ----------
+        indices : array_like (Nj, ...)
+            The indices of the values to select.
+        kwargs : dict
+            Additional keyword arguments.
+
+        Returns
+        -------
+        out : DenseTraitMatrix
+            The output Matrix with values selected. Note that select does not
+            occur in-place: a new Matrix is allocated and filled.
+        """
+        # get values
+        mat = self._mat
+        trait = self._trait
+
+        # select values
+        mat = numpy.take(mat, indices, axis = self.trait_axis)
+        if trait is not None:
+            trait = numpy.take(trait, indices, axis = 0)
+
+        out = self.__class__(
+            mat = mat,
+            trait = trait,
+            **kwargs
+        )
+
+        return out
+
     @classmethod
     def concat(
             cls, 
             mats: Sequence, 
             axis: int = -1, 
             **kwargs: dict
-        ) -> 'DenseSquareTaxaTraitMatrix':
+        ) -> 'DenseTraitMatrix':
         """
         Concatenate matrices together along an axis.
 
         Parameters
         ----------
         mats : Sequence of matrices
             List of Matrix to concatenate. The matrices must have the same
@@ -391,87 +523,177 @@
         axis : int
             The axis along which the arrays will be joined.
         kwargs : dict
             Additional keyword arguments
 
         Returns
         -------
-        out : DenseSquareTaxaTraitMatrix
-            The concatenated DenseSquareTaxaTraitMatrix. Note that concat does not occur in-place:
-            a new DenseSquareTaxaTraitMatrix is allocated and filled.
+        out : DenseTraitMatrix
+            The concatenated matrix. Note that concat does not occur in-place:
+            a new Matrix is allocated and filled.
         """
         axis = get_axis(axis, mats[0].mat_ndim)     # get axis
         out = None                                  # declare variable
 
         # dispatch items to worker functions
-        if axis in mats[0].square_axes:
-            out = cls.concat_taxa(mats = mats, **kwargs)
-        elif axis == mats[0].trait_axis:
-            out = cls.concat_trait(mats = mats, **kwargs)
+        if axis == mats[0].trait_axis:
+            out = cls.concat_trait(mats, **kwargs)
         else:
             raise ValueError("cannot concat along axis {0}".format(axis))
 
         return out
 
+    @classmethod
+    def concat_trait(
+            cls, 
+            mats: Sequence['DenseTraitMatrix'], 
+            **kwargs: dict
+        ) -> 'DenseTraitMatrix':
+        """
+        Concatenate list of Matrix together along the trait axis.
+
+        Parameters
+        ----------
+        mats : Sequence of DenseTraitMatrix
+            List of ``DenseTraitMatrix`` to concatenate. The matrices must have the same
+            shape, except in the dimension corresponding to axis.
+        kwargs : dict
+            Additional keyword arguments
+
+        Returns
+        -------
+        out : DenseTraitMatrix
+            The concatenated DenseTraitMatrix. Note that concat does not occur in-place:
+            a new DenseTraitMatrix is allocated and filled.
+        """
+        # ensure that we have an iterable object
+        check_is_iterable(mats, "mats")
+
+        # ensure that we have an array_like of length >= 1
+        if len(mats) <= 0:
+            raise ValueError("need at least one Matrix to concatenate")
+
+        # ensure that all items in mats are DenseTraitMatrix
+        for i,v in enumerate(mats):
+            generic_check_isinstance(v, "mats[{0}]".format(i), cls)
+
+        # make sure dimensions are all identical to first element in mats
+        if any(m.mat_ndim != mats[0].mat_ndim for m in mats):
+            raise ValueError("cannot concat: not all matrices have the same number of dimensions")
+
+        # extract tuple of shapes for testing compatibility
+        shape_t = tuple(zip(*[m.mat.shape for m in mats]))
+
+        # test matrix compatibility (same axis length along non-trait axes)
+        for i,v in enumerate(shape_t):                              # for each index,tuple in shape_t
+            if (i != mats[0].trait_axis) and any(l != v[0] for l in v): # if not the trait axis AND axis lengths are different
+                raise ValueError("cannot concat: matrix shapes do not all align along axis {0}".format(i))
+
+        # create matrix lists
+        mat_ls = [m.mat for m in mats]
+        trait_ls = [m.trait for m in mats]
+
+        # process/error check trait_ls
+        if all(e is None for e in trait_ls):    # if all elements are None
+            trait_ls = None                     # replace list with None
+        elif any(e is None for e in trait_ls):  # else if any elements are None
+            raise ValueError("cannot concat: 'trait' needed for all Matrix in list")
+
+        # concatenate mat, trait items
+        mat = numpy.concatenate(mat_ls, axis = mats[0].trait_axis)
+        trait = None if trait_ls is None else numpy.concatenate(trait_ls, axis = 0)
+
+        # concatenate everything and put into new DenseTraitMatrix
+        out = cls(
+            mat = mat,
+            trait = trait,
+            **kwargs
+        )
+
+        return out
+
     ######### Matrix element in-place-manipulation #########
     def append(
             self, 
             values: Union[Matrix,numpy.ndarray], 
             axis: int = -1, 
-            taxa: Optional[numpy.ndarray] = None, 
-            taxa_grp: Optional[numpy.ndarray] = None, 
-            trait: Optional[numpy.ndarray] = None,
+            trait: Optional[numpy.ndarray] = None, 
             **kwargs: dict
         ) -> None:
         """
         Append values to the matrix.
 
         Parameters
         ----------
-        values : DenseSquareTaxaTraitMatrix, numpy.ndarray
+        values : DenseTraitMatrix, numpy.ndarray
             Values are appended to append to the matrix.
             Must be of type int8.
             Must be of shape (m, n, p)
         axis : int
             The axis along which values are appended.
-        taxa : numpy.ndarray
-            Taxa names to append to the Matrix.
-            If values is a DenseSquareTaxaTraitMatrix that has a non-None
-            taxa field, providing this argument overwrites the field.
-        taxa_grp : numpy.ndarray
-            Taxa groups to append to the Matrix.
-            If values is a DenseSquareTaxaTraitMatrix that has a non-None
-            taxa_grp field, providing this argument overwrites the field.
-        trait : numpy.ndarray, None
+        trait : numpy.ndarray
             Trait names to append to the Matrix.
-            If ``values`` is a DenseSquareTaxaTraitMatrix that has a non-None
-            taxa_grp field, providing this argument overwrites the field.
+            If values is a DenseTraitMatrix that has a non-None
+            trait field, providing this argument overwrites the field.
         kwargs : dict
             Additional keyword arguments.
         """
         # get axis
         axis = get_axis(axis, self.mat_ndim)
 
         # dispatch functions
-        if axis in self.square_axes:
-            self.append_taxa(
-                values = values,
-                taxa = taxa,
-                taxa_grp = taxa_grp,
-                **kwargs
-            )
-        elif axis == self.trait_axis:
+        if axis == self.trait_axis:
             self.append_trait(
                 values = values,
                 trait = trait,
                 **kwargs
             )
         else:
             raise ValueError("cannot append along axis {0}".format(axis))
 
+    def append_trait(
+            self, 
+            values: Union[Matrix,numpy.ndarray], 
+            trait: Optional[numpy.ndarray] = None, 
+            **kwargs: dict
+        ) -> None:
+        """
+        Append values to the Matrix along the trait axis.
+
+        Parameters
+        ----------
+        values : Matrix, numpy.ndarray
+            Values are appended to append to the matrix.
+        trait : numpy.ndarray
+            Trait names to append to the Matrix.
+        kwargs : dict
+            Additional keyword arguments.
+        """
+        # extract mat values
+        if isinstance(values, self.__class__):
+            if trait is None:
+                trait = values.trait
+            values = values.mat
+        elif not isinstance(values, numpy.ndarray):
+            raise ValueError("'values' must be of type {0} or numpy.ndarray".format(self.__class__))
+
+        # perform error checks before allocating memory
+        if values.ndim != self.mat_ndim:
+            raise ValueError("cannot append: 'values' must have ndim == {0}".format(self.mat_ndim))
+        for i,(j,k) in enumerate(zip(values.shape, self.mat_shape)):
+            if (i != self.trait_axis) and (j != k):
+                raise ValueError("cannot append: axis lengths incompatible for axis {0}".format(i))
+        if (self._trait is not None) and (trait is None):
+            raise ValueError("cannot append: 'trait' argument is required")
+
+        # append values
+        self._mat = numpy.append(self._mat, values, axis = self.trait_axis)
+        if self._trait is not None:
+            self._trait = numpy.append(self._trait, trait, axis = 0)
+
     def remove(
             self, 
             obj: Union[int,slice,Sequence], 
             axis: int = -1, 
             **kwargs: dict
         ) -> None:
         """
@@ -485,79 +707,121 @@
             The axis along which to remove the subarray defined by obj.
         kwargs : dict
             Additional keyword arguments.
         """
         # get axis
         axis = get_axis(axis, self.mat_ndim)
 
-        if axis in self.square_axes:
-            self.remove_taxa(obj = obj, **kwargs)
-        elif axis == self.trait_axis:
+        if axis == self.trait_axis:
             self.remove_trait(obj = obj, **kwargs)
         else:
             raise ValueError("cannot remove along axis {0}".format(axis))
 
+    def remove_trait(
+            self, 
+            obj: Union[int,slice,Sequence], 
+            **kwargs: dict
+        ) -> None:
+        """
+        Remove sub-arrays along the trait axis.
+
+        Parameters
+        ----------
+        obj : int, slice, or Sequence of ints
+            Indicate indices of sub-arrays to remove along the specified axis.
+        kwargs : dict
+            Additional keyword arguments.
+        """
+        # delete values
+        self._mat = numpy.delete(self._mat, obj, axis = self.trait_axis)
+
+        if self._trait is not None:
+            self._trait = numpy.delete(self._trait, obj, axis = 0)
+
     def incorp(
             self, 
             obj: Union[int,slice,Sequence], 
             values: Union[Matrix,numpy.ndarray], 
             axis: int = -1, 
-            taxa: Optional[numpy.ndarray] = None, 
-            taxa_grp: Optional[numpy.ndarray] = None, 
-            trait: Optional[numpy.ndarray] = None,
+            trait: Optional[numpy.ndarray] = None, 
             **kwargs: dict
         ) -> None:
         """
         Incorporate values along the given axis before the given indices.
 
         Parameters
         ----------
         obj: int, slice, or Sequence of ints
             Object that defines the index or indices before which values is
             incorporated.
         values : array_like
             Values to incorporate into the matrix.
         axis : int
             The axis along which values are incorporated.
-        taxa : numpy.ndarray
-            Taxa names to incorporate into the Matrix.
-            If values is a DenseSquareTaxaTraitMatrix that has a non-None
-            taxa field, providing this argument overwrites the field.
-        taxa_grp : numpy.ndarray
-            Taxa groups to incorporate into the Matrix.
-            If values is a DenseSquareTaxaTraitMatrix that has a non-None
-            taxa_grp field, providing this argument overwrites the field.
-        trait : numpy.ndarray, None
-            Trait names to incorporate into the Matrix.
-            If ``values`` is a DenseSquareTaxaTraitMatrix that has a non-None
-            taxa_grp field, providing this argument overwrites the field.
         kwargs : dict
             Additional keyword arguments.
         """
         # get axis
         axis = get_axis(axis, self.mat_ndim)
 
-        if axis in self.square_axes:
-            self.incorp_taxa(
-                obj = obj,
-                values = values,
-                taxa = taxa,
-                taxa_grp = taxa_grp,
-                **kwargs
-            )
-        elif axis == self.trait_axis:
-            self.incorp_trait(
+        if axis == self.trait_axis:
+            self.incorp(
                 obj = obj,
                 values = values,
                 trait = trait,
                 **kwargs
             )
         else:
             raise ValueError("cannot incorp along axis {0}".format(axis))
 
+    def incorp_trait(
+            self, 
+            obj: Union[int,slice,Sequence], 
+            values: Union[Matrix,numpy.ndarray], 
+            trait: Optional[numpy.ndarray] = None, 
+            **kwargs: dict
+        ) -> None:
+        """
+        Incorporate values along the trait axis before the given indices.
+
+        Parameters
+        ----------
+        obj: int, slice, or Sequence of ints
+            Object that defines the index or indices before which values is
+            incorporated.
+        values : Matrix, numpy.ndarray
+            Values to incorporate into the matrix.
+        trait : numpy.ndarray
+            Trait names to incorporate into the Matrix.
+        kwargs : dict
+            Additional keyword arguments.
+        """
+        # extract mat values
+        if isinstance(values, self.__class__):
+            if trait is None:
+                trait = values.trait
+            values = values.mat
+        elif not isinstance(values, numpy.ndarray):
+            raise ValueError("'values' must be of type DenseTraitMatrix or numpy.ndarray")
+
+        # perform error checks before allocating memory
+        if values.ndim != self.mat_ndim:
+            raise ValueError("cannot incorp: 'values' must have ndim == {0}".format(self.mat_ndim))
+        for i,(j,k) in enumerate(zip(values.shape, self.mat_shape)):
+            if (i != self.trait_axis) and (j != k):
+                raise ValueError("cannot incorp: axis lengths incompatible for axis {0}".format(i))
+        if (self._trait is not None) and (trait is None):
+            raise ValueError("cannot incorp: 'trait' argument is required")
+
+        # insert values
+        self._mat = numpy.insert(self._mat, obj, values, axis = self.trait_axis)
+
+        if self._trait is not None:
+            self._trait = numpy.insert(self._trait, obj, trait, axis = 0)
+
     ################### Sorting Methods ####################
     def lexsort(
             self, 
             keys: Union[tuple,numpy.ndarray,None], 
             axis: int = -1, 
             **kwargs: dict
         ) -> numpy.ndarray:
@@ -567,35 +831,79 @@
         Parameters
         ----------
         keys : tuple, None
             A tuple of columns to be sorted. The last column is the primary
             sort key.
         axis : int
             The axis of the Matrix over which to sort values.
-        kwargs : dict
-            Additional keyword arguments.
 
         Returns
         -------
         indices : numpy.ndarray
             Array of indices that sort the keys.
         """
         axis = get_axis(axis, self.mat_ndim)    # transform axis number to an index
         indices = None                          # declare variable
 
         # dispatch to correct function
-        if axis in self.square_axes:
-            indices = self.lexsort_taxa(keys = keys, **kwargs)
-        elif axis == self.trait_axis:
+        if axis == self.trait_axis:
             indices = self.lexsort_trait(keys = keys, **kwargs)
         else:
             raise ValueError("cannot lexsort along axis {0}".format(axis))
 
         return indices
 
+    def lexsort_trait(
+            self, 
+            keys: Union[tuple,numpy.ndarray,None] = None, 
+            **kwargs: dict
+        ) -> numpy.ndarray:
+        """
+        Perform an indirect stable sort using a sequence of keys along the trait
+        axis.
+
+        Parameters
+        ----------
+        keys : A (k, N) array or tuple containing k (N,)-shaped sequences
+            The k different columns to be sorted. The last column (or row if
+            keys is a 2D array) is the primary sort key.
+        kwargs : dict
+            Additional keyword arguments.
+
+        Returns
+        -------
+        indices : A (N,) ndarray of ints
+            Array of indices that sort the keys along the specified axis.
+        """
+        # default error message
+        emess = "no available keys to sort"
+
+        # if no keys were provided, set a default
+        if keys is None:
+            keys = (self._trait,)    # trait default keys
+            emess = "trait is None"  # trait error message
+
+        # remove None keys
+        keys = tuple(k for k in keys if k is not None)
+
+        # raise error if no keys remain
+        if len(keys) == 0:
+            raise ValueError("cannot lexsort on axis {0} (trait axis): {1}".format(self.trait_axis, emess))
+
+        # raise error if keys are of incompatible length
+        if any(len(k) != self.ntrait for k in keys):
+            emess = "keys are not all length {0}".format(self.ntrait)
+            raise ValueError("cannot lexsort on axis {0} (trait axis): {1}".format(self.trait_axis, emess))
+
+        # get indices
+        indices = numpy.lexsort(keys)
+
+        # return indices
+        return indices
+
     def reorder(
             self, 
             indices: Union[numpy.ndarray,Sequence], 
             axis: int = -1, 
             **kwargs: dict
         ) -> None:
         """
@@ -603,258 +911,314 @@
 
         Parameters
         ----------
         indices : numpy.ndarray
             Indices of where to place elements.
         axis : int
             The axis over which to reorder values.
-        kwargs : dict
-            Additional keyword arguments.
         """
         axis = get_axis(axis, self.mat_ndim)                   # transform axis number to an index
 
-        if axis in self.square_axes:
-            self.reorder_taxa(indices = indices, **kwargs)
-        elif axis == self.trait_axis:
-            self.reorder_trait(indices = indices, **kwargs)
+        if axis == self.trait_axis:
+            self.reorder(indices = indices, **kwargs)
         else:
             raise ValueError("cannot reorder along axis {0}".format(axis))
 
-    def sort(
+    def reorder_trait(
             self, 
-            keys: Optional[Union[tuple,numpy.ndarray]] = None, 
-            axis: int = -1, 
+            indices: Union[numpy.ndarray,Sequence], 
             **kwargs: dict
         ) -> None:
         """
-        Reset metadata for corresponding axis: name, stix, spix, len.
-        Sort the VariantMatrix using a tuple of keys.
+        Reorder elements of the Matrix along the trait axis using an array of
+        indices. Note this modifies the Matrix in-place.
 
         Parameters
         ----------
-        keys : tuple, None
-            A tuple of columns to be sorted. The last column is the primary
-            sort key.
-        axis : int
-            The axis over which to sort values.
+        indices : A (N,) ndarray of ints
+            Array of indices that reorder the matrix along the specified axis.
         kwargs : dict
             Additional keyword arguments.
         """
-        # transform axis number to an index
-        axis = get_axis(axis, self.mat_ndim)
+        # build a tuple to slice the matrix
+        ix = tuple(indices if i == self.trait_axis else slice(None) for i in range(self.mat_ndim))
 
-        # dispatch functions
-        if axis in self.square_axes:
-            self.sort_taxa(keys = keys, **kwargs)
-        elif axis == self.trait_axis:
-            self.sort_trait(keys = keys, **kwargs)
-        else:
-            raise ValueError("cannot sort along axis {0}".format(axis))
+        # reorder arrays
+        self._mat = self._mat[ix]
+
+        if self._trait is not None:
+            self._trait = self._trait[indices]                # reorder trait array
 
-    ################### Grouping Methods ###################
-    def group(
+    def sort(
             self, 
+            keys: Union[tuple,numpy.ndarray,None], 
             axis: int = -1, 
             **kwargs: dict
         ) -> None:
         """
-        Sort the DenseSquareTaxaTraitMatrix along an axis, then populate 
-        grouping indices.
+        Reset metadata for corresponding axis: name, stix, spix, len.
+        Sort the VariantMatrix using a tuple of keys.
 
         Parameters
         ----------
+        keys : tuple, None
+            A tuple of columns to be sorted. The last column is the primary
+            sort key.
         axis : int
-            The axis along which values are grouped.
-        kwargs : dict
-            Additional keyword arguments.
+            The axis over which to sort values.
         """
         # transform axis number to an index
         axis = get_axis(axis, self.mat_ndim)
 
         # dispatch functions
-        if axis in self.square_axes:
-            self.group_taxa(**kwargs)
-        elif axis == self.trait_axis:
-            raise ValueError("cannot group along trait axis {0}".format(axis))
+        if axis == self.trait_axis:
+            self.sort_trait(keys = keys, **kwargs)
         else:
-            raise ValueError("cannot group along axis {0}".format(axis))
+            raise ValueError("cannot sort along axis {0}".format(axis))
 
-    def ungroup(
-            self,
-            axis: int = -1,
+    def sort_trait(
+            self, 
+            keys: Union[tuple,numpy.ndarray,None] = None, 
             **kwargs: dict
         ) -> None:
         """
-        Ungroup the DenseSquareTaxaMatrix along an axis by removing grouping 
-        metadata.
+        Sort slements of the Matrix along the trait axis using a sequence of
+        keys. Note this modifies the Matrix in-place.
 
         Parameters
         ----------
-        axis : int
-            The axis along which values should be ungrouped.
+        keys : A (k, N) array or tuple containing k (N,)-shaped sequences
+            The k different columns to be sorted. The last column (or row if
+            keys is a 2D array) is the primary sort key.
         kwargs : dict
             Additional keyword arguments.
         """
-        # transform axis number to an index
-        axis = get_axis(axis, self.mat_ndim)
+        # get indices for sort
+        indices = self.lexsort_trait(keys, **kwargs)
 
-        # dispatch functions
-        if axis in self.square_axes:
-            self.ungroup_taxa(**kwargs)
-        elif axis == self.trait_axis:
-            raise ValueError("cannot ungroup along trait axis {0}".format(axis))
-        else:
-            raise ValueError("cannot ungroup along axis {0}".format(axis))
+        # reorder internals
+        self.reorder_trait(indices, **kwargs)
 
-    def is_grouped(
+    ################### Matrix File I/O ####################
+    def to_hdf5(
             self, 
-            axis: int = -1, 
-            **kwargs: dict
-        ) -> bool:
+            filename: Union[str,Path,h5py.File], 
+            groupname: Optional[str] = None,
+            overwrite: bool = True,
+        ) -> None:
         """
-        Determine whether the Matrix has been sorted and grouped.
+        Write ``DenseTraitMatrix`` to an HDF5 file.
 
         Parameters
         ----------
-        axis : int
-            Axis to test for grouping.
-        kwargs : dict
-            Additional keyword arguments.
+        filename : str, Path, h5py.File
+            If ``str``, an HDF5 file name to which to write. File is closed after writing.
+            If ``h5py.File``, an opened HDF5 file to which to write. File is not closed after writing.
+
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseMatrix`` data is stored.
+            If ``None``, the ``DenseMatrix`` is written to the base HDF5 group.
+
+        overwrite : bool
+            Whether to overwrite values in an HDF5 file if a field already exists.
+        """
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in append (``r+``) mode
+        if isinstance(filename, (str,Path)):
+            h5file = h5py.File(filename, "a")
+
+        # elif we have an h5py.File, make sure mode is writable, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_writable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
 
-        Returns
-        -------
-        grouped : bool
-            True or False indicating whether the GeneticMap has been sorted and
-            grouped.
-        """
-        axis = get_axis(axis, self.mat_ndim)    # transform axis number to an index
-        grouped = False                         # default output
+        ########################################################
+        ############ process ``groupname`` argument ############
 
-        if axis in self.square_axes:
-            grouped = self.is_grouped_taxa(**kwargs)
-        elif axis == self.trait_axis:
-            raise ValueError("cannot test for grouping along trait axis {0}".format(axis))
+        # if we have a string
+        if isinstance(groupname, str):
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
         else:
-            raise ValueError("cannot test for grouping along axis {0}".format(axis))
-
-        return grouped
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
 
-    ################### Matrix File I/O ####################
-    def to_hdf5(
-            self, 
-            filename: str, 
-            groupname: Optional[str] = None
-        ) -> None:
-        """
-        Write DenseSquareTaxaTraitMatrix to an HDF5 file.
+        ########################################################
+        #### write data to HDF5 file and (optionally) close ####
 
-        Parameters
-        ----------
-        filename : str
-            HDF5 file name to which to write.
-        groupname : str or None
-            HDF5 group name under which the ``DenseSquareTaxaTraitMatrix`` data is stored.
-            If ``None``, the ``DenseSquareTaxaTraitMatrix`` is written to the base HDF5 group.
-        """
-        h5file = h5py.File(filename, "a")                       # open HDF5 in write mode
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### populate HDF5 file
-        data_dict = {                                           # data dictionary
-            "mat"       : self.mat,
-            "taxa"      : self.taxa,
-            "taxa_grp"  : self.taxa_grp,
-            "trait"     : self.trait
+        # data dictionary
+        data = {
+            "mat"   : self.mat,
+            "trait" : self.trait,
         }
-        save_dict_to_hdf5(h5file, groupname, data_dict)         # save data
-        ######################################################### write conclusion
-        h5file.close()                                          # close the file
+
+        # save data
+        h5py_File_write_dict(h5file, groupname, data, overwrite)
+
+        # close the file, only if the provided filename was a string or Path and not a h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
 
     ############################## Class Methods ###############################
 
     ################### Matrix File I/O ####################
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
-        ) -> 'DenseSquareTaxaTraitMatrix':
+        ) -> 'DenseTraitMatrix':
         """
-        Read DenseSquareTaxaTraitMatrix from an HDF5 file.
+        Read a ``DenseTraitMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseSquareTaxaTraitMatrix data is stored.
-            If None, DenseSquareTaxaTraitMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseTraitMatrix`` data is stored.
+            If ``None``, ``DenseTraitMatrix`` is read from base HDF5 group.
 
         Returns
         -------
-        out : DenseSquareTaxaTraitMatrix
-            A dense matrix read from file.
-        """
-        check_file_exists(filename)                             # check file exists
-        h5file = h5py.File(filename, "r")                       # open HDF5 in read only
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            check_h5py_File_has_group(h5file, filename, groupname)    # check that group exists
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### check that we have all required fields
-        required_fields = ["mat"]                               # all required arguments
-        for field in required_fields:                           # for each required field
-            fieldname = groupname + field                       # concatenate base groupname and field
-            check_h5py_File_has_group(h5file, filename, fieldname)    # check that group exists
-        ######################################################### read data
-        data_dict = {                                           # output dictionary
-            "mat"       : None,
-            "taxa"      : None,
-            "taxa_grp"  : None,
-            "trait"     : None
+        out : DenseTraitMatrix
+            A dense trait matrix read from file.
+        """
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in read (``r``) mode
+        if isinstance(filename, (str,Path)):
+            check_file_exists(filename)
+            h5file = h5py.File(filename, "r")
+
+        # elif we have an ``h5py.File``, make sure mode is in at least ``r`` mode, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_readable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # FIXME: errors if groupname == "" or "/"
+            # if the group does not exist in the file, close and raise error
+            check_h5py_File_has_group(h5file, groupname)
+
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        ######## check that we have all required fields ########
+
+        # all required arguments
+        required_fields = ["mat"]
+
+        # for each required field, check if the field exists in the HDF5 file.
+        for field in required_fields:
+            check_h5py_File_has_group(h5file, groupname + field)
+        
+        ########################################################
+        ### read data from HDF5 file and (optionally) close ####
+        
+        # output dictionary
+        data = {
+            "mat"   : None,
+            "trait" : None,
         }
-        for field in data_dict.keys():                          # for each field
-            fieldname = groupname + field                       # concatenate base groupname and field
-            if fieldname in h5file:                             # if the field exists in the HDF5 file
-                data_dict[field] = h5file[fieldname][()]        # read array
-        ######################################################### read conclusion
-        h5file.close()                                          # close file
-        ######################################################### convert data types
-        str_fields = ["taxa","trait"]                           # string array fields
-        for field in str_fields:                                # for each field
-            if data_dict[field] is not None:                    # if the field is not None
-                arr = data_dict[field]                          # extract pointer to field
-                for i in range(len(arr)):                       # for each element in field
-                    if isinstance(arr[i], bytes):               # if element is bytes
-                        arr[i] = arr[i].decode("utf-8")         # convert bytes element to str
-                data_dict[field] = arr                          # store pointer
-        ######################################################### create object
-        mat = cls(**data_dict)                                  # create object from read data
-        return mat
+
+        ##################################
+        ### read mandatory data fields ###
+
+        # read mat array (ndarray dtype = int8)
+        data["mat"] = h5py_File_read_ndarray(h5file, groupname + "mat")
+        
+        #################################
+        ### read optional data fields ###
+
+        # read trait array (ndarray dtype = unicode / object)
+        if groupname + "trait" in h5file:
+            data["trait"] = h5py_File_read_ndarray_utf8(h5file, groupname + "trait")
+
+        ######################
+        ### close the file ###
+
+        # close the file, only if the provided fieldname was a string or Path an not an h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
+
+        ########################################################
+        ################### Object creation ####################
+        
+        # create object from read data
+        out = cls(
+            mat     = data["mat"],
+            trait   = data["trait"],
+        )
+
+        return out
 
 
 
 ################################## Utilities ###################################
-def check_is_DenseSquareTaxaTraitMatrix(v: object, vname: str) -> None:
+def check_is_DenseTraitMatrix(v: object, vname: str) -> None:
     """
-    Check if object is of type DenseSquareTaxaTraitMatrix. Otherwise raise TypeError.
+    Check if object is of type DenseTraitMatrix. Otherwise raise TypeError.
 
     Parameters
     ----------
     v : object
         Any Python object to test.
     vname : str
         Name of variable to print in TypeError message.
     """
-    if not isinstance(v, DenseSquareTaxaTraitMatrix):
-        raise TypeError("variable '{0}' must be a of type '{1}' but received type '{2}'".format(vname,DenseSquareTaxaTraitMatrix.__name__,type(v).__name__))
+    if not isinstance(v, DenseTraitMatrix):
+        raise TypeError("variable '{0}' must be a of type '{1}' but received type '{2}'".format(vname,DenseTraitMatrix.__name__,type(v).__name__))
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/DenseSquareTraitMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/DenseSquareTraitMatrix.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,25 +5,27 @@
 
 __all__ = [
     "DenseSquareTraitMatrix",
     "check_is_DenseSquareTraitMatrix",
 ]
 
 import copy
-from typing import Optional, Sequence, Union
+from typing import Optional
+from typing import Sequence
+from typing import Union
 import numpy
 from numpy.typing import ArrayLike
 from pybrops.core.error.error_attr_python import check_is_iterable
 from pybrops.core.error.error_generic_python import generic_check_isinstance
 from pybrops.core.error.error_type_python import check_is_array_like
 from pybrops.core.mat.DenseSquareMatrix import DenseSquareMatrix
 from pybrops.core.mat.DenseTraitMatrix import DenseTraitMatrix
 from pybrops.core.mat.Matrix import Matrix
 from pybrops.core.mat.SquareTraitMatrix import SquareTraitMatrix
-from pybrops.core.mat.util import get_axis
+from pybrops.core.util.array import get_axis
 
 class DenseSquareTraitMatrix(
         DenseSquareMatrix,
         DenseTraitMatrix,
         SquareTraitMatrix,
     ):
     """
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/DenseTaxaMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/DenseTaxaMatrix.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,39 +5,49 @@
 
 __all__ = [
     "DenseTaxaMatrix",
     "check_is_DenseTaxaMatrix",
 ]
 
 import copy
+from pathlib import Path
 import numpy
 import h5py
-from typing import Optional, Sequence, Union
+from typing import Optional
+from typing import Sequence
+from typing import Union
 
 from numpy.typing import ArrayLike
 
 from pybrops.core.error.error_io_python import check_file_exists
 from pybrops.core.error.error_type_python import check_is_array_like
 from pybrops.core.error.error_attr_python import check_is_iterable
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_readable
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_writable
 from pybrops.core.error.error_value_numpy import check_ndarray_axis_len
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_integer
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_object
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.core.error.error_attr_python import error_readonly
 from pybrops.core.error.error_generic_python import generic_check_isinstance
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim_gteq
 from pybrops.core.mat.Matrix import Matrix
-from pybrops.core.mat.util import get_axis
+from pybrops.core.util.array import get_axis
 from pybrops.core.mat.DenseMutableMatrix import DenseMutableMatrix
 from pybrops.core.mat.TaxaMatrix import TaxaMatrix
-from pybrops.core.util.h5py import save_dict_to_hdf5
-
-class DenseTaxaMatrix(DenseMutableMatrix,TaxaMatrix):
+from pybrops.core.util.h5py import h5py_File_read_ndarray
+from pybrops.core.util.h5py import h5py_File_read_ndarray_utf8
+from pybrops.core.util.h5py import h5py_File_write_dict
+
+class DenseTaxaMatrix(
+        DenseMutableMatrix,
+        TaxaMatrix,
+    ):
     """
     A concrete class for dense matrices with taxa metadata.
 
     The purpose of this concrete class is to implement base functionality for:
         1) Dense matrix taxa metadata.
         2) Dense matrix taxa routines.
     """
@@ -747,17 +757,15 @@
             raise ValueError("cannot concat: 'taxa_grp' needed for all Matrix in list")
 
         # concatenate mat, taxa, taxa_grp items
         mat = numpy.concatenate(mat_ls, axis = mats[0].taxa_axis)
         taxa = None if taxa_ls is None else numpy.concatenate(taxa_ls, axis = 0)
         taxa_grp = None if taxa_grp_ls is None else numpy.concatenate(taxa_grp_ls, axis = 0)
 
-        # TODO: decide if first element in list is good source of information
         # concatenate everything and put into new DenseTaxaMatrix
-        # use first element as source of variant data
         out = cls(
             mat = mat,
             taxa = taxa,
             taxa_grp = taxa_grp,
             **kwargs
         )
 
@@ -779,14 +787,24 @@
         ----------
         values : DenseTaxaMatrix, numpy.ndarray
             Values are appended to append to the matrix.
             Must be of type int8.
             Must be of shape (m, n, p)
         axis : int
             The axis along which values are appended.
+        taxa : numpy.ndarray
+            Taxa names to append to the Matrix.
+            If values is a DenseTaxaMatrix that has a non-None
+            taxa field, providing this argument overwrites the field.
+        taxa_grp : numpy.ndarray
+            Taxa groups to append to the Matrix.
+            If values is a DenseTaxaMatrix that has a non-None
+            taxa_grp field, providing this argument overwrites the field.
+        kwargs : dict
+            Additional keyword arguments.
         """
         # get axis
         axis = get_axis(axis, self.mat_ndim)
 
         # dispatch functions
         if axis == self.taxa_axis:
             self.append_taxa(
@@ -925,14 +943,22 @@
         obj: int, slice, or Sequence of ints
             Object that defines the index or indices before which values is
             incorporated.
         values : array_like
             Values to incorporate into the matrix.
         axis : int
             The axis along which values are incorporated.
+        taxa : numpy.ndarray
+            Taxa names to incorporate into the Matrix.
+            If values is a DenseTaxaMatrix that has a non-None
+            taxa field, providing this argument overwrites the field.
+        taxa_grp : numpy.ndarray
+            Taxa groups to incorporate into the Matrix.
+            If values is a DenseTaxaMatrix that has a non-None
+            taxa_grp field, providing this argument overwrites the field.
         kwargs : dict
             Additional keyword arguments.
         """
         # get axis
         axis = get_axis(axis, self.mat_ndim)
 
         if axis == self.taxa_axis:
@@ -1019,14 +1045,16 @@
         Parameters
         ----------
         keys : tuple, None
             A tuple of columns to be sorted. The last column is the primary
             sort key.
         axis : int
             The axis of the Matrix over which to sort values.
+        kwargs : dict
+            Additional keyword arguments.
 
         Returns
         -------
         indices : numpy.ndarray
             Array of indices that sort the keys.
         """
         axis = get_axis(axis, self.mat_ndim)    # transform axis number to an index
@@ -1091,23 +1119,24 @@
     def reorder(
             self, 
             indices: Union[numpy.ndarray,Sequence], 
             axis: int = -1, 
             **kwargs: dict
         ) -> None:
         """
-        Reorder the VariantMatrix.
+        Reorder values in the ``DenseTaxaMatrix``.
 
         Parameters
         ----------
         indices : numpy.ndarray
             Indices of where to place elements.
         axis : int
             The axis over which to reorder values.
-
+        kwargs : dict
+            Additional keyword arguments.
         """
         axis = get_axis(axis, self.mat_ndim)                   # transform axis number to an index
 
         if axis == self.taxa_axis:
             self.reorder(indices = indices, **kwargs)
         else:
             raise ValueError("cannot reorder along axis {0}".format(axis))
@@ -1152,14 +1181,16 @@
         Parameters
         ----------
         keys : tuple, None
             A tuple of columns to be sorted. The last column is the primary
             sort key.
         axis : int
             The axis over which to sort values.
+        kwargs : dict
+            Additional keyword arguments.
         """
         # transform axis number to an index
         axis = get_axis(axis, self.mat_ndim)
 
         # dispatch functions
         if axis == self.taxa_axis:
             self.sort_taxa(keys = keys, **kwargs)
@@ -1291,14 +1322,21 @@
             self, 
             axis: int = -1, 
             **kwargs: dict
         ) -> bool:
         """
         Determine whether the Matrix has been sorted and grouped.
 
+        Parameters
+        ----------
+        axis : int
+            The axis along which to test if values are grouped.
+        kwargs : dict
+            Additional keyword arguments.
+
         Returns
         -------
         grouped : bool
             True or False indicating whether the GeneticMap has been sorted and
             grouped.
         """
         axis = get_axis(axis, self.mat_ndim)    # transform axis number to an index
@@ -1336,103 +1374,260 @@
             (self._taxa_grp_spix is not None) and
             (self._taxa_grp_len is not None)
         )
 
     ################### Matrix File I/O ####################
     def to_hdf5(
             self, 
-            filename: str, 
-            groupname: Optional[str] = None
+            filename: Union[str,Path,h5py.File], 
+            groupname: Optional[str] = None,
+            overwrite: bool = True,
         ) -> None:
         """
-        Write GenotypeMatrix to an HDF5 file.
+        Write ``DenseTaxaMatrix`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name to which to write.
-        groupname : str or None
-            HDF5 group name under which the ``DenseMatrix`` data is stored.
-            If ``None``, the ``DenseMatrix`` is written to the base HDF5 group.
-        """
-        h5file = h5py.File(filename, "a")                       # open HDF5 in write mode
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### populate HDF5 file
-        data_dict = {                                           # data dictionary
-            "mat": self.mat,
-            "taxa" : self.taxa,
-            "taxa_grp" : self.taxa_grp
+        filename : str, Path, h5py.File
+            If ``str``, an HDF5 file name to which to write. File is closed after writing.
+            If ``h5py.File``, an opened HDF5 file to which to write. File is not closed after writing.
+
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseTaxaMatrix`` data is stored.
+            If ``None``, the ``DenseTaxaMatrix`` is written to the base HDF5 group.
+
+        overwrite : bool
+            Whether to overwrite values in an HDF5 file if a field already exists.
+        """
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in append (``r+``) mode
+        if isinstance(filename, (str,Path)):
+            h5file = h5py.File(filename, "a")
+
+        # elif we have an h5py.File, make sure mode is writable, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_writable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        #### write data to HDF5 file and (optionally) close ####
+
+        # data dictionary
+        data = {
+            "mat"           : self.mat,
+            "taxa"          : self.taxa,
+            "taxa_grp"      : self.taxa_grp,
+            # metadata
+            "taxa_grp_name" : self.taxa_grp_name,
+            "taxa_grp_stix" : self.taxa_grp_stix,
+            "taxa_grp_spix" : self.taxa_grp_spix,
+            "taxa_grp_len"  : self.taxa_grp_len,
         }
-        save_dict_to_hdf5(h5file, groupname, data_dict)         # save data
-        ######################################################### write conclusion
-        h5file.close()                                          # close the file
+
+        # save data
+        h5py_File_write_dict(h5file, groupname, data, overwrite)
+
+        # close the file, only if the provided filename was a string or Path and not a h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
 
     ############################## Class Methods ###############################
 
     ################### Matrix File I/O ####################
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseTaxaMatrix':
         """
-        Read DenseMatrix from an HDF5 file.
+        Read ``DenseTaxaMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseMatrix data is stored.
-            If None, DenseMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseTaxaMatrix`` data is stored.
+            If ``None``, ``DenseTaxaMatrix`` is read from base HDF5 group.
 
         Returns
         -------
-        out : DenseMatrix
+        out : DenseTaxaMatrix
             A dense matrix read from file.
         """
-        check_file_exists(filename)                             # check file exists
-        h5file = h5py.File(filename, "r")                       # open HDF5 in read only
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            check_h5py_File_has_group(h5file, filename, groupname)    # check that group exists
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### check that we have all required fields
-        required_fields = ["mat"]                               # all required arguments
-        for field in required_fields:                           # for each required field
-            fieldname = groupname + field                       # concatenate base groupname and field
-            check_h5py_File_has_group(h5file, filename, fieldname)    # check that group exists
-        ######################################################### read data
-        data_dict = {                                           # output dictionary
-            "mat": None,
-            "taxa" : None,
-            "taxa_grp" : None
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in read (``r``) mode
+        if isinstance(filename, (str,Path)):
+            check_file_exists(filename)
+            h5file = h5py.File(filename, "r")
+
+        # elif we have an ``h5py.File``, make sure mode is in at least ``r`` mode, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_readable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # FIXME: errors if groupname == "" or "/"
+            # if the group does not exist in the file, close and raise error
+            check_h5py_File_has_group(h5file, groupname)
+
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        ######## check that we have all required fields ########
+
+        # all required arguments
+        required_fields = ["mat"]
+
+        # for each required field, check if the field exists in the HDF5 file.
+        for field in required_fields:
+            check_h5py_File_has_group(h5file, groupname + field)
+        
+        ########################################################
+        ### read data from HDF5 file and (optionally) close ####
+        
+        # output dictionary
+        data = {
+            "mat"               : None,
+            "taxa"              : None,
+            "taxa_grp"          : None,
+            # metadata
+            "taxa_grp_name"     : None,
+            "taxa_grp_stix"     : None,
+            "taxa_grp_spix"     : None,
+            "taxa_grp_len"      : None,
         }
-        for field in data_dict.keys():                          # for each field
-            fieldname = groupname + field                       # concatenate base groupname and field
-            if fieldname in h5file:                             # if the field exists in the HDF5 file
-                data_dict[field] = h5file[fieldname][()]        # read array
-        ######################################################### read conclusion
-        h5file.close()                                          # close file
-        ######################################################### create object
-        mat = cls(**data_dict)                                  # create object from read data
-        return mat
+
+        ##################################
+        ### read mandatory data fields ###
+
+        # read mat array (ndarray dtype = int8)
+        data["mat"] = h5py_File_read_ndarray(h5file, groupname + "mat")
+        
+        #################################
+        ### read optional data fields ###
+
+        # read taxa array (ndarray dtype = unicode / object)
+        if groupname + "taxa" in h5file:
+            data["taxa"] = h5py_File_read_ndarray_utf8(h5file, groupname + "taxa")
+
+        # read taxa_grp array (ndarray dtype = any)
+        if groupname + "taxa_grp" in h5file:
+            data["taxa_grp"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp")
+        
+        #####################################
+        ### read optional metadata fields ###
+
+        # read taxa_grp_name array (ndarray dtype = any)
+        if groupname + "taxa_grp_name" in h5file:
+            data["taxa_grp_name"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_name")
+
+        # read taxa_grp_stix array (ndarray dtype = any)
+        if groupname + "taxa_grp_stix" in h5file:
+            data["taxa_grp_stix"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_stix")
+
+        # read taxa_grp_spix array (ndarray dtype = any)
+        if groupname + "taxa_grp_spix" in h5file:
+            data["taxa_grp_spix"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_spix")
+
+        # read taxa_grp_len array (ndarray dtype = any)
+        if groupname + "taxa_grp_len" in h5file:
+            data["taxa_grp_len"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_len")
+
+        ######################
+        ### close the file ###
+
+        # close the file, only if the provided fieldname was a string or Path an not an h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
+
+        ########################################################
+        ################### Object creation ####################
+        
+        # create object from read data
+        out = cls(
+            mat         = data["mat"],
+            taxa        = data["taxa"],
+            taxa_grp    = data["taxa_grp"],
+        )
+
+        # copy metadata
+        out.taxa_grp_name    = data["taxa_grp_name"]
+        out.taxa_grp_stix    = data["taxa_grp_stix"]
+        out.taxa_grp_spix    = data["taxa_grp_spix"]
+        out.taxa_grp_len     = data["taxa_grp_len"]
+
+        return out
 
 
 
 ################################## Utilities ###################################
 def check_is_DenseTaxaMatrix(v: object, vname: str) -> None:
     """
     Check if object is of type DenseTaxaMatrix. Otherwise raise TypeError.
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/DenseTaxaTraitMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/DenseTaxaTraitMatrix.py`

 * *Files 24% similar despite different names*

```diff
@@ -4,25 +4,35 @@
 """
 
 __all__ = [
     "DenseTaxaTraitMatrix",
     "check_is_DenseTaxaTraitMatrix",
 ]
 
+from pathlib import Path
 import numpy
 from numpy.typing import ArrayLike
 import copy
-from typing import Optional, Sequence, Union
-
-from pybrops.core.error.error_attr_python import error_readonly
+from typing import Optional
+from typing import Sequence
+from typing import Union
+import h5py
+
+from pybrops.core.error.error_io_python import check_file_exists
+from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_readable
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_writable
 from pybrops.core.mat.Matrix import Matrix
-from pybrops.core.mat.util import get_axis
+from pybrops.core.util.array import get_axis
 from pybrops.core.mat.DenseTaxaMatrix import DenseTaxaMatrix
 from pybrops.core.mat.DenseTraitMatrix import DenseTraitMatrix
 from pybrops.core.mat.TaxaTraitMatrix import TaxaTraitMatrix
+from pybrops.core.util.h5py import h5py_File_read_ndarray
+from pybrops.core.util.h5py import h5py_File_read_ndarray_utf8
+from pybrops.core.util.h5py import h5py_File_write_dict
 
 class DenseTaxaTraitMatrix(
         DenseTaxaMatrix,
         DenseTraitMatrix,
         TaxaTraitMatrix,
     ):
     """
@@ -933,14 +943,16 @@
         ----------
         keys : tuple, None
             A tuple of columns to be sorted. The last column is the primary
             sort key. If None, sort using vrnt_chrgrp as primary key, and
             vrnt_phypos as secondary key.
         axis : int
             The axis of the Matrix over which to sort values.
+        kwargs : dict
+            Additional keyword arguments.
 
         Returns
         -------
         indices : numpy.ndarray
             Array of indices that sort the keys.
         """
         axis = get_axis(axis, self.mat_ndim)    # transform axis number to an index
@@ -967,14 +979,16 @@
 
         Parameters
         ----------
         indices : numpy.ndarray
             Indices of where to place elements.
         axis : int
             The axis over which to reorder values.
+        kwargs : dict
+            Additional keyword arguments.
         """
         axis = get_axis(axis, self.mat_ndim)                   # transform axis number to an index
 
         if axis == self.taxa_axis:
             self.reorder_taxa(indices = indices, **kwargs)
         elif axis == self.trait_axis:
             self.reorder_trait(indices = indices, **kwargs)
@@ -995,14 +1009,16 @@
         ----------
         keys : tuple, None
             A tuple of columns to be sorted. The last column is the primary
             sort key. If None, sort using vrnt_chrgrp as primary key, and
             vrnt_phypos as secondary key.
         axis : int
             The axis over which to sort values.
+        kwargs : dict
+            Additional keyword arguments.
         """
         # transform axis number to an index
         axis = get_axis(axis, self.mat_ndim)
 
         # dispatch functions
         if axis == self.taxa_axis:
             self.sort_taxa(keys = keys, **kwargs)
@@ -1070,14 +1086,21 @@
             self, 
             axis: int = -1, 
             **kwargs: dict
         ) -> bool:
         """
         Determine whether the Matrix has been sorted and grouped.
 
+        Parameters
+        ----------
+        axis : int
+            Axis along which to test for grouping.
+        kwargs : dict
+            Additional keyword arguments.
+
         Returns
         -------
         grouped : bool
             True or False indicating whether the GeneticMap has been sorted and
             grouped.
         """
         axis = get_axis(axis, self.mat_ndim)    # transform axis number to an index
@@ -1088,14 +1111,271 @@
         elif axis == self.trait_axis:
             raise ValueError("cannot test for grouping along axis {0} (trait axis)".format(axis))
         else:
             raise ValueError("cannot test for grouping along axis {0}".format(axis))
 
         return grouped
 
+    ################### Matrix File I/O ####################
+    def to_hdf5(
+            self, 
+            filename: Union[str,Path,h5py.File], 
+            groupname: Optional[str] = None,
+            overwrite: bool = True,
+        ) -> None:
+        """
+        Write ``DenseTaxaTraitMatrix`` to an HDF5 file.
+
+        Parameters
+        ----------
+        filename : str, Path, h5py.File
+            If ``str``, an HDF5 file name to which to write. File is closed after writing.
+            If ``h5py.File``, an opened HDF5 file to which to write. File is not closed after writing.
+
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseTaxaTraitMatrix`` data is stored.
+            If ``None``, the ``DenseTaxaTraitMatrix`` is written to the base HDF5 group.
+
+        overwrite : bool
+            Whether to overwrite values in an HDF5 file if a field already exists.
+        """
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in append (``r+``) mode
+        if isinstance(filename, (str,Path)):
+            h5file = h5py.File(filename, "a")
+
+        # elif we have an h5py.File, make sure mode is writable, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_writable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        #### write data to HDF5 file and (optionally) close ####
+
+        # data dictionary
+        data = {
+            "mat"           : self.mat,
+            "taxa"          : self.taxa,
+            "taxa_grp"      : self.taxa_grp,
+            "trait"         : self.trait,
+            # metadata
+            "taxa_grp_name" : self.taxa_grp_name,
+            "taxa_grp_stix" : self.taxa_grp_stix,
+            "taxa_grp_spix" : self.taxa_grp_spix,
+            "taxa_grp_len"  : self.taxa_grp_len,
+        }
+
+        # save data
+        h5py_File_write_dict(h5file, groupname, data, overwrite)
+
+        # close the file, only if the provided filename was a string or Path and not a h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
+
+    ############################## Class Methods ###############################
+
+    ################### Matrix File I/O ####################
+    @classmethod
+    def from_hdf5(
+            cls, 
+            filename: Union[str,Path,h5py.File], 
+            groupname: Optional[str] = None
+        ) -> 'DenseTaxaTraitMatrix':
+        """
+        Read ``DenseTaxaTraitMatrix`` from an HDF5 file.
+
+        Parameters
+        ----------
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseTaxaTraitMatrix`` data is stored.
+            If ``None``, ``DenseTaxaTraitMatrix`` is read from base HDF5 group.
+
+        Returns
+        -------
+        out : DenseTaxaTraitMatrix
+            A dense matrix read from file.
+        """
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in read (``r``) mode
+        if isinstance(filename, (str,Path)):
+            check_file_exists(filename)
+            h5file = h5py.File(filename, "r")
+
+        # elif we have an ``h5py.File``, make sure mode is in at least ``r`` mode, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_readable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # FIXME: errors if groupname == "" or "/"
+            # if the group does not exist in the file, close and raise error
+            check_h5py_File_has_group(h5file, groupname)
+
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        ######## check that we have all required fields ########
+
+        # all required arguments
+        required_fields = ["mat"]
+
+        # for each required field, check if the field exists in the HDF5 file.
+        for field in required_fields:
+            check_h5py_File_has_group(h5file, groupname + field)
+        
+        ########################################################
+        ### read data from HDF5 file and (optionally) close ####
+        
+        # output dictionary
+        data = {
+            "mat"           : None,
+            "taxa"          : None,
+            "taxa_grp"      : None,
+            "trait"         : None,
+            # metadata
+            "taxa_grp_name" : None,
+            "taxa_grp_stix" : None,
+            "taxa_grp_spix" : None,
+            "taxa_grp_len"  : None,
+        }
+
+        ##################################
+        ### read mandatory data fields ###
+
+        # read mat array (ndarray dtype = int8)
+        data["mat"] = h5py_File_read_ndarray(h5file, groupname + "mat")
+        
+        #################################
+        ### read optional data fields ###
+
+        # read taxa array (ndarray dtype = unicode / object)
+        if groupname + "taxa" in h5file:
+            data["taxa"] = h5py_File_read_ndarray_utf8(h5file, groupname + "taxa")
+
+        # read taxa_grp array (ndarray dtype = any)
+        if groupname + "taxa_grp" in h5file:
+            data["taxa_grp"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp")
+        
+        # read trait array (ndarray dtype = unicode / object)
+        if groupname + "trait" in h5file:
+            data["trait"] = h5py_File_read_ndarray_utf8(h5file, groupname + "trait")
+
+        #####################################
+        ### read optional metadata fields ###
+
+        # read taxa_grp_name array (ndarray dtype = any)
+        if groupname + "taxa_grp_name" in h5file:
+            data["taxa_grp_name"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_name")
+
+        # read taxa_grp_stix array (ndarray dtype = any)
+        if groupname + "taxa_grp_stix" in h5file:
+            data["taxa_grp_stix"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_stix")
+
+        # read taxa_grp_spix array (ndarray dtype = any)
+        if groupname + "taxa_grp_spix" in h5file:
+            data["taxa_grp_spix"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_spix")
+
+        # read taxa_grp_len array (ndarray dtype = any)
+        if groupname + "taxa_grp_len" in h5file:
+            data["taxa_grp_len"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_len")
+
+        ######################
+        ### close the file ###
+
+        # close the file, only if the provided fieldname was a string or Path an not an h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
+
+        ########################################################
+        ################### Object creation ####################
+        
+        # create object from read data
+        out = cls(
+            mat         = data["mat"],
+            taxa        = data["taxa"],
+            taxa_grp    = data["taxa_grp"],
+            trait       = data["trait"],
+        )
+
+        # copy metadata
+        out.taxa_grp_name   = data["taxa_grp_name"]
+        out.taxa_grp_stix   = data["taxa_grp_stix"]
+        out.taxa_grp_spix   = data["taxa_grp_spix"]
+        out.taxa_grp_len    = data["taxa_grp_len"]
+
+        return out
+
 
 
 ################################## Utilities ###################################
 def check_is_DenseTaxaTraitMatrix(v: object, vname: str) -> None:
     """
     Check if object is of type DenseTaxaTraitMatrix. Otherwise raise TypeError.
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/DenseTaxaVariantMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/DenseTaxaVariantMatrix.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,25 +1,35 @@
 """
 Module defining implementing dense matrices with taxa and variant metadata and
 associated error checking routines.
 """
 
 import copy
+from pathlib import Path
 import numpy
-from typing import Sequence, Union
+from typing import Sequence
+from typing import Union
 from typing import Optional
 from numpy.typing import ArrayLike
+import h5py
 
+from pybrops.core.error.error_io_python import check_file_exists
 from pybrops.core.error.error_type_numpy import check_is_ndarray
+from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_readable
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_writable
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim_gteq
 from pybrops.core.mat.Matrix import Matrix
-from pybrops.core.mat.util import get_axis
+from pybrops.core.util.array import get_axis
 from pybrops.core.mat.DenseTaxaMatrix import DenseTaxaMatrix
 from pybrops.core.mat.DenseVariantMatrix import DenseVariantMatrix
 from pybrops.core.mat.TaxaVariantMatrix import TaxaVariantMatrix
+from pybrops.core.util.h5py import h5py_File_read_ndarray
+from pybrops.core.util.h5py import h5py_File_read_ndarray_utf8
+from pybrops.core.util.h5py import h5py_File_write_dict
 
 class DenseTaxaVariantMatrix(
         DenseTaxaMatrix,
         DenseVariantMatrix,
         TaxaVariantMatrix
     ):
     """
@@ -1379,14 +1389,16 @@
 
         Parameters
         ----------
         indices : numpy.ndarray
             Indices of where to place elements.
         axis : int
             The axis over which to reorder values.
+        kwargs : dict
+            Additional keyword arguments.
         """
         axis = get_axis(axis, self.mat_ndim)                   # transform axis number to an index
 
         if axis == self.taxa_axis:
             self.reorder_taxa(indices = indices, **kwargs)
         elif axis == self.vrnt_axis:
             self.reorder_vrnt(indices = indices, **kwargs)
@@ -1509,14 +1521,355 @@
         elif axis == self.vrnt_axis:
             grouped = self.is_grouped_vrnt(**kwargs)
         else:
             raise ValueError("cannot test for grouping along axis {0}".format(axis))
 
         return grouped
 
+    ################### Matrix File I/O ####################
+    def to_hdf5(
+            self, 
+            filename: Union[str,Path,h5py.File], 
+            groupname: Optional[str] = None,
+            overwrite: bool = True,
+        ) -> None:
+        """
+        Write ``DenseTaxaVariantMatrix`` to an HDF5 file.
+
+        Parameters
+        ----------
+        filename : str, Path, h5py.File
+            If ``str``, an HDF5 file name to which to write. File is closed after writing.
+            If ``h5py.File``, an opened HDF5 file to which to write. File is not closed after writing.
+
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseTaxaVariantMatrix`` data is stored.
+            If None, ``DenseTaxaVariantMatrix`` is written to the base HDF5 group.
+
+        overwrite : bool
+            Whether to overwrite values in an HDF5 file if a field already exists.
+        """
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in append (``r+``) mode
+        if isinstance(filename, (str,Path)):
+            h5file = h5py.File(filename, "a")
+
+        # elif we have an h5py.File, make sure mode is writable, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_writable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        #### write data to HDF5 file and (optionally) close ####
+
+        # data dictionary
+        data = {
+            "mat"               : self.mat,
+            "taxa"              : self.taxa,
+            "taxa_grp"          : self.taxa_grp,
+            "vrnt_chrgrp"       : self.vrnt_chrgrp,
+            "vrnt_phypos"       : self.vrnt_phypos,
+            "vrnt_name"         : self.vrnt_name,
+            "vrnt_genpos"       : self.vrnt_genpos,
+            "vrnt_xoprob"       : self.vrnt_xoprob,
+            "vrnt_hapgrp"       : self.vrnt_hapgrp,
+            "vrnt_hapalt"       : self.vrnt_hapalt,
+            "vrnt_hapref"       : self.vrnt_hapref,
+            "vrnt_mask"         : self.vrnt_mask,
+            # metadata
+            "taxa_grp_name"     : self.taxa_grp_name,
+            "taxa_grp_stix"     : self.taxa_grp_stix,
+            "taxa_grp_spix"     : self.taxa_grp_spix,
+            "taxa_grp_len"      : self.taxa_grp_len,
+            "vrnt_chrgrp_name"  : self.vrnt_chrgrp_name,
+            "vrnt_chrgrp_stix"  : self.vrnt_chrgrp_stix,
+            "vrnt_chrgrp_spix"  : self.vrnt_chrgrp_spix,
+            "vrnt_chrgrp_len"   : self.vrnt_chrgrp_len,
+        }
+
+        # save data
+        h5py_File_write_dict(h5file, groupname, data, overwrite)
+
+        # close the file, only if the provided filename was a string or Path and not a h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
+
+    ############################## Class Methods ###############################
+
+    ################### Matrix File I/O ####################
+    @classmethod
+    def from_hdf5(
+            cls, 
+            filename: Union[str,Path,h5py.File], 
+            groupname: Optional[str] = None
+        ) -> 'DenseTaxaVariantMatrix':
+        """
+        Read ``DenseTaxaVariantMatrix`` from an HDF5 file.
+
+        Parameters
+        ----------
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseTaxaVariantMatrix`` data is stored.
+            If None, ``DenseTaxaVariantMatrix`` is read from base HDF5 group.
+
+        Returns
+        -------
+        gmat : DenseTaxaVariantMatrix
+            A genotype matrix read from file.
+        """
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in read (``r``) mode
+        if isinstance(filename, (str,Path)):
+            check_file_exists(filename)
+            h5file = h5py.File(filename, "r")
+
+        # elif we have an ``h5py.File``, make sure mode is in at least ``r`` mode, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_readable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # FIXME: errors if groupname == "" or "/"
+            # if the group does not exist in the file, close and raise error
+            check_h5py_File_has_group(h5file, groupname)
+
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        ######## check that we have all required fields ########
+
+        # all required arguments
+        required_fields = ["mat"]
+
+        # for each required field, check if the field exists in the HDF5 file.
+        for field in required_fields:
+            check_h5py_File_has_group(h5file, groupname + field)
+        
+        ########################################################
+        ### read data from HDF5 file and (optionally) close ####
+        
+        # output dictionary
+        data = {
+            "mat"               : None,
+            "taxa"              : None,
+            "taxa_grp"          : None,
+            "vrnt_chrgrp"       : None,
+            "vrnt_phypos"       : None,
+            "vrnt_name"         : None,
+            "vrnt_genpos"       : None,
+            "vrnt_xoprob"       : None,
+            "vrnt_hapgrp"       : None,
+            "vrnt_hapalt"       : None,
+            "vrnt_hapref"       : None,
+            "vrnt_mask"         : None,
+            # metadata
+            "taxa_grp_name"     : None,
+            "taxa_grp_stix"     : None,
+            "taxa_grp_spix"     : None,
+            "taxa_grp_len"      : None,
+            "vrnt_chrgrp_name"  : None,
+            "vrnt_chrgrp_stix"  : None,
+            "vrnt_chrgrp_spix"  : None,
+            "vrnt_chrgrp_len"   : None,
+        }
+
+        ##################################
+        ### read mandatory data fields ###
+
+        # read mat array (ndarray dtype = any)
+        data["mat"] = h5py_File_read_ndarray(h5file, groupname + "mat")
+        
+        #################################
+        ### read optional data fields ###
+
+        # read taxa array (ndarray dtype = unicode / object)
+        if groupname + "taxa" in h5file:
+            data["taxa"] = h5py_File_read_ndarray_utf8(h5file, groupname + "taxa")
+
+        # read taxa_grp array (ndarray dtype = any)
+        if groupname + "taxa_grp" in h5file:
+            data["taxa_grp"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp")
+        
+        # read vrnt_chrgrp array (ndarray dtype = any)
+        if groupname + "vrnt_chrgrp" in h5file:
+            data["vrnt_chrgrp"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_chrgrp")
+
+        # read vrnt_phypos array (ndarray dtype = any)
+        if groupname + "vrnt_phypos" in h5file:
+            data["vrnt_phypos"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_phypos")
+
+        # read vrnt_name array (ndarray dtype = unicode / object)
+        if groupname + "vrnt_name" in h5file:
+            data["vrnt_name"] = h5py_File_read_ndarray_utf8(h5file, groupname + "vrnt_name")
+
+        # read vrnt_genpos array (ndarray dtype = any)
+        if groupname + "vrnt_genpos" in h5file:
+            data["vrnt_genpos"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_genpos")
+
+        # read vrnt_xoprob array (ndarray dtype = any)
+        if groupname + "vrnt_xoprob" in h5file:
+            data["vrnt_xoprob"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_xoprob")
+
+        # read vrnt_hapgrp array (ndarray dtype = any)
+        if groupname + "vrnt_hapgrp" in h5file:
+            data["vrnt_hapgrp"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_hapgrp")
+
+        # read vrnt_hapalt array (ndarray dtype = unicode / object)
+        if groupname + "vrnt_hapalt" in h5file:
+            data["vrnt_hapalt"] = h5py_File_read_ndarray_utf8(h5file, groupname + "vrnt_hapalt")
+
+        # read vrnt_hapref array (ndarray dtype = unicode / object)
+        if groupname + "vrnt_hapref" in h5file:
+            data["vrnt_hapref"] = h5py_File_read_ndarray_utf8(h5file, groupname + "vrnt_hapref")
+
+        # read vrnt_mask array (ndarray dtype = any)
+        if groupname + "vrnt_mask" in h5file:
+            data["vrnt_mask"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_mask")
+
+        #####################################
+        ### read optional metadata fields ###
+
+        # read taxa_grp_name array (ndarray dtype = any)
+        if groupname + "taxa_grp_name" in h5file:
+            data["taxa_grp_name"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_name")
+
+        # read taxa_grp_stix array (ndarray dtype = any)
+        if groupname + "taxa_grp_stix" in h5file:
+            data["taxa_grp_stix"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_stix")
+
+        # read taxa_grp_spix array (ndarray dtype = any)
+        if groupname + "taxa_grp_spix" in h5file:
+            data["taxa_grp_spix"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_spix")
+
+        # read taxa_grp_len array (ndarray dtype = any)
+        if groupname + "taxa_grp_len" in h5file:
+            data["taxa_grp_len"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_len")
+
+        # read vrnt_chrgrp_name array (ndarray dtype = any)
+        if groupname + "vrnt_chrgrp_name" in h5file:
+            data["vrnt_chrgrp_name"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_chrgrp_name")
+
+        # read vrnt_chrgrp_stix array (ndarray dtype = any)
+        if groupname + "vrnt_chrgrp_stix" in h5file:
+            data["vrnt_chrgrp_stix"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_chrgrp_stix")
+
+        # read vrnt_chrgrp_spix array (ndarray dtype = any)
+        if groupname + "vrnt_chrgrp_spix" in h5file:
+            data["vrnt_chrgrp_spix"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_chrgrp_spix")
+
+        # read vrnt_chrgrp_len array (ndarray dtype = any)
+        if groupname + "vrnt_chrgrp_len" in h5file:
+            data["vrnt_chrgrp_len"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_chrgrp_len")
+
+        ######################
+        ### close the file ###
+
+        # close the file, only if the provided fieldname was a string or Path an not an h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
+
+        ########################################################
+        ################### Object creation ####################
+        
+        # create object from read data
+        out = cls(
+            mat         = data["mat"],
+            taxa        = data["taxa"],
+            taxa_grp    = data["taxa_grp"],
+            vrnt_chrgrp = data["vrnt_chrgrp"],
+            vrnt_phypos = data["vrnt_phypos"],
+            vrnt_name   = data["vrnt_name"],
+            vrnt_genpos = data["vrnt_genpos"],
+            vrnt_xoprob = data["vrnt_xoprob"],
+            vrnt_hapgrp = data["vrnt_hapgrp"],
+            vrnt_hapalt = data["vrnt_hapalt"],
+            vrnt_hapref = data["vrnt_hapref"],
+            vrnt_mask   = data["vrnt_mask"], 
+        )
+
+        # copy metadata
+        out.taxa_grp_name    = data["taxa_grp_name"]
+        out.taxa_grp_stix    = data["taxa_grp_stix"]
+        out.taxa_grp_spix    = data["taxa_grp_spix"]
+        out.taxa_grp_len     = data["taxa_grp_len"]
+        out.vrnt_chrgrp_name = data["vrnt_chrgrp_name"]
+        out.vrnt_chrgrp_stix = data["vrnt_chrgrp_stix"]
+        out.vrnt_chrgrp_spix = data["vrnt_chrgrp_spix"]
+        out.vrnt_chrgrp_len  = data["vrnt_chrgrp_len"]
+
+        return out
+
 
 
 ################################## Utilities ###################################
 def check_is_DenseTaxaVariantMatrix(v: object, vname: str) -> None:
     """
     Check if object is of type DenseTaxaVariantMatrix. Otherwise raise TypeError.
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/DenseVariantMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/DenseVariantMatrix.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,34 +5,47 @@
 
 __all__ = [
     "DenseVariantMatrix",
     "check_is_DenseVariantMatrix",
 ]
 
 import copy
+from pathlib import Path
 import numpy
-from typing import Sequence, Union
+from typing import Sequence
+from typing import Union
 from typing import Optional
 from numpy.typing import ArrayLike
+import h5py
 
 from pybrops.core.error.error_attr_python import check_is_iterable
+from pybrops.core.error.error_io_python import check_file_exists
 from pybrops.core.error.error_type_numpy import check_is_ndarray
+from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_readable
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_writable
 from pybrops.core.error.error_value_numpy import check_ndarray_axis_len
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_bool
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_integer
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_float64
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_object
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.core.error.error_generic_python import generic_check_isinstance
 from pybrops.core.mat.Matrix import Matrix
-from pybrops.core.mat.util import get_axis
+from pybrops.core.util.array import get_axis
 from pybrops.core.mat.DenseMutableMatrix import DenseMutableMatrix
 from pybrops.core.mat.VariantMatrix import VariantMatrix
-
-class DenseVariantMatrix(DenseMutableMatrix,VariantMatrix):
+from pybrops.core.util.h5py import h5py_File_read_ndarray
+from pybrops.core.util.h5py import h5py_File_read_ndarray_utf8
+from pybrops.core.util.h5py import h5py_File_write_dict
+
+class DenseVariantMatrix(
+        DenseMutableMatrix,
+        VariantMatrix,
+    ):
     """
     A concrete class for dense matrices with variant metadata.
 
     The purpose of this concrete class is to implement base functionality for:
         1) Dense matrix variant metadata.
         2) Dense matrix variant routines.
     """
@@ -2112,14 +2125,313 @@
         return (
             (self._vrnt_chrgrp_name is not None) and
             (self._vrnt_chrgrp_stix is not None) and
             (self._vrnt_chrgrp_spix is not None) and
             (self._vrnt_chrgrp_len is not None)
         )
 
+    ################### Matrix File I/O ####################
+    def to_hdf5(
+            self, 
+            filename: Union[str,Path,h5py.File], 
+            groupname: Optional[str] = None,
+            overwrite: bool = True,
+        ) -> None:
+        """
+        Write ``DenseVariantMatrix`` to an HDF5 file.
+
+        Parameters
+        ----------
+        filename : str, Path, h5py.File
+            If ``str``, an HDF5 file name to which to write. File is closed after writing.
+            If ``h5py.File``, an opened HDF5 file to which to write. File is not closed after writing.
+
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseMatrix`` data is stored.
+            If ``None``, the ``DenseMatrix`` is written to the base HDF5 group.
+
+        overwrite : bool
+            Whether to overwrite values in an HDF5 file if a field already exists.
+        """
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in append (``r+``) mode
+        if isinstance(filename, (str,Path)):
+            h5file = h5py.File(filename, "a")
+
+        # elif we have an h5py.File, make sure mode is writable, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_writable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        #### write data to HDF5 file and (optionally) close ####
+
+        # data dictionary
+        data = {
+            "mat"              : self.mat,
+            "vrnt_chrgrp"      : self.vrnt_chrgrp,
+            "vrnt_phypos"      : self.vrnt_phypos,
+            "vrnt_name"        : self.vrnt_name,
+            "vrnt_genpos"      : self.vrnt_genpos,
+            "vrnt_xoprob"      : self.vrnt_xoprob,
+            "vrnt_hapgrp"      : self.vrnt_hapgrp,
+            "vrnt_hapalt"      : self.vrnt_hapalt,
+            "vrnt_hapref"      : self.vrnt_hapref,
+            "vrnt_mask"        : self.vrnt_mask,
+            # metadata
+            "vrnt_chrgrp_name" : self.vrnt_chrgrp_name,
+            "vrnt_chrgrp_stix" : self.vrnt_chrgrp_stix,
+            "vrnt_chrgrp_spix" : self.vrnt_chrgrp_spix,
+            "vrnt_chrgrp_len"  : self.vrnt_chrgrp_len,
+        }
+
+        # save data
+        h5py_File_write_dict(h5file, groupname, data, overwrite)
+
+        # close the file, only if the provided filename was a string or Path and not a h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
+
+    ############################## Class Methods ###############################
+
+    ################### Matrix File I/O ####################
+    @classmethod
+    def from_hdf5(
+            cls, 
+            filename: Union[str,Path,h5py.File], 
+            groupname: Optional[str] = None
+        ) -> 'DenseVariantMatrix':
+        """
+        Read ``DenseVariantMatrix`` from an HDF5 file.
+
+        Parameters
+        ----------
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseVariantMatrix`` data is stored.
+            If None, ``DenseVariantMatrix`` is read from base HDF5 group.
+
+        Returns
+        -------
+        out : DenseVariantMatrix
+            A dense matrix read from file.
+        """
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in read (``r``) mode
+        if isinstance(filename, (str,Path)):
+            check_file_exists(filename)
+            h5file = h5py.File(filename, "r")
+
+        # elif we have an ``h5py.File``, make sure mode is in at least ``r`` mode, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_readable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # FIXME: errors if groupname == "" or "/"
+            # if the group does not exist in the file, close and raise error
+            check_h5py_File_has_group(h5file, groupname)
+
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        ######## check that we have all required fields ########
+
+        # all required arguments
+        required_fields = ["mat"]
+
+        # for each required field, check if the field exists in the HDF5 file.
+        for field in required_fields:
+            check_h5py_File_has_group(h5file, groupname + field)
+        
+        ########################################################
+        ### read data from HDF5 file and (optionally) close ####
+        
+        # output dictionary
+        data = {
+            "mat"               : None,
+            "vrnt_chrgrp"       : None,
+            "vrnt_phypos"       : None,
+            "vrnt_name"         : None,
+            "vrnt_genpos"       : None,
+            "vrnt_xoprob"       : None,
+            "vrnt_hapgrp"       : None,
+            "vrnt_hapalt"       : None,
+            "vrnt_hapref"       : None,
+            "vrnt_mask"         : None,
+            # metadata
+            "vrnt_chrgrp_name"  : None,
+            "vrnt_chrgrp_stix"  : None,
+            "vrnt_chrgrp_spix"  : None,
+            "vrnt_chrgrp_len"   : None,
+        }
+
+        ##################################
+        ### read mandatory data fields ###
+
+        # read mat array (ndarray dtype = any)
+        data["mat"] = h5py_File_read_ndarray(h5file, groupname + "mat")
+        
+        #################################
+        ### read optional data fields ###
+
+        # read vrnt_chrgrp array (ndarray dtype = any)
+        if groupname + "vrnt_chrgrp" in h5file:
+            data["vrnt_chrgrp"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_chrgrp")
+
+        # read vrnt_phypos array (ndarray dtype = any)
+        if groupname + "vrnt_phypos" in h5file:
+            data["vrnt_phypos"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_phypos")
+
+        # read vrnt_name array (ndarray dtype = unicode / object)
+        if groupname + "vrnt_name" in h5file:
+            data["vrnt_name"] = h5py_File_read_ndarray_utf8(h5file, groupname + "vrnt_name")
+
+        # read vrnt_genpos array (ndarray dtype = any)
+        if groupname + "vrnt_genpos" in h5file:
+            data["vrnt_genpos"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_genpos")
+
+        # read vrnt_xoprob array (ndarray dtype = any)
+        if groupname + "vrnt_xoprob" in h5file:
+            data["vrnt_xoprob"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_xoprob")
+
+        # read vrnt_hapgrp array (ndarray dtype = any)
+        if groupname + "vrnt_hapgrp" in h5file:
+            data["vrnt_hapgrp"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_hapgrp")
+
+        # read vrnt_hapalt array (ndarray dtype = unicode / object)
+        if groupname + "vrnt_hapalt" in h5file:
+            data["vrnt_hapalt"] = h5py_File_read_ndarray_utf8(h5file, groupname + "vrnt_hapalt")
+
+        # read vrnt_hapref array (ndarray dtype = unicode / object)
+        if groupname + "vrnt_hapref" in h5file:
+            data["vrnt_hapref"] = h5py_File_read_ndarray_utf8(h5file, groupname + "vrnt_hapref")
+
+        # read vrnt_mask array (ndarray dtype = any)
+        if groupname + "vrnt_mask" in h5file:
+            data["vrnt_mask"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_mask")
+
+        #####################################
+        ### read optional metadata fields ###
+
+        # read vrnt_chrgrp_name array (ndarray dtype = any)
+        if groupname + "vrnt_chrgrp_name" in h5file:
+            data["vrnt_chrgrp_name"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_chrgrp_name")
+
+        # read vrnt_chrgrp_stix array (ndarray dtype = any)
+        if groupname + "vrnt_chrgrp_stix" in h5file:
+            data["vrnt_chrgrp_stix"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_chrgrp_stix")
+
+        # read vrnt_chrgrp_spix array (ndarray dtype = any)
+        if groupname + "vrnt_chrgrp_spix" in h5file:
+            data["vrnt_chrgrp_spix"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_chrgrp_spix")
+
+        # read vrnt_chrgrp_len array (ndarray dtype = any)
+        if groupname + "vrnt_chrgrp_len" in h5file:
+            data["vrnt_chrgrp_len"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_chrgrp_len")
+
+        ######################
+        ### close the file ###
+
+        # close the file, only if the provided fieldname was a string or Path an not an h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
+
+        ########################################################
+        ################### Object creation ####################
+        
+        # create object from read data
+        out = cls(
+            mat         = data["mat"],
+            vrnt_chrgrp = data["vrnt_chrgrp"],
+            vrnt_phypos = data["vrnt_phypos"],
+            vrnt_name   = data["vrnt_name"],
+            vrnt_genpos = data["vrnt_genpos"],
+            vrnt_xoprob = data["vrnt_xoprob"],
+            vrnt_hapgrp = data["vrnt_hapgrp"],
+            vrnt_hapalt = data["vrnt_hapalt"],
+            vrnt_hapref = data["vrnt_hapref"],
+            vrnt_mask   = data["vrnt_mask"], 
+        )
+
+        # copy metadata
+        out.vrnt_chrgrp_name = data["vrnt_chrgrp_name"]
+        out.vrnt_chrgrp_stix = data["vrnt_chrgrp_stix"]
+        out.vrnt_chrgrp_spix = data["vrnt_chrgrp_spix"]
+        out.vrnt_chrgrp_len  = data["vrnt_chrgrp_len"]
+
+        return out
+
 
 
 ################################## Utilities ###################################
 def check_is_DenseVariantMatrix(v: object, vname: str) -> None:
     """
     Check if object is of type DenseVariantMatrix. Otherwise raise TypeError.
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/GroupableMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/GroupableMatrix.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,18 +4,22 @@
 """
 
 __all__ = [
     "GroupableMatrix",
     "check_is_GroupableMatrix",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.core.mat.SortableMatrix import SortableMatrix
 
-class GroupableMatrix(SortableMatrix,metaclass=ABCMeta):
+class GroupableMatrix(
+        SortableMatrix,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for groupable matrix wrapper objects.
 
     The purpose of this abstract class is to provide base functionality for:
         1) Matrix in-place matrix axis grouping routines.
     """
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/Matrix.py` & `pybrops-1.0.3/pybrops/core/mat/Matrix.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,18 +3,19 @@
 """
 
 __all__ = [
     "Matrix",
     "check_is_Matrix",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 import numpy
-from typing import Iterator, Union
-
+from typing import Iterator
+from typing import Union
 from typing import Sequence
 from numpy.typing import ArrayLike
 
 from pybrops.core.io.HDF5InputOutput import HDF5InputOutput
 
 class Matrix(
         HDF5InputOutput,
@@ -1049,17 +1050,14 @@
             occur in-place: a new Matrix is allocated and filled.
         """
         raise NotImplementedError("method is abstract")
 
     ############################################################################
     ############################## Static Methods ##############################
     ############################################################################
-    # TODO: there are discrepancies between this as a static method and other
-    #       related methods such as concat_taxa being class methods. Consider
-    #       converting this method to a class method as well.
     @classmethod
     @abstractmethod
     def concat(
             cls,
             mats: Sequence, 
             axis: int, 
             **kwargs: dict
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/MutableMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/MutableMatrix.py`

 * *Files 3% similar despite different names*

```diff
@@ -3,21 +3,26 @@
 """
 
 __all__ = [
     "MutableMatrix",
     "check_is_MutableMatrix",
 ]
 
-from abc import ABCMeta, abstractmethod
-from typing import Sequence, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from typing import Sequence
+from typing import Union
 
 import numpy
 from pybrops.core.mat.Matrix import Matrix
 
-class MutableMatrix(Matrix,metaclass=ABCMeta):
+class MutableMatrix(
+        Matrix,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for mutable matrix wrapper objects.
 
     The purpose of this abstract class is to provide base functionality for:
         1) Matrix in-place matrix shape changing routines.
 
     The shape of a MutableMatrix is mutable.
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/PhasedMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/PhasedMatrix.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,22 +3,27 @@
 """
 
 __all__ = [
     "PhasedMatrix",
     "check_is_PhasedMatrix",
 ]
 
-from abc import ABCMeta, abstractmethod
-from typing import Sequence, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from typing import Sequence
+from typing import Union
 import numpy
 from numpy.typing import ArrayLike
 from pybrops.core.mat.Matrix import Matrix
 from pybrops.core.mat.MutableMatrix import MutableMatrix
 
-class PhasedMatrix(MutableMatrix,metaclass=ABCMeta):
+class PhasedMatrix(
+        MutableMatrix,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for phased matrix wrapper objects.
 
     A phased matrix is defined as a matrix with a third dimension. This
     interface mostly pertains to phased genotype matrices.
 
     The purpose of this abstract class is to provide base functionality for:
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/PhasedTaxaVariantMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/PhasedTaxaVariantMatrix.py`

 * *Files 7% similar despite different names*

```diff
@@ -8,15 +8,19 @@
     "check_is_PhasedTaxaVariantMatrix",
 ]
 
 from abc import ABCMeta
 from pybrops.core.mat.TaxaVariantMatrix import TaxaVariantMatrix
 from pybrops.core.mat.PhasedMatrix import PhasedMatrix
 
-class PhasedTaxaVariantMatrix(TaxaVariantMatrix,PhasedMatrix,metaclass=ABCMeta):
+class PhasedTaxaVariantMatrix(
+        TaxaVariantMatrix,
+        PhasedMatrix,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for matrix wrapper objects with phase, variant, and taxa
     metadata.
 
     The purpose of this abstract class is to merge the following interfaces:
         1) TaxaVariantMatrix
         2) PhasedMatrix
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/PrunableMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/PrunableMatrix.py`

 * *Files 10% similar despite different names*

```diff
@@ -4,20 +4,24 @@
 """
 
 __all__ = [
     "PrunableMatrix",
     "check_is_PrunableMatrix",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 import numpy
 from pybrops.core.mat.Matrix import Matrix
 
 # TODO: is this class even necessary?
-class PrunableMatrix(Matrix,metaclass=ABCMeta):
+class PrunableMatrix(
+        Matrix,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for prunable matrix wrapper objects.
 
     The purpose of this abstract class is to provide base functionality for:
         1) Matrix column and row pruning
         2) Provide backwards compatibility for previous software iterations.
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/SortableMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/SortableMatrix.py`

 * *Files 6% similar despite different names*

```diff
@@ -4,21 +4,26 @@
 """
 
 __all__ = [
     "SortableMatrix",
     "check_is_SortableMatrix",
 ]
 
-from abc import ABCMeta, abstractmethod
-from typing import Sequence, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from typing import Sequence
+from typing import Union
 
 import numpy
 from pybrops.core.mat.MutableMatrix import MutableMatrix
 
-class SortableMatrix(MutableMatrix,metaclass=ABCMeta):
+class SortableMatrix(
+        MutableMatrix,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for sortable matrix wrapper objects.
 
     The purpose of this abstract class is to provide base functionality for:
         1) Matrix in-place matrix sorting routines.
     """
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/SquareMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/SquareMatrix.py`

 * *Files 5% similar despite different names*

```diff
@@ -4,18 +4,22 @@
 """
 
 __all__ = [
     "SquareMatrix",
     "check_is_SquareMatrix",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.core.mat.Matrix import Matrix
 
-class SquareMatrix(Matrix,metaclass=ABCMeta):
+class SquareMatrix(
+        Matrix,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for square matrices. A "square matrix" is defined as a
     matrix that has the same axis metadata associated with two or more axes.
     For example::
 
         This is a square matrix since metadata applies to axes 0 and 1:
                taxa
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/SquareTaxaMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/SquareTaxaMatrix.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,15 +4,16 @@
 """
 
 __all__ = [
     "SquareTaxaMatrix",
     "check_is_SquareTaxaMatrix",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.core.mat.SquareMatrix import SquareMatrix
 from pybrops.core.mat.TaxaMatrix import TaxaMatrix
 
 class SquareTaxaMatrix(
         SquareMatrix,
         TaxaMatrix,
         metaclass = ABCMeta,
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/SquareTaxaSquareTraitMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/SquareTaxaSquareTraitMatrix.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/core/mat/SquareTaxaTraitMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/SquareTaxaTraitMatrix.py`

 * *Files 1% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 from pybrops.core.mat.SquareTaxaMatrix import SquareTaxaMatrix
 from pybrops.core.mat.TraitMatrix import TraitMatrix
 
 
 class SquareTaxaTraitMatrix(
         SquareTaxaMatrix,
         TraitMatrix,
-        metaclass=ABCMeta,
+        metaclass = ABCMeta,
     ):
     """
     An abstract class for matrix wrapper object with taxa axes which are square
     and a trait axis which is not square.
 
     The purpose of this abstract class is to merge the following interfaces:
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/SquareTraitMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/SquareTraitMatrix.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,15 +4,16 @@
 """
 
 __all__ = [
     "SquareTraitMatrix",
     "check_is_SquareTraitMatrix",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.core.mat.SquareMatrix import SquareMatrix
 from pybrops.core.mat.TraitMatrix import TraitMatrix
 
 class SquareTraitMatrix(
         SquareMatrix,
         TraitMatrix,
         metaclass = ABCMeta,
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/TaxaMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/TaxaMatrix.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,23 +4,28 @@
 """
 
 __all__ = [
     "TaxaMatrix",
     "check_is_TaxaMatrix",
 ]
 
-from abc import ABCMeta, abstractmethod
-from typing import Sequence, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from typing import Sequence
+from typing import Union
 
 import numpy
 from numpy.typing import ArrayLike
 from pybrops.core.mat.GroupableMatrix import GroupableMatrix
 from pybrops.core.mat.Matrix import Matrix
 
-class TaxaMatrix(GroupableMatrix,metaclass=ABCMeta):
+class TaxaMatrix(
+        GroupableMatrix,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for matrix wrapper objects with taxa metadata.
 
     The purpose of this abstract class is to provide base functionality for:
         1) Matrix taxa metadata.
         2) Matrix taxa routines.
     """
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/TaxaTraitMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/TaxaTraitMatrix.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,15 +8,19 @@
     "check_is_TaxaTraitMatrix",
 ]
 
 from abc import ABCMeta
 from pybrops.core.mat.TaxaMatrix import TaxaMatrix
 from pybrops.core.mat.TraitMatrix import TraitMatrix
 
-class TaxaTraitMatrix(TaxaMatrix,TraitMatrix,metaclass=ABCMeta):
+class TaxaTraitMatrix(
+        TaxaMatrix,
+        TraitMatrix,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for matrix wrapper objects with taxa and trait metadata.
 
     The purpose of this abstract class is to merge the following interfaces:
         1) TaxaMatrix
         2) TraitMatrix
     """
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/TaxaVariantMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/TaxaVariantMatrix.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,15 +8,19 @@
     "check_is_TaxaVariantMatrix",
 ]
 
 from abc import ABCMeta
 from pybrops.core.mat.TaxaMatrix import TaxaMatrix
 from pybrops.core.mat.VariantMatrix import VariantMatrix
 
-class TaxaVariantMatrix(TaxaMatrix,VariantMatrix,metaclass=ABCMeta):
+class TaxaVariantMatrix(
+        TaxaMatrix,
+        VariantMatrix,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for matrix wrapper objects with taxa and variant metadata.
 
     The purpose of this abstract class is to merge the following interfaces:
         1) TaxaMatrix
         2) VariantMatrix
     """
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/TraitMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/TraitMatrix.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,23 +4,28 @@
 """
 
 __all__ = [
     "TraitMatrix",
     "check_is_TraitMatrix",
 ]
 
-from abc import ABCMeta, abstractmethod
-from typing import Sequence, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from typing import Sequence
+from typing import Union
 
 import numpy
 from numpy.typing import ArrayLike
 from pybrops.core.mat.Matrix import Matrix
 from pybrops.core.mat.SortableMatrix import SortableMatrix
 
-class TraitMatrix(SortableMatrix,metaclass=ABCMeta):
+class TraitMatrix(
+        SortableMatrix,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for matrix wrapper objects with trait metadata.
 
     The purpose of this abstract class is to provide base functionality for:
         1) trait metadata manipulation routines.
         2) trait manipulation routines.
     """
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/VariantMatrix.py` & `pybrops-1.0.3/pybrops/core/mat/VariantMatrix.py`

 * *Files 0% similar despite different names*

```diff
@@ -4,23 +4,28 @@
 """
 
 __all__ = [
     "VariantMatrix",
     "check_is_VariantMatrix",
 ]
 
-from abc import ABCMeta, abstractmethod
-from typing import Sequence, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from typing import Sequence
+from typing import Union
 
 import numpy
 from numpy.typing import ArrayLike
 from pybrops.core.mat.GroupableMatrix import GroupableMatrix
 from pybrops.core.mat.Matrix import Matrix
 
-class VariantMatrix(GroupableMatrix,metaclass=ABCMeta):
+class VariantMatrix(
+        GroupableMatrix,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for matrix wrapper objects with variant metadata.
 
     The purpose of this abstract class is to provide base functionality for:
         1) variant metadata manipulation routines.
         2) variant manipulation routines.
     """
```

### Comparing `pybrops-1.0.2/pybrops/core/mat/__init__.py` & `pybrops-1.0.3/pybrops/core/mat/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,14 +3,15 @@
 """
 
 __all__ = [
     "util",
     "Matrix",
     "PrunableMatrix",
     "SquareMatrix",
+    "ScaledMatrix",
     "MutableMatrix",
     "PhasedMatrix",
     "SortableMatrix",
     "TraitMatrix",
     "GroupableMatrix",
     "TaxaMatrix",
     "VariantMatrix",
@@ -31,21 +32,19 @@
     "DenseTaxaTraitMatrix",
     "DenseTaxaVariantMatrix",
     "DensePhasedTaxaVariantMatrix",
 ]
 
 # order dependent!
 
-# Utilities
-from pybrops.core.mat import util
-
 # level 0 interface
 from pybrops.core.mat import Matrix           # order 0
 from pybrops.core.mat import PrunableMatrix   # order 1
 from pybrops.core.mat import SquareMatrix     # order 1
+from pybrops.core.mat import ScaledMatrix     # order 1
 
 # level 1 interface
 from pybrops.core.mat import MutableMatrix    # order 0
 from pybrops.core.mat import PhasedMatrix     # order 1
 
 # level 2 interface
 from pybrops.core.mat import SortableMatrix   # order 0
```

### Comparing `pybrops-1.0.2/pybrops/core/random/prng.py` & `pybrops-1.0.3/pybrops/core/random/prng.py`

 * *Files 0% similar despite different names*

```diff
@@ -53,15 +53,16 @@
     "zipf",
     # "sample",
     # "ranf",
     "seed",
     "spawn",
 ]
 
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 import numpy
 import random as py_random
 from numpy.random import PCG64
 from numpy.random import Generator
 
 # get the numpy random number generator state
 global_prng = numpy.random.random.__self__
```

### Comparing `pybrops-1.0.2/pybrops/core/random/sampling.py` & `pybrops-1.0.3/pybrops/core/random/sampling.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,20 +6,23 @@
     "stochastic_universal_sampling",
     "tiled_choice",
     "axis_shuffle",
     "outcross_shuffle",
 ]
 
 from numbers import Integral
-from typing import Optional, Tuple, Union
+from typing import Optional
+from typing import Tuple
+from typing import Union
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 
 from pybrops.core.random.prng import global_prng
-from pybrops.core.util.arrayix import sliceaxisix
+from pybrops.core.util.array import sliceaxisix
 
 
 def stochastic_universal_sampling(
         a: numpy.ndarray,
         p: numpy.ndarray, 
         size: Optional[Union[Integral,Tuple[Integral,...]]] = None,
         rng: Optional[Union[Generator,RandomState]] = None
```

### Comparing `pybrops-1.0.2/pybrops/core/util/arrayix.py` & `pybrops-1.0.3/pybrops/core/util/array.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,23 +1,54 @@
 """
-Module with utility functions for generating matrix indices.
+Module with utility functions for array-related functions and generating array 
+indices.
 """
 
 __all__ = [
+    "get_axis",
     "sqarrayix", 
     "triuix", 
     "triuix",
     "xmapix",
     "sliceaxisix",
 ]
 
+from typing import Generator, Tuple
 import numpy
 
+def get_axis(
+        axis: int, 
+        ndim: int
+    ) -> int:
+    """
+    Return an index (unsigned) from a provided axis integer (signed)
+
+    Parameters
+    ----------
+    axis : int
+        Integer representation of the axis. Can be in range (-ndim,ndim).
+        If outside this range, will raise an AxisError.
+    ndim : int
+        Number of dimensions available to index along.
+
+    Returns
+    -------
+    index : int
+        Index representation of the axis. In range [0,ndim).
+    """
+    # handle axis argument
+    if (axis >= ndim) or (axis < -ndim):
+        raise IndexError("axis {0} is out of bounds for array of dimension {1}".format(axis, ndim))
+
+    # modulo the axis number to get the axis (in the case of negative axis)
+    axis %= ndim
+
+    return axis
 
-def sqarrayix(n: int, k: int) -> list:
+def sqarrayix(n: int, k: int) -> Generator:
     """
     Generate lists containing indices for indexing square arrays.
 
     Parameters
     ----------
     n : int
         Length of the array along each dimension.
@@ -38,15 +69,15 @@
         else:
             for i in range(n):
                 l.append(i)
                 yield from recurse(l,n,k)
                 l.pop()
     yield from recurse([],n,k)
 
-def triuix(n: int, k: int) -> list:
+def triuix(n: int, k: int) -> Generator:
     """
     Generate lists containing indices for indexing upper triangle arrays
     including elements along the diagonal.
 
     Parameters
     ----------
     n : int
@@ -69,15 +100,15 @@
         else:
             for i in range(st,n):
                 l.append(i)
                 yield from recurse(l,n,k)
                 l.pop()
     yield from recurse([],n,k)
 
-def triudix(n: int, k: int) -> list:
+def triudix(n: int, k: int) -> Generator:
     """
     Generate lists containing indices for indexing upper triangle arrays
     excluding elements along the diagonal.
 
     Parameters
     ----------
     n : int
@@ -100,15 +131,15 @@
         else:
             for i in range(st,n):
                 l.append(i)
                 yield from recurse(l,n,k)
                 l.pop()
     yield from recurse([],n,k)
 
-def xmapix(ntaxa: int, nparent: int, unique_parents: bool) -> list:
+def xmapix(ntaxa: int, nparent: int, unique_parents: bool) -> Generator:
     """
     Generate lists containing indices for cross maps.
 
     Parameters
     ----------
     ntaxa : int
         Number of parental candidates.
@@ -123,15 +154,15 @@
         A list of length ``nparent`` containing parental indices.
     """
     if unique_parents:
         yield from triudix(ntaxa,nparent)
     else:
         yield from triuix(ntaxa,nparent)
 
-def sliceaxisix(shape: tuple, axis: tuple) -> tuple:
+def sliceaxisix(shape: tuple, axis: tuple) -> Generator:
     """
     Generate tuples containing indices for iteratively slicing 
     a ``numpy.ndarray`` along a set of axes.
 
     Parameters
     ----------
     shape : tuple
@@ -140,15 +171,15 @@
         The axes along which to iterate.
     
     Yields
     ------
     out : tuple
         A tuple which can be used to slice an array.
     """
-    def recurse(l: list, s: tuple, a: tuple) -> tuple:
+    def recurse(l: list, s: tuple, a: tuple) -> Generator:
         if len(l) == len(s)-1:
             if len(l) in a:
                 for i in range(s[len(l)]):
                     l.append(i)
                     yield tuple(l)
                     l.pop()
             else:
@@ -165,15 +196,15 @@
                 l.append(slice(None))
                 yield from recurse(l, s, a)
                 l.pop()
     yield from recurse([],shape,axis)
 
 def flattenix(
         arr: numpy.ndarray
-    ) -> tuple[numpy.ndarray,tuple[numpy.ndarray,...]]:
+    ) -> Tuple[numpy.ndarray,Tuple[numpy.ndarray,...]]:
     """
     Flatten an array and return a tuple of axis indices corresponding to their 
     position along that axis.
 
     Parameters
     ----------
     arr : numpy.ndarray
```

### Comparing `pybrops-1.0.2/pybrops/core/util/haplo.py` & `pybrops-1.0.3/pybrops/core/util/haplo.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/core/util/pareto.py` & `pybrops-1.0.3/pybrops/core/util/pareto.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/core/util/subroutines.py` & `pybrops-1.0.3/pybrops/core/util/subroutines.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,23 +1,24 @@
 """
 Module containing miscellaneous utility subroutines.
 """
 
+from typing import Generator
 import numpy
 import math
 
 __all__ = [
     "srange",
     "matrix_is_sorted",
     "slice_to_range",
     "slice_to_list",
     "human2bytes",
 ]
 
-def srange(start: int, stop: int, step: int) -> int:
+def srange(start: int, stop: int, step: int) -> Generator:
     """
     Stop range generator. Similar to a normal ``range`` generator object, but
     also yields the stop index as its final output.
 
     Parameters
     ----------
     start : int
@@ -25,16 +26,16 @@
     stop : int
         Stopping index.
     step : int
         Step to advance.
 
     Yields
     ------
-    out : int
-        The next index.
+    out : Generator
+        A Generator for indices.
     """
     yield from range(start, stop, step)
     yield stop
 
 def matrix_is_sorted(mat: numpy.ndarray) -> bool:
     """
     Determine if a matrix is sorted in ascending order.
```

### Comparing `pybrops-1.0.2/pybrops/model/gmod/AdditiveDominanceEpistaticLinearGenomicModel.py` & `pybrops-1.0.3/pybrops/model/gmod/AdditiveDominanceEpistaticLinearGenomicModel.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,21 @@
 """
 Module defining interfaces and error checking routines for genomic prediction
 models that incorporate genomic additive, dominance, and epistatic effects.
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from numbers import Integral
 from pybrops.model.gmod.AdditiveDominanceLinearGenomicModel import AdditiveDominanceLinearGenomicModel
 
-class AdditiveDominanceEpistaticLinearGenomicModel(AdditiveDominanceLinearGenomicModel,metaclass=ABCMeta):
+class AdditiveDominanceEpistaticLinearGenomicModel(
+        AdditiveDominanceLinearGenomicModel,
+        metaclass = ABCMeta,
+    ):
     """
     The AdditiveDominanceEpistaticLinearGenomicModel class represents an interface for a
     Multivariate Multiple Linear Regression model.
 
     A Multivariate Multiple Linear Regression model is defined as:
 
     .. math::
```

### Comparing `pybrops-1.0.2/pybrops/model/gmod/AdditiveDominanceLinearGenomicModel.py` & `pybrops-1.0.3/pybrops/model/gmod/AdditiveDominanceLinearGenomicModel.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,17 +1,21 @@
 """
 Module defining interfaces and error checking routines for genomic prediction
 models that incorporate genomic additive and dominance effects.
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from numbers import Integral
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 
-class AdditiveDominanceLinearGenomicModel(AdditiveLinearGenomicModel,metaclass=ABCMeta):
+class AdditiveDominanceLinearGenomicModel(
+        AdditiveLinearGenomicModel,
+        metaclass = ABCMeta,
+    ):
     """
     The AdditiveDominanceLinearGenomicModel class represents an interface for a
     Multivariate Multiple Linear Regression model.
 
     A Multivariate Multiple Linear Regression model is defined as:
 
     .. math::
```

### Comparing `pybrops-1.0.2/pybrops/model/gmod/AdditiveLinearGenomicModel.py` & `pybrops-1.0.3/pybrops/model/gmod/AdditiveLinearGenomicModel.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,17 +1,21 @@
 """
 Module defining interfaces and error checking routines for genomic prediction
 models that incorporate genomic additive effects.
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from numbers import Integral
 from pybrops.model.gmod.LinearGenomicModel import LinearGenomicModel
 
-class AdditiveLinearGenomicModel(LinearGenomicModel,metaclass=ABCMeta):
+class AdditiveLinearGenomicModel(
+        LinearGenomicModel,
+        metaclass = ABCMeta,
+    ):
     """
     The AdditiveLinearGenomicModel class represents an interface for a
     Multivariate Multiple Linear Regression model.
 
     A Multivariate Multiple Linear Regression model is defined as:
 
     .. math::
```

### Comparing `pybrops-1.0.2/pybrops/model/gmod/CoancestryLinearGenomicModel.py` & `pybrops-1.0.3/pybrops/model/gmod/CoancestryLinearGenomicModel.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,20 @@
 """
 Module defining interfaces and error checking routines for genomic prediction
 models that incorporate genomic coancestry effects.
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.model.gmod.LinearGenomicModel import LinearGenomicModel
 
-class CoancestryLinearGenomicModel(LinearGenomicModel,metaclass=ABCMeta):
+class CoancestryLinearGenomicModel(
+        LinearGenomicModel,
+        metaclass = ABCMeta,
+    ):
     """
     The CoancestryLinearGenomicModel class represents an interface for a
     Multivariate Multiple Linear Regression model.
 
     A Multivariate Multiple Linear Regression model is defined as:
 
     .. math::
```

### Comparing `pybrops-1.0.2/pybrops/model/gmod/DenseAdditiveDominanceLinearGenomicModel.py` & `pybrops-1.0.3/pybrops/model/gmod/DenseAdditiveDominanceLinearGenomicModel.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,34 +1,49 @@
 """
 Module implementign classes and error checking routines for genomic
 prediciton models that incorporate additive and dominance effects.
 """
 
 import copy
+from pathlib import Path
 import h5py
 from numbers import Integral
-from typing import Dict, Optional, Sequence, Union
+from typing import Dict
+from typing import Optional
+from typing import Sequence
+from typing import Union
 import numpy
 import pandas
+
 from pybrops.core.error.error_io_python import check_file_exists
-from pybrops.core.error.error_type_numpy import check_is_ndarray, check_ndarray_dtype_is_float64, check_ndarray_dtype_is_object
+from pybrops.core.error.error_type_numpy import check_is_ndarray
+from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_float64
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
-from pybrops.core.error.error_type_python import check_is_dict, check_is_str, check_is_str_or_Sequence
+from pybrops.core.error.error_type_python import check_is_dict
+from pybrops.core.error.error_type_python import check_is_str
+from pybrops.core.error.error_type_python import check_is_str_or_Sequence
 from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
-from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_eq, check_ndarray_ndim
-from pybrops.core.error.error_value_python import check_dict_has_keys, check_len, check_str_value
-from pybrops.core.util.h5py import save_dict_to_hdf5
-
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_readable
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_writable
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
+from pybrops.core.error.error_value_python import check_dict_has_keys
+from pybrops.core.error.error_value_python import check_len
+from pybrops.core.error.error_value_python import check_str_value
+from pybrops.core.util.h5py import h5py_File_read_dict
+from pybrops.core.util.h5py import h5py_File_read_ndarray
+from pybrops.core.util.h5py import h5py_File_read_ndarray_utf8
+from pybrops.core.util.h5py import h5py_File_read_utf8
+from pybrops.core.util.h5py import h5py_File_write_dict
 from pybrops.model.gmod.AdditiveDominanceLinearGenomicModel import AdditiveDominanceLinearGenomicModel
 from pybrops.model.gmod.DenseAdditiveLinearGenomicModel import DenseAdditiveLinearGenomicModel
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.bvmat.DenseGenomicEstimatedBreedingValueMatrix import DenseGenomicEstimatedBreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
-
 class DenseAdditiveDominanceLinearGenomicModel(
         DenseAdditiveLinearGenomicModel,
         AdditiveDominanceLinearGenomicModel,
     ):
     """
     The DenseAdditiveDominanceLinearGenomicModel class represents a Multivariate Multiple
     Linear Regression model.
@@ -977,50 +992,98 @@
                 header = header,
                 index = index,
                 **kwargs
             )
 
     def to_hdf5(
             self, 
-            filename: str, 
-            groupname: Optional[str] = None
+            filename: Union[str,Path,h5py.File], 
+            groupname: Optional[str] = None,
+            overwrite: bool = True,
         ) -> None:
         """
-        Write GenomicModel to an HDF5 file.
+        Write ``DenseAdditiveDominanceLinearGenomicModel`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name to which to write.
-        groupname : str or None
-            HDF5 group name under which GenomicModel data is stored.
-            If ``None``, GenomicModel is written to the base HDF5 group.
-        """
-        h5file = h5py.File(filename, "a")                       # open HDF5 in write mode
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### populate HDF5 file
-        data_dict = {                                           # data dictionary
-            "beta":        self.beta,
-            "u_misc":      self.u_misc,
-            "u_a":         self.u_a,
-            "u_d":         self.u_d,
-            "trait":       self.trait,
-            "model_name":  self.model_name,
-            "hyperparams": self.hyperparams
+        filename : str, Path, h5py.File
+            If ``str``, an HDF5 file name to which to write. File is closed after writing.
+            If ``h5py.File``, an opened HDF5 file to which to write. File is not closed after writing.
+
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseAdditiveDominanceLinearGenomicModel`` data is stored.
+            If ``None``, ``DenseAdditiveDominanceLinearGenomicModel`` is written to the base HDF5 group.
+
+        overwrite : bool
+            Whether to overwrite data fields if they are present in the HDF5 file.
+        """
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in append (``r+``) mode
+        if isinstance(filename, (str,Path)):
+            h5file = h5py.File(filename, "a")
+
+        # elif we have an h5py.File, make sure mode is writable, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_writable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        #### write data to HDF5 file and (optionally) close ####
+
+        # data dictionary
+        data = {
+            "beta"          : self.beta,
+            "u_misc"        : self.u_misc,
+            "u_a"           : self.u_a,
+            "u_d"           : self.u_d,
+            "trait"         : self.trait,
+            "model_name"    : self.model_name,
+            "hyperparams"   : self.hyperparams,
         }
-        save_dict_to_hdf5(h5file, groupname, data_dict)         # write data
-        ######################################################### write conclusion
-        h5file.close()                                          # close the file
+
+        # save data
+        h5py_File_write_dict(h5file, groupname, data, overwrite)
+
+        # close the file, only if the provided filename was a string or Path and not a h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
 
     ############################## Class Methods ###############################
 
     ################## Model I/O methods ###################
     @classmethod
     def from_pandas_dict(
             cls,
@@ -1143,19 +1206,19 @@
             header: int = 0,
             trait_cols: Optional[Union[str,Sequence]] = "infer",
             model_name: Optional[str] = None, 
             hyperparams: Optional[dict] = None, 
             **kwargs: dict
         ) -> 'DenseAdditiveDominanceLinearGenomicModel':
         """
-        Read a DenseAdditiveDominanceLinearGenomicModel from a set of CSV files specified by values in a ``dict``.
+        Read a ``DenseAdditiveDominanceLinearGenomicModel`` from a set of CSV files specified by values in a ``dict``.
 
         Parameters
         ----------
-        filename : str
+        filenames : str
             Dictionary of CSV file names from which to read.
             
             Must have the following fields::
 
             - ``"beta"`` is a ``str`` containing fixed effects.
             - ``"u_misc"`` is ``None`` or a ``str`` of CSV file path containing 
               miscellaneous random effects.
@@ -1189,15 +1252,15 @@
 
         kwargs : dict
             Additional keyword arguments to use for dictating importing from a CSV.
 
         Returns
         -------
         out : DenseAdditiveDominanceLinearGenomicModel
-            A DenseAdditiveDominanceLinearGenomicModel read from a set of CSV files.
+            A ``DenseAdditiveDominanceLinearGenomicModel`` read from a set of CSV files.
         """
         # type checks
         check_is_dict(filenames, "filenames")
         check_dict_has_keys(filenames, "filenames", "beta", "u_misc", "u_a", "u_d")
         check_is_str(filenames["beta"], 'filenames["beta"]')
         if filenames["u_misc"] is not None:
             check_is_str(filenames["u_misc"], 'filenames["u_misc"]')
@@ -1229,85 +1292,155 @@
         )
 
         return out
 
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseAdditiveDominanceLinearGenomicModel':
         """
-        Read DenseAdditiveDominanceLinearGenomicModel from an HDF5 file.
+        Read ``DenseAdditiveDominanceLinearGenomicModel`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseAdditiveDominanceLinearGenomicModel data is stored.
-            If ``None``, DenseAdditiveDominanceLinearGenomicModel is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseAdditiveDominanceLinearGenomicModel`` data is stored.
+            If ``None``, ``DenseAdditiveDominanceLinearGenomicModel`` is read from base HDF5 group.
 
         Returns
         -------
         out : DenseAdditiveDominanceLinearGenomicModel
             A genomic model read from file.
         """
-        check_file_exists(filename)                             # check file exists
-        h5file = h5py.File(filename, "r")                       # open HDF5 in read only
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            check_h5py_File_has_group(h5file, filename, groupname)    # check that group exists
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### check that we have all required fields
-        required_fields = ["beta", "u_misc", "u_a"]             # all required arguments
-        for field in required_fields:                           # for each required field
-            fieldname = groupname + field                       # concatenate base groupname and field
-            check_h5py_File_has_group(h5file, filename, fieldname)    # check that group exists
-        ######################################################### read data
-        data_dict = {                                           # output dictionary
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in append (``r``) mode
+        if isinstance(filename, (str,Path)):
+            check_file_exists(filename)
+            h5file = h5py.File(filename, "r")
+
+        # elif we have an h5py.File, make sure mode is in at least ``r`` mode, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_readable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ######## check that we have all required fields ########
+
+        # all required arguments
+        required_fields = ["beta", "u_misc", "u_a", "u_d"]
+
+        # for each required field, check if the field exists in the HDF5 file.
+        for field in required_fields:
+            check_h5py_File_has_group(h5file, groupname + field)
+        
+        ########################################################
+        ### read data from HDF5 file and (optionally) close ####
+
+        # output dictionary
+        data = {
             "beta"        : None,
             "u_misc"      : None,
             "u_a"         : None,
             "u_d"         : None,
             "trait"       : None,
             "model_name"  : None,
-            "hyperparams" : None
+            "hyperparams" : None,
         }
-        data_dict["beta"] = h5file[groupname + "beta"][()]      # read beta array
-        data_dict["u_misc"] = h5file[groupname + "u_misc"][()]  # read u_misc array
-        data_dict["u_a"] = h5file[groupname + "u_a"][()]        # read u_a array
-        data_dict["u_d"] = h5file[groupname + "u_d"][()]        # read u_d array
-        fieldname = groupname + "trait"                         # construct "groupname/trait"
-        if fieldname in h5file:                                 # if "groupname/trait" in hdf5
-            data_dict["trait"] = h5file[fieldname][()]          # read trait array
-            data_dict["trait"] = numpy.array(                   # convert trait string from byte to utf-8
-                [s.decode("utf-8") for s in data_dict["trait"]],
-                dtype = object
-            )
-        fieldname = groupname + "model_name"                    # construct "groupname/model_name"
-        if fieldname in h5file:                                 # if "groupname/model_name" in hdf5
-            data_dict["model_name"] = h5file[fieldname][()]     # read string (as bytes); convert to utf-8
-            data_dict["model_name"] = data_dict["model_name"].decode("utf-8")
-        fieldname = groupname + "hyperparams"                        # construct "groupname/hyperparams"
-        if fieldname in h5file:                                 # if "groupname/hyperparams" in hdf5
-            data_dict["hyperparams"] = {}                            # create empty dictionary
-            view = h5file[fieldname]                            # get view of dataset
-            for key in view.keys():                             # for each field
-                data_dict["hyperparams"][key] = view[key][()]        # extract data
-        ######################################################### read conclusion
-        h5file.close()                                          # close file
-        ######################################################### create object
-        dalgmod = cls(**data_dict)                              # create object from read data
-        return dalgmod
+
+        ##################################
+        ### read mandatory data fields ###
+
+        # read beta array (ndarray dtype = any)
+        data["beta"] = h5py_File_read_ndarray(h5file, groupname + "beta")
+
+        # read u_misc array (ndarray dtype = any)
+        data["u_misc"] = h5py_File_read_ndarray(h5file, groupname + "u_misc")
+
+        # read u_a array (ndarray dtype = any)
+        data["u_a"] = h5py_File_read_ndarray(h5file, groupname + "u_a")
+
+        # read u_d array (ndarray dtype = any)
+        data["u_d"] = h5py_File_read_ndarray(h5file, groupname + "u_d")
+
+        #################################
+        ### read optional data fields ###
+
+        # read trat array (ndarray dtype = unicode / object)
+        if groupname + "trait" in h5file:
+            data["trait"] = h5py_File_read_ndarray_utf8(h5file, groupname + "trait")
+
+        # read model_name data (dtype = str)
+        if groupname + "model_name" in h5file:
+            data["model_name"] = h5py_File_read_utf8(h5file, groupname + "model_name")
+
+        # read hyperparams data (dtype = dict)
+        if groupname + "hyperparams" in h5file:
+            data["hyperparams"] = h5py_File_read_dict(h5file, groupname + "hyperparams")
+
+        ######################
+        ### close the file ###
+
+        # close the file, only if the provided fieldname was a string or Path an not an h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
+
+        ########################################################
+        ################### Object creation ####################
+
+        # create object from read data
+        out = cls(
+            beta        = data["beta"],
+            u_misc      = data["u_misc"],
+            u_a         = data["u_a"],
+            u_d         = data["u_d"],
+            trait       = data["trait"],
+            model_name  = data["model_name"],
+            hyperparams = data["hyperparams"],
+        )
+
+        return out
 
 
 
 ################################## Utilities ###################################
 def check_is_DenseAdditiveDominanceLinearGenomicModel(v: object, vname: str) -> None:
     """
     Check if object is of type DenseAdditiveDominanceLinearGenomicModel. Otherwise raise TypeError.
```

### Comparing `pybrops-1.0.2/pybrops/model/gmod/DenseAdditiveLinearGenomicModel.py` & `pybrops-1.0.3/pybrops/model/gmod/DenseAdditiveLinearGenomicModel.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,38 +1,48 @@
 """
 Module implementing classes and error checking routines for genomic prediction
 models that incorporate genomic additive effects.
 """
 
 import copy
 from numbers import Integral
-from typing import Dict, Optional, Sequence, Union
+from pathlib import Path
+from typing import Dict
+from typing import Optional
+from typing import Sequence
+from typing import Union
 import h5py
 import numpy
 import pandas
 from pybrops.core.error.error_io_python import check_file_exists
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_float64
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
 from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_readable
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_writable
 from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_eq
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.core.error.error_type_python import check_is_str_or_Sequence
 from pybrops.core.error.error_type_python import check_is_str
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_object
-from pybrops.core.error.error_attr_python import error_readonly
 from pybrops.core.error.error_value_python import check_dict_has_keys
 from pybrops.core.error.error_value_python import check_len
 from pybrops.core.error.error_value_python import check_str_value
 from pybrops.core.io.CSVDictInputOutput import CSVDictInputOutput
 from pybrops.core.io.PandasDictInputOutput import PandasDictInputOutput
-from pybrops.core.util.h5py import save_dict_to_hdf5
+from pybrops.core.util.h5py import h5py_File_read_dict
+from pybrops.core.util.h5py import h5py_File_read_ndarray
+from pybrops.core.util.h5py import h5py_File_read_ndarray_utf8
+from pybrops.core.util.h5py import h5py_File_read_utf8
+from pybrops.core.util.h5py import h5py_File_write_dict
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
+from pybrops.popgen.gmat.GenotypeMatrix import check_is_GenotypeMatrix
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.bvmat.DenseGenomicEstimatedBreedingValueMatrix import DenseGenomicEstimatedBreedingValueMatrix
 
 class DenseAdditiveLinearGenomicModel(
         AdditiveLinearGenomicModel,
         PandasDictInputOutput,
         CSVDictInputOutput,
@@ -475,33 +485,62 @@
             X: numpy.ndarray, 
             Z: numpy.ndarray, 
             **kwargs: dict
         ) -> numpy.ndarray:
         """
         Predict breeding values.
 
-        Remark: The difference between 'predict_numpy' and 'gebv_numpy' is that
-        'predict_numpy' can incorporate other factors (e.g., fixed effects) to
+        Remark: The difference between ``predict_numpy`` and ``gebv_numpy`` is that
+        ``predict_numpy`` can incorporate other factors (e.g., fixed effects) to
         provide prediction estimates.
 
         Parameters
         ----------
         X : numpy.ndarray
-            A matrix of covariates.
+            A matrix of covariates of shape ``(n,q)``.
+
+            Where:
+
+            - ``n`` is the number of taxa (observations).
+            - ``q`` is the number of fixed effects.
+        
         Z : numpy.ndarray
-            A matrix of genotype values.
+            A matrix of random predictors and/or genotype values of shape ``(n,p)``.
+
+            Where:
+
+            - ``n`` is the number of taxa (observations).
+            - ``p`` is the number of random predictors.
+
         kwargs : dict
             Additional keyword arguments.
 
         Returns
         -------
         Y_hat : numpy.ndarray
-            A matrix of estimated breeding values.
+            A matrix of estimated breeding values of shape ``(n,t)``.
+
+            Where:
+
+            - ``n`` is the number of taxa (observations).
+            - ``t`` is the number of traits.
         """
+        # type checks
+        check_is_ndarray(X, "X")
+        check_ndarray_ndim(X, "X", 2)
+        check_ndarray_axis_len_eq(X, "X", 1, self.nexplan_beta)
+        check_is_ndarray(Z, "Z")
+        check_ndarray_ndim(Z, "Z", 2)
+        check_ndarray_axis_len_eq(Z, "Z", 0, X.shape[0])
+        check_ndarray_axis_len_eq(Z, "Z", 1, self.nexplan_u)
+
         # Y = Xβ + Zu
+        # (n,q) @ (q,t) -> (n,t)
+        # (n,p) @ (p,t) -> (n,t)
+        # (n,t) + (n,t) -> (n,t)
         Y_hat = (X @ self.beta) + (Z @ self.u)
 
         return Y_hat
 
     def predict(
             self, 
             cvobj: numpy.ndarray, 
@@ -570,32 +609,61 @@
         ) -> numpy.ndarray:
         """
         Return the coefficient of determination R**2 of the prediction.
 
         Parameters
         ----------
         Y : numpy.ndarray
-            A matrix of phenotypes.
+            A matrix of phenotypes of shape ``(n,t)``.
+
+            Where:
+
+            - ``n`` is the number of taxa (observations).
+            - ``t`` is the number of traits.
+    
         X : numpy.ndarray
-            A matrix of covariates.
+            A matrix of covariates of shape ``(n,q)``.
+
+            Where:
+
+            - ``n`` is the number of taxa (observations).
+            - ``q`` is the number of fixed effects.
+        
         Z : numpy.ndarray
-            A matrix of genotypes.
+            A matrix of random predictors and/or genotype values of shape ``(n,p)``.
+
+            Where:
+
+            - ``n`` is the number of taxa (observations).
+            - ``p`` is the number of random predictors.
+
         kwargs : dict
             Additional keyword arguments.
 
         Returns
         -------
         Rsq : numpy.ndarray
             A coefficient of determination array of shape ``(t,)``.
 
             Where:
 
             - ``t`` is the number of traits.
         """
-        # TODO: array shape checks
+        # type checks
+        check_is_ndarray(Y, "Y")
+        check_ndarray_ndim(Y, "Y", 2)
+        check_ndarray_axis_len_eq(Y, "Y", 1, self.ntrait)
+        check_is_ndarray(X, "X")
+        check_ndarray_ndim(X, "X", 2)
+        check_ndarray_axis_len_eq(X, "X", 0, Y.shape[0])
+        check_ndarray_axis_len_eq(X, "X", 1, self.nexplan_beta)
+        check_is_ndarray(Z, "Z")
+        check_ndarray_ndim(Z, "Z", 2)
+        check_ndarray_axis_len_eq(Z, "Z", 0, Y.shape[0])
+        check_ndarray_axis_len_eq(Z, "Z", 1, self.nexplan_u)
 
         # calculate predictions
         # (n,q) @ (q,t) -> (n,t)
         # (n,p) @ (p,t) -> (n,t)
         # (n,t) + (n,t) -> (n,t)
         Y_hat = (X @ self.beta) + (Z @ self.u)
 
@@ -1414,15 +1482,19 @@
     def facount(
             self, 
             gmat: GenotypeMatrix, 
             dtype: Optional[numpy.dtype] = None, 
             **kwargs: dict
         ) -> numpy.ndarray:
         """
-        Favorable allele count across all taxa.
+        Calculate the favorable allele count across all taxa.
+
+        An allele is considered favorable if its effect is greater than zero.
+        Alleles with zero effect are not considered favorable; they are 
+        considered neutral.
 
         Parameters
         ----------
         gmat : GenotypeMatrix
             Genotype matrix for which to count favorable alleles.
         dtype : numpy.dtype, None
             Datatype of the returned array. If ``None``, use the native type.
@@ -1430,15 +1502,23 @@
             Additional keyword arguments.
             
         Returns
         -------
         out : numpy.ndarray
             A numpy.ndarray of shape ``(p,t)`` containing allele counts of the 
             favorable allele.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
         """
+        # check types
+        check_is_GenotypeMatrix(gmat, "gmat")
+
         # process dtype
         if dtype is None:
             dtype = int
         dtype = numpy.dtype(dtype)
 
         # construct mask for beneficial alleles
         # (p,t)
@@ -1449,44 +1529,61 @@
         acount = gmat.acount(dtype = dtype)[:,None]
 
         # get maximum number of favorable alleles
         # scalar
         maxfav = dtype.type(gmat.ploidy * gmat.ntaxa)
 
         # calculate favorable allele counts
+        # if u_a > 0.0, then acount
+        # if u_a <= 0.0, then maxfav - acount
         # (p,t)
         out = numpy.where(mask, acount, maxfav - acount)
 
+        # for alleles with zero effect, set favorable allele count to 0
+        # (p,t)
+        out[self.u_a == 0.0] = 0
+
         return out
 
     def fafreq(
             self, 
             gmat: GenotypeMatrix, 
             dtype: Optional[numpy.dtype] = None, 
             **kwargs: dict
         ) -> numpy.ndarray:
         """
-        Favorable allele frequency across all taxa.
+        Calculate the favorable allele frequency across all taxa.
+        
+        An allele is considered favorable if its effect is greater than zero.
+        Alleles with zero effect are not considered favorable; they are 
+        considered neutral.
         
         Parameters
         ----------
         gmat : GenotypeMatrix
             Genotype matrix for which to determine favorable allele frequencies.
         dtype : numpy.dtype, None
-            Datatype of the returned array. If ``None``, use the native float 
-            type.
+            Datatype of the returned array. If ``None``, use the native type.
         kwargs : dict
             Additional keyword arguments.
         
         Returns
         -------
         out : numpy.ndarray
             A numpy.ndarray of shape ``(p,t)`` containing allele frequencies of 
             the favorable allele.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
         """
+        # check types
+        check_is_GenotypeMatrix(gmat, "gmat")
+
         # process dtype
         if dtype is None:
             dtype = float
         dtype = numpy.dtype(dtype)
 
         # get favorable allele frequencies
         out = (1.0 / (gmat.ploidy * gmat.ntaxa)) * self.facount(gmat)
@@ -1500,30 +1597,44 @@
     def faavail(
             self, 
             gmat: GenotypeMatrix, 
             dtype: Optional[numpy.dtype] = None, 
             **kwargs: dict
         ) -> numpy.ndarray:
         """
-        Determine which favorable alleles are available in an input set of taxa.
-        
+        Determine whether a favorable allele is polymorphic or fixed across all 
+        taxa.
+
+        An allele is considered favorable if its effect is greater than zero.
+        Alleles with zero effect are not considered favorable; they are 
+        considered neutral.
+
         Parameters
         ----------
         gmat : GenotypeMatrix
             Genotype matrix for which to determine favorable allele frequencies.
         dtype : numpy.dtype, None
-            Datatype of the returned array. If ``None``, use the native bool type.
+            Datatype of the returned array. If ``None``, use the native type.
         kwargs : dict
             Additional keyword arguments.
         
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(p,t)`` containing whether a favorable allele is available.
+            A numpy.ndarray of shape ``(p,t)`` containing whether a favorable 
+            allele is available.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
         """
+        # check types
+        check_is_GenotypeMatrix(gmat, "gmat")
+
         # process dtype
         if dtype is None:
             dtype = bool
         dtype = numpy.dtype(dtype)
 
         # get favorable allele counts
         facount = self.facount(gmat)
@@ -1541,29 +1652,42 @@
             self, 
             gmat: GenotypeMatrix, 
             dtype: Optional[numpy.dtype] = None, 
             **kwargs: dict
         ) -> numpy.ndarray:
         """
         Determine whether a favorable allele is fixed across all taxa.
-        
+
+        An allele is considered favorable if its effect is greater than zero.
+        Alleles with zero effect are not considered favorable; they are 
+        considered neutral.
+
         Parameters
         ----------
         gmat : GenotypeMatrix
             Genotype matrix for which to determine favorable allele frequencies.
         dtype : numpy.dtype, None
             Datatype of the returned array. If ``None``, use the native type.
         kwargs : dict
             Additional keyword arguments.
         
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(p,t)`` containing whether a favorable allele is fixed.
+            A numpy.ndarray of shape ``(p,t)`` containing whether a favorable 
+            allele is fixed.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
         """
+        # check types
+        check_is_GenotypeMatrix(gmat, "gmat")
+
         # process dtype
         if dtype is None:
             dtype = bool
         dtype = numpy.dtype(dtype)
 
         # get favorable allele counts
         facount = self.facount(gmat)
@@ -1576,83 +1700,285 @@
 
         # convert datatype if needed
         if out.dtype != dtype:
             out = out.astype(dtype)
         
         return out
 
+    def fapoly(
+            self, 
+            gmat: GenotypeMatrix, 
+            dtype: Optional[numpy.dtype] = None, 
+            **kwargs: dict
+        ) -> numpy.ndarray:
+        """
+        Determine whether a favorable allele is polymorphic across all taxa.
+
+        An allele is considered favorable if its effect is greater than zero.
+        Alleles with zero effect are not considered favorable; they are 
+        considered neutral.
+
+        Parameters
+        ----------
+        gmat : GenotypeMatrix
+            Genotype matrix for which to determine favorable allele frequencies.
+        dtype : numpy.dtype, None
+            Datatype of the returned array. If ``None``, use the native type.
+        kwargs : dict
+            Additional keyword arguments.
+        
+        Returns
+        -------
+        out : numpy.ndarray
+            A numpy.ndarray of shape ``(p,t)`` containing whether a favorable 
+            allele is polymorphic.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
+        """
+        # check types
+        check_is_GenotypeMatrix(gmat, "gmat")
+
+        # process dtype
+        if dtype is None:
+            dtype = bool
+        dtype = numpy.dtype(dtype)
+
+        # get favorable allele counts
+        # (p,t)
+        facount = self.facount(gmat)
+
+        # get maximum number of favorable alleles
+        maxfav = gmat.ploidy * gmat.ntaxa
+
+        # get boolean mask of favorable alleles that are fixed
+        out = (facount > 0) & (facount < maxfav)
+
+        # convert datatype if needed
+        if out.dtype != dtype:
+            out = out.astype(dtype)
+        
+        return out
+
+    def nafixed(
+            self, 
+            gmat: GenotypeMatrix, 
+            dtype: Optional[numpy.ndarray] = None, 
+            **kwargs: dict
+        ) -> numpy.ndarray:
+        """
+        Determine whether a neutral allele is fixed across all taxa.
+
+        An allele is considered neutral if its effect is equal to zero.
+
+        Parameters
+        ----------
+        gmat : GenotypeMatrix
+            Genotype matrix for which to determine neutral allele frequencies.
+        dtype : numpy.dtype, None
+            Datatype of the returned array. If ``None``, use the native type.
+        kwargs : dict
+            Additional keyword arguments.
+        
+        Returns
+        -------
+        out : numpy.ndarray
+            A numpy.ndarray of shape ``(p,t)`` containing whether a neutral 
+            allele is fixed.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
+        """
+        # check types
+        check_is_GenotypeMatrix(gmat, "gmat")
+
+        # process dtype
+        if dtype is None:
+            dtype = bool
+        dtype = numpy.dtype(dtype)
+
+        # get allele counts
+        # (p,1)
+        acount = gmat.acount()[:,None]
+
+        # get maximum number of alleles
+        # scalar
+        maxfav = gmat.ploidy * gmat.ntaxa
+
+        # get boolean mask of alleles that are fixed and neutral
+        # (p,1) & (p,t) -> (p,t)
+        out = ((acount == 0) | (acount == maxfav)) & (self.u_a == 0.0)
+
+        # convert datatype if needed
+        if out.dtype != dtype:
+            out = out.astype(dtype)
+        
+        return out
+
+    def napoly(
+            self,
+            gmat: GenotypeMatrix,
+            dtype: Optional[numpy.dtype] = None,
+            **kwargs: dict
+        ) -> numpy.ndarray:
+        """
+        Determine whether a neutral allele is polymorphic across all taxa.
+
+        An allele is considered neutral if its effect is equal to zero.
+
+        Parameters
+        ----------
+        gmat : GenotypeMatrix
+            Genotype matrix for which to determine neutral allele frequencies.
+        dtype : numpy.dtype, None
+            Datatype of the returned array. If ``None``, use the native type.
+        kwargs : dict
+            Additional keyword arguments.
+        
+        Returns
+        -------
+        out : numpy.ndarray
+            A numpy.ndarray of shape ``(p,t)`` containing whether a neutral 
+            allele is polymorphic.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
+        """
+        # check types
+        check_is_GenotypeMatrix(gmat, "gmat")
+
+        # process dtype
+        if dtype is None:
+            dtype = bool
+        dtype = numpy.dtype(dtype)
+
+        # get allele counts
+        # (p,1)
+        acount = gmat.acount()[:,None]
+
+        # get maximum number of alleles
+        maxfav = gmat.ploidy * gmat.ntaxa
+
+        # get boolean mask of alleles that are polymorphic and neutral
+        # (p,1) & (p,t) -> (p,t)
+        out = ((acount > 0) & (acount < maxfav)) & (self.u_a == 0.0)
+
+        # convert datatype if needed
+        if out.dtype != dtype:
+            out = out.astype(dtype)
+        
+        return out
+
     def dacount(
             self, 
             gmat: GenotypeMatrix, 
             dtype: Optional[numpy.dtype] = None, 
             **kwargs: dict
         ) -> numpy.ndarray:
         """
-        Deleterious allele count across all taxa.
+        Calculate the deleterious allele count across all taxa.
+
+        An allele is considered deleterious if its effect is less than zero.
+        Alleles with zero effect are not considered deleterious; they are 
+        considered neutral.
 
         Parameters
         ----------
         gmat : GenotypeMatrix
             Genotype matrix for which to count deleterious alleles.
         dtype : numpy.dtype, None
             Datatype of the returned array. If ``None``, use the native type.
         kwargs : dict
             Additional keyword arguments.
             
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(p,)`` containing allele counts of the deleterious allele.
+            A numpy.ndarray of shape ``(p,t)`` containing allele counts of the 
+            deleterious allele.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
         """
+        # check types
+        check_is_GenotypeMatrix(gmat, "gmat")
+
         # convert data type
         if dtype is None:
             dtype = int
         dtype = numpy.dtype(dtype)
 
         # construct mask for deleterious alleles
         # (p,t)
         mask = (self.u_a < 0.0)
 
         # get allele counts for the genotype matrix
         # (p,) -> (p,1)
         acount = gmat.acount(dtype = dtype)[:,None]
 
-        # get maximum number of favorable alleles
+        # get maximum number of deleterious alleles
         # scalar
         maxfav = dtype.type(gmat.ploidy * gmat.ntaxa)
 
-        # calculate favorable allele counts
+        # calculate deleterious allele counts
+        # if u_a < 0.0, then acount
+        # if u_a >= 0.0, then maxfav - acount
         # (p,t)
         out = numpy.where(mask, acount, maxfav - acount)
 
+        # for alleles with zero effect, set deleterious allele count to 0
+        # (p,t)
+        out[self.u_a == 0.0] = 0
+
         return out
 
     def dafreq(
             self, 
             gmat: GenotypeMatrix, 
             dtype: Optional[numpy.dtype] = None, 
             **kwargs: dict
         ) -> numpy.ndarray:
         """
-        Deleterious allele frequency across all taxa.
-        
+        Calculate the deleterious allele frequency across all taxa.
+
+        An allele is considered deleterious if its effect is less than zero.
+        Alleles with zero effect are not considered deleterious; they are 
+        considered neutral.
+
         Parameters
         ----------
         gmat : GenotypeMatrix
             Genotype matrix for which to determine deleterious allele frequencies.
         dtype : numpy.dtype, None
             Datatype of the returned array. If ``None``, use the native type.
         kwargs : dict
             Additional keyword arguments.
         
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(p,)`` containing allele frequencies of the deleterious allele.
+            A ``numpy.ndarray`` of shape ``(p,t)`` containing allele frequencies 
+            of the deleterious allele.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
         """
+        # check types
+        check_is_GenotypeMatrix(gmat, "gmat")
+
         # process dtype
         if dtype is None:
             dtype = float
         dtype = numpy.dtype(dtype)
 
         # get deleterious allele frequencies
         out = (1.0 / (gmat.ploidy * gmat.ntaxa)) * self.dacount(gmat)
@@ -1667,29 +1993,44 @@
             self, 
             gmat: GenotypeMatrix, 
             dtype: Optional[numpy.dtype] = None, 
             **kwargs: dict
         ) -> numpy.ndarray:
         """
         Determine whether a deleterious allele is available in the present taxa.
-        
+
+        An allele is considered deleterious if its effect is less than zero.
+        Alleles with zero effect are not considered deleterious; they are 
+        considered neutral.
+
         Parameters
         ----------
         gmat : GenotypeMatrix
-            Genotype matrix for which to determine deleterious allele frequencies.
+            Genotype matrix for which to determine deleterious allele 
+            frequencies.
         dtype : numpy.dtype, None
-            Datatype of the returned array. If ``None``, use the native boolean type.
+            Datatype of the returned array. If ``None``, use the native boolean 
+            type.
         kwargs : dict
             Additional keyword arguments.
         
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(p,t)`` containing whether a deleterious allele is available.
+            A ``numpy.ndarray`` of shape ``(p,t)`` containing whether a deleterious 
+            allele is available.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
         """
+        # check types
+        check_is_GenotypeMatrix(gmat, "gmat")
+
         # process dtype
         if dtype is None:
             dtype = bool
         dtype = numpy.dtype(dtype)
 
         # get deleterious allele counts
         facount = self.dacount(gmat)
@@ -1707,29 +2048,42 @@
             self, 
             gmat: GenotypeMatrix, 
             dtype: Optional[numpy.dtype] = None, 
             **kwargs: dict
         ) -> numpy.ndarray:
         """
         Determine whether a deleterious allele is fixed across all taxa.
-        
+
+        An allele is considered deleterious if its effect is less than zero.
+        Alleles with zero effect are not considered deleterious; they are 
+        considered neutral.
+
         Parameters
         ----------
         gmat : GenotypeMatrix
             Genotype matrix for which to determine deleterious allele frequencies.
         dtype : numpy.dtype, None
             Datatype of the returned array. If ``None``, use the native type.
         kwargs : dict
             Additional keyword arguments.
         
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(p,)`` containing whether a deleterious allele is fixed.
+            A ``numpy.ndarray`` of shape ``(p,t)`` containing whether a deleterious 
+            allele is fixed.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
         """
+        # check types
+        check_is_GenotypeMatrix(gmat, "gmat")
+
         # process dtype
         if dtype is None:
             dtype = bool
         dtype = numpy.dtype(dtype)
 
         # get deleterious allele counts
         dacount = self.dacount(gmat)
@@ -1742,14 +2096,70 @@
 
         # convert datatype if needed
         if out.dtype != dtype:
             out = out.astype(dtype)
         
         return out
 
+    def dapoly(
+            self, 
+            gmat: GenotypeMatrix, 
+            dtype: Optional[numpy.dtype] = None, 
+            **kwargs: dict
+        ) -> numpy.ndarray:
+        """
+        Determine whether a deleterious allele is polymorphic across all taxa.
+
+        An allele is considered deleterious if its effect is less than zero.
+        Alleles with zero effect are not considered deleterious; they are 
+        considered neutral.
+
+        Parameters
+        ----------
+        gmat : GenotypeMatrix
+            Genotype matrix for which to determine deleterious allele frequencies.
+        dtype : numpy.dtype, None
+            Datatype of the returned array. If ``None``, use the native type.
+        kwargs : dict
+            Additional keyword arguments.
+        
+        Returns
+        -------
+        out : numpy.ndarray
+            A ``numpy.ndarray`` of shape ``(p,t)`` containing whether a deleterious 
+            allele is polymorphic.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
+        """
+        # check types
+        check_is_GenotypeMatrix(gmat, "gmat")
+
+        # process dtype
+        if dtype is None:
+            dtype = bool
+        dtype = numpy.dtype(dtype)
+
+        # get deleterious allele counts
+        dacount = self.dacount(gmat)
+
+        # get maximum number of deleterious alleles
+        maxdel = gmat.ploidy * gmat.ntaxa
+
+        # get boolean mask of deleterious alleles that are polymorphic
+        out = (dacount > 0) & (dacount < maxdel)
+
+        # convert datatype if needed
+        if out.dtype != dtype:
+            out = out.astype(dtype)
+        
+        return out
+
     ################## Model I/O methods ###################
     def to_pandas_dict(
             self,
             trait_cols: Optional[Union[str,Sequence]] = "trait",
             **kwargs: dict
         ) -> Dict[str,pandas.DataFrame]:
         """
@@ -1870,49 +2280,97 @@
                 header = header,
                 index = index,
                 **kwargs
             )
 
     def to_hdf5(
             self, 
-            filename: str, 
-            groupname: Optional[str] = None
+            filename: Union[str,Path,h5py.File], 
+            groupname: Optional[str] = None,
+            overwrite: bool = True,
         ) -> None:
         """
-        Write GenomicModel to an HDF5 file.
+        Write ``DenseAdditiveLinearGenomicModel`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name to which to write.
-        groupname : str or None
-            HDF5 group name under which GenomicModel data is stored.
-            If ``None``, GenomicModel is written to the base HDF5 group.
-        """
-        h5file = h5py.File(filename, "a")                       # open HDF5 in write mode
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### populate HDF5 file
-        data_dict = {                                           # data dictionary
-            "beta": self.beta,
-            "u_misc": self.u_misc,
-            "u_a": self.u_a,
-            "trait": self.trait,
-            "model_name": self.model_name,
-            "hyperparams": self.hyperparams
+        filename : str, Path, h5py.File
+            If ``str``, an HDF5 file name to which to write. File is closed after writing.
+            If ``h5py.File``, an opened HDF5 file to which to write. File is not closed after writing.
+
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseAdditiveLinearGenomicModel`` data is stored.
+            If ``None``, ``DenseAdditiveLinearGenomicModel`` is written to the base HDF5 group.
+
+        overwrite : bool
+            Whether to overwrite data fields if they are present in the HDF5 file.
+        """
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in append (``r+``) mode
+        if isinstance(filename, (str,Path)):
+            h5file = h5py.File(filename, "a")
+
+        # elif we have an h5py.File, make sure mode is writable, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_writable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        #### write data to HDF5 file and (optionally) close ####
+
+        # data dictionary
+        data = {
+            "beta"          : self.beta,
+            "u_misc"        : self.u_misc,
+            "u_a"           : self.u_a,
+            "trait"         : self.trait,
+            "model_name"    : self.model_name,
+            "hyperparams"   : self.hyperparams,
         }
-        save_dict_to_hdf5(h5file, groupname, data_dict)         # write data
-        ######################################################### write conclusion
-        h5file.close()                                          # close the file
+
+        # save data
+        h5py_File_write_dict(h5file, groupname, data, overwrite)
+
+        # close the file, only if the provided filename was a string or Path and not a h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
 
     ############################## Class Methods ###############################
 
     ################## Model I/O methods ###################
     @classmethod
     def from_pandas_dict(
             cls,
@@ -2105,83 +2563,151 @@
         )
 
         return out
 
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseAdditiveLinearGenomicModel':
         """
-        Read GenotypeMatrix from an HDF5 file.
+        Read ``DenseAdditiveLinearGenomicModel`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which GenotypeMatrix data is stored.
-            If ``None``, GenotypeMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseAdditiveLinearGenomicModel`` data is stored.
+            If ``None``, ``DenseAdditiveLinearGenomicModel`` is read from base HDF5 group.
 
         Returns
         -------
-        gmat : GenotypeMatrix
+        gmat : DenseAdditiveLinearGenomicModel
             A genotype matrix read from file.
         """
-        check_file_exists(filename)                             # check file exists
-        h5file = h5py.File(filename, "r")                       # open HDF5 in read only
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            check_h5py_File_has_group(h5file, filename, groupname)    # check that group exists
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### check that we have all required fields
-        required_fields = ["beta", "u_misc", "u_a"]             # all required arguments
-        for field in required_fields:                           # for each required field
-            fieldname = groupname + field                       # concatenate base groupname and field
-            check_h5py_File_has_group(h5file, filename, fieldname)    # check that group exists
-        ######################################################### read data
-        data_dict = {                                           # output dictionary
-            "beta": None,
-            "u_misc" : None,
-            "u_a" : None,
-            "trait": None,
-            "model_name": None,
-            "hyperparams": None
-        }
-        data_dict["beta"] = h5file[groupname + "beta"][()]      # read beta array
-        data_dict["u_misc"] = h5file[groupname + "u_misc"][()]  # read u array
-        data_dict["u_a"] = h5file[groupname + "u_a"][()]        # read u array
-        fieldname = groupname + "trait"                         # construct "groupname/trait"
-        if fieldname in h5file:                                 # if "groupname/trait" in hdf5
-            data_dict["trait"] = h5file[fieldname][()]          # read trait array
-            data_dict["trait"] = numpy.array(                   # convert trait string from byte to utf-8
-                [s.decode("utf-8") for s in data_dict["trait"]],
-                dtype = object
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in append (``r``) mode
+        if isinstance(filename, (str,Path)):
+            check_file_exists(filename)
+            h5file = h5py.File(filename, "r")
+
+        # elif we have an h5py.File, make sure mode is in at least ``r`` mode, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_readable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
             )
-        fieldname = groupname + "model_name"                    # construct "groupname/model_name"
-        if fieldname in h5file:                                 # if "groupname/model_name" in hdf5
-            data_dict["model_name"] = h5file[fieldname][()]     # read string (as bytes); convert to utf-8
-            data_dict["model_name"] = data_dict["model_name"].decode("utf-8")
-        fieldname = groupname + "hyperparams"                        # construct "groupname/hyperparams"
-        if fieldname in h5file:                                 # if "groupname/hyperparams" in hdf5
-            data_dict["hyperparams"] = {}                            # create empty dictionary
-            view = h5file[fieldname]                            # get view of dataset
-            for key in view.keys():                             # for each field
-                data_dict["hyperparams"][key] = view[key][()]        # extract data
-        ######################################################### read conclusion
-        h5file.close()                                          # close file
-        ######################################################### create object
-        dalgmod = cls(**data_dict)                              # create object from read data
-        return dalgmod
+
+        ########################################################
+        ######## check that we have all required fields ########
+
+        # all required arguments
+        required_fields = ["beta", "u_misc", "u_a"]
+
+        # for each required field, check if the field exists in the HDF5 file.
+        for field in required_fields:
+            check_h5py_File_has_group(h5file, groupname + field)
+
+
+        ########################################################
+        ### read data from HDF5 file and (optionally) close ####
+        
+        # output dictionary
+        data = {
+            "beta"          : None,
+            "u_misc"        : None,
+            "u_a"           : None,
+            "trait"         : None,
+            "model_name"    : None,
+            "hyperparams"   : None,
+        }
+
+        ##################################
+        ### read mandatory data fields ###
+
+        # read beta array (ndarray dtype = any)
+        data["beta"] = h5py_File_read_ndarray(h5file, groupname + "beta")
+
+        # read u_misc array (ndarray dtype = any)
+        data["u_misc"] = h5py_File_read_ndarray(h5file, groupname + "u_misc")
+
+        # read u_a array (ndarray dtype = any)
+        data["u_a"] = h5py_File_read_ndarray(h5file, groupname + "u_a")
+
+        #################################
+        ### read optional data fields ###
+
+        # read trat array (ndarray dtype = unicode / object)
+        if groupname + "trait" in h5file:
+            data["trait"] = h5py_File_read_ndarray_utf8(h5file, groupname + "trait")
+
+        # read model_name data (dtype = str)
+        if groupname + "model_name" in h5file:
+            data["model_name"] = h5py_File_read_utf8(h5file, groupname + "model_name")
+
+        # read hyperparams data (dtype = dict)
+        if groupname + "hyperparams" in h5file:
+            data["hyperparams"] = h5py_File_read_dict(h5file, groupname + "hyperparams")
+
+        ######################
+        ### close the file ###
+
+        # close the file, only if the provided fieldname was a string or Path an not an h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
+        
+        ########################################################
+        ################### Object creation ####################
+
+        # create object from read data
+        out = cls(
+            beta        = data["beta"],
+            u_misc      = data["u_misc"],
+            u_a         = data["u_a"],
+            trait       = data["trait"],
+            model_name  = data["model_name"],
+            hyperparams = data["hyperparams"],
+        )
+
+        return out
 
 
 
 ################################## Utilities ###################################
 def check_is_DenseAdditiveLinearGenomicModel(v: object, vname: str) -> None:
     """
     Check if object is of type DenseAdditiveLinearGenomicModel. Otherwise raise TypeError.
```

### Comparing `pybrops-1.0.2/pybrops/model/gmod/DenseLinearGenomicModel.py` & `pybrops-1.0.3/pybrops/model/gmod/DenseLinearGenomicModel.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,34 +1,44 @@
 """
 Module implementing classes and error checking routines for genomic prediction
 models that incorporate linear genomic effects.
 """
 
 import copy
 from numbers import Integral
-from typing import Optional, Union
+from pathlib import Path
+from typing import Optional
+from typing import Union
 import numpy
 import h5py
 import pandas
 from pybrops.core.error.error_io_python import check_file_exists
 from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_python import check_is_str
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_float64
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_object
 from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_readable
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_writable
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.core.error.error_attr_python import error_readonly
-from pybrops.core.util.h5py import save_dict_to_hdf5
+from pybrops.core.util.h5py import h5py_File_read_dict
+from pybrops.core.util.h5py import h5py_File_read_ndarray
+from pybrops.core.util.h5py import h5py_File_read_ndarray_utf8
+from pybrops.core.util.h5py import h5py_File_read_utf8
+from pybrops.core.util.h5py import h5py_File_write_dict
 from pybrops.model.gmod.LinearGenomicModel import LinearGenomicModel
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.bvmat.DenseGenomicEstimatedBreedingValueMatrix import DenseGenomicEstimatedBreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
-class DenseLinearGenomicModel(LinearGenomicModel):
+class DenseLinearGenomicModel(
+        LinearGenomicModel,
+    ):
     """
     The DenseLinearGenomicModel class represents a Multivariate Multiple
     Linear Regression model.
 
     A Multivariate Multiple Linear Regression model is defined as:
 
     .. math::
@@ -1462,122 +1472,234 @@
             out = dtype.type(out)
         
         return out
 
     ################### File I/O methods ###################
     def to_hdf5(
             self, 
-            filename: str, 
-            groupname: Optional[str] = None
+            filename: Union[str,Path,h5py.File], 
+            groupname: Optional[str] = None,
+            overwrite: bool = True,
         ) -> None:
         """
-        Write GenotypeMatrix to an HDF5 file.
+        Write ``DenseLinearGenomicModel`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name to which to write.
-        groupname : str or None
-            HDF5 group name under which GenotypeMatrix data is stored.
-            If ``None``, GenotypeMatrix is written to the base HDF5 group.
-        """
-        h5file = h5py.File(filename, "a")                       # open HDF5 in write mode
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### populate HDF5 file
-        data_dict = {                                           # data dictionary
-            "beta": self.beta,
-            "u": self.u,
-            "trait": self.trait,
-            "model_name": self.model_name,
-            "hyperparams": self.hyperparams
+        filename : str, Path, h5py.File
+            If ``str``, an HDF5 file name to which to write. File is closed after writing.
+            If ``h5py.File``, an opened HDF5 file to which to write. File is not closed after writing.
+
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseLinearGenomicModel`` data is stored.
+            If ``None``, ``DenseLinearGenomicModel`` is written to the base HDF5 group.
+
+        overwrite : bool
+            Whether to overwrite data fields if they are present in the HDF5 file.
+        """
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in append (``r+``) mode
+        if isinstance(filename, (str,Path)):
+            h5file = h5py.File(filename, "a")
+
+        # elif we have an h5py.File, make sure mode is writable, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_writable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        #### write data to HDF5 file and (optionally) close ####
+
+        # data dictionary
+        data = {
+            "beta"          : self.beta,
+            "u"             : self.u,
+            "trait"         : self.trait,
+            "model_name"    : self.model_name,
+            "hyperparams"   : self.hyperparams,
         }
-        save_dict_to_hdf5(h5file, groupname, data_dict)         # write data
-        ######################################################### write conclusion
-        h5file.close()                                          # close the file
+
+        # save data
+        h5py_File_write_dict(h5file, groupname, data, overwrite)
+
+        # close the file, only if the provided filename was a string or Path and not a h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
 
     ############################## Class Methods ###############################
 
     ################### File I/O methods ###################
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
-            groupname: Optional[str] = None
+            filename: Union[str,Path,h5py.File], 
+            groupname: Optional[str] = None,
         ) -> 'DenseLinearGenomicModel':
         """
-        Read GenotypeMatrix from an HDF5 file.
+        Read ``DenseLinearGenomicModel`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which GenotypeMatrix data is stored.
-            If ``None``, GenotypeMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseLinearGenomicModel`` data is stored.
+            If ``None``, ``DenseLinearGenomicModel`` is read from base HDF5 group.
 
         Returns
         -------
-        gmat : GenotypeMatrix
+        gmat : DenseLinearGenomicModel
             A genotype matrix read from file.
         """
-        check_file_exists(filename)                             # check file exists
-        h5file = h5py.File(filename, "r")                       # open HDF5 in read only
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            check_h5py_File_has_group(h5file, filename, groupname)    # check that group exists
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### check that we have all required fields
-        required_fields = ["beta", "u"]                         # all required arguments
-        for field in required_fields:                           # for each required field
-            fieldname = groupname + field                       # concatenate base groupname and field
-            check_h5py_File_has_group(h5file, filename, fieldname)    # check that group exists
-        ######################################################### read data
-        data_dict = {                                           # output dictionary
-            "beta": None,
-            "u" : None,
-            "trait": None,
-            "model_name": None,
-            "hyperparams": None
-        }
-        data_dict["beta"] = h5file[groupname + "beta"][()]      # read beta array
-        data_dict["u"] = h5file[groupname + "u"][()]            # read u array
-        fieldname = groupname + "trait"                         # construct "groupname/trait"
-        if fieldname in h5file:                                 # if "groupname/trait" in hdf5
-            data_dict["trait"] = h5file[fieldname][()]          # read trait array
-            data_dict["trait"] = numpy.array(                   # convert trait string from byte to utf-8
-                [s.decode("utf-8") for s in data_dict["trait"]],
-                dtype = object
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
             )
-        fieldname = groupname + "model_name"                    # construct "groupname/model_name"
-        if fieldname in h5file:                                 # if "groupname/model_name" in hdf5
-            data_dict["model_name"] = h5file[fieldname][()]     # read string (as bytes); convert to utf-8
-            data_dict["model_name"] = data_dict["model_name"].decode("utf-8")
-        fieldname = groupname + "hyperparams"                        # construct "groupname/hyperparams"
-        if fieldname in h5file:                                 # if "groupname/hyperparams" in hdf5
-            data_dict["hyperparams"] = {}                            # create empty dictionary
-            view = h5file[fieldname]                            # get view of dataset
-            for key in view.keys():                             # for each field
-                data_dict["hyperparams"][key] = view[key][()]        # extract data
-        ######################################################### read conclusion
-        h5file.close()                                          # close file
-        ######################################################### create object
-        glgmod = cls(**data_dict)         # create object from read data
-        return glgmod
+
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in append (``r``) mode
+        if isinstance(filename, (str,Path)):
+            check_file_exists(filename)
+            h5file = h5py.File(filename, "r")
+
+        # elif we have an h5py.File, make sure mode is in at least ``r`` mode, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_readable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ######## check that we have all required fields ########
+
+        # all required arguments
+        required_fields = ["beta", "u"]
+
+        # for each required field, check if the field exists in the HDF5 file.
+        for field in required_fields:
+            check_h5py_File_has_group(h5file, groupname + field)
+
+        ########################################################
+        ### read data from HDF5 file and (optionally) close ####
+        
+        # output dictionary
+        data = {
+            "beta"          : None,
+            "u"             : None,
+            "trait"         : None,
+            "model_name"    : None,
+            "hyperparams"   : None,
+        }
+
+        ##################################
+        ### read mandatory data fields ###
+
+        # read beta array (ndarray dtype = any)
+        data["beta"] = h5py_File_read_ndarray(h5file, groupname + "beta")
+
+        # read u array (ndarray dtype = any)
+        data["u"] = h5py_File_read_ndarray(h5file, groupname + "u")
+
+        #################################
+        ### read optional data fields ###
+
+        # read trat array (ndarray dtype = unicode / object)
+        if groupname + "trait" in h5file:
+            data["trait"] = h5py_File_read_ndarray_utf8(h5file, groupname + "trait")
+
+        # read model_name data (dtype = str)
+        if groupname + "model_name" in h5file:
+            data["model_name"] = h5py_File_read_utf8(h5file, groupname + "model_name")
+
+        # read hyperparams data (dtype = dict)
+        if groupname + "hyperparams" in h5file:
+            data["hyperparams"] = h5py_File_read_dict(h5file, groupname + "hyperparams")
+
+        ######################
+        ### close the file ###
+
+        # close the file, only if the provided fieldname was a string or Path an not an h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
+        
+        ########################################################
+        ################### Object creation ####################
+
+        # create object from read data
+        out = cls(
+            beta        = data["beta"],
+            u           = data["u"],
+            trait       = data["trait"],
+            model_name  = data["model_name"],
+            hyperparams = data["hyperparams"],
+        )
+        
+        return out
 
 
 
 ################################## Utilities ###################################
 def check_is_DenseLinearGenomicModel(v: object, vname: str) -> None:
     """
     Check if object is of type DenseLinearGenomicModel. Otherwise raise TypeError.
```

### Comparing `pybrops-1.0.2/pybrops/model/gmod/GenomicModel.py` & `pybrops-1.0.3/pybrops/model/gmod/GenomicModel.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,22 +1,26 @@
 """
 Module defining basal interfaces and error checking routines for genomic models.
 """
 
-from abc import ABCMeta, abstractmethod
-import copy
+from abc import ABCMeta
+from abc import abstractmethod
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 import numpy
 import pandas
 from pybrops.core.io.HDF5InputOutput import HDF5InputOutput
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
-class GenomicModel(HDF5InputOutput,metaclass=ABCMeta):
+class GenomicModel(
+        HDF5InputOutput,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for genomic models.
 
     The purpose for this abstract interface is to provide base functionality for:
         1) Model metadata storage.
         2) Model fitting.
         3) Model prediction.
@@ -768,215 +772,434 @@
     def facount(
             self, 
             gmat: GenotypeMatrix, 
             dtype: Optional[numpy.dtype], 
             **kwargs: dict
         ) -> numpy.ndarray:
         """
-        Favorable allele count across all taxa.
+        Calculate the favorable allele count across all taxa.
+
+        An allele is considered favorable if its effect is greater than zero.
+        Alleles with zero effect are not considered favorable; they are 
+        considered neutral.
 
         Parameters
         ----------
         gmat : GenotypeMatrix
             Genotype matrix for which to count favorable alleles.
         dtype : numpy.dtype, None
             Datatype of the returned array. If ``None``, use the native type.
         kwargs : dict
             Additional keyword arguments.
             
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(p,)`` containing allele counts of the favorable allele.
+            A numpy.ndarray of shape ``(p,t)`` containing allele counts of the 
+            favorable allele.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
         """
         raise NotImplementedError("method is abstract")
 
     @abstractmethod
     def fafreq(
             self, 
             gmat: GenotypeMatrix, 
             dtype: Optional[numpy.ndarray], 
             **kwargs: dict
         ) -> numpy.ndarray:
         """
-        Favorable allele frequency across all taxa.
+        Calculate the favorable allele frequency across all taxa.
+        
+        An allele is considered favorable if its effect is greater than zero.
+        Alleles with zero effect are not considered favorable; they are 
+        considered neutral.
         
         Parameters
         ----------
         gmat : GenotypeMatrix
             Genotype matrix for which to determine favorable allele frequencies.
         dtype : numpy.dtype, None
             Datatype of the returned array. If ``None``, use the native type.
         kwargs : dict
             Additional keyword arguments.
         
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(p,t)`` containing allele frequencies of the favorable allele.
+            A numpy.ndarray of shape ``(p,t)`` containing allele frequencies of 
+            the favorable allele.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
         """
         raise NotImplementedError("method is abstract")
     
     @abstractmethod
     def faavail(
             self, 
             gmat: GenotypeMatrix, 
             dtype: Optional[numpy.dtype] = None, 
             **kwargs: dict
         ) -> numpy.ndarray:
         """
-        Determine whether a favorable allele is available in the present taxa.
-        
+        Determine whether a favorable allele is polymorphic or fixed across all 
+        taxa.
+
+        An allele is considered favorable if its effect is greater than zero.
+        Alleles with zero effect are not considered favorable; they are 
+        considered neutral.
+
         Parameters
         ----------
         gmat : GenotypeMatrix
             Genotype matrix for which to determine favorable allele frequencies.
         dtype : numpy.dtype, None
             Datatype of the returned array. If ``None``, use the native type.
         kwargs : dict
             Additional keyword arguments.
         
         Returns
         -------
         out : numpy.ndarray
             A numpy.ndarray of shape ``(p,t)`` containing whether a favorable 
             allele is available.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
         """
         raise NotImplementedError("method is abstract")
 
     @abstractmethod
     def fafixed(
             self, 
             gmat: GenotypeMatrix, 
             dtype: Optional[numpy.ndarray], 
             **kwargs: dict
         ) -> numpy.ndarray:
         """
         Determine whether a favorable allele is fixed across all taxa.
+
+        An allele is considered favorable if its effect is greater than zero.
+        Alleles with zero effect are not considered favorable; they are 
+        considered neutral.
+
+        Parameters
+        ----------
+        gmat : GenotypeMatrix
+            Genotype matrix for which to determine favorable allele frequencies.
+        dtype : numpy.dtype, None
+            Datatype of the returned array. If ``None``, use the native type.
+        kwargs : dict
+            Additional keyword arguments.
         
+        Returns
+        -------
+        out : numpy.ndarray
+            A numpy.ndarray of shape ``(p,t)`` containing whether a favorable 
+            allele is fixed.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
+        """
+        raise NotImplementedError("method is abstract")
+
+    @abstractmethod
+    def fapoly(
+            self,
+            gmat: GenotypeMatrix,
+            dtype: Optional[numpy.dtype],
+            **kwargs: dict
+        ) -> numpy.ndarray:
+        """
+        Determine whether a favorable allele is polymorphic across all taxa.
+
+        An allele is considered favorable if its effect is greater than zero.
+        Alleles with zero effect are not considered favorable; they are 
+        considered neutral.
+
         Parameters
         ----------
         gmat : GenotypeMatrix
             Genotype matrix for which to determine favorable allele frequencies.
         dtype : numpy.dtype, None
             Datatype of the returned array. If ``None``, use the native type.
         kwargs : dict
             Additional keyword arguments.
         
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(p,)`` containing whether a favorable allele is fixed.
+            A numpy.ndarray of shape ``(p,t)`` containing whether a favorable 
+            allele is polymorphic.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
+        """
+        raise NotImplementedError("method is abstract")
+
+    @abstractmethod
+    def nafixed(
+            self, 
+            gmat: GenotypeMatrix, 
+            dtype: Optional[numpy.ndarray], 
+            **kwargs: dict
+        ) -> numpy.ndarray:
+        """
+        Determine whether a neutral allele is fixed across all taxa.
+
+        An allele is considered neutral if its effect is equal to zero.
+
+        Parameters
+        ----------
+        gmat : GenotypeMatrix
+            Genotype matrix for which to determine neutral allele frequencies.
+        dtype : numpy.dtype, None
+            Datatype of the returned array. If ``None``, use the native type.
+        kwargs : dict
+            Additional keyword arguments.
+        
+        Returns
+        -------
+        out : numpy.ndarray
+            A numpy.ndarray of shape ``(p,t)`` containing whether a neutral 
+            allele is fixed.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
+        """
+        raise NotImplementedError("method is abstract")
+
+    @abstractmethod
+    def napoly(
+            self,
+            gmat: GenotypeMatrix,
+            dtype: Optional[numpy.dtype],
+            **kwargs: dict
+        ) -> numpy.ndarray:
+        """
+        Determine whether a neutral allele is polymorphic across all taxa.
+
+        An allele is considered neutral if its effect is equal to zero.
+
+        Parameters
+        ----------
+        gmat : GenotypeMatrix
+            Genotype matrix for which to determine neutral allele frequencies.
+        dtype : numpy.dtype, None
+            Datatype of the returned array. If ``None``, use the native type.
+        kwargs : dict
+            Additional keyword arguments.
+        
+        Returns
+        -------
+        out : numpy.ndarray
+            A numpy.ndarray of shape ``(p,t)`` containing whether a neutral 
+            allele is polymorphic.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
         """
         raise NotImplementedError("method is abstract")
 
     @abstractmethod
     def dacount(
             self, 
             gmat: GenotypeMatrix, 
             dtype: Optional[numpy.ndarray], 
             **kwargs: dict
         ) -> numpy.ndarray:
         """
-        Deleterious allele count across all taxa.
+        Calculate the deleterious allele count across all taxa.
+
+        An allele is considered deleterious if its effect is less than zero.
+        Alleles with zero effect are not considered deleterious; they are 
+        considered neutral.
 
         Parameters
         ----------
         gmat : GenotypeMatrix
             Genotype matrix for which to count deleterious alleles.
         dtype : numpy.dtype, None
             Datatype of the returned array. If ``None``, use the native type.
         kwargs : dict
             Additional keyword arguments.
             
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(p,)`` containing allele counts of the deleterious allele.
+            A numpy.ndarray of shape ``(p,t)`` containing allele counts of the 
+            deleterious allele.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
         """
         raise NotImplementedError("method is abstract")
 
     @abstractmethod
     def dafreq(
             self, 
             gmat: GenotypeMatrix, 
             dtype: Optional[numpy.ndarray], 
             **kwargs: dict
         ) -> numpy.ndarray:
         """
-        Deleterious allele frequency across all taxa.
-        
+        Calculate the deleterious allele frequency across all taxa.
+
+        An allele is considered deleterious if its effect is less than zero.
+        Alleles with zero effect are not considered deleterious; they are 
+        considered neutral.
+
         Parameters
         ----------
         gmat : GenotypeMatrix
             Genotype matrix for which to determine deleterious allele frequencies.
         dtype : numpy.dtype, None
             Datatype of the returned array. If ``None``, use the native type.
         kwargs : dict
             Additional keyword arguments.
         
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(p,)`` containing allele frequencies of the deleterious allele.
+            A ``numpy.ndarray`` of shape ``(p,t)`` containing allele frequencies 
+            of the deleterious allele.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
         """
         raise NotImplementedError("method is abstract")
     
     @abstractmethod
     def daavail(
             self, 
             gmat: GenotypeMatrix, 
             dtype: Optional[numpy.dtype] = None, 
             **kwargs: dict
         ) -> numpy.ndarray:
         """
         Determine whether a deleterious allele is available in the present taxa.
-        
+
+        An allele is considered deleterious if its effect is less than zero.
+        Alleles with zero effect are not considered deleterious; they are 
+        considered neutral.
+
         Parameters
         ----------
         gmat : GenotypeMatrix
             Genotype matrix for which to determine deleterious allele 
             frequencies.
         dtype : numpy.dtype, None
             Datatype of the returned array. If ``None``, use the native boolean 
             type.
         kwargs : dict
             Additional keyword arguments.
         
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(p,t)`` containing whether a deleterious 
+            A ``numpy.ndarray`` of shape ``(p,t)`` containing whether a deleterious 
             allele is available.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
         """
         raise NotImplementedError("method is abstract")
 
     @abstractmethod
     def dafixed(
             self, 
             gmat: GenotypeMatrix, 
             dtype: Optional[numpy.ndarray], 
             **kwargs: dict
         ) -> numpy.ndarray:
         """
         Determine whether a deleterious allele is fixed across all taxa.
+
+        An allele is considered deleterious if its effect is less than zero.
+        Alleles with zero effect are not considered deleterious; they are 
+        considered neutral.
+
+        Parameters
+        ----------
+        gmat : GenotypeMatrix
+            Genotype matrix for which to determine deleterious allele frequencies.
+        dtype : numpy.dtype, None
+            Datatype of the returned array. If ``None``, use the native type.
+        kwargs : dict
+            Additional keyword arguments.
         
+        Returns
+        -------
+        out : numpy.ndarray
+            A ``numpy.ndarray`` of shape ``(p,t)`` containing whether a deleterious 
+            allele is fixed.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
+        """
+        raise NotImplementedError("method is abstract")
+
+    @abstractmethod
+    def dapoly(
+            self,
+            gmat: GenotypeMatrix,
+            dtype: Optional[numpy.dtype],
+            **kwargs: dict
+        ) -> numpy.ndarray:
+        """
+        Determine whether a deleterious allele is polymorphic across all taxa.
+
+        An allele is considered deleterious if its effect is less than zero.
+        Alleles with zero effect are not considered deleterious; they are 
+        considered neutral.
+
         Parameters
         ----------
         gmat : GenotypeMatrix
             Genotype matrix for which to determine deleterious allele frequencies.
         dtype : numpy.dtype, None
             Datatype of the returned array. If ``None``, use the native type.
         kwargs : dict
             Additional keyword arguments.
         
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(p,)`` containing whether a deleterious allele is fixed.
+            A ``numpy.ndarray`` of shape ``(p,t)`` containing whether a deleterious 
+            allele is polymorphic.
+
+            Where:
+
+            - ``p`` is the number of alleles.
+            - ``t`` is the number of traits.
         """
         raise NotImplementedError("method is abstract")
 
 
 
 ################################## Utilities ###################################
 def check_is_GenomicModel(v: object, vname: str) -> None:
```

### Comparing `pybrops-1.0.2/pybrops/model/gmod/LinearGenomicModel.py` & `pybrops-1.0.3/pybrops/model/gmod/LinearGenomicModel.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 """
 Module defining interfaces and error checking routines for genomic models that
 are linear in nature.
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from numbers import Integral
 from pybrops.core.io.CSVDictInputOutput import CSVDictInputOutput
 from pybrops.core.io.PandasDictInputOutput import PandasDictInputOutput
 from pybrops.model.gmod.GenomicModel import GenomicModel
 
 class LinearGenomicModel(
         GenomicModel,
```

### Comparing `pybrops-1.0.2/pybrops/model/gmod/NonlinearGenomicModel.py` & `pybrops-1.0.3/pybrops/model/gmod/NonlinearGenomicModel.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,15 +2,18 @@
 Module defining interfaces and error checking routines for genomic models that
 are non-linear in nature.
 """
 
 from abc import ABCMeta
 from pybrops.model.gmod.GenomicModel import GenomicModel
 
-class NonlinearGenomicModel(GenomicModel,metaclass=ABCMeta):
+class NonlinearGenomicModel(
+        GenomicModel,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for non-linear genomic models.
 
     The purpose for this abstract interface is to provide an interface through
     which non-linear models (e.g. neural networks) may be incorporated into
     PyBrOpS.
     """
```

### Comparing `pybrops-1.0.2/pybrops/model/gmod/__init__.py` & `pybrops-1.0.3/pybrops/model/gmod/__init__.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/model/gmod/rrBLUPModel0.py` & `pybrops-1.0.3/pybrops/model/gmod/rrBLUPModel0.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,23 +1,29 @@
 """
 Module containing RR-BLUP genomic prediction classes for a very simple 
 intercept + marker effects model.
 """
 
 import copy
-from typing import Optional, Tuple, Union
-from numbers import Integral, Real
+from typing import Optional
+from typing import Tuple
+from typing import Union
+from numbers import Integral
+from numbers import Real
 import numpy
 import pandas
 from pybrops.core.error.error_type_numpy import check_is_ndarray
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_Real
-from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_eq, check_ndarray_ndim
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_Real
+from pybrops.core.error.error_value_numpy import check_ndarray_axis_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.core.error.error_value_python import check_is_gteq
 from pybrops.model.gmod.DenseAdditiveLinearGenomicModel import DenseAdditiveLinearGenomicModel
-from scipy.optimize import minimize, Bounds
+from scipy.optimize import minimize
+from scipy.optimize import Bounds
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
 def rrBLUP_ML0_calc_G(Z: numpy.ndarray) -> numpy.ndarray:
     """
     Calculate a genomic relationship matrix from a marker matrix.
 
@@ -77,15 +83,16 @@
         A genomic relationship matrix of shape ``(nobs,nobs)``.
     
     Returns
     -------
     out : tuple
         A tuple containing ``(d,V)``.
         
-        Where::
+        Where:
+
         - ``d`` is a vector of shape ``(nobs,)`` representing the diagonal of the spectral decomposition.
         - ``V`` is a matrix of shape ``(nobs,nobs)`` representing the orthonormal basis of the spectral decomposition.
 
         Entries are sorted from highest eigenvalue to lowest eigenvalue.
     """
     # take the spectral decomposition of the (symmetric) G matrix.
     # (nobs,nobs) -> eigenvalues = (nobs,), eigenvectors = (nobs,nobs)
@@ -114,15 +121,16 @@
         A matrix of shape ``(nobs,nobs)`` representing the orthonormal basis of the spectral decomposition.
     
     Returns
     -------
     out : tuple
         A tuple containing ``(d,V)``.
         
-        Where::
+        Where:
+
         - ``d`` is a vector of shape ``(ncomp,)`` representing the diagonal of the spectral decomposition.
         - ``V`` is a matrix of shape ``(nobs,ncomp)`` representing the orthonormal basis of the spectral decomposition.
     """
     # for the spectral decomposition, construct a mask for eigenvalues greater than approximately zero
     # (nobs,) -> (nobs,) 
     mask = d > tol
     # extract eigenvalues that are greater than approximately zero
@@ -312,14 +320,15 @@
 def rrBLUP_ML0(y: numpy.ndarray, Z: numpy.ndarray, varlb: Real = 1e-5, varub: Real = 1e5, gsatol: Real = 1e-8, gsmaxiter: Integral = 1000):
     """
     Ridge regression BLUP for the simple model::
 
     y = Zu + e
 
     Where::
+    
         - ``y`` are observations.
         - ``Z`` is a design matrix for genetic markers.
         - ``u`` are marker effects which follow the distribution ``MVN(0, varU * I)``.
         - ``e`` are errors which follow the distribution ``MVN(0, varE * I)``.
     
     Uses the EMMA formulation to solve for ``varE`` and ``varU``.
     Uses the Nelder-Mead method to optimize for variance components.
@@ -472,15 +481,17 @@
         "logLik": logLik,
         # optimization solution object
         "soln": soln,
     }
 
     return out
 
-class rrBLUPModel0(DenseAdditiveLinearGenomicModel):
+class rrBLUPModel0(
+        DenseAdditiveLinearGenomicModel,
+    ):
     """
     The rrBLUPModel0 class represents a simple RR-BLUP model with an intercept 
     (fixed) and marker effects (random).
 
     An rrBLUPModel0 is a Multivariate Multiple Linear Regression model defined as:
 
     .. math::
@@ -531,26 +542,28 @@
     If multiple traits are provided, fit independent models for each trait.
 
     For a single trait, the model is::
 
     y = Xb + Zu + e
 
     Where::
+
         - ``y`` are observations.
         - ``X`` is a matrix of ones for the incidence of the slope.
         - ``b`` is the intercept.
         - ``Z`` is a design matrix for genetic markers.
         - ``u`` are marker effects which follow the distribution ``MVN(0, varU * I)``.
         - ``e`` are errors which follow the distribution ``MVN(0, varE * I)``.
 
     For a single trait, if the observations (y) are mean centered, then the model becomes::
 
     y = Zu + e
 
     Where::
+    
         - ``y`` are observations.
         - ``Z`` is a design matrix for genetic markers.
         - ``u`` are marker effects which follow the distribution ``MVN(0, varU * I)``.
         - ``e`` are errors which follow the distribution ``MVN(0, varE * I)``.
 
     Multiple traits are concatenated together into the model::
 
@@ -757,65 +770,108 @@
         ) -> 'rrBLUPModel0':
         """
         Fit a dense, additive linear genomic model.
 
         Parameters
         ----------
         Y : numpy.ndarray
-            A phenotype matrix of shape (n,t).
+            A phenotype matrix of shape ``(n,t)``.
+            
+            Where:
+
+            - ``n`` is the number of observations.
+            - ``t`` is the number of traits.
+        
         X : numpy.ndarray
             Not used by this model. Assumed to be ``(n,q)`` matrix of ones.
+
+            Where:
+
+            - ``n`` is the number of observations.
+            - ``q`` is the number of fixed effects.
+        
         Z : numpy.ndarray
-            A genotypes matrix of shape (n,p).
-        trait : numpy.ndarray
-            A trait name array of shape (t,).
+            A genotypes matrix of shape ``(n,p)``.
+
+            Where:
+
+            - ``n`` is the number of observations.
+            - ``p`` is the number of markers to be considered as random effects.
+        
+        trait : numpy.ndarray, None
+            A trait name array of shape ``(t,)``.
+
+            Where:
+
+            - ``t`` is the number of traits.
+        
         method : str
             Fitting method to use. Options are ``{"ML"}``.
+        
         model_name : str, None
             Name of the model.
+        
         hyperparams : dict, None
             Model parameters.
+        
         kwargs : dict
             Additional keyword arguments.
 
         Returns
         -------
         out : rrBLUPModel0
             An RR-BLUP model.
         """
-        # type checks
+        # type and shape checks
         check_is_ndarray(Y, "Y")
-        # check_is_ndarray(X, "X") # ignored by this model
-        check_is_ndarray(Z, "Z")
-
-        # shape checks
         check_ndarray_ndim(Y, "Y", 2)
+        # check_is_ndarray(X, "X") # ignored by this model
         # check_ndarray_ndim(X, "X", 2) # ignored by this model
+        # check_ndarray_axis_len_eq(X, "X", 0, Y.shape[0])
+        check_is_ndarray(Z, "Z")
         check_ndarray_ndim(Z, "Z", 2)
+        check_ndarray_axis_len_eq(Z, "Z", 0, Y.shape[0])
+
+        # get number of taxa (n), traits (t), markers (p)
+        # scalar
+        # ntaxa = Y.shape[0]
+        ntrait = Y.shape[1]
+        nmarker = Z.shape[1]
 
         # convert data types to floating if needed
         if not numpy.issubdtype(Y.dtype, numpy.floating):
             Y = Y.astype(float)
         if not numpy.issubdtype(Z.dtype, numpy.floating):
             Z = Z.astype(float)
 
-        # get number of traits
-        # scalar = t
-        ntrait = Y.shape[1]
+        # determine columns (loci) that are polymorphic
+        # True if polymorphic, False if monomorphic
+        # (p,)
+        ispolymorphic = ~numpy.all(Z == Z[0,:], axis = 0)
+
+        # get columns that are polymorphic
+        # (n,p)[:,mask] -> (n,p_poly)
+        Zpoly = Z[:,ispolymorphic]
 
-        # for each trait, fit a model
-        models = [rrBLUP_ML0(Y[:,i], Z) for i in range(ntrait)]
+        # for each trait, fit a model with polymorphic markers
+        models = [rrBLUP_ML0(Y[:,i], Zpoly) for i in range(ntrait)]
 
         # aggregate intercepts and stack estimates
         # (1,t)
         beta = numpy.stack([models[i]["betahat"] for i in range(ntrait)], axis = 1)
 
         # aggregate marker effects and stack estimates
+        # (p_poly,t)
+        uhat = numpy.stack([models[i]["uhat"] for i in range(ntrait)], axis = 1)
+
+        # create marker effect coefficent matrix, for monomorphic loci, assign effect as zero
         # (p,t)
-        u_a = numpy.stack([models[i]["uhat"] for i in range(ntrait)], axis = 1)
+        u_a = numpy.empty((nmarker,ntrait), dtype = float)
+        u_a[ispolymorphic,:] = uhat
+        u_a[~ispolymorphic,:] = 0.0
 
         # create output
         out = cls(
             beta = beta,
             u_misc = None,
             u_a = u_a,
             trait = trait,
```

### Comparing `pybrops-1.0.2/pybrops/model/pcvmat/AdditiveProgenyGeneticCovarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/pcvmat/AdditiveProgenyGeneticCovarianceMatrix.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 """
 Module defining interfaces and associated error checking routines for matrices
 storing additive genetic covariance estimates.
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 from pybrops.model.pcvmat.ProgenyGeneticCovarianceMatrix import ProgenyGeneticCovarianceMatrix
 from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 class AdditiveProgenyGeneticCovarianceMatrix(
         ProgenyGeneticCovarianceMatrix,
```

### Comparing `pybrops-1.0.2/pybrops/model/pcvmat/AdditiveProgenyGenicCovarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/pcvmat/AdditiveProgenyGenicCovarianceMatrix.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,21 @@
 """
 Module defining interfaces and associated error checking routines for matrices
 storing additive genic covariance estimates.
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 from pybrops.model.pcvmat.ProgenyGenicCovarianceMatrix import ProgenyGenicCovarianceMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 class AdditiveProgenyGenicCovarianceMatrix(
         ProgenyGenicCovarianceMatrix,
-        metaclass=ABCMeta,
+        metaclass = ABCMeta,
     ):
     """
     An abstract class for additive genetic covariance matrices.
 
     The purpose of this abstract interface is to provide functionality for:
         1) Estimation of additive genic covariance from an additive linear
            genomic model.
```

### Comparing `pybrops-1.0.2/pybrops/model/pcvmat/DenseAdditiveProgenyGeneticCovarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/pcvmat/DenseAdditiveProgenyGeneticCovarianceMatrix.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/model/pcvmat/DenseAdditiveProgenyGenicCovarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/pcvmat/DenseAdditiveProgenyGenicCovarianceMatrix.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/model/pcvmat/DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/pcvmat/DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,38 +1,49 @@
 """
 Module implementing classes and associated error checking routines for matrices
 storing dense additive genetic covariance estimates calculated using dihybrid DH
 formulae.
 """
 
 import math
-from numbers import Integral, Real
-from typing import Optional, Union
+from numbers import Integral
+from numbers import Real
+from pathlib import Path
+from typing import Optional
+from typing import Union
 import numpy
 import pandas
 import h5py
-from pybrops.core.error.error_io_python import check_file_exists
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_Integral_or_None, check_is_Integral_or_inf, check_is_str, check_is_str_or_Integral
-from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_Integral_or_None
+from pybrops.core.error.error_type_python import check_is_Integral_or_inf
+from pybrops.core.error.error_type_python import check_is_str
+from pybrops.core.error.error_type_python import check_is_str_or_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column, check_pandas_DataFrame_has_column_index
-from pybrops.core.util.arrayix import flattenix
-from pybrops.core.util.h5py import save_dict_to_hdf5
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column_index
+from pybrops.core.util.array import flattenix
 from pybrops.core.util.subroutines import srange
-from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel, check_is_AdditiveLinearGenomicModel
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
 from pybrops.model.vmat.util import cov_D1s
 from pybrops.model.vmat.util import cov_D2s
 from pybrops.model.pcvmat.DenseAdditiveProgenyGeneticCovarianceMatrix import DenseAdditiveProgenyGeneticCovarianceMatrix
-from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction, check_is_GeneticMapFunction
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
-
-class DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix(DenseAdditiveProgenyGeneticCovarianceMatrix):
+from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
+from pybrops.popgen.gmap.GeneticMapFunction import check_is_GeneticMapFunction
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
+
+class DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix(
+        DenseAdditiveProgenyGeneticCovarianceMatrix,
+    ):
     """
     A concrete class for dense additive genetic covariance matrices calculated
     for dihybrid DH progenies.
 
     The purpose of this concrete class is to implement functionality for:
         1) Genetic covariance estimation for dihybrid DH progenies.
         2) I/O for dihybrid DH progeny covariance matrices.
@@ -65,14 +76,35 @@
             mat = mat,
             taxa = taxa,
             taxa_grp = taxa_grp,
             trait = trait,
             **kwargs
         )
 
+    ########### Miscellaneous special functions ############
+    def __repr__(
+            self
+        ) -> str:
+        """
+        Return repr(self).
+        
+        Returns
+        -------
+        out : str
+            A representation of the object.
+        """
+        return "<{0} of shape (nfemale = {1}, nmale = {2}, ntrait = {3}, ntrait = {4}) at {5}>".format(
+            type(self).__name__,
+            self.nfemale,
+            self.nmale,
+            self.ntrait,
+            self.ntrait,
+            hex(id(self)),
+        )
+
     ############################ Object Properties #############################
 
     ##################### Matrix Data ######################
     @DenseAdditiveProgenyGeneticCovarianceMatrix.mat.setter
     def mat(self, value: numpy.ndarray) -> None:
         """Set pointer to raw numpy.ndarray object."""
         check_is_ndarray(value, "mat")
@@ -283,75 +315,39 @@
             header = header,
             index = index,
             **kwargs
         )
 
     def to_hdf5(
             self, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None,
             overwrite: bool = True,
         ) -> None:
         """
-        Write DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix to an HDF5 file.
+        Write ``DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str, h5py.File
+        filename : str, Path, h5py.File
             HDF5 file name or HDF5 file stream to which to write.
 
-        groupname : str or None
-            HDF5 group name under which the ``DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix`` data is stored.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix`` data is stored.
             If ``None``, the ``DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix`` is written to the base HDF5 group.
         
         overwrite : bool
             Whether to overwrite data fields if they are present in the HDF5 file.
         """
-        ### type checks
-        check_is_str(filename, "filename")
-
-        # open HDF5 in write mode
-        h5file = h5py.File(filename, "a")
-
-        ############ process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if groupname is a string, add '/' to end of string if not last character
-        elif isinstance(groupname, str):
-            if groupname[-1] != '/':
-                groupname += '/'
-
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ################ populate HDF5 file ################
-
-        # data dictionary
-        data_dict = {
-            "mat"           : self.mat,
-            "taxa"          : self.taxa,
-            "taxa_grp"      : self.taxa_grp,
-            "trait"         : self.trait,
-            "taxa_grp_name" : self.taxa_grp_name,
-            "taxa_grp_stix" : self.taxa_grp_stix,
-            "taxa_grp_spix" : self.taxa_grp_spix,
-            "taxa_grp_len"  : self.taxa_grp_len,
-        }
-
-        # save data
-        save_dict_to_hdf5(h5file, groupname, data_dict, overwrite)
-
-        ################# write conclusion #################
-
-        # close the file
-        h5file.close()
+        # call super function
+        super(DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix, self).to_hdf5(
+            filename  = filename,
+            groupname = groupname,
+            overwrite = overwrite,
+        )
     
     ############################## Class Methods ###############################
 
     ###################### Matrix I/O ######################
     @classmethod
     def from_pandas(
             cls, 
@@ -615,129 +611,39 @@
         )
 
         return out
     
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix':
         """
-        Read DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix from an HDF5 file.
+        Read ``DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix data is stored.
-            If None, DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix`` data is stored.
+            If ``None``, ``DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix`` is read from base HDF5 group.
 
         Returns
         -------
         out : DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix
-            A DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix read from file.
+            A ``DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix`` read from file.
         """
-        # type checks
-        check_is_str(filename, "filename")
-
-        #################### Open file #####################
-        
-        # check file exists
-        check_file_exists(filename)
-        
-        # open HDF5 in read only
-        h5file = h5py.File(filename, "r")
-        
-        ############ Process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if we have a string, check that group exists, add '/' to end if needed
-        elif isinstance(groupname, str):
-            check_h5py_File_has_group(h5file, filename, groupname)
-            if groupname[-1] != '/':
-                groupname += '/'
-        
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ############ Check for required fields #############
-
-        # list of all required arguments
-        required_fields = ["mat"]
-
-        # for each required field, concatenate base groupname and field and
-        # check that group exists
-        for field in required_fields:
-            fieldname = groupname + field
-            check_h5py_File_has_group(h5file, filename, fieldname)
-        
-        #################### Read data #####################
-
-        # output dictionary
-        data = {
-            "mat"           : None,
-            "taxa"          : None,
-            "taxa_grp"      : None,
-            "trait"         : None,
-            "taxa_grp_name" : None,
-            "taxa_grp_stix" : None,
-            "taxa_grp_spix" : None,
-            "taxa_grp_len"  : None,
-        }
-
-        # for each field, concatenate base groupname and field and
-        # if the field exists in the HDF5 file, then read the array
-        for field in data.keys():
-            fieldname = groupname + field
-            if fieldname in h5file:
-                data[field] = h5file[fieldname][()]
-
-        #################### Close file ####################
-        
-        # close file
-        h5file.close()
-        
-        ############### Datatype conversion ################
-
-        # if taxa names read, convert taxa strings from byte to utf-8
-        if data["taxa"] is not None:
-            data["taxa"] = numpy.array(
-                [s.decode("utf-8") for s in data["taxa"]],
-                dtype = object
-            )
-
-        # if trait names read, convert trait strings from byte to utf-8
-        if data["trait"] is not None:
-            data["trait"] = numpy.array(
-                [s.decode("utf-8") for s in data["trait"]],
-                dtype = object
-            )
-        
-        ################# Object creation ##################
-        # create object from read data
-        out = cls(
-            mat      = data["mat"],
-            taxa     = data["taxa"],
-            taxa_grp = data["taxa_grp"],
-            trait    = data["trait"],
+        # call super function
+        return super(DenseDihybridDHAdditiveProgenyGeneticCovarianceMatrix, cls).from_hdf5(
+            filename  = filename,
+            groupname = groupname,
         )
-        
-        # copy metadata if there is any
-        out.taxa_grp_name = data["taxa_grp_name"]
-        out.taxa_grp_stix = data["taxa_grp_stix"]
-        out.taxa_grp_spix = data["taxa_grp_spix"]
-        out.taxa_grp_len  = data["taxa_grp_len"]
-
-        return out
 
     ############# Matrix Factory Class Methods #############
     # TODO: provide support for non-linear models
     @classmethod
     def from_gmod(
             cls, 
             gmod: GenomicModel,
```

### Comparing `pybrops-1.0.2/pybrops/model/pcvmat/DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/pcvmat/DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix.py`

 * *Files 5% similar despite different names*

```diff
@@ -2,33 +2,40 @@
 Module implementing classes and associated error checking routines for matrices
 storing dense additive genic covariance estimates calculated using three-way DH
 formulae.
 """
 
 import math
 from numbers import Integral
-from typing import Optional, Union
+from pathlib import Path
+from typing import Optional
+from typing import Union
 import numpy
 import pandas
 import h5py
-from pybrops.core.error.error_io_python import check_file_exists
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_str, check_is_str_or_Integral
-from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_str
+from pybrops.core.error.error_type_python import check_is_str_or_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column, check_pandas_DataFrame_has_column_index
-from pybrops.core.util.arrayix import flattenix
-from pybrops.core.util.h5py import save_dict_to_hdf5
-from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel, check_is_AdditiveLinearGenomicModel
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column_index
+from pybrops.core.util.array import flattenix
+from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
 from pybrops.model.pcvmat.DenseAdditiveProgenyGenicCovarianceMatrix import DenseAdditiveProgenyGenicCovarianceMatrix
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
 
-class DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix(DenseAdditiveProgenyGenicCovarianceMatrix):
+class DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix(
+        DenseAdditiveProgenyGenicCovarianceMatrix,
+    ):
     """
     A concrete class for dense additive genic covariance matrices calculated
     for two-way DH progenies.
 
     The purpose of this concrete class is to implement functionality for:
         1) Genic covariance estimation for two-way DH progenies.
     """
@@ -60,14 +67,35 @@
             mat = mat,
             taxa = taxa,
             taxa_grp = taxa_grp,
             trait = trait,
             **kwargs
         )
 
+    ########### Miscellaneous special functions ############
+    def __repr__(
+            self
+        ) -> str:
+        """
+        Return repr(self).
+        
+        Returns
+        -------
+        out : str
+            A representation of the object.
+        """
+        return "<{0} of shape (nfemale = {1}, nmale = {2}, ntrait = {3}, ntrait = {4}) at {5}>".format(
+            type(self).__name__,
+            self.nfemale,
+            self.nmale,
+            self.ntrait,
+            self.ntrait,
+            hex(id(self)),
+        )
+
     ############################ Object Properties #############################
 
     ##################### Matrix Data ######################
     @DenseAdditiveProgenyGenicCovarianceMatrix.mat.setter
     def mat(self, value: numpy.ndarray) -> None:
         """Set pointer to raw numpy.ndarray object."""
         check_is_ndarray(value, "mat")
@@ -278,75 +306,39 @@
             header = header,
             index = index,
             **kwargs
         )
 
     def to_hdf5(
             self, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None,
             overwrite: bool = True,
         ) -> None:
         """
-        Write DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix to an HDF5 file.
+        Write ``DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str, h5py.File
+        filename : str, Path, h5py.File
             HDF5 file name or HDF5 file stream to which to write.
 
-        groupname : str or None
-            HDF5 group name under which the ``DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix`` data is stored.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix`` data is stored.
             If ``None``, the ``DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix`` is written to the base HDF5 group.
         
         overwrite : bool
             Whether to overwrite data fields if they are present in the HDF5 file.
         """
-        ### type checks
-        check_is_str(filename, "filename")
-
-        # open HDF5 in write mode
-        h5file = h5py.File(filename, "a")
-
-        ############ process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if groupname is a string, add '/' to end of string if not last character
-        elif isinstance(groupname, str):
-            if groupname[-1] != '/':
-                groupname += '/'
-
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ################ populate HDF5 file ################
-
-        # data dictionary
-        data_dict = {
-            "mat"           : self.mat,
-            "taxa"          : self.taxa,
-            "taxa_grp"      : self.taxa_grp,
-            "trait"         : self.trait,
-            "taxa_grp_name" : self.taxa_grp_name,
-            "taxa_grp_stix" : self.taxa_grp_stix,
-            "taxa_grp_spix" : self.taxa_grp_spix,
-            "taxa_grp_len"  : self.taxa_grp_len,
-        }
-
-        # save data
-        save_dict_to_hdf5(h5file, groupname, data_dict, overwrite)
-
-        ################# write conclusion #################
-
-        # close the file
-        h5file.close()
+        # call super function
+        super(DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix, self).to_hdf5(
+            filename  = filename,
+            groupname = groupname,
+            overwrite = overwrite,
+        )
     
     ############################## Class Methods ###############################
 
     ###################### Matrix I/O ######################
     @classmethod
     def from_pandas(
             cls, 
@@ -609,129 +601,39 @@
         )
 
         return out
     
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix':
         """
-        Read DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix from an HDF5 file.
+        Read ``DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix data is stored.
-            If None, DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix`` data is stored.
+            If ``None``, ``DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix`` is read from base HDF5 group.
 
         Returns
         -------
         out : DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix
-            A DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix read from file.
+            A ``DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix`` read from file.
         """
-        # type checks
-        check_is_str(filename, "filename")
-
-        #################### Open file #####################
-        
-        # check file exists
-        check_file_exists(filename)
-        
-        # open HDF5 in read only
-        h5file = h5py.File(filename, "r")
-        
-        ############ Process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if we have a string, check that group exists, add '/' to end if needed
-        elif isinstance(groupname, str):
-            check_h5py_File_has_group(h5file, filename, groupname)
-            if groupname[-1] != '/':
-                groupname += '/'
-        
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ############ Check for required fields #############
-
-        # list of all required arguments
-        required_fields = ["mat"]
-
-        # for each required field, concatenate base groupname and field and
-        # check that group exists
-        for field in required_fields:
-            fieldname = groupname + field
-            check_h5py_File_has_group(h5file, filename, fieldname)
-        
-        #################### Read data #####################
-
-        # output dictionary
-        data = {
-            "mat"           : None,
-            "taxa"          : None,
-            "taxa_grp"      : None,
-            "trait"         : None,
-            "taxa_grp_name" : None,
-            "taxa_grp_stix" : None,
-            "taxa_grp_spix" : None,
-            "taxa_grp_len"  : None,
-        }
-
-        # for each field, concatenate base groupname and field and
-        # if the field exists in the HDF5 file, then read the array
-        for field in data.keys():
-            fieldname = groupname + field
-            if fieldname in h5file:
-                data[field] = h5file[fieldname][()]
-
-        #################### Close file ####################
-        
-        # close file
-        h5file.close()
-        
-        ############### Datatype conversion ################
-
-        # if taxa names read, convert taxa strings from byte to utf-8
-        if data["taxa"] is not None:
-            data["taxa"] = numpy.array(
-                [s.decode("utf-8") for s in data["taxa"]],
-                dtype = object
-            )
-
-        # if trait names read, convert trait strings from byte to utf-8
-        if data["trait"] is not None:
-            data["trait"] = numpy.array(
-                [s.decode("utf-8") for s in data["trait"]],
-                dtype = object
-            )
-        
-        ################# Object creation ##################
-        # create object from read data
-        out = cls(
-            mat      = data["mat"],
-            taxa     = data["taxa"],
-            taxa_grp = data["taxa_grp"],
-            trait    = data["trait"],
+        # call super function
+        return super(DenseDihybridDHAdditiveProgenyGenicCovarianceMatrix, cls).from_hdf5(
+            filename  = filename,
+            groupname = groupname,
         )
-        
-        # copy metadata if there is any
-        out.taxa_grp_name = data["taxa_grp_name"]
-        out.taxa_grp_stix = data["taxa_grp_stix"]
-        out.taxa_grp_spix = data["taxa_grp_spix"]
-        out.taxa_grp_len  = data["taxa_grp_len"]
-
-        return out
 
     ############# Matrix Factory Class Methods #############
     # TODO: provide support for non-linear models
     @classmethod
     def from_gmod(
             cls, 
             gmod: GenomicModel, 
@@ -855,8 +757,8 @@
         out = cls(
             mat = cov_a,
             taxa = pgmat.taxa,
             taxa_grp = pgmat.taxa_grp,
             trait = algmod.trait
         )
 
-        return out
+        return out
```

### Comparing `pybrops-1.0.2/pybrops/model/pcvmat/DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/pcvmat/DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,38 +1,49 @@
 """
 Module implementing classes and associated error checking routines for matrices
 storing dense additive genetic covariance estimates calculated using four-way DH
 formulae.
 """
 
 import math
-from numbers import Integral, Real
-from typing import Optional, Union
+from numbers import Integral
+from numbers import Real
+from pathlib import Path
+from typing import Optional
+from typing import Union
 import numpy
 import pandas
 import h5py
-from pybrops.core.error.error_io_python import check_file_exists
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_Integral_or_None, check_is_Integral_or_inf, check_is_str, check_is_str_or_Integral
-from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_Integral_or_None
+from pybrops.core.error.error_type_python import check_is_Integral_or_inf
+from pybrops.core.error.error_type_python import check_is_str
+from pybrops.core.error.error_type_python import check_is_str_or_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column, check_pandas_DataFrame_has_column_index
-from pybrops.core.util.arrayix import flattenix
-from pybrops.core.util.h5py import save_dict_to_hdf5
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column_index
+from pybrops.core.util.array import flattenix
 from pybrops.core.util.subroutines import srange
-from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel, check_is_AdditiveLinearGenomicModel
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
 from pybrops.model.vmat.util import cov_D1s
 from pybrops.model.vmat.util import cov_D2s
 from pybrops.model.pcvmat.DenseAdditiveProgenyGeneticCovarianceMatrix import DenseAdditiveProgenyGeneticCovarianceMatrix
-from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction, check_is_GeneticMapFunction
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
-
-class DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix(DenseAdditiveProgenyGeneticCovarianceMatrix):
+from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
+from pybrops.popgen.gmap.GeneticMapFunction import check_is_GeneticMapFunction
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
+
+class DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix(
+        DenseAdditiveProgenyGeneticCovarianceMatrix,
+    ):
     """
     A concrete class for dense additive genetic covariance matrices calculated
     for four-way DH progenies.
 
     The purpose of this concrete class is to implement functionality for:
         1) Genetic covariance estimation for four-way DH progenies.
         2) I/O for four-way DH progeny covariance matrices.
@@ -65,14 +76,37 @@
             mat = mat,
             taxa = taxa,
             taxa_grp = taxa_grp,
             trait = trait,
             **kwargs
         )
 
+    ########### Miscellaneous special functions ############
+    def __repr__(
+            self
+        ) -> str:
+        """
+        Return repr(self).
+        
+        Returns
+        -------
+        out : str
+            A representation of the object.
+        """
+        return "<{0} of shape (nfemale2 = {1}, nmale2 = {2}, nfemale1 = {3}, nmale1 = {4}, ntrait = {5}, ntrait = {6}) at {7}>".format(
+            type(self).__name__,
+            self.nfemale2,
+            self.nmale2,
+            self.nfemale1,
+            self.nmale1,
+            self.ntrait,
+            self.ntrait,
+            hex(id(self)),
+        )
+
     ############################ Object Properties #############################
 
     ##################### Matrix Data ######################
     @DenseAdditiveProgenyGeneticCovarianceMatrix.mat.setter
     def mat(self, value: numpy.ndarray) -> None:
         """Set pointer to raw numpy.ndarray object."""
         check_is_ndarray(value, "mat")
@@ -362,75 +396,39 @@
             header = header,
             index = index,
             **kwargs
         )
 
     def to_hdf5(
             self, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None,
             overwrite: bool = True,
         ) -> None:
         """
-        Write DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix to an HDF5 file.
+        Write ``DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str, h5py.File
+        filename : str, Path, h5py.File
             HDF5 file name or HDF5 file stream to which to write.
 
-        groupname : str or None
-            HDF5 group name under which the ``DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix`` data is stored.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix`` data is stored.
             If ``None``, the ``DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix`` is written to the base HDF5 group.
         
         overwrite : bool
             Whether to overwrite data fields if they are present in the HDF5 file.
         """
-        ### type checks
-        check_is_str(filename, "filename")
-
-        # open HDF5 in write mode
-        h5file = h5py.File(filename, "a")
-
-        ############ process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if groupname is a string, add '/' to end of string if not last character
-        elif isinstance(groupname, str):
-            if groupname[-1] != '/':
-                groupname += '/'
-
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ################ populate HDF5 file ################
-
-        # data dictionary
-        data_dict = {
-            "mat"           : self.mat,
-            "taxa"          : self.taxa,
-            "taxa_grp"      : self.taxa_grp,
-            "trait"         : self.trait,
-            "taxa_grp_name" : self.taxa_grp_name,
-            "taxa_grp_stix" : self.taxa_grp_stix,
-            "taxa_grp_spix" : self.taxa_grp_spix,
-            "taxa_grp_len"  : self.taxa_grp_len,
-        }
-
-        # save data
-        save_dict_to_hdf5(h5file, groupname, data_dict, overwrite)
-
-        ################# write conclusion #################
-
-        # close the file
-        h5file.close()
+        # call super function
+        super(DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix, self).to_hdf5(
+            filename  = filename,
+            groupname = groupname,
+            overwrite = overwrite,
+        )
     
     ############################## Class Methods ###############################
 
     ###################### Matrix I/O ######################
     @classmethod
     def from_pandas(
             cls, 
@@ -801,129 +799,39 @@
         )
 
         return out
     
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix':
         """
-        Read DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix from an HDF5 file.
+        Read ``DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix data is stored.
-            If None, DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix`` data is stored.
+            If ``None``, ``DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix`` is read from base HDF5 group.
 
         Returns
         -------
         out : DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix
-            A DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix read from file.
+            A ``DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix`` read from file.
         """
-        # type checks
-        check_is_str(filename, "filename")
-
-        #################### Open file #####################
-        
-        # check file exists
-        check_file_exists(filename)
-        
-        # open HDF5 in read only
-        h5file = h5py.File(filename, "r")
-        
-        ############ Process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if we have a string, check that group exists, add '/' to end if needed
-        elif isinstance(groupname, str):
-            check_h5py_File_has_group(h5file, filename, groupname)
-            if groupname[-1] != '/':
-                groupname += '/'
-        
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ############ Check for required fields #############
-
-        # list of all required arguments
-        required_fields = ["mat"]
-
-        # for each required field, concatenate base groupname and field and
-        # check that group exists
-        for field in required_fields:
-            fieldname = groupname + field
-            check_h5py_File_has_group(h5file, filename, fieldname)
-        
-        #################### Read data #####################
-
-        # output dictionary
-        data = {
-            "mat"           : None,
-            "taxa"          : None,
-            "taxa_grp"      : None,
-            "trait"         : None,
-            "taxa_grp_name" : None,
-            "taxa_grp_stix" : None,
-            "taxa_grp_spix" : None,
-            "taxa_grp_len"  : None,
-        }
-
-        # for each field, concatenate base groupname and field and
-        # if the field exists in the HDF5 file, then read the array
-        for field in data.keys():
-            fieldname = groupname + field
-            if fieldname in h5file:
-                data[field] = h5file[fieldname][()]
-
-        #################### Close file ####################
-        
-        # close file
-        h5file.close()
-        
-        ############### Datatype conversion ################
-
-        # if taxa names read, convert taxa strings from byte to utf-8
-        if data["taxa"] is not None:
-            data["taxa"] = numpy.array(
-                [s.decode("utf-8") for s in data["taxa"]],
-                dtype = object
-            )
-
-        # if trait names read, convert trait strings from byte to utf-8
-        if data["trait"] is not None:
-            data["trait"] = numpy.array(
-                [s.decode("utf-8") for s in data["trait"]],
-                dtype = object
-            )
-        
-        ################# Object creation ##################
-        # create object from read data
-        out = cls(
-            mat      = data["mat"],
-            taxa     = data["taxa"],
-            taxa_grp = data["taxa_grp"],
-            trait    = data["trait"],
+        # call super function
+        return super(DenseFourWayDHAdditiveProgenyGeneticCovarianceMatrix, cls).from_hdf5(
+            filename  = filename,
+            groupname = groupname,
         )
-        
-        # copy metadata if there is any
-        out.taxa_grp_name = data["taxa_grp_name"]
-        out.taxa_grp_stix = data["taxa_grp_stix"]
-        out.taxa_grp_spix = data["taxa_grp_spix"]
-        out.taxa_grp_len  = data["taxa_grp_len"]
-
-        return out
 
     ############# Matrix Factory Class Methods #############
     # TODO: provide support for non-linear models
     @classmethod
     def from_gmod(
             cls, 
             gmod: GenomicModel,
```

### Comparing `pybrops-1.0.2/pybrops/model/pcvmat/DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/pcvmat/DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,33 +2,40 @@
 Module implementing classes and associated error checking routines for matrices
 storing dense additive genic covariance estimates calculated using four-way DH
 formulae.
 """
 
 import math
 from numbers import Integral
-from typing import Optional, Union
+from pathlib import Path
+from typing import Optional
+from typing import Union
 import numpy
 import pandas
 import h5py
-from pybrops.core.error.error_io_python import check_file_exists
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_str, check_is_str_or_Integral
-from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_str
+from pybrops.core.error.error_type_python import check_is_str_or_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column, check_pandas_DataFrame_has_column_index
-from pybrops.core.util.arrayix import flattenix
-from pybrops.core.util.h5py import save_dict_to_hdf5
-from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel, check_is_AdditiveLinearGenomicModel
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column_index
+from pybrops.core.util.array import flattenix
+from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
 from pybrops.model.pcvmat.DenseAdditiveProgenyGenicCovarianceMatrix import DenseAdditiveProgenyGenicCovarianceMatrix
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
 
-class DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix(DenseAdditiveProgenyGenicCovarianceMatrix):
+class DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix(
+        DenseAdditiveProgenyGenicCovarianceMatrix,
+    ):
     """
     A concrete class for dense additive genic covariance matrices calculated
     for two-way DH progenies.
 
     The purpose of this concrete class is to implement functionality for:
         1) Genic covariance estimation for two-way DH progenies.
     """
@@ -60,14 +67,37 @@
             mat = mat,
             taxa = taxa,
             taxa_grp = taxa_grp,
             trait = trait,
             **kwargs
         )
 
+    ########### Miscellaneous special functions ############
+    def __repr__(
+            self
+        ) -> str:
+        """
+        Return repr(self).
+        
+        Returns
+        -------
+        out : str
+            A representation of the object.
+        """
+        return "<{0} of shape (nfemale2 = {1}, nmale2 = {2}, nfemale1 = {3}, nmale1 = {4}, ntrait = {5}, ntrait = {6}) at {7}>".format(
+            type(self).__name__,
+            self.nfemale2,
+            self.nmale2,
+            self.nfemale1,
+            self.nmale1,
+            self.ntrait,
+            self.ntrait,
+            hex(id(self)),
+        )
+
     ############################ Object Properties #############################
 
     ##################### Matrix Data ######################
     @DenseAdditiveProgenyGenicCovarianceMatrix.mat.setter
     def mat(self, value: numpy.ndarray) -> None:
         """Set pointer to raw numpy.ndarray object."""
         check_is_ndarray(value, "mat")
@@ -357,75 +387,39 @@
             header = header,
             index = index,
             **kwargs
         )
 
     def to_hdf5(
             self, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None,
             overwrite: bool = True,
         ) -> None:
         """
-        Write DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix to an HDF5 file.
+        Write ``DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str, h5py.File
+        filename : str, Path, h5py.File
             HDF5 file name or HDF5 file stream to which to write.
 
-        groupname : str or None
-            HDF5 group name under which the ``DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix`` data is stored.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix`` data is stored.
             If ``None``, the ``DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix`` is written to the base HDF5 group.
         
         overwrite : bool
             Whether to overwrite data fields if they are present in the HDF5 file.
         """
-        ### type checks
-        check_is_str(filename, "filename")
-
-        # open HDF5 in write mode
-        h5file = h5py.File(filename, "a")
-
-        ############ process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if groupname is a string, add '/' to end of string if not last character
-        elif isinstance(groupname, str):
-            if groupname[-1] != '/':
-                groupname += '/'
-
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ################ populate HDF5 file ################
-
-        # data dictionary
-        data_dict = {
-            "mat"           : self.mat,
-            "taxa"          : self.taxa,
-            "taxa_grp"      : self.taxa_grp,
-            "trait"         : self.trait,
-            "taxa_grp_name" : self.taxa_grp_name,
-            "taxa_grp_stix" : self.taxa_grp_stix,
-            "taxa_grp_spix" : self.taxa_grp_spix,
-            "taxa_grp_len"  : self.taxa_grp_len,
-        }
-
-        # save data
-        save_dict_to_hdf5(h5file, groupname, data_dict, overwrite)
-
-        ################# write conclusion #################
-
-        # close the file
-        h5file.close()
+        # call super function
+        super(DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix, self).to_hdf5(
+            filename  = filename,
+            groupname = groupname,
+            overwrite = overwrite,
+        )
     
     ############################## Class Methods ###############################
 
     ###################### Matrix I/O ######################
     @classmethod
     def from_pandas(
             cls, 
@@ -795,129 +789,39 @@
         )
 
         return out
     
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix':
         """
-        Read DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix from an HDF5 file.
+        Read ``DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix data is stored.
-            If None, DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix`` data is stored.
+            If ``None``, ``DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix`` is read from base HDF5 group.
 
         Returns
         -------
         out : DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix
-            A DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix read from file.
+            A ``DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix`` read from file.
         """
-        # type checks
-        check_is_str(filename, "filename")
-
-        #################### Open file #####################
-        
-        # check file exists
-        check_file_exists(filename)
-        
-        # open HDF5 in read only
-        h5file = h5py.File(filename, "r")
-        
-        ############ Process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if we have a string, check that group exists, add '/' to end if needed
-        elif isinstance(groupname, str):
-            check_h5py_File_has_group(h5file, filename, groupname)
-            if groupname[-1] != '/':
-                groupname += '/'
-        
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ############ Check for required fields #############
-
-        # list of all required arguments
-        required_fields = ["mat"]
-
-        # for each required field, concatenate base groupname and field and
-        # check that group exists
-        for field in required_fields:
-            fieldname = groupname + field
-            check_h5py_File_has_group(h5file, filename, fieldname)
-        
-        #################### Read data #####################
-
-        # output dictionary
-        data = {
-            "mat"           : None,
-            "taxa"          : None,
-            "taxa_grp"      : None,
-            "trait"         : None,
-            "taxa_grp_name" : None,
-            "taxa_grp_stix" : None,
-            "taxa_grp_spix" : None,
-            "taxa_grp_len"  : None,
-        }
-
-        # for each field, concatenate base groupname and field and
-        # if the field exists in the HDF5 file, then read the array
-        for field in data.keys():
-            fieldname = groupname + field
-            if fieldname in h5file:
-                data[field] = h5file[fieldname][()]
-
-        #################### Close file ####################
-        
-        # close file
-        h5file.close()
-        
-        ############### Datatype conversion ################
-
-        # if taxa names read, convert taxa strings from byte to utf-8
-        if data["taxa"] is not None:
-            data["taxa"] = numpy.array(
-                [s.decode("utf-8") for s in data["taxa"]],
-                dtype = object
-            )
-
-        # if trait names read, convert trait strings from byte to utf-8
-        if data["trait"] is not None:
-            data["trait"] = numpy.array(
-                [s.decode("utf-8") for s in data["trait"]],
-                dtype = object
-            )
-        
-        ################# Object creation ##################
-        # create object from read data
-        out = cls(
-            mat      = data["mat"],
-            taxa     = data["taxa"],
-            taxa_grp = data["taxa_grp"],
-            trait    = data["trait"],
+        # call super function
+        return super(DenseFourWayDHAdditiveProgenyGenicCovarianceMatrix, cls).from_hdf5(
+            filename  = filename,
+            groupname = groupname,
         )
-        
-        # copy metadata if there is any
-        out.taxa_grp_name = data["taxa_grp_name"]
-        out.taxa_grp_stix = data["taxa_grp_stix"]
-        out.taxa_grp_spix = data["taxa_grp_spix"]
-        out.taxa_grp_len  = data["taxa_grp_len"]
-
-        return out
 
     ############# Matrix Factory Class Methods #############
     # TODO: provide support for non-linear models
     @classmethod
     def from_gmod(
             cls, 
             gmod: GenomicModel,
```

### Comparing `pybrops-1.0.2/pybrops/model/pcvmat/DenseProgenyGeneticCovarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/pcvmat/DenseProgenyGeneticCovarianceMatrix.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,15 +1,18 @@
 """
 Module implementing classes and associated error checking routines for matrices
 storing dense genetic covariance estimates.
 """
 
 import copy
+from pathlib import Path
 from typing import Optional
+from typing import Union
 import numpy
+import h5py
 from pybrops.core.mat.DenseSquareTaxaSquareTraitMatrix import DenseSquareTaxaSquareTraitMatrix
 from pybrops.model.pcvmat.ProgenyGeneticCovarianceMatrix import ProgenyGeneticCovarianceMatrix
 
 
 class DenseProgenyGeneticCovarianceMatrix(
         DenseSquareTaxaSquareTraitMatrix,
         ProgenyGeneticCovarianceMatrix,
@@ -118,25 +121,25 @@
 
     ############################## Class Methods ###############################
 
     ################### Matrix File I/O ####################
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseProgenyGeneticCovarianceMatrix':
         """
         Read DenseProgenyGeneticCovarianceMatrix from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
+        filename : str, Path, or h5py.File
             HDF5 file name which to read.
-        groupname : str or None
+        groupname : str, None
             HDF5 group name under which DenseProgenyGeneticCovarianceMatrix data is stored.
             If None, DenseProgenyGeneticCovarianceMatrix is read from base HDF5 group.
 
         Returns
         -------
         out : DenseProgenyGeneticCovarianceMatrix
             A dense matrix read from file.
```

### Comparing `pybrops-1.0.2/pybrops/model/pcvmat/DenseProgenyGenicCovarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/pcvmat/DenseProgenyGenicCovarianceMatrix.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/model/pcvmat/DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/pcvmat/DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,38 +1,49 @@
 """
 Module implementing classes and associated error checking routines for matrices
 storing dense additive genetic covariance estimates calculated using three-way DH
 formulae.
 """
 
 import math
-from numbers import Integral, Real
-from typing import Optional, Union
+from numbers import Integral
+from numbers import Real
+from pathlib import Path
+from typing import Optional
+from typing import Union
 import numpy
 import pandas
 import h5py
-from pybrops.core.error.error_io_python import check_file_exists
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_Integral_or_None, check_is_Integral_or_inf, check_is_str, check_is_str_or_Integral
-from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_Integral_or_None
+from pybrops.core.error.error_type_python import check_is_Integral_or_inf
+from pybrops.core.error.error_type_python import check_is_str
+from pybrops.core.error.error_type_python import check_is_str_or_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column, check_pandas_DataFrame_has_column_index
-from pybrops.core.util.arrayix import flattenix
-from pybrops.core.util.h5py import save_dict_to_hdf5
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column_index
+from pybrops.core.util.array import flattenix
 from pybrops.core.util.subroutines import srange
-from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel, check_is_AdditiveLinearGenomicModel
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
 from pybrops.model.vmat.util import cov_D1s
 from pybrops.model.vmat.util import cov_D2s
 from pybrops.model.pcvmat.DenseAdditiveProgenyGeneticCovarianceMatrix import DenseAdditiveProgenyGeneticCovarianceMatrix
-from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction, check_is_GeneticMapFunction
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
-
-class DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix(DenseAdditiveProgenyGeneticCovarianceMatrix):
+from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
+from pybrops.popgen.gmap.GeneticMapFunction import check_is_GeneticMapFunction
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
+
+class DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix(
+        DenseAdditiveProgenyGeneticCovarianceMatrix,
+    ):
     """
     A concrete class for dense additive genetic covariance matrices calculated
     for three-way DH progenies.
 
     The purpose of this concrete class is to implement functionality for:
         1) Genetic covariance estimation for three-way DH progenies.
         2) I/O for three-way DH progeny covariance matrices.
@@ -65,14 +76,36 @@
             mat = mat,
             taxa = taxa,
             taxa_grp = taxa_grp,
             trait = trait,
             **kwargs
         )
 
+    ########### Miscellaneous special functions ############
+    def __repr__(
+            self
+        ) -> str:
+        """
+        Return repr(self).
+        
+        Returns
+        -------
+        out : str
+            A representation of the object.
+        """
+        return "<{0} of shape (nrecurrent = {1}, nfemale = {2}, nmale = {3}, ntrait = {4}, ntrait = {5}) at {6}>".format(
+            type(self).__name__,
+            self.nrecurrent,
+            self.nfemale,
+            self.nmale,
+            self.ntrait,
+            self.ntrait,
+            hex(id(self)),
+        )
+
     ############################ Object Properties #############################
 
     ##################### Matrix Data ######################
     @DenseAdditiveProgenyGeneticCovarianceMatrix.mat.setter
     def mat(self, value: numpy.ndarray) -> None:
         """Set pointer to raw numpy.ndarray object."""
         check_is_ndarray(value, "mat")
@@ -319,75 +352,39 @@
             header = header,
             index = index,
             **kwargs
         )
 
     def to_hdf5(
             self, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None,
             overwrite: bool = True,
         ) -> None:
         """
         Write DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix to an HDF5 file.
 
         Parameters
         ----------
-        filename : str, h5py.File
+        filename : str, Path, h5py.File
             HDF5 file name or HDF5 file stream to which to write.
 
-        groupname : str or None
-            HDF5 group name under which the ``DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix`` data is stored.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix`` data is stored.
             If ``None``, the ``DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix`` is written to the base HDF5 group.
         
         overwrite : bool
             Whether to overwrite data fields if they are present in the HDF5 file.
         """
-        ### type checks
-        check_is_str(filename, "filename")
-
-        # open HDF5 in write mode
-        h5file = h5py.File(filename, "a")
-
-        ############ process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if groupname is a string, add '/' to end of string if not last character
-        elif isinstance(groupname, str):
-            if groupname[-1] != '/':
-                groupname += '/'
-
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ################ populate HDF5 file ################
-
-        # data dictionary
-        data_dict = {
-            "mat"           : self.mat,
-            "taxa"          : self.taxa,
-            "taxa_grp"      : self.taxa_grp,
-            "trait"         : self.trait,
-            "taxa_grp_name" : self.taxa_grp_name,
-            "taxa_grp_stix" : self.taxa_grp_stix,
-            "taxa_grp_spix" : self.taxa_grp_spix,
-            "taxa_grp_len"  : self.taxa_grp_len,
-        }
-
-        # save data
-        save_dict_to_hdf5(h5file, groupname, data_dict, overwrite)
-
-        ################# write conclusion #################
-
-        # close the file
-        h5file.close()
+        # call super function
+        super(DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix, self).to_hdf5(
+            filename  = filename,
+            groupname = groupname,
+            overwrite = overwrite,
+        )
     
     ############################## Class Methods ###############################
 
     ###################### Matrix I/O ######################
     @classmethod
     def from_pandas(
             cls, 
@@ -703,129 +700,39 @@
         )
 
         return out
     
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix':
         """
-        Read DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix from an HDF5 file.
+        Read ``DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix data is stored.
-            If None, DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix`` data is stored.
+            If ``None``, ``DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix`` is read from base HDF5 group.
 
         Returns
         -------
         out : DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix
-            A DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix read from file.
+            A ``DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix`` read from file.
         """
-        # type checks
-        check_is_str(filename, "filename")
-
-        #################### Open file #####################
-        
-        # check file exists
-        check_file_exists(filename)
-        
-        # open HDF5 in read only
-        h5file = h5py.File(filename, "r")
-        
-        ############ Process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if we have a string, check that group exists, add '/' to end if needed
-        elif isinstance(groupname, str):
-            check_h5py_File_has_group(h5file, filename, groupname)
-            if groupname[-1] != '/':
-                groupname += '/'
-        
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ############ Check for required fields #############
-
-        # list of all required arguments
-        required_fields = ["mat"]
-
-        # for each required field, concatenate base groupname and field and
-        # check that group exists
-        for field in required_fields:
-            fieldname = groupname + field
-            check_h5py_File_has_group(h5file, filename, fieldname)
-        
-        #################### Read data #####################
-
-        # output dictionary
-        data = {
-            "mat"           : None,
-            "taxa"          : None,
-            "taxa_grp"      : None,
-            "trait"         : None,
-            "taxa_grp_name" : None,
-            "taxa_grp_stix" : None,
-            "taxa_grp_spix" : None,
-            "taxa_grp_len"  : None,
-        }
-
-        # for each field, concatenate base groupname and field and
-        # if the field exists in the HDF5 file, then read the array
-        for field in data.keys():
-            fieldname = groupname + field
-            if fieldname in h5file:
-                data[field] = h5file[fieldname][()]
-
-        #################### Close file ####################
-        
-        # close file
-        h5file.close()
-        
-        ############### Datatype conversion ################
-
-        # if taxa names read, convert taxa strings from byte to utf-8
-        if data["taxa"] is not None:
-            data["taxa"] = numpy.array(
-                [s.decode("utf-8") for s in data["taxa"]],
-                dtype = object
-            )
-
-        # if trait names read, convert trait strings from byte to utf-8
-        if data["trait"] is not None:
-            data["trait"] = numpy.array(
-                [s.decode("utf-8") for s in data["trait"]],
-                dtype = object
-            )
-        
-        ################# Object creation ##################
-        # create object from read data
-        out = cls(
-            mat      = data["mat"],
-            taxa     = data["taxa"],
-            taxa_grp = data["taxa_grp"],
-            trait    = data["trait"],
+        # call super function
+        return super(DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix, cls).from_hdf5(
+            filename  = filename,
+            groupname = groupname,
         )
-        
-        # copy metadata if there is any
-        out.taxa_grp_name = data["taxa_grp_name"]
-        out.taxa_grp_stix = data["taxa_grp_stix"]
-        out.taxa_grp_spix = data["taxa_grp_spix"]
-        out.taxa_grp_len  = data["taxa_grp_len"]
-
-        return out
 
     ############# Matrix Factory Class Methods #############
     # TODO: provide support for non-linear models
     @classmethod
     def from_gmod(
             cls, 
             gmod: GenomicModel,
```

### Comparing `pybrops-1.0.2/pybrops/model/pcvmat/DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/pcvmat/DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix.py`

 * *Files 15% similar despite different names*

```diff
@@ -2,33 +2,40 @@
 Module implementing classes and associated error checking routines for matrices
 storing dense additive genic covariance estimates calculated using three-way DH
 formulae.
 """
 
 import math
 from numbers import Integral
-from typing import Optional, Union
+from pathlib import Path
+from typing import Optional
+from typing import Union
 import numpy
 import pandas
 import h5py
-from pybrops.core.error.error_io_python import check_file_exists
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_str, check_is_str_or_Integral
-from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_str
+from pybrops.core.error.error_type_python import check_is_str_or_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column, check_pandas_DataFrame_has_column_index
-from pybrops.core.util.arrayix import flattenix
-from pybrops.core.util.h5py import save_dict_to_hdf5
-from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel, check_is_AdditiveLinearGenomicModel
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column_index
+from pybrops.core.util.array import flattenix
+from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
 from pybrops.model.pcvmat.DenseAdditiveProgenyGenicCovarianceMatrix import DenseAdditiveProgenyGenicCovarianceMatrix
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
 
-class DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix(DenseAdditiveProgenyGenicCovarianceMatrix):
+class DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix(
+        DenseAdditiveProgenyGenicCovarianceMatrix,
+    ):
     """
     A concrete class for dense additive genic covariance matrices calculated
     for two-way DH progenies.
 
     The purpose of this concrete class is to implement functionality for:
         1) Genic covariance estimation for two-way DH progenies.
     """
@@ -60,14 +67,36 @@
             mat = mat,
             taxa = taxa,
             taxa_grp = taxa_grp,
             trait = trait,
             **kwargs
         )
 
+    ########### Miscellaneous special functions ############
+    def __repr__(
+            self
+        ) -> str:
+        """
+        Return repr(self).
+        
+        Returns
+        -------
+        out : str
+            A representation of the object.
+        """
+        return "<{0} of shape (nrecurrent = {1}, nfemale = {2}, nmale = {3}, ntrait = {4}, ntrait = {5}) at {6}>".format(
+            type(self).__name__,
+            self.nrecurrent,
+            self.nfemale,
+            self.nmale,
+            self.ntrait,
+            self.ntrait,
+            hex(id(self)),
+        )
+
     ############################ Object Properties #############################
 
     ##################### Matrix Data ######################
     @DenseAdditiveProgenyGenicCovarianceMatrix.mat.setter
     def mat(self, value: numpy.ndarray) -> None:
         """Set pointer to raw numpy.ndarray object."""
         check_is_ndarray(value, "mat")
@@ -314,75 +343,39 @@
             header = header,
             index = index,
             **kwargs
         )
 
     def to_hdf5(
             self, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None,
             overwrite: bool = True,
         ) -> None:
         """
-        Write DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix to an HDF5 file.
+        Write ``DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str, h5py.File
+        filename : str, Path, h5py.File
             HDF5 file name or HDF5 file stream to which to write.
 
-        groupname : str or None
-            HDF5 group name under which the ``DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix`` data is stored.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix`` data is stored.
             If ``None``, the ``DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix`` is written to the base HDF5 group.
         
         overwrite : bool
             Whether to overwrite data fields if they are present in the HDF5 file.
         """
-        ### type checks
-        check_is_str(filename, "filename")
-
-        # open HDF5 in write mode
-        h5file = h5py.File(filename, "a")
-
-        ############ process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if groupname is a string, add '/' to end of string if not last character
-        elif isinstance(groupname, str):
-            if groupname[-1] != '/':
-                groupname += '/'
-
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ################ populate HDF5 file ################
-
-        # data dictionary
-        data_dict = {
-            "mat"           : self.mat,
-            "taxa"          : self.taxa,
-            "taxa_grp"      : self.taxa_grp,
-            "trait"         : self.trait,
-            "taxa_grp_name" : self.taxa_grp_name,
-            "taxa_grp_stix" : self.taxa_grp_stix,
-            "taxa_grp_spix" : self.taxa_grp_spix,
-            "taxa_grp_len"  : self.taxa_grp_len,
-        }
-
-        # save data
-        save_dict_to_hdf5(h5file, groupname, data_dict, overwrite)
-
-        ################# write conclusion #################
-
-        # close the file
-        h5file.close()
+        # call super function
+        super(DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix, self).to_hdf5(
+            filename  = filename,
+            groupname = groupname,
+            overwrite = overwrite,
+        )
     
     ############################## Class Methods ###############################
 
     ###################### Matrix I/O ######################
     @classmethod
     def from_pandas(
             cls, 
@@ -697,129 +690,39 @@
         )
 
         return out
     
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix':
         """
-        Read DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix from an HDF5 file.
+        Read ``DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix data is stored.
-            If None, DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix`` data is stored.
+            If ``None``, ``DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix`` is read from base HDF5 group.
 
         Returns
         -------
         out : DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix
-            A DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix read from file.
+            A ``DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix`` read from file.
         """
-        # type checks
-        check_is_str(filename, "filename")
-
-        #################### Open file #####################
-        
-        # check file exists
-        check_file_exists(filename)
-        
-        # open HDF5 in read only
-        h5file = h5py.File(filename, "r")
-        
-        ############ Process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if we have a string, check that group exists, add '/' to end if needed
-        elif isinstance(groupname, str):
-            check_h5py_File_has_group(h5file, filename, groupname)
-            if groupname[-1] != '/':
-                groupname += '/'
-        
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ############ Check for required fields #############
-
-        # list of all required arguments
-        required_fields = ["mat"]
-
-        # for each required field, concatenate base groupname and field and
-        # check that group exists
-        for field in required_fields:
-            fieldname = groupname + field
-            check_h5py_File_has_group(h5file, filename, fieldname)
-        
-        #################### Read data #####################
-
-        # output dictionary
-        data = {
-            "mat"           : None,
-            "taxa"          : None,
-            "taxa_grp"      : None,
-            "trait"         : None,
-            "taxa_grp_name" : None,
-            "taxa_grp_stix" : None,
-            "taxa_grp_spix" : None,
-            "taxa_grp_len"  : None,
-        }
-
-        # for each field, concatenate base groupname and field and
-        # if the field exists in the HDF5 file, then read the array
-        for field in data.keys():
-            fieldname = groupname + field
-            if fieldname in h5file:
-                data[field] = h5file[fieldname][()]
-
-        #################### Close file ####################
-        
-        # close file
-        h5file.close()
-        
-        ############### Datatype conversion ################
-
-        # if taxa names read, convert taxa strings from byte to utf-8
-        if data["taxa"] is not None:
-            data["taxa"] = numpy.array(
-                [s.decode("utf-8") for s in data["taxa"]],
-                dtype = object
-            )
-
-        # if trait names read, convert trait strings from byte to utf-8
-        if data["trait"] is not None:
-            data["trait"] = numpy.array(
-                [s.decode("utf-8") for s in data["trait"]],
-                dtype = object
-            )
-        
-        ################# Object creation ##################
-        # create object from read data
-        out = cls(
-            mat      = data["mat"],
-            taxa     = data["taxa"],
-            taxa_grp = data["taxa_grp"],
-            trait    = data["trait"],
+        # call super function
+        return super(DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix, cls).from_hdf5(
+            filename  = filename,
+            groupname = groupname,
         )
-        
-        # copy metadata if there is any
-        out.taxa_grp_name = data["taxa_grp_name"]
-        out.taxa_grp_stix = data["taxa_grp_stix"]
-        out.taxa_grp_spix = data["taxa_grp_spix"]
-        out.taxa_grp_len  = data["taxa_grp_len"]
-
-        return out
 
     ############# Matrix Factory Class Methods #############
     # TODO: provide support for non-linear models
     @classmethod
     def from_gmod(
             cls, 
             gmod: GenomicModel,
```

### Comparing `pybrops-1.0.2/pybrops/model/pcvmat/DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/pcvmat/DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,33 +1,34 @@
 """
 Module implementing classes and associated error checking routines for matrices
 storing dense additive genetic covariance estimates calculated using two-way DH
 formulae.
 """
 
 import math
-from numbers import Integral, Real
-from typing import Optional, Union
+from numbers import Integral
+from numbers import Real
+from pathlib import Path
+from typing import Optional
+from typing import Union
 import h5py
 import numpy
 import pandas
-from pybrops.core.error.error_io_python import check_file_exists
+
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
 from pybrops.core.error.error_type_python import check_is_Integral
 from pybrops.core.error.error_type_python import check_is_Integral_or_None
 from pybrops.core.error.error_type_python import check_is_Integral_or_inf
 from pybrops.core.error.error_type_python import check_is_str
 from pybrops.core.error.error_type_python import check_is_str_or_Integral
-from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column
 from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column_index
-from pybrops.core.util.arrayix import flattenix
-from pybrops.core.util.h5py import save_dict_to_hdf5
+from pybrops.core.util.array import flattenix
 from pybrops.core.util.subroutines import srange
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
 from pybrops.model.vmat.util import cov_D1s
 from pybrops.model.pcvmat.DenseAdditiveProgenyGeneticCovarianceMatrix import DenseAdditiveProgenyGeneticCovarianceMatrix
@@ -75,14 +76,35 @@
             mat = mat,
             taxa = taxa,
             taxa_grp = taxa_grp,
             trait = trait,
             **kwargs
         )
 
+    ########### Miscellaneous special functions ############
+    def __repr__(
+            self
+        ) -> str:
+        """
+        Return repr(self).
+        
+        Returns
+        -------
+        out : str
+            A representation of the object.
+        """
+        return "<{0} of shape (nfemale = {1}, nmale = {2}, ntrait = {3}, ntrait = {4}) at {5}>".format(
+            type(self).__name__,
+            self.nfemale,
+            self.nmale,
+            self.ntrait,
+            self.ntrait,
+            hex(id(self)),
+        )
+
     ############################ Object Properties #############################
 
     ##################### Matrix Data ######################
     @DenseAdditiveProgenyGeneticCovarianceMatrix.mat.setter
     def mat(self, value: numpy.ndarray) -> None:
         """Set pointer to raw numpy.ndarray object."""
         check_is_ndarray(value, "mat")
@@ -303,75 +325,39 @@
             header      = header,
             index       = index,
             **kwargs
         )
 
     def to_hdf5(
             self, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None,
             overwrite: bool = True,
         ) -> None:
         """
-        Write DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix to an HDF5 file.
+        Write ``DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str, h5py.File
+        filename : str, Path, h5py.File
             HDF5 file name or HDF5 file stream to which to write.
 
-        groupname : str or None
-            HDF5 group name under which the ``DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix`` data is stored.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix`` data is stored.
             If ``None``, the ``DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix`` is written to the base HDF5 group.
         
         overwrite : bool
             Whether to overwrite data fields if they are present in the HDF5 file.
         """
-        ### type checks
-        check_is_str(filename, "filename")
-
-        # open HDF5 in write mode
-        h5file = h5py.File(filename, "a")
-
-        ############ process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if groupname is a string, add '/' to end of string if not last character
-        elif isinstance(groupname, str):
-            if groupname[-1] != '/':
-                groupname += '/'
-
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ################ populate HDF5 file ################
-
-        # data dictionary
-        data_dict = {
-            "mat"           : self.mat,
-            "taxa"          : self.taxa,
-            "taxa_grp"      : self.taxa_grp,
-            "trait"         : self.trait,
-            "taxa_grp_name" : self.taxa_grp_name,
-            "taxa_grp_stix" : self.taxa_grp_stix,
-            "taxa_grp_spix" : self.taxa_grp_spix,
-            "taxa_grp_len"  : self.taxa_grp_len,
-        }
-
-        # save data
-        save_dict_to_hdf5(h5file, groupname, data_dict, overwrite)
-
-        ################# write conclusion #################
-
-        # close the file
-        h5file.close()
+        # call super function
+        super(DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix, self).to_hdf5(
+            filename  = filename,
+            groupname = groupname,
+            overwrite = overwrite,
+        )
     
     ############################## Class Methods ###############################
 
     ###################### Matrix I/O ######################
     @classmethod
     def from_pandas(
             cls, 
@@ -640,129 +626,39 @@
         )
 
         return out
     
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix':
         """
-        Read DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix from an HDF5 file.
+        Read ``DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix data is stored.
-            If None, DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix`` data is stored.
+            If ``None``, ``DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix`` is read from base HDF5 group.
 
         Returns
         -------
         out : DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix
-            A DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix read from file.
+            A ``DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix`` read from file.
         """
-        # type checks
-        check_is_str(filename, "filename")
-
-        #################### Open file #####################
-        
-        # check file exists
-        check_file_exists(filename)
-        
-        # open HDF5 in read only
-        h5file = h5py.File(filename, "r")
-        
-        ############ Process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if we have a string, check that group exists, add '/' to end if needed
-        elif isinstance(groupname, str):
-            check_h5py_File_has_group(h5file, filename, groupname)
-            if groupname[-1] != '/':
-                groupname += '/'
-        
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ############ Check for required fields #############
-
-        # list of all required arguments
-        required_fields = ["mat"]
-
-        # for each required field, concatenate base groupname and field and
-        # check that group exists
-        for field in required_fields:
-            fieldname = groupname + field
-            check_h5py_File_has_group(h5file, filename, fieldname)
-        
-        #################### Read data #####################
-
-        # output dictionary
-        data = {
-            "mat"           : None,
-            "taxa"          : None,
-            "taxa_grp"      : None,
-            "trait"         : None,
-            "taxa_grp_name" : None,
-            "taxa_grp_stix" : None,
-            "taxa_grp_spix" : None,
-            "taxa_grp_len"  : None,
-        }
-
-        # for each field, concatenate base groupname and field and
-        # if the field exists in the HDF5 file, then read the array
-        for field in data.keys():
-            fieldname = groupname + field
-            if fieldname in h5file:
-                data[field] = h5file[fieldname][()]
-
-        #################### Close file ####################
-        
-        # close file
-        h5file.close()
-        
-        ############### Datatype conversion ################
-
-        # if taxa names read, convert taxa strings from byte to utf-8
-        if data["taxa"] is not None:
-            data["taxa"] = numpy.array(
-                [s.decode("utf-8") for s in data["taxa"]],
-                dtype = object
-            )
-
-        # if trait names read, convert trait strings from byte to utf-8
-        if data["trait"] is not None:
-            data["trait"] = numpy.array(
-                [s.decode("utf-8") for s in data["trait"]],
-                dtype = object
-            )
-        
-        ################# Object creation ##################
-        # create object from read data
-        out = cls(
-            mat      = data["mat"],
-            taxa     = data["taxa"],
-            taxa_grp = data["taxa_grp"],
-            trait    = data["trait"],
+        # call super function
+        return super(DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix, cls).from_hdf5(
+            filename  = filename,
+            groupname = groupname,
         )
-        
-        # copy metadata if there is any
-        out.taxa_grp_name = data["taxa_grp_name"]
-        out.taxa_grp_stix = data["taxa_grp_stix"]
-        out.taxa_grp_spix = data["taxa_grp_spix"]
-        out.taxa_grp_len  = data["taxa_grp_len"]
-
-        return out
 
     ############# Matrix Factory Class Methods #############
     # TODO: provide support for non-linear models
     @classmethod
     def from_gmod(
             cls, 
             gmod: GenomicModel,
```

### Comparing `pybrops-1.0.2/pybrops/model/pcvmat/DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/pcvmat/DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,33 +2,41 @@
 Module implementing classes and associated error checking routines for matrices
 storing dense additive genic covariance estimates calculated using three-way DH
 formulae.
 """
 
 import math
 from numbers import Integral
-from typing import Optional, Union
+from pathlib import Path
+from typing import Optional
+from typing import Union
 import numpy
 import pandas
 import h5py
-from pybrops.core.error.error_io_python import check_file_exists
+
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_str, check_is_str_or_Integral
-from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_str
+from pybrops.core.error.error_type_python import check_is_str_or_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column, check_pandas_DataFrame_has_column_index
-from pybrops.core.util.arrayix import flattenix
-from pybrops.core.util.h5py import save_dict_to_hdf5
-from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel, check_is_AdditiveLinearGenomicModel
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column_index
+from pybrops.core.util.array import flattenix
+from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
 from pybrops.model.pcvmat.DenseAdditiveProgenyGenicCovarianceMatrix import DenseAdditiveProgenyGenicCovarianceMatrix
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
 
-class DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix(DenseAdditiveProgenyGenicCovarianceMatrix):
+class DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix(
+        DenseAdditiveProgenyGenicCovarianceMatrix,
+    ):
     """
     A concrete class for dense additive genic covariance matrices calculated
     for two-way DH progenies.
 
     The purpose of this concrete class is to implement functionality for:
         1) Genic covariance estimation for two-way DH progenies.
     """
@@ -60,14 +68,35 @@
             mat = mat,
             taxa = taxa,
             taxa_grp = taxa_grp,
             trait = trait,
             **kwargs
         )
 
+    ########### Miscellaneous special functions ############
+    def __repr__(
+            self
+        ) -> str:
+        """
+        Return repr(self).
+        
+        Returns
+        -------
+        out : str
+            A representation of the object.
+        """
+        return "<{0} of shape (nfemale = {1}, nmale = {2}, ntrait = {3}, ntrait = {4}) at {5}>".format(
+            type(self).__name__,
+            self.nfemale,
+            self.nmale,
+            self.ntrait,
+            self.ntrait,
+            hex(id(self)),
+        )
+
     ############################ Object Properties #############################
 
     ##################### Matrix Data ######################
     @DenseAdditiveProgenyGenicCovarianceMatrix.mat.setter
     def mat(self, value: numpy.ndarray) -> None:
         """Set pointer to raw numpy.ndarray object."""
         check_is_ndarray(value, "mat")
@@ -278,75 +307,39 @@
             header = header,
             index = index,
             **kwargs
         )
 
     def to_hdf5(
             self, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None,
             overwrite: bool = True,
         ) -> None:
         """
-        Write DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix to an HDF5 file.
+        Write ``DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str, h5py.File
+        filename : str, Path, h5py.File
             HDF5 file name or HDF5 file stream to which to write.
 
-        groupname : str or None
-            HDF5 group name under which the ``DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix`` data is stored.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix`` data is stored.
             If ``None``, the ``DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix`` is written to the base HDF5 group.
         
         overwrite : bool
             Whether to overwrite data fields if they are present in the HDF5 file.
         """
-        ### type checks
-        check_is_str(filename, "filename")
-
-        # open HDF5 in write mode
-        h5file = h5py.File(filename, "a")
-
-        ############ process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if groupname is a string, add '/' to end of string if not last character
-        elif isinstance(groupname, str):
-            if groupname[-1] != '/':
-                groupname += '/'
-
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ################ populate HDF5 file ################
-
-        # data dictionary
-        data_dict = {
-            "mat"           : self.mat,
-            "taxa"          : self.taxa,
-            "taxa_grp"      : self.taxa_grp,
-            "trait"         : self.trait,
-            "taxa_grp_name" : self.taxa_grp_name,
-            "taxa_grp_stix" : self.taxa_grp_stix,
-            "taxa_grp_spix" : self.taxa_grp_spix,
-            "taxa_grp_len"  : self.taxa_grp_len,
-        }
-
-        # save data
-        save_dict_to_hdf5(h5file, groupname, data_dict, overwrite)
-
-        ################# write conclusion #################
-
-        # close the file
-        h5file.close()
+        # call super function
+        super(DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix, self).to_hdf5(
+            filename  = filename,
+            groupname = groupname,
+            overwrite = overwrite,
+        )
     
     ############################## Class Methods ###############################
 
     ###################### Matrix I/O ######################
     @classmethod
     def from_pandas(
             cls, 
@@ -610,129 +603,39 @@
         )
 
         return out
     
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix':
         """
-        Read DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix from an HDF5 file.
+        Read ``DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix data is stored.
-            If None, DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix`` data is stored.
+            If ``None``, ``DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix`` is read from base HDF5 group.
 
         Returns
         -------
         out : DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix
-            A DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix read from file.
+            A ``DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix`` read from file.
         """
-        # type checks
-        check_is_str(filename, "filename")
-
-        #################### Open file #####################
-        
-        # check file exists
-        check_file_exists(filename)
-        
-        # open HDF5 in read only
-        h5file = h5py.File(filename, "r")
-        
-        ############ Process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if we have a string, check that group exists, add '/' to end if needed
-        elif isinstance(groupname, str):
-            check_h5py_File_has_group(h5file, filename, groupname)
-            if groupname[-1] != '/':
-                groupname += '/'
-        
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ############ Check for required fields #############
-
-        # list of all required arguments
-        required_fields = ["mat"]
-
-        # for each required field, concatenate base groupname and field and
-        # check that group exists
-        for field in required_fields:
-            fieldname = groupname + field
-            check_h5py_File_has_group(h5file, filename, fieldname)
-        
-        #################### Read data #####################
-
-        # output dictionary
-        data = {
-            "mat"           : None,
-            "taxa"          : None,
-            "taxa_grp"      : None,
-            "trait"         : None,
-            "taxa_grp_name" : None,
-            "taxa_grp_stix" : None,
-            "taxa_grp_spix" : None,
-            "taxa_grp_len"  : None,
-        }
-
-        # for each field, concatenate base groupname and field and
-        # if the field exists in the HDF5 file, then read the array
-        for field in data.keys():
-            fieldname = groupname + field
-            if fieldname in h5file:
-                data[field] = h5file[fieldname][()]
-
-        #################### Close file ####################
-        
-        # close file
-        h5file.close()
-        
-        ############### Datatype conversion ################
-
-        # if taxa names read, convert taxa strings from byte to utf-8
-        if data["taxa"] is not None:
-            data["taxa"] = numpy.array(
-                [s.decode("utf-8") for s in data["taxa"]],
-                dtype = object
-            )
-
-        # if trait names read, convert trait strings from byte to utf-8
-        if data["trait"] is not None:
-            data["trait"] = numpy.array(
-                [s.decode("utf-8") for s in data["trait"]],
-                dtype = object
-            )
-        
-        ################# Object creation ##################
-        # create object from read data
-        out = cls(
-            mat      = data["mat"],
-            taxa     = data["taxa"],
-            taxa_grp = data["taxa_grp"],
-            trait    = data["trait"],
+        # call super function
+        return super(DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix, cls).from_hdf5(
+            filename  = filename,
+            groupname = groupname,
         )
-        
-        # copy metadata if there is any
-        out.taxa_grp_name = data["taxa_grp_name"]
-        out.taxa_grp_stix = data["taxa_grp_stix"]
-        out.taxa_grp_spix = data["taxa_grp_spix"]
-        out.taxa_grp_len  = data["taxa_grp_len"]
-
-        return out
 
     ############# Matrix Factory Class Methods #############
     # TODO: provide support for non-linear models
     @classmethod
     def from_gmod(
             cls, 
             gmod: GenomicModel,
```

### Comparing `pybrops-1.0.2/pybrops/model/pcvmat/ProgenyGeneticCovarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/pcvmat/ProgenyGeneticCovarianceMatrix.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 """
 Module defining interfaces and error checking routines for matrices storing progeny genetic covariance-covariance estimates.
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.core.io.CSVInputOutput import CSVInputOutput
 from pybrops.core.io.PandasInputOutput import PandasInputOutput
 from pybrops.core.mat.SquareTaxaSquareTraitMatrix import SquareTaxaSquareTraitMatrix
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
```

### Comparing `pybrops-1.0.2/pybrops/model/pcvmat/ProgenyGenicCovarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/pcvmat/ProgenyGenicCovarianceMatrix.py`

 * *Files 7% similar despite different names*

```diff
@@ -4,15 +4,16 @@
 """
 
 __all__ = [
     "ProgenyGenicCovarianceMatrix",
     "check_is_ProgenyGenicCovarianceMatrix",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.core.io.CSVInputOutput import CSVInputOutput
 from pybrops.core.io.PandasInputOutput import PandasInputOutput
 from pybrops.core.mat.SquareTaxaSquareTraitMatrix import SquareTaxaSquareTraitMatrix
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 class ProgenyGenicCovarianceMatrix(
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/AdditiveGeneticVarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/vmat/AdditiveGeneticVarianceMatrix.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 """
 Module defining interfaces and associated error checking routines for matrices
 storing additive genetic variance estimates.
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 from pybrops.model.vmat.GeneticVarianceMatrix import GeneticVarianceMatrix
 from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 class AdditiveGeneticVarianceMatrix(
         GeneticVarianceMatrix,
@@ -30,15 +31,15 @@
     ############################## Class Methods ###############################
     @classmethod
     @abstractmethod
     def from_algmod(
             cls, 
             algmod: AdditiveLinearGenomicModel, 
             pgmat: PhasedGenotypeMatrix, 
-            ncross: int, 
+            nmating: int, 
             nprogeny: int, 
             nself: int, 
             gmapfn: GeneticMapFunction, 
             mem: int,
             **kwargs: dict
         ) -> 'AdditiveGeneticVarianceMatrix':
         """
@@ -46,15 +47,15 @@
 
         Parameters
         ----------
         algmod : AdditiveLinearGenomicModel
             AdditiveLinearGenomicModel with which to estimate genetic variances.
         pgmat : PhasedGenotypeMatrix
             Input genomes to use to estimate genetic variances.
-        ncross : int
+        nmating : int
             Number of cross patterns to simulate for genetic variance
             estimation.
         nprogeny : int
             Number of progeny to simulate per cross to estimate genetic
             variance.
         nself : int
             Number of selfing generations post-cross pattern before 'nprogeny'
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/AdditiveGenicVarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/vmat/AdditiveGenicVarianceMatrix.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 """
 Module defining interfaces and associated error checking routines for matrices
 storing additive genic variance estimates.
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 from pybrops.model.vmat.GenicVarianceMatrix import GenicVarianceMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 class AdditiveGenicVarianceMatrix(
         GenicVarianceMatrix,
         metaclass = ABCMeta,
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/DenseAdditiveGeneticVarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/vmat/DenseAdditiveGeneticVarianceMatrix.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/model/vmat/DenseAdditiveGenicVarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/vmat/DenseAdditiveGenicVarianceMatrix.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/model/vmat/DenseDihybridDHAdditiveGeneticVarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/vmat/DenseDihybridDHAdditiveGeneticVarianceMatrix.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,38 +1,50 @@
 """
 Module implementing classes and associated error checking routines for matrices
 storing dense additive genetic variance estimates calculated using dihybrid DH
 formulae.
 """
 
 import math
-from numbers import Integral, Real
-from typing import Optional, Union
+from numbers import Integral
+from numbers import Real
+from pathlib import Path
+from typing import Optional
+from typing import Union
 import numpy
 import pandas
 import h5py
-from pybrops.core.error.error_io_python import check_file_exists
+
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_Integral_or_None, check_is_Integral_or_inf, check_is_str, check_is_str_or_Integral
-from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_Integral_or_None
+from pybrops.core.error.error_type_python import check_is_Integral_or_inf
+from pybrops.core.error.error_type_python import check_is_str
+from pybrops.core.error.error_type_python import check_is_str_or_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column, check_pandas_DataFrame_has_column_index
-from pybrops.core.util.arrayix import flattenix
-from pybrops.core.util.h5py import save_dict_to_hdf5
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column_index
+from pybrops.core.util.array import flattenix
 from pybrops.core.util.subroutines import srange
-from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel, check_is_AdditiveLinearGenomicModel
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
 from pybrops.model.vmat.util import cov_D1s
 from pybrops.model.vmat.util import cov_D2s
 from pybrops.model.vmat.DenseAdditiveGeneticVarianceMatrix import DenseAdditiveGeneticVarianceMatrix
-from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction, check_is_GeneticMapFunction
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
-
-class DenseDihybridDHAdditiveGeneticVarianceMatrix(DenseAdditiveGeneticVarianceMatrix):
+from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
+from pybrops.popgen.gmap.GeneticMapFunction import check_is_GeneticMapFunction
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
+
+class DenseDihybridDHAdditiveGeneticVarianceMatrix(
+        DenseAdditiveGeneticVarianceMatrix,
+    ):
     """
     A concrete class for dense additive genetic variance matrices calculated
     for dihybrid DH progenies.
 
     The purpose of this concrete class is to implement functionality for:
         1) Genetic variance estimation for dihybrid DH progenies.
         2) I/O for dihybrid DH progeny variance matrices.
@@ -288,75 +300,39 @@
             header = header,
             index = index,
             **kwargs
         )
 
     def to_hdf5(
             self, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None,
             overwrite: bool = True,
         ) -> None:
         """
-        Write DenseDihybridDHAdditiveGeneticVarianceMatrix to an HDF5 file.
+        Write ``DenseDihybridDHAdditiveGeneticVarianceMatrix`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str, h5py.File
+        filename : str, Path, h5py.File
             HDF5 file name or HDF5 file stream to which to write.
 
-        groupname : str or None
-            HDF5 group name under which the ``DenseDihybridDHAdditiveGeneticVarianceMatrix`` data is stored.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseDihybridDHAdditiveGeneticVarianceMatrix`` data is stored.
             If ``None``, the ``DenseDihybridDHAdditiveGeneticVarianceMatrix`` is written to the base HDF5 group.
         
         overwrite : bool
             Whether to overwrite data fields if they are present in the HDF5 file.
         """
-        ### type checks
-        check_is_str(filename, "filename")
-
-        # open HDF5 in write mode
-        h5file = h5py.File(filename, "a")
-
-        ############ process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if groupname is a string, add '/' to end of string if not last character
-        elif isinstance(groupname, str):
-            if groupname[-1] != '/':
-                groupname += '/'
-
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ################ populate HDF5 file ################
-
-        # data dictionary
-        data_dict = {
-            "mat"           : self.mat,
-            "taxa"          : self.taxa,
-            "taxa_grp"      : self.taxa_grp,
-            "trait"         : self.trait,
-            "taxa_grp_name" : self.taxa_grp_name,
-            "taxa_grp_stix" : self.taxa_grp_stix,
-            "taxa_grp_spix" : self.taxa_grp_spix,
-            "taxa_grp_len"  : self.taxa_grp_len,
-        }
-
-        # save data
-        save_dict_to_hdf5(h5file, groupname, data_dict)
-
-        ################# write conclusion #################
-
-        # close the file
-        h5file.close()
+        # call super function
+        super(DenseDihybridDHAdditiveGeneticVarianceMatrix, self).to_hdf5(
+            filename  = filename,
+            groupname = groupname,
+            overwrite = overwrite,
+        )
     
     ############################## Class Methods ###############################
 
     ###################### Matrix I/O ######################
     @classmethod
     def from_pandas(
             cls, 
@@ -608,138 +584,48 @@
         )
 
         return out
     
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
-            groupname: Optional[str] = None
+            filename: Union[str,Path,h5py.File], 
+            groupname: Optional[str] = None,
         ) -> 'DenseDihybridDHAdditiveGeneticVarianceMatrix':
         """
-        Read DenseDihybridDHAdditiveGeneticVarianceMatrix from an HDF5 file.
+        Read ``DenseDihybridDHAdditiveGeneticVarianceMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseDihybridDHAdditiveGeneticVarianceMatrix data is stored.
-            If None, DenseDihybridDHAdditiveGeneticVarianceMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseDihybridDHAdditiveGeneticVarianceMatrix`` data is stored.
+            If ``None``, ``DenseDihybridDHAdditiveGeneticVarianceMatrix`` is read from base HDF5 group.
 
         Returns
         -------
         out : DenseDihybridDHAdditiveGeneticVarianceMatrix
-            A DenseDihybridDHAdditiveGeneticVarianceMatrix read from file.
+            A ``DenseDihybridDHAdditiveGeneticVarianceMatrix`` read from file.
         """
-        # type checks
-        check_is_str(filename, "filename")
-
-        #################### Open file #####################
-        
-        # check file exists
-        check_file_exists(filename)
-        
-        # open HDF5 in read only
-        h5file = h5py.File(filename, "r")
-        
-        ############ Process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if we have a string, check that group exists, add '/' to end if needed
-        elif isinstance(groupname, str):
-            check_h5py_File_has_group(h5file, filename, groupname)
-            if groupname[-1] != '/':
-                groupname += '/'
-        
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ############ Check for required fields #############
-
-        # list of all required arguments
-        required_fields = ["mat"]
-
-        # for each required field, concatenate base groupname and field and
-        # check that group exists
-        for field in required_fields:
-            fieldname = groupname + field
-            check_h5py_File_has_group(h5file, filename, fieldname)
-        
-        #################### Read data #####################
-
-        # output dictionary
-        data = {
-            "mat"           : None,
-            "taxa"          : None,
-            "taxa_grp"      : None,
-            "trait"         : None,
-            "taxa_grp_name" : None,
-            "taxa_grp_stix" : None,
-            "taxa_grp_spix" : None,
-            "taxa_grp_len"  : None,
-        }
-
-        # for each field, concatenate base groupname and field and
-        # if the field exists in the HDF5 file, then read the array
-        for field in data.keys():
-            fieldname = groupname + field
-            if fieldname in h5file:
-                data[field] = h5file[fieldname][()]
-
-        #################### Close file ####################
-        
-        # close file
-        h5file.close()
-        
-        ############### Datatype conversion ################
-
-        # if taxa names read, convert taxa strings from byte to utf-8
-        if data["taxa"] is not None:
-            data["taxa"] = numpy.array(
-                [s.decode("utf-8") for s in data["taxa"]],
-                dtype = object
-            )
-
-        # if trait names read, convert trait strings from byte to utf-8
-        if data["trait"] is not None:
-            data["trait"] = numpy.array(
-                [s.decode("utf-8") for s in data["trait"]],
-                dtype = object
-            )
-        
-        ################# Object creation ##################
-        # create object from read data
-        out = cls(
-            mat      = data["mat"],
-            taxa     = data["taxa"],
-            taxa_grp = data["taxa_grp"],
-            trait    = data["trait"],
+        # call super function
+        return super(DenseDihybridDHAdditiveGeneticVarianceMatrix, cls).from_hdf5(
+            filename  = filename,
+            groupname = groupname,
         )
-        
-        # copy metadata if there is any
-        out.taxa_grp_name = data["taxa_grp_name"]
-        out.taxa_grp_stix = data["taxa_grp_stix"]
-        out.taxa_grp_spix = data["taxa_grp_spix"]
-        out.taxa_grp_len  = data["taxa_grp_len"]
-
-        return out
 
     ############# Matrix Factory Class Methods #############
     # TODO: provide support for non-linear models
     @classmethod
     def from_gmod(
             cls, 
             gmod: GenomicModel, 
             pgmat: PhasedGenotypeMatrix, 
-            ncross: Integral, 
+            nmating: Integral, 
             nprogeny: Integral, 
             nself: Union[Integral,Real],
             gmapfn: GeneticMapFunction,
             **kwargs: dict
         ) -> 'DenseDihybridDHAdditiveGeneticVarianceMatrix':
         """
         Calculate a symmetrical tensor of progeny variances for each possible
@@ -747,15 +633,15 @@
 
         Parameters
         ----------
         gmod : GenomicModel
             Genomic Model with which to estimate genetic variances.
         pgmat : PhasedGenotypeMatrix
             Input genomes to use to estimate genetic variances.
-        ncross : Integral
+        nmating : Integral
             Number of cross patterns to simulate for genetic variance
             estimation.
         nprogeny : Integral
             Number of progeny to simulate per cross to estimate genetic
             variance.
         nself : Integral, Real
             Number of selfing generations post-cross pattern before 'nprogeny'
@@ -784,40 +670,40 @@
         -------
         out : DenseDihybridDHAdditiveGeneticVarianceMatrix
             A matrix of additive genetic variance estimations.
         """
         # type checks
         check_is_GenomicModel(gmod, "gmod")
         check_is_PhasedGenotypeMatrix(pgmat, "pgmat")
-        check_is_Integral(ncross, "ncross")
+        check_is_Integral(nmating, "nmating")
         check_is_Integral(nprogeny, "nprogeny")
         check_is_Integral_or_inf(nself, "nself")
         check_is_GeneticMapFunction(gmapfn, "gmapfn")
         
         # if genomic model is an additive linear genomic model, then use specialized routine
         if isinstance(gmod, AdditiveLinearGenomicModel):
             return cls.from_algmod(
                 algmod = gmod, 
                 pgmat = pgmat, 
-                ncross = ncross, 
+                nmating = nmating, 
                 nprogeny = nprogeny, 
                 nself = nself, 
                 gmapfn = gmapfn, 
                 **kwargs
             )
         # otherwise raise error since non-linear support hasn't been implemented yet
         else:
             raise NotImplementedError("support for non-linear models not implemented yet")
 
     @classmethod
     def from_algmod(
             cls, 
             algmod: AdditiveLinearGenomicModel, 
             pgmat: PhasedGenotypeMatrix, 
-            ncross: Integral, 
+            nmating: Integral, 
             nprogeny: Integral, 
             nself: Union[Integral,Real], 
             gmapfn: Integral, 
             mem: Union[Integral,None] = 1024
         ) -> 'DenseDihybridDHAdditiveGeneticVarianceMatrix':
         """
         Calculate a symmetrical matrix of DH progeny variances for each possible
@@ -826,15 +712,15 @@
 
         Parameters
         ----------
         algmod : AdditiveLinearGenomicModel
             AdditiveLinearGenomicModel with which to estimate genetic variances.
         pgmat : PhasedGenotypeMatrix
             Input genomes to use to estimate genetic variances.
-        ncross : Integral
+        nmating : Integral
             Number of cross patterns to simulate for genetic variance
             estimation.
         nprogeny : Integral
             Number of progeny to simulate per cross to estimate genetic
             variance.
         nself : Integral, Real
             Number of selfing generations post-cross pattern before 'nprogeny'
@@ -869,15 +755,15 @@
         -------
         out : GeneticVarianceMatrix
             A matrix of additive genetic variance estimations.
         """
         # type checks
         check_is_AdditiveLinearGenomicModel(algmod, "algmod")
         check_is_PhasedGenotypeMatrix(pgmat, "pgmat")
-        check_is_Integral(ncross, "ncross")
+        check_is_Integral(nmating, "nmating")
         check_is_Integral(nprogeny, "nprogeny")
         check_is_Integral_or_inf(nself, "nself")
         check_is_GeneticMapFunction(gmapfn, "gmapfn")
         check_is_Integral_or_None(mem, "mem")
 
         # check for chromosome grouping
         if not pgmat.is_grouped_vrnt():
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/DenseDihybridDHAdditiveGenicVarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/vmat/DenseTwoWayDHAdditiveGeneticVarianceMatrix.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,99 +1,115 @@
 """
 Module implementing classes and associated error checking routines for matrices
-storing dense additive genic variance estimates calculated using three-way DH
+storing dense additive genetic variance estimates calculated using two-way DH
 formulae.
 """
 
 import math
 from numbers import Integral
-from typing import Optional, Union
+from numbers import Real
+from pathlib import Path
+from typing import Optional
+from typing import Union
+import h5py
 import numpy
 import pandas
-import h5py
-from pybrops.core.error.error_io_python import check_file_exists
+
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_str, check_is_str_or_Integral
-from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_Integral_or_None
+from pybrops.core.error.error_type_python import check_is_Integral_or_inf
+from pybrops.core.error.error_type_python import check_is_str
+from pybrops.core.error.error_type_python import check_is_str_or_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column, check_pandas_DataFrame_has_column_index
-from pybrops.core.util.arrayix import flattenix
-from pybrops.core.util.h5py import save_dict_to_hdf5
-from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel, check_is_AdditiveLinearGenomicModel
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
-from pybrops.model.vmat.DenseAdditiveGenicVarianceMatrix import DenseAdditiveGenicVarianceMatrix
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
-
-class DenseDihybridDHAdditiveGenicVarianceMatrix(DenseAdditiveGenicVarianceMatrix):
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column_index
+from pybrops.core.util.array import flattenix
+from pybrops.core.util.subroutines import srange
+from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
+from pybrops.model.vmat.util import cov_D1s
+from pybrops.model.vmat.DenseAdditiveGeneticVarianceMatrix import DenseAdditiveGeneticVarianceMatrix
+from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
+from pybrops.popgen.gmap.GeneticMapFunction import check_is_GeneticMapFunction
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
+
+class DenseTwoWayDHAdditiveGeneticVarianceMatrix(
+        DenseAdditiveGeneticVarianceMatrix,
+    ):
     """
-    A concrete class for dense additive genic variance matrices calculated
+    A concrete class for dense additive genetic variance matrices calculated
     for two-way DH progenies.
 
     The purpose of this concrete class is to implement functionality for:
-        1) Genic variance estimation for two-way DH progenies.
+        1) Genetic variance estimation for two-way DH progenies.
+        2) I/O for two-way DH progeny variance matrices.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
             mat: numpy.ndarray, 
             taxa: Optional[numpy.ndarray] = None, 
             taxa_grp: Optional[numpy.ndarray] = None, 
             trait: Optional[numpy.ndarray] = None, 
             **kwargs: dict
         ) -> None:
         """
-        Constructor for the concrete class DenseDihybridDHAdditiveGenicVarianceMatrix.
+        Constructor for the concrete class DenseTwoWayDHAdditiveGeneticVarianceMatrix.
 
         Parameters
         ----------
         mat : numpy.ndarray
             Array used to construct the object.
         taxa : numpy.ndarray, None
             Taxa names.
         taxa_grp : numpy.ndarray, None
             Taxa groupings.
         trait : numpy.ndarray, None
             Trait names.
         kwargs : dict
             Additional keyword arguments.
         """
-        super(DenseDihybridDHAdditiveGenicVarianceMatrix, self).__init__(
+        super(DenseTwoWayDHAdditiveGeneticVarianceMatrix, self).__init__(
             mat = mat,
             taxa = taxa,
             taxa_grp = taxa_grp,
             trait = trait,
             **kwargs
         )
 
     ############################ Object Properties #############################
 
     ##################### Matrix Data ######################
-    @DenseAdditiveGenicVarianceMatrix.mat.setter
+    @DenseAdditiveGeneticVarianceMatrix.mat.setter
     def mat(self, value: numpy.ndarray) -> None:
         """Set pointer to raw numpy.ndarray object."""
         check_is_ndarray(value, "mat")
         check_ndarray_ndim(value, "mat", 3) # (ntaxa,ntaxa,ntrait)
         self._mat = value
 
     ############## Square Metadata Properties ##############
-    @DenseAdditiveGenicVarianceMatrix.square_axes.getter
+    @DenseAdditiveGeneticVarianceMatrix.square_axes.getter
     def square_axes(self) -> tuple:
         """Get axis indices for axes that are square"""
         return (0,1) # (female, male)
 
     #################### Trait metadata ####################
-    @DenseAdditiveGenicVarianceMatrix.trait_axis.getter
+    @DenseAdditiveGeneticVarianceMatrix.trait_axis.getter
     def trait_axis(self) -> int:
         """Axis along which traits are stored."""
         return 2
 
     ######## Expected parental genome contributions ########
-    @DenseAdditiveGenicVarianceMatrix.epgc.getter
+    @DenseAdditiveGeneticVarianceMatrix.epgc.getter
     def epgc(self) -> tuple:
         """Get a tuple of the expected parental genome contributions."""
         return (0.5, 0.5)
 
     ################# Parental dimensions ##################
     @property
     def nfemale(self) -> Integral:
@@ -126,15 +142,15 @@
             male_col: str = "male",
             male_grp_col: Optional[str] = "male_grp",
             trait_col: str = "trait",
             variance_col: str = "variance",
             **kwargs: dict
         ) -> pandas.DataFrame:
         """
-        Export a DenseDihybridDHAdditiveGenicVarianceMatrix to a pandas.DataFrame.
+        Export a DenseTwoWayDHAdditiveGeneticVarianceMatrix to a pandas.DataFrame.
 
         Parameters
         ----------
         female_col : str, default = "female"
             Name of the column to which to write female taxa names.
 
         female_grp_col : str, None, default = "female_grp"
@@ -225,15 +241,15 @@
             variance_col: str = "variance",
             sep: str = ',', 
             header: bool = True, 
             index: bool = False, 
             **kwargs: dict
         ) -> None:
         """
-        Write a DenseDihybridDHAdditiveGenicVarianceMatrix to a CSV file.
+        Write a DenseTwoWayDHAdditiveGeneticVarianceMatrix to a CSV file.
 
         Parameters
         ----------
         filename : str
             CSV file name to which to write.
         
         female_col : str, default = "female"
@@ -262,15 +278,15 @@
         
         index : bool, default = False
             Whether to save a row index in the exported CSV file.
 
         kwargs : dict
             Additional keyword arguments to use for dictating export to a CSV.
         """
-        # convert DenseDihybridDHAdditiveGenicVarianceMatrix to pandas.DataFrame
+        # convert DenseTwoWayDHAdditiveGeneticVarianceMatrix to pandas.DataFrame
         df = self.to_pandas(
             female_col = female_col,
             female_grp_col = female_grp_col,
             male_col = male_col,
             male_grp_col = male_grp_col,
             trait_col = trait_col,
             variance_col = variance_col,
@@ -283,75 +299,39 @@
             header = header,
             index = index,
             **kwargs
         )
 
     def to_hdf5(
             self, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None,
             overwrite: bool = True,
         ) -> None:
         """
-        Write DenseDihybridDHAdditiveGenicVarianceMatrix to an HDF5 file.
+        Write ``DenseTwoWayDHAdditiveGeneticVarianceMatrix`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str, h5py.File
+        filename : str, Path, h5py.File
             HDF5 file name or HDF5 file stream to which to write.
 
-        groupname : str or None
-            HDF5 group name under which the ``DenseDihybridDHAdditiveGenicVarianceMatrix`` data is stored.
-            If ``None``, the ``DenseDihybridDHAdditiveGenicVarianceMatrix`` is written to the base HDF5 group.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseTwoWayDHAdditiveGeneticVarianceMatrix`` data is stored.
+            If ``None``, the ``DenseTwoWayDHAdditiveGeneticVarianceMatrix`` is written to the base HDF5 group.
         
         overwrite : bool
             Whether to overwrite data fields if they are present in the HDF5 file.
         """
-        ### type checks
-        check_is_str(filename, "filename")
-
-        # open HDF5 in write mode
-        h5file = h5py.File(filename, "a")
-
-        ############ process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if groupname is a string, add '/' to end of string if not last character
-        elif isinstance(groupname, str):
-            if groupname[-1] != '/':
-                groupname += '/'
-
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ################ populate HDF5 file ################
-
-        # data dictionary
-        data_dict = {
-            "mat"           : self.mat,
-            "taxa"          : self.taxa,
-            "taxa_grp"      : self.taxa_grp,
-            "trait"         : self.trait,
-            "taxa_grp_name" : self.taxa_grp_name,
-            "taxa_grp_stix" : self.taxa_grp_stix,
-            "taxa_grp_spix" : self.taxa_grp_spix,
-            "taxa_grp_len"  : self.taxa_grp_len,
-        }
-
-        # save data
-        save_dict_to_hdf5(h5file, groupname, data_dict)
-
-        ################# write conclusion #################
-
-        # close the file
-        h5file.close()
+        # call super function
+        super(DenseTwoWayDHAdditiveGeneticVarianceMatrix, self).to_hdf5(
+            filename  = filename,
+            groupname = groupname,
+            overwrite = overwrite,
+        )
     
     ############################## Class Methods ###############################
 
     ###################### Matrix I/O ######################
     @classmethod
     def from_pandas(
             cls, 
@@ -359,17 +339,17 @@
             female_col: Union[str,Integral] = "female",
             female_grp_col: Optional[Union[str,Integral]] = "female_grp",
             male_col: Union[str,Integral] = "male",
             male_grp_col: Optional[Union[str,Integral]] = "male_grp",
             trait_col: Union[str,Integral] = "trait",
             variance_col: Union[str,Integral] = "variance",
             **kwargs: dict
-        ) -> 'DenseDihybridDHAdditiveGenicVarianceMatrix':
+        ) -> 'DenseTwoWayDHAdditiveGeneticVarianceMatrix':
         """
-        Read a ``DenseDihybridDHAdditiveGenicVarianceMatrix`` from a ``pandas.DataFrame``.
+        Read a ``DenseTwoWayDHAdditiveGeneticVarianceMatrix`` from a ``pandas.DataFrame``.
 
         Parameters
         ----------
         df : pandas.DataFrame
             Pandas dataframe from which to read.
 
         female_col : str, Integral, default = "female"
@@ -392,16 +372,16 @@
 
         kwargs : dict
             Additional keyword arguments to use for dictating importing from a 
             ``pandas.DataFrame``.
         
         Returns
         -------
-        out : DenseDihybridDHAdditiveGenicVarianceMatrix
-            A ``DenseDihybridDHAdditiveGenicVarianceMatrix`` read from a ``pandas.DataFrame``.
+        out : DenseTwoWayDHAdditiveGeneticVarianceMatrix
+            A ``DenseTwoWayDHAdditiveGeneticVarianceMatrix`` read from a ``pandas.DataFrame``.
         """
         ### type checks and get df indices
 
         # df
         check_is_pandas_DataFrame(df, "df")
 
         # female_col
@@ -540,15 +520,15 @@
             male_col: Union[str,Integral] = "male",
             male_grp_col: Optional[Union[str,Integral]] = "male_grp",
             trait_col: Union[str,Integral] = "trait",
             variance_col: Union[str,Integral] = "variance",
             sep: str = ',',
             header: int = 0,
             **kwargs: dict
-        ) -> 'DenseDihybridDHAdditiveGenicVarianceMatrix':
+        ) -> 'DenseTwoWayDHAdditiveGeneticVarianceMatrix':
         """
         Read an object from a CSV file.
 
         Parameters
         ----------
         filename : str
             CSV file name from which to read.
@@ -603,249 +583,270 @@
         )
 
         return out
     
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
-        ) -> 'DenseDihybridDHAdditiveGenicVarianceMatrix':
+        ) -> 'DenseTwoWayDHAdditiveGeneticVarianceMatrix':
         """
-        Read DenseDihybridDHAdditiveGenicVarianceMatrix from an HDF5 file.
+        Read ``DenseTwoWayDHAdditiveGeneticVarianceMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseDihybridDHAdditiveGenicVarianceMatrix data is stored.
-            If None, DenseDihybridDHAdditiveGenicVarianceMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseTwoWayDHAdditiveGeneticVarianceMatrix`` data is stored.
+            If ``None``, ``DenseTwoWayDHAdditiveGeneticVarianceMatrix`` is read from base HDF5 group.
 
         Returns
         -------
-        out : DenseDihybridDHAdditiveGenicVarianceMatrix
-            A DenseDihybridDHAdditiveGenicVarianceMatrix read from file.
+        out : DenseTwoWayDHAdditiveGeneticVarianceMatrix
+            A ``DenseTwoWayDHAdditiveGeneticVarianceMatrix`` read from file.
         """
-        # type checks
-        check_is_str(filename, "filename")
-
-        #################### Open file #####################
-        
-        # check file exists
-        check_file_exists(filename)
-        
-        # open HDF5 in read only
-        h5file = h5py.File(filename, "r")
-        
-        ############ Process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if we have a string, check that group exists, add '/' to end if needed
-        elif isinstance(groupname, str):
-            check_h5py_File_has_group(h5file, filename, groupname)
-            if groupname[-1] != '/':
-                groupname += '/'
-        
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ############ Check for required fields #############
-
-        # list of all required arguments
-        required_fields = ["mat"]
-
-        # for each required field, concatenate base groupname and field and
-        # check that group exists
-        for field in required_fields:
-            fieldname = groupname + field
-            check_h5py_File_has_group(h5file, filename, fieldname)
-        
-        #################### Read data #####################
-
-        # output dictionary
-        data = {
-            "mat"           : None,
-            "taxa"          : None,
-            "taxa_grp"      : None,
-            "trait"         : None,
-            "taxa_grp_name" : None,
-            "taxa_grp_stix" : None,
-            "taxa_grp_spix" : None,
-            "taxa_grp_len"  : None,
-        }
-
-        # for each field, concatenate base groupname and field and
-        # if the field exists in the HDF5 file, then read the array
-        for field in data.keys():
-            fieldname = groupname + field
-            if fieldname in h5file:
-                data[field] = h5file[fieldname][()]
-
-        #################### Close file ####################
-        
-        # close file
-        h5file.close()
-        
-        ############### Datatype conversion ################
-
-        # if taxa names read, convert taxa strings from byte to utf-8
-        if data["taxa"] is not None:
-            data["taxa"] = numpy.array(
-                [s.decode("utf-8") for s in data["taxa"]],
-                dtype = object
-            )
-
-        # if trait names read, convert trait strings from byte to utf-8
-        if data["trait"] is not None:
-            data["trait"] = numpy.array(
-                [s.decode("utf-8") for s in data["trait"]],
-                dtype = object
-            )
-        
-        ################# Object creation ##################
-        # create object from read data
-        out = cls(
-            mat      = data["mat"],
-            taxa     = data["taxa"],
-            taxa_grp = data["taxa_grp"],
-            trait    = data["trait"],
+        # call super function
+        return super(DenseTwoWayDHAdditiveGeneticVarianceMatrix, cls).from_hdf5(
+            filename  = filename,
+            groupname = groupname,
         )
-        
-        # copy metadata if there is any
-        out.taxa_grp_name = data["taxa_grp_name"]
-        out.taxa_grp_stix = data["taxa_grp_stix"]
-        out.taxa_grp_spix = data["taxa_grp_spix"]
-        out.taxa_grp_len  = data["taxa_grp_len"]
-
-        return out
 
     ############# Matrix Factory Class Methods #############
     # TODO: provide support for non-linear models
     @classmethod
     def from_gmod(
             cls, 
             gmod: GenomicModel, 
             pgmat: PhasedGenotypeMatrix, 
-            nprogeny: int,
+            nmating: Integral, 
+            nprogeny: Integral, 
+            nself: Union[Integral,Real],
+            gmapfn: GeneticMapFunction,
             **kwargs: dict
-        ) -> 'DenseDihybridDHAdditiveGenicVarianceMatrix':
+        ) -> 'DenseTwoWayDHAdditiveGeneticVarianceMatrix':
         """
-        Estimate genic variances from a GenomicModel.
+        Calculate a symmetrical matrix of progeny variance for each pairwise
+        2-way cross between *inbred* individuals.
 
         Parameters
         ----------
         gmod : GenomicModel
-            GenomicModel with which to estimate genic variances.
+            Genomic Model with which to estimate genetic variances.
         pgmat : PhasedGenotypeMatrix
-            Input genomes to use to estimate genic variances.
-        nprogeny : int
-            Number of progeny to simulate per cross to estimate genic
+            Input genomes to use to estimate genetic variances.
+        nmating : Integral
+            Number of cross patterns to simulate for genetic variance
+            estimation.
+        nprogeny : Integral
+            Number of progeny to simulate per cross to estimate genetic
             variance.
+        nself : Integral, Real
+            Number of selfing generations post-cross pattern before 'nprogeny'
+            individuals are simulated.
+
+            +-----------------+-------------------------+
+            | Example         | Description             |
+            +=================+=========================+
+            | ``nself = 0``   | Derive gametes from F1  |
+            +-----------------+-------------------------+
+            | ``nself = 1``   | Derive gametes from F2  |
+            +-----------------+-------------------------+
+            | ``nself = 2``   | Derive gametes from F3  |
+            +-----------------+-------------------------+
+            | ``...``         | etc.                    |
+            +-----------------+-------------------------+
+            | ``nself = inf`` | Derive gametes from SSD |
+            +-----------------+-------------------------+
+        gmapfn : GeneticMapFunction
+            GeneticMapFunction to use to estimate covariance induced by
+            recombination.
         kwargs : dict
             Additional keyword arguments.
 
         Returns
         -------
-        out : GenicVarianceMatrix
-            A matrix of genic variance estimations.
+        out : DenseTwoWayDHAdditiveGeneticVarianceMatrix
+            A matrix of additive genetic variance estimations.
         """
         # type checks
         check_is_GenomicModel(gmod, "gmod")
         check_is_PhasedGenotypeMatrix(pgmat, "pgmat")
+        check_is_Integral(nmating, "nmating")
         check_is_Integral(nprogeny, "nprogeny")
+        check_is_Integral_or_inf(nself, "nself")
+        check_is_GeneticMapFunction(gmapfn, "gmapfn")
 
         # if genomic model is an additive linear genomic model, then use specialized routine
         if isinstance(gmod, AdditiveLinearGenomicModel):
             return cls.from_algmod(
                 algmod = gmod, 
                 pgmat = pgmat, 
+                nmating = nmating, 
                 nprogeny = nprogeny, 
+                nself = nself, 
+                gmapfn = gmapfn, 
                 **kwargs
             )
         # otherwise raise error since non-linear support hasn't been implemented yet
         else:
             raise NotImplementedError("support for non-linear models not implemented yet")
 
     @classmethod
     def from_algmod(
             cls, 
             algmod: AdditiveLinearGenomicModel, 
             pgmat: PhasedGenotypeMatrix, 
-            nprogeny: int, 
-            mem: int
-        ) -> 'DenseDihybridDHAdditiveGenicVarianceMatrix':
-        """
-        Estimate genic variances from a GenomicModel.
+            nmating: Integral, 
+            nprogeny: Integral, 
+            nself: Union[Integral,Real], 
+            gmapfn: GeneticMapFunction, 
+            mem: Union[Integral,None] = 1024
+        ) -> 'DenseTwoWayDHAdditiveGeneticVarianceMatrix':
+        """
+        Calculate a symmetrical matrix of progeny variance for each pairwise
+        2-way cross between *inbred* individuals.
+        Calculations are derived from Osthushenrich et al. (2017).
 
         Parameters
         ----------
-        gmod : GenomicModel
-            GenomicModel with which to estimate genic variances.
+        algmod : AdditiveLinearGenomicModel
+            AdditiveLinearGenomicModel with which to estimate genetic variances.
         pgmat : PhasedGenotypeMatrix
-            Input genomes to use to estimate genic variances.
-        nprogeny : int
-            Number of progeny to simulate per cross to estimate genic
+            Input genomes to use to estimate genetic variances.
+        nmating : Integral
+            Number of cross patterns to simulate for genetic variance
+            estimation.
+        nprogeny : Integral
+            Number of progeny to simulate per cross to estimate genetic
             variance.
-        mem : int
-            Memory chunk size to use during matrix operations.
+        nself : Integral, Real
+            Number of selfing generations post-cross pattern before 'nprogeny'
+            individuals are simulated.
+
+            +-----------------+-------------------------+
+            | Example         | Description             |
+            +=================+=========================+
+            | ``nself = 0``   | Derive gametes from F1  |
+            +-----------------+-------------------------+
+            | ``nself = 1``   | Derive gametes from F2  |
+            +-----------------+-------------------------+
+            | ``nself = 2``   | Derive gametes from F3  |
+            +-----------------+-------------------------+
+            | ``...``         | etc.                    |
+            +-----------------+-------------------------+
+            | ``nself = inf`` | Derive gametes from SSD |
+            +-----------------+-------------------------+
+        gmapfn : GeneticMapFunction
+            GeneticMapFunction to use to estimate covariance induced by
+            recombination.
+        mem : Integral, default = 1024
+            Memory chunk size to use during matrix operations. If ``None``,
+            then memory chunk size is not limited.
+
+            WARNING: Setting ``mem = None`` might result in memory allocation
+            errors! For reference, ``mem = 1024`` refers to a matrix of size
+            1024x1024, which needs about 8.5 MB of storage. Matrices of course
+            need a quadratic amount of memory: :math:`O(n^2)`.
 
         Returns
         -------
-        out : GenicVarianceMatrix
-            A matrix of additive genic variance estimations.
+        out : GeneticVarianceMatrix
+            A matrix of additive genetic variance estimations.
         """
         # type checks
         check_is_AdditiveLinearGenomicModel(algmod, "algmod")
         check_is_PhasedGenotypeMatrix(pgmat, "pgmat")
+        check_is_Integral(nmating, "nmating")
+        check_is_Integral(nprogeny, "nprogeny")
+        check_is_Integral_or_inf(nself, "nself")
+        check_is_GeneticMapFunction(gmapfn, "gmapfn")
+        check_is_Integral_or_None(mem, "mem")
+        
+        # check for chromosome grouping
+        if not pgmat.is_grouped_vrnt():
+            raise ValueError("pgmat must be grouped along the vrnt axis")
+
+        # check for genetic positions
+        if pgmat.vrnt_genpos is None:
+            raise ValueError("pgmat must have genetic positions")
 
         # gather shapes of data input
         ntrait = algmod.ntrait                  # number of traits (t)
         ntaxa = pgmat.ntaxa                     # number of individuals (n)
-        ploidy = pgmat.ploidy                   # ploidy level (scalar)
-        epgc = (0.5,0.5)                        # parental contributions
 
-        # gather allele frequencies within each taxon
-        tafreq = pgmat.tafreq()                 # (n,p) allele frequencies within taxon
+        # gather data pointers from genotypes and linear model
+        geno = pgmat.mat                        # (m,n,p) genotype matrix
+        chrgrp_stix = pgmat.vrnt_chrgrp_stix    # (g,) chromosome group start indices
+        chrgrp_spix = pgmat.vrnt_chrgrp_spix    # (g,) chromosome group stop indices
+        genpos = pgmat.vrnt_genpos              # (p,) marker genetic positions
         u = algmod.u_a                          # (p,t) marker effect coefficients
-        
-        # calculate individual locus variance coeffients for binomial distributions
-        # (p,t) -> (p,t)
-        varcoef = (ploidy * u)**2
 
         # allocate a square matrix for each pairwise variance
-        var_a = numpy.empty(
-            (ntaxa,ntaxa,ntrait),               # (n,n,t) variance matrix
+        var_A = numpy.zeros(
+            (ntaxa, ntaxa, ntrait),             # (n,n,t) variance matrix
             dtype = float
         )
 
-        # for each mate pair (including selfs)
-        for female in range(0,ntaxa):
-            for male in range(0,female):
-                # calculate the cross allele frequency
-                # (n,p)[(2,),:] -> (2,p)
-                # (2,) . (2,p) -> (p,)
-                p = numpy.dot(epgc, tafreq[(female,male),:])
-
-                # calculate the variance
-                # scalar - (p,1) -> (p,1)
-                # (p,t) * (p,1) * (p,1) -> (p,t)
-                # (p,t).sum(0) -> (t,)
-                v = (varcoef * p[:,None] * (1.0 - p[:,None])).sum(0)
-
-                # store in matrix and copy to lower since matrix is symmetrical
-                var_a[female,male,:] = v
-                var_a[male,female,:] = v
+        # for each linkage group
+        for lst, lsp in zip(chrgrp_stix, chrgrp_spix):
+            # determine memory chunk step (for iterators)
+            step = (lsp - lst) if mem is None else mem
+            # for each computational chunk: rb = row block, cb = column block
+            for rst,rsp in zip(range(lst,lsp,step),srange(lst+step,lsp,step)):
+                for cst,csp in zip(range(lst,lsp,step),srange(lst+step,lsp,step)):
+                    # create sparse meshgrid indicating where genetic positions are
+                    gi, gj = numpy.meshgrid(
+                        genpos[rst:rsp],        # row block genetic positions
+                        genpos[cst:csp],        # column block genetic positions
+                        indexing='ij',          # use ij indexing
+                        sparse=True             # generate a spare array tuple for speed
+                    )
+
+                    # calculate recombination probability matrix for chunk
+                    r = gmapfn.mapfn(numpy.abs(gi - gj)) # (rb,cb) covariance matrix
+
+                    # calculate a D1 recombination covariance matrix; this is specific to mating scheme
+                    D1 = cov_D1s(r, nself)  # (rb,cb) covariance matrix
+
+                    # get marker coefficients for rows and columns
+                    ru = u[rst:rsp].T # (rb,t)' -> (t,rb)
+                    cu = u[cst:csp].T # (cb,t)' -> (t,cb)
+
+                    # for each mate pair (excluding selfs)
+                    for female in range(1,ntaxa): # varA row index
+                        for male in range(0,female): # varA col index
+                            # calculate genotype differences for row, col
+                            # phased genotype matrix must be coded in {0,1}
+                            # resulting difference matrix has values {-1,0,1}
+                            rdgeno = geno[0,female,rst:rsp] - geno[0,male,rst:rsp] # (rb,)
+                            cdgeno = geno[0,female,cst:csp] - geno[0,male,cst:csp] # (cb,)
+
+                            # calculate effect differences
+                            reffect = rdgeno * ru # (rb,)*(t,rb) -> (t,rb)
+                            ceffect = cdgeno * cu # (cb,)*(t,cb) -> (t,cb)
+
+                            # compute dot product for each trait to get partial variance sum
+                            # (t,rb)@(rb,cb) -> (t,cb)
+                            # (t,cb)*(t,cb) -> (t,cb)
+                            # (t,cb)[1] -> (t,)
+                            var_A_partial = (reffect @ D1 * ceffect).sum(1)
+
+                            # add this partial variance to the lower triangle
+                            var_A[female,male,:] += var_A_partial
+
+        # since var_A matrix is symmetrical, copy lower triangle to the upper
+        for female in range(1, ntaxa):
+            for male in range(0, female):
+                var_A[male,female,:] = var_A[female,male,:]
 
         # construct output
         out = cls(
-            mat = var_a,
+            mat = var_A,
             taxa = pgmat.taxa,
             taxa_grp = pgmat.taxa_grp,
             trait = algmod.trait
         )
 
-        return out
+        return out
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/DenseFourWayDHAdditiveGeneticVarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/vmat/DenseFourWayDHAdditiveGeneticVarianceMatrix.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,38 +1,50 @@
 """
 Module implementing classes and associated error checking routines for matrices
 storing dense additive genetic variance estimates calculated using four-way DH
 formulae.
 """
 
 import math
-from numbers import Integral, Real
-from typing import Optional, Union
+from numbers import Integral
+from numbers import Real
+from pathlib import Path
+from typing import Optional
+from typing import Union
 import numpy
 import pandas
 import h5py
-from pybrops.core.error.error_io_python import check_file_exists
+
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_Integral_or_None, check_is_Integral_or_inf, check_is_str, check_is_str_or_Integral
-from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_Integral_or_None
+from pybrops.core.error.error_type_python import check_is_Integral_or_inf
+from pybrops.core.error.error_type_python import check_is_str
+from pybrops.core.error.error_type_python import check_is_str_or_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column, check_pandas_DataFrame_has_column_index
-from pybrops.core.util.arrayix import flattenix
-from pybrops.core.util.h5py import save_dict_to_hdf5
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column_index
+from pybrops.core.util.array import flattenix
 from pybrops.core.util.subroutines import srange
-from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel, check_is_AdditiveLinearGenomicModel
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
 from pybrops.model.vmat.util import cov_D1s
 from pybrops.model.vmat.util import cov_D2s
 from pybrops.model.vmat.DenseAdditiveGeneticVarianceMatrix import DenseAdditiveGeneticVarianceMatrix
-from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction, check_is_GeneticMapFunction
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
-
-class DenseFourWayDHAdditiveGeneticVarianceMatrix(DenseAdditiveGeneticVarianceMatrix):
+from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
+from pybrops.popgen.gmap.GeneticMapFunction import check_is_GeneticMapFunction
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
+
+class DenseFourWayDHAdditiveGeneticVarianceMatrix(
+        DenseAdditiveGeneticVarianceMatrix,
+    ):
     """
     A concrete class for dense additive genetic variance matrices calculated
     for four-way DH progenies.
 
     The purpose of this concrete class is to implement functionality for:
         1) Genetic variance estimation for four-way DH progenies.
         2) I/O for four-way DH progeny variance matrices.
@@ -367,75 +379,39 @@
             header = header,
             index = index,
             **kwargs
         )
 
     def to_hdf5(
             self, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None,
             overwrite: bool = True,
         ) -> None:
         """
-        Write DenseFourWayDHAdditiveGeneticVarianceMatrix to an HDF5 file.
+        Write ``DenseFourWayDHAdditiveGeneticVarianceMatrix`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str, h5py.File
+        filename : str, Path, h5py.File
             HDF5 file name or HDF5 file stream to which to write.
 
-        groupname : str or None
-            HDF5 group name under which the ``DenseFourWayDHAdditiveGeneticVarianceMatrix`` data is stored.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseFourWayDHAdditiveGeneticVarianceMatrix`` data is stored.
             If ``None``, the ``DenseFourWayDHAdditiveGeneticVarianceMatrix`` is written to the base HDF5 group.
         
         overwrite : bool
             Whether to overwrite data fields if they are present in the HDF5 file.
         """
-        ### type checks
-        check_is_str(filename, "filename")
-
-        # open HDF5 in write mode
-        h5file = h5py.File(filename, "a")
-
-        ############ process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if groupname is a string, add '/' to end of string if not last character
-        elif isinstance(groupname, str):
-            if groupname[-1] != '/':
-                groupname += '/'
-
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ################ populate HDF5 file ################
-
-        # data dictionary
-        data_dict = {
-            "mat"           : self.mat,
-            "taxa"          : self.taxa,
-            "taxa_grp"      : self.taxa_grp,
-            "trait"         : self.trait,
-            "taxa_grp_name" : self.taxa_grp_name,
-            "taxa_grp_stix" : self.taxa_grp_stix,
-            "taxa_grp_spix" : self.taxa_grp_spix,
-            "taxa_grp_len"  : self.taxa_grp_len,
-        }
-
-        # save data
-        save_dict_to_hdf5(h5file, groupname, data_dict, overwrite)
-
-        ################# write conclusion #################
-
-        # close the file
-        h5file.close()
+        # call super function
+        super(DenseFourWayDHAdditiveGeneticVarianceMatrix, self).to_hdf5(
+            filename  = filename,
+            groupname = groupname,
+            overwrite = overwrite,
+        )
     
     ############################## Class Methods ###############################
 
     ###################### Matrix I/O ######################
     @classmethod
     def from_pandas(
             cls, 
@@ -794,138 +770,48 @@
         )
 
         return out
     
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseFourWayDHAdditiveGeneticVarianceMatrix':
         """
-        Read DenseFourWayDHAdditiveGeneticVarianceMatrix from an HDF5 file.
+        Read ``DenseFourWayDHAdditiveGeneticVarianceMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseFourWayDHAdditiveGeneticVarianceMatrix data is stored.
-            If None, DenseFourWayDHAdditiveGeneticVarianceMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseFourWayDHAdditiveGeneticVarianceMatrix`` data is stored.
+            If ``None``, ``DenseFourWayDHAdditiveGeneticVarianceMatrix`` is read from base HDF5 group.
 
         Returns
         -------
         out : DenseFourWayDHAdditiveGeneticVarianceMatrix
-            A DenseFourWayDHAdditiveGeneticVarianceMatrix read from file.
+            A ``DenseFourWayDHAdditiveGeneticVarianceMatrix`` read from file.
         """
-        # type checks
-        check_is_str(filename, "filename")
-
-        #################### Open file #####################
-        
-        # check file exists
-        check_file_exists(filename)
-        
-        # open HDF5 in read only
-        h5file = h5py.File(filename, "r")
-        
-        ############ Process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if we have a string, check that group exists, add '/' to end if needed
-        elif isinstance(groupname, str):
-            check_h5py_File_has_group(h5file, filename, groupname)
-            if groupname[-1] != '/':
-                groupname += '/'
-        
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ############ Check for required fields #############
-
-        # list of all required arguments
-        required_fields = ["mat"]
-
-        # for each required field, concatenate base groupname and field and
-        # check that group exists
-        for field in required_fields:
-            fieldname = groupname + field
-            check_h5py_File_has_group(h5file, filename, fieldname)
-        
-        #################### Read data #####################
-
-        # output dictionary
-        data = {
-            "mat"           : None,
-            "taxa"          : None,
-            "taxa_grp"      : None,
-            "trait"         : None,
-            "taxa_grp_name" : None,
-            "taxa_grp_stix" : None,
-            "taxa_grp_spix" : None,
-            "taxa_grp_len"  : None,
-        }
-
-        # for each field, concatenate base groupname and field and
-        # if the field exists in the HDF5 file, then read the array
-        for field in data.keys():
-            fieldname = groupname + field
-            if fieldname in h5file:
-                data[field] = h5file[fieldname][()]
-
-        #################### Close file ####################
-        
-        # close file
-        h5file.close()
-        
-        ############### Datatype conversion ################
-
-        # if taxa names read, convert taxa strings from byte to utf-8
-        if data["taxa"] is not None:
-            data["taxa"] = numpy.array(
-                [s.decode("utf-8") for s in data["taxa"]],
-                dtype = object
-            )
-
-        # if trait names read, convert trait strings from byte to utf-8
-        if data["trait"] is not None:
-            data["trait"] = numpy.array(
-                [s.decode("utf-8") for s in data["trait"]],
-                dtype = object
-            )
-        
-        ################# Object creation ##################
-        # create object from read data
-        out = cls(
-            mat      = data["mat"],
-            taxa     = data["taxa"],
-            taxa_grp = data["taxa_grp"],
-            trait    = data["trait"],
+        # call super function
+        return super(DenseFourWayDHAdditiveGeneticVarianceMatrix, cls).from_hdf5(
+            filename  = filename,
+            groupname = groupname,
         )
-        
-        # copy metadata if there is any
-        out.taxa_grp_name = data["taxa_grp_name"]
-        out.taxa_grp_stix = data["taxa_grp_stix"]
-        out.taxa_grp_spix = data["taxa_grp_spix"]
-        out.taxa_grp_len  = data["taxa_grp_len"]
-
-        return out
 
     ############# Matrix Factory Class Methods #############
     # TODO: provide support for non-linear models
     @classmethod
     def from_gmod(
             cls, 
             gmod: GenomicModel, 
             pgmat: PhasedGenotypeMatrix, 
-            ncross: Integral, 
+            nmating: Integral, 
             nprogeny: Integral, 
             nself: Union[Integral,Real],
             gmapfn: GeneticMapFunction,
             **kwargs: dict
         ) -> 'DenseFourWayDHAdditiveGeneticVarianceMatrix':
         """
         Calculate a symmetrical tensor of progeny variances for each possible
@@ -933,15 +819,15 @@
 
         Parameters
         ----------
         gmod : GenomicModel
             Genomic Model with which to estimate genetic variances.
         pgmat : PhasedGenotypeMatrix
             Input genomes to use to estimate genetic variances.
-        ncross : Integral
+        nmating : Integral
             Number of cross patterns to simulate for genetic variance
             estimation.
         nprogeny : Integral
             Number of progeny to simulate per cross to estimate genetic
             variance.
         nself : Integral, Real
             Number of selfing generations post-cross pattern before 'nprogeny'
@@ -970,40 +856,40 @@
         -------
         out : DenseTwoWayDHAdditiveGeneticVarianceMatrix
             A matrix of additive genetic variance estimations.
         """
         # type checks
         check_is_GenomicModel(gmod, "gmod")
         check_is_PhasedGenotypeMatrix(pgmat, "pgmat")
-        check_is_Integral(ncross, "ncross")
+        check_is_Integral(nmating, "nmating")
         check_is_Integral(nprogeny, "nprogeny")
         check_is_Integral_or_inf(nself, "nself")
         check_is_GeneticMapFunction(gmapfn, "gmapfn")
 
         # if genomic model is an additive linear genomic model, then use specialized routine
         if isinstance(gmod, AdditiveLinearGenomicModel):
             return cls.from_algmod(
                 algmod = gmod, 
                 pgmat = pgmat, 
-                ncross = ncross, 
+                nmating = nmating, 
                 nprogeny = nprogeny, 
                 nself = nself, 
                 gmapfn = gmapfn, 
                 **kwargs
             )
         # otherwise raise error since non-linear support hasn't been implemented yet
         else:
             raise NotImplementedError("support for non-linear models not implemented yet")
 
     @classmethod
     def from_algmod(
             cls, 
             algmod: AdditiveLinearGenomicModel, 
             pgmat: PhasedGenotypeMatrix, 
-            ncross: Integral, 
+            nmating: Integral, 
             nprogeny: Integral, 
             nself: Union[Integral,Real], 
             gmapfn: GeneticMapFunction, 
             mem: Union[Integral,None] = 1024
         ) -> 'DenseFourWayDHAdditiveGeneticVarianceMatrix':
         """
         Calculate a symmetrical tensor of progeny variances for each possible
@@ -1012,15 +898,15 @@
 
         Parameters
         ----------
         algmod : AdditiveLinearGenomicModel
             AdditiveLinearGenomicModel with which to estimate genetic variances.
         pgmat : PhasedGenotypeMatrix
             Input genomes to use to estimate genetic variances.
-        ncross : Integral
+        nmating : Integral
             Number of cross patterns to simulate for genetic variance
             estimation.
         nprogeny : Integral
             Number of progeny to simulate per cross to estimate genetic
             variance.
         nself : Integral
             Number of selfing generations post-cross pattern before 'nprogeny'
@@ -1055,15 +941,15 @@
         -------
         out : GeneticVarianceMatrix
             A matrix of additive genetic variance estimations.
         """
         # type checks
         check_is_AdditiveLinearGenomicModel(algmod, "algmod")
         check_is_PhasedGenotypeMatrix(pgmat, "pgmat")
-        check_is_Integral(ncross, "ncross")
+        check_is_Integral(nmating, "nmating")
         check_is_Integral(nprogeny, "nprogeny")
         check_is_Integral_or_inf(nself, "nself")
         check_is_GeneticMapFunction(gmapfn, "gmapfn")
         check_is_Integral_or_None(mem, "mem")
         
         # check for chromosome grouping
         if not pgmat.is_grouped_vrnt():
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/DenseFourWayDHAdditiveGenicVarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/vmat/DenseFourWayDHAdditiveGenicVarianceMatrix.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,33 +2,41 @@
 Module implementing classes and associated error checking routines for matrices
 storing dense additive genic variance estimates calculated using four-way DH
 formulae.
 """
 
 import math
 from numbers import Integral
-from typing import Optional, Union
+from pathlib import Path
+from typing import Optional
+from typing import Union
 import numpy
 import pandas
 import h5py
-from pybrops.core.error.error_io_python import check_file_exists
+
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_str, check_is_str_or_Integral
-from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_str
+from pybrops.core.error.error_type_python import check_is_str_or_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column, check_pandas_DataFrame_has_column_index
-from pybrops.core.util.arrayix import flattenix
-from pybrops.core.util.h5py import save_dict_to_hdf5
-from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel, check_is_AdditiveLinearGenomicModel
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column_index
+from pybrops.core.util.array import flattenix
+from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
 from pybrops.model.vmat.DenseAdditiveGenicVarianceMatrix import DenseAdditiveGenicVarianceMatrix
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
 
-class DenseFourWayDHAdditiveGenicVarianceMatrix(DenseAdditiveGenicVarianceMatrix):
+class DenseFourWayDHAdditiveGenicVarianceMatrix(
+        DenseAdditiveGenicVarianceMatrix,
+    ):
     """
     A concrete class for dense additive genic variance matrices calculated
     for two-way DH progenies.
 
     The purpose of this concrete class is to implement functionality for:
         1) Genic variance estimation for two-way DH progenies.
     """
@@ -362,75 +370,39 @@
             header = header,
             index = index,
             **kwargs
         )
 
     def to_hdf5(
             self, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None,
             overwrite: bool = True,
         ) -> None:
         """
-        Write DenseFourWayDHAdditiveGenicVarianceMatrix to an HDF5 file.
+        Write ``DenseFourWayDHAdditiveGenicVarianceMatrix`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str, h5py.File
+        filename : str, Path, h5py.File
             HDF5 file name or HDF5 file stream to which to write.
 
-        groupname : str or None
-            HDF5 group name under which the ``DenseFourWayDHAdditiveGenicVarianceMatrix`` data is stored.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseFourWayDHAdditiveGenicVarianceMatrix`` data is stored.
             If ``None``, the ``DenseFourWayDHAdditiveGenicVarianceMatrix`` is written to the base HDF5 group.
         
         overwrite : bool
             Whether to overwrite data fields if they are present in the HDF5 file.
         """
-        ### type checks
-        check_is_str(filename, "filename")
-
-        # open HDF5 in write mode
-        h5file = h5py.File(filename, "a")
-
-        ############ process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if groupname is a string, add '/' to end of string if not last character
-        elif isinstance(groupname, str):
-            if groupname[-1] != '/':
-                groupname += '/'
-
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ################ populate HDF5 file ################
-
-        # data dictionary
-        data_dict = {
-            "mat"           : self.mat,
-            "taxa"          : self.taxa,
-            "taxa_grp"      : self.taxa_grp,
-            "trait"         : self.trait,
-            "taxa_grp_name" : self.taxa_grp_name,
-            "taxa_grp_stix" : self.taxa_grp_stix,
-            "taxa_grp_spix" : self.taxa_grp_spix,
-            "taxa_grp_len"  : self.taxa_grp_len,
-        }
-
-        # save data
-        save_dict_to_hdf5(h5file, groupname, data_dict, overwrite)
-
-        ################# write conclusion #################
-
-        # close the file
-        h5file.close()
+        # call super function
+        super(DenseFourWayDHAdditiveGenicVarianceMatrix, self).to_hdf5(
+            filename  = filename,
+            groupname = groupname,
+            overwrite = overwrite,
+        )
     
     ############################## Class Methods ###############################
 
     ###################### Matrix I/O ######################
     @classmethod
     def from_pandas(
             cls, 
@@ -789,129 +761,39 @@
         )
 
         return out
     
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseFourWayDHAdditiveGenicVarianceMatrix':
         """
-        Read DenseFourWayDHAdditiveGenicVarianceMatrix from an HDF5 file.
+        Read ``DenseFourWayDHAdditiveGenicVarianceMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseFourWayDHAdditiveGenicVarianceMatrix data is stored.
-            If None, DenseFourWayDHAdditiveGenicVarianceMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseFourWayDHAdditiveGenicVarianceMatrix`` data is stored.
+            If ``None``, ``DenseFourWayDHAdditiveGenicVarianceMatrix`` is read from base HDF5 group.
 
         Returns
         -------
         out : DenseFourWayDHAdditiveGenicVarianceMatrix
-            A DenseFourWayDHAdditiveGenicVarianceMatrix read from file.
+            A ``DenseFourWayDHAdditiveGenicVarianceMatrix`` read from file.
         """
-        # type checks
-        check_is_str(filename, "filename")
-
-        #################### Open file #####################
-        
-        # check file exists
-        check_file_exists(filename)
-        
-        # open HDF5 in read only
-        h5file = h5py.File(filename, "r")
-        
-        ############ Process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if we have a string, check that group exists, add '/' to end if needed
-        elif isinstance(groupname, str):
-            check_h5py_File_has_group(h5file, filename, groupname)
-            if groupname[-1] != '/':
-                groupname += '/'
-        
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ############ Check for required fields #############
-
-        # list of all required arguments
-        required_fields = ["mat"]
-
-        # for each required field, concatenate base groupname and field and
-        # check that group exists
-        for field in required_fields:
-            fieldname = groupname + field
-            check_h5py_File_has_group(h5file, filename, fieldname)
-        
-        #################### Read data #####################
-
-        # output dictionary
-        data = {
-            "mat"           : None,
-            "taxa"          : None,
-            "taxa_grp"      : None,
-            "trait"         : None,
-            "taxa_grp_name" : None,
-            "taxa_grp_stix" : None,
-            "taxa_grp_spix" : None,
-            "taxa_grp_len"  : None,
-        }
-
-        # for each field, concatenate base groupname and field and
-        # if the field exists in the HDF5 file, then read the array
-        for field in data.keys():
-            fieldname = groupname + field
-            if fieldname in h5file:
-                data[field] = h5file[fieldname][()]
-
-        #################### Close file ####################
-        
-        # close file
-        h5file.close()
-        
-        ############### Datatype conversion ################
-
-        # if taxa names read, convert taxa strings from byte to utf-8
-        if data["taxa"] is not None:
-            data["taxa"] = numpy.array(
-                [s.decode("utf-8") for s in data["taxa"]],
-                dtype = object
-            )
-
-        # if trait names read, convert trait strings from byte to utf-8
-        if data["trait"] is not None:
-            data["trait"] = numpy.array(
-                [s.decode("utf-8") for s in data["trait"]],
-                dtype = object
-            )
-        
-        ################# Object creation ##################
-        # create object from read data
-        out = cls(
-            mat      = data["mat"],
-            taxa     = data["taxa"],
-            taxa_grp = data["taxa_grp"],
-            trait    = data["trait"],
+        # call super function
+        return super(DenseFourWayDHAdditiveGenicVarianceMatrix, cls).from_hdf5(
+            filename  = filename,
+            groupname = groupname,
         )
-        
-        # copy metadata if there is any
-        out.taxa_grp_name = data["taxa_grp_name"]
-        out.taxa_grp_stix = data["taxa_grp_stix"]
-        out.taxa_grp_spix = data["taxa_grp_spix"]
-        out.taxa_grp_len  = data["taxa_grp_len"]
-
-        return out
 
     ############# Matrix Factory Class Methods #############
     # TODO: provide support for non-linear models
     @classmethod
     def from_gmod(
             cls, 
             gmod: GenomicModel,
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/DenseGeneticVarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/vmat/DenseGeneticVarianceMatrix.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,20 +1,26 @@
 """
 Module implementing classes and associated error checking routines for matrices
 storing dense genetic variance estimates.
 """
 
 import copy
+from pathlib import Path
 from typing import Optional
+from typing import Union
 import numpy
+import h5py
 from pybrops.core.error.error_attr_python import error_readonly
 from pybrops.core.mat.DenseSquareTaxaTraitMatrix import DenseSquareTaxaTraitMatrix
 from pybrops.model.vmat.GeneticVarianceMatrix import GeneticVarianceMatrix
 
-class DenseGeneticVarianceMatrix(DenseSquareTaxaTraitMatrix,GeneticVarianceMatrix):
+class DenseGeneticVarianceMatrix(
+        DenseSquareTaxaTraitMatrix,
+        GeneticVarianceMatrix,
+    ):
     """
     A semi-concrete class for dense genetic variance matrices.
 
     The purpose of this semi-concrete class is to provide functionality for:
         1) Object construction of dense genetic variance matrices.
 
     Methods responsible for estimating genetic variances from genomic models
@@ -83,15 +89,15 @@
         ) -> 'DenseGeneticVarianceMatrix':
         """
         Make a shallow copy of the Matrix.
 
         Returns
         -------
         out : DenseGeneticVarianceMatrix
-            A shallow copy of the original DenseGeneticVarianceMatrix.
+            A shallow copy of the original ``DenseGeneticVarianceMatrix``.
         """
         return copy.copy(self)
 
     def deepcopy(
             self, 
             memo: Optional[dict] = None
         ) -> 'DenseGeneticVarianceMatrix':
@@ -102,48 +108,49 @@
         ----------
         memo : dict
             Dictionary of memo metadata.
 
         Returns
         -------
         out : DenseGeneticVarianceMatrix
-            A deep copy of the original DenseGeneticVarianceMatrix.
+            A deep copy of the original ``DenseGeneticVarianceMatrix``.
         """
         return copy.deepcopy(self, memo)
 
     ################### Matrix File I/O ####################
 
     ############################## Class Methods ###############################
 
     ################### Matrix File I/O ####################
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseGeneticVarianceMatrix':
         """
-        Read DenseGeneticVarianceMatrix from an HDF5 file.
+        Read ``DenseGeneticVarianceMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseGeneticVarianceMatrix data is stored.
-            If None, DenseGeneticVarianceMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, HDF5 group name under which ``DenseGeneticVarianceMatrix`` data is stored.
+            If ``None``, ``DenseGeneticVarianceMatrix`` is read from base HDF5 group.
 
         Returns
         -------
         out : DenseGeneticVarianceMatrix
             A dense matrix read from file.
         """
         return super(DenseGeneticVarianceMatrix, cls).from_hdf5(
-            filename, 
-            groupname
+            filename  = filename, 
+            groupname = groupname,
         )
 
     # from_gmod
     # this method should remain abstract; it depends on the cross structure
     # maybe in the future if generic cross structures are implemented,
     # then this method can become concrete
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/DenseGenicVarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/vmat/DenseGenicVarianceMatrix.py`

 * *Files 5% similar despite different names*

```diff
@@ -6,15 +6,18 @@
 import copy
 from typing import Optional
 import numpy
 from pybrops.core.error.error_attr_python import error_readonly
 from pybrops.core.mat.DenseSquareTaxaTraitMatrix import DenseSquareTaxaTraitMatrix
 from pybrops.model.vmat.GenicVarianceMatrix import GenicVarianceMatrix
 
-class DenseGenicVarianceMatrix(DenseSquareTaxaTraitMatrix,GenicVarianceMatrix):
+class DenseGenicVarianceMatrix(
+        DenseSquareTaxaTraitMatrix,
+        GenicVarianceMatrix,
+    ):
     """
     A semi-concrete class for dense genic variance matrices.
 
     The purpose of this semi-concrete class is to provide functionality for:
         1) Object construction of dense genic variance matrices.
 
     Methods responsible for estimating genic variances from genomic models
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/DenseThreeWayDHAdditiveGeneticVarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/vmat/DenseThreeWayDHAdditiveGeneticVarianceMatrix.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,38 +1,50 @@
 """
 Module implementing classes and associated error checking routines for matrices
 storing dense additive genetic variance estimates calculated using three-way DH
 formulae.
 """
 
 import math
-from numbers import Integral, Real
-from typing import Optional, Union
+from numbers import Integral
+from numbers import Real
+from pathlib import Path
+from typing import Optional
+from typing import Union
 import numpy
 import pandas
 import h5py
-from pybrops.core.error.error_io_python import check_file_exists
+
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_Integral_or_None, check_is_Integral_or_inf, check_is_str, check_is_str_or_Integral
-from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_Integral_or_None
+from pybrops.core.error.error_type_python import check_is_Integral_or_inf
+from pybrops.core.error.error_type_python import check_is_str
+from pybrops.core.error.error_type_python import check_is_str_or_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column, check_pandas_DataFrame_has_column_index
-from pybrops.core.util.arrayix import flattenix
-from pybrops.core.util.h5py import save_dict_to_hdf5
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column_index
+from pybrops.core.util.array import flattenix
 from pybrops.core.util.subroutines import srange
-from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel, check_is_AdditiveLinearGenomicModel
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
 from pybrops.model.vmat.util import cov_D1s
 from pybrops.model.vmat.util import cov_D2s
 from pybrops.model.vmat.DenseAdditiveGeneticVarianceMatrix import DenseAdditiveGeneticVarianceMatrix
-from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction, check_is_GeneticMapFunction
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
-
-class DenseThreeWayDHAdditiveGeneticVarianceMatrix(DenseAdditiveGeneticVarianceMatrix):
+from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
+from pybrops.popgen.gmap.GeneticMapFunction import check_is_GeneticMapFunction
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
+
+class DenseThreeWayDHAdditiveGeneticVarianceMatrix(
+        DenseAdditiveGeneticVarianceMatrix,
+    ):
     """
     A concrete class for dense additive genetic variance matrices calculated
     for three-way DH progenies.
 
     The purpose of this concrete class is to implement functionality for:
         1) Genetic variance estimation for three-way DH progenies.
         2) I/O for three-way DH progeny variance matrices.
@@ -330,75 +342,39 @@
             header = header,
             index = index,
             **kwargs
         )
 
     def to_hdf5(
             self, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None,
             overwrite: bool = True,
         ) -> None:
         """
-        Write DenseThreeWayDHAdditiveGeneticVarianceMatrix to an HDF5 file.
+        Write ``DenseThreeWayDHAdditiveGeneticVarianceMatrix`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str, h5py.File
+        filename : str, Path, h5py.File
             HDF5 file name or HDF5 file stream to which to write.
 
-        groupname : str or None
-            HDF5 group name under which the ``DenseThreeWayDHAdditiveGeneticVarianceMatrix`` data is stored.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseThreeWayDHAdditiveGeneticVarianceMatrix`` data is stored.
             If ``None``, the ``DenseThreeWayDHAdditiveGeneticVarianceMatrix`` is written to the base HDF5 group.
         
         overwrite : bool
             Whether to overwrite data fields if they are present in the HDF5 file.
         """
-        ### type checks
-        check_is_str(filename, "filename")
-
-        # open HDF5 in write mode
-        h5file = h5py.File(filename, "a")
-
-        ############ process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if groupname is a string, add '/' to end of string if not last character
-        elif isinstance(groupname, str):
-            if groupname[-1] != '/':
-                groupname += '/'
-
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ################ populate HDF5 file ################
-
-        # data dictionary
-        data_dict = {
-            "mat"           : self.mat,
-            "taxa"          : self.taxa,
-            "taxa_grp"      : self.taxa_grp,
-            "trait"         : self.trait,
-            "taxa_grp_name" : self.taxa_grp_name,
-            "taxa_grp_stix" : self.taxa_grp_stix,
-            "taxa_grp_spix" : self.taxa_grp_spix,
-            "taxa_grp_len"  : self.taxa_grp_len,
-        }
-
-        # save data
-        save_dict_to_hdf5(h5file, groupname, data_dict)
-
-        ################# write conclusion #################
-
-        # close the file
-        h5file.close()
+        # call super function
+        super(DenseThreeWayDHAdditiveGeneticVarianceMatrix, self).to_hdf5(
+            filename  = filename,
+            groupname = groupname,
+            overwrite = overwrite,
+        )
     
     ############################## Class Methods ###############################
 
     ###################### Matrix I/O ######################
     @classmethod
     def from_pandas(
             cls, 
@@ -705,138 +681,48 @@
         )
 
         return out
     
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseThreeWayDHAdditiveGeneticVarianceMatrix':
         """
-        Read DenseThreeWayDHAdditiveGeneticVarianceMatrix from an HDF5 file.
+        Read ``DenseThreeWayDHAdditiveGeneticVarianceMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseThreeWayDHAdditiveGeneticVarianceMatrix data is stored.
-            If None, DenseThreeWayDHAdditiveGeneticVarianceMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseThreeWayDHAdditiveGeneticVarianceMatrix`` data is stored.
+            If ``None``, ``DenseThreeWayDHAdditiveGeneticVarianceMatrix`` is read from base HDF5 group.
 
         Returns
         -------
         out : DenseThreeWayDHAdditiveGeneticVarianceMatrix
-            A DenseThreeWayDHAdditiveGeneticVarianceMatrix read from file.
+            A ``DenseThreeWayDHAdditiveGeneticVarianceMatrix`` read from file.
         """
-        # type checks
-        check_is_str(filename, "filename")
-
-        #################### Open file #####################
-        
-        # check file exists
-        check_file_exists(filename)
-        
-        # open HDF5 in read only
-        h5file = h5py.File(filename, "r")
-        
-        ############ Process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if we have a string, check that group exists, add '/' to end if needed
-        elif isinstance(groupname, str):
-            check_h5py_File_has_group(h5file, filename, groupname)
-            if groupname[-1] != '/':
-                groupname += '/'
-        
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ############ Check for required fields #############
-
-        # list of all required arguments
-        required_fields = ["mat"]
-
-        # for each required field, concatenate base groupname and field and
-        # check that group exists
-        for field in required_fields:
-            fieldname = groupname + field
-            check_h5py_File_has_group(h5file, filename, fieldname)
-        
-        #################### Read data #####################
-
-        # output dictionary
-        data = {
-            "mat"           : None,
-            "taxa"          : None,
-            "taxa_grp"      : None,
-            "trait"         : None,
-            "taxa_grp_name" : None,
-            "taxa_grp_stix" : None,
-            "taxa_grp_spix" : None,
-            "taxa_grp_len"  : None,
-        }
-
-        # for each field, concatenate base groupname and field and
-        # if the field exists in the HDF5 file, then read the array
-        for field in data.keys():
-            fieldname = groupname + field
-            if fieldname in h5file:
-                data[field] = h5file[fieldname][()]
-
-        #################### Close file ####################
-        
-        # close file
-        h5file.close()
-        
-        ############### Datatype conversion ################
-
-        # if taxa names read, convert taxa strings from byte to utf-8
-        if data["taxa"] is not None:
-            data["taxa"] = numpy.array(
-                [s.decode("utf-8") for s in data["taxa"]],
-                dtype = object
-            )
-
-        # if trait names read, convert trait strings from byte to utf-8
-        if data["trait"] is not None:
-            data["trait"] = numpy.array(
-                [s.decode("utf-8") for s in data["trait"]],
-                dtype = object
-            )
-        
-        ################# Object creation ##################
-        # create object from read data
-        out = cls(
-            mat      = data["mat"],
-            taxa     = data["taxa"],
-            taxa_grp = data["taxa_grp"],
-            trait    = data["trait"],
+        # call super function
+        return super(DenseThreeWayDHAdditiveGeneticVarianceMatrix, cls).from_hdf5(
+            filename  = filename,
+            groupname = groupname,
         )
-        
-        # copy metadata if there is any
-        out.taxa_grp_name = data["taxa_grp_name"]
-        out.taxa_grp_stix = data["taxa_grp_stix"]
-        out.taxa_grp_spix = data["taxa_grp_spix"]
-        out.taxa_grp_len  = data["taxa_grp_len"]
-
-        return out
 
     ############# Matrix Factory Class Methods #############
     # TODO: provide support for non-linear models
     @classmethod
     def from_gmod(
             cls, 
             gmod: GenomicModel, 
             pgmat: PhasedGenotypeMatrix, 
-            ncross: Integral, 
+            nmating: Integral, 
             nprogeny: Integral, 
             nself: Union[Integral,Real],
             gmapfn: GeneticMapFunction,
             **kwargs: dict
         ) -> 'DenseThreeWayDHAdditiveGeneticVarianceMatrix':
         """
         Calculate a symmetrical tensor of progeny variances for each possible
@@ -844,15 +730,15 @@
 
         Parameters
         ----------
         gmod : GenomicModel
             Genomic Model with which to estimate genetic variances.
         pgmat : PhasedGenotypeMatrix
             Input genomes to use to estimate genetic variances.
-        ncross : Integral
+        nmating : Integral
             Number of cross patterns to simulate for genetic variance
             estimation.
         nprogeny : Integral
             Number of progeny to simulate per cross to estimate genetic
             variance.
         nself : Integral, Real
             Number of selfing generations post-cross pattern before 'nprogeny'
@@ -881,40 +767,40 @@
         -------
         out : DenseThreeWayDHAdditiveGeneticVarianceMatrix
             A matrix of additive genetic variance estimations.
         """
         # type checks
         check_is_GenomicModel(gmod, "gmod")
         check_is_PhasedGenotypeMatrix(pgmat, "pgmat")
-        check_is_Integral(ncross, "ncross")
+        check_is_Integral(nmating, "nmating")
         check_is_Integral(nprogeny, "nprogeny")
         check_is_Integral_or_inf(nself, "nself")
         check_is_GeneticMapFunction(gmapfn, "gmapfn")
 
         # if genomic model is an additive linear genomic model, then use specialized routine
         if isinstance(gmod, AdditiveLinearGenomicModel):
             return cls.from_algmod(
                 algmod = gmod, 
                 pgmat = pgmat, 
-                ncross = ncross, 
+                nmating = nmating, 
                 nprogeny = nprogeny, 
                 nself = nself, 
                 gmapfn = gmapfn, 
                 **kwargs
             )
         # otherwise raise error since non-linear support hasn't been implemented yet
         else:
             raise NotImplementedError("support for non-linear models not implemented yet")
 
     @classmethod
     def from_algmod(
             cls, 
             algmod: AdditiveLinearGenomicModel, 
             pgmat: PhasedGenotypeMatrix, 
-            ncross: Integral, 
+            nmating: Integral, 
             nprogeny: Integral, 
             nself: Union[Integral,Real], 
             gmapfn: GeneticMapFunction, 
             mem: Union[Integral,None] = 1024
         ) -> 'DenseThreeWayDHAdditiveGeneticVarianceMatrix':
         """
         Calculate a symmetrical tensor of progeny variances for each possible
@@ -923,15 +809,15 @@
 
         Parameters
         ----------
         algmod : AdditiveLinearGenomicModel
             AdditiveLinearGenomicModel with which to estimate genetic variances.
         pgmat : PhasedGenotypeMatrix
             Input genomes to use to estimate genetic variances.
-        ncross : Integral
+        nmating : Integral
             Number of cross patterns to simulate for genetic variance
             estimation.
         nprogeny : Integral
             Number of progeny to simulate per cross to estimate genetic
             variance.
         nself : Integral, Real
             Number of selfing generations post-cross pattern before 'nprogeny'
@@ -966,15 +852,15 @@
         -------
         out : GeneticVarianceMatrix
             A matrix of additive genetic variance estimations.
         """
         # type checks
         check_is_AdditiveLinearGenomicModel(algmod, "algmod")
         check_is_PhasedGenotypeMatrix(pgmat, "pgmat")
-        check_is_Integral(ncross, "ncross")
+        check_is_Integral(nmating, "nmating")
         check_is_Integral(nprogeny, "nprogeny")
         check_is_Integral_or_inf(nself, "nself")
         check_is_GeneticMapFunction(gmapfn, "gmapfn")
         check_is_Integral_or_None(mem, "mem")
         
         # check for chromosome grouping
         if not pgmat.is_grouped_vrnt():
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/DenseThreeWayDHAdditiveGenicVarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/vmat/DenseThreeWayDHAdditiveGenicVarianceMatrix.py`

 * *Files 9% similar despite different names*

```diff
@@ -2,33 +2,41 @@
 Module implementing classes and associated error checking routines for matrices
 storing dense additive genic variance estimates calculated using three-way DH
 formulae.
 """
 
 import math
 from numbers import Integral
-from typing import Optional, Union
+from pathlib import Path
+from typing import Optional
+from typing import Union
 import numpy
 import pandas
 import h5py
-from pybrops.core.error.error_io_python import check_file_exists
+
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_str, check_is_str_or_Integral
-from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_str
+from pybrops.core.error.error_type_python import check_is_str_or_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column, check_pandas_DataFrame_has_column_index
-from pybrops.core.util.arrayix import flattenix
-from pybrops.core.util.h5py import save_dict_to_hdf5
-from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel, check_is_AdditiveLinearGenomicModel
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column_index
+from pybrops.core.util.array import flattenix
+from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
 from pybrops.model.vmat.DenseAdditiveGenicVarianceMatrix import DenseAdditiveGenicVarianceMatrix
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
 
-class DenseThreeWayDHAdditiveGenicVarianceMatrix(DenseAdditiveGenicVarianceMatrix):
+class DenseThreeWayDHAdditiveGenicVarianceMatrix(
+        DenseAdditiveGenicVarianceMatrix,
+    ):
     """
     A concrete class for dense additive genic variance matrices calculated
     for two-way DH progenies.
 
     The purpose of this concrete class is to implement functionality for:
         1) Genic variance estimation for two-way DH progenies.
     """
@@ -325,75 +333,39 @@
             header = header,
             index = index,
             **kwargs
         )
 
     def to_hdf5(
             self, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None,
             overwrite: bool = True,
         ) -> None:
         """
-        Write DenseThreeWayDHAdditiveGenicVarianceMatrix to an HDF5 file.
+        Write ``DenseThreeWayDHAdditiveGenicVarianceMatrix`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str, h5py.File
+        filename : str, Path, h5py.File
             HDF5 file name or HDF5 file stream to which to write.
 
-        groupname : str or None
-            HDF5 group name under which the ``DenseThreeWayDHAdditiveGenicVarianceMatrix`` data is stored.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseThreeWayDHAdditiveGenicVarianceMatrix`` data is stored.
             If ``None``, the ``DenseThreeWayDHAdditiveGenicVarianceMatrix`` is written to the base HDF5 group.
         
         overwrite : bool
             Whether to overwrite data fields if they are present in the HDF5 file.
         """
-        ### type checks
-        check_is_str(filename, "filename")
-
-        # open HDF5 in write mode
-        h5file = h5py.File(filename, "a")
-
-        ############ process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if groupname is a string, add '/' to end of string if not last character
-        elif isinstance(groupname, str):
-            if groupname[-1] != '/':
-                groupname += '/'
-
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ################ populate HDF5 file ################
-
-        # data dictionary
-        data_dict = {
-            "mat"           : self.mat,
-            "taxa"          : self.taxa,
-            "taxa_grp"      : self.taxa_grp,
-            "trait"         : self.trait,
-            "taxa_grp_name" : self.taxa_grp_name,
-            "taxa_grp_stix" : self.taxa_grp_stix,
-            "taxa_grp_spix" : self.taxa_grp_spix,
-            "taxa_grp_len"  : self.taxa_grp_len,
-        }
-
-        # save data
-        save_dict_to_hdf5(h5file, groupname, data_dict)
-
-        ################# write conclusion #################
-
-        # close the file
-        h5file.close()
+        # call super function
+        super(DenseThreeWayDHAdditiveGenicVarianceMatrix, self).to_hdf5(
+            filename  = filename,
+            groupname = groupname,
+            overwrite = overwrite,
+        )
     
     ############################## Class Methods ###############################
 
     ###################### Matrix I/O ######################
     @classmethod
     def from_pandas(
             cls, 
@@ -700,129 +672,39 @@
         )
 
         return out
     
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseThreeWayDHAdditiveGenicVarianceMatrix':
         """
-        Read DenseThreeWayDHAdditiveGenicVarianceMatrix from an HDF5 file.
+        Read ``DenseThreeWayDHAdditiveGenicVarianceMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseThreeWayDHAdditiveGenicVarianceMatrix data is stored.
-            If None, DenseThreeWayDHAdditiveGenicVarianceMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseThreeWayDHAdditiveGenicVarianceMatrix`` data is stored.
+            If ``None``, ``DenseThreeWayDHAdditiveGenicVarianceMatrix`` is read from base HDF5 group.
 
         Returns
         -------
         out : DenseThreeWayDHAdditiveGenicVarianceMatrix
-            A DenseThreeWayDHAdditiveGenicVarianceMatrix read from file.
+            A ``DenseThreeWayDHAdditiveGenicVarianceMatrix`` read from file.
         """
-        # type checks
-        check_is_str(filename, "filename")
-
-        #################### Open file #####################
-        
-        # check file exists
-        check_file_exists(filename)
-        
-        # open HDF5 in read only
-        h5file = h5py.File(filename, "r")
-        
-        ############ Process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if we have a string, check that group exists, add '/' to end if needed
-        elif isinstance(groupname, str):
-            check_h5py_File_has_group(h5file, filename, groupname)
-            if groupname[-1] != '/':
-                groupname += '/'
-        
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ############ Check for required fields #############
-
-        # list of all required arguments
-        required_fields = ["mat"]
-
-        # for each required field, concatenate base groupname and field and
-        # check that group exists
-        for field in required_fields:
-            fieldname = groupname + field
-            check_h5py_File_has_group(h5file, filename, fieldname)
-        
-        #################### Read data #####################
-
-        # output dictionary
-        data = {
-            "mat"           : None,
-            "taxa"          : None,
-            "taxa_grp"      : None,
-            "trait"         : None,
-            "taxa_grp_name" : None,
-            "taxa_grp_stix" : None,
-            "taxa_grp_spix" : None,
-            "taxa_grp_len"  : None,
-        }
-
-        # for each field, concatenate base groupname and field and
-        # if the field exists in the HDF5 file, then read the array
-        for field in data.keys():
-            fieldname = groupname + field
-            if fieldname in h5file:
-                data[field] = h5file[fieldname][()]
-
-        #################### Close file ####################
-        
-        # close file
-        h5file.close()
-        
-        ############### Datatype conversion ################
-
-        # if taxa names read, convert taxa strings from byte to utf-8
-        if data["taxa"] is not None:
-            data["taxa"] = numpy.array(
-                [s.decode("utf-8") for s in data["taxa"]],
-                dtype = object
-            )
-
-        # if trait names read, convert trait strings from byte to utf-8
-        if data["trait"] is not None:
-            data["trait"] = numpy.array(
-                [s.decode("utf-8") for s in data["trait"]],
-                dtype = object
-            )
-        
-        ################# Object creation ##################
-        # create object from read data
-        out = cls(
-            mat      = data["mat"],
-            taxa     = data["taxa"],
-            taxa_grp = data["taxa_grp"],
-            trait    = data["trait"],
+        # call super function
+        return super(DenseThreeWayDHAdditiveGenicVarianceMatrix, cls).from_hdf5(
+            filename  = filename,
+            groupname = groupname,
         )
-        
-        # copy metadata if there is any
-        out.taxa_grp_name = data["taxa_grp_name"]
-        out.taxa_grp_stix = data["taxa_grp_stix"]
-        out.taxa_grp_spix = data["taxa_grp_spix"]
-        out.taxa_grp_len  = data["taxa_grp_len"]
-
-        return out
 
     ############# Matrix Factory Class Methods #############
     # TODO: provide support for non-linear models
     @classmethod
     def from_gmod(
             cls, 
             gmod: GenomicModel,
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/DenseTwoWayDHAdditiveGenicVarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/vmat/DenseTwoWayDHAdditiveGenicVarianceMatrix.py`

 * *Files 18% similar despite different names*

```diff
@@ -2,33 +2,41 @@
 Module implementing classes and associated error checking routines for matrices
 storing dense additive genic variance estimates calculated using three-way DH
 formulae.
 """
 
 import math
 from numbers import Integral
-from typing import Optional, Union
+from pathlib import Path
+from typing import Optional
+from typing import Union
 import numpy
 import pandas
 import h5py
-from pybrops.core.error.error_io_python import check_file_exists
+
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_str, check_is_str_or_Integral
-from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_str
+from pybrops.core.error.error_type_python import check_is_str_or_Integral
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
-from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column, check_pandas_DataFrame_has_column_index
-from pybrops.core.util.arrayix import flattenix
-from pybrops.core.util.h5py import save_dict_to_hdf5
-from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel, check_is_AdditiveLinearGenomicModel
-from pybrops.model.gmod.GenomicModel import GenomicModel, check_is_GenomicModel
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column
+from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column_index
+from pybrops.core.util.array import flattenix
+from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
+from pybrops.model.gmod.AdditiveLinearGenomicModel import check_is_AdditiveLinearGenomicModel
+from pybrops.model.gmod.GenomicModel import GenomicModel
+from pybrops.model.gmod.GenomicModel import check_is_GenomicModel
 from pybrops.model.vmat.DenseAdditiveGenicVarianceMatrix import DenseAdditiveGenicVarianceMatrix
-from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix, check_is_PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
+from pybrops.popgen.gmat.PhasedGenotypeMatrix import check_is_PhasedGenotypeMatrix
 
-class DenseTwoWayDHAdditiveGenicVarianceMatrix(DenseAdditiveGenicVarianceMatrix):
+class DenseTwoWayDHAdditiveGenicVarianceMatrix(
+        DenseAdditiveGenicVarianceMatrix,
+    ):
     """
     A concrete class for dense additive genic variance matrices calculated
     for two-way DH progenies.
 
     The purpose of this concrete class is to implement functionality for:
         1) Genic variance estimation for two-way DH progenies.
     """
@@ -283,75 +291,39 @@
             header = header,
             index = index,
             **kwargs
         )
 
     def to_hdf5(
             self, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None,
             overwrite: bool = True,
         ) -> None:
         """
         Write DenseTwoWayDHAdditiveGenicVarianceMatrix to an HDF5 file.
 
         Parameters
         ----------
-        filename : str, h5py.File
+        filename : str, Path, h5py.File
             HDF5 file name or HDF5 file stream to which to write.
 
-        groupname : str or None
-            HDF5 group name under which the ``DenseTwoWayDHAdditiveGenicVarianceMatrix`` data is stored.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseTwoWayDHAdditiveGenicVarianceMatrix`` data is stored.
             If ``None``, the ``DenseTwoWayDHAdditiveGenicVarianceMatrix`` is written to the base HDF5 group.
         
         overwrite : bool
             Whether to overwrite data fields if they are present in the HDF5 file.
         """
-        ### type checks
-        check_is_str(filename, "filename")
-
-        # open HDF5 in write mode
-        h5file = h5py.File(filename, "a")
-
-        ############ process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if groupname is a string, add '/' to end of string if not last character
-        elif isinstance(groupname, str):
-            if groupname[-1] != '/':
-                groupname += '/'
-
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ################ populate HDF5 file ################
-
-        # data dictionary
-        data_dict = {
-            "mat"           : self.mat,
-            "taxa"          : self.taxa,
-            "taxa_grp"      : self.taxa_grp,
-            "trait"         : self.trait,
-            "taxa_grp_name" : self.taxa_grp_name,
-            "taxa_grp_stix" : self.taxa_grp_stix,
-            "taxa_grp_spix" : self.taxa_grp_spix,
-            "taxa_grp_len"  : self.taxa_grp_len,
-        }
-
-        # save data
-        save_dict_to_hdf5(h5file, groupname, data_dict)
-
-        ################# write conclusion #################
-
-        # close the file
-        h5file.close()
+        # call super function
+        super(DenseTwoWayDHAdditiveGenicVarianceMatrix, self).to_hdf5(
+            filename  = filename,
+            groupname = groupname,
+            overwrite = overwrite,
+        )
     
     ############################## Class Methods ###############################
 
     ###################### Matrix I/O ######################
     @classmethod
     def from_pandas(
             cls, 
@@ -603,129 +575,39 @@
         )
 
         return out
     
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseTwoWayDHAdditiveGenicVarianceMatrix':
         """
         Read DenseTwoWayDHAdditiveGenicVarianceMatrix from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseTwoWayDHAdditiveGenicVarianceMatrix data is stored.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which DenseTwoWayDHAdditiveGenicVarianceMatrix data is stored.
             If None, DenseTwoWayDHAdditiveGenicVarianceMatrix is read from base HDF5 group.
 
         Returns
         -------
         out : DenseTwoWayDHAdditiveGenicVarianceMatrix
             A DenseTwoWayDHAdditiveGenicVarianceMatrix read from file.
         """
-        # type checks
-        check_is_str(filename, "filename")
-
-        #################### Open file #####################
-        
-        # check file exists
-        check_file_exists(filename)
-        
-        # open HDF5 in read only
-        h5file = h5py.File(filename, "r")
-        
-        ############ Process groupname argument ############
-
-        # if groupname is None, set groupname to empty string
-        if groupname is None:
-            groupname = ""
-        
-        # if we have a string, check that group exists, add '/' to end if needed
-        elif isinstance(groupname, str):
-            check_h5py_File_has_group(h5file, filename, groupname)
-            if groupname[-1] != '/':
-                groupname += '/'
-        
-        # else raise error
-        else:
-            check_is_str(groupname, "groupname")
-        
-        ############ Check for required fields #############
-
-        # list of all required arguments
-        required_fields = ["mat"]
-
-        # for each required field, concatenate base groupname and field and
-        # check that group exists
-        for field in required_fields:
-            fieldname = groupname + field
-            check_h5py_File_has_group(h5file, filename, fieldname)
-        
-        #################### Read data #####################
-
-        # output dictionary
-        data = {
-            "mat"           : None,
-            "taxa"          : None,
-            "taxa_grp"      : None,
-            "trait"         : None,
-            "taxa_grp_name" : None,
-            "taxa_grp_stix" : None,
-            "taxa_grp_spix" : None,
-            "taxa_grp_len"  : None,
-        }
-
-        # for each field, concatenate base groupname and field and
-        # if the field exists in the HDF5 file, then read the array
-        for field in data.keys():
-            fieldname = groupname + field
-            if fieldname in h5file:
-                data[field] = h5file[fieldname][()]
-
-        #################### Close file ####################
-        
-        # close file
-        h5file.close()
-        
-        ############### Datatype conversion ################
-
-        # if taxa names read, convert taxa strings from byte to utf-8
-        if data["taxa"] is not None:
-            data["taxa"] = numpy.array(
-                [s.decode("utf-8") for s in data["taxa"]],
-                dtype = object
-            )
-
-        # if trait names read, convert trait strings from byte to utf-8
-        if data["trait"] is not None:
-            data["trait"] = numpy.array(
-                [s.decode("utf-8") for s in data["trait"]],
-                dtype = object
-            )
-        
-        ################# Object creation ##################
-        # create object from read data
-        out = cls(
-            mat      = data["mat"],
-            taxa     = data["taxa"],
-            taxa_grp = data["taxa_grp"],
-            trait    = data["trait"],
+        # call super function
+        return super(DenseTwoWayDHAdditiveGenicVarianceMatrix, cls).from_hdf5(
+            filename  = filename,
+            groupname = groupname,
         )
-        
-        # copy metadata if there is any
-        out.taxa_grp_name = data["taxa_grp_name"]
-        out.taxa_grp_stix = data["taxa_grp_stix"]
-        out.taxa_grp_spix = data["taxa_grp_spix"]
-        out.taxa_grp_len  = data["taxa_grp_len"]
-
-        return out
 
     ############# Matrix Factory Class Methods #############
     # TODO: provide support for non-linear models
     @classmethod
     def from_gmod(
             cls, 
             gmod: GenomicModel,
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/GeneticVarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/vmat/GeneticVarianceMatrix.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,14 @@
 """
 Module defining interfaces and associated error checking routines for matrices
 storing genetic variance estimates.
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.core.io.CSVInputOutput import CSVInputOutput
 from pybrops.core.io.PandasInputOutput import PandasInputOutput
 from pybrops.core.mat.SquareTaxaMatrix import SquareTaxaMatrix
 from pybrops.core.mat.TraitMatrix import TraitMatrix
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
@@ -47,30 +48,30 @@
     ############################## Class Methods ###############################
     @classmethod
     @abstractmethod
     def from_gmod(
             cls, 
             gmod: GenomicModel, 
             pgmat: PhasedGenotypeMatrix, 
-            ncross: int, 
+            nmating: int, 
             nprogeny: int, 
             nself: int, 
             gmapfn: GeneticMapFunction, 
             **kwargs: dict
         ) -> 'GeneticVarianceMatrix':
         """
         Estimate genetic variances from a GenomicModel.
 
         Parameters
         ----------
         gmod : GenomicModel
             GenomicModel with which to estimate genetic variances.
         pgmat : PhasedGenotypeMatrix
             Input genomes to use to estimate genetic variances.
-        ncross : int
+        nmating : int
             Number of cross patterns to simulate for genetic variance
             estimation.
         nprogeny : int
             Number of progeny to simulate per cross to estimate genetic
             variance.
         nself : int
             Number of selfing generations post-cross pattern before 'nprogeny'
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/GenicVarianceMatrix.py` & `pybrops-1.0.3/pybrops/model/vmat/GenicVarianceMatrix.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,15 +4,16 @@
 """
 
 __all__ = [
     "GenicVarianceMatrix",
     "check_is_GenicVarianceMatrix",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.core.io.CSVInputOutput import CSVInputOutput
 from pybrops.core.io.PandasInputOutput import PandasInputOutput
 from pybrops.core.mat.SquareTaxaMatrix import SquareTaxaMatrix
 from pybrops.core.mat.TraitMatrix import TraitMatrix
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/__init__.py` & `pybrops-1.0.3/pybrops/model/vmat/__init__.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/model/vmat/fcty/AdditiveGeneticVarianceMatrixFactory.py` & `pybrops-1.0.3/pybrops/model/vmat/fcty/AdditiveGeneticVarianceMatrixFactory.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,20 @@
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 from pybrops.model.vmat.AdditiveGeneticVarianceMatrix import AdditiveGeneticVarianceMatrix
 from pybrops.model.vmat.fcty.GeneticVarianceMatrixFactory import GeneticVarianceMatrixFactory
 from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class AdditiveGeneticVarianceMatrixFactory(GeneticVarianceMatrixFactory,metaclass=ABCMeta):
+class AdditiveGeneticVarianceMatrixFactory(
+        GeneticVarianceMatrixFactory,
+        metaclass = ABCMeta,
+    ):
     """
     Abstract factory class for producing AdditiveGeneticVarianceMatrix objects.
     """
 
     ########################## Special Object Methods ##########################
 
     ############################## Object Methods ##############################
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/fcty/AdditiveGenicVarianceMatrixFactory.py` & `pybrops-1.0.3/pybrops/model/vmat/fcty/AdditiveGenicVarianceMatrixFactory.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,15 +1,19 @@
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 from pybrops.model.vmat.AdditiveGenicVarianceMatrix import AdditiveGenicVarianceMatrix
 from pybrops.model.vmat.fcty.GenicVarianceMatrixFactory import GenicVarianceMatrixFactory
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class AdditiveGenicVarianceMatrixFactory(GenicVarianceMatrixFactory,metaclass=ABCMeta):
+class AdditiveGenicVarianceMatrixFactory(
+        GenicVarianceMatrixFactory,
+        metaclass = ABCMeta,
+    ):
     """
     Abstract factory class for producing AdditiveGenicVarianceMatrix objects.
     """
 
     ########################## Special Object Methods ##########################
 
     ############################## Object Methods ##############################
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/fcty/DenseDihybridDHAdditiveGeneticVarianceMatrixFactory.py` & `pybrops-1.0.3/pybrops/model/vmat/fcty/DenseDihybridDHAdditiveGeneticVarianceMatrixFactory.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,17 @@
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.model.vmat.fcty.AdditiveGeneticVarianceMatrixFactory import AdditiveGeneticVarianceMatrixFactory
 from pybrops.model.vmat.DenseDihybridDHAdditiveGeneticVarianceMatrix import DenseDihybridDHAdditiveGeneticVarianceMatrix
 from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class DenseDihybridDHAdditiveGeneticVarianceMatrixFactory(AdditiveGeneticVarianceMatrixFactory):
+class DenseDihybridDHAdditiveGeneticVarianceMatrixFactory(
+        AdditiveGeneticVarianceMatrixFactory,
+    ):
     """
     docstring for DenseDihybridDHAdditiveGeneticVarianceMatrixFactory.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -64,15 +66,15 @@
         -------
         out : DenseDihybridDHAdditiveGeneticVarianceMatrix
             A matrix of genetic variance estimations.
         """
         return DenseDihybridDHAdditiveGeneticVarianceMatrix.from_gmod(
             gmod = gmod, 
             pgmat = pgmat, 
-            ncross = ncross, 
+            nmating = ncross, 
             nprogeny = nprogeny, 
             nself = nself, 
             gmapfn = gmapfn, 
             **kwargs
         )
 
     def from_algmod(
@@ -116,15 +118,15 @@
         -------
         out : DenseDihybridDHAdditiveGeneticVarianceMatrix
             A matrix of additive genetic variance estimations.
         """
         return DenseDihybridDHAdditiveGeneticVarianceMatrix.from_algmod(
             algmod = algmod, 
             pgmat = pgmat, 
-            ncross = ncross, 
+            nmating = ncross, 
             nprogeny = nprogeny, 
             nself = nself, 
             gmapfn = gmapfn, 
             mem = mem, 
             **kwargs
         )
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/fcty/DenseFourWayDHAdditiveGeneticVarianceMatrixFactory.py` & `pybrops-1.0.3/pybrops/model/vmat/fcty/DenseFourWayDHAdditiveGeneticVarianceMatrixFactory.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,17 @@
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.model.vmat.fcty.AdditiveGeneticVarianceMatrixFactory import AdditiveGeneticVarianceMatrixFactory
 from pybrops.model.vmat.DenseFourWayDHAdditiveGeneticVarianceMatrix import DenseFourWayDHAdditiveGeneticVarianceMatrix
 from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class DenseFourWayDHAdditiveGeneticVarianceMatrixFactory(AdditiveGeneticVarianceMatrixFactory):
+class DenseFourWayDHAdditiveGeneticVarianceMatrixFactory(
+        AdditiveGeneticVarianceMatrixFactory,
+    ):
     """
     docstring for DenseFourWayDHAdditiveGeneticVarianceMatrixFactory.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -64,15 +66,15 @@
         -------
         out : DenseFourWayDHAdditiveGeneticVarianceMatrix
             A matrix of genetic variance estimations.
         """
         return DenseFourWayDHAdditiveGeneticVarianceMatrix.from_gmod(
             gmod = gmod, 
             pgmat = pgmat, 
-            ncross = ncross, 
+            nmating = ncross, 
             nprogeny = nprogeny, 
             nself = nself, 
             gmapfn = gmapfn, 
             **kwargs
         )
 
     def from_algmod(
@@ -116,15 +118,15 @@
         -------
         out : DenseFourWayDHAdditiveGeneticVarianceMatrix
             A matrix of additive genetic variance estimations.
         """
         return DenseFourWayDHAdditiveGeneticVarianceMatrix.from_algmod(
             algmod = algmod, 
             pgmat = pgmat, 
-            ncross = ncross, 
+            nmating = ncross, 
             nprogeny = nprogeny, 
             nself = nself, 
             gmapfn = gmapfn, 
             mem = mem, 
             **kwargs
         )
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/fcty/DenseThreeWayDHAdditiveGeneticVarianceMatrixFactory.py` & `pybrops-1.0.3/pybrops/model/vmat/fcty/DenseThreeWayDHAdditiveGeneticVarianceMatrixFactory.py`

 * *Files 2% similar despite different names*

```diff
@@ -2,15 +2,17 @@
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.model.vmat.fcty.AdditiveGeneticVarianceMatrixFactory import AdditiveGeneticVarianceMatrixFactory
 from pybrops.model.vmat.DenseThreeWayDHAdditiveGeneticVarianceMatrix import DenseThreeWayDHAdditiveGeneticVarianceMatrix
 from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class DenseThreeWayDHAdditiveGeneticVarianceMatrixFactory(AdditiveGeneticVarianceMatrixFactory):
+class DenseThreeWayDHAdditiveGeneticVarianceMatrixFactory(
+        AdditiveGeneticVarianceMatrixFactory,
+    ):
     """
     docstring for DenseThreeWayDHAdditiveGeneticVarianceMatrixFactory.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -64,15 +66,15 @@
         -------
         out : DenseThreeWayDHAdditiveGeneticVarianceMatrix
             A matrix of genetic variance estimations.
         """
         return DenseThreeWayDHAdditiveGeneticVarianceMatrix.from_gmod(
             gmod = gmod, 
             pgmat = pgmat, 
-            ncross = ncross, 
+            nmating = ncross, 
             nprogeny = nprogeny, 
             nself = nself, 
             gmapfn = gmapfn, 
             **kwargs
         )
 
     def from_algmod(
@@ -116,15 +118,15 @@
         -------
         out : DenseThreeWayDHAdditiveGeneticVarianceMatrix
             A matrix of additive genetic variance estimations.
         """
         return DenseThreeWayDHAdditiveGeneticVarianceMatrix.from_algmod(
             algmod = algmod, 
             pgmat = pgmat, 
-            ncross = ncross, 
+            nmating = ncross, 
             nprogeny = nprogeny, 
             nself = nself, 
             gmapfn = gmapfn, 
             mem = mem, 
             **kwargs
         )
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/fcty/DenseTwoWayDHAdditiveGeneticVarianceMatrixFactory.py` & `pybrops-1.0.3/pybrops/model/vmat/fcty/DenseTwoWayDHAdditiveGeneticVarianceMatrixFactory.py`

 * *Files 3% similar despite different names*

```diff
@@ -2,15 +2,17 @@
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.model.vmat.fcty.AdditiveGeneticVarianceMatrixFactory import AdditiveGeneticVarianceMatrixFactory
 from pybrops.model.vmat.DenseTwoWayDHAdditiveGeneticVarianceMatrix import DenseTwoWayDHAdditiveGeneticVarianceMatrix
 from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class DenseTwoWayDHAdditiveGeneticVarianceMatrixFactory(AdditiveGeneticVarianceMatrixFactory):
+class DenseTwoWayDHAdditiveGeneticVarianceMatrixFactory(
+        AdditiveGeneticVarianceMatrixFactory,
+    ):
     """
     docstring for DenseTwoWayDHAdditiveGeneticVarianceMatrixFactory.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self, 
@@ -64,15 +66,15 @@
         -------
         out : DenseTwoWayDHAdditiveGeneticVarianceMatrix
             A matrix of genetic variance estimations.
         """
         return DenseTwoWayDHAdditiveGeneticVarianceMatrix.from_gmod(
             gmod = gmod, 
             pgmat = pgmat, 
-            ncross = ncross, 
+            nmating = ncross, 
             nprogeny = nprogeny, 
             nself = nself, 
             gmapfn = gmapfn, 
             **kwargs
         )
 
     def from_algmod(
@@ -116,15 +118,15 @@
         -------
         out : DenseTwoWayDHAdditiveGeneticVarianceMatrix
             A matrix of additive genetic variance estimations.
         """
         return DenseTwoWayDHAdditiveGeneticVarianceMatrix.from_algmod(
             algmod = algmod, 
             pgmat = pgmat, 
-            ncross = ncross, 
+            nmating = ncross, 
             nprogeny = nprogeny, 
             nself = nself, 
             gmapfn = gmapfn, 
             mem = mem, 
             **kwargs
         )
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/fcty/DenseTwoWayDHAdditiveGenicVarianceMatrixFactory.py` & `pybrops-1.0.3/pybrops/model/vmat/fcty/DenseTwoWayDHAdditiveGenicVarianceMatrixFactory.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,17 @@
 from pybrops.model.gmod.AdditiveLinearGenomicModel import AdditiveLinearGenomicModel
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.model.vmat.DenseTwoWayDHAdditiveGenicVarianceMatrix import DenseTwoWayDHAdditiveGenicVarianceMatrix
 from pybrops.model.vmat.fcty.AdditiveGenicVarianceMatrixFactory import AdditiveGenicVarianceMatrixFactory
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class DenseTwoWayDHAdditiveGenicVarianceMatrixFactory(AdditiveGenicVarianceMatrixFactory):
+class DenseTwoWayDHAdditiveGenicVarianceMatrixFactory(
+        AdditiveGenicVarianceMatrixFactory,
+    ):
     """
     docstring for DenseTwoWayDHAdditiveGenicVarianceMatrixFactory.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/fcty/GeneticVarianceMatrixFactory.py` & `pybrops-1.0.3/pybrops/model/vmat/fcty/GeneticVarianceMatrixFactory.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,21 +1,24 @@
 """
 Module defining a genetic variance matrix factory interface and associated error 
 checking routines.
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from numbers import Integral
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.model.vmat.GeneticVarianceMatrix import GeneticVarianceMatrix
 from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class GeneticVarianceMatrixFactory(metaclass=ABCMeta):
+class GeneticVarianceMatrixFactory(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class for GeneticVarianceMatrix factory classes.
 
     The purpose of this abstract interface is to provide functionality for:
         1) Construction of genetic variance matrices.
     """
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/fcty/GenicVarianceMatrixFactory.py` & `pybrops-1.0.3/pybrops/model/vmat/fcty/GenicVarianceMatrixFactory.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,17 @@
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.model.gmod.GenomicModel import GenomicModel
 from pybrops.model.vmat.GenicVarianceMatrix import GenicVarianceMatrix
 from pybrops.popgen.gmat.PhasedGenotypeMatrix import PhasedGenotypeMatrix
 
 
-class GenicVarianceMatrixFactory(metaclass=ABCMeta):
+class GenicVarianceMatrixFactory(
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class for GenicVarianceMatrix factory classes.
 
     The purpose of this abstract interface is to provide functionality for:
         1) Construction of genetic variance matrices.
     """
```

### Comparing `pybrops-1.0.2/pybrops/model/vmat/fcty/__init__.py` & `pybrops-1.0.3/pybrops/model/vmat/fcty/__init__.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/model/vmat/util.py` & `pybrops-1.0.3/pybrops/model/vmat/util.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/opt/algo/BinaryGeneticAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/BinaryGeneticAlgorithm.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,33 +6,40 @@
 # all public classes and functions available in this module
 __all__ = [
     "BinaryGeneticAlgorithm",
 ]
 
 # imports
 from numbers import Integral
-from numpy.random import Generator,RandomState
-from typing import Optional, Union
+from numpy.random import Generator
+from numpy.random import RandomState
+from typing import Optional
+from typing import Union
 import numpy
 from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_dict
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.core.random.prng import global_prng
 from pybrops.opt.algo.BinaryOptimizationAlgorithm import BinaryOptimizationAlgorithm
-from pybrops.opt.prob.BinaryProblem import BinaryProblem, check_BinaryProblem_is_single_objective, check_is_BinaryProblem
+from pybrops.opt.prob.BinaryProblem import BinaryProblem
+from pybrops.opt.prob.BinaryProblem import check_BinaryProblem_is_single_objective
+from pybrops.opt.prob.BinaryProblem import check_is_BinaryProblem
 from pybrops.opt.soln.BinarySolution import BinarySolution
 from pybrops.opt.soln.BinarySolution import BinarySolution
 from pymoo.algorithms.soo.nonconvex.ga import GA
 from pymoo.operators.crossover.pntx import SinglePointCrossover
 from pymoo.operators.mutation.bitflip import BitflipMutation
 from pymoo.operators.sampling.rnd import BinaryRandomSampling
 from pymoo.optimize import minimize
 from pymoo.termination.max_gen import MaximumGenerationTermination
 
-class BinaryGeneticAlgorithm(BinaryOptimizationAlgorithm):
+class BinaryGeneticAlgorithm(
+        BinaryOptimizationAlgorithm,
+    ):
     """
     Class implementing an NSGA-II genetic algorithm adapted for subset selection
     optimization. The search space is discrete and nominal in nature.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/BinaryOptimizationAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/BinaryOptimizationAlgorithm.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,21 +3,25 @@
 """
 
 __all__ = [
     "BinaryOptimizationAlgorithm",
     "check_is_BinaryOptimizationAlgorithm",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from typing import Optional
 from pybrops.opt.algo.OptimizationAlgorithm import OptimizationAlgorithm
 from pybrops.opt.prob.BinaryProblem import BinaryProblem
 from pybrops.opt.soln.BinarySolution import BinarySolution
 
-class BinaryOptimizationAlgorithm(OptimizationAlgorithm,metaclass=ABCMeta):
+class BinaryOptimizationAlgorithm(
+        OptimizationAlgorithm,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for optimization algorithms optimizing in binary search spaces.
 
     The purpose of this abstract class is to provide functionality for:
         1) Optimization of objective functions in binary search spaces.
     """
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/IntegerGeneticAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/IntegerGeneticAlgorithm.py`

 * *Files 3% similar despite different names*

```diff
@@ -6,32 +6,41 @@
 # all public classes and functions available in this module
 __all__ = [
     "IntegerGeneticAlgorithm",
 ]
 
 # imports
 from numbers import Integral
-from numpy.random import Generator,RandomState
-from typing import Optional, Union
+from numpy.random import Generator
+from numpy.random import RandomState
+from typing import Optional
+from typing import Union
 import numpy
+from pymoo.algorithms.soo.nonconvex.ga import GA
+from pymoo.operators.sampling.rnd import IntegerRandomSampling
+from pymoo.optimize import minimize
+from pymoo.termination.max_gen import MaximumGenerationTermination
+
 from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_dict
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.core.random.prng import global_prng
 from pybrops.opt.algo.IntegerOptimizationAlgorithm import IntegerOptimizationAlgorithm
-from pybrops.opt.algo.pymoo_addon import IntegerPolynomialMutation, IntegerSimulatedBinaryCrossover
-from pybrops.opt.prob.IntegerProblem import IntegerProblem, check_IntegerProblem_is_single_objective, check_is_IntegerProblem
+from pybrops.opt.algo.pymoo_addon import IntegerPolynomialMutation
+from pybrops.opt.algo.pymoo_addon import IntegerSimulatedBinaryCrossover
+from pybrops.opt.prob.IntegerProblem import IntegerProblem
+from pybrops.opt.prob.IntegerProblem import check_IntegerProblem_is_single_objective
+from pybrops.opt.prob.IntegerProblem import check_is_IntegerProblem
 from pybrops.opt.soln.IntegerSolution import IntegerSolution
 from pybrops.opt.soln.IntegerSolution import IntegerSolution
-from pymoo.algorithms.soo.nonconvex.ga import GA
-from pymoo.operators.sampling.rnd import IntegerRandomSampling
-from pymoo.optimize import minimize
-from pymoo.termination.max_gen import MaximumGenerationTermination
 
-class IntegerGeneticAlgorithm(IntegerOptimizationAlgorithm):
+class IntegerGeneticAlgorithm(
+        IntegerOptimizationAlgorithm,
+    ):
     """
     Class implementing an NSGA-II genetic algorithm adapted for subset selection
     optimization. The search space is discrete and nominal in nature.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/IntegerOptimizationAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/IntegerOptimizationAlgorithm.py`

 * *Files 11% similar despite different names*

```diff
@@ -3,21 +3,25 @@
 """
 
 __all__ = [
     "IntegerOptimizationAlgorithm",
     "check_is_IntegerOptimizationAlgorithm",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from typing import Optional
 from pybrops.opt.algo.OptimizationAlgorithm import OptimizationAlgorithm
 from pybrops.opt.prob.IntegerProblem import IntegerProblem
 from pybrops.opt.soln.IntegerSolution import IntegerSolution
 
-class IntegerOptimizationAlgorithm(OptimizationAlgorithm,metaclass=ABCMeta):
+class IntegerOptimizationAlgorithm(
+        OptimizationAlgorithm,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for optimization algorithms optimizing in integer search spaces.
 
     The purpose of this abstract class is to provide functionality for:
         1) Optimization of objective functions in integer search spaces.
     """
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/NSGA2BinaryGeneticAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/NSGA2BinaryGeneticAlgorithm.py`

 * *Files 3% similar despite different names*

```diff
@@ -6,33 +6,40 @@
 # all public classes and functions available in this module
 __all__ = [
     "NSGA2BinaryGeneticAlgorithm",
 ]
 
 # imports
 from numbers import Integral
-from numpy.random import Generator,RandomState
-from typing import Optional, Union
+from numpy.random import Generator
+from numpy.random import RandomState
+from typing import Optional
+from typing import Union
 import numpy
 from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_dict
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.core.random.prng import global_prng
 from pybrops.opt.algo.BinaryOptimizationAlgorithm import BinaryOptimizationAlgorithm
-from pybrops.opt.prob.BinaryProblem import BinaryProblem, check_BinaryProblem_is_multi_objective, check_is_BinaryProblem
+from pybrops.opt.prob.BinaryProblem import BinaryProblem
+from pybrops.opt.prob.BinaryProblem import check_BinaryProblem_is_multi_objective
+from pybrops.opt.prob.BinaryProblem import check_is_BinaryProblem
 from pybrops.opt.soln.BinarySolution import BinarySolution
 from pybrops.opt.soln.BinarySolution import BinarySolution
 from pymoo.algorithms.moo.nsga2 import NSGA2
 from pymoo.optimize import minimize
 from pymoo.termination.max_gen import MaximumGenerationTermination
 from pymoo.operators.crossover.pntx import SinglePointCrossover
 from pymoo.operators.mutation.bitflip import BitflipMutation
 from pymoo.operators.sampling.rnd import BinaryRandomSampling
 
-class NSGA2BinaryGeneticAlgorithm(BinaryOptimizationAlgorithm):
+class NSGA2BinaryGeneticAlgorithm(
+        BinaryOptimizationAlgorithm,
+    ):
     """
     Class implementing an NSGA-II genetic algorithm adapted for subset selection
     optimization. The search space is discrete and nominal in nature.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/NSGA2IntegerGeneticAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/NSGA2IntegerGeneticAlgorithm.py`

 * *Files 3% similar despite different names*

```diff
@@ -6,32 +6,40 @@
 # all public classes and functions available in this module
 __all__ = [
     "NSGA2IntegerGeneticAlgorithm",
 ]
 
 # imports
 from numbers import Integral
-from numpy.random import Generator,RandomState
-from typing import Optional, Union
+from numpy.random import Generator
+from numpy.random import RandomState
+from typing import Optional
+from typing import Union
 import numpy
 from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_dict
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.core.random.prng import global_prng
 from pybrops.opt.algo.IntegerOptimizationAlgorithm import IntegerOptimizationAlgorithm
-from pybrops.opt.algo.pymoo_addon import IntegerPolynomialMutation, IntegerSimulatedBinaryCrossover
-from pybrops.opt.prob.IntegerProblem import IntegerProblem, check_IntegerProblem_is_multi_objective, check_is_IntegerProblem
+from pybrops.opt.algo.pymoo_addon import IntegerPolynomialMutation
+from pybrops.opt.algo.pymoo_addon import IntegerSimulatedBinaryCrossover
+from pybrops.opt.prob.IntegerProblem import IntegerProblem
+from pybrops.opt.prob.IntegerProblem import check_IntegerProblem_is_multi_objective
+from pybrops.opt.prob.IntegerProblem import check_is_IntegerProblem
 from pybrops.opt.soln.IntegerSolution import IntegerSolution
 from pybrops.opt.soln.IntegerSolution import IntegerSolution
 from pymoo.algorithms.moo.nsga2 import NSGA2
 from pymoo.optimize import minimize
 from pymoo.termination.max_gen import MaximumGenerationTermination
 from pymoo.operators.sampling.rnd import IntegerRandomSampling
 
-class NSGA2IntegerGeneticAlgorithm(IntegerOptimizationAlgorithm):
+class NSGA2IntegerGeneticAlgorithm(
+        IntegerOptimizationAlgorithm,
+    ):
     """
     Class implementing an NSGA-II genetic algorithm adapted for subset selection
     optimization. The search space is discrete and nominal in nature.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/NSGA2MemeticSubsetGeneticAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/NSGA2MemeticSubsetGeneticAlgorithm.py`

 * *Files 5% similar despite different names*

```diff
@@ -6,31 +6,45 @@
 # all public classes and functions available in this module
 __all__ = [
     "NSGA2SteepestDescentSubsetGeneticAlgorithm",
 ]
 
 # imports
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_Real, check_is_dict
-from pybrops.core.error.error_value_python import check_is_gt, check_is_in_interval_inclusive
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_Real
+from pybrops.core.error.error_type_python import check_is_dict
+from pybrops.core.error.error_value_python import check_is_gt
+from pybrops.core.error.error_value_python import check_is_in_interval_inclusive
 from pybrops.core.random.prng import global_prng
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
-from pybrops.opt.algo.pymoo_addon import MutatorA, MutatorB, ReducedExchangeCrossover, SubsetRandomSampling, MultiObjectiveSteepestDescentHillClimberMutation, MultiObjectiveStochasticDescentHillClimberMutation, StochasticHillClimberMutation
-from pybrops.opt.prob.SubsetProblem import SubsetProblem, check_SubsetProblem_is_multi_objective, check_is_SubsetProblem
+from pybrops.opt.algo.pymoo_addon import MutatorA
+from pybrops.opt.algo.pymoo_addon import MutatorB
+from pybrops.opt.algo.pymoo_addon import ReducedExchangeCrossover
+from pybrops.opt.algo.pymoo_addon import SubsetRandomSampling
+from pybrops.opt.algo.pymoo_addon import MultiObjectiveSteepestDescentHillClimberMutation
+from pybrops.opt.algo.pymoo_addon import StochasticHillClimberMutation
+from pybrops.opt.prob.SubsetProblem import SubsetProblem
+from pybrops.opt.prob.SubsetProblem import check_SubsetProblem_is_multi_objective
+from pybrops.opt.prob.SubsetProblem import check_is_SubsetProblem
 from pybrops.opt.soln.SubsetSolution import SubsetSolution
 from pybrops.opt.soln.SubsetSolution import SubsetSolution
 from pymoo.algorithms.moo.nsga2 import NSGA2
 from pymoo.optimize import minimize
 from pymoo.termination.max_gen import MaximumGenerationTermination
 
-class NSGA2SteepestDescentSubsetGeneticAlgorithm(SubsetOptimizationAlgorithm):
+class NSGA2SteepestDescentSubsetGeneticAlgorithm(
+        SubsetOptimizationAlgorithm,
+    ):
     """
     Class implementing an NSGA-II genetic algorithm adapted for subset selection
     optimization. The search space is discrete and nominal in nature.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
@@ -193,15 +207,17 @@
             soln_obj = soln_obj,
             soln_ineqcv = soln_ineqcv,
             soln_eqcv = soln_eqcv
         )
 
         return soln
 
-class NSGA2StochasticDescentSubsetGeneticAlgorithm(SubsetOptimizationAlgorithm):
+class NSGA2StochasticDescentSubsetGeneticAlgorithm(
+        SubsetOptimizationAlgorithm,
+    ):
     """
     Class implementing an NSGA-II genetic algorithm adapted for subset selection
     optimization. The search space is discrete and nominal in nature.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
@@ -367,15 +383,17 @@
             soln_obj = soln_obj,
             soln_ineqcv = soln_ineqcv,
             soln_eqcv = soln_eqcv
         )
 
         return soln
 
-class NSGA2MutatorASubsetGeneticAlgorithm(SubsetOptimizationAlgorithm):
+class NSGA2MutatorASubsetGeneticAlgorithm(
+        SubsetOptimizationAlgorithm,
+    ):
     """
     Class implementing an NSGA-II genetic algorithm adapted for subset selection
     optimization. The search space is discrete and nominal in nature.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
@@ -541,15 +559,17 @@
             soln_obj = soln_obj,
             soln_ineqcv = soln_ineqcv,
             soln_eqcv = soln_eqcv
         )
 
         return soln
 
-class NSGA2MutatorBSubsetGeneticAlgorithm(SubsetOptimizationAlgorithm):
+class NSGA2MutatorBSubsetGeneticAlgorithm(
+        SubsetOptimizationAlgorithm,
+    ):
     """
     Class implementing an NSGA-II genetic algorithm adapted for subset selection
     optimization. The search space is discrete and nominal in nature.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/NSGA2RealGeneticAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/RealGeneticAlgorithm.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,38 +1,45 @@
 """
 Module implementing an NSGA-II genetic algorithm adapted for subset selection
 optimization.
 """
 
 # all public classes and functions available in this module
 __all__ = [
-    "NSGA2RealGeneticAlgorithm",
+    "RealGeneticAlgorithm",
 ]
 
 # imports
 from numbers import Integral
-from numpy.random import Generator,RandomState
-from typing import Optional, Union
+from numpy.random import Generator
+from numpy.random import RandomState
+from typing import Optional
+from typing import Union
 import numpy
 from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_dict
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.core.random.prng import global_prng
 from pybrops.opt.algo.RealOptimizationAlgorithm import RealOptimizationAlgorithm
-from pybrops.opt.prob.RealProblem import RealProblem, check_RealProblem_is_multi_objective, check_is_RealProblem
+from pybrops.opt.prob.RealProblem import RealProblem
+from pybrops.opt.prob.RealProblem import check_RealProblem_is_single_objective
+from pybrops.opt.prob.RealProblem import check_is_RealProblem
 from pybrops.opt.soln.RealSolution import RealSolution
 from pybrops.opt.soln.RealSolution import RealSolution
-from pymoo.algorithms.moo.nsga2 import NSGA2
-from pymoo.optimize import minimize
-from pymoo.termination.max_gen import MaximumGenerationTermination
+from pymoo.algorithms.soo.nonconvex.ga import GA
 from pymoo.operators.crossover.pcx import ParentCentricCrossover
 from pymoo.operators.mutation.pm import PolynomialMutation
 from pymoo.operators.sampling.rnd import FloatRandomSampling
+from pymoo.optimize import minimize
+from pymoo.termination.max_gen import MaximumGenerationTermination
 
-class NSGA2RealGeneticAlgorithm(RealOptimizationAlgorithm):
+class RealGeneticAlgorithm(
+        RealOptimizationAlgorithm,
+    ):
     """
     Class implementing an NSGA-II genetic algorithm adapted for subset selection
     optimization. The search space is discrete and nominal in nature.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
@@ -121,20 +128,20 @@
         Returns
         -------
         out : RealSolution
             An object containing the solution to the provided problem.
         """
         # type checks
         check_is_RealProblem(prob, "prob")
-        check_RealProblem_is_multi_objective(prob, "prob")
+        check_RealProblem_is_single_objective(prob, "prob")
         if miscout is not None:
             check_is_dict(miscout, "miscout")
         
-        # construct the NSGA2 algorithm with custom operators
-        algo = NSGA2(
+        # construct the genetic algorithm with custom operators
+        algo = GA(
             pop_size = self.pop_size,
             sampling = FloatRandomSampling(),
             crossover = ParentCentricCrossover(),
             mutation = PolynomialMutation(),
         )
 
         # optimize the objective function
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/NSGA2SubsetGeneticAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/SubsetGeneticAlgorithm.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,36 +1,45 @@
 """
 Module implementing an NSGA-II genetic algorithm adapted for subset selection
 optimization.
 """
 
 # all public classes and functions available in this module
 __all__ = [
-    "NSGA2SubsetGeneticAlgorithm",
+    "SubsetGeneticAlgorithm",
 ]
 
 # imports
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_dict
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.core.random.prng import global_prng
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
-from pybrops.opt.algo.pymoo_addon import ReducedExchangeCrossover, ReducedExchangeMutation, SubsetRandomSampling
-from pybrops.opt.prob.SubsetProblem import SubsetProblem, check_SubsetProblem_is_multi_objective, check_is_SubsetProblem
+from pybrops.opt.algo.pymoo_addon import ReducedExchangeCrossover
+from pybrops.opt.algo.pymoo_addon import ReducedExchangeMutation
+from pybrops.opt.algo.pymoo_addon import SubsetRandomSampling
+from pybrops.opt.prob.SubsetProblem import SubsetProblem
+from pybrops.opt.prob.SubsetProblem import check_SubsetProblem_is_single_objective
+from pybrops.opt.prob.SubsetProblem import check_is_SubsetProblem
 from pybrops.opt.soln.SubsetSolution import SubsetSolution
 from pybrops.opt.soln.SubsetSolution import SubsetSolution
-from pymoo.algorithms.moo.nsga2 import NSGA2
+from pymoo.algorithms.soo.nonconvex.ga import GA
 from pymoo.optimize import minimize
 from pymoo.termination.max_gen import MaximumGenerationTermination
 
-class NSGA2SubsetGeneticAlgorithm(SubsetOptimizationAlgorithm):
+class SubsetGeneticAlgorithm(
+        SubsetOptimizationAlgorithm,
+    ):
     """
     Class implementing an NSGA-II genetic algorithm adapted for subset selection
     optimization. The search space is discrete and nominal in nature.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
@@ -119,20 +128,20 @@
         Returns
         -------
         out : SubsetSolution
             An object containing the solution to the provided problem.
         """
         # type checks
         check_is_SubsetProblem(prob, "prob")
-        check_SubsetProblem_is_multi_objective(prob, "prob")
+        check_SubsetProblem_is_single_objective(prob, "prob")
         if miscout is not None:
             check_is_dict(miscout, "miscout")
         
-        # construct the NSGA2 algorithm with custom operators
-        algo = NSGA2(
+        # construct the genetic algorithm with custom operators
+        algo = GA(
             pop_size = self.pop_size,
             sampling = SubsetRandomSampling(setspace = prob.decn_space),
             crossover = ReducedExchangeCrossover(),
             mutation = ReducedExchangeMutation(setspace = prob.decn_space),
         )
 
         # optimize the objective function
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/NSGA3SubsetGeneticAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/NSGA3SubsetGeneticAlgorithm.py`

 * *Files 6% similar despite different names*

```diff
@@ -6,32 +6,41 @@
 # all public classes and functions available in this module
 __all__ = [
     "NSGA3SubsetGeneticAlgorithm",
 ]
 
 # imports
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pymoo.algorithms.moo.nsga3 import NSGA3
 from pymoo.optimize import minimize
 from pymoo.termination.max_gen import MaximumGenerationTermination
 from pymoo.util.ref_dirs import get_reference_directions
 
 from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_dict
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.core.random.prng import global_prng
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
-from pybrops.opt.algo.pymoo_addon import ReducedExchangeCrossover, ReducedExchangeMutation, SubsetRandomSampling
-from pybrops.opt.prob.SubsetProblem import SubsetProblem, check_SubsetProblem_is_multi_objective, check_is_SubsetProblem
+from pybrops.opt.algo.pymoo_addon import ReducedExchangeCrossover
+from pybrops.opt.algo.pymoo_addon import ReducedExchangeMutation
+from pybrops.opt.algo.pymoo_addon import SubsetRandomSampling
+from pybrops.opt.prob.SubsetProblem import SubsetProblem
+from pybrops.opt.prob.SubsetProblem import check_SubsetProblem_is_multi_objective
+from pybrops.opt.prob.SubsetProblem import check_is_SubsetProblem
 from pybrops.opt.soln.SubsetSolution import SubsetSolution
 
-class NSGA3SubsetGeneticAlgorithm(SubsetOptimizationAlgorithm):
+class NSGA3SubsetGeneticAlgorithm(
+        SubsetOptimizationAlgorithm,
+    ):
     """
     Class implementing an NSGA-III genetic algorithm adapted for subset selection
     optimization. The search space is discrete and nominal in nature.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/OptimizationAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/OptimizationAlgorithm.py`

 * *Files 3% similar despite different names*

```diff
@@ -4,20 +4,23 @@
 """
 
 __all__ = [
     "OptimizationAlgorithm",
     "check_is_OptimizationAlgorithm",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from typing import Optional
 from pybrops.opt.prob.Problem import Problem
 from pybrops.opt.soln.Solution import Solution
 
-class OptimizationAlgorithm(metaclass=ABCMeta):
+class OptimizationAlgorithm(
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for optimization algorithms.
 
     The purpose of this abstract class is to provide functionality for:
         1) Optimization of objective functions.
     """
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/RealGeneticAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/NSGA2RealGeneticAlgorithm.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,38 +1,45 @@
 """
 Module implementing an NSGA-II genetic algorithm adapted for subset selection
 optimization.
 """
 
 # all public classes and functions available in this module
 __all__ = [
-    "RealGeneticAlgorithm",
+    "NSGA2RealGeneticAlgorithm",
 ]
 
 # imports
 from numbers import Integral
-from numpy.random import Generator,RandomState
-from typing import Optional, Union
+from numpy.random import Generator
+from numpy.random import RandomState
+from typing import Optional
+from typing import Union
 import numpy
 from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_dict
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.core.random.prng import global_prng
 from pybrops.opt.algo.RealOptimizationAlgorithm import RealOptimizationAlgorithm
-from pybrops.opt.prob.RealProblem import RealProblem, check_RealProblem_is_single_objective, check_is_RealProblem
+from pybrops.opt.prob.RealProblem import RealProblem
+from pybrops.opt.prob.RealProblem import check_RealProblem_is_multi_objective
+from pybrops.opt.prob.RealProblem import check_is_RealProblem
 from pybrops.opt.soln.RealSolution import RealSolution
 from pybrops.opt.soln.RealSolution import RealSolution
-from pymoo.algorithms.soo.nonconvex.ga import GA
+from pymoo.algorithms.moo.nsga2 import NSGA2
+from pymoo.optimize import minimize
+from pymoo.termination.max_gen import MaximumGenerationTermination
 from pymoo.operators.crossover.pcx import ParentCentricCrossover
 from pymoo.operators.mutation.pm import PolynomialMutation
 from pymoo.operators.sampling.rnd import FloatRandomSampling
-from pymoo.optimize import minimize
-from pymoo.termination.max_gen import MaximumGenerationTermination
 
-class RealGeneticAlgorithm(RealOptimizationAlgorithm):
+class NSGA2RealGeneticAlgorithm(
+        RealOptimizationAlgorithm,
+    ):
     """
     Class implementing an NSGA-II genetic algorithm adapted for subset selection
     optimization. The search space is discrete and nominal in nature.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
@@ -121,20 +128,20 @@
         Returns
         -------
         out : RealSolution
             An object containing the solution to the provided problem.
         """
         # type checks
         check_is_RealProblem(prob, "prob")
-        check_RealProblem_is_single_objective(prob, "prob")
+        check_RealProblem_is_multi_objective(prob, "prob")
         if miscout is not None:
             check_is_dict(miscout, "miscout")
         
-        # construct the genetic algorithm with custom operators
-        algo = GA(
+        # construct the NSGA2 algorithm with custom operators
+        algo = NSGA2(
             pop_size = self.pop_size,
             sampling = FloatRandomSampling(),
             crossover = ParentCentricCrossover(),
             mutation = PolynomialMutation(),
         )
 
         # optimize the objective function
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/RealOptimizationAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/RealOptimizationAlgorithm.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,21 +3,25 @@
 """
 
 __all__ = [
     "RealOptimizationAlgorithm",
     "check_is_RealOptimizationAlgorithm",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from typing import Optional
 from pybrops.opt.algo.OptimizationAlgorithm import OptimizationAlgorithm
 from pybrops.opt.prob.RealProblem import RealProblem
 from pybrops.opt.soln.RealSolution import RealSolution
 
-class RealOptimizationAlgorithm(OptimizationAlgorithm,metaclass=ABCMeta):
+class RealOptimizationAlgorithm(
+        OptimizationAlgorithm,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for optimization algorithms optimizing in real search spaces.
 
     The purpose of this abstract class is to provide functionality for:
         1) Optimization of objective functions in real search spaces.
     """
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/SortingSteepestDescentSubsetHillClimber.py` & `pybrops-1.0.3/pybrops/opt/algo/SortingSteepestDescentSubsetHillClimber.py`

 * *Files 3% similar despite different names*

```diff
@@ -6,18 +6,22 @@
     "SteepestDescentSubsetHillClimber",
 ]
 
 from typing import Optional
 import numpy
 from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
-from pybrops.opt.prob.SubsetProblem import SubsetProblem, check_SubsetProblem_is_single_objective, check_is_SubsetProblem
+from pybrops.opt.prob.SubsetProblem import SubsetProblem
+from pybrops.opt.prob.SubsetProblem import check_SubsetProblem_is_single_objective
+from pybrops.opt.prob.SubsetProblem import check_is_SubsetProblem
 from pybrops.opt.soln.SubsetSolution import SubsetSolution
 
-class SortingSteepestDescentSubsetHillClimber(SubsetOptimizationAlgorithm):
+class SortingSteepestDescentSubsetHillClimber(
+        SubsetOptimizationAlgorithm,
+    ):
     """
     A variant on the steepest descent hill climber for subset search spaces.
     The hillclimber first tests each element in the decision space, identifies 
     the best decision space variables, then iteratively improves the solution 
     using a steepest descent algorithm to improve the score if any contraint 
     violations exist.
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/SortingSubsetOptimizationAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/SortingSubsetOptimizationAlgorithm.py`

 * *Files 4% similar despite different names*

```diff
@@ -7,18 +7,22 @@
     "SortingSubsetOptimizationAlgorithm",
 ]
 
 from typing import Optional
 import numpy
 from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
-from pybrops.opt.prob.SubsetProblem import SubsetProblem, check_SubsetProblem_is_single_objective, check_is_SubsetProblem
+from pybrops.opt.prob.SubsetProblem import SubsetProblem
+from pybrops.opt.prob.SubsetProblem import check_SubsetProblem_is_single_objective
+from pybrops.opt.prob.SubsetProblem import check_is_SubsetProblem
 from pybrops.opt.soln.SubsetSolution import SubsetSolution
 
-class SortingSubsetOptimizationAlgorithm(SubsetOptimizationAlgorithm):
+class SortingSubsetOptimizationAlgorithm(
+        SubsetOptimizationAlgorithm,
+    ):
     """
     Optimization algorithm class that scores individuals separate from each other,
     sorts to scores, and selects a solution from the sorted list.
 
     Assumes a convex search space where decision variables are additive.
     Ignores any and all constraint violations.
     """
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/SteepestDescentSubsetHillClimber.py` & `pybrops-1.0.3/pybrops/opt/algo/SteepestDescentSubsetHillClimber.py`

 * *Files 6% similar despite different names*

```diff
@@ -2,25 +2,31 @@
 Module implementing a steepest ascent hill climber capable of handling constraints.
 """
 
 __all__ = [
     "SteepestDescentSubsetHillClimber",
 ]
 
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
 from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.core.random.prng import global_prng
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
-from pybrops.opt.prob.SubsetProblem import SubsetProblem, check_SubsetProblem_is_single_objective, check_is_SubsetProblem
+from pybrops.opt.prob.SubsetProblem import SubsetProblem
+from pybrops.opt.prob.SubsetProblem import check_SubsetProblem_is_single_objective
+from pybrops.opt.prob.SubsetProblem import check_is_SubsetProblem
 from pybrops.opt.soln.SubsetSolution import SubsetSolution
 
-class SteepestDescentSubsetHillClimber(SubsetOptimizationAlgorithm):
+class SteepestDescentSubsetHillClimber(
+        SubsetOptimizationAlgorithm,
+    ):
     """
     Steepest descent hill climber for subset search spaces.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/SubsetGeneticAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/NSGA2SubsetGeneticAlgorithm.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,36 +1,45 @@
 """
 Module implementing an NSGA-II genetic algorithm adapted for subset selection
 optimization.
 """
 
 # all public classes and functions available in this module
 __all__ = [
-    "SubsetGeneticAlgorithm",
+    "NSGA2SubsetGeneticAlgorithm",
 ]
 
 # imports
 from numbers import Integral
-from typing import Optional, Union
+from typing import Optional
+from typing import Union
 import numpy
-from numpy.random import Generator, RandomState
+from numpy.random import Generator
+from numpy.random import RandomState
 from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_dict
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.core.random.prng import global_prng
 from pybrops.opt.algo.SubsetOptimizationAlgorithm import SubsetOptimizationAlgorithm
-from pybrops.opt.algo.pymoo_addon import ReducedExchangeCrossover, ReducedExchangeMutation, SubsetRandomSampling
-from pybrops.opt.prob.SubsetProblem import SubsetProblem, check_SubsetProblem_is_single_objective, check_is_SubsetProblem
+from pybrops.opt.algo.pymoo_addon import ReducedExchangeCrossover
+from pybrops.opt.algo.pymoo_addon import ReducedExchangeMutation
+from pybrops.opt.algo.pymoo_addon import SubsetRandomSampling
+from pybrops.opt.prob.SubsetProblem import SubsetProblem
+from pybrops.opt.prob.SubsetProblem import check_SubsetProblem_is_multi_objective
+from pybrops.opt.prob.SubsetProblem import check_is_SubsetProblem
 from pybrops.opt.soln.SubsetSolution import SubsetSolution
 from pybrops.opt.soln.SubsetSolution import SubsetSolution
-from pymoo.algorithms.soo.nonconvex.ga import GA
+from pymoo.algorithms.moo.nsga2 import NSGA2
 from pymoo.optimize import minimize
 from pymoo.termination.max_gen import MaximumGenerationTermination
 
-class SubsetGeneticAlgorithm(SubsetOptimizationAlgorithm):
+class NSGA2SubsetGeneticAlgorithm(
+        SubsetOptimizationAlgorithm,
+    ):
     """
     Class implementing an NSGA-II genetic algorithm adapted for subset selection
     optimization. The search space is discrete and nominal in nature.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
@@ -119,20 +128,20 @@
         Returns
         -------
         out : SubsetSolution
             An object containing the solution to the provided problem.
         """
         # type checks
         check_is_SubsetProblem(prob, "prob")
-        check_SubsetProblem_is_single_objective(prob, "prob")
+        check_SubsetProblem_is_multi_objective(prob, "prob")
         if miscout is not None:
             check_is_dict(miscout, "miscout")
         
-        # construct the genetic algorithm with custom operators
-        algo = GA(
+        # construct the NSGA2 algorithm with custom operators
+        algo = NSGA2(
             pop_size = self.pop_size,
             sampling = SubsetRandomSampling(setspace = prob.decn_space),
             crossover = ReducedExchangeCrossover(),
             mutation = ReducedExchangeMutation(setspace = prob.decn_space),
         )
 
         # optimize the objective function
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/SubsetOptimizationAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/SubsetOptimizationAlgorithm.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,21 +3,25 @@
 """
 
 __all__ = [
     "SubsetOptimizationAlgorithm",
     "check_is_SubsetOptimizationAlgorithm",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from typing import Optional
 from pybrops.opt.algo.OptimizationAlgorithm import OptimizationAlgorithm
 from pybrops.opt.prob.SubsetProblem import SubsetProblem
 from pybrops.opt.soln.SubsetSolution import SubsetSolution
 
-class SubsetOptimizationAlgorithm(OptimizationAlgorithm,metaclass=ABCMeta):
+class SubsetOptimizationAlgorithm(
+        OptimizationAlgorithm,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for optimization algorithms optimizing in subset search spaces.
 
     The purpose of this abstract class is to provide functionality for:
         1) Optimization of objective functions in subset search spaces.
     """
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/UnconstrainedNSGA2SetGeneticAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/UnconstrainedNSGA2SetGeneticAlgorithm.py`

 * *Files 1% similar despite different names*

```diff
@@ -16,15 +16,17 @@
 from pybrops.opt.algo.UnconstrainedOptimizationAlgorithm import UnconstrainedOptimizationAlgorithm
 from pybrops.core.util.pareto import is_pareto_efficient
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.core.error.error_type_python import check_is_int
 from pybrops.core.error.error_type_python import check_is_float
 from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
 
-class UnconstrainedNSGA2SetGeneticAlgorithm(UnconstrainedOptimizationAlgorithm):
+class UnconstrainedNSGA2SetGeneticAlgorithm(
+        UnconstrainedOptimizationAlgorithm,
+    ):
     """
     Class implementing an NSGA-II genetic algorithm adapted for subset selection
     optimization. The search space is discrete and nominal in nature.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(self, ngen = 250, mu = 100, lamb = 100, M = 1.5, rng = global_prng, **kwargs: dict):
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/UnconstrainedOptimizationAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/UnconstrainedOptimizationAlgorithm.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/opt/algo/UnconstrainedSetGeneticAlgorithm.py` & `pybrops-1.0.3/pybrops/opt/algo/UnconstrainedSetGeneticAlgorithm.py`

 * *Files 1% similar despite different names*

```diff
@@ -17,15 +17,17 @@
 from pybrops.opt.algo.UnconstrainedOptimizationAlgorithm import UnconstrainedOptimizationAlgorithm
 from pybrops.core.util.pareto import is_pareto_efficient
 from pybrops.core.error.error_value_python import check_is_gt
 from pybrops.core.error.error_type_python import check_is_int
 from pybrops.core.error.error_type_python import check_is_float
 from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
 
-class UnconstrainedSetGeneticAlgorithm(UnconstrainedOptimizationAlgorithm):
+class UnconstrainedSetGeneticAlgorithm(
+        UnconstrainedOptimizationAlgorithm,
+    ):
     """
     Class implementing an NSGA-II genetic algorithm adapted for subset selection
     optimization. The search space is discrete and nominal in nature.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(self, ngen = 250, mu = 100, lamb = 100, M = 1.5, rng = global_prng, **kwargs: dict):
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/UnconstrainedSteepestAscentSetHillClimber.py` & `pybrops-1.0.3/pybrops/opt/algo/UnconstrainedSteepestAscentSetHillClimber.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,15 +6,17 @@
 from typing import Union
 import numpy
 
 from pybrops.opt.algo.UnconstrainedOptimizationAlgorithm import UnconstrainedOptimizationAlgorithm
 from pybrops.core.random.prng import global_prng
 from pybrops.core.error.error_type_numpy import check_is_Generator_or_RandomState
 
-class UnconstrainedSteepestAscentSetHillClimber(UnconstrainedOptimizationAlgorithm):
+class UnconstrainedSteepestAscentSetHillClimber(
+        UnconstrainedOptimizationAlgorithm,
+    ):
     """
     Class implementing a steepest ascent hill climber algorithm adapted for
     subset selection optimization. The search space is discrete and nominal in
     nature.
     """
 
     ########################## Special Object Methods ##########################
```

### Comparing `pybrops-1.0.2/pybrops/opt/algo/__init__.py` & `pybrops-1.0.3/pybrops/opt/algo/__init__.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/opt/algo/pymoo_addon.py` & `pybrops-1.0.3/pybrops/opt/algo/pymoo_addon.py`

 * *Files 1% similar despite different names*

```diff
@@ -10,14 +10,15 @@
     "MultiObjectiveStochasticHillClimberMutation",
     "IntegerPolynomialMutation",
     "IntegerSimulatedBinaryCrossover",
     "MultiObjectiveSteepestDescentHillClimberMutation",
     "MultiObjectiveStochasticDescentHillClimberMutation",
 ]
 
+from typing import Optional
 import numpy as np
 import copy
 from pymoo.core.variable import get
 from pymoo.core.sampling import Sampling
 from pymoo.core.problem import Problem
 from pymoo.core.crossover import Crossover
 from pymoo.core.mutation import Mutation
@@ -66,15 +67,17 @@
     ndiv = size // a
     nrem = size % a
     for i in range(ndiv):
         out[a*i:a*(i+1)] = np.random.choice(a, a, replace = False)
     out[a*ndiv:] = np.random.choice(a, nrem, replace = False)
     return out
 
-class SubsetRandomSampling(Sampling):
+class SubsetRandomSampling(
+        Sampling,
+    ):
     """
     Class implementing subset sampling for chromosome construction.
     """
 
     ################ Special object methods ################
     def __init__(
             self,
@@ -158,15 +161,17 @@
                 problem.n_var,              # number of elements to sample 
                 replace = self._replace     # whether to replace elements for the subset sampling
             )
 
         # return output array
         return out
 
-class ReducedExchangeCrossover(Crossover):
+class ReducedExchangeCrossover(
+        Crossover,
+    ):
     """
     Perform a subset crossover according to Correa et al. (2001).
 
     Citations
     ---------
     Correa, E. S., Steiner, M. T. A., Freitas, A. A., Carnieri, C. A Genetic 
     Algorithm for the P-median Problem In: Genetic and Evolutionary Computation 
@@ -240,15 +245,17 @@
             mex = np.random.choice(clen, nex)   # get a mask of the elements to exchange
             ap[mex], bp[mex] = bp[mex], ap[mex] # exchange alleles
             Xp[0,i,mab] = ap                    # copy over exchanges to indiv 1
             Xp[1,i,mba] = bp                    # copy over exchanges to indiv 2
 
         return Xp
 
-class ReducedExchangeMutation(Mutation):
+class ReducedExchangeMutation(
+        Mutation,
+    ):
     """
     Perform a subset exchange mutation according to Correa et al. (2001).
 
     Citations
     ---------
     Correa, E. S., Steiner, M. T. A., Freitas, A. A., Carnieri, C. A Genetic 
     Algorithm for the P-median Problem In: Genetic and Evolutionary Computation 
@@ -331,15 +338,17 @@
             mex = np.random.random(len(pp)) < pp    # get mutation locations
             nex = mex.sum()                         # get number of mutations
             ap[mex] = np.random.choice(bp, nex)     # randomly assign new alleles to reduced indiv chromosome
             Xm[i,mab] = ap                          # overwrite mutations to indiv
         
         return Xm
 
-class IntegerSimulatedBinaryCrossover(SimulatedBinaryCrossover):
+class IntegerSimulatedBinaryCrossover(
+        SimulatedBinaryCrossover,
+    ):
     def _do(
             self, 
             problem: Problem, 
             X: np.ndarray, 
             **kwargs: dict
         ) -> np.ndarray:
         """
@@ -368,15 +377,17 @@
         )
 
         # round results and convert type
         out = out.round(0).astype(X.dtype)
 
         return out
 
-class IntegerPolynomialMutation(PolynomialMutation):
+class IntegerPolynomialMutation(
+        PolynomialMutation,
+    ):
     def _do(
             self, 
             problem: Problem, 
             X: np.ndarray, 
             **kwargs: dict
         ) -> np.ndarray:
         """
@@ -405,15 +416,17 @@
         )
 
         # round results and convert type
         out = out.round(0).astype(X.dtype)
 
         return out
 
-class MultiObjectiveStochasticHillClimberMutation(Mutation):
+class MultiObjectiveStochasticHillClimberMutation(
+        Mutation,
+    ):
     """
     Perform a memetic subset exchange mutation.
     """
 
     ################ Special object methods ################
     def __init__(
             self,
@@ -609,15 +622,17 @@
         # apply hillclimber to mutated individuals
         for i in range(n_indiv):
             if np.random.random() < self.p_hillclimb:
                 Xm[i,:] = self.hillclimb(problem, Xm[i,:])
 
         return Xm
 
-class MultiObjectiveSteepestDescentHillClimberMutation(Mutation):
+class MultiObjectiveSteepestDescentHillClimberMutation(
+        Mutation,
+    ):
     """
     Perform a memetic subset exchange mutation.
     """
 
     ################ Special object methods ################
     def __init__(
             self,
@@ -816,25 +831,27 @@
             mex = np.random.random(len(pp)) < pp    # get mutation locations
             nex = mex.sum()                         # get number of mutations
             ap[mex] = np.random.choice(bp, nex)     # randomly assign new alleles to reduced indiv chromosome
             Xm[i,mab] = ap                          # overwrite mutations to indiv
 
         return Xm
 
-class MultiObjectiveStochasticDescentHillClimberMutation(Mutation):
+class MultiObjectiveStochasticDescentHillClimberMutation(
+        Mutation,
+    ):
     """
     Perform a memetic subset exchange mutation.
     """
 
     ################ Special object methods ################
     def __init__(
             self,
             setspace: np.ndarray,
             phc: float,
-            nhc: int | None = None,
+            nhc: Optional[int] = None,
             **kwargs: dict
         ) -> None:
         """
         Constructor for MultiObjectiveStochasticDescentHillClimberMutation.
         
         Parameters
         ----------
@@ -1063,15 +1080,17 @@
             mex = np.random.random(len(pp)) < pp    # get mutation locations
             nex = mex.sum()                         # get number of mutations
             ap[mex] = np.random.choice(bp, nex)     # randomly assign new alleles to reduced indiv chromosome
             Xm[i,mab] = ap                          # overwrite mutations to indiv
 
         return Xm
 
-class StochasticHillClimberMutation(Mutation):
+class StochasticHillClimberMutation(
+        Mutation,
+    ):
     """
     Perform a memetic subset exchange mutation.
     """
 
     ################ Special object methods ################
     def __init__(
             self,
@@ -1281,15 +1300,17 @@
             if rnd < self.phc:
                 Xm[i,:] = self.hillclimb(problem, Xm[i,:])
             else:
                 Xm[i,:] = self.reduced_exchange(problem, Xm[i,:])
         
         return Xm
 
-class MutatorA(Mutation):
+class MutatorA(
+        Mutation,
+    ):
     """
     Randomly test nearby solutions and randomly choose one solution that 
     non-dominates from the tested mutations.
     """
     ################ Special object methods ################
     def __init__(
             self,
@@ -1462,15 +1483,17 @@
             if rnd < self.phc:
                 Xm[i,:] = self.hillclimb(problem, Xm[i,:])
             else:
                 Xm[i,:] = self.reduced_exchange(problem, Xm[i,:])
         
         return Xm
 
-class MutatorB(Mutation):
+class MutatorB(
+        Mutation,
+    ):
     """
     Randomly test nearby solutions and randomly choose one solution that 
     exhibits extreme values for one of the objectives.
     """
     ################ Special object methods ################
     def __init__(
             self,
@@ -1646,26 +1669,28 @@
             if rnd < self.phc:
                 Xm[i,:] = self.hillclimb(problem, Xm[i,:])
             else:
                 Xm[i,:] = self.reduced_exchange(problem, Xm[i,:])
         
         return Xm
 
-class MutatorF(Mutation):
+class MutatorF(
+        Mutation,
+    ):
     """
     Perform a memetic subset exchange mutation (Mutation F).
     """
 
     ################ Special object methods ################
     def __init__(
             self,
             setspace: np.ndarray,
             phc: float,
-            maxhc: int | None = None,
-            maxhcstep: int | None = None,
+            maxhc: Optional[int] = None,
+            maxhcstep: Optional[int] = None,
             **kwargs: dict
         ) -> None:
         """
         Constructor for SubsetMutation.
         
         Parameters
         ----------
```

### Comparing `pybrops-1.0.2/pybrops/opt/prob/BinaryProblem.py` & `pybrops-1.0.3/pybrops/opt/prob/BinaryProblem.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,24 +5,34 @@
 # list of public objects in this module
 __all__ = [
     "BinaryProblem",
     "check_is_BinaryProblem",
 ]
 
 # imports
-from numbers import Integral, Real
-from typing import Callable, Iterable, Optional, Sequence, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Iterable
+from typing import Optional
+from typing import Sequence
+from typing import Union
 import numpy
-from pymoo.core.problem import ElementwiseEvaluationFunction, LoopedElementwiseEvaluation
+from pymoo.core.problem import ElementwiseEvaluationFunction
+from pymoo.core.problem import LoopedElementwiseEvaluation
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_bool_or_integer
-from pybrops.core.error.error_value_numpy import check_ndarray_is_binary, check_ndarray_len_eq, check_ndarray_shape_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_is_binary
+from pybrops.core.error.error_value_numpy import check_ndarray_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_shape_eq
 from pybrops.opt.prob.Problem import Problem
 
 # inheritance ordering is important for method resolution order
-class BinaryProblem(Problem):
+class BinaryProblem(
+        Problem,
+    ):
     """
     Partially implemented class for optimization problems with nominal decision 
     variables where the goal is to select an optimal subset.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
```

### Comparing `pybrops-1.0.2/pybrops/opt/prob/FunctionWeight.py` & `pybrops-1.0.3/pybrops/opt/prob/FunctionWeight.py`

 * *Files 6% similar despite different names*

```diff
@@ -107,15 +107,17 @@
             raise TypeError("'optimization_type' must be of type str")
         value = value.lower()
         if value != "min" and value != "max":
             raise ValueError("'optimization_type' value must be either 'min' or 'max'")
         self._optimization_type = value
 
 
-class MinimizingFunctionWeight(FunctionWeight):
+class MinimizingFunctionWeight(
+        FunctionWeight,
+    ):
     """
     Class for representing weights for functions that are minimizing in their natural state.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
@@ -191,15 +193,17 @@
         out : str
             A weight represented as a string.
         """
         return str(self.wt if self.optimization_type == "min" else -self.wt)
 
 
 
-class MaximizingFunctionWeight(FunctionWeight):
+class MaximizingFunctionWeight(
+        FunctionWeight,
+    ):
     """
     Class for representing weights for functions that are maximizing in their natural state.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/opt/prob/IntegerProblem.py` & `pybrops-1.0.3/pybrops/opt/prob/IntegerProblem.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,24 +5,33 @@
 # list of public objects in this module
 __all__ = [
     "IntegerProblem",
     "check_is_IntegerProblem",
 ]
 
 # imports
-from numbers import Integral, Real
-from typing import Callable, Iterable, Optional, Sequence, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Iterable
+from typing import Optional
+from typing import Sequence
+from typing import Union
 import numpy
-from pymoo.core.problem import ElementwiseEvaluationFunction, LoopedElementwiseEvaluation
+from pymoo.core.problem import ElementwiseEvaluationFunction
+from pymoo.core.problem import LoopedElementwiseEvaluation
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_integer
-from pybrops.core.error.error_value_numpy import check_ndarray_len_eq, check_ndarray_shape_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_shape_eq
 from pybrops.opt.prob.Problem import Problem
 
 # inheritance ordering is important for method resolution order
-class IntegerProblem(Problem):
+class IntegerProblem(
+        Problem,
+    ):
     """
     Partially implemented class for optimization problems with nominal decision 
     variables where the goal is to select an optimal subset.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
```

### Comparing `pybrops-1.0.2/pybrops/opt/prob/Problem.py` & `pybrops-1.0.3/pybrops/opt/prob/Problem.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,20 +5,29 @@
 # list of public objects in this module
 __all__ = [
     "Problem",
     "check_is_Problem",
 ]
 
 # imports
-from abc import ABCMeta, abstractmethod
-from numbers import Integral, Real
-from typing import Callable, Container, Iterable, Tuple, Union
+from abc import ABCMeta
+from abc import abstractmethod
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Container
+from typing import Iterable
+from typing import Tuple
+from typing import Union
 import numpy
-from pybrops.core.error.error_type_python import check_is_Integral, check_is_type
-from pybrops.core.error.error_value_numpy import check_ndarray_len_eq, check_ndarray_ndim, check_ndarray_shape_eq
+from pybrops.core.error.error_type_python import check_is_Integral
+from pybrops.core.error.error_type_python import check_is_type
+from pybrops.core.error.error_value_numpy import check_ndarray_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_shape_eq
 from pybrops.core.error.error_value_python import check_is_gteq
 import pymoo.core.problem
 
 class Problem(
         pymoo.core.problem.Problem,
         metaclass = ABCMeta
     ):
```

### Comparing `pybrops-1.0.2/pybrops/opt/prob/RealProblem.py` & `pybrops-1.0.3/pybrops/opt/prob/RealProblem.py`

 * *Files 3% similar despite different names*

```diff
@@ -5,24 +5,33 @@
 # list of public objects in this module
 __all__ = [
     "RealProblem",
     "check_is_RealProblem",
 ]
 
 # imports
-from numbers import Integral, Real
-from typing import Callable, Iterable, Optional, Sequence, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Iterable
+from typing import Optional
+from typing import Sequence
+from typing import Union
 import numpy
-from pymoo.core.problem import ElementwiseEvaluationFunction, LoopedElementwiseEvaluation
+from pymoo.core.problem import ElementwiseEvaluationFunction
+from pymoo.core.problem import LoopedElementwiseEvaluation
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_floating
-from pybrops.core.error.error_value_numpy import check_ndarray_len_eq, check_ndarray_shape_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_shape_eq
 from pybrops.opt.prob.Problem import Problem
 
 # inheritance ordering is important for method resolution order
-class RealProblem(Problem):
+class RealProblem(
+        Problem,
+    ):
     """
     Partially implemented class for optimization problems with nominal decision 
     variables where the goal is to select an optimal subset.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
```

### Comparing `pybrops-1.0.2/pybrops/opt/prob/SubsetProblem.py` & `pybrops-1.0.3/pybrops/opt/prob/SubsetProblem.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,24 +5,33 @@
 # list of public objects in this module
 __all__ = [
     "SubsetProblem",
     "check_is_SubsetProblem",
 ]
 
 # imports
-from numbers import Integral, Real
-from typing import Callable, Iterable, Optional, Sequence, Union
+from numbers import Integral
+from numbers import Real
+from typing import Callable
+from typing import Iterable
+from typing import Optional
+from typing import Sequence
+from typing import Union
 import numpy
-from pymoo.core.problem import ElementwiseEvaluationFunction, LoopedElementwiseEvaluation
+from pymoo.core.problem import ElementwiseEvaluationFunction
+from pymoo.core.problem import LoopedElementwiseEvaluation
 from pybrops.core.error.error_type_numpy import check_is_ndarray
-from pybrops.core.error.error_value_numpy import check_ndarray_len_gteq, check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_len_gteq
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.opt.prob.Problem import Problem
 
 # inheritance ordering is important for method resolution order
-class SubsetProblem(Problem):
+class SubsetProblem(
+        Problem,
+    ):
     """
     Partially implemented class for optimization problems with nominal decision 
     variables where the goal is to select an optimal subset.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
```

### Comparing `pybrops-1.0.2/pybrops/opt/soln/BinarySolution.py` & `pybrops-1.0.3/pybrops/opt/soln/BinarySolution.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,22 +5,27 @@
 # list of all public imports in the module
 __all__ = [
     "BinarySolution",
     "check_is_BinarySolution",
 ]
 
 # imports
-from numbers import Integral, Real
+from numbers import Integral
+from numbers import Real
 from typing import Union
 import numpy
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_bool_or_integer
-from pybrops.core.error.error_value_numpy import check_ndarray_is_binary, check_ndarray_len_eq, check_ndarray_shape_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_is_binary
+from pybrops.core.error.error_value_numpy import check_ndarray_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_shape_eq
 from pybrops.opt.soln.Solution import Solution
 
-class BinarySolution(Solution):
+class BinarySolution(
+        Solution,
+    ):
     """
     Class for optimization problem solutions with binary decision variables.
     """
 
     ########################## Special Object Methods ##########################
     
     # implementation of abstract method
```

### Comparing `pybrops-1.0.2/pybrops/opt/soln/IntegerSolution.py` & `pybrops-1.0.3/pybrops/opt/soln/IntegerSolution.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,22 +5,26 @@
 # list of all public imports in the module
 __all__ = [
     "IntegerSolution",
     "check_is_IntegerSolution",
 ]
 
 # imports
-from numbers import Integral, Real
+from numbers import Integral
+from numbers import Real
 from typing import Union
 import numpy
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_integer
-from pybrops.core.error.error_value_numpy import check_ndarray_len_eq, check_ndarray_shape_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_shape_eq
 from pybrops.opt.soln.Solution import Solution
 
-class IntegerSolution(Solution):
+class IntegerSolution(
+        Solution,
+    ):
     """
     Class for optimization problem solutions with integer decision variables.
     """
 
     ########################## Special Object Methods ##########################
     
     # implementation of abstract method
```

### Comparing `pybrops-1.0.2/pybrops/opt/soln/RealSolution.py` & `pybrops-1.0.3/pybrops/opt/soln/RealSolution.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,22 +5,26 @@
 # list of all public imports in the module
 __all__ = [
     "RealSolution",
     "check_is_RealSolution",
 ]
 
 # imports
-from numbers import Integral, Real
+from numbers import Integral
+from numbers import Real
 from typing import Union
 import numpy
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_real
-from pybrops.core.error.error_value_numpy import check_ndarray_len_eq, check_ndarray_shape_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_shape_eq
 from pybrops.opt.soln.Solution import Solution
 
-class RealSolution(Solution):
+class RealSolution(
+        Solution,
+    ):
     """
     Class for optimization problem solutions with real decision variables.
     """
 
     ########################## Special Object Methods ##########################
 
     # implementation of abstract method
```

### Comparing `pybrops-1.0.2/pybrops/opt/soln/Solution.py` & `pybrops-1.0.3/pybrops/opt/soln/Solution.py`

 * *Files 10% similar despite different names*

```diff
@@ -5,24 +5,29 @@
 # list of all public objects in this module
 __all__ = [
     "Solution",
     "check_is_Solution",
 ]
 
 from abc import ABCMeta
-from numbers import Integral, Real
+from numbers import Integral
+from numbers import Real
 from typing import Union
 import numpy
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_python import check_is_Integral
-from pybrops.core.error.error_value_numpy import check_ndarray_len_eq, check_ndarray_ndim, check_ndarray_shape_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_shape_eq
 from pybrops.core.error.error_value_python import check_is_gteq
 
 
-class Solution(metaclass=ABCMeta):
+class Solution(
+        metaclass = ABCMeta,
+    ):
     """
     A semi-abstract class defining a Solution interface and implementing several
     essential properties for all Solution classes.
 
     A user must implement the following abstract methods in derivatives:
         1) ``__init__``
 
@@ -30,14 +35,35 @@
         1) It is possible to call the constructor of this semi-abstract from a
            derived class.
     """
 
     ########################## Special Object Methods ##########################
     # do not implement __init__() since this is an interface/mixin class
 
+    def __repr__(
+            self
+        ) -> str:
+        """
+        Return repr(self).
+        
+        Returns
+        -------
+        out : str
+            A representation of the object.
+        """
+        return "<{0} with [ndecn = {1}, nsoln = {2}, nobj = {3}, nineqcv = {4}, neqcv = {5}] at {6}>".format(
+            type(self).__name__,
+            self.ndecn,
+            self.nsoln,
+            self.nobj,
+            self.nineqcv,
+            self.neqcv,
+            hex(id(self)),
+        )
+
     ############################ Object Properties #############################
 
     ############## Decision space properties ###############
     @property
     def ndecn(self) -> Integral:
         """Number of decision variables."""
         return self._ndecn
```

### Comparing `pybrops-1.0.2/pybrops/opt/soln/SubsetSolution.py` & `pybrops-1.0.3/pybrops/opt/soln/SubsetSolution.py`

 * *Files 3% similar despite different names*

```diff
@@ -5,22 +5,27 @@
 # list of all public imports in the module
 __all__ = [
     "SubsetSolution",
     "check_is_SubsetSolution",
 ]
 
 # imports
-from numbers import Integral, Real
+from numbers import Integral
+from numbers import Real
 from typing import Union
 import numpy
 from pybrops.core.error.error_type_numpy import check_is_ndarray
-from pybrops.core.error.error_value_numpy import check_ndarray_len_eq, check_ndarray_len_gteq, check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_len_eq
+from pybrops.core.error.error_value_numpy import check_ndarray_len_gteq
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.opt.soln.Solution import Solution
 
-class SubsetSolution(Solution):
+class SubsetSolution(
+        Solution,
+    ):
     """
     Class for optimization problem solutions with nominal decision variables.
     """
 
     ########################## Special Object Methods ##########################
     
     # implementation of abstract method
```

### Comparing `pybrops-1.0.2/pybrops/popgen/bvmat/BreedingValueMatrix.py` & `pybrops-1.0.3/pybrops/popgen/bvmat/BreedingValueMatrix.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,24 +4,34 @@
 """
 
 __all__ = [
     "BreedingValueMatrix",
     "check_is_BreedingValueMatrix",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
+from pathlib import Path
 from typing import Optional
+from typing import Union
 import numpy
 import pandas
+import h5py
 from pybrops.core.io.CSVInputOutput import CSVInputOutput
 from pybrops.core.io.HDF5InputOutput import HDF5InputOutput
 from pybrops.core.io.PandasInputOutput import PandasInputOutput
 from pybrops.core.mat.TaxaTraitMatrix import TaxaTraitMatrix
 
-class BreedingValueMatrix(TaxaTraitMatrix,PandasInputOutput,CSVInputOutput,HDF5InputOutput,metaclass=ABCMeta):
+class BreedingValueMatrix(
+        TaxaTraitMatrix,
+        PandasInputOutput,
+        CSVInputOutput,
+        HDF5InputOutput,
+        metaclass = ABCMeta,
+    ):
     """
     The BreedingValueMatrix class represents a Multivariate Breeding Value.
 
     Notes
     -----
     All elements within a BreedingValueMatrix are mean-centered and scaled to
     unit variance for each trait.
@@ -313,27 +323,28 @@
         """
         raise NotImplementedError("class method is abstract")
     
     @classmethod
     @abstractmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str]
         ) -> 'BreedingValueMatrix':
         """
         Read a BreedingValueMatrix from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which object data is stored.
-            If None, object is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, HDF5 group name under which object data is stored.
+            If ``None``, object is read from base HDF5 group.
 
         Returns
         -------
         out : BreedingValueMatrix
             A BreedingValueMatrix read from an HDF5 file.
         """
         raise NotImplementedError("class method is abstract")
```

### Comparing `pybrops-1.0.2/pybrops/popgen/bvmat/DenseBreedingValueMatrix.py` & `pybrops-1.0.3/pybrops/popgen/bvmat/DenseBreedingValueMatrix.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,40 +5,51 @@
 
 __all__ = [
     "DenseBreedingValueMatrix",
     "check_is_DenseBreedingValueMatrix",
 ]
 
 import copy
-from numbers import Integral, Real
-from typing import Optional, Sequence, Union
+from numbers import Integral
+from numbers import Real
+from pathlib import Path
+from typing import Optional
+from typing import Sequence
+from typing import Union
 import numpy
 from numpy.typing import ArrayLike
 import h5py
 import pandas
 from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
 from pybrops.core.error.error_type_python import check_is_array_like
 from pybrops.core.error.error_type_python import check_is_bool
 from pybrops.core.error.error_type_python import check_is_str
 from pybrops.core.error.error_type_python import check_is_str_or_Integral
 from pybrops.core.error.error_type_python import check_is_str_or_Sequence
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_readable
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_writable
 from pybrops.core.error.error_value_numpy import check_ndarray_all_gteq
 from pybrops.core.error.error_value_numpy import check_ndarray_axis_len
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.core.error.error_io_python import check_file_exists
 from pybrops.core.error.error_value_python import check_is_gteq
 from pybrops.core.error.error_value_python import check_len
 from pybrops.core.error.error_value_python import check_str_value
 from pybrops.core.mat.DenseTaxaTraitMatrix import DenseTaxaTraitMatrix
-from pybrops.core.util.h5py import save_dict_to_hdf5
+from pybrops.core.util.h5py import h5py_File_read_ndarray
+from pybrops.core.util.h5py import h5py_File_read_ndarray_utf8
+from pybrops.core.util.h5py import h5py_File_write_dict
 from pybrops.popgen.bvmat.BreedingValueMatrix import BreedingValueMatrix
 
-class DenseBreedingValueMatrix(DenseTaxaTraitMatrix,BreedingValueMatrix):
+class DenseBreedingValueMatrix(
+        DenseTaxaTraitMatrix,
+        BreedingValueMatrix,
+    ):
     """
     The DenseBreedingValueMatrix class uses a dense matrix to represent a
     Multivariate Breeding Value.
 
     Notes
     -----
     All elements within a BreedingValueMatrix are mean-centered and scaled to
@@ -181,14 +192,33 @@
         out.taxa_grp_name = copy.deepcopy(self.taxa_grp_name, memo)
         out.taxa_grp_stix = copy.deepcopy(self.taxa_grp_stix, memo)
         out.taxa_grp_spix = copy.deepcopy(self.taxa_grp_spix, memo)
         out.taxa_grp_len = copy.deepcopy(self.taxa_grp_len, memo)
 
         return out
 
+    ########### Miscellaneous special functions ############
+    def __repr__(
+            self
+        ) -> str:
+        """
+        Return repr(self).
+        
+        Returns
+        -------
+        out : str
+            A representation of the object.
+        """
+        return "<{0} of shape (ntaxa = {1}, ntrait = {2}) at {3}>".format(
+            type(self).__name__,
+            self.ntaxa,
+            self.ntrait,
+            hex(id(self)),
+        )
+
     ############################ Object Properties #############################
 
     ################# Breeding Value Data ##################
     @DenseTaxaTraitMatrix.mat.setter
     def mat(self, value: numpy.ndarray) -> None:
         """Set raw matrix"""
         check_is_ndarray(value, "mat")
@@ -850,49 +880,102 @@
             header = header,
             index = index,
             **kwargs
         )
 
     def to_hdf5(
             self, 
-            filename: str, 
-            groupname: Optional[str] = None
+            filename: Union[str,Path,h5py.File], 
+            groupname: Optional[str] = None,
+            overwrite: bool = True,
         ) -> None:
         """
-        Write GenotypeMatrix to an HDF5 file.
+        Write ``DenseBreedingValueMatrix`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name to which to write.
+        filename : str, Path, h5py.File
+            If ``str``, an HDF5 file name to which to write. File is closed after writing.
+            If ``h5py.File``, an opened HDF5 file to which to write. File is not closed after writing.
+
         groupname : str, None
-            HDF5 group name under which GenotypeMatrix data is stored.
-            If ``None``, GenotypeMatrix is written to the base HDF5 group.
+            If ``str``, an HDF5 group name under which ``DenseBreedingValueMatrix`` data is stored.
+            If ``None``, ``DenseBreedingValueMatrix`` is written to the base HDF5 group.
+
+        overwrite : bool
+            Whether to overwrite values in an HDF5 file if a field already exists.
         """
-        h5file = h5py.File(filename, "a")                       # open HDF5 in write mode
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### populate HDF5 file
-        data_dict = {                                           # data dictionary
-            "mat": self.mat,
-            "location": self.location,
-            "scale": self.scale,
-            "taxa": self.taxa,
-            "taxa_grp": self.taxa_grp,
-            "trait": self.trait
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in append (``r+``) mode
+        if isinstance(filename, (str,Path)):
+            h5file = h5py.File(filename, "a")
+
+        # elif we have an h5py.File, make sure mode is writable, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_writable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        #### write data to HDF5 file and (optionally) close ####
+
+        # data dictionary
+        data = {
+            "mat"           : self.mat,
+            "location"      : self.location,
+            "scale"         : self.scale,
+            "taxa"          : self.taxa,
+            "taxa_grp"      : self.taxa_grp,
+            "trait"         : self.trait,
+            # metadata
+            "taxa_grp_name" : self.taxa_grp_name,
+            "taxa_grp_stix" : self.taxa_grp_stix,
+            "taxa_grp_spix" : self.taxa_grp_spix,
+            "taxa_grp_len"  : self.taxa_grp_len,
         }
-        save_dict_to_hdf5(h5file, groupname, data_dict)         # save data
-        ######################################################### write conclusion
-        h5file.close()                                          # close the file
+
+        # save data
+        h5py_File_write_dict(h5file, groupname, data, overwrite)
+
+        # close the file, only if the provided filename was a string or Path and not a h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
 
     ############################## Class Methods ###############################
 
     ################### Matrix File I/O ####################
     @classmethod
     def from_numpy(
             cls, 
@@ -904,15 +987,15 @@
         ) -> 'DenseBreedingValueMatrix':
         """
         Construct a DenseBreedingValueMatrix from a numpy.ndarray.
         Calculates mean-centering and scaling to unit variance.
 
         Parameters
         ----------
-        a : numpy.ndarray
+        mat : numpy.ndarray
             A ``float64`` matrix of shape ``(n,t)``.
 
             Where:
 
             - ``n`` is the number of taxa.
             - ``t`` is the number of traits.
         taxa : numpy.ndarray
@@ -938,18 +1021,18 @@
         # (n,t) -> (t,)
         scale = numpy.nanstd(mat, axis = 0)
 
         # if scale == 0.0, set to 1.0 (do not scale)
         scale[scale == 0.0] = 1.0
 
         # mean center and scale values
-        # scalar / (t,) -> (t,)
-        # (t,) * ( (n,t) - (t,) ) -> (n,t)
+        # scalar / (1,t) -> (1,t)
+        # (1,t) * ( (n,t) - (1,t) ) -> (n,t)
         # multiply since multiplication is faster than division for floating points
-        mat = (1.0 / scale) * (mat - location) 
+        mat = (1.0 / scale[None,:]) * (mat - location[None,:]) 
 
         # construct output
         out = cls(
             mat = mat,
             location = location,
             scale = scale,
             taxa = taxa,
@@ -1164,49 +1247,239 @@
         )
 
         return out
 
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseBreedingValueMatrix':
         """
-        Read DenseBreedingValueMatrix from an HDF5 file.
+        Read ``DenseBreedingValueMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which DenseBreedingValueMatrix data is stored.
-            If ``None``, DenseBreedingValueMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which ``DenseBreedingValueMatrix`` data is stored.
+            If ``None``, ``DenseBreedingValueMatrix`` is read from base HDF5 group.
 
         Returns
         -------
         gmat : DenseBreedingValueMatrix
-            A genotype matrix read from file.
+            A ``DenseBreedingValueMatrix`` read from file.
         """
-        check_file_exists(filename)                             # check file exists
-        h5file = h5py.File(filename, "r")                       # open HDF5 in read only
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            check_h5py_File_has_group(h5file, filename, groupname)    # check that group exists
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### check that we have all required fields
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in read (``r``) mode
+        if isinstance(filename, (str,Path)):
+            check_file_exists(filename)
+            h5file = h5py.File(filename, "r")
+
+        # elif we have an ``h5py.File``, make sure mode is in at least ``r`` mode, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_readable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # FIXME: errors if groupname == "" or "/"
+            # if the group does not exist in the file, close and raise error
+            check_h5py_File_has_group(h5file, groupname)
+
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        ######## check that we have all required fields ########
+
+        # all required arguments
+        required_fields = ["mat", "location", "scale"]
+
+        # for each required field, check if the field exists in the HDF5 file.
+        for field in required_fields:
+            check_h5py_File_has_group(h5file, groupname + field)
+        
+        ########################################################
+        ### read data from HDF5 file and (optionally) close ####
+        
+        # output dictionary
+        data = {
+            "mat"           : None,
+            "location"      : None,
+            "scale"         : None,
+            "taxa"          : None,
+            "taxa_grp"      : None,
+            "trait"         : None,
+            # metadata
+            "taxa_grp_name" : None,
+            "taxa_grp_stix" : None,
+            "taxa_grp_spix" : None,
+            "taxa_grp_len"  : None,
+        }
+
+        ##################################
+        ### read mandatory data fields ###
+
+        # read mat array (ndarray dtype = any)
+        data["mat"] = h5py_File_read_ndarray(h5file, groupname + "mat")
+        
+        # read location array (ndarray dtype = any)
+        data["location"] = h5py_File_read_ndarray(h5file, groupname + "location")
+
+        # read scale array (ndarray dtype = any)
+        data["scale"] = h5py_File_read_ndarray(h5file, groupname + "scale")
+
+        #################################
+        ### read optional data fields ###
+
+        # read taxa array (ndarray dtype = unicode / object)
+        if groupname + "taxa" in h5file:
+            data["taxa"] = h5py_File_read_ndarray_utf8(h5file, groupname + "taxa")
+
+        # read taxa_grp array (ndarray dtype = any)
+        if groupname + "taxa_grp" in h5file:
+            data["taxa_grp"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp")
+        
+        # read trait array (ndarray dtype = unicode / object)
+        if groupname + "trait" in h5file:
+            data["trait"] = h5py_File_read_ndarray_utf8(h5file, groupname + "trait")
+
+        #####################################
+        ### read optional metadata fields ###
+
+        # read taxa_grp_name array (ndarray dtype = any)
+        if groupname + "taxa_grp_name" in h5file:
+            data["taxa_grp_name"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_name")
+
+        # read taxa_grp_stix array (ndarray dtype = any)
+        if groupname + "taxa_grp_stix" in h5file:
+            data["taxa_grp_stix"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_stix")
+
+        # read taxa_grp_spix array (ndarray dtype = any)
+        if groupname + "taxa_grp_spix" in h5file:
+            data["taxa_grp_spix"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_spix")
+
+        # read taxa_grp_len array (ndarray dtype = any)
+        if groupname + "taxa_grp_len" in h5file:
+            data["taxa_grp_len"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_len")
+
+        ######################
+        ### close the file ###
+
+        # close the file, only if the provided fieldname was a string or Path an not an h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
+
+        ########################################################
+        ################### Object creation ####################
+        
+        # create object from read data
+        out = cls(
+            mat         = data["mat"],
+            location    = data["location"],
+            scale       = data["scale"],
+            taxa        = data["taxa"],
+            taxa_grp    = data["taxa_grp"],
+            trait       = data["trait"],
+        )
+
+        # copy metadata
+        out.taxa_grp_name   = data["taxa_grp_name"]
+        out.taxa_grp_stix   = data["taxa_grp_stix"]
+        out.taxa_grp_spix   = data["taxa_grp_spix"]
+        out.taxa_grp_len    = data["taxa_grp_len"]
+
+        return out
+
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in append (``r``) mode
+        if isinstance(filename, (str,Path)):
+            check_file_exists(filename)
+            h5file = h5py.File(filename, "r")
+
+        # elif we have an h5py.File, make sure mode is in at least ``r`` mode, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_readable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ######## check that we have all required fields ########
+
+        # all required arguments
         required_fields = ["mat", "location", "scale"]          # all required arguments
         for field in required_fields:                           # for each required field
             fieldname = groupname + field                       # concatenate base groupname and field
-            check_h5py_File_has_group(h5file, filename, fieldname)    # check that group exists
+            check_h5py_File_has_group(h5file, fieldname)    # check that group exists
         ######################################################### read data
         data_dict = {                                           # output dictionary
             "mat": None,
             "location": None,
             "scale": None,
             "taxa": None,
             "taxa_grp": None,
```

### Comparing `pybrops-1.0.2/pybrops/popgen/bvmat/DenseEstimatedBreedingValueMatrix.py` & `pybrops-1.0.3/pybrops/popgen/bvmat/DenseEstimatedBreedingValueMatrix.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,15 +10,17 @@
 
 from typing import Optional
 
 import numpy
 from pybrops.popgen.bvmat.DenseBreedingValueMatrix import DenseBreedingValueMatrix
 
 # TODO: add standard errors for this class; this could be used for two-stage estimation
-class DenseEstimatedBreedingValueMatrix(DenseBreedingValueMatrix):
+class DenseEstimatedBreedingValueMatrix(
+        DenseBreedingValueMatrix,
+    ):
     """
     The DenseEstimatedBreedingValueMatrix class uses a dense matrix to represent
     a Multivariate Breeding Value.
 
     Notes
     -----
     All elements within a BreedingValueMatrix are mean-centered and scaled to
```

### Comparing `pybrops-1.0.2/pybrops/popgen/bvmat/DenseGenomicEstimatedBreedingValueMatrix.py` & `pybrops-1.0.3/pybrops/popgen/bvmat/DenseGenomicEstimatedBreedingValueMatrix.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,15 +10,17 @@
 
 from typing import Optional
 
 import numpy
 from pybrops.popgen.bvmat.DenseBreedingValueMatrix import DenseBreedingValueMatrix
 
 # TODO: add standard errors for this class; this could be used for two-stage estimation
-class DenseGenomicEstimatedBreedingValueMatrix(DenseBreedingValueMatrix):
+class DenseGenomicEstimatedBreedingValueMatrix(
+        DenseBreedingValueMatrix,
+    ):
     """
     The DenseGenomicEstimatedBreedingValueMatrix class uses a dense matrix to
     represent a Multivariate Breeding Value.
 
     Notes
     -----
     All elements within a BreedingValueMatrix are mean-centered and scaled to
```

### Comparing `pybrops-1.0.2/pybrops/popgen/bvmat/__init__.py` & `pybrops-1.0.3/pybrops/popgen/bvmat/__init__.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/popgen/cmat/CoancestryMatrix.py` & `pybrops-1.0.3/pybrops/popgen/cmat/CoancestryMatrix.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,32 +3,36 @@
 """
 
 __all__ = [
     "CoancestryMatrix",
     "check_is_CoancestryMatrix",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from numbers import Real
-from typing import Optional, Union
+from pathlib import Path
+from typing import Optional
+from typing import Union
 import numpy
 from numpy.typing import DTypeLike
 import pandas
+import h5py
 from pybrops.core.io.CSVInputOutput import CSVInputOutput
 from pybrops.core.io.HDF5InputOutput import HDF5InputOutput
 from pybrops.core.io.PandasInputOutput import PandasInputOutput
 from pybrops.core.mat.SquareTaxaMatrix import SquareTaxaMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
 class CoancestryMatrix(
         SquareTaxaMatrix,
         PandasInputOutput,
         CSVInputOutput,
         HDF5InputOutput,
-        metaclass=ABCMeta,
+        metaclass = ABCMeta,
     ):
     """
     An abstract class for coancestry matrices. Coancestry matrices are square.
     Coancestry matrices are related to kinship matrices in the following manner:
 
     ..math:
         \\mathbf{K} = \\frac{1}{2}\\mathbf{A}
@@ -368,26 +372,27 @@
             Additional keyword arguments to use for dictating export to a CSV.
         """
         raise NotImplementedError("method is abstract")
 
     @abstractmethod
     def to_hdf5(
             self, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str]
         ) -> None:
         """
         Write an object to an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name to which to write.
-        groupname : str or None
-            HDF5 group name under which object data is stored.
+        filename : str, Path, h5py.File
+            If ``str``, an HDF5 file name to which to write. File is closed after writing.
+            If ``h5py.File``, an opened HDF5 file to which to write. File is not closed after writing.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which object data is stored.
             If None, object is written to the base HDF5 group.
         """
         raise NotImplementedError("method is abstract")
 
     ############################## Class Methods ###############################
 
     ###################### Matrix I/O ######################
@@ -440,27 +445,28 @@
         """
         raise NotImplementedError("class method is abstract")
 
     @classmethod
     @abstractmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str]
         ) -> 'CoancestryMatrix':
         """
         Read a ``CoancestryMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which object data is stored.
-            If None, object is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which object data is stored.
+            If ``None``, object is read from base HDF5 group.
 
         Returns
         -------
         out : CoancestryMatrix
             A ``CoancestryMatrix`` read from an HDF5 file.
         """
         raise NotImplementedError("class method is abstract")
```

### Comparing `pybrops-1.0.2/pybrops/popgen/cmat/DenseCoancestryMatrix.py` & `pybrops-1.0.3/pybrops/popgen/cmat/DenseCoancestryMatrix.py`

 * *Files 7% similar despite different names*

```diff
@@ -3,45 +3,48 @@
 """
 
 __all__ = [
     "DenseCoancestryMatrix",
     "check_is_DenseCoancestryMatrix",
 ]
 
-import math
-from numbers import Integral, Real
-from typing import Optional, Sequence, Union
+from numbers import Integral
+from numbers import Real
+from pathlib import Path
+from typing import Optional
+from typing import Sequence
+from typing import Union
 import numpy
 import warnings
 import h5py
 from numpy.typing import DTypeLike
 import pandas
-from pybrops.core.error.error_io_python import check_file_exists
+
 from pybrops.core.error.error_type_numpy import check_is_ndarray
-from pybrops.core.error.error_type_pandas import check_Series_all_type, check_is_pandas_DataFrame
-from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_type_pandas import check_Series_all_type
+from pybrops.core.error.error_type_pandas import check_is_pandas_DataFrame
 from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column
 from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column_index
 from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_column_indices
 from pybrops.core.error.error_value_pandas import check_pandas_DataFrame_has_columns
 from pybrops.core.error.error_value_pandas import check_pandas_Series_has_indices
 from pybrops.core.error.error_value_pandas import check_pandas_Series_has_values
 from pybrops.core.error.error_value_python import check_all_equal
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_object
-from pybrops.core.error.error_value_numpy import check_ndarray_has_values, check_ndarray_ndim
+from pybrops.core.error.error_value_numpy import check_ndarray_has_values
+from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.core.error.error_value_numpy import check_ndarray_axis_len
 from pybrops.core.error.error_type_python import check_Sequence_all_type
 from pybrops.core.error.error_type_python import check_is_str
 from pybrops.core.error.error_type_python import check_is_str_or_Integral
 from pybrops.core.error.error_type_python import check_is_str_or_Sequence
 from pybrops.core.error.error_value_python import check_str_value
 from pybrops.core.mat.DenseSquareTaxaMatrix import DenseSquareTaxaMatrix
-from pybrops.core.util.h5py import save_dict_to_hdf5
 from pybrops.popgen.cmat.CoancestryMatrix import CoancestryMatrix
 
 class DenseCoancestryMatrix(
         DenseSquareTaxaMatrix,
         CoancestryMatrix,
     ):
     """
@@ -82,14 +85,33 @@
         super(DenseCoancestryMatrix, self).__init__(
             mat = mat,
             taxa = taxa,
             taxa_grp = taxa_grp,
             **kwargs
         )
 
+    ########### Miscellaneous special functions ############
+    def __repr__(
+            self
+        ) -> str:
+        """
+        Return repr(self).
+        
+        Returns
+        -------
+        out : str
+            A representation of the object.
+        """
+        return "<{0} of shape (ntaxa = {1}, ntaxa = {2}) at {3}>".format(
+            type(self).__name__,
+            self.ntaxa,
+            self.ntaxa,
+            hex(id(self)),
+        )
+
     ############################ Object Properties #############################
 
     ############## Coancestry Data Properites ##############
     @DenseSquareTaxaMatrix.mat.setter
     def mat(self, value: numpy.ndarray) -> None:
         check_is_ndarray(value, "mat")
         check_all_equal(value.shape, "mat.shape")
@@ -730,46 +752,40 @@
             header = header,
             index = index,
             **kwargs
         )
 
     def to_hdf5(
             self, 
-            filename: str, 
-            groupname: Optional[str] = None
+            filename: Union[str,Path,h5py.File], 
+            groupname: Optional[str] = None,
+            overwrite: bool = True,
         ) -> None:
         """
-        Write GenotypeMatrix to an HDF5 file.
+        Write ``DenseCoancestryMatrix`` to an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name to which to write.
-        groupname : str or None
-            HDF5 group name under which the ``DenseMatrix`` data is stored.
-            If ``None``, the ``DenseMatrix`` is written to the base HDF5 group.
-        """
-        h5file = h5py.File(filename, "a")                       # open HDF5 in write mode
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### populate HDF5 file
-        data_dict = {                                           # data dictionary
-            "mat": self.mat,
-            "taxa" : self.taxa,
-            "taxa_grp" : self.taxa_grp
-        }
-        save_dict_to_hdf5(h5file, groupname, data_dict)         # save data
-        ######################################################### write conclusion
-        h5file.close()                                          # close the file
+        filename : str, Path, h5py.File
+            If ``str``, an HDF5 file name to which to write. File is closed after writing.
+            If ``h5py.File``, an opened HDF5 file to which to write. File is not closed after writing.
+
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseCoancestryMatrix`` data is stored.
+            If ``None``, the ``DenseCoancestryMatrix`` is written to the base HDF5 group.
+
+        overwrite : bool
+            Whether to overwrite values in an HDF5 file if a field already exists.
+        """
+        # call super function
+        super(DenseCoancestryMatrix, self).to_hdf5(
+            filename  = filename,
+            groupname = groupname,
+            overwrite = overwrite,
+        )
 
     ############################## Class Methods ###############################
 
     ###################### Matrix I/O ######################
     @classmethod
     def from_pandas(
             cls, 
@@ -1007,64 +1023,39 @@
         )
 
         return out
 
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseCoancestryMatrix':
         """
         Read a ``DenseCoancestryMatrix`` from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which the ``DenseCoancestryMatrix`` data is stored.
-            If None, the ``DenseCoancestryMatrix`` is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which the ``DenseCoancestryMatrix`` data is stored.
+            If ``None``, the ``DenseCoancestryMatrix`` is read from base HDF5 group.
 
         Returns
         -------
         out : DenseCoancestryMatrix
-            A dense matrix read from file.
+            A ``DenseCoancestryMatrix`` read from file.
         """
-        check_file_exists(filename)                             # check file exists
-        h5file = h5py.File(filename, "r")                       # open HDF5 in read only
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            check_h5py_File_has_group(h5file, filename, groupname)    # check that group exists
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### check that we have all required fields
-        required_fields = ["mat"]                               # all required arguments
-        for field in required_fields:                           # for each required field
-            fieldname = groupname + field                       # concatenate base groupname and field
-            check_h5py_File_has_group(h5file, filename, fieldname)    # check that group exists
-        ######################################################### read data
-        data_dict = {                                           # output dictionary
-            "mat": None,
-            "taxa" : None,
-            "taxa_grp" : None
-        }
-        for field in data_dict.keys():                          # for each field
-            fieldname = groupname + field                       # concatenate base groupname and field
-            if fieldname in h5file:                             # if the field exists in the HDF5 file
-                data_dict[field] = h5file[fieldname][()]        # read array
-        ######################################################### read conclusion
-        h5file.close()                                          # close file
-        ######################################################### create object
-        mat = cls(**data_dict)                                  # create object from read data
-        return mat
+        # call super function
+        return super(DenseCoancestryMatrix, cls).from_hdf5(
+            filename  = filename,
+            groupname = groupname,
+        )
 
 
 
 ################################## Utilities ###################################
 def check_is_DenseCoancestryMatrix(v: object, vname: str) -> None:
     """
     Check if object is of type DenseCoancestryMatrix. Otherwise raise TypeError.
```

### Comparing `pybrops-1.0.2/pybrops/popgen/cmat/DenseGeneralizedWeightedCoancestryMatrix.py` & `pybrops-1.0.3/pybrops/popgen/cmat/DenseGeneralizedWeightedCoancestryMatrix.py`

 * *Files 1% similar despite different names*

```diff
@@ -16,15 +16,17 @@
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.core.error.error_value_numpy import check_ndarray_axis_len
 from pybrops.core.error.error_value_python import check_is_in_interval_inclusive
 from pybrops.popgen.cmat.DenseCoancestryMatrix import DenseCoancestryMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import check_is_GenotypeMatrix
 
-class DenseGeneralizedWeightedCoancestryMatrix(DenseCoancestryMatrix):
+class DenseGeneralizedWeightedCoancestryMatrix(
+        DenseCoancestryMatrix,
+    ):
     """
     docstring for DenseGeneralizedWeightedCoancestryMatrix.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/popgen/cmat/DenseMolecularCoancestryMatrix.py` & `pybrops-1.0.3/pybrops/popgen/cmat/DenseMolecularCoancestryMatrix.py`

 * *Files 0% similar despite different names*

```diff
@@ -5,15 +5,17 @@
 
 from typing import Optional
 import numpy
 
 from pybrops.popgen.cmat.DenseCoancestryMatrix import DenseCoancestryMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
-class DenseMolecularCoancestryMatrix(DenseCoancestryMatrix):
+class DenseMolecularCoancestryMatrix(
+        DenseCoancestryMatrix,
+    ):
     """
     A concrete class for a dense coancestry matrix calculated using molecular
     coancestry (identity by state). Coancestry matrices are square.
 
     The purpose of this concrete class is to implement functionality for:
         1) Dense coancestry matrix value calculation.
         2) Dense coancestry matrix value access.
```

### Comparing `pybrops-1.0.2/pybrops/popgen/cmat/DenseVanRadenCoancestryMatrix.py` & `pybrops-1.0.3/pybrops/popgen/cmat/DenseVanRadenCoancestryMatrix.py`

 * *Files 1% similar despite different names*

```diff
@@ -20,15 +20,17 @@
 from pybrops.core.error.error_value_python import check_is_in_interval_inclusive
 from pybrops.core.error.error_value_numpy import check_ndarray_in_interval
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_object
 from pybrops.popgen.cmat.DenseCoancestryMatrix import DenseCoancestryMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import check_is_GenotypeMatrix
 
-class DenseVanRadenCoancestryMatrix(DenseCoancestryMatrix):
+class DenseVanRadenCoancestryMatrix(
+        DenseCoancestryMatrix,
+    ):
     """
     A concrete class for a dense coancestry matrix calculated using the VanRaden
     method. Coancestry matrices are square.
 
     The purpose of this concrete class is to implement functionality for:
         1) Dense coancestry matrix value calculation.
         2) Dense coancestry matrix value access.
```

### Comparing `pybrops-1.0.2/pybrops/popgen/cmat/DenseYangCoancestryMatrix.py` & `pybrops-1.0.3/pybrops/popgen/cmat/DenseYangCoancestryMatrix.py`

 * *Files 1% similar despite different names*

```diff
@@ -20,15 +20,17 @@
 from pybrops.core.error.error_value_python import check_is_in_interval_inclusive
 from pybrops.core.error.error_value_numpy import check_ndarray_in_interval
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_object
 from pybrops.popgen.cmat.DenseCoancestryMatrix import DenseCoancestryMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import check_is_GenotypeMatrix
 
-class DenseYangCoancestryMatrix(DenseCoancestryMatrix):
+class DenseYangCoancestryMatrix(
+        DenseCoancestryMatrix,
+    ):
     """
     A concrete class for a dense coancestry matrix calculated using the VanRaden
     method. Coancestry matrices are square.
 
     The purpose of this concrete class is to implement functionality for:
         1) Dense coancestry matrix value calculation.
         2) Dense coancestry matrix value access.
```

### Comparing `pybrops-1.0.2/pybrops/popgen/cmat/__init__.py` & `pybrops-1.0.3/pybrops/popgen/cmat/__init__.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/popgen/cmat/fcty/CoancestryMatrixFactory.py` & `pybrops-1.0.3/pybrops/popgen/cmat/fcty/CoancestryMatrixFactory.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,19 +3,22 @@
 """
 
 __all__ = [
     "CoancestryMatrixFactory",
     "check_is_CoancestryMatrixFactory",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.popgen.cmat.CoancestryMatrix import CoancestryMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
-class CoancestryMatrixFactory(metaclass=ABCMeta):
+class CoancestryMatrixFactory(
+        metaclass = ABCMeta,
+    ):
     """
     Factory class for producing CoancestryMatrix objects.
     """
 
     ########################## Special Object Methods ##########################
 
     ############################## Object Methods ##############################
```

### Comparing `pybrops-1.0.2/pybrops/popgen/cmat/fcty/DenseCoancestryMatrixFactory.py` & `pybrops-1.0.3/pybrops/popgen/cmat/fcty/DenseCoancestryMatrixFactory.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,15 +7,17 @@
     "check_is_DenseCoancestryMatrixFactory",
 ]
 
 from pybrops.popgen.cmat.DenseCoancestryMatrix import DenseCoancestryMatrix
 from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import CoancestryMatrixFactory
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
-class DenseCoancestryMatrixFactory(CoancestryMatrixFactory):
+class DenseCoancestryMatrixFactory(
+        CoancestryMatrixFactory,
+    ):
     """
     Factory class for producing CoancestryMatrix objects.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/popgen/cmat/fcty/DenseGeneralizedWeightedCoancestryMatrixFactory.py` & `pybrops-1.0.3/pybrops/popgen/cmat/fcty/DenseGeneralizedWeightedCoancestryMatrixFactory.py`

 * *Files 4% similar despite different names*

```diff
@@ -10,15 +10,17 @@
 from numbers import Real
 from typing import Union
 import numpy
 from pybrops.popgen.cmat.DenseGeneralizedWeightedCoancestryMatrix import DenseGeneralizedWeightedCoancestryMatrix
 from pybrops.popgen.cmat.fcty.DenseCoancestryMatrixFactory import DenseCoancestryMatrixFactory
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
-class DenseGeneralizedWeightedCoancestryMatrixFactory(DenseCoancestryMatrixFactory):
+class DenseGeneralizedWeightedCoancestryMatrixFactory(
+        DenseCoancestryMatrixFactory,
+    ):
     """
     Factory class for producing CoancestryMatrix objects.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/popgen/cmat/fcty/DenseMolecularCoancestryMatrixFactory.py` & `pybrops-1.0.3/pybrops/popgen/cmat/fcty/DenseMolecularCoancestryMatrixFactory.py`

 * *Files 3% similar despite different names*

```diff
@@ -7,15 +7,17 @@
     "check_is_DenseMolecularCoancestryMatrixFactory",
 ]
 
 from pybrops.popgen.cmat.DenseMolecularCoancestryMatrix import DenseMolecularCoancestryMatrix
 from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import CoancestryMatrixFactory
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
-class DenseMolecularCoancestryMatrixFactory(CoancestryMatrixFactory):
+class DenseMolecularCoancestryMatrixFactory(
+        CoancestryMatrixFactory,
+    ):
     """
     Factory class for producing CoancestryMatrix objects.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/popgen/cmat/fcty/DenseVanRadenCoancestryMatrixFactory.py` & `pybrops-1.0.3/pybrops/popgen/cmat/fcty/DenseVanRadenCoancestryMatrixFactory.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,15 +10,17 @@
 from typing import Union
 
 import numpy
 from pybrops.popgen.cmat.DenseVanRadenCoancestryMatrix import DenseVanRadenCoancestryMatrix
 from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import CoancestryMatrixFactory
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
-class DenseVanRadenCoancestryMatrixFactory(CoancestryMatrixFactory):
+class DenseVanRadenCoancestryMatrixFactory(
+        CoancestryMatrixFactory,
+    ):
     """
     Factory class for producing CoancestryMatrix objects.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/popgen/cmat/fcty/DenseYangCoancestryMatrixFactory.py` & `pybrops-1.0.3/pybrops/popgen/cmat/fcty/DenseYangCoancestryMatrixFactory.py`

 * *Files 6% similar despite different names*

```diff
@@ -4,22 +4,23 @@
 
 __all__ = [
     "DenseYangCoancestryMatrixFactory",
     "check_is_DenseYangCoancestryMatrixFactory",
 ]
 
 from typing import Union
-
 import numpy
+
 from pybrops.popgen.cmat.DenseYangCoancestryMatrix import DenseYangCoancestryMatrix
 from pybrops.popgen.cmat.fcty.CoancestryMatrixFactory import CoancestryMatrixFactory
-
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
-class DenseYangCoancestryMatrixFactory(CoancestryMatrixFactory):
+class DenseYangCoancestryMatrixFactory(
+        CoancestryMatrixFactory,
+    ):
     """
     Factory class for producing CoancestryMatrix objects.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
             self,
```

### Comparing `pybrops-1.0.2/pybrops/popgen/cmat/fcty/__init__.py` & `pybrops-1.0.3/pybrops/popgen/cmat/fcty/__init__.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/popgen/gmap/DenseGeneticMappableMatrix.py` & `pybrops-1.0.3/pybrops/popgen/gmap/DenseGeneticMappableMatrix.py`

 * *Files 6% similar despite different names*

```diff
@@ -8,19 +8,24 @@
     "check_is_DenseGeneticMappableMatrix",
 ]
 
 from typing import Optional
 
 import numpy
 from pybrops.core.mat.DenseVariantMatrix import DenseVariantMatrix
-from pybrops.popgen.gmap.GeneticMap import GeneticMap, check_is_GeneticMap
+from pybrops.popgen.gmap.GeneticMap import GeneticMap
+from pybrops.popgen.gmap.GeneticMap import check_is_GeneticMap
 from pybrops.popgen.gmap.GeneticMappableMatrix import GeneticMappableMatrix
-from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction, check_is_GeneticMapFunction
+from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
+from pybrops.popgen.gmap.GeneticMapFunction import check_is_GeneticMapFunction
 
-class DenseGeneticMappableMatrix(DenseVariantMatrix,GeneticMappableMatrix):
+class DenseGeneticMappableMatrix(
+        DenseVariantMatrix,
+        GeneticMappableMatrix,
+    ):
     """
     Concrete class for dense variant matrices that can be interpolated using a
     GeneticMap.
     """
 
     ########################## Special Object Methods ##########################
     def __init__(
```

### Comparing `pybrops-1.0.2/pybrops/popgen/gmap/ExtendedGeneticMap.py` & `pybrops-1.0.3/pybrops/popgen/gmap/ExtendedGeneticMap.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,15 +6,18 @@
 __all__ = [
     "ExtendedGeneticMap",
     "check_is_ExtendedGeneticMap",
 ]
 
 import copy
 from numbers import Integral
-from typing import Optional, Sequence, Tuple, Union
+from typing import Optional
+from typing import Sequence
+from typing import Tuple
+from typing import Union
 import numpy
 import math
 import pandas
 import warnings
 from scipy.interpolate import interp1d
 
 from pybrops.core.error.error_type_numpy import check_is_ndarray
@@ -27,15 +30,17 @@
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.core.error.error_type_python import check_is_str_or_Integral
 from pybrops.core.error.error_type_python import check_is_str
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_object
 from pybrops.popgen.gmap.GeneticMap import GeneticMap
 
-class ExtendedGeneticMap(GeneticMap):
+class ExtendedGeneticMap(
+        GeneticMap,
+    ):
     """
     A concrete class for representing an extended genetic map format.
 
     The purpose of this concrete class is to implement functionality for:
         1) Extended genetic map representation.
         2) Extended genetic map metadata.
         3) Extended genetic map routines.
```

### Comparing `pybrops-1.0.2/pybrops/popgen/gmap/GeneticMap.py` & `pybrops-1.0.3/pybrops/popgen/gmap/GeneticMap.py`

 * *Files 2% similar despite different names*

```diff
@@ -3,22 +3,25 @@
 """
 
 __all__ = [
     "GeneticMap",
     "check_is_GeneticMap",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from numbers import Integral
-from typing import Optional, Sequence, Union
+from typing import Optional
+from typing import Sequence
+from typing import Union
 import numpy
 from numpy.typing import ArrayLike
 import pandas
-from pybrops.core.io.CSVInputOutput import CSVInputOutput
 
+from pybrops.core.io.CSVInputOutput import CSVInputOutput
 from pybrops.core.io.PandasInputOutput import PandasInputOutput
 
 class GeneticMap(
         PandasInputOutput,
         CSVInputOutput,
         metaclass = ABCMeta,
     ):
```

### Comparing `pybrops-1.0.2/pybrops/popgen/gmap/GeneticMapFunction.py` & `pybrops-1.0.3/pybrops/popgen/gmap/GeneticMapFunction.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,19 +4,22 @@
 """
 
 __all__ = [
     "GeneticMapFunction",
     "check_is_GeneticMapFunction",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 import numpy
 from pybrops.popgen.gmap.GeneticMap import GeneticMap
 
-class GeneticMapFunction(metaclass=ABCMeta):
+class GeneticMapFunction(
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for genetic map function objects.
 
     The purpose of this abstract class is to define base functionality for:
         1) Converting genetic distance to recombination probability.
         2) Converting recombination probability to genetic distance.
         3) Converting physical distance to recombination probability.
```

### Comparing `pybrops-1.0.2/pybrops/popgen/gmap/GeneticMappableMatrix.py` & `pybrops-1.0.3/pybrops/popgen/gmap/GeneticMappableMatrix.py`

 * *Files 3% similar despite different names*

```diff
@@ -4,20 +4,24 @@
 """
 
 __all__ = [
     "GeneticMappableMatrix",
     "check_is_GeneticMappableMatrix",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from pybrops.core.mat.VariantMatrix import VariantMatrix
 from pybrops.popgen.gmap.GeneticMap import GeneticMap
 from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
 
-class GeneticMappableMatrix(VariantMatrix,metaclass=ABCMeta):
+class GeneticMappableMatrix(
+        VariantMatrix,
+        metaclass = ABCMeta,
+    ):
     """
     Abstract class for variant matrices that can be interpolated using a
     GeneticMap.
     """
 
     ########################## Special Object Methods ##########################
```

### Comparing `pybrops-1.0.2/pybrops/popgen/gmap/HaldaneMapFunction.py` & `pybrops-1.0.3/pybrops/popgen/gmap/HaldaneMapFunction.py`

 * *Files 0% similar despite different names*

```diff
@@ -7,15 +7,17 @@
     "check_is_HaldaneMapFunction",
 ]
 
 import numpy
 from pybrops.popgen.gmap.GeneticMap import GeneticMap
 from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
 
-class HaldaneMapFunction(GeneticMapFunction):
+class HaldaneMapFunction(
+        GeneticMapFunction,
+    ):
     """
     A concrete class for the Haldane genetic map function.
 
     The purpose of this concrete class is to implement functionality for:
         1) Converting genetic distance to recombination probability.
         2) Converting recombination probability to genetic distance.
         3) Converting physical distance to recombination probability.
```

### Comparing `pybrops-1.0.2/pybrops/popgen/gmap/KosambiMapFunction.py` & `pybrops-1.0.3/pybrops/popgen/gmap/KosambiMapFunction.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,15 +7,17 @@
     "check_is_KosambiMapFunction",
 ]
 
 import numpy
 from pybrops.popgen.gmap.GeneticMap import GeneticMap
 from pybrops.popgen.gmap.GeneticMapFunction import GeneticMapFunction
 
-class KosambiMapFunction(GeneticMapFunction):
+class KosambiMapFunction(
+        GeneticMapFunction,
+    ):
     """
     A concrete class for the Kosambi genetic map function.
 
     The purpose of this concrete class is to implement functionality for:
         1) Converting genetic distance to recombination probability.
         2) Converting recombination probability to genetic distance.
         3) Converting physical distance to recombination probability.
```

### Comparing `pybrops-1.0.2/pybrops/popgen/gmap/StandardGeneticMap.py` & `pybrops-1.0.3/pybrops/popgen/gmap/StandardGeneticMap.py`

 * *Files 0% similar despite different names*

```diff
@@ -6,15 +6,18 @@
 __all__ = [
     "StandardGeneticMap",
     "check_is_StandardGeneticMap",
 ]
 
 import copy
 from numbers import Integral
-from typing import Optional, Sequence, Tuple, Union
+from typing import Optional
+from typing import Sequence
+from typing import Tuple
+from typing import Union
 import warnings
 import numpy
 import pandas
 from scipy.interpolate import interp1d
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_numpy import check_is_str_or_ndarray
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_floating
@@ -25,15 +28,17 @@
 from pybrops.core.error.error_type_python import check_is_dict
 from pybrops.core.error.error_type_python import check_is_str
 from pybrops.core.error.error_type_python import check_is_str_or_Integral
 from pybrops.core.error.error_value_python import check_tuple_len_eq
 from pybrops.popgen.gmap.GeneticMap import GeneticMap
 
 
-class StandardGeneticMap(GeneticMap):
+class StandardGeneticMap(
+        GeneticMap,
+    ):
     """
     A concrete class for representing a standard genetic map format.
 
     The purpose of this concrete class is to implement functionality for:
         1) Genetic map representation.
         2) Genetic map metadata.
         3) Genetic map routines.
```

### Comparing `pybrops-1.0.2/pybrops/popgen/gmap/__init__.py` & `pybrops-1.0.3/pybrops/popgen/gmap/__init__.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/popgen/gmap/util.py` & `pybrops-1.0.3/pybrops/popgen/gmap/util.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/popgen/gmat/DenseGenotypeMatrix.py` & `pybrops-1.0.3/pybrops/popgen/gmat/DenseGenotypeMatrix.py`

 * *Files 15% similar despite different names*

```diff
@@ -6,30 +6,40 @@
 __all__ = [
     "DenseGenotypeMatrix",
     "check_is_DenseGenotypeMatrix",
 ]
 
 import copy
 from numbers import Real
-from typing import Optional, Sequence, Union
+from pathlib import Path
+from typing import Optional
+from typing import Sequence
+from typing import Union
 import cyvcf2
 import h5py
 import numpy
-from numpy.typing import DTypeLike, ArrayLike
+from numpy.typing import DTypeLike
+from numpy.typing import ArrayLike
 
 from pybrops.core.error.error_io_python import check_file_exists
 from pybrops.core.error.error_type_python import check_is_int
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_int8
 from pybrops.core.error.error_attr_python import error_readonly
 from pybrops.core.error.error_value_h5py import check_h5py_File_has_group
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_readable
+from pybrops.core.error.error_value_h5py import check_h5py_File_is_writable
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.core.mat.Matrix import Matrix
 from pybrops.core.mat.DenseTaxaVariantMatrix import DenseTaxaVariantMatrix
-from pybrops.core.util.h5py import save_dict_to_hdf5
+from pybrops.core.util.h5py import h5py_File_read_int
+from pybrops.core.util.h5py import h5py_File_read_ndarray
+from pybrops.core.util.h5py import h5py_File_read_ndarray_int8
+from pybrops.core.util.h5py import h5py_File_read_ndarray_utf8
+from pybrops.core.util.h5py import h5py_File_write_dict
 from pybrops.popgen.gmap.DenseGeneticMappableMatrix import DenseGeneticMappableMatrix
 from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
 
 class DenseGenotypeMatrix(
         DenseTaxaVariantMatrix,
         DenseGeneticMappableMatrix,
         GenotypeMatrix,
@@ -64,59 +74,116 @@
             **kwargs: dict
         ) -> None:
         """
         Parameters
         ----------
         mat : numpy.ndarray
             An int8 haplotype matrix. Must be {0,1,2} format.
+        
         taxa : numpy.ndarray, None
-            A numpy.ndarray of shape ``(n,)`` containing taxa names.
+            A ``numpy.ndarray`` of shape ``(n,)`` containing taxa names.
             If ``None``, do not store any taxa name information.
+        
+            Where:
+
+            - ``n`` is the number of taxa.
+
         taxa_grp : numpy.ndarray, None
-            A numpy.ndarray of shape ``(n,)`` containing taxa groupings.
+            A ``numpy.ndarray`` of shape ``(n,)`` containing taxa groupings.
             If ``None``, do not store any taxa group information.
+        
+            Where:
+
+            - ``n`` is the number of taxa.
+
         vrnt_chrgrp : numpy.ndarray, None
-            A numpy.ndarray of shape ``(p,)`` containing variant chromosome
+            A ``numpy.ndarray`` of shape ``(p,)`` containing variant chromosome
             group labels. If ``None``, do not store any variant chromosome group
             label information.
+
+            Where:
+
+            - ``p`` is the number of variants.
+
         vrnt_phypos : numpy.ndarray, None
-            A numpy.ndarray of shape ``(p,)`` containing variant chromosome
+            A ``numpy.ndarray`` of shape ``(p,)`` containing variant chromosome
             physical positions. If ``None``, do not store any variant chromosome
             physical position information.
+        
+            Where:
+
+            - ``p`` is the number of variants.
+
         vrnt_name : numpy.ndarray, None
-            A numpy.ndarray of shape ``(p,)`` containing variant names.
+            A ``numpy.ndarray`` of shape ``(p,)`` containing variant names.
             If ``None``, do not store any variant names.
+        
+            Where:
+
+            - ``p`` is the number of variants.
+
         vrnt_genpos : numpy.ndarray, None
-            A numpy.ndarray of shape ``(p,)`` containing variant chromosome
+            A ``numpy.ndarray`` of shape ``(p,)`` containing variant chromosome
             genetic positions. If ``None``, do not store any variant chromosome
             genetic position information.
+        
+            Where:
+
+            - ``p`` is the number of variants.
+
         vrnt_xoprob : numpy.ndarray, None
-            A numpy.ndarray of shape ``(p,)`` containing variant crossover
+            A ``numpy.ndarray`` of shape ``(p,)`` containing variant crossover
             probabilities. If ``None``, do not store any variant crossover
             probabilities.
+        
+            Where:
+
+            - ``p`` is the number of variants.
+
         vrnt_hapgrp : numpy.ndarray, None
-            A numpy.ndarray of shape ``(p,)`` containing variant haplotype
+            A ``numpy.ndarray`` of shape ``(p,)`` containing variant haplotype
             group labels. If ``None``, do not store any variant haplotype group
             label information.
+        
+            Where:
+
+            - ``p`` is the number of variants.
+
         vrnt_hapalt : numpy.ndarray, None
-            A numpy.ndarray of shape ``(p,)`` containing variant alternative
+            A ``numpy.ndarray`` of shape ``(p,)`` containing variant alternative
             alleles. If ``None``, do not store any variant alternative allele
             information.
+        
+            Where:
+
+            - ``p`` is the number of variants.
+
         vrnt_hapref : numpy.ndarray, None
-            A numpy.ndarray of shape ``(p,)`` containing variant reference
+            A ``numpy.ndarray`` of shape ``(p,)`` containing variant reference
             alleles. If ``None``, do not store any variant reference allele
             information.
+        
+            Where:
+
+            - ``p`` is the number of variants.
+
         vrnt_mask : numpy.ndarray, None
-            A numpy.ndarray of shape ``(p,)`` containing a variant mask.
+            A ``numpy.ndarray`` of shape ``(p,)`` containing a variant mask.
             If ``None``, do not store any variant mask information.
+        
+            Where:
+
+            - ``p`` is the number of variants.
+
         ploidy : int
             The ploidy represented by the genotype matrix. This only represents
             ploidy of the reproductive habit. If the organism represented is an
             allopolyploid (e.g. hexaploid wheat), the ploidy is 2 since it
             reproduces in a diploid manner.
+        
         kwargs : dict
             Additional keyword arguments.
         """
         # set ploidy
         check_is_int(ploidy, "ploidy")
         self._ploidy = ploidy
 
@@ -221,14 +288,35 @@
         out.vrnt_chrgrp_name = copy.deepcopy(self.vrnt_chrgrp_name, memo)
         out.vrnt_chrgrp_stix = copy.deepcopy(self.vrnt_chrgrp_stix, memo)
         out.vrnt_chrgrp_spix = copy.deepcopy(self.vrnt_chrgrp_spix, memo)
         out.vrnt_chrgrp_len = copy.deepcopy(self.vrnt_chrgrp_len, memo)
 
         return out
 
+    ########### Miscellaneous special functions ############
+    def __repr__(
+            self
+        ) -> str:
+        """
+        Return repr(self).
+        
+        Returns
+        -------
+        out : str
+            A representation of the object.
+        """
+        return "<{0} of shape (nphase = {1}, ntaxa = {2}, nvrnt = {3}) with ploidy = {4} at {5}>".format(
+            type(self).__name__,
+            self.nphase,
+            self.ntaxa,
+            self.nvrnt,
+            self.ploidy,
+            hex(id(self)),
+        )
+
     ############################ Object Properties #############################
 
     ############## Genotype Data Properites ##############
     @DenseTaxaVariantMatrix.mat.setter
     def mat(self, value: numpy.ndarray) -> None:
         check_is_ndarray(value, "mat")
         check_ndarray_dtype_is_int8(value, "mat")
@@ -752,21 +840,21 @@
         ) -> numpy.ndarray:
         """
         Allele count of the non-zero allele within each taxon.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the accumulator and returned array.
+            The data type of the accumulator and returned array.
             If ``None``, use the native accumulator type (int or float).
 
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(n,p)`` containing allele counts of the
+            A ``numpy.ndarray`` of shape ``(n,p)`` containing allele counts of the
             allele coded as ``1`` for all ``n`` individuals, for all ``p`` loci.
         """
         # get accumulator type
         if dtype is None:
             if numpy.issubdtype(self._mat.dtype, numpy.integer):
                 dtype = int
             elif numpy.issubdtype(self._mat.dtype, numpy.floating):
@@ -783,20 +871,21 @@
         ) -> numpy.ndarray:
         """
         Allele frequency of the non-zero allele within each taxon.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(n,p)`` containing allele frequencies of
+            A ``numpy.ndarray`` of shape ``(n,p)`` containing allele frequencies of
             the allele coded as ``1`` for all ``n`` individuals, for all ``p``
             loci.
         """
         rnphase = 1.0 / self.ploidy         # take the reciprocal of the ploidy number
         out = rnphase * self._mat           # take sum across the phase axis (0) and divide by ploidy
         if dtype is not None:               # if dtype is specified
             dtype = numpy.dtype(dtype)      # ensure conversion to dtype class
@@ -810,20 +899,20 @@
         ) -> numpy.ndarray:
         """
         Allele count of the non-zero allele across all taxa.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the accumulator and returned array. If ``None``, use the native integer type.
+            The data type of the accumulator and returned array. If ``None``, use the native integer type.
 
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(p,)`` containing allele counts of the
+            A ``numpy.ndarray`` of shape ``(p,)`` containing allele counts of the
             allele coded as ``1`` for all ``p`` loci.
         """
         # process dtype
         if dtype is None:
             dtype = int
         dtype = numpy.dtype(dtype)
 
@@ -838,57 +927,89 @@
         ) -> numpy.ndarray:
         """
         Allele frequency of the non-zero allele across all taxa.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(p,)`` containing allele frequencies of
+            A ``numpy.ndarray`` of shape ``(p,)`` containing allele frequencies of
             the allele coded as ``1`` for all ``p`` loci.
         """
         denom = (self.ploidy * self.ntaxa)              # get ploidy * ntaxa
         rnphase = 1.0 / denom                           # take 1 / (ploidy * ntaxa)
         out = rnphase * self._mat.sum(self.taxa_axis)   # take sum across the taxa axis (0) and divide by nphase
         if dtype is not None:                           # if dtype is specified
             dtype = numpy.dtype(dtype)                  # ensure conversion to dtype class
             if out.dtype != dtype:                      # if output dtype and desired are different
                 out = dtype.type(out)                   # convert to correct dtype
         return out
 
+    def afixed(
+            self,
+            dtype: Optional[DTypeLike] = None,
+        ) -> numpy.ndarray:
+        """
+        Determine allele fixation for loci across all taxa.
+
+        Parameters
+        ----------
+        dtype : dtype, None
+            The data type of the returned array. 
+            If ``None``, use the native type.
+        
+        Returns
+        -------
+        out : numpy.ndarray
+            A ``numpy.ndarray`` of shape ``(p,)`` containing indicator variables 
+            for whether a locus is fixed at a particular locus.
+        """
+        # get the allele frequency
+        afreq = self.afreq()
+
+        # determine whether the allele frequency is equal to 0.0 or 1.0
+        out = (afreq == 0.0) | (afreq == 1.0)
+
+        # convert to specific dtype if needed
+        if dtype is not None:                           # if dtype is specified
+            dtype = numpy.dtype(dtype)                  # ensure conversion to dtype class
+            if out.dtype != dtype:                      # if output dtype and desired are different
+                out = dtype.type(out)                   # convert to correct dtype
+
+        return out
+
     def apoly(
             self, 
             dtype: Optional[DTypeLike] = None
         ) -> numpy.ndarray:
         """
         Allele polymorphism presence or absense across all loci.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(p,)`` containing indicator variables for
+            A ``numpy.ndarray`` of shape ``(p,)`` containing indicator variables for
             whether the locus is polymorphic.
         """
-        # find any loci that are monomorphic for 0 allele
-        min_mask = numpy.all(self.mat == 0, axis = self.taxa_axis)
-
-        # find any loci that are monomorphic for 1 allele
-        max_mask = numpy.all(self.mat == self.ploidy, axis = self.taxa_axis)
+        # get the allele frequency
+        afreq = self.afreq()
 
-        # logical or results and take logical not
-        out = numpy.logical_not(min_mask | max_mask)
+        # determine whether the allele frequency is between 0.0 and 1.0
+        out = (afreq > 0.0) & (afreq < 1.0)
 
         # convert to specific dtype if needed
         if dtype is not None:                           # if dtype is specified
             dtype = numpy.dtype(dtype)                  # ensure conversion to dtype class
             if out.dtype != dtype:                      # if output dtype and desired are different
                 out = dtype.type(out)                   # convert to correct dtype
 
@@ -900,20 +1021,21 @@
         ) -> numpy.ndarray:
         """
         Minor allele frequency across all taxa.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray of shape ``(p,)`` containing allele frequencies for
+            A ``numpy.ndarray`` of shape ``(p,)`` containing allele frequencies for
             the minor allele.
         """
         out = self.afreq(dtype)     # get allele frequencies
         mask = out > 0.5            # create mask of allele frequencies > 0.5
         out[mask] = 1.0 - out[mask] # take 1 - allele frequency
         return out
 
@@ -923,15 +1045,16 @@
         ) -> Real:
         """
         Mean expected heterozygosity across all taxa.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : Real
             A number representing the mean expected heterozygous.
             If ``dtype`` is ``None``, then a native 64-bit floating point is
             returned. Otherwise, of type specified by ``dtype``.
@@ -954,20 +1077,21 @@
         """
         Gather genotype counts for homozygous major, heterozygous, homozygous
         minor for all individuals.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray array of shape ``(g,p)`` containing allele counts
+            A ``numpy.ndarray`` array of shape ``(g,p)`` containing allele counts
             across all ``p`` loci for each of ``g`` genotype combinations.
 
             Where:
 
             - ``out[0]`` is the count of ``0`` genotype across all loci
             - ``out[1]`` is the count of ``1`` genotype across all loci
             - ``out[2]`` is the count of ``2`` genotype across all loci
@@ -1002,20 +1126,21 @@
         """
         Gather genotype frequencies for homozygous major, heterozygous,
         homozygous minor across all individuals.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
-            A numpy.ndarray array of shape ``(g,p)`` containing haplotype counts
+            A ``numpy.ndarray`` array of shape ``(g,p)`` containing haplotype counts
             across all ``p`` loci for all ``g`` genotype combinations.
 
             Where:
 
             - ``out[0]`` is the frequency of ``0`` genotype across all loci
             - ``out[1]`` is the frequency of ``1`` genotype across all loci
             - ``out[2]`` is the frequency of ``2`` genotype across all loci
@@ -1029,148 +1154,358 @@
             if out.dtype != dtype:      # if output dtype and desired are different
                 out = dtype.type(out)   # convert to correct dtype
         return out
 
     ################### Matrix File I/O ####################
     def to_hdf5(
             self, 
-            filename: str, 
-            groupname: Optional[str] = None
+            filename: Union[str,Path,h5py.File], 
+            groupname: Optional[str] = None,
+            overwrite: bool = True,
         ) -> None:
         """
         Write GenotypeMatrix to an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name to which to write.
-        groupname : str or None
-            HDF5 group name under which GenotypeMatrix data is stored.
+        filename : str, Path, h5py.File
+            If ``str``, an HDF5 file name to which to write. File is closed after writing.
+            If ``h5py.File``, an opened HDF5 file to which to write. File is not closed after writing.
+
+        groupname : str, None
+            If ``str``, an HDF5 group name under which GenotypeMatrix data is stored.
             If None, GenotypeMatrix is written to the base HDF5 group.
+
+        overwrite : bool
+            Whether to overwrite values in an HDF5 file if a field already exists.
         """
-        h5file = h5py.File(filename, "a")                       # open HDF5 in write mode
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### populate HDF5 file
-        data_dict = {                                           # data dictionary
-            "mat": self.mat,
-            "taxa" : self.taxa,
-            "taxa_grp" : self.taxa_grp,
-            "vrnt_chrgrp" : self.vrnt_chrgrp,
-            "vrnt_phypos" : self.vrnt_phypos,
-            "vrnt_name" : self.vrnt_name,
-            "vrnt_genpos" : self.vrnt_genpos,
-            "vrnt_xoprob" : self.vrnt_xoprob,
-            "vrnt_hapgrp" : self.vrnt_hapgrp,
-            "vrnt_hapalt" : self.vrnt_hapalt,
-            "vrnt_hapref" : self.vrnt_hapref,
-            "vrnt_mask" : self.vrnt_mask,
-            "ploidy" : self.ploidy
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in append (``r+``) mode
+        if isinstance(filename, (str,Path)):
+            h5file = h5py.File(filename, "a")
+
+        # elif we have an h5py.File, make sure mode is writable, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_writable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
+            )
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
+            )
+
+        ########################################################
+        #### write data to HDF5 file and (optionally) close ####
+
+        # data dictionary
+        data = {
+            "mat"               : self.mat,
+            "taxa"              : self.taxa,
+            "taxa_grp"          : self.taxa_grp,
+            "vrnt_chrgrp"       : self.vrnt_chrgrp,
+            "vrnt_phypos"       : self.vrnt_phypos,
+            "vrnt_name"         : self.vrnt_name,
+            "vrnt_genpos"       : self.vrnt_genpos,
+            "vrnt_xoprob"       : self.vrnt_xoprob,
+            "vrnt_hapgrp"       : self.vrnt_hapgrp,
+            "vrnt_hapalt"       : self.vrnt_hapalt,
+            "vrnt_hapref"       : self.vrnt_hapref,
+            "vrnt_mask"         : self.vrnt_mask,
+            "ploidy"            : self.ploidy,
+            # metadata
+            "taxa_grp_name"     : self.taxa_grp_name,
+            "taxa_grp_stix"     : self.taxa_grp_stix,
+            "taxa_grp_spix"     : self.taxa_grp_spix,
+            "taxa_grp_len"      : self.taxa_grp_len,
+            "vrnt_chrgrp_name"  : self.vrnt_chrgrp_name,
+            "vrnt_chrgrp_stix"  : self.vrnt_chrgrp_stix,
+            "vrnt_chrgrp_spix"  : self.vrnt_chrgrp_spix,
+            "vrnt_chrgrp_len"   : self.vrnt_chrgrp_len,
         }
-        save_dict_to_hdf5(h5file, groupname, data_dict)         # save data
-        ######################################################### write conclusion
-        h5file.close()                                          # close the file
+
+        # save data
+        h5py_File_write_dict(h5file, groupname, data, overwrite)
+
+        # close the file, only if the provided filename was a string or Path and not a h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
 
     ############################## Class Methods ###############################
 
     ################### Matrix File I/O ####################
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DenseGenotypeMatrix':
         """
         Read GenotypeMatrix from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which GenotypeMatrix data is stored.
-            If None, GenotypeMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, an HDF5 group name under which GenotypeMatrix data is stored.
+            If ``None``, GenotypeMatrix is read from base HDF5 group.
 
         Returns
         -------
         gmat : GenotypeMatrix
             A genotype matrix read from file.
         """
-        check_file_exists(filename)                             # check file exists
-        h5file = h5py.File(filename, "r")                       # open HDF5 in read only
-        ######################################################### process groupname argument
-        if isinstance(groupname, str):                          # if we have a string
-            check_h5py_File_has_group(h5file, filename, groupname)    # check that group exists
-            if groupname[-1] != '/':                            # if last character in string is not '/'
-                groupname += '/'                                # add '/' to end of string
-        elif groupname is None:                                 # else if groupname is None
-            groupname = ""                                      # empty string
-        else:                                                   # else raise error
-            raise TypeError("'groupname' must be of type str or None")
-        ######################################################### check that we have all required fields
-        required_fields = ["mat"]                               # all required arguments
-        for field in required_fields:                           # for each required field
-            fieldname = groupname + field                       # concatenate base groupname and field
-            check_h5py_File_has_group(h5file, filename, fieldname)    # check that group exists
-        ######################################################### read data
-        data_dict = {                                           # output dictionary
-            "mat": None,
-            "taxa" : None,
-            "taxa_grp" : None,
-            "vrnt_chrgrp" : None,
-            "vrnt_phypos" : None,
-            "vrnt_name" : None,
-            "vrnt_genpos" : None,
-            "vrnt_xoprob" : None,
-            "vrnt_hapgrp" : None,
-            "vrnt_hapalt" : None,
-            "vrnt_hapref" : None,
-            "vrnt_mask" : None,
-            "ploidy" : None
-        }
-        for field in data_dict.keys():                          # for each field
-            fieldname = groupname + field                       # concatenate base groupname and field
-            if fieldname in h5file:                             # if the field exists in the HDF5 file
-                data_dict[field] = h5file[fieldname][()]        # read array
-        # fieldname = groupname + "ploidy"                        # special case for reading ploidy ()
-        # if fieldname in h5file:
-        #     data_dict["ploidy"] = h5file[fieldname][]
-        ######################################################### read conclusion
-        h5file.close()                                          # close file
-        if data_dict["taxa"] is not None:
-            data_dict["taxa"] = numpy.array(                    # convert taxa strings from byte to utf-8
-                [s.decode("utf-8") for s in data_dict["taxa"]],
-                dtype = object
-            )
-        if data_dict["vrnt_name"] is not None:
-            data_dict["vrnt_name"] = numpy.array(               # convert vrnt_name string from byte to utf-8
-                [s.decode("utf-8") for s in data_dict["vrnt_name"]],
-                dtype = object
-            )
-        if data_dict["vrnt_hapgrp"] is not None:
-            data_dict["vrnt_hapgrp"] = numpy.array(             # convert vrnt_hapgrp string from byte to utf-8
-                [s.decode("utf-8") for s in data_dict["vrnt_hapgrp"]],
-                dtype = object
+        ########################################################
+        ############ process ``filename`` argument #############
+
+        # HDF5 file object
+        h5file = None
+
+        # if we have a string or Path, open HDF5 file in read (``r``) mode
+        if isinstance(filename, (str,Path)):
+            check_file_exists(filename)
+            h5file = h5py.File(filename, "r")
+
+        # elif we have an ``h5py.File``, make sure mode is in at least ``r`` mode, and copy pointer
+        elif isinstance(filename, h5py.File):
+            check_h5py_File_is_readable(filename)
+            h5file = filename
+        
+        # else raise TypeError
+        else:
+            raise TypeError(
+                "``filename`` must be of type ``str``, ``Path``, or ``h5py.File`` but received type ``{0}``".format(
+                    type(filename).__name__
+                )
             )
-        if data_dict["vrnt_hapalt"] is not None:
-            data_dict["vrnt_hapalt"] = numpy.array(             # convert vrnt_hapalt string from byte to utf-8
-                [s.decode("utf-8") for s in data_dict["vrnt_hapalt"]],
-                dtype = object
+
+        ########################################################
+        ############ process ``groupname`` argument ############
+
+        # if we have a string
+        if isinstance(groupname, str):
+            # FIXME: errors if groupname == "" or "/"
+            # if the group does not exist in the file, close and raise error
+            check_h5py_File_has_group(h5file, groupname)
+
+            # if last character in string is not '/', add '/' to end of string
+            if groupname[-1] != '/':
+                groupname += '/'
+        
+        # else if ``groupname`` is None, set ``groupname`` to empty string
+        elif groupname is None:
+            groupname = ""
+        
+        # else raise error
+        else:
+            raise TypeError(
+                "``groupname`` must be of type ``str`` or ``None`` but received type ``{0}``".format(
+                    type(groupname).__name__
+                )
             )
-        if data_dict["ploidy"] is not None:
-            data_dict["ploidy"] = int(data_dict["ploidy"])      # convert to int, from numpy.int64
-        ######################################################### create object
-        gmat = cls(**data_dict)                                 # create object from read data
-        return gmat
+
+        ########################################################
+        ######## check that we have all required fields ########
+
+        # all required arguments
+        required_fields = ["mat"]
+
+        # for each required field, check if the field exists in the HDF5 file.
+        for field in required_fields:
+            check_h5py_File_has_group(h5file, groupname + field)
+        
+        ########################################################
+        ### read data from HDF5 file and (optionally) close ####
+        
+        # output dictionary
+        data = {
+            "mat"               : None,
+            "taxa"              : None,
+            "taxa_grp"          : None,
+            "vrnt_chrgrp"       : None,
+            "vrnt_phypos"       : None,
+            "vrnt_name"         : None,
+            "vrnt_genpos"       : None,
+            "vrnt_xoprob"       : None,
+            "vrnt_hapgrp"       : None,
+            "vrnt_hapalt"       : None,
+            "vrnt_hapref"       : None,
+            "vrnt_mask"         : None,
+            "ploidy"            : None,
+            # metadata
+            "taxa_grp_name"     : None,
+            "taxa_grp_stix"     : None,
+            "taxa_grp_spix"     : None,
+            "taxa_grp_len"      : None,
+            "vrnt_chrgrp_name"  : None,
+            "vrnt_chrgrp_stix"  : None,
+            "vrnt_chrgrp_spix"  : None,
+            "vrnt_chrgrp_len"   : None,
+        }
+
+        ##################################
+        ### read mandatory data fields ###
+
+        # read mat array (ndarray dtype = int8)
+        data["mat"] = h5py_File_read_ndarray_int8(h5file, groupname + "mat")
+        
+        #################################
+        ### read optional data fields ###
+
+        # read taxa array (ndarray dtype = unicode / object)
+        if groupname + "taxa" in h5file:
+            data["taxa"] = h5py_File_read_ndarray_utf8(h5file, groupname + "taxa")
+
+        # read taxa_grp array (ndarray dtype = any)
+        if groupname + "taxa_grp" in h5file:
+            data["taxa_grp"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp")
+        
+        # read vrnt_chrgrp array (ndarray dtype = any)
+        if groupname + "vrnt_chrgrp" in h5file:
+            data["vrnt_chrgrp"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_chrgrp")
+
+        # read vrnt_phypos array (ndarray dtype = any)
+        if groupname + "vrnt_phypos" in h5file:
+            data["vrnt_phypos"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_phypos")
+
+        # read vrnt_name array (ndarray dtype = unicode / object)
+        if groupname + "vrnt_name" in h5file:
+            data["vrnt_name"] = h5py_File_read_ndarray_utf8(h5file, groupname + "vrnt_name")
+
+        # read vrnt_genpos array (ndarray dtype = any)
+        if groupname + "vrnt_genpos" in h5file:
+            data["vrnt_genpos"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_genpos")
+
+        # read vrnt_xoprob array (ndarray dtype = any)
+        if groupname + "vrnt_xoprob" in h5file:
+            data["vrnt_xoprob"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_xoprob")
+
+        # read vrnt_hapgrp array (ndarray dtype = any)
+        if groupname + "vrnt_hapgrp" in h5file:
+            data["vrnt_hapgrp"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_hapgrp")
+
+        # read vrnt_hapalt array (ndarray dtype = unicode / object)
+        if groupname + "vrnt_hapalt" in h5file:
+            data["vrnt_hapalt"] = h5py_File_read_ndarray_utf8(h5file, groupname + "vrnt_hapalt")
+
+        # read vrnt_hapref array (ndarray dtype = unicode / object)
+        if groupname + "vrnt_hapref" in h5file:
+            data["vrnt_hapref"] = h5py_File_read_ndarray_utf8(h5file, groupname + "vrnt_hapref")
+
+        # read vrnt_mask array (ndarray dtype = any)
+        if groupname + "vrnt_mask" in h5file:
+            data["vrnt_mask"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_mask")
+
+        # read ploidy (dtype = int)
+        if groupname + "ploidy" in h5file:
+            data["ploidy"] = h5py_File_read_int(h5file, groupname + "ploidy")
+
+        #####################################
+        ### read optional metadata fields ###
+
+        # read taxa_grp_name array (ndarray dtype = any)
+        if groupname + "taxa_grp_name" in h5file:
+            data["taxa_grp_name"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_name")
+
+        # read taxa_grp_stix array (ndarray dtype = any)
+        if groupname + "taxa_grp_stix" in h5file:
+            data["taxa_grp_stix"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_stix")
+
+        # read taxa_grp_spix array (ndarray dtype = any)
+        if groupname + "taxa_grp_spix" in h5file:
+            data["taxa_grp_spix"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_spix")
+
+        # read taxa_grp_len array (ndarray dtype = any)
+        if groupname + "taxa_grp_len" in h5file:
+            data["taxa_grp_len"] = h5py_File_read_ndarray(h5file, groupname + "taxa_grp_len")
+
+        # read vrnt_chrgrp_name array (ndarray dtype = any)
+        if groupname + "vrnt_chrgrp_name" in h5file:
+            data["vrnt_chrgrp_name"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_chrgrp_name")
+
+        # read vrnt_chrgrp_stix array (ndarray dtype = any)
+        if groupname + "vrnt_chrgrp_stix" in h5file:
+            data["vrnt_chrgrp_stix"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_chrgrp_stix")
+
+        # read vrnt_chrgrp_spix array (ndarray dtype = any)
+        if groupname + "vrnt_chrgrp_spix" in h5file:
+            data["vrnt_chrgrp_spix"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_chrgrp_spix")
+
+        # read vrnt_chrgrp_len array (ndarray dtype = any)
+        if groupname + "vrnt_chrgrp_len" in h5file:
+            data["vrnt_chrgrp_len"] = h5py_File_read_ndarray(h5file, groupname + "vrnt_chrgrp_len")
+
+        ######################
+        ### close the file ###
+
+        # close the file, only if the provided fieldname was a string or Path an not an h5py.File.
+        if isinstance(filename, (str,Path)):
+            h5file.close()
+
+        ########################################################
+        ################### Object creation ####################
+        
+        # create object from read data
+        out = cls(
+            mat         = data["mat"],
+            taxa        = data["taxa"],
+            taxa_grp    = data["taxa_grp"],
+            vrnt_chrgrp = data["vrnt_chrgrp"],
+            vrnt_phypos = data["vrnt_phypos"],
+            vrnt_name   = data["vrnt_name"],
+            vrnt_genpos = data["vrnt_genpos"],
+            vrnt_xoprob = data["vrnt_xoprob"],
+            vrnt_hapgrp = data["vrnt_hapgrp"],
+            vrnt_hapalt = data["vrnt_hapalt"],
+            vrnt_hapref = data["vrnt_hapref"],
+            vrnt_mask   = data["vrnt_mask"], 
+            ploidy      = data["ploidy"],
+        )
+
+        # copy metadata
+        out.taxa_grp_name    = data["taxa_grp_name"]
+        out.taxa_grp_stix    = data["taxa_grp_stix"]
+        out.taxa_grp_spix    = data["taxa_grp_spix"]
+        out.taxa_grp_len     = data["taxa_grp_len"]
+        out.vrnt_chrgrp_name = data["vrnt_chrgrp_name"]
+        out.vrnt_chrgrp_stix = data["vrnt_chrgrp_stix"]
+        out.vrnt_chrgrp_spix = data["vrnt_chrgrp_spix"]
+        out.vrnt_chrgrp_len  = data["vrnt_chrgrp_len"]
+
+        return out
 
     @classmethod
     def from_vcf(
             cls, 
             filename: str,
             auto_group_vrnt: bool = True
         ) -> 'DenseGenotypeMatrix':
```

### Comparing `pybrops-1.0.2/pybrops/popgen/gmat/DensePhasedGenotypeMatrix.py` & `pybrops-1.0.3/pybrops/popgen/gmat/DensePhasedGenotypeMatrix.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,25 @@
 """
 Module providing implementations of dense phased genotype matrices and
 associated error checking routines.
 """
 
 import copy
 from numbers import Real
-from typing import Optional, Sequence, Union
-
+from pathlib import Path
+from typing import Optional
+from typing import Sequence
+from typing import Union
+import h5py
 import cyvcf2
 import numpy
-from numpy.typing import DTypeLike, ArrayLike
+from numpy.typing import DTypeLike
+from numpy.typing import ArrayLike
 
+from pybrops.core.error.error_io_python import check_file_exists
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_type_numpy import check_ndarray_dtype_is_int8
 from pybrops.core.error.error_type_numpy import check_is_ndarray
 from pybrops.core.error.error_value_numpy import check_ndarray_ndim
 from pybrops.core.mat.DensePhasedTaxaVariantMatrix import DensePhasedTaxaVariantMatrix
 from pybrops.core.mat.Matrix import Matrix
 from pybrops.popgen.gmat.DenseGenotypeMatrix import DenseGenotypeMatrix
@@ -722,15 +727,15 @@
         ) -> numpy.ndarray:
         """
         Allele count of the non-zero allele within each taxon.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the accumulator and returned array.
+            The data type of the accumulator and returned array.
             If ``None``, use the native accumulator type (int or float).
 
         Returns
         -------
         out : numpy.ndarray
             A numpy.ndarray of shape ``(n,p)`` containing allele counts of the
             allele coded as ``1`` for all ``n`` individuals, for all ``p`` loci.
@@ -756,15 +761,16 @@
         ) -> numpy.ndarray:
         """
         Allele frequency of the non-zero allele within each taxon.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
             A numpy.ndarray of shape ``(n,p)`` containing allele frequencies of
             the allele coded as ``1`` for all ``n`` individuals, for all ``p``
             loci.
@@ -783,15 +789,16 @@
         ) -> numpy.ndarray:
         """
         Allele count of the non-zero allele across all taxa.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
             A numpy.ndarray of shape ``(p,)`` containing allele counts of the
             allele coded as ``1`` for all ``p`` loci.
         """
@@ -808,15 +815,16 @@
         ) -> numpy.ndarray:
         """
         Allele frequency of the non-zero allele across all taxa.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
             A numpy.ndarray of shape ``(p,)`` containing allele frequencies of
             the allele coded as ``1`` for all ``p`` loci.
         """
@@ -834,15 +842,16 @@
         ) -> numpy.ndarray:
         """
         Allele polymorphism presence or absense across all loci.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
             A numpy.ndarray of shape ``(p,)`` containing indicator variables for
             whether the locus is polymorphic.
         """
@@ -869,15 +878,16 @@
         ) -> numpy.ndarray:
         """
         Minor allele frequency across all taxa.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
             A numpy.ndarray of shape ``(p,)`` containing allele frequencies for
             the minor allele.
         """
@@ -892,15 +902,16 @@
         ) -> Real:
         """
         Mean expected heterozygosity across all taxa.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : Real
             A number representing the mean expected heterozygous.
             If ``dtype`` is ``None``, then a native 64-bit floating point is
             returned. Otherwise, of type specified by ``dtype``.
@@ -921,15 +932,16 @@
         """
         Gather genotype counts for homozygous major, heterozygous, homozygous
         minor for all individuals.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
             An ``int64`` array of shape ``(g,p)`` containing allele counts across
             all ``p`` loci for each of ``g`` genotype combinations.
 
@@ -996,27 +1008,28 @@
 
     ############################## Class Methods ###############################
 
     ################### Matrix File I/O ####################
     @classmethod
     def from_hdf5(
             cls, 
-            filename: str, 
+            filename: Union[str,Path,h5py.File], 
             groupname: Optional[str] = None
         ) -> 'DensePhasedGenotypeMatrix':
         """
         Read a DensePhasedGenotypeMatrix from an HDF5 file.
 
         Parameters
         ----------
-        filename : str
-            HDF5 file name which to read.
-        groupname : str or None
-            HDF5 group name under which GenotypeMatrix data is stored.
-            If None, GenotypeMatrix is read from base HDF5 group.
+        filename : str, Path, h5py.File
+            If ``str`` or ``Path``, an HDF5 file name from which to read. File is closed after reading.
+            If ``h5py.File``, an opened HDF5 file from which to read. File is not closed after reading.
+        groupname : str, None
+            If ``str``, HDF5 group name under which GenotypeMatrix data is stored.
+            If ``None``, GenotypeMatrix is read from base HDF5 group.
 
         Returns
         -------
         gmat : DensePhasedGenotypeMatrix
             A genotype matrix read from file.
         """
         return super(DensePhasedGenotypeMatrix, cls).from_hdf5(
@@ -1027,16 +1040,33 @@
     @classmethod
     def from_vcf(
             cls, 
             filename: str,
             auto_group_vrnt: bool = True
         ) -> 'DensePhasedGenotypeMatrix':
         """
-        Does not ensure that data is phased, just reads it as phased.
+        Read a ``DensePhasedGenotypeMatrix`` from a VCF file. This classmethod 
+        treats the VCF file as if it has been phased. It does not check if 
+        this assumption is correct.
+
+        Parameters
+        ----------
+        filename : str
+            Path to a VCF file.
+        auto_group_vrnt : bool
+            Whether to automatically group variants into chromosome groupings.
+        
+        Returns
+        -------
+        out : DensePhasedGenotypeMatrix
+            A ``DensePhasedGenotypeMatrix`` read from the VCF file.
         """
+        # check that the file exists
+        check_file_exists(filename)
+
         # make VCF iterator
         vcf = cyvcf2.VCF(filename)
 
         # extract taxa names from vcf header
         taxa = numpy.array(vcf.samples, dtype = object)
 
         # make empty lists to store extracted values
```

### Comparing `pybrops-1.0.2/pybrops/popgen/gmat/GenotypeMatrix.py` & `pybrops-1.0.3/pybrops/popgen/gmat/GenotypeMatrix.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,22 +1,28 @@
 """
 Module defining basal matrix interfaces and associated error checking routines
 for genotype matrices.
 """
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from numbers import Real
 import numpy
 from numpy.typing import DTypeLike
 from typing import Optional
 from pybrops.core.io.HDF5InputOutput import HDF5InputOutput
 from pybrops.core.mat.TaxaVariantMatrix import TaxaVariantMatrix
 from pybrops.popgen.gmap.GeneticMappableMatrix import GeneticMappableMatrix
 
-class GenotypeMatrix(TaxaVariantMatrix,GeneticMappableMatrix,HDF5InputOutput,metaclass=ABCMeta):
+class GenotypeMatrix(
+        TaxaVariantMatrix,
+        GeneticMappableMatrix,
+        HDF5InputOutput,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for genoypte matrix objects.
 
     The purpose of this abstract class is to define base functionality for:
         1) Genotype matrix ploidy and phase metadata.
         2) Genotype matrix format conversion.
         3) Genotype matrix allele counting routines.
@@ -66,20 +72,20 @@
     ################## Matrix conversion ###################
     @abstractmethod
     def mat_asformat(
             self, 
             format: str
         ) -> numpy.ndarray:
         """
-        Get mat in a specific format type.
+        Get the genotype matrix in a specific format type.
 
         Parameters
         ----------
         format : str
-            Desired output format. Options are "{0,1,2}", "{-1,0,1}", "{-1,m,1}".
+            Desired output format. Options are ``"{0,1,2}"``, ``"{-1,0,1}"``, ``"{-1,m,1}"``.
 
         Returns
         -------
         out : numpy.ndarray
             Matrix in the desired output format.
         """
         raise NotImplementedError("method is abstract")
@@ -92,37 +98,43 @@
         ) -> numpy.ndarray:
         """
         Allele count of the non-zero allele within each taxon.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the accumulator and returned array.
+            The data type of the accumulator and returned array.
             If ``None``, use the native accumulator type (int or float).
 
         Returns
         -------
         out : numpy.ndarray
             A numpy.ndarray of shape ``(n,p)`` containing allele counts of the
             allele coded as ``1`` for all ``n`` individuals, for all ``p`` loci.
+
+            Where:
+
+            - ``n`` is the number of taxa (individuals).
+            - ``p`` is the number of variants (loci).
         """
         raise NotImplementedError("method is abstract")
 
     @abstractmethod
     def tafreq(
             self, 
             dtype: Optional[DTypeLike]
         ) -> numpy.ndarray:
         """
         Allele frequency of the non-zero allele within each taxon.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
             A numpy.ndarray of shape ``(n,p)`` containing allele frequencies of
             the allele coded as ``1`` for all ``n`` individuals, for all ``p``
             loci.
@@ -136,15 +148,16 @@
         ) -> numpy.ndarray:
         """
         Allele count of the non-zero allele across all taxa.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
             A numpy.ndarray of shape ``(p,)`` containing allele counts of the
             allele coded as ``1`` for all ``p`` loci.
         """
@@ -157,36 +170,60 @@
         ) -> numpy.ndarray:
         """
         Allele frequency of the non-zero allele across all taxa.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
             A numpy.ndarray of shape ``(p,)`` containing allele frequencies of
             the allele coded as ``1`` for all ``p`` loci.
         """
         raise NotImplementedError("method is abstract")
 
     @abstractmethod
+    def afixed(
+            self,
+            dtype: Optional[DTypeLike],
+        ) -> numpy.ndarray:
+        """
+        Determine allele fixation for loci across all taxa.
+
+        Parameters
+        ----------
+        dtype : dtype, None
+            The data type of the returned array. 
+            If ``None``, use the native type.
+        
+        Returns
+        -------
+        out : numpy.ndarray
+            A ``numpy.ndarray`` of shape ``(p,)`` containing indicator variables 
+            for whether a locus is fixed at a particular locus.
+        """
+        raise NotImplementedError("method is abstract")
+
+    @abstractmethod
     def apoly(
             self, 
             dtype: Optional[DTypeLike]
         ) -> numpy.ndarray:
         """
         Allele polymorphism presence or absense across all loci.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
             A numpy.ndarray of shape ``(p,)`` containing indicator variables for
             whether the locus is polymorphic.
         """
@@ -199,15 +236,16 @@
         ) -> numpy.ndarray:
         """
         Minor allele frequency across all taxa.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
             A numpy.ndarray of shape ``(p,)`` containing allele frequencies for
             the minor allele.
         """
@@ -220,15 +258,16 @@
         ) -> Real:
         """
         Mean expected heterozygosity across all taxa.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : Real
             A number representing the mean expected heterozygous.
             If ``dtype`` is ``None``, then a native 64-bit floating point is
             returned. Otherwise, of type specified by ``dtype``.
@@ -243,15 +282,16 @@
         """
         Gather genotype counts for homozygous major, heterozygous, homozygous
         minor for all individuals.
 
         Parameters
         ----------
         dtype : dtype, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
             A numpy.ndarray array of shape ``(g,p)`` containing allele counts
             across all ``p`` loci for each of ``g`` genotype combinations.
 
@@ -273,15 +313,16 @@
         """
         Gather genotype frequencies for homozygous major, heterozygous,
         homozygous minor across all individuals.
 
         Parameters
         ----------
         dtype : DTypeLike, None
-            The dtype of the returned array. If ``None``, use the native type.
+            The data type of the returned array. 
+            If ``None``, use the native type.
 
         Returns
         -------
         out : numpy.ndarray
             A numpy.ndarray array of shape ``(g,p)`` containing haplotype counts
             across all ``p`` loci for all ``g`` genotype combinations.
```

### Comparing `pybrops-1.0.2/pybrops/popgen/gmat/HaplotypeMatrix.py` & `pybrops-1.0.3/pybrops/popgen/gmat/HaplotypeMatrix.py`

 * *Files 1% similar despite different names*

```diff
@@ -4,23 +4,28 @@
 """
 
 __all__ = [
     "HaplotypeMatrix",
     "check_is_HaplotypeMatrix",
 ]
 
-from abc import ABCMeta, abstractmethod
+from abc import ABCMeta
+from abc import abstractmethod
 from numbers import Real
 from typing import Optional
 import numpy
 from numpy.typing import DTypeLike
 from pybrops.core.io.HDF5InputOutput import HDF5InputOutput
 from pybrops.core.mat.TaxaVariantMatrix import TaxaVariantMatrix
 
-class HaplotypeMatrix(TaxaVariantMatrix,HDF5InputOutput,metaclass=ABCMeta):
+class HaplotypeMatrix(
+        TaxaVariantMatrix,
+        HDF5InputOutput,
+        metaclass = ABCMeta,
+    ):
     """
     An abstract class for haplotype matrix objects.
 
     The purpose of this abstract class is to proved base functionality for:
         1) haplotype metadata manipulation routines.
         2) haplotype math functions.
     """
```

### Comparing `pybrops-1.0.2/pybrops/popgen/gmat/PhasedGenotypeMatrix.py` & `pybrops-1.0.3/pybrops/popgen/gmat/PhasedHaplotypeMatrix.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,46 +1,45 @@
 """
 Module defining basal matrix interfaces and associated error checking routines
-for phased genotype matrices.
+for phased haplotype matrices.
 """
 
+__all__ = [
+    "PhasedHaplotypeMatrix",
+    "check_is_PhasedHaplotypeMatrix",
+]
+
 from abc import ABCMeta
 from pybrops.core.mat.PhasedTaxaVariantMatrix import PhasedTaxaVariantMatrix
-from pybrops.popgen.gmat.GenotypeMatrix import GenotypeMatrix
+from pybrops.popgen.gmat.HaplotypeMatrix import HaplotypeMatrix
 
-# NOTE: GenotypeMatrix MUST GO FIRST: causes method resolution error otherwise!
-# NOTE: this is because
-#       GenotypeMatrix extends TaxaVariantMatrix
-#       PhasedTaxaVariantMatrix extends TaxaVariantMatrix
-# I think a situation is caused where TaxaVariantMatrix is needed to be imported
-# before itself due to its ranking in the MRO algorithm for multiple inheritance
-class PhasedGenotypeMatrix(
-        GenotypeMatrix,
+class PhasedHaplotypeMatrix(
+        HaplotypeMatrix,
         PhasedTaxaVariantMatrix,
         metaclass = ABCMeta,
     ):
     """
     An abstract class for phased genoypte matrix objects.
 
     The purpose of this abstract class is to merge the following interfaces:
-        1) GenotypeMatrix
+        1) HaplotypeMatrix
         2) PhasedTaxaVariantMatrix
     """
 
     ########################## Special Object Methods ##########################
 
 
 
 ################################## Utilities ###################################
-def check_is_PhasedGenotypeMatrix(v: object, vname: str) -> None:
+def check_is_PhasedHaplotypeMatrix(v: object, vname: str) -> None:
     """
-    Check if object is of type ``PhasedGenotypeMatrix``. Otherwise raise ``TypeError``.
+    Check if object is of type ``PhasedHaplotypeMatrix``. Otherwise raise ``TypeError``.
 
     Parameters
     ----------
     v : object
         Any Python object to test.
     vname : str
         Name of variable to print in ``TypeError`` message.
     """
-    if not isinstance(v, PhasedGenotypeMatrix):
-        raise TypeError("'%s' must be a PhasedGenotypeMatrix." % vname)
+    if not isinstance(v, PhasedHaplotypeMatrix):
+        raise TypeError("'%s' must be a PhasedHaplotypeMatrix." % vname)
```

### Comparing `pybrops-1.0.2/pybrops/popgen/gmat/__init__.py` & `pybrops-1.0.3/pybrops/popgen/gmat/__init__.py`

 * *Files identical despite different names*

### Comparing `pybrops-1.0.2/pybrops/test/assert_python.py` & `pybrops-1.0.3/pybrops/test/assert_python.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 from abc import ABCMeta
 import inspect
 import re
-from typing import Callable, Generator
+from typing import Callable, Generator, Optional, Tuple
 from contextlib import contextmanager
 
 @contextmanager
-def raises(*ExpectedExceptions: tuple[Exception]) -> Generator:
+def raises(*ExpectedExceptions: Tuple[Exception,...]) -> Generator:
     """
     Ensure that a function raises an expected exception or one of an expected 
     set of exceptions.
     
     Parameters
     ----------
     ExpectedExceptions : tuple
@@ -917,14 +917,15 @@
 def assert_module_documentation(obj: object) -> None:
     """
     Test a module for complete documentation.
 
     Parameters
     ----------
     obj : object
+        Input module.
     """
     # assert that the object is a class
     if not inspect.ismodule(obj):
         raise AssertionError("type ``{0}`` is not a module".format(obj.__name__))
 
     # make sure we have a docstring attribute
     if not hasattr(obj, "__doc__") or obj.__doc__ is None:
@@ -933,7 +934,58 @@
     # make sure our docstring is a string
     if not isinstance(obj.__doc__, str):
         raise AssertionError("in module ``{0}``: docstring is not a string".format(obj.__name__))
 
     # make sure our docstring length is greater than zero
     if len(obj.__doc__) <= 0:
         raise AssertionError("in module ``{0}``: docstring is empty".format(obj.__name__))
+
+def assert_module_public_api(obj: object, exclude: Optional[list] = None) -> None:
+    """
+    Test a module for a public API.
+
+    Parameters
+    ----------
+    obj : object
+        Input module.
+    """
+    # assert that the object is a class
+    if not inspect.ismodule(obj):
+        raise AssertionError("type ``{0}`` is not a module".format(obj.__name__))
+
+    # make sure we have a public API (__all__) attribute
+    if not hasattr(obj, "__all__") or obj.__all__ is None:
+        raise AssertionError("in module ``{0}``: public API (``__all__``) is not present".format(obj.__name__))
+
+    # make sure our public API is a list
+    if not isinstance(obj.__all__, list):
+        raise AssertionError("in module ``{0}``: public API (``__all__``) is not a list".format(obj.__name__))
+
+    # get public function members defined within the module itself (not imported)
+    fnmbrs = [m for m in inspect.getmembers(obj, inspect.isfunction) if m[0][0] != "_" and inspect.getmodule(m[1]) == obj]
+    
+    # make sure all public function members are within the public API
+    if exclude is None:
+        for fnmbr in fnmbrs:
+            if fnmbr[0] not in obj.__all__:
+                raise AssertionError("in module ``{0}``: function ``{1}`` not in public API (``__all__``)".format(obj.__name__,fnmbr[0]))
+    else:
+        for fnmbr in fnmbrs:
+            if fnmbr[0] in exclude:
+                continue
+            if fnmbr[0] not in obj.__all__:
+                raise AssertionError("in module ``{0}``: function ``{1}`` not in public API (``__all__``)".format(obj.__name__,fnmbr[0]))
+
+    # get public class members defined within the the module itself (not imported)
+    clsmbrs = [m for m in inspect.getmembers(obj, inspect.isclass) if m[0][0] != "_" and inspect.getmodule(m[1]) == obj]
+
+    # make sure all public function members are within the public API
+    if exclude is None:
+        for clsmbr in clsmbrs:
+            if clsmbr[0] not in obj.__all__:
+                raise AssertionError("in module ``{0}``: class ``{1}`` not in public API (``__all__``)".format(obj.__name__,clsmbr[0]))
+    else:
+        for clsmbr in clsmbrs:
+            if clsmbr[0] in exclude:
+                continue
+            if clsmbr[0] not in obj.__all__:
+                raise AssertionError("in module ``{0}``: class ``{1}`` not in public API (``__all__``)".format(obj.__name__,clsmbr[0]))
```

### Comparing `pybrops-1.0.2/pybrops.egg-info/PKG-INFO` & `pybrops-1.0.3/pybrops.egg-info/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pybrops
-Version: 1.0.2
+Version: 1.0.3
 Summary: Python package for breeding program numerical optimization and simulation
 Home-page: https://github.com/rzshrote/pybrops
 Author: Robert Z. Shrote
 Author-email: shrotero@msu.edu
 License: Apache License 2.0
 Project-URL: Bug Tracker, https://github.com/rzshrote/pybrops/issues
 Classifier: Programming Language :: Python :: 3
```

### Comparing `pybrops-1.0.2/pybrops.egg-info/SOURCES.txt` & `pybrops-1.0.3/pybrops.egg-info/SOURCES.txt`

 * *Files 5% similar despite different names*

```diff
@@ -27,14 +27,16 @@
 ./pybrops/breed/op/ssel/SurvivorSelectionOperator.py
 ./pybrops/breed/op/ssel/__init__.py
 ./pybrops/breed/prot/__init__.py
 ./pybrops/breed/prot/bv/BreedingValueProtocol.py
 ./pybrops/breed/prot/bv/MeanPhenotypicBreedingValue.py
 ./pybrops/breed/prot/bv/TrueBreedingValue.py
 ./pybrops/breed/prot/bv/__init__.py
+./pybrops/breed/prot/gt/DenseMaskedPhasedGenotyping.py
+./pybrops/breed/prot/gt/DenseMaskedUnphasedGenotyping.py
 ./pybrops/breed/prot/gt/DenseUnphasedGenotyping.py
 ./pybrops/breed/prot/gt/GenotypingProtocol.py
 ./pybrops/breed/prot/gt/__init__.py
 ./pybrops/breed/prot/mate/FourWayCross.py
 ./pybrops/breed/prot/mate/FourWayDHCross.py
 ./pybrops/breed/prot/mate/MatingProtocol.py
 ./pybrops/breed/prot/mate/SelfCross.py
@@ -63,24 +65,24 @@
 ./pybrops/breed/prot/sel/MateSelectionProtocol.py
 ./pybrops/breed/prot/sel/MeanExpectedHeterozygositySelection.py
 ./pybrops/breed/prot/sel/MeanGenomicRelationshipSelection.py
 ./pybrops/breed/prot/sel/MultiObjectiveGenomicSelection.py
 ./pybrops/breed/prot/sel/OptimalContributionSelection.py
 ./pybrops/breed/prot/sel/OptimalHaploidValueSelection.py
 ./pybrops/breed/prot/sel/OptimalPopulationValueSelection.py
+./pybrops/breed/prot/sel/PopulationAlleleFrequencyDistanceSelection.py
+./pybrops/breed/prot/sel/PopulationAlleleUnavailabilitySelection.py
 ./pybrops/breed/prot/sel/RandomSelection.py
 ./pybrops/breed/prot/sel/RealMateSelectionProtocol.py
 ./pybrops/breed/prot/sel/RealSelectionProtocol.py
 ./pybrops/breed/prot/sel/SelectionProtocol.py
 ./pybrops/breed/prot/sel/SubsetMateSelectionProtocol.py
 ./pybrops/breed/prot/sel/SubsetSelectionProtocol.py
 ./pybrops/breed/prot/sel/UnconstrainedGeneralized1NormGenomicSelection.py
 ./pybrops/breed/prot/sel/UnconstrainedMultiObjectiveGenomicMating.py
-./pybrops/breed/prot/sel/UnconstrainedPopulationAlleleFrequencyDistanceSelection.py
-./pybrops/breed/prot/sel/UnconstrainedPopulationAlleleUnavailabilitySelection.py
 ./pybrops/breed/prot/sel/UnconstrainedSelectionProtocol.py
 ./pybrops/breed/prot/sel/UsefulnessCriterionSelection.py
 ./pybrops/breed/prot/sel/WeightedGenomicSelection.py
 ./pybrops/breed/prot/sel/__init__.py
 ./pybrops/breed/prot/sel/targetfn.py
 ./pybrops/breed/prot/sel/transfn.py
 ./pybrops/breed/prot/sel/weightfn.py
@@ -114,14 +116,16 @@
 ./pybrops/breed/prot/sel/prob/MeanExpectedHeterozygositySelectionProblem.py
 ./pybrops/breed/prot/sel/prob/MeanGenomicRelationshipSelectionProblem.py
 ./pybrops/breed/prot/sel/prob/MultiObjectiveGenomicMatingProblem.py
 ./pybrops/breed/prot/sel/prob/MultiObjectiveGenomicSelectionProblem.py
 ./pybrops/breed/prot/sel/prob/OptimalContributionSelectionProblem.py
 ./pybrops/breed/prot/sel/prob/OptimalHaploidValueSelectionProblem.py
 ./pybrops/breed/prot/sel/prob/OptimalPopulationValueSelectionProblem.py
+./pybrops/breed/prot/sel/prob/PopulationAlleleFrequencyDistanceSelectionProblem.py
+./pybrops/breed/prot/sel/prob/PopulationAlleleUnavailabilitySelectionProblem.py
 ./pybrops/breed/prot/sel/prob/RandomSelectionProblem.py
 ./pybrops/breed/prot/sel/prob/RealLookAheadGeneralizedWeightedGenomicSelectionProblem.py
 ./pybrops/breed/prot/sel/prob/RealMateSelectionProblem.py
 ./pybrops/breed/prot/sel/prob/RealSelectionProblem.py
 ./pybrops/breed/prot/sel/prob/SelectionProblem.py
 ./pybrops/breed/prot/sel/prob/SubsetMateSelectionProblem.py
 ./pybrops/breed/prot/sel/prob/SubsetSelectionProblem.py
@@ -152,26 +156,30 @@
 ./pybrops/core/error/error_type_python.py
 ./pybrops/core/error/error_value_h5py.py
 ./pybrops/core/error/error_value_numpy.py
 ./pybrops/core/error/error_value_pandas.py
 ./pybrops/core/error/error_value_python.py
 ./pybrops/core/io/CSVDictInputOutput.py
 ./pybrops/core/io/CSVInputOutput.py
+./pybrops/core/io/Copyable.py
 ./pybrops/core/io/DictInputOutput.py
 ./pybrops/core/io/HDF5InputOutput.py
 ./pybrops/core/io/NPYInputOutput.py
 ./pybrops/core/io/NPZInputOutput.py
 ./pybrops/core/io/NumPyInputOutput.py
 ./pybrops/core/io/PandasDictInputOutput.py
 ./pybrops/core/io/PandasInputOutput.py
 ./pybrops/core/io/__init__.py
 ./pybrops/core/mat/DenseMatrix.py
 ./pybrops/core/mat/DenseMutableMatrix.py
 ./pybrops/core/mat/DensePhasedMatrix.py
 ./pybrops/core/mat/DensePhasedTaxaVariantMatrix.py
+./pybrops/core/mat/DenseScaledMatrix.py
+./pybrops/core/mat/DenseScaledSquareTaxaTraitMatrix.py
+./pybrops/core/mat/DenseSquare2TaxaTraitMatrix.py
 ./pybrops/core/mat/DenseSquareMatrix.py
 ./pybrops/core/mat/DenseSquareTaxaMatrix.py
 ./pybrops/core/mat/DenseSquareTaxaSquareTraitMatrix.py
 ./pybrops/core/mat/DenseSquareTaxaTraitMatrix.py
 ./pybrops/core/mat/DenseSquareTraitMatrix.py
 ./pybrops/core/mat/DenseTaxaMatrix.py
 ./pybrops/core/mat/DenseTaxaTraitMatrix.py
@@ -180,38 +188,44 @@
 ./pybrops/core/mat/DenseVariantMatrix.py
 ./pybrops/core/mat/GroupableMatrix.py
 ./pybrops/core/mat/Matrix.py
 ./pybrops/core/mat/MutableMatrix.py
 ./pybrops/core/mat/PhasedMatrix.py
 ./pybrops/core/mat/PhasedTaxaVariantMatrix.py
 ./pybrops/core/mat/PrunableMatrix.py
+./pybrops/core/mat/ScaledMatrix.py
+./pybrops/core/mat/ScaledSquareTaxaTraitMatrix.py
 ./pybrops/core/mat/SortableMatrix.py
 ./pybrops/core/mat/SquareMatrix.py
 ./pybrops/core/mat/SquareTaxaMatrix.py
 ./pybrops/core/mat/SquareTaxaSquareTraitMatrix.py
 ./pybrops/core/mat/SquareTaxaTraitMatrix.py
 ./pybrops/core/mat/SquareTraitMatrix.py
 ./pybrops/core/mat/TaxaMatrix.py
 ./pybrops/core/mat/TaxaTraitMatrix.py
 ./pybrops/core/mat/TaxaVariantMatrix.py
 ./pybrops/core/mat/TraitMatrix.py
 ./pybrops/core/mat/VariantMatrix.py
 ./pybrops/core/mat/__init__.py
-./pybrops/core/mat/util.py
 ./pybrops/core/random/__init__.py
 ./pybrops/core/random/prng.py
 ./pybrops/core/random/sampling.py
 ./pybrops/core/util/__init__.py
-./pybrops/core/util/arrayix.py
+./pybrops/core/util/array.py
 ./pybrops/core/util/h5py.py
 ./pybrops/core/util/haplo.py
 ./pybrops/core/util/iterator.py
+./pybrops/core/util/mate.py
 ./pybrops/core/util/pareto.py
 ./pybrops/core/util/subroutines.py
+./pybrops/core/util/trans.py
 ./pybrops/model/__init__.py
+./pybrops/model/embvmat/DenseExpectedMaximumBreedingValueMatrix.py
+./pybrops/model/embvmat/ExpectedMaximumBreedingValueMatrix.py
+./pybrops/model/embvmat/__init__.py
 ./pybrops/model/gmod/AdditiveDominanceEpistaticLinearGenomicModel.py
 ./pybrops/model/gmod/AdditiveDominanceLinearGenomicModel.py
 ./pybrops/model/gmod/AdditiveLinearGenomicModel.py
 ./pybrops/model/gmod/CoancestryLinearGenomicModel.py
 ./pybrops/model/gmod/DenseAdditiveDominanceLinearGenomicModel.py
 ./pybrops/model/gmod/DenseAdditiveLinearGenomicModel.py
 ./pybrops/model/gmod/DenseLinearGenomicModel.py
@@ -233,14 +247,17 @@
 ./pybrops/model/pcvmat/DenseThreeWayDHAdditiveProgenyGeneticCovarianceMatrix.py
 ./pybrops/model/pcvmat/DenseThreeWayDHAdditiveProgenyGenicCovarianceMatrix.py
 ./pybrops/model/pcvmat/DenseTwoWayDHAdditiveProgenyGeneticCovarianceMatrix.py
 ./pybrops/model/pcvmat/DenseTwoWayDHAdditiveProgenyGenicCovarianceMatrix.py
 ./pybrops/model/pcvmat/ProgenyGeneticCovarianceMatrix.py
 ./pybrops/model/pcvmat/ProgenyGenicCovarianceMatrix.py
 ./pybrops/model/pcvmat/__init__.py
+./pybrops/model/pmebvmat/DenseTwoWayProgenyMeanEstimatedBreedingValueMatrix.py
+./pybrops/model/pmebvmat/ProgenyMeanEstimatedBreedingValueMatrix.py
+./pybrops/model/pmebvmat/__init__.py
 ./pybrops/model/vmat/AdditiveGeneticVarianceMatrix.py
 ./pybrops/model/vmat/AdditiveGenicVarianceMatrix.py
 ./pybrops/model/vmat/DenseAdditiveGeneticVarianceMatrix.py
 ./pybrops/model/vmat/DenseAdditiveGenicVarianceMatrix.py
 ./pybrops/model/vmat/DenseDihybridDHAdditiveGeneticVarianceMatrix.py
 ./pybrops/model/vmat/DenseDihybridDHAdditiveGenicVarianceMatrix.py
 ./pybrops/model/vmat/DenseFourWayDHAdditiveGeneticVarianceMatrix.py
@@ -261,14 +278,17 @@
 ./pybrops/model/vmat/fcty/DenseFourWayDHAdditiveGeneticVarianceMatrixFactory.py
 ./pybrops/model/vmat/fcty/DenseThreeWayDHAdditiveGeneticVarianceMatrixFactory.py
 ./pybrops/model/vmat/fcty/DenseTwoWayDHAdditiveGeneticVarianceMatrixFactory.py
 ./pybrops/model/vmat/fcty/DenseTwoWayDHAdditiveGenicVarianceMatrixFactory.py
 ./pybrops/model/vmat/fcty/GeneticVarianceMatrixFactory.py
 ./pybrops/model/vmat/fcty/GenicVarianceMatrixFactory.py
 ./pybrops/model/vmat/fcty/__init__.py
+./pybrops/model/wgebvmat/DenseWeightedGenomicEstimatedBreedingValueMatrix.py
+./pybrops/model/wgebvmat/WeightedGenomicEstimatedBreedingValueMatrix.py
+./pybrops/model/wgebvmat/__init__.py
 ./pybrops/opt/__init__.py
 ./pybrops/opt/algo/BinaryGeneticAlgorithm.py
 ./pybrops/opt/algo/BinaryOptimizationAlgorithm.py
 ./pybrops/opt/algo/IntegerGeneticAlgorithm.py
 ./pybrops/opt/algo/IntegerOptimizationAlgorithm.py
 ./pybrops/opt/algo/NSGA2BinaryGeneticAlgorithm.py
 ./pybrops/opt/algo/NSGA2IntegerGeneticAlgorithm.py
```

### Comparing `pybrops-1.0.2/setup.py` & `pybrops-1.0.3/setup.py`

 * *Files 0% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 import setuptools
 
 # setup.py metadata
 setup_location = "." # pathlib.Path(__file__).parents[1]
 
 # package metadata: general descriptors
 pybrops_name = "pybrops"
-pybrops_version = "1.0.2"
+pybrops_version = "1.0.3"
 pybrops_author = "Robert Z. Shrote"
 pybrops_author_email = "shrotero@msu.edu"
 pybrops_description = "Python package for breeding program numerical optimization and simulation"
 with open("README.md", "r", encoding = "utf-8") as readme_file:
     pybrops_description_long = readme_file.read()
     pybrops_description_long_type = "text/markdown"
```

